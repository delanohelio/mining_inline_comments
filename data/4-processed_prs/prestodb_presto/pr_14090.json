{"pr_number": 14090, "pr_title": "Add IPPREFIX functions", "pr_createdAt": "2020-02-12T19:10:01Z", "pr_url": "https://github.com/prestodb/presto/pull/14090", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MDA1OA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379180058", "bodyText": "you can do IPADDRESS'192.168.255.255'.", "author": "rongrong", "createdAt": "2020-02-13T23:39:20Z", "path": "presto-docs/src/main/sphinx/functions/ip.rst", "diffHunk": "@@ -10,3 +10,42 @@ IP Functions\n         SELECT ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9); -- {192.128.0.0/9}\n         SELECT ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48); -- {2001:db8:85a3::/48}\n \n+.. function:: ip_subnet_min(ip_prefix) -> ip_address\n+\n+    Returns the first/smallest IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_min(ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9)); -- {192.128.0.0}", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MTUzMQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379181531", "bodyText": "Or just use IPPREFIX'192.168.255.255/9'", "author": "rongrong", "createdAt": "2020-02-13T23:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MDA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MTA0Mw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379181043", "bodyText": "Just use smallest. I'm not sure what does \"first\" mean here. Is the term used in IP subnet?", "author": "rongrong", "createdAt": "2020-02-13T23:41:52Z", "path": "presto-docs/src/main/sphinx/functions/ip.rst", "diffHunk": "@@ -10,3 +10,42 @@ IP Functions\n         SELECT ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9); -- {192.128.0.0/9}\n         SELECT ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48); -- {2001:db8:85a3::/48}\n \n+.. function:: ip_subnet_min(ip_prefix) -> ip_address\n+\n+    Returns the first/smallest IP address of type ``IPADDRESS`` in the subnet", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2OTA5Ng==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379569096", "bodyText": "I dont know either. Lets just go ahead with smallest.", "author": "NikhilCollooru", "createdAt": "2020-02-14T18:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MTA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MTE4Mw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379181183", "bodyText": "use \"largest\" corresponding to \"smallest\" in ip_subnet_min", "author": "rongrong", "createdAt": "2020-02-13T23:42:24Z", "path": "presto-docs/src/main/sphinx/functions/ip.rst", "diffHunk": "@@ -10,3 +10,42 @@ IP Functions\n         SELECT ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9); -- {192.128.0.0/9}\n         SELECT ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48); -- {2001:db8:85a3::/48}\n \n+.. function:: ip_subnet_min(ip_prefix) -> ip_address\n+\n+    Returns the first/smallest IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_min(ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9)); -- {192.128.0.0}\n+        SELECT ip_subnet_min(ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48)); -- {2001:db8:85a3::}\n+\n+.. function:: ip_subnet_max(ip_prefix) -> ip_address\n+\n+    Returns the last/maximum IP address of type ``IPADDRESS`` in the subnet", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MTk3OA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379181978", "bodyText": "use two different variable to the description is clearer. is_subnet_of(ip_prefix1, ip_prefix2) -> boolean", "author": "rongrong", "createdAt": "2020-02-13T23:45:12Z", "path": "presto-docs/src/main/sphinx/functions/ip.rst", "diffHunk": "@@ -10,3 +10,42 @@ IP Functions\n         SELECT ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9); -- {192.128.0.0/9}\n         SELECT ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48); -- {2001:db8:85a3::/48}\n \n+.. function:: ip_subnet_min(ip_prefix) -> ip_address\n+\n+    Returns the first/smallest IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_min(ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9)); -- {192.128.0.0}\n+        SELECT ip_subnet_min(ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48)); -- {2001:db8:85a3::}\n+\n+.. function:: ip_subnet_max(ip_prefix) -> ip_address\n+\n+    Returns the last/maximum IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_max(ip_prefix(CAST('192.64.0.0' AS IPADDRESS), 9)); -- {192.127.255.255}\n+        SELECT ip_subnet_max(ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48)); -- {2001:db8:85a3:ffff:ffff:ffff:ffff:ffff}\n+\n+.. function:: ip_subnet_range(ip_prefix) -> array(ip_address)\n+\n+    Returns an array of ``ip_address`` of size 2 and of type ``IPADDRESS``.\n+    It contains the first/smallest IP address and the last/maximum IP address\n+    of the subnet specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_range(ip_prefix('1.2.3.160', 24)); -- [{1.2.3.0}, {1.2.3.255}]\n+        SELECT ip_subnet_range(ip_prefix('64:ff9b::52f4', 120)); -- [{64:ff9b::5200}, {64:ff9b::52ff}]\n+\n+.. function:: is_subnet_of(ip_prefix, ip_address) -> boolean\n+\n+    Returns ``true`` if the ``ip_address`` lies within the subnet of ``ip_prefix``. ::\n+\n+        SELECT is_subnet_of(ip_prefix('1.2.3.128', 26), ipaddress '1.2.3.129'); -- true\n+        SELECT is_subnet_of(ip_prefix('64:fa9b::17', 64), ipaddress '64:ffff::17'); -- false\n+\n+.. function:: is_prefix_subnet_of(ip_prefix, ip_prefix) -> boolean", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MzM1MQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379183351", "bodyText": "I don't understand this description. The grammar doesn't compute to me... -_-", "author": "rongrong", "createdAt": "2020-02-13T23:49:34Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Last/Maximum subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = validateIpPrefixAndGetBytes(value);\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Range of IP address's in the subnet of the IP prefix\")", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2OTkzMA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379569930", "bodyText": "Changed it to\n\"Array of smallest and largest IP address in the subnet of the given IP prefix\"", "author": "NikhilCollooru", "createdAt": "2020-02-14T18:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MzM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4Mzc5NQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379183795", "bodyText": "You can annotate this with `@ScalarFunction(\"is_subnet_of\") so the name of the function is consistent with the other one.", "author": "rongrong", "createdAt": "2020-02-13T23:51:05Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Last/Maximum subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = validateIpPrefixAndGetBytes(value);\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Range of IP address's in the subnet of the IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        validateIpAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_prefix_subnet_of\")", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4NDYxNw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379184617", "bodyText": "You can just name the variable ipAddress. The function should be named toInetAddress.", "author": "rongrong", "createdAt": "2020-02-13T23:54:08Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Last/Maximum subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = validateIpPrefixAndGetBytes(value);\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Range of IP address's in the subnet of the IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        validateIpAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_prefix_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isPrefixSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPPREFIX) Slice right)\n+    {\n+        return between(ipSubnetMin(right), ipSubnetMin(left), ipSubnetMax(left)) && between(ipSubnetMax(right), ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    private static InetAddress validateIpAddress(Slice ipAddressSlice)", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4NTY4OA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379185688", "bodyText": "Maybe just \"Smallest IP address for a given IP prefix\"", "author": "rongrong", "createdAt": "2020-02-13T23:57:44Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTg3NA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379191874", "bodyText": "The value is validated 3 times in this function.", "author": "rongrong", "createdAt": "2020-02-14T00:19:48Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Last/Maximum subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = validateIpPrefixAndGetBytes(value);\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Range of IP address's in the subnet of the IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU3MDE5OA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379570198", "bodyText": "Removed the validation part. Since the IPREFIX input will always be valid.", "author": "NikhilCollooru", "createdAt": "2020-02-14T18:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MjAzNA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379192034", "bodyText": "The input has to be a valid ipprefix so you don't need to validate it.", "author": "rongrong", "createdAt": "2020-02-14T00:20:34Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "40fc1302ce768ee1a677f204e1f06552f309b487", "url": "https://github.com/prestodb/presto/commit/40fc1302ce768ee1a677f204e1f06552f309b487", "message": "Add IPPREFIX functions", "committedDate": "2020-02-14T18:06:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0NzMzMg==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380347332", "bodyText": "Double back quotes around ip_prefix2 and ip_prefix1", "author": "caithagoras", "createdAt": "2020-02-17T19:55:57Z", "path": "presto-docs/src/main/sphinx/functions/ip.rst", "diffHunk": "@@ -10,3 +10,42 @@ IP Functions\n         SELECT ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9); -- {192.128.0.0/9}\n         SELECT ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48); -- {2001:db8:85a3::/48}\n \n+.. function:: ip_subnet_min(ip_prefix) -> ip_address\n+\n+    Returns the smallest IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_min(IPPREFIX '192.168.255.255/9'); -- {192.128.0.0}\n+        SELECT ip_subnet_min(IPPREFIX '2001:0db8:85a3:0001:0001:8a2e:0370:7334/48'); -- {2001:db8:85a3::}\n+\n+.. function:: ip_subnet_max(ip_prefix) -> ip_address\n+\n+    Returns the largest IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_max(IPPREFIX '192.64.0.0/9'); -- {192.127.255.255}\n+        SELECT ip_subnet_max(IPPREFIX '2001:0db8:85a3:0001:0001:8a2e:0370:7334/48'); -- {2001:db8:85a3:ffff:ffff:ffff:ffff:ffff}\n+\n+.. function:: ip_subnet_range(ip_prefix) -> array(ip_address)\n+\n+    Returns an array of ``ip_address`` of size 2 and of type ``IPADDRESS``.\n+    It contains the smallest IP address and the largest IP address\n+    of the subnet specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_range(IPPREFIX '1.2.3.160/24'); -- [{1.2.3.0}, {1.2.3.255}]\n+        SELECT ip_subnet_range(IPPREFIX '64:ff9b::52f4/120'); -- [{64:ff9b::5200}, {64:ff9b::52ff}]\n+\n+.. function:: is_subnet_of(ip_prefix, ip_address) -> boolean\n+\n+    Returns ``true`` if the ``ip_address`` lies within the subnet of ``ip_prefix``. ::\n+\n+        SELECT is_subnet_of(IPPREFIX '1.2.3.128/26', IPADDRESS '1.2.3.129'); -- true\n+        SELECT is_subnet_of(IPPREFIX '64:fa9b::17/64', IPADDRESS '64:ffff::17'); -- false\n+\n+.. function:: is_subnet_of(ip_prefix1, ip_prefix2) -> boolean\n+\n+    Returns ``true`` if ip_prefix2 is a subnet of ip_prefix1. ::", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0NzU1NQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380347555", "bodyText": "\"lies within the subnet of\" -> \"is in the subnet of\"\nhttp://www.differencebetween.net/language/differences-between-in-and-within/", "author": "caithagoras", "createdAt": "2020-02-17T19:56:41Z", "path": "presto-docs/src/main/sphinx/functions/ip.rst", "diffHunk": "@@ -10,3 +10,42 @@ IP Functions\n         SELECT ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9); -- {192.128.0.0/9}\n         SELECT ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48); -- {2001:db8:85a3::/48}\n \n+.. function:: ip_subnet_min(ip_prefix) -> ip_address\n+\n+    Returns the smallest IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_min(IPPREFIX '192.168.255.255/9'); -- {192.128.0.0}\n+        SELECT ip_subnet_min(IPPREFIX '2001:0db8:85a3:0001:0001:8a2e:0370:7334/48'); -- {2001:db8:85a3::}\n+\n+.. function:: ip_subnet_max(ip_prefix) -> ip_address\n+\n+    Returns the largest IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_max(IPPREFIX '192.64.0.0/9'); -- {192.127.255.255}\n+        SELECT ip_subnet_max(IPPREFIX '2001:0db8:85a3:0001:0001:8a2e:0370:7334/48'); -- {2001:db8:85a3:ffff:ffff:ffff:ffff:ffff}\n+\n+.. function:: ip_subnet_range(ip_prefix) -> array(ip_address)\n+\n+    Returns an array of ``ip_address`` of size 2 and of type ``IPADDRESS``.\n+    It contains the smallest IP address and the largest IP address\n+    of the subnet specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_range(IPPREFIX '1.2.3.160/24'); -- [{1.2.3.0}, {1.2.3.255}]\n+        SELECT ip_subnet_range(IPPREFIX '64:ff9b::52f4/120'); -- [{64:ff9b::5200}, {64:ff9b::52ff}]\n+\n+.. function:: is_subnet_of(ip_prefix, ip_address) -> boolean\n+\n+    Returns ``true`` if the ``ip_address`` lies within the subnet of ``ip_prefix``. ::", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4NDg3OQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380384879", "bodyText": ":) good one.", "author": "NikhilCollooru", "createdAt": "2020-02-17T22:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0NzU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM0NzY5MQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380347691", "bodyText": "Return an array of 2 IP addresses.\nThe array contains the smallest and the largest IP address\nin the subnet specified by ``ip_prefix``.", "author": "caithagoras", "createdAt": "2020-02-17T19:57:13Z", "path": "presto-docs/src/main/sphinx/functions/ip.rst", "diffHunk": "@@ -10,3 +10,42 @@ IP Functions\n         SELECT ip_prefix(CAST('192.168.255.255' AS IPADDRESS), 9); -- {192.128.0.0/9}\n         SELECT ip_prefix('2001:0db8:85a3:0001:0001:8a2e:0370:7334', 48); -- {2001:db8:85a3::/48}\n \n+.. function:: ip_subnet_min(ip_prefix) -> ip_address\n+\n+    Returns the smallest IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_min(IPPREFIX '192.168.255.255/9'); -- {192.128.0.0}\n+        SELECT ip_subnet_min(IPPREFIX '2001:0db8:85a3:0001:0001:8a2e:0370:7334/48'); -- {2001:db8:85a3::}\n+\n+.. function:: ip_subnet_max(ip_prefix) -> ip_address\n+\n+    Returns the largest IP address of type ``IPADDRESS`` in the subnet\n+    specified by ``ip_prefix``. ::\n+\n+        SELECT ip_subnet_max(IPPREFIX '192.64.0.0/9'); -- {192.127.255.255}\n+        SELECT ip_subnet_max(IPPREFIX '2001:0db8:85a3:0001:0001:8a2e:0370:7334/48'); -- {2001:db8:85a3:ffff:ffff:ffff:ffff:ffff}\n+\n+.. function:: ip_subnet_range(ip_prefix) -> array(ip_address)\n+\n+    Returns an array of ``ip_address`` of size 2 and of type ``IPADDRESS``.", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1MTM5Mg==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380351392", "bodyText": "What about: Is the second IP prefix in the subnet of the first IP prefix", "author": "caithagoras", "createdAt": "2020-02-17T20:11:20Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        toInetAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1Mjc4Nw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380352787", "bodyText": "Now that this is a standalone function. You can just do return InetAdress.get... here, and remove the temporary variable.", "author": "caithagoras", "createdAt": "2020-02-17T20:16:48Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        toInetAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isPrefixSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPPREFIX) Slice right)\n+    {\n+        return between(ipSubnetMin(right), ipSubnetMin(left), ipSubnetMax(left)) && between(ipSubnetMax(right), ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    private static InetAddress toInetAddress(Slice ipAddress)\n+    {\n+        InetAddress address;\n+        try {\n+            address = InetAddress.getByAddress(ipAddress.getBytes());", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1MzE0OA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380353148", "bodyText": "nit: what about naming the parameters as (prefix, address), or (ipPrefix, ipAddress).", "author": "caithagoras", "createdAt": "2020-02-17T20:18:25Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1MzM4NQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380353385", "bodyText": "nit: What about naming those variables as first and second, as corresponding to the description.", "author": "caithagoras", "createdAt": "2020-02-17T20:19:21Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        toInetAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isPrefixSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPPREFIX) Slice right)", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDA4OQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380354089", "bodyText": "Those 2 test cases do not belong to this test method. Unlike the IP_PREFIX, which can take VARCHAR  as the input, those 2 test cases are not testing the behavior of IP_SUBNET_MIN, but the behavior of casting VARCHAR to IPPREFIX.", "author": "caithagoras", "createdAt": "2020-02-17T20:21:59Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,65 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '64::ff9b::10/48')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/48\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '123.456.789.012/24')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/24\");", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4NTExNw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380385117", "bodyText": "I added these tests based on Rongrong's earlier comment. But i agree that they do not test the IP_SUBNET_MIN  function. If the argument IPPREFIX is always valid then we need not test the invalid input cases.", "author": "NikhilCollooru", "createdAt": "2020-02-17T22:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDE4Nw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380354187", "bodyText": "Same here, remove.", "author": "caithagoras", "createdAt": "2020-02-17T20:22:22Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,65 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '64::ff9b::10/48')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/48\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '123.456.789.012/24')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/24\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetMax()\n+    {\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '1.2.3.128/26')\", IPADDRESS, \"1.2.3.191\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '192.168.128.4/32')\", IPADDRESS, \"192.168.128.4\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '10.1.16.3/9')\", IPADDRESS, \"10.127.255.255\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/127')\", IPADDRESS, \"2001:db8::17\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/128')\", IPADDRESS, \"2001:db8::16\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::ffff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/72')\", IPADDRESS, \"64:ff9b::ff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDIyNg==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380354226", "bodyText": "Same here.", "author": "caithagoras", "createdAt": "2020-02-17T20:22:28Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,65 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '64::ff9b::10/48')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/48\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '123.456.789.012/24')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/24\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetMax()\n+    {\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '1.2.3.128/26')\", IPADDRESS, \"1.2.3.191\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '192.168.128.4/32')\", IPADDRESS, \"192.168.128.4\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '10.1.16.3/9')\", IPADDRESS, \"10.127.255.255\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/127')\", IPADDRESS, \"2001:db8::17\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/128')\", IPADDRESS, \"2001:db8::16\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::ffff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/72')\", IPADDRESS, \"64:ff9b::ff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetRange()\n+    {\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.160/24')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.0\", \"1.2.3.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.128/31')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.128\", \"1.2.3.129\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/32')\", new ArrayType(IPADDRESS), ImmutableList.of(\"10.1.6.46\", \"10.1.6.46\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/0')\", new ArrayType(IPADDRESS), ImmutableList.of(\"0.0.0.0\", \"255.255.255.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/64')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::\", \"64:ff9b::ffff:ffff:ffff:ffff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::52f4/120')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::5200\", \"64:ff9b::52ff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/128')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::17\", \"64:ff9b::17\"));\n+        assertInvalidCast(\"IP_SUBNET_RANGE(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_RANGE(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDI1MA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380354250", "bodyText": "Same here.", "author": "caithagoras", "createdAt": "2020-02-17T20:22:35Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,65 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '64::ff9b::10/48')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/48\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '123.456.789.012/24')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/24\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetMax()\n+    {\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '1.2.3.128/26')\", IPADDRESS, \"1.2.3.191\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '192.168.128.4/32')\", IPADDRESS, \"192.168.128.4\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '10.1.16.3/9')\", IPADDRESS, \"10.127.255.255\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/127')\", IPADDRESS, \"2001:db8::17\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/128')\", IPADDRESS, \"2001:db8::16\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::ffff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/72')\", IPADDRESS, \"64:ff9b::ff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetRange()\n+    {\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.160/24')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.0\", \"1.2.3.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.128/31')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.128\", \"1.2.3.129\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/32')\", new ArrayType(IPADDRESS), ImmutableList.of(\"10.1.6.46\", \"10.1.6.46\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/0')\", new ArrayType(IPADDRESS), ImmutableList.of(\"0.0.0.0\", \"255.255.255.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/64')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::\", \"64:ff9b::ffff:ffff:ffff:ffff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::52f4/120')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::5200\", \"64:ff9b::52ff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/128')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::17\", \"64:ff9b::17\"));\n+        assertInvalidCast(\"IP_SUBNET_RANGE(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_RANGE(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");\n+    }\n+\n+    @Test\n+    public void testIsSubnetOf()\n+    {\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPADDRESS '1.2.3.129')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPADDRESS '1.2.5.1')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/32', IPADDRESS '1.2.3.128')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/0', IPADDRESS '192.168.5.1')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPADDRESS '64:ff9b::ffff:ff')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPADDRESS '64:ffff::17')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '192.168.3.131/26', IPPREFIX '192.168.3.144/30')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPPREFIX '1.2.5.1/30')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPPREFIX '1.2.3.128/26')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPPREFIX '64:ff9b::ff:25/80')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPPREFIX '64:ffff::17/64')\", BOOLEAN, false);\n+        assertInvalidCast(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPPREFIX '64::ffff::17/64')\", \"Cannot cast value to IPPREFIX: 64::ffff::17/64\");\n+        assertInvalidCast(\"IS_SUBNET_OF(IPPREFIX '123.456.789.012/-1', IPPREFIX '10.1.1.10/20')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");\n+        assertInvalidCast(\"IS_SUBNET_OF(IPPREFIX '123.456.789.012/-1', IPPREFIX '10.1.1.10/99')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NTY2NA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380355664", "bodyText": "@rongrong Correct me if I'm wrong here: I believe the second between is redundant?\nIf\nbetween(ipSubnetMin(right), ipSubnetMin(left), ipSubnetMax(left))\n\nis true,\nbetween(ipSubnetMax(right), ipSubnetMin(left), ipSubnetMax(left))\n\nmust be true, and vice versa.", "author": "caithagoras", "createdAt": "2020-02-17T20:27:53Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        toInetAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isPrefixSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPPREFIX) Slice right)\n+    {\n+        return between(ipSubnetMin(right), ipSubnetMin(left), ipSubnetMax(left)) && between(ipSubnetMax(right), ipSubnetMin(left), ipSubnetMax(left));", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4NTI2MA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380385260", "bodyText": "Agree. I thought about it but added the redundant check just to be sure. Anyways we can remove it.", "author": "NikhilCollooru", "createdAt": "2020-02-17T22:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NTY2NA=="}], "type": "inlineReview"}, {"oid": "905a033fe7122a993ccb7093c8ece30118ddd75d", "url": "https://github.com/prestodb/presto/commit/905a033fe7122a993ccb7093c8ece30118ddd75d", "message": "Add IPPREFIX functions", "committedDate": "2020-02-17T22:35:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5NjA2Mg==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380396062", "bodyText": "nit: Add a line break between line 109 and line 110 for readability.", "author": "caithagoras", "createdAt": "2020-02-17T23:23:08Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,56 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetMax()\n+    {\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '1.2.3.128/26')\", IPADDRESS, \"1.2.3.191\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '192.168.128.4/32')\", IPADDRESS, \"192.168.128.4\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '10.1.16.3/9')\", IPADDRESS, \"10.127.255.255\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/127')\", IPADDRESS, \"2001:db8::17\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/128')\", IPADDRESS, \"2001:db8::16\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::ffff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/72')\", IPADDRESS, \"64:ff9b::ff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetRange()\n+    {\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.160/24')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.0\", \"1.2.3.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.128/31')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.128\", \"1.2.3.129\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/32')\", new ArrayType(IPADDRESS), ImmutableList.of(\"10.1.6.46\", \"10.1.6.46\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/0')\", new ArrayType(IPADDRESS), ImmutableList.of(\"0.0.0.0\", \"255.255.255.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/64')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::\", \"64:ff9b::ffff:ffff:ffff:ffff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::52f4/120')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::5200\", \"64:ff9b::52ff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/128')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::17\", \"64:ff9b::17\"));\n+    }\n+\n+    @Test\n+    public void testIsSubnetOf()\n+    {\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPADDRESS '1.2.3.129')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPADDRESS '1.2.5.1')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/32', IPADDRESS '1.2.3.128')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/0', IPADDRESS '192.168.5.1')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPADDRESS '64:ff9b::ffff:ff')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPADDRESS '64:ffff::17')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '192.168.3.131/26', IPPREFIX '192.168.3.144/30')\", BOOLEAN, true);", "originalCommit": "905a033fe7122a993ccb7093c8ece30118ddd75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ca981677126aa72f5d64b3d4bf37812be99126a", "url": "https://github.com/prestodb/presto/commit/6ca981677126aa72f5d64b3d4bf37812be99126a", "message": "Add IPPREFIX functions", "committedDate": "2020-02-18T20:26:23Z", "type": "commit"}, {"oid": "6ca981677126aa72f5d64b3d4bf37812be99126a", "url": "https://github.com/prestodb/presto/commit/6ca981677126aa72f5d64b3d4bf37812be99126a", "message": "Add IPPREFIX functions", "committedDate": "2020-02-18T20:26:23Z", "type": "forcePushed"}]}