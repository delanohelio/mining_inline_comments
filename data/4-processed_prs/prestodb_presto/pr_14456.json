{"pr_number": 14456, "pr_title": "Handle pruned columns in a pushed down pinot table scan", "pr_createdAt": "2020-04-29T02:49:00Z", "pr_url": "https://github.com/prestodb/presto/pull/14456", "timeline": [{"oid": "89f812c3098c25cfc7007c2138417599911623da", "url": "https://github.com/prestodb/presto/commit/89f812c3098c25cfc7007c2138417599911623da", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-04-29T05:54:02Z", "type": "forcePushed"}, {"oid": "e864785604a1795718e47a6609e0ad5a66698c7c", "url": "https://github.com/prestodb/presto/commit/e864785604a1795718e47a6609e0ad5a66698c7c", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-04-29T16:14:50Z", "type": "forcePushed"}, {"oid": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "url": "https://github.com/prestodb/presto/commit/b2b6ac211288de923b8ea9bae454b6bd1b17754d", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-04-29T17:39:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1OTc4Mg==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418259782", "bodyText": "final", "author": "highker", "createdAt": "2020-04-30T20:09:19Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -75,6 +78,7 @@\n     private final GeneratedPql brokerPql;\n     private final PinotConfig pinotConfig;\n     private final List<PinotColumnHandle> columnHandles;\n+    private List<PinotColumnHandle> expectedHandles;", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2Mzg5MQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418263891", "bodyText": "keep all params for format in the same line or one param each line.", "author": "highker", "createdAt": "2020-04-30T20:17:24Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -169,14 +178,19 @@ private void setValuesForGroupby(\n             JsonNode group,\n             String[] values)\n     {\n+        requireNonNull(group, \"Expected valid group\");\n+        requireNonNull(values, \"Expected valid values in group by\");\n+        Preconditions.checkState(\n+                blockBuilders.size() == values.length + group.size(),\n+                String.format(", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NDMxOA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418264318", "bodyText": "private", "author": "highker", "createdAt": "2020-04-30T20:18:10Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +430,60 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    static class BlockAndTypeBuilder", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NDYxMg==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418264612", "bodyText": "expectedColumnIndex", "author": "highker", "createdAt": "2020-04-30T20:18:41Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +430,60 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    static class BlockAndTypeBuilder\n+    {\n+        private final PageBuilder pageBuilder;\n+        private final List<BlockBuilder> columnBlockBuilders;\n+        private final List<Type> columnTypes;\n+\n+        public PageBuilder getPageBuilder()\n+        {\n+            return pageBuilder;\n+        }\n+\n+        public List<BlockBuilder> getColumnBlockBuilders()\n+        {\n+            return columnBlockBuilders;\n+        }\n+\n+        public List<Type> getColumnTypes()\n+        {\n+            return columnTypes;\n+        }\n+\n+        @VisibleForTesting\n+        public BlockAndTypeBuilder(List<PinotColumnHandle> columnHandles, GeneratedPql brokerPql, List<PinotColumnHandle> expectedColumnHandles)\n+        {\n+            // When we created the PQL, we came up with some column handles\n+            // however other optimizers post-pushdown can come in and prune/re-order the required column handles\n+            // so we need to map from the column handles the PQL corresponds to, to the actual column handles\n+            // needed in the scan.\n+\n+            List<Type> expectedTypes = columnHandles.stream()\n+                    .map(PinotColumnHandle::getDataType)\n+                    .collect(Collectors.toList());\n+            pageBuilder = new PageBuilder(expectedTypes);\n+            Preconditions.checkState(brokerPql.getExpectedColumnIndices().size() == expectedColumnHandles.size());\n+            Preconditions.checkState(expectedColumnHandles.size() >= columnHandles.size());\n+\n+            // map the expected column handle to the actual handle\n+            int[] expectedToActual = new int[expectedColumnHandles.size()];\n+            for (int i = 0; i < expectedToActual.length; ++i) {\n+                expectedToActual[i] = columnHandles.indexOf(expectedColumnHandles.get(i));\n+            }\n+\n+            columnBlockBuilders = new ArrayList<>();\n+            columnTypes = new ArrayList<>();\n+\n+            for (int expectedColIdx : brokerPql.getExpectedColumnIndices()) {", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NDczMg==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418264732", "bodyText": "actualColumnIndex", "author": "highker", "createdAt": "2020-04-30T20:18:54Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +430,60 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    static class BlockAndTypeBuilder\n+    {\n+        private final PageBuilder pageBuilder;\n+        private final List<BlockBuilder> columnBlockBuilders;\n+        private final List<Type> columnTypes;\n+\n+        public PageBuilder getPageBuilder()\n+        {\n+            return pageBuilder;\n+        }\n+\n+        public List<BlockBuilder> getColumnBlockBuilders()\n+        {\n+            return columnBlockBuilders;\n+        }\n+\n+        public List<Type> getColumnTypes()\n+        {\n+            return columnTypes;\n+        }\n+\n+        @VisibleForTesting\n+        public BlockAndTypeBuilder(List<PinotColumnHandle> columnHandles, GeneratedPql brokerPql, List<PinotColumnHandle> expectedColumnHandles)\n+        {\n+            // When we created the PQL, we came up with some column handles\n+            // however other optimizers post-pushdown can come in and prune/re-order the required column handles\n+            // so we need to map from the column handles the PQL corresponds to, to the actual column handles\n+            // needed in the scan.\n+\n+            List<Type> expectedTypes = columnHandles.stream()\n+                    .map(PinotColumnHandle::getDataType)\n+                    .collect(Collectors.toList());\n+            pageBuilder = new PageBuilder(expectedTypes);\n+            Preconditions.checkState(brokerPql.getExpectedColumnIndices().size() == expectedColumnHandles.size());\n+            Preconditions.checkState(expectedColumnHandles.size() >= columnHandles.size());\n+\n+            // map the expected column handle to the actual handle\n+            int[] expectedToActual = new int[expectedColumnHandles.size()];\n+            for (int i = 0; i < expectedToActual.length; ++i) {\n+                expectedToActual[i] = columnHandles.indexOf(expectedColumnHandles.get(i));\n+            }\n+\n+            columnBlockBuilders = new ArrayList<>();\n+            columnTypes = new ArrayList<>();\n+\n+            for (int expectedColIdx : brokerPql.getExpectedColumnIndices()) {\n+                int actualColIdx = -1;", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NDg2OA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418264868", "bodyText": "static import checkState", "author": "highker", "createdAt": "2020-04-30T20:19:12Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +430,60 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    static class BlockAndTypeBuilder\n+    {\n+        private final PageBuilder pageBuilder;\n+        private final List<BlockBuilder> columnBlockBuilders;\n+        private final List<Type> columnTypes;\n+\n+        public PageBuilder getPageBuilder()\n+        {\n+            return pageBuilder;\n+        }\n+\n+        public List<BlockBuilder> getColumnBlockBuilders()\n+        {\n+            return columnBlockBuilders;\n+        }\n+\n+        public List<Type> getColumnTypes()\n+        {\n+            return columnTypes;\n+        }\n+\n+        @VisibleForTesting\n+        public BlockAndTypeBuilder(List<PinotColumnHandle> columnHandles, GeneratedPql brokerPql, List<PinotColumnHandle> expectedColumnHandles)\n+        {\n+            // When we created the PQL, we came up with some column handles\n+            // however other optimizers post-pushdown can come in and prune/re-order the required column handles\n+            // so we need to map from the column handles the PQL corresponds to, to the actual column handles\n+            // needed in the scan.\n+\n+            List<Type> expectedTypes = columnHandles.stream()\n+                    .map(PinotColumnHandle::getDataType)\n+                    .collect(Collectors.toList());\n+            pageBuilder = new PageBuilder(expectedTypes);\n+            Preconditions.checkState(brokerPql.getExpectedColumnIndices().size() == expectedColumnHandles.size());", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTA3Ng==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418265076", "bodyText": "move .stream() to the previous line", "author": "highker", "createdAt": "2020-04-30T20:19:34Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotSegmentPageSource.java", "diffHunk": "@@ -85,6 +84,10 @@ public PinotSegmentPageSource(\n         this.pinotQueryClient = requireNonNull(pinotQueryClient, \"pinotQueryClient is null\");\n         this.columnHandles = requireNonNull(columnHandles, \"columnHandles is null\");\n         this.session = requireNonNull(session, \"session is null\");\n+        this.columnTypes = columnHandles\n+                .stream()", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzI1NQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418363255", "bodyText": "not addressed?", "author": "highker", "createdAt": "2020-05-01T00:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTI1NQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418265255", "bodyText": "I would name them expectedColumns and actualColumns", "author": "highker", "createdAt": "2020-04-30T20:19:56Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotSegmentPageSource.java", "diffHunk": "@@ -99,6 +102,12 @@ private static void checkExceptions(DataTable dataTable, PinotSplit split)\n         if (!exceptions.isEmpty()) {\n             throw new PinotException(PinotErrorCode.PINOT_EXCEPTION, split.getSegmentPql(), String.format(\"Encountered %d pinot exceptions for split %s: %s\", exceptions.size(), split, exceptions));\n         }\n+        int columnsExpected = split.getExpectedColumnHandles().size();", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzQwMw==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418363403", "bodyText": "not addressed?", "author": "highker", "createdAt": "2020-05-01T00:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTM4MQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418265381", "bodyText": "one param per line for both PinotException() and format()", "author": "highker", "createdAt": "2020-04-30T20:20:15Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotSegmentPageSource.java", "diffHunk": "@@ -99,6 +102,12 @@ private static void checkExceptions(DataTable dataTable, PinotSplit split)\n         if (!exceptions.isEmpty()) {\n             throw new PinotException(PinotErrorCode.PINOT_EXCEPTION, split.getSegmentPql(), String.format(\"Encountered %d pinot exceptions for split %s: %s\", exceptions.size(), split, exceptions));\n         }\n+        int columnsExpected = split.getExpectedColumnHandles().size();\n+        int columnsActual = dataTable.getDataSchema().size();\n+        if (columnsActual != columnsExpected) {\n+            throw new PinotException(PinotErrorCode.PINOT_EXCEPTION, split.getSegmentPql(), String.format(", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTUxOA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418265518", "bodyText": "index", "author": "highker", "createdAt": "2020-04-30T20:20:29Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotSegmentPageSource.java", "diffHunk": "@@ -150,15 +159,22 @@ public Page getNextPage()\n             return null;\n         }\n         currentDataTable = dataTableList.pop();\n-\n+        List<PinotColumnHandle> expectedColumnHandles = split.getExpectedColumnHandles();\n         PageBuilder pageBuilder = new PageBuilder(columnTypes);\n         // Note that declared positions in the Page should be the same with number of rows in each Block\n         pageBuilder.declarePositions(currentDataTable.getDataTable().getNumberOfRows());\n         for (int columnHandleIdx = 0; columnHandleIdx < columnHandles.size(); columnHandleIdx++) {\n             BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(columnHandleIdx);\n             Type columnType = columnTypes.get(columnHandleIdx);\n             // Write a block for each column in the original order.\n-            writeBlock(blockBuilder, columnType, columnHandleIdx);\n+            PinotColumnHandle handle = columnHandles.get(columnHandleIdx);\n+            int idxReturnedByPinot = expectedColumnHandles.indexOf(handle);", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzU3Nw==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418363577", "bodyText": "not addressed?", "author": "highker", "createdAt": "2020-05-01T00:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTU1OA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418265558", "bodyText": "same", "author": "highker", "createdAt": "2020-04-30T20:20:35Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotSegmentPageSource.java", "diffHunk": "@@ -150,15 +159,22 @@ public Page getNextPage()\n             return null;\n         }\n         currentDataTable = dataTableList.pop();\n-\n+        List<PinotColumnHandle> expectedColumnHandles = split.getExpectedColumnHandles();\n         PageBuilder pageBuilder = new PageBuilder(columnTypes);\n         // Note that declared positions in the Page should be the same with number of rows in each Block\n         pageBuilder.declarePositions(currentDataTable.getDataTable().getNumberOfRows());\n         for (int columnHandleIdx = 0; columnHandleIdx < columnHandles.size(); columnHandleIdx++) {\n             BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(columnHandleIdx);\n             Type columnType = columnTypes.get(columnHandleIdx);\n             // Write a block for each column in the original order.\n-            writeBlock(blockBuilder, columnType, columnHandleIdx);\n+            PinotColumnHandle handle = columnHandles.get(columnHandleIdx);\n+            int idxReturnedByPinot = expectedColumnHandles.indexOf(handle);\n+            if (idxReturnedByPinot < 0) {\n+                throw new PinotException(PinotErrorCode.PINOT_INVALID_PQL_GENERATED, split.getSegmentPql(),\n+                        String.format(\"Expected column handle %s to be present in the handles %s corresponding to the segment PQL\",", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzU5MA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418363590", "bodyText": "not addressed?", "author": "highker", "createdAt": "2020-05-01T00:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NzM0OA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418267348", "bodyText": "one param per line", "author": "highker", "createdAt": "2020-04-30T20:24:08Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/TestPinotBrokerPageSource.java", "diffHunk": "@@ -161,26 +190,60 @@ PqlParsedInfo getBasicInfoFromPql(String pqlResponse)\n                                 \"    \\\"segmentStatistics\\\": [],\\n\" +\n                                 \"    \\\"traceInfo\\\": {}\\n\" +\n                                 \"}\",\n-                        ImmutableList.of(BIGINT, BIGINT, VARCHAR, VARCHAR, BIGINT, BIGINT, BIGINT, BIGINT, BIGINT, BIGINT), Optional.empty()}\n+                        ImmutableList.of(bigint(\"activeTrips\"), bigint(\"numDrivers\"), varchar(\"region\"), bigint(\"rowtime\"), secondsSinceEpoch, fraction(\"utilization\"), bigint(\"utilizedDrivers\"), bigint(\"vehicleViewId\"), bigint(\"windowEnd\"), bigint(\"windowStart\")),\n+                        ImmutableList.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9),\n+                        ImmutableList.of(bigint(\"activeTrips\"), bigint(\"numDrivers\"), varchar(\"region\"), bigint(\"rowtime\"), secondsSinceEpoch, fraction(\"utilization\"), bigint(\"utilizedDrivers\"), bigint(\"vehicleViewId\"), bigint(\"windowEnd\"), bigint(\"windowStart\")),\n+                        Optional.empty()}\n         };\n     }\n \n     @Test(dataProvider = \"pqlResponses\")\n-    public void testPopulateFromPql(String pql, String pqlResponse, List<Type> types, Optional<Class<? extends PrestoException>> expectedError)\n+    public void testPopulateFromPql(String pql, String pqlResponse, List<PinotColumnHandle> actualHandles,\n+            List<Integer> expectedColumnIndices,\n+            List<PinotColumnHandle> expectedColumnHandles,\n+            Optional<Class<? extends PrestoException>> expectedError)\n             throws IOException\n     {\n         PqlParsedInfo pqlParsedInfo = getBasicInfoFromPql(pqlResponse);\n-        ImmutableList.Builder<BlockBuilder> blockBuilders = ImmutableList.builder();\n-        PageBuilder pageBuilder = new PageBuilder(types);\n-        PinotBrokerPageSource pageSource = getPinotBrokerPageSource();\n-        for (int i = 0; i < types.size(); i++) {\n-            blockBuilders.add(pageBuilder.getBlockBuilder(i));\n+        PinotQueryGenerator.GeneratedPql generatedPql = new PinotQueryGenerator.GeneratedPql(\n+                pinotTable.getTableName(),\n+                pql,\n+                expectedColumnIndices,\n+                pqlParsedInfo.groupByColumns,\n+                false,\n+                false);\n+        PinotBrokerPageSource pageSource = new PinotBrokerPageSource(\n+                pinotConfig,\n+                new TestingConnectorSession(ImmutableList.of()),\n+                generatedPql, actualHandles, expectedColumnHandles, new MockPinotClusterInfoFetcher(pinotConfig), objectMapper);", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NzQxMA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418267410", "bodyText": "numNonNullTypes++", "author": "highker", "createdAt": "2020-04-30T20:24:16Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/TestPinotBrokerPageSource.java", "diffHunk": "@@ -161,26 +190,60 @@ PqlParsedInfo getBasicInfoFromPql(String pqlResponse)\n                                 \"    \\\"segmentStatistics\\\": [],\\n\" +\n                                 \"    \\\"traceInfo\\\": {}\\n\" +\n                                 \"}\",\n-                        ImmutableList.of(BIGINT, BIGINT, VARCHAR, VARCHAR, BIGINT, BIGINT, BIGINT, BIGINT, BIGINT, BIGINT), Optional.empty()}\n+                        ImmutableList.of(bigint(\"activeTrips\"), bigint(\"numDrivers\"), varchar(\"region\"), bigint(\"rowtime\"), secondsSinceEpoch, fraction(\"utilization\"), bigint(\"utilizedDrivers\"), bigint(\"vehicleViewId\"), bigint(\"windowEnd\"), bigint(\"windowStart\")),\n+                        ImmutableList.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9),\n+                        ImmutableList.of(bigint(\"activeTrips\"), bigint(\"numDrivers\"), varchar(\"region\"), bigint(\"rowtime\"), secondsSinceEpoch, fraction(\"utilization\"), bigint(\"utilizedDrivers\"), bigint(\"vehicleViewId\"), bigint(\"windowEnd\"), bigint(\"windowStart\")),\n+                        Optional.empty()}\n         };\n     }\n \n     @Test(dataProvider = \"pqlResponses\")\n-    public void testPopulateFromPql(String pql, String pqlResponse, List<Type> types, Optional<Class<? extends PrestoException>> expectedError)\n+    public void testPopulateFromPql(String pql, String pqlResponse, List<PinotColumnHandle> actualHandles,\n+            List<Integer> expectedColumnIndices,\n+            List<PinotColumnHandle> expectedColumnHandles,\n+            Optional<Class<? extends PrestoException>> expectedError)\n             throws IOException\n     {\n         PqlParsedInfo pqlParsedInfo = getBasicInfoFromPql(pqlResponse);\n-        ImmutableList.Builder<BlockBuilder> blockBuilders = ImmutableList.builder();\n-        PageBuilder pageBuilder = new PageBuilder(types);\n-        PinotBrokerPageSource pageSource = getPinotBrokerPageSource();\n-        for (int i = 0; i < types.size(); i++) {\n-            blockBuilders.add(pageBuilder.getBlockBuilder(i));\n+        PinotQueryGenerator.GeneratedPql generatedPql = new PinotQueryGenerator.GeneratedPql(\n+                pinotTable.getTableName(),\n+                pql,\n+                expectedColumnIndices,\n+                pqlParsedInfo.groupByColumns,\n+                false,\n+                false);\n+        PinotBrokerPageSource pageSource = new PinotBrokerPageSource(\n+                pinotConfig,\n+                new TestingConnectorSession(ImmutableList.of()),\n+                generatedPql, actualHandles, expectedColumnHandles, new MockPinotClusterInfoFetcher(pinotConfig), objectMapper);\n+        PinotBrokerPageSource.BlockAndTypeBuilder blockAndTypeBuilder = new PinotBrokerPageSource.BlockAndTypeBuilder(actualHandles, generatedPql, expectedColumnHandles);\n+\n+        validateExpectedColumnIndices(expectedColumnIndices, expectedColumnHandles);\n+        List<BlockBuilder> columnBlockBuilders = blockAndTypeBuilder.getColumnBlockBuilders();\n+        List<Type> columnTypes = blockAndTypeBuilder.getColumnTypes();\n+\n+        assertEquals(columnTypes.size(), columnBlockBuilders.size());\n+\n+        int numNonNullTypes = 0;\n+        for (int i = 0; i < columnTypes.size(); ++i) {\n+            Type type = columnTypes.get(i);\n+            BlockBuilder builder = columnBlockBuilders.get(i);\n+            assertEquals(type == null, builder == null);\n+            if (type != null) {\n+                ++numNonNullTypes;", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NzQzOA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418267438", "bodyText": "i++", "author": "highker", "createdAt": "2020-04-30T20:24:21Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/TestPinotBrokerPageSource.java", "diffHunk": "@@ -161,26 +190,60 @@ PqlParsedInfo getBasicInfoFromPql(String pqlResponse)\n                                 \"    \\\"segmentStatistics\\\": [],\\n\" +\n                                 \"    \\\"traceInfo\\\": {}\\n\" +\n                                 \"}\",\n-                        ImmutableList.of(BIGINT, BIGINT, VARCHAR, VARCHAR, BIGINT, BIGINT, BIGINT, BIGINT, BIGINT, BIGINT), Optional.empty()}\n+                        ImmutableList.of(bigint(\"activeTrips\"), bigint(\"numDrivers\"), varchar(\"region\"), bigint(\"rowtime\"), secondsSinceEpoch, fraction(\"utilization\"), bigint(\"utilizedDrivers\"), bigint(\"vehicleViewId\"), bigint(\"windowEnd\"), bigint(\"windowStart\")),\n+                        ImmutableList.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9),\n+                        ImmutableList.of(bigint(\"activeTrips\"), bigint(\"numDrivers\"), varchar(\"region\"), bigint(\"rowtime\"), secondsSinceEpoch, fraction(\"utilization\"), bigint(\"utilizedDrivers\"), bigint(\"vehicleViewId\"), bigint(\"windowEnd\"), bigint(\"windowStart\")),\n+                        Optional.empty()}\n         };\n     }\n \n     @Test(dataProvider = \"pqlResponses\")\n-    public void testPopulateFromPql(String pql, String pqlResponse, List<Type> types, Optional<Class<? extends PrestoException>> expectedError)\n+    public void testPopulateFromPql(String pql, String pqlResponse, List<PinotColumnHandle> actualHandles,\n+            List<Integer> expectedColumnIndices,\n+            List<PinotColumnHandle> expectedColumnHandles,\n+            Optional<Class<? extends PrestoException>> expectedError)\n             throws IOException\n     {\n         PqlParsedInfo pqlParsedInfo = getBasicInfoFromPql(pqlResponse);\n-        ImmutableList.Builder<BlockBuilder> blockBuilders = ImmutableList.builder();\n-        PageBuilder pageBuilder = new PageBuilder(types);\n-        PinotBrokerPageSource pageSource = getPinotBrokerPageSource();\n-        for (int i = 0; i < types.size(); i++) {\n-            blockBuilders.add(pageBuilder.getBlockBuilder(i));\n+        PinotQueryGenerator.GeneratedPql generatedPql = new PinotQueryGenerator.GeneratedPql(\n+                pinotTable.getTableName(),\n+                pql,\n+                expectedColumnIndices,\n+                pqlParsedInfo.groupByColumns,\n+                false,\n+                false);\n+        PinotBrokerPageSource pageSource = new PinotBrokerPageSource(\n+                pinotConfig,\n+                new TestingConnectorSession(ImmutableList.of()),\n+                generatedPql, actualHandles, expectedColumnHandles, new MockPinotClusterInfoFetcher(pinotConfig), objectMapper);\n+        PinotBrokerPageSource.BlockAndTypeBuilder blockAndTypeBuilder = new PinotBrokerPageSource.BlockAndTypeBuilder(actualHandles, generatedPql, expectedColumnHandles);\n+\n+        validateExpectedColumnIndices(expectedColumnIndices, expectedColumnHandles);\n+        List<BlockBuilder> columnBlockBuilders = blockAndTypeBuilder.getColumnBlockBuilders();\n+        List<Type> columnTypes = blockAndTypeBuilder.getColumnTypes();\n+\n+        assertEquals(columnTypes.size(), columnBlockBuilders.size());\n+\n+        int numNonNullTypes = 0;\n+        for (int i = 0; i < columnTypes.size(); ++i) {", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NzY2Mw==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418267663", "bodyText": "i -> expectedColumnIndex", "author": "highker", "createdAt": "2020-04-30T20:24:47Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/TestPinotBrokerPageSource.java", "diffHunk": "@@ -190,16 +253,22 @@ public void testPopulateFromPql(String pql, String pqlResponse, List<Type> types\n         Optional<String> errorString = thrown.map(e -> Throwables.getStackTraceAsString(e));\n         assertEquals(thrownType, expectedError, String.format(\"Expected error %s, but got error of type %s: %s\", expectedError, thrownType, errorString));\n         if (!expectedError.isPresent()) {\n-            assertEquals(types.size(), pqlParsedInfo.columns);\n+            assertEquals(expectedColumnIndices.size(), pqlParsedInfo.columns);\n             assertEquals(rows, pqlParsedInfo.rows);\n         }\n     }\n \n-    private PinotBrokerPageSource getPinotBrokerPageSource()\n+    private void validateExpectedColumnIndices(List<Integer> expectedColumnIndices, List<PinotColumnHandle> expectedColumnHandles)\n     {\n-        List<PinotColumnHandle> pinotColumnHandles = ImmutableList.of(regionId, fare, city, fare, secondsSinceEpoch);\n-        PinotConfig pinotConfig = new PinotConfig();\n-        PinotQueryGenerator.GeneratedPql generatedPql = new PinotQueryGenerator.GeneratedPql(pinotTable.getTableName(), String.format(\"SELECT %s, %s FROM %s LIMIT %d\", city.getColumnName(), regionId.getColumnName(), pinotTable.getTableName(), pinotConfig.getLimitLargeForSegment()), ImmutableList.of(0, 1), 0, false, true);\n-        return new PinotBrokerPageSource(pinotConfig, new TestingConnectorSession(ImmutableList.of()), generatedPql, pinotColumnHandles, new MockPinotClusterInfoFetcher(pinotConfig), objectMapper);\n+        int numValid = 0;\n+        Set<Integer> uniqueIndices = new HashSet<>();\n+        for (int i : expectedColumnIndices) {", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NzczNA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418267734", "bodyText": "numValid++", "author": "highker", "createdAt": "2020-04-30T20:24:55Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/TestPinotBrokerPageSource.java", "diffHunk": "@@ -190,16 +253,22 @@ public void testPopulateFromPql(String pql, String pqlResponse, List<Type> types\n         Optional<String> errorString = thrown.map(e -> Throwables.getStackTraceAsString(e));\n         assertEquals(thrownType, expectedError, String.format(\"Expected error %s, but got error of type %s: %s\", expectedError, thrownType, errorString));\n         if (!expectedError.isPresent()) {\n-            assertEquals(types.size(), pqlParsedInfo.columns);\n+            assertEquals(expectedColumnIndices.size(), pqlParsedInfo.columns);\n             assertEquals(rows, pqlParsedInfo.rows);\n         }\n     }\n \n-    private PinotBrokerPageSource getPinotBrokerPageSource()\n+    private void validateExpectedColumnIndices(List<Integer> expectedColumnIndices, List<PinotColumnHandle> expectedColumnHandles)\n     {\n-        List<PinotColumnHandle> pinotColumnHandles = ImmutableList.of(regionId, fare, city, fare, secondsSinceEpoch);\n-        PinotConfig pinotConfig = new PinotConfig();\n-        PinotQueryGenerator.GeneratedPql generatedPql = new PinotQueryGenerator.GeneratedPql(pinotTable.getTableName(), String.format(\"SELECT %s, %s FROM %s LIMIT %d\", city.getColumnName(), regionId.getColumnName(), pinotTable.getTableName(), pinotConfig.getLimitLargeForSegment()), ImmutableList.of(0, 1), 0, false, true);\n-        return new PinotBrokerPageSource(pinotConfig, new TestingConnectorSession(ImmutableList.of()), generatedPql, pinotColumnHandles, new MockPinotClusterInfoFetcher(pinotConfig), objectMapper);\n+        int numValid = 0;\n+        Set<Integer> uniqueIndices = new HashSet<>();\n+        for (int i : expectedColumnIndices) {\n+            assertTrue(i == -1 || i >= 0 && i < expectedColumnHandles.size());\n+            if (i >= 0) {\n+                ++numValid;", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2Nzg1Mg==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418267852", "bodyText": "i--", "author": "highker", "createdAt": "2020-04-30T20:25:08Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/TestPinotSegmentPageSource.java", "diffHunk": "@@ -327,6 +327,47 @@ private DataTable createDataTableWithAllTypes()\n         }\n     }\n \n+    @Test\n+    public void testPrunedColumns()\n+    {\n+        PinotSessionProperties pinotSessionProperties = new PinotSessionProperties(pinotConfig);\n+        ConnectorSession session = new TestingConnectorSession(pinotSessionProperties.getSessionProperties());\n+        List<DataTable> dataTables = IntStream.range(0, 3).mapToObj(i -> createDataTableWithAllTypes()).collect(toImmutableList());\n+        PinotScatterGatherQueryClient mockPinotQueryClient = new MockPinotScatterGatherQueryClient(new PinotScatterGatherQueryClient.Config(\n+                pinotConfig.getIdleTimeout().toMillis(),\n+                pinotConfig.getThreadPoolSize(),\n+                pinotConfig.getMinConnectionsPerServer(),\n+                pinotConfig.getMaxBacklogPerServer(),\n+                pinotConfig.getMaxConnectionsPerServer()), dataTables);\n+        List<PinotColumnHandle> expectedColumnHandles = createPinotColumnHandlesWithAllTypes();\n+        PinotSplit mockPinotSplit = new PinotSplit(pinotConnectorId.toString(), PinotSplit.SplitType.SEGMENT, expectedColumnHandles, Optional.empty(), Optional.of(\"blah\"), ImmutableList.of(\"seg\"), Optional.of(\"host\"));\n+\n+        ImmutableList.Builder<Integer> columnsSurvivingBuilder = ImmutableList.builder();\n+        for (int i = expectedColumnHandles.size() - 1; i >= 0; --i) {", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NzkzMQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418267931", "bodyText": "k++", "author": "highker", "createdAt": "2020-04-30T20:25:19Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/TestPinotSegmentPageSource.java", "diffHunk": "@@ -327,6 +327,47 @@ private DataTable createDataTableWithAllTypes()\n         }\n     }\n \n+    @Test\n+    public void testPrunedColumns()\n+    {\n+        PinotSessionProperties pinotSessionProperties = new PinotSessionProperties(pinotConfig);\n+        ConnectorSession session = new TestingConnectorSession(pinotSessionProperties.getSessionProperties());\n+        List<DataTable> dataTables = IntStream.range(0, 3).mapToObj(i -> createDataTableWithAllTypes()).collect(toImmutableList());\n+        PinotScatterGatherQueryClient mockPinotQueryClient = new MockPinotScatterGatherQueryClient(new PinotScatterGatherQueryClient.Config(\n+                pinotConfig.getIdleTimeout().toMillis(),\n+                pinotConfig.getThreadPoolSize(),\n+                pinotConfig.getMinConnectionsPerServer(),\n+                pinotConfig.getMaxBacklogPerServer(),\n+                pinotConfig.getMaxConnectionsPerServer()), dataTables);\n+        List<PinotColumnHandle> expectedColumnHandles = createPinotColumnHandlesWithAllTypes();\n+        PinotSplit mockPinotSplit = new PinotSplit(pinotConnectorId.toString(), PinotSplit.SplitType.SEGMENT, expectedColumnHandles, Optional.empty(), Optional.of(\"blah\"), ImmutableList.of(\"seg\"), Optional.of(\"host\"));\n+\n+        ImmutableList.Builder<Integer> columnsSurvivingBuilder = ImmutableList.builder();\n+        for (int i = expectedColumnHandles.size() - 1; i >= 0; --i) {\n+            if (i % 2 == 0) {\n+                columnsSurvivingBuilder.add(i);\n+            }\n+        }\n+        List<Integer> columnsSurviving = columnsSurvivingBuilder.build();\n+        List<PinotColumnHandle> handlesSurviving = columnsSurviving.stream().map(expectedColumnHandles::get).collect(toImmutableList());\n+        PinotSegmentPageSource pinotSegmentPageSource = new PinotSegmentPageSource(session, pinotConfig, mockPinotQueryClient, mockPinotSplit, handlesSurviving);\n+\n+        for (int i = 0; i < dataTables.size(); ++i) {\n+            Page page = requireNonNull(pinotSegmentPageSource.getNextPage(), \"Expected a valid page\");\n+            Assert.assertEquals(page.getChannelCount(), columnsSurviving.size());\n+            for (int j = 0; j < columnsSurviving.size(); ++j) {\n+                Block block = page.getBlock(j);\n+                int originalColumnIndex = columnsSurviving.get(j);\n+                Type type = PinotColumnUtils.getPrestoTypeFromPinotType(getFieldSpec(\"dontcare\", ALL_TYPES.get(originalColumnIndex)), false, false);\n+                long maxHashCode = Long.MIN_VALUE;\n+                for (int k = 0; k < NUM_ROWS; ++k) {", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2ODExOA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418268118", "bodyText": "List", "author": "highker", "createdAt": "2020-04-30T20:25:36Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/TestPinotSplitManager.java", "diffHunk": "@@ -61,8 +61,10 @@ private void testSegmentSplitsHelperNoFilter(PinotTableHandle table, int segment\n         SessionHolder sessionHolder = new SessionHolder(pinotConfig);\n         PlanBuilder planBuilder = createPlanBuilder(sessionHolder);\n         PlanNode plan = tableScan(planBuilder, table, regionId, city, fare, secondsSinceEpoch);\n-        PinotQueryGenerator.GeneratedPql generatedPql = new PinotQueryGenerator(pinotConfig, typeManager, functionMetadataManager, standardFunctionResolution).generate(plan, sessionHolder.getConnectorSession()).get().getGeneratedPql();\n-        PinotTableHandle pinotTableHandle = new PinotTableHandle(table.getConnectorId(), table.getSchemaName(), table.getTableName(), Optional.of(false), Optional.of(generatedPql));\n+        PinotQueryGenerator.PinotQueryGeneratorResult pinotQueryGeneratorResult = new PinotQueryGenerator(pinotConfig, typeManager, functionMetadataManager, standardFunctionResolution).generate(plan, sessionHolder.getConnectorSession()).get();\n+        ImmutableList<PinotColumnHandle> expectedHandles = ImmutableList.copyOf(pinotQueryGeneratorResult.getContext().getAssignments().values());", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2ODE2MQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418268161", "bodyText": "List", "author": "highker", "createdAt": "2020-04-30T20:25:40Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/TestPinotSplitManager.java", "diffHunk": "@@ -74,8 +76,10 @@ private void testSegmentSplitsHelperWithFilter(PinotTableHandle table, int segme\n         SessionHolder sessionHolder = new SessionHolder(pinotConfig);\n         PlanBuilder planBuilder = createPlanBuilder(sessionHolder);\n         PlanNode plan = filter(planBuilder, tableScan(planBuilder, table, regionId, city, fare, secondsSinceEpoch), getRowExpression(\"city = 'Boston'\", sessionHolder));\n-        PinotQueryGenerator.GeneratedPql generatedPql = new PinotQueryGenerator(pinotConfig, typeManager, functionMetadataManager, standardFunctionResolution).generate(plan, sessionHolder.getConnectorSession()).get().getGeneratedPql();\n-        PinotTableHandle pinotTableHandle = new PinotTableHandle(table.getConnectorId(), table.getSchemaName(), table.getTableName(), Optional.of(false), Optional.of(generatedPql));\n+        PinotQueryGenerator.PinotQueryGeneratorResult pinotQueryGeneratorResult = new PinotQueryGenerator(pinotConfig, typeManager, functionMetadataManager, standardFunctionResolution).generate(plan, sessionHolder.getConnectorSession()).get();\n+        ImmutableList<PinotColumnHandle> expectedHandles = ImmutableList.copyOf(pinotQueryGeneratorResult.getContext().getAssignments().values());", "originalCommit": "b2b6ac211288de923b8ea9bae454b6bd1b17754d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "efe1f46cb26cbfb139e0b099ea56ba00ed97d055", "url": "https://github.com/prestodb/presto/commit/efe1f46cb26cbfb139e0b099ea56ba00ed97d055", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-04-30T23:26:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0OTQyMQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418349421", "bodyText": "s/expectedToActual/handleMapping/g", "author": "zhenxiao", "createdAt": "2020-04-30T23:43:41Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +432,61 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    @VisibleForTesting\n+    static class BlockAndTypeBuilder\n+    {\n+        private final PageBuilder pageBuilder;\n+        private final List<BlockBuilder> columnBlockBuilders;\n+        private final List<Type> columnTypes;\n+\n+        public PageBuilder getPageBuilder()\n+        {\n+            return pageBuilder;\n+        }\n+\n+        public List<BlockBuilder> getColumnBlockBuilders()\n+        {\n+            return columnBlockBuilders;\n+        }\n+\n+        public List<Type> getColumnTypes()\n+        {\n+            return columnTypes;\n+        }\n+\n+        @VisibleForTesting\n+        public BlockAndTypeBuilder(List<PinotColumnHandle> columnHandles, GeneratedPql brokerPql, List<PinotColumnHandle> expectedColumnHandles)\n+        {\n+            // When we created the PQL, we came up with some column handles\n+            // however other optimizers post-pushdown can come in and prune/re-order the required column handles\n+            // so we need to map from the column handles the PQL corresponds to, to the actual column handles\n+            // needed in the scan.\n+\n+            List<Type> expectedTypes = columnHandles.stream()\n+                    .map(PinotColumnHandle::getDataType)\n+                    .collect(Collectors.toList());\n+            pageBuilder = new PageBuilder(expectedTypes);\n+            Preconditions.checkState(brokerPql.getExpectedColumnIndices().size() == expectedColumnHandles.size());\n+            Preconditions.checkState(expectedColumnHandles.size() >= columnHandles.size());\n+\n+            // map the expected column handle to the actual handle\n+            int[] expectedToActual = new int[expectedColumnHandles.size()];", "originalCommit": "efe1f46cb26cbfb139e0b099ea56ba00ed97d055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0OTcxMA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418349710", "bodyText": "s/actualColumnIdx/columnIndex/g", "author": "zhenxiao", "createdAt": "2020-04-30T23:44:35Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +432,61 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    @VisibleForTesting\n+    static class BlockAndTypeBuilder\n+    {\n+        private final PageBuilder pageBuilder;\n+        private final List<BlockBuilder> columnBlockBuilders;\n+        private final List<Type> columnTypes;\n+\n+        public PageBuilder getPageBuilder()\n+        {\n+            return pageBuilder;\n+        }\n+\n+        public List<BlockBuilder> getColumnBlockBuilders()\n+        {\n+            return columnBlockBuilders;\n+        }\n+\n+        public List<Type> getColumnTypes()\n+        {\n+            return columnTypes;\n+        }\n+\n+        @VisibleForTesting\n+        public BlockAndTypeBuilder(List<PinotColumnHandle> columnHandles, GeneratedPql brokerPql, List<PinotColumnHandle> expectedColumnHandles)\n+        {\n+            // When we created the PQL, we came up with some column handles\n+            // however other optimizers post-pushdown can come in and prune/re-order the required column handles\n+            // so we need to map from the column handles the PQL corresponds to, to the actual column handles\n+            // needed in the scan.\n+\n+            List<Type> expectedTypes = columnHandles.stream()\n+                    .map(PinotColumnHandle::getDataType)\n+                    .collect(Collectors.toList());\n+            pageBuilder = new PageBuilder(expectedTypes);\n+            Preconditions.checkState(brokerPql.getExpectedColumnIndices().size() == expectedColumnHandles.size());\n+            Preconditions.checkState(expectedColumnHandles.size() >= columnHandles.size());\n+\n+            // map the expected column handle to the actual handle\n+            int[] expectedToActual = new int[expectedColumnHandles.size()];\n+            for (int i = 0; i < expectedToActual.length; ++i) {\n+                expectedToActual[i] = columnHandles.indexOf(expectedColumnHandles.get(i));\n+            }\n+\n+            columnBlockBuilders = new ArrayList<>();\n+            columnTypes = new ArrayList<>();\n+\n+            for (int expectedColumnIdx : brokerPql.getExpectedColumnIndices()) {\n+                int actualColumnIdx = -1;", "originalCommit": "efe1f46cb26cbfb139e0b099ea56ba00ed97d055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0OTc5Ng==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418349796", "bodyText": "s/expectedColumnIdx/expectedColumnIndex/g", "author": "zhenxiao", "createdAt": "2020-04-30T23:44:50Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +432,61 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    @VisibleForTesting\n+    static class BlockAndTypeBuilder\n+    {\n+        private final PageBuilder pageBuilder;\n+        private final List<BlockBuilder> columnBlockBuilders;\n+        private final List<Type> columnTypes;\n+\n+        public PageBuilder getPageBuilder()\n+        {\n+            return pageBuilder;\n+        }\n+\n+        public List<BlockBuilder> getColumnBlockBuilders()\n+        {\n+            return columnBlockBuilders;\n+        }\n+\n+        public List<Type> getColumnTypes()\n+        {\n+            return columnTypes;\n+        }\n+\n+        @VisibleForTesting\n+        public BlockAndTypeBuilder(List<PinotColumnHandle> columnHandles, GeneratedPql brokerPql, List<PinotColumnHandle> expectedColumnHandles)\n+        {\n+            // When we created the PQL, we came up with some column handles\n+            // however other optimizers post-pushdown can come in and prune/re-order the required column handles\n+            // so we need to map from the column handles the PQL corresponds to, to the actual column handles\n+            // needed in the scan.\n+\n+            List<Type> expectedTypes = columnHandles.stream()\n+                    .map(PinotColumnHandle::getDataType)\n+                    .collect(Collectors.toList());\n+            pageBuilder = new PageBuilder(expectedTypes);\n+            Preconditions.checkState(brokerPql.getExpectedColumnIndices().size() == expectedColumnHandles.size());\n+            Preconditions.checkState(expectedColumnHandles.size() >= columnHandles.size());\n+\n+            // map the expected column handle to the actual handle\n+            int[] expectedToActual = new int[expectedColumnHandles.size()];\n+            for (int i = 0; i < expectedToActual.length; ++i) {\n+                expectedToActual[i] = columnHandles.indexOf(expectedColumnHandles.get(i));\n+            }\n+\n+            columnBlockBuilders = new ArrayList<>();\n+            columnTypes = new ArrayList<>();\n+\n+            for (int expectedColumnIdx : brokerPql.getExpectedColumnIndices()) {", "originalCommit": "efe1f46cb26cbfb139e0b099ea56ba00ed97d055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MDYxMw==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418350613", "bodyText": "s/columnHandleIdx/columnHandleIndex/g", "author": "zhenxiao", "createdAt": "2020-04-30T23:47:40Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotSegmentPageSource.java", "diffHunk": "@@ -150,15 +159,22 @@ public Page getNextPage()\n             return null;\n         }\n         currentDataTable = dataTableList.pop();\n-\n+        List<PinotColumnHandle> expectedColumnHandles = split.getExpectedColumnHandles();\n         PageBuilder pageBuilder = new PageBuilder(columnTypes);\n         // Note that declared positions in the Page should be the same with number of rows in each Block\n         pageBuilder.declarePositions(currentDataTable.getDataTable().getNumberOfRows());\n         for (int columnHandleIdx = 0; columnHandleIdx < columnHandles.size(); columnHandleIdx++) {\n             BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(columnHandleIdx);\n             Type columnType = columnTypes.get(columnHandleIdx);\n             // Write a block for each column in the original order.\n-            writeBlock(blockBuilder, columnType, columnHandleIdx);\n+            PinotColumnHandle handle = columnHandles.get(columnHandleIdx);", "originalCommit": "efe1f46cb26cbfb139e0b099ea56ba00ed97d055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MDkzNQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418350935", "bodyText": "static import PINOT_INVALID_PQL_GENERATED", "author": "zhenxiao", "createdAt": "2020-04-30T23:48:52Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotSegmentPageSource.java", "diffHunk": "@@ -150,15 +159,22 @@ public Page getNextPage()\n             return null;\n         }\n         currentDataTable = dataTableList.pop();\n-\n+        List<PinotColumnHandle> expectedColumnHandles = split.getExpectedColumnHandles();\n         PageBuilder pageBuilder = new PageBuilder(columnTypes);\n         // Note that declared positions in the Page should be the same with number of rows in each Block\n         pageBuilder.declarePositions(currentDataTable.getDataTable().getNumberOfRows());\n         for (int columnHandleIdx = 0; columnHandleIdx < columnHandles.size(); columnHandleIdx++) {\n             BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(columnHandleIdx);\n             Type columnType = columnTypes.get(columnHandleIdx);\n             // Write a block for each column in the original order.\n-            writeBlock(blockBuilder, columnType, columnHandleIdx);\n+            PinotColumnHandle handle = columnHandles.get(columnHandleIdx);\n+            int idxReturnedByPinot = expectedColumnHandles.indexOf(handle);\n+            if (idxReturnedByPinot < 0) {\n+                throw new PinotException(PinotErrorCode.PINOT_INVALID_PQL_GENERATED, split.getSegmentPql(),", "originalCommit": "efe1f46cb26cbfb139e0b099ea56ba00ed97d055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MTA1Mg==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418351052", "bodyText": "static import PINOT_UNSUPPORTED_COLUMN_TYPE", "author": "zhenxiao", "createdAt": "2020-04-30T23:49:09Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotSegmentPageSource.java", "diffHunk": "@@ -255,10 +267,10 @@ else if (javaType.equals(Slice.class)) {\n         }\n         else {\n             throw new PrestoException(\n-                    PINOT_UNSUPPORTED_COLUMN_TYPE,\n+                    PinotErrorCode.PINOT_UNSUPPORTED_COLUMN_TYPE,", "originalCommit": "efe1f46cb26cbfb139e0b099ea56ba00ed97d055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MTczNQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418351735", "bodyText": "is handles used?", "author": "zhenxiao", "createdAt": "2020-04-30T23:51:23Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotQueryGeneratorContext.java", "diffHunk": "@@ -358,7 +358,9 @@ else if (!groupByColumns.isEmpty()) {\n             query += \" \" + limitKeyWord + \" \" + queryLimit;\n         }\n \n-        List<Integer> indices = getIndicesMappingFromPinotSchemaToPrestoSchema(query, getAssignments());\n+        LinkedHashMap<VariableReferenceExpression, PinotColumnHandle> assignments = getAssignments();\n+        List<PinotColumnHandle> handles = ImmutableList.copyOf(assignments.values());", "originalCommit": "efe1f46cb26cbfb139e0b099ea56ba00ed97d055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "891d33a043ef59b2b5e95957a94ee2d535d8b5cd", "url": "https://github.com/prestodb/presto/commit/891d33a043ef59b2b5e95957a94ee2d535d8b5cd", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-05-01T00:13:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MDg4NQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418360885", "bodyText": "static import checkState", "author": "highker", "createdAt": "2020-05-01T00:25:24Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -169,14 +178,21 @@ private void setValuesForGroupby(\n             JsonNode group,\n             String[] values)\n     {\n+        requireNonNull(group, \"Expected valid group\");\n+        requireNonNull(values, \"Expected valid values in group by\");\n+        Preconditions.checkState(", "originalCommit": "891d33a043ef59b2b5e95957a94ee2d535d8b5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2Mjg4OA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418362888", "bodyText": "static import", "author": "highker", "createdAt": "2020-05-01T00:31:59Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -274,6 +279,12 @@ private int issuePqlAndPopulate(\n         });\n     }\n \n+    private static String asText(JsonNode node)\n+    {\n+        Preconditions.checkState(node.isValueNode());", "originalCommit": "891d33a043ef59b2b5e95957a94ee2d535d8b5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2Mjk0Nw==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418362947", "bodyText": "this.pageBuilder", "author": "highker", "createdAt": "2020-05-01T00:32:12Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +432,69 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    @VisibleForTesting\n+    static class BlockAndTypeBuilder\n+    {\n+        private final PageBuilder pageBuilder;\n+        private final List<BlockBuilder> columnBlockBuilders;\n+        private final List<Type> columnTypes;\n+\n+        public PageBuilder getPageBuilder()\n+        {\n+            return pageBuilder;\n+        }\n+\n+        public List<BlockBuilder> getColumnBlockBuilders()\n+        {\n+            return columnBlockBuilders;\n+        }\n+\n+        public List<Type> getColumnTypes()\n+        {\n+            return columnTypes;\n+        }\n+\n+        @VisibleForTesting\n+        public BlockAndTypeBuilder(List<PinotColumnHandle> columnHandles, GeneratedPql brokerPql, List<PinotColumnHandle> expectedColumnHandles)\n+        {\n+            // When we created the PQL, we came up with some column handles\n+            // however other optimizers post-pushdown can come in and prune/re-order the required column handles\n+            // so we need to map from the column handles the PQL corresponds to, to the actual column handles\n+            // needed in the scan.\n+\n+            List<Type> expectedTypes = columnHandles.stream()\n+                    .map(PinotColumnHandle::getDataType)\n+                    .collect(Collectors.toList());\n+            pageBuilder = new PageBuilder(expectedTypes);", "originalCommit": "891d33a043ef59b2b5e95957a94ee2d535d8b5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzAyNA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418363024", "bodyText": "this.columnBlockBuilders", "author": "highker", "createdAt": "2020-05-01T00:32:25Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +432,69 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    @VisibleForTesting\n+    static class BlockAndTypeBuilder\n+    {\n+        private final PageBuilder pageBuilder;\n+        private final List<BlockBuilder> columnBlockBuilders;\n+        private final List<Type> columnTypes;\n+\n+        public PageBuilder getPageBuilder()\n+        {\n+            return pageBuilder;\n+        }\n+\n+        public List<BlockBuilder> getColumnBlockBuilders()\n+        {\n+            return columnBlockBuilders;\n+        }\n+\n+        public List<Type> getColumnTypes()\n+        {\n+            return columnTypes;\n+        }\n+\n+        @VisibleForTesting\n+        public BlockAndTypeBuilder(List<PinotColumnHandle> columnHandles, GeneratedPql brokerPql, List<PinotColumnHandle> expectedColumnHandles)\n+        {\n+            // When we created the PQL, we came up with some column handles\n+            // however other optimizers post-pushdown can come in and prune/re-order the required column handles\n+            // so we need to map from the column handles the PQL corresponds to, to the actual column handles\n+            // needed in the scan.\n+\n+            List<Type> expectedTypes = columnHandles.stream()\n+                    .map(PinotColumnHandle::getDataType)\n+                    .collect(Collectors.toList());\n+            pageBuilder = new PageBuilder(expectedTypes);\n+            Preconditions.checkState(brokerPql.getExpectedColumnIndices().size() == expectedColumnHandles.size());\n+            Preconditions.checkState(expectedColumnHandles.size() >= columnHandles.size());\n+\n+            // The expectedColumnHandles are the handles corresponding to the generated PQL\n+            // However, the engine could end up requesting only a permutation/subset of those handles\n+            // during the actual scan\n+\n+            // Map the handles from planning time to the handles asked in the scan\n+            // so that we know which columns to discard.\n+            int[] handleMapping = new int[expectedColumnHandles.size()];\n+            for (int i = 0; i < handleMapping.length; ++i) {\n+                handleMapping[i] = columnHandles.indexOf(expectedColumnHandles.get(i));\n+            }\n+\n+            columnBlockBuilders = new ArrayList<>();", "originalCommit": "891d33a043ef59b2b5e95957a94ee2d535d8b5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzA0MQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418363041", "bodyText": "this", "author": "highker", "createdAt": "2020-05-01T00:32:28Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -421,4 +432,69 @@ public void close()\n     {\n         finished = true;\n     }\n+\n+    @VisibleForTesting\n+    static class BlockAndTypeBuilder\n+    {\n+        private final PageBuilder pageBuilder;\n+        private final List<BlockBuilder> columnBlockBuilders;\n+        private final List<Type> columnTypes;\n+\n+        public PageBuilder getPageBuilder()\n+        {\n+            return pageBuilder;\n+        }\n+\n+        public List<BlockBuilder> getColumnBlockBuilders()\n+        {\n+            return columnBlockBuilders;\n+        }\n+\n+        public List<Type> getColumnTypes()\n+        {\n+            return columnTypes;\n+        }\n+\n+        @VisibleForTesting\n+        public BlockAndTypeBuilder(List<PinotColumnHandle> columnHandles, GeneratedPql brokerPql, List<PinotColumnHandle> expectedColumnHandles)\n+        {\n+            // When we created the PQL, we came up with some column handles\n+            // however other optimizers post-pushdown can come in and prune/re-order the required column handles\n+            // so we need to map from the column handles the PQL corresponds to, to the actual column handles\n+            // needed in the scan.\n+\n+            List<Type> expectedTypes = columnHandles.stream()\n+                    .map(PinotColumnHandle::getDataType)\n+                    .collect(Collectors.toList());\n+            pageBuilder = new PageBuilder(expectedTypes);\n+            Preconditions.checkState(brokerPql.getExpectedColumnIndices().size() == expectedColumnHandles.size());\n+            Preconditions.checkState(expectedColumnHandles.size() >= columnHandles.size());\n+\n+            // The expectedColumnHandles are the handles corresponding to the generated PQL\n+            // However, the engine could end up requesting only a permutation/subset of those handles\n+            // during the actual scan\n+\n+            // Map the handles from planning time to the handles asked in the scan\n+            // so that we know which columns to discard.\n+            int[] handleMapping = new int[expectedColumnHandles.size()];\n+            for (int i = 0; i < handleMapping.length; ++i) {\n+                handleMapping[i] = columnHandles.indexOf(expectedColumnHandles.get(i));\n+            }\n+\n+            columnBlockBuilders = new ArrayList<>();\n+            columnTypes = new ArrayList<>();", "originalCommit": "891d33a043ef59b2b5e95957a94ee2d535d8b5cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzM4MQ==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418363381", "bodyText": "one param per line", "author": "highker", "createdAt": "2020-05-01T00:33:43Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotSegmentPageSource.java", "diffHunk": "@@ -97,7 +105,13 @@ private static void checkExceptions(DataTable dataTable, PinotSplit split)\n             }\n         });\n         if (!exceptions.isEmpty()) {\n-            throw new PinotException(PinotErrorCode.PINOT_EXCEPTION, split.getSegmentPql(), String.format(\"Encountered %d pinot exceptions for split %s: %s\", exceptions.size(), split, exceptions));\n+            throw new PinotException(PINOT_EXCEPTION, split.getSegmentPql(), String.format(\"Encountered %d pinot exceptions for split %s: %s\", exceptions.size(), split, exceptions));\n+        }\n+        int columnsExpected = split.getExpectedColumnHandles().size();\n+        int columnsActual = dataTable.getDataSchema().size();\n+        if (columnsActual != columnsExpected) {\n+            throw new PinotException(PINOT_EXCEPTION, split.getSegmentPql(), String.format(", "originalCommit": "891d33a043ef59b2b5e95957a94ee2d535d8b5cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3MTg4NA==", "url": "https://github.com/prestodb/presto/pull/14456#discussion_r418371884", "bodyText": "new change :-)", "author": "agrawaldevesh", "createdAt": "2020-05-01T01:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzM4MQ=="}], "type": "inlineReview"}, {"oid": "7ddc0ecc6d30133236607a48ffb0cf49f98673ed", "url": "https://github.com/prestodb/presto/commit/7ddc0ecc6d30133236607a48ffb0cf49f98673ed", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-05-01T01:15:55Z", "type": "forcePushed"}, {"oid": "072d1e5fd089e6e3be0aeaab3f77d01d0eecfe59", "url": "https://github.com/prestodb/presto/commit/072d1e5fd089e6e3be0aeaab3f77d01d0eecfe59", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-05-01T01:19:14Z", "type": "forcePushed"}, {"oid": "e7d77cab08b7f3e8c7646aa997561d044fd4ef85", "url": "https://github.com/prestodb/presto/commit/e7d77cab08b7f3e8c7646aa997561d044fd4ef85", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-05-01T01:37:48Z", "type": "forcePushed"}, {"oid": "63a0b70f401c3615a3ea70e0c7d0e1a09f5ed21a", "url": "https://github.com/prestodb/presto/commit/63a0b70f401c3615a3ea70e0c7d0e1a09f5ed21a", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-05-01T18:07:18Z", "type": "commit"}, {"oid": "63a0b70f401c3615a3ea70e0c7d0e1a09f5ed21a", "url": "https://github.com/prestodb/presto/commit/63a0b70f401c3615a3ea70e0c7d0e1a09f5ed21a", "message": "Handle pruned columns in a pushed down pinot table scan\n\nAs an example, consider this query:\n```\nselect count(*) from baseballstats group by teamid limit 10\n```\n\nIn this query, the pinot connector sees the plan:\nProject (count) -> Limit 10 -> Aggregation (teamid, count(*)) -> Scan baseballstats.\n\nSince projections cannot currently be pushed on top of aggregations, so only the plan until the limit is pushed down. The resulting plan looks like: Project(count) -> Pushed table scan node with PQL: \"select count(*) from baseballstats group by teamid\". Note that the pushed table scan will emit \"teamid\" and \"count(*)\".\n\nPruneUnreferencedOptimizer runs next and removes the \"teamid\" from the scan node. This creates a problem: we are emitting an extra column teamid in the PinotBrokerPageSource which the scan does not need.\n\nThis PR attempts to handle this scenario: both in the broker and segment codepaths. It does so with a lot of plumbing: It remembers the original column handles when the PQL was generated in the PinotTableHandle. These are passed eventually to the page sources via the PinotSplit.\n\nThe page source then checks which columns can be ignored or have been re-ordered. The broker page source already had some support for this (necessitated by the _hiddenColumnSet_ for handling group-by without aggregations) and I have merely generalized this support. It was also trivial to add this support to the segment page source.\n\nAdded unit tests for these conditions in the pinot broker and segment page sources.", "committedDate": "2020-05-01T18:07:18Z", "type": "forcePushed"}]}