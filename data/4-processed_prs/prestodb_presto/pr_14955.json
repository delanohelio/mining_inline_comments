{"pr_number": 14955, "pr_title": "Push dereferences into table scan for parquet tables", "pr_createdAt": "2020-08-04T22:14:31Z", "pr_url": "https://github.com/prestodb/presto/pull/14955", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzAzMQ==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465447031", "bodyText": "static import checkArgument", "author": "zhenxiao", "createdAt": "2020-08-05T03:15:57Z", "path": "presto-hive-metastore/src/main/java/com/facebook/presto/hive/HiveType.java", "diffHunk": "@@ -303,4 +304,15 @@ public int getEstimatedRetainedSizeInBytes()\n         // Size of TypeInfo is not accounted as TypeInfo's are cached and retained by the TypeInfoFactory\n         return INSTANCE_SIZE + hiveTypeName.getEstimatedSizeInBytes();\n     }\n+\n+    public Optional<HiveType> findChildType(List<String> childPath)\n+    {\n+        TypeInfo typeInfo = getTypeInfo();\n+        for (String part : childPath) {\n+            Preconditions.checkArgument(typeInfo instanceof StructTypeInfo, \"typeinfo is not struct type\", typeInfo);", "originalCommit": "300cd8e153b2e187373baa732bc3c183191fb692", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzI5Mw==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465447293", "bodyText": "how about HiveDereferencePushDown? I think this is general for all formats, right?", "author": "zhenxiao", "createdAt": "2020-08-05T03:17:06Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.hive.NestedColumn;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.NESTED_COLUMN;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown", "originalCommit": "300cd8e153b2e187373baa732bc3c183191fb692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2OTgzOA==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465469838", "bodyText": "Currently this rule is applicable only for Parquet (there is check in the rule). Enabling it by default (without the storage type check) will cause issues if the reader is doesn't understand the HiveColumnHandle with NESTED_COLUMN type.", "author": "vkorukanti", "createdAt": "2020-08-05T04:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NzYzOA==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465447638", "bodyText": "improve the error message with \"expecting dereference expression, of type SpecialFormExpression with form DEREFERENCE\"", "author": "zhenxiao", "createdAt": "2020-08-05T03:18:31Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.hive.NestedColumn;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.NESTED_COLUMN;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown\n+        implements ConnectorPlanOptimizer\n+{\n+    private final HiveTransactionManager transactionManager;\n+    private final RowExpressionService rowExpressionService;\n+\n+    public HiveParquetDereferencePushDown(HiveTransactionManager transactionManager, RowExpressionService rowExpressionService)\n+    {\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.rowExpressionService = requireNonNull(rowExpressionService, \"rowExpressionService is null\");\n+    }\n+\n+    private static Map<RowExpression, NestedColumn> extractDereferences(ConnectorSession session, ExpressionOptimizer expressionOptimizer, Set<RowExpression> expressions)\n+    {\n+        Set<RowExpression> dereferenceAndVariableExprs = new HashSet<>();\n+        expressions.forEach(expr -> expr.accept(new ExtractDereferenceAndVariables(session, expressionOptimizer), dereferenceAndVariableExprs));\n+\n+        // keep prefix only expressions\n+        List<RowExpression> dereferences = dereferenceAndVariableExprs.stream()\n+                .filter(expression -> !prefixExists(expression, dereferenceAndVariableExprs))\n+                .filter(expression -> expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE)\n+                .collect(Collectors.toList());\n+\n+        return dereferences.stream().collect(toMap(identity(), dereference -> createNestedColumn(dereference, expressionOptimizer, session)));\n+    }\n+\n+    private static boolean prefixExists(RowExpression expression, Set<RowExpression> allExpressions)\n+    {\n+        int[] referenceCount = {0};\n+        expression.accept(\n+                new DefaultRowExpressionTraversalVisitor<int[]>()\n+                {\n+                    @Override\n+                    public Void visitSpecialForm(SpecialFormExpression specialForm, int[] context)\n+                    {\n+                        if (specialForm.getForm() != DEREFERENCE) {\n+                            return super.visitSpecialForm(specialForm, context);\n+                        }\n+\n+                        if (allExpressions.contains(specialForm)) {\n+                            referenceCount[0] += 1;\n+                        }\n+\n+                        RowExpression base = specialForm.getArguments().get(0);\n+                        base.accept(this, context);\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitVariableReference(VariableReferenceExpression reference, int[] context)\n+                    {\n+                        if (allExpressions.contains(reference)) {\n+                            referenceCount[0] += 1;\n+                        }\n+                        return null;\n+                    }\n+                }, referenceCount);\n+\n+        return referenceCount[0] > 1;\n+    }\n+\n+    private static NestedColumn createNestedColumn(RowExpression rowExpression, ExpressionOptimizer expressionOptimizer, ConnectorSession session)\n+    {\n+        if (!(rowExpression instanceof SpecialFormExpression) || ((SpecialFormExpression) rowExpression).getForm() != DEREFERENCE) {\n+            throw new IllegalArgumentException(\"invalid expression: \" + rowExpression);", "originalCommit": "300cd8e153b2e187373baa732bc3c183191fb692", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTg5Ng==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465455896", "bodyText": "I don't think we need this class as we already have Subfield", "author": "highker", "createdAt": "2020-08-05T03:51:40Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/NestedColumn.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class NestedColumn", "originalCommit": "300cd8e153b2e187373baa732bc3c183191fb692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MzI2NA==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465473264", "bodyText": "I initially used the Subfield class, but the there is already a member variable with list of needed Subfields in HiveColumnHandle. Rather than adding one more Subfield type member variable to represent the NESTED_COLUMN type definition, created this class which is looked at when the column type is NESTED_COLUMN in HiveColumnHandle. Also Subfield represents more than NestedColumn, it has index etc. Let me know if you think it is ok to use Subfield in this case.", "author": "vkorukanti", "createdAt": "2020-08-05T04:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NTAwNw==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465475007", "bodyText": "NESTED_COLUMN type doesn't fit into ColumnType. ColumnType is the attribute of that column instead of the structure. Why don't we merge the existing subfield together with the one you want in the optimizer rule? I assume you also need the subfield right?", "author": "highker", "createdAt": "2020-08-05T05:05:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4NDI3Nw==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465484277", "bodyText": "Currently the way Subfield in HiveColumnHandle is used is as a hint to the reader telling it to read only the required subfields from the complex column. The type (RowType) of the column from the reader doesn't change.\nFor example col of type RowType(int a, int b, int c). If only col.a is required the returned type is of column is still RowType(int a, int b, int c) but only the Block of a gets read and added to RowBlock. For the subcolumns b and c, RLEBlock is returned in RowBlock.\nIn this patch we are changing the output type to be the type of the nested column. In the same above example: col.a is selected, the reader just returns the IntBlock and the column name is a derived name. For this reason we added the new ColumnType as the reader interprets this column differently.\nWe can replace NestedColumn with Subfield, but the ColumnType(NESTED_COLUMN) is needed. May be rename the NESTED_COLUMN to SUBFIELD?", "author": "vkorukanti", "createdAt": "2020-08-05T05:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwMDg4Mg==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r465500882", "bodyText": "ColumnType should not denote the if a column is structured or not. It is to denote the attribute. A column could be a regular/synthesized column but still be nested. On a side question, I don't see NESTED_COLUMN is used in this commit? Did I miss anything?", "author": "highker", "createdAt": "2020-08-05T06:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NTYzNw==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r469055637", "bodyText": "@highker @zhenxiao  Here are the changes that we discussed offline.\n\ndon't add any new columnType type in HiveColumnHandle -- removed it\nremove NestedColumn class and use Subfield instead - done\npiggyback on List<Subfield> requiredSubfields to store the pushed down Nested column - unfortunately this has issues. This particular field is always populated when there is any Subfield type such as a[1].b. This type of Subfields are not handled in current Parquet reader. So we can't rely on this list being size 1 to convey to the Parquet reader that the Subfield in the list is a pushed down dereference. Instead of piggybacking on List<Subfield> requiredSubfields to store the pushed down, added a new field called Optional<Subfield> pushdownSubfield. This has no impact on existing readers.\n\nAlso added the remaining patches that implement the feature end-2-end including the pushdown of filters on dereference columns to Parquet reader.\nLet me know if there are any changes needed.", "author": "vkorukanti", "createdAt": "2020-08-12T07:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTg5Ng=="}], "type": "inlineReview"}, {"oid": "48594d2b3865dc4994909f6fd85b2039324dfb5e", "url": "https://github.com/prestodb/presto/commit/48594d2b3865dc4994909f6fd85b2039324dfb5e", "message": "Pushdown dereferences into table scan for parquet tables\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>", "committedDate": "2020-08-05T05:09:42Z", "type": "forcePushed"}, {"oid": "d4b3ccd6729e6863f96861df31d7faa7da4ebc26", "url": "https://github.com/prestodb/presto/commit/d4b3ccd6729e6863f96861df31d7faa7da4ebc26", "message": "RowGroup pruning using the filter on pushed down subfield\n\nOnce the dereference is pushed down to tablescan, filters on the dereference column\nare automatically pushed down to tablescan as the pushed down dereference column is\nexposed as a column directly coming from the tablescan. In the reader (this case\nParquet), interpret pushed down dereference columns and convert them to column paths\nto look up the stats in footer.\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>", "committedDate": "2020-08-12T07:07:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzODI5NA==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470438294", "bodyText": "line 313 to 317 could be:\ncheckArgument(pathElement instanceof Subfield.NestedField, ...);\nnestedColumnPathBuilder.add(((Subfield.NestedField) pathElement).getName());", "author": "zhenxiao", "createdAt": "2020-08-14T06:39:40Z", "path": "presto-parquet/src/main/java/com/facebook/presto/parquet/ParquetTypeUtils.java", "diffHunk": "@@ -304,4 +305,26 @@ public static MessageType getSubfieldType(GroupType baseType, Subfield subfield)\n         }\n         return new MessageType(rootName, ImmutableList.of(type));\n     }\n+\n+    public static List<String> nestedColumnPath(Subfield subfield)\n+    {\n+        ImmutableList.Builder<String> nestedColumnPathBuilder = ImmutableList.builder();\n+        for (Subfield.PathElement pathElement : subfield.getPath()) {\n+            if (pathElement instanceof Subfield.NestedField) {", "originalCommit": "ce75db45cfddd2fe6d378b354bb2822efa3674de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0MTY3MA==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470441670", "bodyText": "similar, line 635 to line 639:\ncheckArgument(pathElement instanceof NestedField, ...);\nnestedColumnPathBuilder.add(((NestedField) pathElement).getName());", "author": "zhenxiao", "createdAt": "2020-08-14T06:49:33Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HivePageSourceProvider.java", "diffHunk": "@@ -613,6 +627,20 @@ public int getIndex()\n             return columnMappings.build();\n         }\n \n+        private static Optional<HiveType> getHiveType(Optional<HiveType> baseType, Subfield subfield)\n+        {\n+            List<PathElement> pathElements = subfield.getPath();\n+            ImmutableList.Builder<String> nestedColumnPathBuilder = ImmutableList.builder();\n+            for (PathElement pathElement : pathElements) {\n+                if (pathElement instanceof NestedField) {", "originalCommit": "2c10790683a35e12f4cbdd7ee670a7b7680fedce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0MjQ1OA==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470442458", "bodyText": "simplify the logic, line 96 to 100:\nif (columnIO.isPresent()) {\n    fieldsBuilder.add(constructField(type, columnIO.get()));\n}\nelse {\n    fieldsBuilder.add(Optional.empty());\n}", "author": "zhenxiao", "createdAt": "2020-08-14T06:51:43Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/parquet/ParquetPageSource.java", "diffHunk": "@@ -77,15 +81,25 @@ public ParquetPageSource(\n         ImmutableList.Builder<Type> typesBuilder = ImmutableList.builder();\n         ImmutableList.Builder<Optional<Field>> fieldsBuilder = ImmutableList.builder();\n         for (HiveColumnHandle column : columns) {\n-            checkState(column.getColumnType() == REGULAR, \"column type must be regular\");\n+            checkState(column.getColumnType() == REGULAR, \"column type must be regular column\");\n \n             String name = column.getName();\n             Type type = typeManager.getType(column.getTypeSignature());\n \n             namesBuilder.add(name);\n             typesBuilder.add(type);\n \n-            if (getParquetType(type, fileSchema, useParquetColumnNames, column, tableName, path).isPresent()) {\n+            if (column.getPushdownSubfield().isPresent()) {\n+                Subfield pushdownSubfield = column.getPushdownSubfield().get();\n+                List<String> nestedColumnPath = nestedColumnPath(pushdownSubfield);\n+                Optional<ColumnIO> columnIO = findNestedColumnIO(lookupColumnByName(messageColumnIO, pushdownSubfield.getRootName()), nestedColumnPath);\n+                if (!columnIO.isPresent()) {", "originalCommit": "2c10790683a35e12f4cbdd7ee670a7b7680fedce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "526d917e4dbc1ad8f8769f8c72e7afb2c5f10577", "url": "https://github.com/prestodb/presto/commit/526d917e4dbc1ad8f8769f8c72e7afb2c5f10577", "message": "RowGroup pruning using the filter on pushed down subfield\n\nOnce the dereference is pushed down to tablescan, filters on the dereference column\nare automatically pushed down to tablescan as the pushed down dereference column is\nexposed as a column directly coming from the tablescan. In the reader (this case\nParquet), interpret pushed down dereference columns and convert them to column paths\nto look up the stats in footer.\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>", "committedDate": "2020-08-14T15:26:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1OTgwMg==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r469759802", "bodyText": "keep as is", "author": "highker", "createdAt": "2020-08-13T07:45:24Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveColumnHandle.java", "diffHunk": "@@ -57,7 +57,7 @@\n     {\n         PARTITION_KEY,\n         REGULAR,\n-        SYNTHESIZED,\n+        SYNTHESIZED", "originalCommit": "d4b3ccd6729e6863f96861df31d7faa7da4ebc26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyMTA0MQ==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470721041", "bodyText": "spell out Exprs", "author": "highker", "createdAt": "2020-08-14T16:13:57Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.Subfield;\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.REGULAR;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.parquet.ParquetTypeUtils.pushdownColumnNameForSubfield;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown\n+        implements ConnectorPlanOptimizer\n+{\n+    private final HiveTransactionManager transactionManager;\n+    private final RowExpressionService rowExpressionService;\n+\n+    public HiveParquetDereferencePushDown(HiveTransactionManager transactionManager, RowExpressionService rowExpressionService)\n+    {\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.rowExpressionService = requireNonNull(rowExpressionService, \"rowExpressionService is null\");\n+    }\n+\n+    private static Map<RowExpression, Subfield> extractDereferences(ConnectorSession session, ExpressionOptimizer expressionOptimizer, Set<RowExpression> expressions)\n+    {\n+        Set<RowExpression> dereferenceAndVariableExprs = new HashSet<>();", "originalCommit": "27f57a371c8e70df0b02b1e78840dc832197b5e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNjMyMw==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470736323", "bodyText": "I was under the impression that we gonna make such column \"SYNTHESIZED\"?", "author": "highker", "createdAt": "2020-08-14T16:44:09Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.Subfield;\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.REGULAR;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.parquet.ParquetTypeUtils.pushdownColumnNameForSubfield;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown\n+        implements ConnectorPlanOptimizer\n+{\n+    private final HiveTransactionManager transactionManager;\n+    private final RowExpressionService rowExpressionService;\n+\n+    public HiveParquetDereferencePushDown(HiveTransactionManager transactionManager, RowExpressionService rowExpressionService)\n+    {\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.rowExpressionService = requireNonNull(rowExpressionService, \"rowExpressionService is null\");\n+    }\n+\n+    private static Map<RowExpression, Subfield> extractDereferences(ConnectorSession session, ExpressionOptimizer expressionOptimizer, Set<RowExpression> expressions)\n+    {\n+        Set<RowExpression> dereferenceAndVariableExprs = new HashSet<>();\n+        expressions.forEach(expr -> expr.accept(new ExtractDereferenceAndVariables(session, expressionOptimizer), dereferenceAndVariableExprs));\n+\n+        // keep prefix only expressions\n+        List<RowExpression> dereferences = dereferenceAndVariableExprs.stream()\n+                .filter(expression -> !prefixExists(expression, dereferenceAndVariableExprs))\n+                .filter(expression -> expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE)\n+                .collect(Collectors.toList());\n+\n+        return dereferences.stream().collect(toMap(identity(), dereference -> createNestedColumn(dereference, expressionOptimizer, session)));\n+    }\n+\n+    private static boolean prefixExists(RowExpression expression, Set<RowExpression> allExpressions)\n+    {\n+        int[] referenceCount = {0};\n+        expression.accept(\n+                new DefaultRowExpressionTraversalVisitor<int[]>()\n+                {\n+                    @Override\n+                    public Void visitSpecialForm(SpecialFormExpression specialForm, int[] context)\n+                    {\n+                        if (specialForm.getForm() != DEREFERENCE) {\n+                            return super.visitSpecialForm(specialForm, context);\n+                        }\n+\n+                        if (allExpressions.contains(specialForm)) {\n+                            referenceCount[0] += 1;\n+                        }\n+\n+                        RowExpression base = specialForm.getArguments().get(0);\n+                        base.accept(this, context);\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitVariableReference(VariableReferenceExpression reference, int[] context)\n+                    {\n+                        if (allExpressions.contains(reference)) {\n+                            referenceCount[0] += 1;\n+                        }\n+                        return null;\n+                    }\n+                }, referenceCount);\n+\n+        return referenceCount[0] > 1;\n+    }\n+\n+    private static Subfield createNestedColumn(RowExpression rowExpression, ExpressionOptimizer expressionOptimizer, ConnectorSession session)\n+    {\n+        if (!(rowExpression instanceof SpecialFormExpression) || ((SpecialFormExpression) rowExpression).getForm() != DEREFERENCE) {\n+            throw new IllegalArgumentException(\"expecting SpecialFormExpression(DEREFERENCE), but got: \" + rowExpression);\n+        }\n+\n+        List<Subfield.PathElement> elements = new ArrayList<>();\n+        while (true) {\n+            if (rowExpression instanceof VariableReferenceExpression) {\n+                Collections.reverse(elements);\n+                return new Subfield(((VariableReferenceExpression) rowExpression).getName(), unmodifiableList(elements));\n+            }\n+\n+            if (rowExpression instanceof SpecialFormExpression && ((SpecialFormExpression) rowExpression).getForm() == DEREFERENCE) {\n+                SpecialFormExpression dereferenceExpression = (SpecialFormExpression) rowExpression;\n+                RowExpression base = dereferenceExpression.getArguments().get(0);\n+                RowType baseType = (RowType) base.getType();\n+\n+                RowExpression indexExpression = expressionOptimizer.optimize(\n+                        dereferenceExpression.getArguments().get(1),\n+                        ExpressionOptimizer.Level.OPTIMIZED,\n+                        session);\n+\n+                if (indexExpression instanceof ConstantExpression) {\n+                    Object index = ((ConstantExpression) indexExpression).getValue();\n+                    if (index instanceof Number) {\n+                        Optional<String> fieldName = baseType.getFields().get(((Number) index).intValue()).getName();\n+                        if (fieldName.isPresent()) {\n+                            elements.add(new Subfield.NestedField(fieldName.get()));\n+                            rowExpression = base;\n+                            continue;\n+                        }\n+                    }\n+                }\n+            }\n+            break;\n+        }\n+\n+        throw new IllegalArgumentException(\"expecting SpecialFormExpression(DEREFERENCE) with constants for indices, but got: \" + rowExpression);\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan, ConnectorSession session, VariableAllocator variableAllocator, PlanNodeIdAllocator idAllocator)\n+    {\n+        return maxSubplan.accept(new Visitor(session, variableAllocator, idAllocator), null);\n+    }\n+\n+    private boolean isParquetDereferenceEnabled(ConnectorSession session, TableHandle tableHandle)\n+    {\n+        checkArgument(tableHandle.getConnectorHandle() instanceof HiveTableHandle, \"Dereference pushdown into reader is not supported on a non-hive TableHandle\");\n+\n+        if (!isParquetDereferencePushdownEnabled(session)) {\n+            return false;\n+        }\n+\n+        return PARQUET == getHiveStorageFormat(getMetadata(tableHandle).getTableMetadata(session, tableHandle.getConnectorHandle()).getProperties());\n+    }\n+\n+    protected HiveMetadata getMetadata(TableHandle tableHandle)\n+    {\n+        ConnectorMetadata metadata = transactionManager.get(tableHandle.getTransaction());\n+        checkState(metadata instanceof HiveMetadata, \"metadata must be HiveMetadata\");\n+        return (HiveMetadata) metadata;\n+    }\n+\n+    /**\n+     * Visitor to extract all dereference expressions and variable references.\n+     * <p>\n+     * If a dereference expression contains dereference expression, inner dereference expression are not returned\n+     * * sub(deref(deref(x, 1), 2)) --> deref(deref(x,1), 2)\n+     * Variable expressions returned are the ones not referenced by the dereference expressions\n+     * * sub(x + 1) --> x\n+     * * sub(deref(x, 1)) -> deref(x,1)\n+     */\n+    private static class ExtractDereferenceAndVariables\n+            extends DefaultRowExpressionTraversalVisitor<Set<RowExpression>>\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final ExpressionOptimizer expressionOptimizer;\n+\n+        public ExtractDereferenceAndVariables(ConnectorSession connectorSession, ExpressionOptimizer expressionOptimizer)\n+        {\n+            this.connectorSession = connectorSession;\n+            this.expressionOptimizer = expressionOptimizer;\n+        }\n+\n+        @Override\n+        public Void visitSpecialForm(SpecialFormExpression specialForm, Set<RowExpression> context)\n+        {\n+            if (specialForm.getForm() != DEREFERENCE) {\n+                return super.visitSpecialForm(specialForm, context);\n+            }\n+\n+            RowExpression expression = specialForm;\n+            while (true) {\n+                if (expression instanceof VariableReferenceExpression) {\n+                    context.add(specialForm);\n+                    return null;\n+                }\n+\n+                if (expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE) {\n+                    SpecialFormExpression dereferenceExpression = (SpecialFormExpression) expression;\n+                    RowExpression base = dereferenceExpression.getArguments().get(0);\n+                    RowType baseType = (RowType) base.getType();\n+\n+                    RowExpression indexExpression = expressionOptimizer.optimize(\n+                            dereferenceExpression.getArguments().get(1),\n+                            ExpressionOptimizer.Level.OPTIMIZED,\n+                            connectorSession);\n+\n+                    if (indexExpression instanceof ConstantExpression) {\n+                        Object index = ((ConstantExpression) indexExpression).getValue();\n+                        if (index instanceof Number) {\n+                            Optional<String> fieldName = baseType.getFields().get(((Number) index).intValue()).getName();\n+                            if (fieldName.isPresent()) {\n+                                expression = base;\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+            }\n+\n+            return super.visitSpecialForm(specialForm, context);\n+        }\n+\n+        @Override\n+        public Void visitVariableReference(VariableReferenceExpression reference, Set<RowExpression> context)\n+        {\n+            context.add(reference);\n+            return null;\n+        }\n+    }\n+\n+    private static class DereferenceExpressionRewriter\n+            extends RowExpressionRewriter<Void>\n+    {\n+        private final Map<RowExpression, VariableReferenceExpression> dereferenceMap;\n+\n+        public DereferenceExpressionRewriter(Map<RowExpression, VariableReferenceExpression> dereferenceMap)\n+        {\n+            this.dereferenceMap = dereferenceMap;\n+        }\n+\n+        @Override\n+        public RowExpression rewriteSpecialForm(SpecialFormExpression node, Void context, RowExpressionTreeRewriter<Void> treeRewriter)\n+        {\n+            return dereferenceMap.get(node);\n+        }\n+    }\n+\n+    /**\n+     * Looks for ProjectNode -> TableScanNode patterns. Goes through the project expressions to extract out the DEREFERENCE expressions,\n+     * pushes the dereferences down to TableScan and creates new project expressions with the pushed down column coming from the TableScan.\n+     * Returned plan nodes could contain unreferenced outputs which will be pruned later in the planning process.\n+     */\n+    private class Visitor\n+            extends PlanVisitor<PlanNode, Void>\n+    {\n+        private final ConnectorSession session;\n+        private final VariableAllocator variableAllocator;\n+        private final PlanNodeIdAllocator idAllocator;\n+\n+        Visitor(ConnectorSession session, VariableAllocator variableAllocator, PlanNodeIdAllocator idAllocator)\n+        {\n+            this.session = requireNonNull(session, \"session is null\");\n+            this.variableAllocator = requireNonNull(variableAllocator, \"variableAllocator is null\");\n+            this.idAllocator = requireNonNull(idAllocator, \"idAllocator is null\");\n+        }\n+\n+        @Override\n+        public PlanNode visitPlan(PlanNode node, Void context)\n+        {\n+            ImmutableList.Builder<PlanNode> children = ImmutableList.builder();\n+            boolean changed = false;\n+            for (PlanNode child : node.getSources()) {\n+                PlanNode newChild = child.accept(this, null);\n+                if (newChild != child) {\n+                    changed = true;\n+                }\n+                children.add(newChild);\n+            }\n+\n+            if (!changed) {\n+                return node;\n+            }\n+            return node.replaceChildren(children.build());\n+        }\n+\n+        @Override\n+        public PlanNode visitProject(ProjectNode project, Void context)\n+        {\n+            if (!(project.getSource() instanceof TableScanNode)) {\n+                return visitPlan(project, context);\n+            }\n+\n+            TableScanNode tableScan = (TableScanNode) project.getSource();\n+            if (!isParquetDereferenceEnabled(session, tableScan.getTable())) {\n+                return visitPlan(project, context);\n+            }\n+\n+            Map<RowExpression, Subfield> dereferenceToNestedColumnMap = extractDereferences(\n+                    session,\n+                    rowExpressionService.getExpressionOptimizer(),\n+                    new HashSet<>(project.getAssignments().getExpressions()));\n+            if (dereferenceToNestedColumnMap.isEmpty()) {\n+                return visitPlan(project, context);\n+            }\n+\n+            Map<String, HiveColumnHandle> regularHiveColumnHandles = tableScan.getAssignments().values().stream()\n+                    .map(columnHandle -> (HiveColumnHandle) columnHandle)\n+                    .collect(toMap(HiveColumnHandle::getName, identity()));\n+\n+            List<VariableReferenceExpression> newOutputVariables = new ArrayList<>(tableScan.getOutputVariables());\n+            Map<VariableReferenceExpression, ColumnHandle> newAssignments = new HashMap<>(tableScan.getAssignments());\n+\n+            Map<RowExpression, VariableReferenceExpression> dereferenceToVariableMap = new HashMap<>();\n+\n+            for (Map.Entry<RowExpression, Subfield> dereference : dereferenceToNestedColumnMap.entrySet()) {\n+                Subfield nestedColumn = dereference.getValue();\n+                RowExpression dereferenceExpression = dereference.getKey();\n+\n+                // Find the nested column Hive Type\n+                HiveColumnHandle regularColumnHandle = regularHiveColumnHandles.get(nestedColumn.getRootName());\n+                if (regularColumnHandle == null) {\n+                    throw new IllegalArgumentException(\"nested column [\" + nestedColumn + \"]'s base column \" + nestedColumn.getRootName() + \" is not present in table scan output\");\n+                }\n+\n+                Optional<HiveType> nestedColumnHiveType = regularHiveColumnHandles.get(nestedColumn.getRootName())\n+                        .getHiveType()\n+                        .findChildType(\n+                                nestedColumn.getPath().stream()\n+                                        .map(p -> ((Subfield.NestedField) p).getName())\n+                                        .collect(Collectors.toList()));\n+\n+                if (!nestedColumnHiveType.isPresent()) {\n+                    throw new IllegalArgumentException(\"nested column [\" + nestedColumn + \"] type is not present in Hive column type\");\n+                }\n+\n+                String pushdownColumnName = pushdownColumnNameForSubfield(nestedColumn);\n+                // Create column handle for nested column\n+                HiveColumnHandle nestedColumnHandle = new HiveColumnHandle(\n+                        pushdownColumnName,\n+                        nestedColumnHiveType.get(),\n+                        dereferenceExpression.getType().getTypeSignature(),\n+                        -1,\n+                        REGULAR,", "originalCommit": "526d917e4dbc1ad8f8769f8c72e7afb2c5f10577", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNjg0MA==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470736840", "bodyText": "If we have this to be \"SYNTHESIZED\", then we don't need two subfields variables here. We just use one. The SYNTHESIZED one is to denote parquet pushdown and the regular one for selective page source.", "author": "highker", "createdAt": "2020-08-14T16:45:10Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/rule/HiveParquetDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.hive.rule;\n+\n+import com.facebook.presto.common.Subfield;\n+import com.facebook.presto.common.type.RowType;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.hive.HiveColumnHandle;\n+import com.facebook.presto.hive.HiveMetadata;\n+import com.facebook.presto.hive.HiveTableHandle;\n+import com.facebook.presto.hive.HiveTransactionManager;\n+import com.facebook.presto.hive.HiveType;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.connector.ConnectorMetadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.ExpressionOptimizer;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.RowExpressionService;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.hive.HiveColumnHandle.ColumnType.REGULAR;\n+import static com.facebook.presto.hive.HiveSessionProperties.isParquetDereferencePushdownEnabled;\n+import static com.facebook.presto.hive.HiveStorageFormat.PARQUET;\n+import static com.facebook.presto.hive.HiveTableProperties.getHiveStorageFormat;\n+import static com.facebook.presto.parquet.ParquetTypeUtils.pushdownColumnNameForSubfield;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class HiveParquetDereferencePushDown\n+        implements ConnectorPlanOptimizer\n+{\n+    private final HiveTransactionManager transactionManager;\n+    private final RowExpressionService rowExpressionService;\n+\n+    public HiveParquetDereferencePushDown(HiveTransactionManager transactionManager, RowExpressionService rowExpressionService)\n+    {\n+        this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n+        this.rowExpressionService = requireNonNull(rowExpressionService, \"rowExpressionService is null\");\n+    }\n+\n+    private static Map<RowExpression, Subfield> extractDereferences(ConnectorSession session, ExpressionOptimizer expressionOptimizer, Set<RowExpression> expressions)\n+    {\n+        Set<RowExpression> dereferenceAndVariableExprs = new HashSet<>();\n+        expressions.forEach(expr -> expr.accept(new ExtractDereferenceAndVariables(session, expressionOptimizer), dereferenceAndVariableExprs));\n+\n+        // keep prefix only expressions\n+        List<RowExpression> dereferences = dereferenceAndVariableExprs.stream()\n+                .filter(expression -> !prefixExists(expression, dereferenceAndVariableExprs))\n+                .filter(expression -> expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE)\n+                .collect(Collectors.toList());\n+\n+        return dereferences.stream().collect(toMap(identity(), dereference -> createNestedColumn(dereference, expressionOptimizer, session)));\n+    }\n+\n+    private static boolean prefixExists(RowExpression expression, Set<RowExpression> allExpressions)\n+    {\n+        int[] referenceCount = {0};\n+        expression.accept(\n+                new DefaultRowExpressionTraversalVisitor<int[]>()\n+                {\n+                    @Override\n+                    public Void visitSpecialForm(SpecialFormExpression specialForm, int[] context)\n+                    {\n+                        if (specialForm.getForm() != DEREFERENCE) {\n+                            return super.visitSpecialForm(specialForm, context);\n+                        }\n+\n+                        if (allExpressions.contains(specialForm)) {\n+                            referenceCount[0] += 1;\n+                        }\n+\n+                        RowExpression base = specialForm.getArguments().get(0);\n+                        base.accept(this, context);\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitVariableReference(VariableReferenceExpression reference, int[] context)\n+                    {\n+                        if (allExpressions.contains(reference)) {\n+                            referenceCount[0] += 1;\n+                        }\n+                        return null;\n+                    }\n+                }, referenceCount);\n+\n+        return referenceCount[0] > 1;\n+    }\n+\n+    private static Subfield createNestedColumn(RowExpression rowExpression, ExpressionOptimizer expressionOptimizer, ConnectorSession session)\n+    {\n+        if (!(rowExpression instanceof SpecialFormExpression) || ((SpecialFormExpression) rowExpression).getForm() != DEREFERENCE) {\n+            throw new IllegalArgumentException(\"expecting SpecialFormExpression(DEREFERENCE), but got: \" + rowExpression);\n+        }\n+\n+        List<Subfield.PathElement> elements = new ArrayList<>();\n+        while (true) {\n+            if (rowExpression instanceof VariableReferenceExpression) {\n+                Collections.reverse(elements);\n+                return new Subfield(((VariableReferenceExpression) rowExpression).getName(), unmodifiableList(elements));\n+            }\n+\n+            if (rowExpression instanceof SpecialFormExpression && ((SpecialFormExpression) rowExpression).getForm() == DEREFERENCE) {\n+                SpecialFormExpression dereferenceExpression = (SpecialFormExpression) rowExpression;\n+                RowExpression base = dereferenceExpression.getArguments().get(0);\n+                RowType baseType = (RowType) base.getType();\n+\n+                RowExpression indexExpression = expressionOptimizer.optimize(\n+                        dereferenceExpression.getArguments().get(1),\n+                        ExpressionOptimizer.Level.OPTIMIZED,\n+                        session);\n+\n+                if (indexExpression instanceof ConstantExpression) {\n+                    Object index = ((ConstantExpression) indexExpression).getValue();\n+                    if (index instanceof Number) {\n+                        Optional<String> fieldName = baseType.getFields().get(((Number) index).intValue()).getName();\n+                        if (fieldName.isPresent()) {\n+                            elements.add(new Subfield.NestedField(fieldName.get()));\n+                            rowExpression = base;\n+                            continue;\n+                        }\n+                    }\n+                }\n+            }\n+            break;\n+        }\n+\n+        throw new IllegalArgumentException(\"expecting SpecialFormExpression(DEREFERENCE) with constants for indices, but got: \" + rowExpression);\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan, ConnectorSession session, VariableAllocator variableAllocator, PlanNodeIdAllocator idAllocator)\n+    {\n+        return maxSubplan.accept(new Visitor(session, variableAllocator, idAllocator), null);\n+    }\n+\n+    private boolean isParquetDereferenceEnabled(ConnectorSession session, TableHandle tableHandle)\n+    {\n+        checkArgument(tableHandle.getConnectorHandle() instanceof HiveTableHandle, \"Dereference pushdown into reader is not supported on a non-hive TableHandle\");\n+\n+        if (!isParquetDereferencePushdownEnabled(session)) {\n+            return false;\n+        }\n+\n+        return PARQUET == getHiveStorageFormat(getMetadata(tableHandle).getTableMetadata(session, tableHandle.getConnectorHandle()).getProperties());\n+    }\n+\n+    protected HiveMetadata getMetadata(TableHandle tableHandle)\n+    {\n+        ConnectorMetadata metadata = transactionManager.get(tableHandle.getTransaction());\n+        checkState(metadata instanceof HiveMetadata, \"metadata must be HiveMetadata\");\n+        return (HiveMetadata) metadata;\n+    }\n+\n+    /**\n+     * Visitor to extract all dereference expressions and variable references.\n+     * <p>\n+     * If a dereference expression contains dereference expression, inner dereference expression are not returned\n+     * * sub(deref(deref(x, 1), 2)) --> deref(deref(x,1), 2)\n+     * Variable expressions returned are the ones not referenced by the dereference expressions\n+     * * sub(x + 1) --> x\n+     * * sub(deref(x, 1)) -> deref(x,1)\n+     */\n+    private static class ExtractDereferenceAndVariables\n+            extends DefaultRowExpressionTraversalVisitor<Set<RowExpression>>\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final ExpressionOptimizer expressionOptimizer;\n+\n+        public ExtractDereferenceAndVariables(ConnectorSession connectorSession, ExpressionOptimizer expressionOptimizer)\n+        {\n+            this.connectorSession = connectorSession;\n+            this.expressionOptimizer = expressionOptimizer;\n+        }\n+\n+        @Override\n+        public Void visitSpecialForm(SpecialFormExpression specialForm, Set<RowExpression> context)\n+        {\n+            if (specialForm.getForm() != DEREFERENCE) {\n+                return super.visitSpecialForm(specialForm, context);\n+            }\n+\n+            RowExpression expression = specialForm;\n+            while (true) {\n+                if (expression instanceof VariableReferenceExpression) {\n+                    context.add(specialForm);\n+                    return null;\n+                }\n+\n+                if (expression instanceof SpecialFormExpression && ((SpecialFormExpression) expression).getForm() == DEREFERENCE) {\n+                    SpecialFormExpression dereferenceExpression = (SpecialFormExpression) expression;\n+                    RowExpression base = dereferenceExpression.getArguments().get(0);\n+                    RowType baseType = (RowType) base.getType();\n+\n+                    RowExpression indexExpression = expressionOptimizer.optimize(\n+                            dereferenceExpression.getArguments().get(1),\n+                            ExpressionOptimizer.Level.OPTIMIZED,\n+                            connectorSession);\n+\n+                    if (indexExpression instanceof ConstantExpression) {\n+                        Object index = ((ConstantExpression) indexExpression).getValue();\n+                        if (index instanceof Number) {\n+                            Optional<String> fieldName = baseType.getFields().get(((Number) index).intValue()).getName();\n+                            if (fieldName.isPresent()) {\n+                                expression = base;\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+                break;\n+            }\n+\n+            return super.visitSpecialForm(specialForm, context);\n+        }\n+\n+        @Override\n+        public Void visitVariableReference(VariableReferenceExpression reference, Set<RowExpression> context)\n+        {\n+            context.add(reference);\n+            return null;\n+        }\n+    }\n+\n+    private static class DereferenceExpressionRewriter\n+            extends RowExpressionRewriter<Void>\n+    {\n+        private final Map<RowExpression, VariableReferenceExpression> dereferenceMap;\n+\n+        public DereferenceExpressionRewriter(Map<RowExpression, VariableReferenceExpression> dereferenceMap)\n+        {\n+            this.dereferenceMap = dereferenceMap;\n+        }\n+\n+        @Override\n+        public RowExpression rewriteSpecialForm(SpecialFormExpression node, Void context, RowExpressionTreeRewriter<Void> treeRewriter)\n+        {\n+            return dereferenceMap.get(node);\n+        }\n+    }\n+\n+    /**\n+     * Looks for ProjectNode -> TableScanNode patterns. Goes through the project expressions to extract out the DEREFERENCE expressions,\n+     * pushes the dereferences down to TableScan and creates new project expressions with the pushed down column coming from the TableScan.\n+     * Returned plan nodes could contain unreferenced outputs which will be pruned later in the planning process.\n+     */\n+    private class Visitor\n+            extends PlanVisitor<PlanNode, Void>\n+    {\n+        private final ConnectorSession session;\n+        private final VariableAllocator variableAllocator;\n+        private final PlanNodeIdAllocator idAllocator;\n+\n+        Visitor(ConnectorSession session, VariableAllocator variableAllocator, PlanNodeIdAllocator idAllocator)\n+        {\n+            this.session = requireNonNull(session, \"session is null\");\n+            this.variableAllocator = requireNonNull(variableAllocator, \"variableAllocator is null\");\n+            this.idAllocator = requireNonNull(idAllocator, \"idAllocator is null\");\n+        }\n+\n+        @Override\n+        public PlanNode visitPlan(PlanNode node, Void context)\n+        {\n+            ImmutableList.Builder<PlanNode> children = ImmutableList.builder();\n+            boolean changed = false;\n+            for (PlanNode child : node.getSources()) {\n+                PlanNode newChild = child.accept(this, null);\n+                if (newChild != child) {\n+                    changed = true;\n+                }\n+                children.add(newChild);\n+            }\n+\n+            if (!changed) {\n+                return node;\n+            }\n+            return node.replaceChildren(children.build());\n+        }\n+\n+        @Override\n+        public PlanNode visitProject(ProjectNode project, Void context)\n+        {\n+            if (!(project.getSource() instanceof TableScanNode)) {\n+                return visitPlan(project, context);\n+            }\n+\n+            TableScanNode tableScan = (TableScanNode) project.getSource();\n+            if (!isParquetDereferenceEnabled(session, tableScan.getTable())) {\n+                return visitPlan(project, context);\n+            }\n+\n+            Map<RowExpression, Subfield> dereferenceToNestedColumnMap = extractDereferences(\n+                    session,\n+                    rowExpressionService.getExpressionOptimizer(),\n+                    new HashSet<>(project.getAssignments().getExpressions()));\n+            if (dereferenceToNestedColumnMap.isEmpty()) {\n+                return visitPlan(project, context);\n+            }\n+\n+            Map<String, HiveColumnHandle> regularHiveColumnHandles = tableScan.getAssignments().values().stream()\n+                    .map(columnHandle -> (HiveColumnHandle) columnHandle)\n+                    .collect(toMap(HiveColumnHandle::getName, identity()));\n+\n+            List<VariableReferenceExpression> newOutputVariables = new ArrayList<>(tableScan.getOutputVariables());\n+            Map<VariableReferenceExpression, ColumnHandle> newAssignments = new HashMap<>(tableScan.getAssignments());\n+\n+            Map<RowExpression, VariableReferenceExpression> dereferenceToVariableMap = new HashMap<>();\n+\n+            for (Map.Entry<RowExpression, Subfield> dereference : dereferenceToNestedColumnMap.entrySet()) {\n+                Subfield nestedColumn = dereference.getValue();\n+                RowExpression dereferenceExpression = dereference.getKey();\n+\n+                // Find the nested column Hive Type\n+                HiveColumnHandle regularColumnHandle = regularHiveColumnHandles.get(nestedColumn.getRootName());\n+                if (regularColumnHandle == null) {\n+                    throw new IllegalArgumentException(\"nested column [\" + nestedColumn + \"]'s base column \" + nestedColumn.getRootName() + \" is not present in table scan output\");\n+                }\n+\n+                Optional<HiveType> nestedColumnHiveType = regularHiveColumnHandles.get(nestedColumn.getRootName())\n+                        .getHiveType()\n+                        .findChildType(\n+                                nestedColumn.getPath().stream()\n+                                        .map(p -> ((Subfield.NestedField) p).getName())\n+                                        .collect(Collectors.toList()));\n+\n+                if (!nestedColumnHiveType.isPresent()) {\n+                    throw new IllegalArgumentException(\"nested column [\" + nestedColumn + \"] type is not present in Hive column type\");\n+                }\n+\n+                String pushdownColumnName = pushdownColumnNameForSubfield(nestedColumn);\n+                // Create column handle for nested column\n+                HiveColumnHandle nestedColumnHandle = new HiveColumnHandle(\n+                        pushdownColumnName,\n+                        nestedColumnHiveType.get(),\n+                        dereferenceExpression.getType().getTypeSignature(),\n+                        -1,\n+                        REGULAR,\n+                        Optional.of(\"nested column pushdown\"),\n+                        ImmutableList.of(),\n+                        Optional.of(nestedColumn));", "originalCommit": "526d917e4dbc1ad8f8769f8c72e7afb2c5f10577", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNzMxMw==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470737313", "bodyText": "We can reuse requiredSubfields instead of introducing a new field. Use SYNTHESIZED to distinguish the difference. Let me know if this approach will miss anything.", "author": "highker", "createdAt": "2020-08-14T16:46:04Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveColumnHandle.java", "diffHunk": "@@ -67,6 +67,7 @@\n     private final ColumnType columnType;\n     private final Optional<String> comment;\n     private final List<Subfield> requiredSubfields;\n+    private final Optional<Subfield> pushdownSubfield;", "originalCommit": "526d917e4dbc1ad8f8769f8c72e7afb2c5f10577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgxNjg0NQ==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470816845", "bodyText": "Made the change to use columnType as SYNTHESIZED and use requiredSubfield to store the pushed down Subfield.\nThere was one change I had to make in HiveColumnHandle.withRequiredSubfields where we have to check if the column is already a pushed down subfield. If it is then don't store the requiredSubfields (this gets called from PushdownSubfields rule, specifically for the case arbitrary(x.a).b where SubfieldPushdowns is trying to give an hint to reader that only b under column x.a is needed. This is a special handling done as part of the a123e5c.", "author": "vkorukanti", "createdAt": "2020-08-14T19:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNzMxMw=="}], "type": "inlineReview"}, {"oid": "fbbfb72ee480ca9cd01532649b3daa3de3af0a59", "url": "https://github.com/prestodb/presto/commit/fbbfb72ee480ca9cd01532649b3daa3de3af0a59", "message": "Add an option to control Parquet dereferance pushdown", "committedDate": "2020-08-14T19:05:47Z", "type": "commit"}, {"oid": "6cfdd172065bebb8b47e34597811cbc435670995", "url": "https://github.com/prestodb/presto/commit/6cfdd172065bebb8b47e34597811cbc435670995", "message": "Pushdown dereferences into table scan for parquet tables\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>", "committedDate": "2020-08-14T19:05:47Z", "type": "commit"}, {"oid": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "url": "https://github.com/prestodb/presto/commit/c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "message": "Use SYNTHESIZED type to represent pushed down Subfield in HiveColumnHandle", "committedDate": "2020-08-14T19:05:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDI2NQ==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470860265", "bodyText": "one param per line and leave the first line empty", "author": "highker", "createdAt": "2020-08-14T20:54:03Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -1079,6 +1243,17 @@ private static PlanMatchPattern tableScan(String expectedTableName, Map<String,\n         return PlanMatchPattern.tableScan(expectedTableName).with(new HiveTableScanMatcher(expectedRequiredSubfields));\n     }\n \n+    private static PlanMatchPattern tableScanParquetDeferencePushDowns(String expectedTableName, Map<String, Subfield> expectedDeferencePushDowns)\n+    {\n+        return PlanMatchPattern.tableScan(expectedTableName).with(new HiveParquetDereferencePushdownMatcher(expectedDeferencePushDowns, TupleDomain.all(), ImmutableSet.of(), TRUE_CONSTANT));\n+    }\n+\n+    private static PlanMatchPattern tableScanParquetDeferencePushDowns(String expectedTableName, Map<String, Subfield> expectedDeferencePushDowns,\n+            TupleDomain<String> domainPredicate, Set<String> predicateColumns, RowExpression remainingPredicate)", "originalCommit": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDM3Mw==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470860373", "bodyText": "same", "author": "highker", "createdAt": "2020-08-14T20:54:23Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -1097,6 +1272,23 @@ private void assertPushdownFilterOnSubfields(String query, Map<Subfield, Domain>\n                         predicateDomains.keySet().stream().map(Subfield::getRootName).collect(toImmutableSet())));\n     }\n \n+    private void assertParquetDereferencePushDown(String query, String tableName, Map<String, Subfield> expectedDeferencePushDowns)\n+    {\n+        assertParquetDereferencePushDown(withParquetDereferencePushDownEnabled(), query, tableName, expectedDeferencePushDowns);\n+    }\n+\n+    private void assertParquetDereferencePushDown(String query, String tableName, Map<String, Subfield> expectedDeferencePushDowns, TupleDomain<String> domainPredicate,\n+            Set<String> predicateColumns, RowExpression remainingPredicate)", "originalCommit": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDQyNA==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470860424", "bodyText": "same", "author": "highker", "createdAt": "2020-08-14T20:54:30Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -1097,6 +1272,23 @@ private void assertPushdownFilterOnSubfields(String query, Map<Subfield, Domain>\n                         predicateDomains.keySet().stream().map(Subfield::getRootName).collect(toImmutableSet())));\n     }\n \n+    private void assertParquetDereferencePushDown(String query, String tableName, Map<String, Subfield> expectedDeferencePushDowns)\n+    {\n+        assertParquetDereferencePushDown(withParquetDereferencePushDownEnabled(), query, tableName, expectedDeferencePushDowns);\n+    }\n+\n+    private void assertParquetDereferencePushDown(String query, String tableName, Map<String, Subfield> expectedDeferencePushDowns, TupleDomain<String> domainPredicate,\n+            Set<String> predicateColumns, RowExpression remainingPredicate)\n+    {\n+        assertPlan(withParquetDereferencePushDownEnabled(), query,\n+                anyTree(tableScanParquetDeferencePushDowns(tableName, expectedDeferencePushDowns, domainPredicate, predicateColumns, remainingPredicate)));", "originalCommit": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDcyMw==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470860723", "bodyText": "Make sure all these functions are with one parameter per line with the first line empty.", "author": "highker", "createdAt": "2020-08-14T20:55:07Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -953,6 +963,160 @@ public void testPushdownSubfieldsAndJoinReordering()\n         }\n     }\n \n+    @Test\n+    public void testParquetDereferencePushDown()\n+    {\n+        assertUpdate(\"CREATE TABLE test_pushdown_nestedcolumn_parquet(\" +\n+                \"id bigint, \" +\n+                \"x row(a bigint, b varchar, c double, d row(d1 bigint, d2 double)),\" +\n+                \"y array(row(a bigint, b varchar, c double, d row(d1 bigint, d2 double)))) \" +\n+                \"with (format = 'PARQUET')\");\n+\n+        assertParquetDereferencePushDown(\"SELECT x.a FROM test_pushdown_nestedcolumn_parquet\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT x.a, mod(x.d.d1, 2) FROM test_pushdown_nestedcolumn_parquet\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.d.d1\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT x.d, mod(x.d.d1, 2), x.d.d2 FROM test_pushdown_nestedcolumn_parquet\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT x.a FROM test_pushdown_nestedcolumn_parquet WHERE x.b LIKE 'abc%'\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.b\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT x.a FROM test_pushdown_nestedcolumn_parquet WHERE x.a > 10 AND x.b LIKE 'abc%'\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.b\"),\n+                withColumnDomains(ImmutableMap.of(pushdownColumnNameForSubfield(nestedColumn(\"x.a\")), create(ofRanges(greaterThan(BIGINT, 10L)), false))),\n+                ImmutableSet.of(pushdownColumnNameForSubfield(nestedColumn(\"x.a\"))),\n+                TRUE_CONSTANT);\n+\n+        // Join\n+        assertPlan(withParquetDereferencePushDownEnabled(), \"SELECT l.orderkey, x.a, mod(x.d.d1, 2) FROM lineitem l, test_pushdown_nestedcolumn_parquet a WHERE l.linenumber = a.id\",\n+                anyTree(\n+                        node(JoinNode.class,\n+                                anyTree(tableScan(\"lineitem\", ImmutableMap.of())),\n+                                anyTree(tableScanParquetDeferencePushDowns(\"test_pushdown_nestedcolumn_parquet\", nestedColumnMap(\"x.a\", \"x.d.d1\"))))));\n+\n+        assertPlan(withParquetDereferencePushDownEnabled(), \"SELECT l.orderkey, x.a, mod(x.d.d1, 2) FROM lineitem l, test_pushdown_nestedcolumn_parquet a WHERE l.linenumber = a.id AND x.a > 10\",\n+                anyTree(\n+                        node(JoinNode.class,\n+                                anyTree(tableScan(\"lineitem\", ImmutableMap.of())),\n+                                anyTree(tableScanParquetDeferencePushDowns(\n+                                        \"test_pushdown_nestedcolumn_parquet\",\n+                                        nestedColumnMap(\"x.a\", \"x.d.d1\"),\n+                                        withColumnDomains(ImmutableMap.of(pushdownColumnNameForSubfield(nestedColumn(\"x.a\")), create(ofRanges(greaterThan(BIGINT, 10L)), false))),\n+                                        ImmutableSet.of(pushdownColumnNameForSubfield(nestedColumn(\"x.a\"))),\n+                                        TRUE_CONSTANT)))));\n+        // Aggregation\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.a) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, min(mod(x.a, 3)) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.a) FILTER (WHERE x.b LIKE 'abc%') FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.b\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.a + 1) * avg(x.d.d1) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.d.d1\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, arbitrary(x.a) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        // Dereference can't be pushed down, but the subfield pushdown will help in pruning the number of columns to read\n+        assertPushdownSubfields(\"SELECT id, arbitrary(x.a) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                ImmutableMap.of(\"x\", toSubfields(\"x.a\")));\n+\n+        // Dereference can't be pushed down, but the subfield pushdown will help in pruning the number of columns to read\n+        assertPushdownSubfields(\"SELECT id, arbitrary(x).d.d1 FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                ImmutableMap.of(\"x\", toSubfields(\"x.d.d1\")));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, arbitrary(x.d).d1 FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, arbitrary(x.d.d2) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d.d2\"));\n+\n+        // Unnest\n+        assertParquetDereferencePushDown(\"SELECT t.a, t.d.d1, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(a, b, c, d)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT t.*, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(a, b, c, d)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(a, b, c, d)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        // Legacy unnest\n+        Session legacyUnnest = Session.builder(withParquetDereferencePushDownEnabled())\n+                .setSystemProperty(\"legacy_unnest\", \"true\")\n+                .build();\n+        assertParquetDereferencePushDown(legacyUnnest, \"SELECT t.y.a, t.y.d.d1, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(y)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(legacyUnnest, \"SELECT t.*, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(y)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        assertParquetDereferencePushDown(legacyUnnest, \"SELECT id, x.a FROM test_pushdown_nestedcolumn_parquet CROSS JOIN UNNEST(y) as t(y)\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\"));\n+\n+        // Case sensitivity\n+        assertParquetDereferencePushDown(\"SELECT x.a, x.b, x.A + 2 FROM test_pushdown_nestedcolumn_parquet WHERE x.B LIKE 'abc%'\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.a\", \"x.b\"));\n+\n+        // No pass-through nested column pruning\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.d).d1 FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d\"));\n+\n+        assertParquetDereferencePushDown(\"SELECT id, min(x.d).d1, min(x.d.d2) FROM test_pushdown_nestedcolumn_parquet GROUP BY 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d\"));\n+\n+        // Test pushdown of filters on dereference columns\n+        assertParquetDereferencePushDown(\"SELECT id, x.d.d1 FROM test_pushdown_nestedcolumn_parquet WHERE x.d.d1 = 1\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d.d1\"),\n+                withColumnDomains(ImmutableMap.of(\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d1\")), singleValue(BIGINT, 1L))),\n+                ImmutableSet.of(pushdownColumnNameForSubfield(nestedColumn(\"x.d.d1\"))),\n+                TRUE_CONSTANT);\n+\n+        assertParquetDereferencePushDown(\"SELECT id, x.d.d1 FROM test_pushdown_nestedcolumn_parquet WHERE x.d.d1 = 1 and x.d.d2 = 5.0\",\n+                \"test_pushdown_nestedcolumn_parquet\",\n+                nestedColumnMap(\"x.d.d1\", \"x.d.d2\"),\n+                withColumnDomains(ImmutableMap.of(\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d1\")), singleValue(BIGINT, 1L),\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d2\")), singleValue(DOUBLE, 5.0))),\n+                ImmutableSet.of(\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d1\")),\n+                        pushdownColumnNameForSubfield(nestedColumn(\"x.d.d2\"))),\n+                TRUE_CONSTANT);", "originalCommit": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MTA3MQ==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470861071", "bodyText": "TestHiveLogicalPlanner::nestedColumn", "author": "highker", "createdAt": "2020-08-14T20:56:03Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -1271,4 +1471,97 @@ public String toString()\n                     .toString();\n         }\n     }\n+\n+    private static final class HiveParquetDereferencePushdownMatcher\n+            implements Matcher\n+    {\n+        private final Map<String, Subfield> dereferenceColumns;\n+        private final TupleDomain<String> domainPredicate;\n+        private final Set<String> predicateColumns;\n+        private final RowExpression remainingPredicate;\n+\n+        private HiveParquetDereferencePushdownMatcher(\n+                Map<String, Subfield> dereferenceColumns,\n+                TupleDomain<String> domainPredicate,\n+                Set<String> predicateColumns,\n+                RowExpression remainingPredicate)\n+        {\n+            this.dereferenceColumns = requireNonNull(dereferenceColumns, \"dereferenceColumns is null\");\n+            this.domainPredicate = requireNonNull(domainPredicate, \"domainPredicate is null\");\n+            this.predicateColumns = requireNonNull(predicateColumns, \"predicateColumns is null\");\n+            this.remainingPredicate = requireNonNull(remainingPredicate, \"remainingPredicate is null\");\n+        }\n+\n+        @Override\n+        public boolean shapeMatches(PlanNode node)\n+        {\n+            return node instanceof TableScanNode;\n+        }\n+\n+        @Override\n+        public MatchResult detailMatches(PlanNode node, StatsProvider stats, Session session, Metadata metadata, SymbolAliases symbolAliases)\n+        {\n+            TableScanNode tableScan = (TableScanNode) node;\n+            for (ColumnHandle column : tableScan.getAssignments().values()) {\n+                HiveColumnHandle hiveColumn = (HiveColumnHandle) column;\n+                String columnName = hiveColumn.getName();\n+                if (dereferenceColumns.containsKey(columnName)) {\n+                    if (hiveColumn.getColumnType() != SYNTHESIZED ||\n+                            hiveColumn.getRequiredSubfields().size() != 1 ||\n+                            !hiveColumn.getRequiredSubfields().get(0).equals(dereferenceColumns.get(columnName))) {\n+                        return NO_MATCH;\n+                    }\n+                    dereferenceColumns.remove(columnName);\n+                }\n+                else {\n+                    if (isPushedDownSubfield(hiveColumn)) {\n+                        return NO_MATCH;\n+                    }\n+                }\n+            }\n+\n+            if (!dereferenceColumns.isEmpty()) {\n+                return NO_MATCH;\n+            }\n+\n+            Optional<ConnectorTableLayoutHandle> layout = tableScan.getTable().getLayout();\n+\n+            if (!layout.isPresent()) {\n+                return NO_MATCH;\n+            }\n+\n+            HiveTableLayoutHandle layoutHandle = (HiveTableLayoutHandle) layout.get();\n+\n+            if (!Objects.equals(layoutHandle.getPredicateColumns().keySet(), predicateColumns) ||\n+                    !Objects.equals(layoutHandle.getDomainPredicate(), domainPredicate.transform(Subfield::new)) ||\n+                    !Objects.equals(layoutHandle.getRemainingPredicate(), remainingPredicate)) {\n+                return NO_MATCH;\n+            }\n+\n+            return match();\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return toStringHelper(this)\n+                    .add(\"dereferenceColumns\", dereferenceColumns)\n+                    .add(\"domainPredicate\", domainPredicate)\n+                    .add(\"predicateColumns\", predicateColumns)\n+                    .add(\"remainingPredicate\", remainingPredicate)\n+                    .toString();\n+        }\n+    }\n+\n+    private static Map<String, Subfield> nestedColumnMap(String... columns)\n+    {\n+        return Arrays.stream(columns).collect(Collectors.toMap(\n+                column -> pushdownColumnNameForSubfield(nestedColumn(column)),\n+                column -> nestedColumn(column)));", "originalCommit": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MTI2Ng==", "url": "https://github.com/prestodb/presto/pull/14955#discussion_r470861266", "bodyText": "leave the first line empty", "author": "highker", "createdAt": "2020-08-14T20:56:32Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestParquetDistributedQueries.java", "diffHunk": "@@ -42,9 +42,11 @@ private static QueryRunner createQueryRunner()\n                 .put(\"hive.storage-format\", \"PARQUET\")\n                 .put(\"hive.parquet.use-column-names\", \"true\")\n                 .put(\"hive.compression-codec\", \"GZIP\")\n+                .put(\"hive.enable-parquet-dereference-pushdown\", \"true\")\n                 .build();\n         return HiveQueryRunner.createQueryRunner(getTables(),\n-                ImmutableMap.of(\"experimental.pushdown-subfields-enabled\", \"true\"),\n+                ImmutableMap.of(\"experimental.pushdown-subfields-enabled\", \"true\",", "originalCommit": "c0e9fd71f15218e252449d3c88bb3340b9e2ef44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "407ef3f1eaa07745c5070bd7474b772cb5dc3fb1", "url": "https://github.com/prestodb/presto/commit/407ef3f1eaa07745c5070bd7474b772cb5dc3fb1", "message": "Update Parquet reader to read pushed down dereference columns\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>", "committedDate": "2020-08-14T21:10:09Z", "type": "commit"}, {"oid": "3c3c49cade0eb140ead2dc58ff09e2ec05279018", "url": "https://github.com/prestodb/presto/commit/3c3c49cade0eb140ead2dc58ff09e2ec05279018", "message": "Fix the dereference validity check in PushdownDeferences rule", "committedDate": "2020-08-14T21:10:09Z", "type": "commit"}, {"oid": "13eb102416a2536483fdaffa82a451c4baa8204c", "url": "https://github.com/prestodb/presto/commit/13eb102416a2536483fdaffa82a451c4baa8204c", "message": "RowGroup pruning using the filter on pushed down subfield\n\nOnce the dereference is pushed down to tablescan, filters on the dereference column\nare automatically pushed down to tablescan as the pushed down dereference column is\nexposed as a column directly coming from the tablescan. In the reader (this case\nParquet), interpret pushed down dereference columns and convert them to column paths\nto look up the stats in footer.\n\nCo-authored-by: Zhenxiao Luo <zluo@twitter.com>\nCo-authored-by: qqibrow <qqibrow@gmail.com>", "committedDate": "2020-08-14T21:10:09Z", "type": "commit"}, {"oid": "a9fa931ba4636ae66f3f39fd23b4473a27ad521f", "url": "https://github.com/prestodb/presto/commit/a9fa931ba4636ae66f3f39fd23b4473a27ad521f", "message": "Use SYNTHESIZED type to represent pushed down Subfield in HiveColumnHandle", "committedDate": "2020-08-14T21:10:09Z", "type": "commit"}, {"oid": "a9fa931ba4636ae66f3f39fd23b4473a27ad521f", "url": "https://github.com/prestodb/presto/commit/a9fa931ba4636ae66f3f39fd23b4473a27ad521f", "message": "Use SYNTHESIZED type to represent pushed down Subfield in HiveColumnHandle", "committedDate": "2020-08-14T21:10:09Z", "type": "forcePushed"}]}