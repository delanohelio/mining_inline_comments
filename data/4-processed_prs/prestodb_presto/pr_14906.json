{"pr_number": 14906, "pr_title": "Add a fast path using totalSize to plan join swapping", "pr_createdAt": "2020-07-28T15:02:14Z", "pr_url": "https://github.com/prestodb/presto/pull/14906", "timeline": [{"oid": "44a1258fb7653ac211a97130e2642d4fa6526059", "url": "https://github.com/prestodb/presto/commit/44a1258fb7653ac211a97130e2642d4fa6526059", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n- Make RuntimeReorderJoinSides directly use tableSize for simple plan.", "committedDate": "2020-07-28T15:02:30Z", "type": "forcePushed"}, {"oid": "4aa4bb1e21284f4d0cc814795bc7a88b52abe50d", "url": "https://github.com/prestodb/presto/commit/4aa4bb1e21284f4d0cc814795bc7a88b52abe50d", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n- Make RuntimeReorderJoinSides directly use tableSize for simple plan.", "committedDate": "2020-07-28T16:10:30Z", "type": "forcePushed"}, {"oid": "028e1479681ac19acded752d6616845ea72fb94c", "url": "https://github.com/prestodb/presto/commit/028e1479681ac19acded752d6616845ea72fb94c", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n- Make RuntimeReorderJoinSides directly use tableSize for simple plan.", "committedDate": "2020-07-28T19:58:39Z", "type": "forcePushed"}, {"oid": "dc5b8128a7ef8f39512216ec45bc50f466e5881d", "url": "https://github.com/prestodb/presto/commit/dc5b8128a7ef8f39512216ec45bc50f466e5881d", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n- Make RuntimeReorderJoinSides directly use tableSize for simple plan.", "committedDate": "2020-07-28T20:08:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3Mzk2OQ==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r462573969", "bodyText": "I would create a method isUnmodifiedTableScan(PlanNode node) (or some other name that makes sense) that traverses the tree with a visitor and returns true if the only nodes it encounters are exchange and TableScan node (and maybe project node that doesn't reduce the number of columns).  then change the condition to\nif(isUnmodifiedScan(left) && isUnmodifiedScan(right))\n{\nleftScan = getLeftScan(left)\nrightScan = getRightScan (right)\n}\nthat way we keep our conditions to what we need and don't rely on the plan looking a particular way (e.g. what if there was an extra local exchange or something).", "author": "rschlussel", "createdAt": "2020-07-29T20:38:40Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java", "diffHunk": "@@ -66,9 +76,35 @@ public Result apply(JoinNode joinNode, Captures captures, Context context)\n             return Result.empty();\n         }\n \n-        StatsProvider statsProvider = context.getStatsProvider();\n-        double leftOutputSizeInBytes = statsProvider.getStats(joinNode.getLeft()).getOutputSizeInBytes(joinNode.getLeft().getOutputVariables());\n-        double rightOutputSizeInBytes = statsProvider.getStats(joinNode.getRight()).getOutputSizeInBytes(joinNode.getRight().getOutputVariables());\n+        double leftOutputSizeInBytes = Double.NaN;\n+        double rightOutputSizeInBytes = Double.NaN;\n+        PlanNode actualLeft = context.getLookup().resolve(joinNode.getLeft());\n+        PlanNode actualRight = context.getLookup().resolve(joinNode.getRight());\n+        if (actualLeft instanceof TableScanNode && actualRight instanceof ExchangeNode && actualRight.getSources().size() == 1", "originalCommit": "dc5b8128a7ef8f39512216ec45bc50f466e5881d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNjcwMA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r462606700", "bodyText": "I guess how to refactor this part depends on our decision of the other comment.", "author": "pguofb", "createdAt": "2020-07-29T21:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3Mzk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3NjIwNw==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r462576207", "bodyText": "what if instead of having these two separate paths, we just use the regular stats calculator path, but added an Optional totalSize (or NaN for absent cases) to PlanNodeStatsEstimate.  then if we call getOutputsizeInBytes()with all of the input variables, then we return that number, and otherwise we calculate as usual per-column. We'd have to handle it correctly in the stats calculators to populate it correctly.  But it would also allow non-materialized queries to benefit from this change.\n@arhimondr what do you think?", "author": "rschlussel", "createdAt": "2020-07-29T20:42:51Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/RuntimeReorderJoinSides.java", "diffHunk": "@@ -66,9 +76,35 @@ public Result apply(JoinNode joinNode, Captures captures, Context context)\n             return Result.empty();\n         }\n \n-        StatsProvider statsProvider = context.getStatsProvider();\n-        double leftOutputSizeInBytes = statsProvider.getStats(joinNode.getLeft()).getOutputSizeInBytes(joinNode.getLeft().getOutputVariables());\n-        double rightOutputSizeInBytes = statsProvider.getStats(joinNode.getRight()).getOutputSizeInBytes(joinNode.getRight().getOutputVariables());\n+        double leftOutputSizeInBytes = Double.NaN;\n+        double rightOutputSizeInBytes = Double.NaN;\n+        PlanNode actualLeft = context.getLookup().resolve(joinNode.getLeft());\n+        PlanNode actualRight = context.getLookup().resolve(joinNode.getRight());\n+        if (actualLeft instanceof TableScanNode && actualRight instanceof ExchangeNode && actualRight.getSources().size() == 1\n+                && context.getLookup().resolve(actualRight.getSources().get(0)) instanceof TableScanNode) {\n+            // Simple plan is characterized as Join[leftSrc: TableScan, rightSrc: Exchange[src: TableScan]].\n+            // For simple plans, directly fetch the overall table sizes as the size of the join sides to have\n+            // accurate input bytes statistics and meanwhile avoid non-negligible cost of collecting and processing\n+            // per-column statistics.\n+            TableScanNode leftScan = (TableScanNode) actualLeft;\n+            TableScanNode rightScan = (TableScanNode) context.getLookup().resolve(actualRight.getSources().get(0));\n+            leftOutputSizeInBytes = metadata.getTableStatistics(context.getSession(),\n+                    leftScan.getTable(),\n+                    ImmutableList.copyOf(leftScan.getAssignments().values()),\n+                    new Constraint<>(leftScan.getCurrentConstraint())).getTotalSize().getValue();\n+            rightOutputSizeInBytes = metadata.getTableStatistics(context.getSession(),\n+                    rightScan.getTable(),\n+                    ImmutableList.copyOf(rightScan.getAssignments().values()),\n+                    new Constraint<>(rightScan.getCurrentConstraint())).getTotalSize().getValue();\n+        }\n+\n+        // Fall back using statsProvider to estimate left and right output size.\n+        if (Double.isNaN(leftOutputSizeInBytes) || Double.isNaN(rightOutputSizeInBytes)) {", "originalCommit": "dc5b8128a7ef8f39512216ec45bc50f466e5881d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNTc5MA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r462605790", "bodyText": "Yeah, adding totalSize field also in PlanNodeStatsEstimate will merge the current \"fast-path\" into the regular statsCalculator path.\nMy only concern is whether it worth adding the field. The downside is only a small portion will have actual values because operations like Aggregate, Join, Project, ... will easily make it NaN. Meanwhile, the advantage seems quite narrow, because for non-materialized queries it will only be effective for directly joining two actual tables. This seems a bit too-good-to-be-true because the optimizer tends to pushdown whatever filter/projection/otherOps possible below the join right?", "author": "pguofb", "createdAt": "2020-07-29T21:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3NjIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1MDY2Mw==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465350663", "bodyText": "It also feels to me that it should be the responsibility of the getOutputSizeInBytes method to return the size based on the column size information if the totalSize is not set. That will effectively merge these two paths and make the code a bit cleaner.\nI'm a little confused why do we think this approach is not preferred? Could you please elaborate a little bit more on that?", "author": "arhimondr", "createdAt": "2020-08-04T21:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3NjIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1NzMwOA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465357308", "bodyText": "@arhimondr it's not possible (or at least easy) to compute stats based on columns if you don't have a list of columns because you won't know how many columns don't have stats that you need to account for.  In order to handle this, we'd need to change the StatsNormalizer not to remove unknown stats from the list of variable statistics. This is what i was asking about before.", "author": "rschlussel", "createdAt": "2020-08-04T22:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3NjIwNw=="}], "type": "inlineReview"}, {"oid": "baa51984a88f88096663cefdae3e9b4d6c8f311b", "url": "https://github.com/prestodb/presto/commit/baa51984a88f88096663cefdae3e9b4d6c8f311b", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-07-31T18:11:37Z", "type": "forcePushed"}, {"oid": "7e2d6eff89e9a748b76196096262bd3738a5c49e", "url": "https://github.com/prestodb/presto/commit/7e2d6eff89e9a748b76196096262bd3738a5c49e", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-07-31T19:35:42Z", "type": "forcePushed"}, {"oid": "2e0d27f5a897105fd13eebbdefe481261b537ff6", "url": "https://github.com/prestodb/presto/commit/2e0d27f5a897105fd13eebbdefe481261b537ff6", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-08-03T14:14:21Z", "type": "forcePushed"}, {"oid": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "url": "https://github.com/prestodb/presto/commit/6e6e09222c9d3dcbf8503743fc3f97858ccff883", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-08-03T18:33:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3Nzg0OA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r464577848", "bodyText": "buildFrom() should also set the total size", "author": "rschlussel", "createdAt": "2020-08-03T18:06:25Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimate.java", "diffHunk": "@@ -170,38 +189,42 @@ public boolean equals(Object o)\n         }\n         PlanNodeStatsEstimate that = (PlanNodeStatsEstimate) o;\n         return Double.compare(outputRowCount, that.outputRowCount) == 0 &&\n+                Double.compare(totalSize, that.totalSize) == 0 &&\n                 Objects.equals(variableStatistics, that.variableStatistics);\n     }\n \n     @Override\n     public int hashCode()\n     {\n-        return Objects.hash(outputRowCount, variableStatistics);\n+        return Objects.hash(outputRowCount, totalSize, variableStatistics);\n     }\n \n     public static Builder builder()\n     {\n         return new Builder();\n     }\n \n+    // Do not inherit totalSize statistics by default. Only explicitly set\n     public static Builder buildFrom(PlanNodeStatsEstimate other)\n     {\n-        return new Builder(other.getOutputRowCount(), other.variableStatistics);\n+        return new Builder(other.getOutputRowCount(), NaN, other.variableStatistics);", "originalCommit": "2e0d27f5a897105fd13eebbdefe481261b537ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTMzOA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465149338", "bodyText": "I'm a bit against propagating the totalSize by default for the current scope of this PR, because people have to explicitly set it to NaN or otherwise a not NaN but possibly wrong totalSize value is carried. Given that we are only using this field for \"leaf\" simple join plans for now, it is safer to set it NaN by default to so that if people \"accidentally\" fetch the totalSize at other places they can tell that it is not usable via isNaN().\nIdeally, when we have implemented how to handle the totalSize field for all types of operator rules, we could set propagate as default to simply the relevant operations in those rules that won't change this field.\nWhat do you think?", "author": "pguofb", "createdAt": "2020-08-04T15:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3Nzg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NDA0MA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465154040", "bodyText": "that makes sense to me", "author": "rschlussel", "createdAt": "2020-08-04T15:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3Nzg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MjgyMA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465342820", "bodyText": "Could you please include this explanation in the comment?", "author": "arhimondr", "createdAt": "2020-08-04T21:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3Nzg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzMjg2Mw==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465332863", "bodyText": "count -> size", "author": "arhimondr", "createdAt": "2020-08-04T21:11:29Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java", "diffHunk": "@@ -432,6 +442,18 @@ static OptionalDouble calculateAverageRowsPerPartition(Collection<PartitionStati\n                 .average();\n     }\n \n+    @VisibleForTesting\n+    static OptionalDouble calculateAverageSizePerPartition(Collection<PartitionStatistics> statistics)\n+    {\n+        return statistics.stream()\n+                .map(PartitionStatistics::getBasicStatistics)\n+                .map(HiveBasicStatistics::getInMemoryDataSizeInBytes)\n+                .filter(OptionalLong::isPresent)\n+                .mapToLong(OptionalLong::getAsLong)\n+                .peek(count -> verify(count >= 0, \"count must be greater than or equal to zero\"))", "originalCommit": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzMzExMA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465333110", "bodyText": "nit: include the actual value into the error message in case it ever fails\ne.g.: verify(averageSizePerPartition >= 0, \"averageSizePerPartition must be greater than or equal to zero: %s\", averageSizePerPartition)", "author": "arhimondr", "createdAt": "2020-08-04T21:12:01Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/statistics/MetastoreHiveStatisticsProvider.java", "diffHunk": "@@ -404,6 +405,15 @@ private static TableStatistics getTableStatistics(\n \n         TableStatistics.Builder result = TableStatistics.builder();\n         result.setRowCount(Estimate.of(rowCount));\n+\n+        OptionalDouble optionalAverageSizePerPartition = calculateAverageSizePerPartition(statistics.values());\n+        if (optionalAverageSizePerPartition.isPresent()) {\n+            double averageSizePerPartition = optionalAverageSizePerPartition.getAsDouble();\n+            verify(averageSizePerPartition >= 0, \"averageSizePerPartition must be greater than or equal to zero\");", "originalCommit": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MjE4Ng==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465342186", "bodyText": "What if totalSize is not set? Should we try to compute it based on the column statistics?", "author": "arhimondr", "createdAt": "2020-08-04T21:31:45Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimate.java", "diffHunk": "@@ -74,6 +77,21 @@ public double getOutputRowCount()\n         return outputRowCount;\n     }\n \n+    @JsonProperty\n+    public double getTotalSize()\n+    {\n+        return totalSize;\n+    }\n+\n+    /**\n+     * Only use when getting all columns and meanwhile do not want to\n+     * do per-column estimation.\n+     */\n+    public double getOutputSizeInBytes()", "originalCommit": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2Mjg1MQ==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465362851", "bodyText": "It is tricky to compute based on current column statistics because suppose now there are three columns A,B,C and only column A has known statistics, we are only able to estimate the size of column A, because statsNormalizer has removed B and C from the PlanNodeStatsEstimate where nothing can be estimated.", "author": "pguofb", "createdAt": "2020-08-04T22:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MjE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQzODQ4NA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465438484", "bodyText": "I see. Now I undestand the problem.", "author": "arhimondr", "createdAt": "2020-08-05T02:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MjE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDQyNA==", "url": "https://github.com/prestodb/presto/pull/14906#discussion_r465344424", "bodyText": "nit: it can be safely simplified to totalSize += sourceStats.getOutputSizeInBytes() (anything + NaN is NaN)", "author": "arhimondr", "createdAt": "2020-08-04T21:36:50Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/ExchangeStatsRule.java", "diffHunk": "@@ -49,9 +52,11 @@ public ExchangeStatsRule(StatsNormalizer normalizer)\n     protected Optional<PlanNodeStatsEstimate> doCalculate(ExchangeNode node, StatsProvider statsProvider, Lookup lookup, Session session, TypeProvider types)\n     {\n         Optional<PlanNodeStatsEstimate> estimate = Optional.empty();\n+        double totalSize = 0;\n         for (int i = 0; i < node.getSources().size(); i++) {\n             PlanNode source = node.getSources().get(i);\n             PlanNodeStatsEstimate sourceStats = statsProvider.getStats(source);\n+            totalSize = (!isNaN(sourceStats.getOutputSizeInBytes()) && !isNaN(totalSize)) ? totalSize + sourceStats.getOutputSizeInBytes() : NaN;", "originalCommit": "6e6e09222c9d3dcbf8503743fc3f97858ccff883", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a2f7e21a372e6210f78fe54130f45b023ae7d156", "url": "https://github.com/prestodb/presto/commit/a2f7e21a372e6210f78fe54130f45b023ae7d156", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-08-04T22:34:11Z", "type": "forcePushed"}, {"oid": "9c1706fa0102a1a1bff774ff8375395827554c78", "url": "https://github.com/prestodb/presto/commit/9c1706fa0102a1a1bff774ff8375395827554c78", "message": "Add totalSize in PlanNodeStatsEstimate\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.\n- Refactor RuntimeReorderJoinSides to use planNodeSearcher functions to\ncapture simple plans, instead of manually checking.", "committedDate": "2020-08-04T22:53:37Z", "type": "forcePushed"}, {"oid": "f32cd86461aba17dffa6cedc406a1dbae3712bf7", "url": "https://github.com/prestodb/presto/commit/f32cd86461aba17dffa6cedc406a1dbae3712bf7", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.", "committedDate": "2020-08-05T13:38:23Z", "type": "commit"}, {"oid": "f32cd86461aba17dffa6cedc406a1dbae3712bf7", "url": "https://github.com/prestodb/presto/commit/f32cd86461aba17dffa6cedc406a1dbae3712bf7", "message": "Use totalSize statistics for simple join plan\n\n- Add a totalSize field in TableStatistics.\n- Enable totalSize to be filled from getTableStatistics: enable\nMetastoreHiveStatsProvider to feed totalSize field from\nPartitionStatistics and use the rowSize before and after\nConnectorFilterStatsCalcService to estimate filted totalSize.\n\n- add totalSize field in PlanNodeStatsEstimate.\n- Fill in the field from tableScanStatsRule.\n- Propagate totalSize through exchangeStatsRule.\n- Refactor RuntimeReorderJoinSides, try using getOutputSizeInBytes()\nwithout parameters to make use of totalSize statistics first if available\nfor simple plans.", "committedDate": "2020-08-05T13:38:23Z", "type": "forcePushed"}]}