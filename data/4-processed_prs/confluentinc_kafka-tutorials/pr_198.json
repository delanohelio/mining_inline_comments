{"pr_number": 198, "pr_title": "Kafka-Tutorials: KTable Foreign Key Joins Tutorial", "pr_createdAt": "2020-02-07T21:43:10Z", "pr_url": "https://github.com/confluentinc/kafka-tutorials/pull/198", "timeline": [{"oid": "cf7b8a2e7d85b2d9f3108f6d255a8e61961e0cd3", "url": "https://github.com/confluentinc/kafka-tutorials/commit/cf7b8a2e7d85b2d9f3108f6d255a8e61961e0cd3", "message": "Initial commit of tutorial code", "committedDate": "2020-02-05T16:49:02Z", "type": "commit"}, {"oid": "a042d8ca062b8006c793d1f157d3e52040cc043c", "url": "https://github.com/confluentinc/kafka-tutorials/commit/a042d8ca062b8006c793d1f157d3e52040cc043c", "message": "added all tutorial-steps, updated build.gradle file", "committedDate": "2020-02-05T18:07:34Z", "type": "commit"}, {"oid": "66d6a1e8317aaccee9eabe8874811f3be0338a96", "url": "https://github.com/confluentinc/kafka-tutorials/commit/66d6a1e8317aaccee9eabe8874811f3be0338a96", "message": "added markup files", "committedDate": "2020-02-05T21:52:13Z", "type": "commit"}, {"oid": "7bee539bbe588bfc45fbe7f8108d847c024ca9e4", "url": "https://github.com/confluentinc/kafka-tutorials/commit/7bee539bbe588bfc45fbe7f8108d847c024ca9e4", "message": "More changes for re-named files", "committedDate": "2020-02-05T21:55:15Z", "type": "commit"}, {"oid": "560600b9ba8245a25c6df6c40114653bb8c38552", "url": "https://github.com/confluentinc/kafka-tutorials/commit/560600b9ba8245a25c6df6c40114653bb8c38552", "message": "clean-up", "committedDate": "2020-02-06T15:34:51Z", "type": "commit"}, {"oid": "2cdd4eb964a8164c4f9aa98475c167aa3f496bbf", "url": "https://github.com/confluentinc/kafka-tutorials/commit/2cdd4eb964a8164c4f9aa98475c167aa3f496bbf", "message": "added harness, joiner test and last parts to complete tutorial", "committedDate": "2020-02-06T17:13:23Z", "type": "commit"}, {"oid": "3fd8ebe6d98f277c44f2becfd94adc6f5dc753d6", "url": "https://github.com/confluentinc/kafka-tutorials/commit/3fd8ebe6d98f277c44f2becfd94adc6f5dc753d6", "message": "add tutorial to index page, fix bugs found from running tutorial, updates for avro console producer", "committedDate": "2020-02-07T17:06:23Z", "type": "commit"}, {"oid": "1802eedfe159ea2ab754e248d67593414d1cc6c2", "url": "https://github.com/confluentinc/kafka-tutorials/commit/1802eedfe159ea2ab754e248d67593414d1cc6c2", "message": "Code clean up, another round of fixes from running tutorial", "committedDate": "2020-02-07T21:31:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyMzEzNw==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r376623137", "bodyText": "as of the 5.4 release, the kafka-avro-console-producer accepts a key-schema parameter.  I've validated this works locally.", "author": "bbejeck", "createdAt": "2020-02-07T21:47:40Z", "path": "_includes/tutorials/fk-joins/kstreams/code/tutorial-steps/dev/console-producer-albums.sh", "diffHunk": "@@ -0,0 +1,5 @@\n+docker exec -i schema-registry /usr/bin/kafka-avro-console-producer --topic albums --broker-list broker:9092\\\n+  --property \"parse.key=true\"\\", "originalCommit": "1802eedfe159ea2ab754e248d67593414d1cc6c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyMzYyOQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r376623629", "bodyText": "This is the correct format, it allows for passing in keys to kafka-avro-console-producer", "author": "bbejeck", "createdAt": "2020-02-07T21:49:01Z", "path": "_includes/tutorials/fk-joins/kstreams/code/tutorial-steps/dev/track-purchases.json", "diffHunk": "@@ -0,0 +1,7 @@\n+100:{\"id\": 100, \"album_id\": 5, \"song_title\": \"Houses Of The Holy\", \"price\": 0.99}", "originalCommit": "1802eedfe159ea2ab754e248d67593414d1cc6c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyMzczOQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r376623739", "bodyText": "This is the correct format, it allows for passing in keys to kafka-avro-console-producer", "author": "bbejeck", "createdAt": "2020-02-07T21:49:19Z", "path": "_includes/tutorials/fk-joins/kstreams/code/tutorial-steps/dev/albums.json", "diffHunk": "@@ -0,0 +1,4 @@\n+5:{\"id\": 5, \"title\": \"Physical Graffiti\", \"artist\": \"Led Zeppelin\", \"genre\": \"Rock\"}\n+6:{\"id\": 6, \"title\": \"Highway to Hell\",   \"artist\": \"AC/DC\", \"genre\": \"Rock\"}", "originalCommit": "1802eedfe159ea2ab754e248d67593414d1cc6c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e6470a5f2ffe802e384aea69cb3273b37c5ebdcc", "url": "https://github.com/confluentinc/kafka-tutorials/commit/e6470a5f2ffe802e384aea69cb3273b37c5ebdcc", "message": "Fixed bad directory in Makefile", "committedDate": "2020-02-07T22:14:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzNTk4NA==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r376635984", "bodyText": "There is a built in bash function (until) for this if you're interested...\nuntil readiness_probe\ndo\n  sleep 5\ndone", "author": "rspurgeon", "createdAt": "2020-02-07T22:23:57Z", "path": "_includes/tutorials/fk-joins/kstreams/code/tutorial-steps/dev/wait-for-containers.sh", "diffHunk": "@@ -0,0 +1,14 @@\n+#!/bin/bash\n+\n+function readiness_probe {\n+    nc -z -w 2 0.0.0.0 29092\n+}\n+\n+echo \"Waiting for the broker to become available ...\"\n+\n+readiness_probe\n+\n+while [[ $? != 0 ]]; do\n+    sleep 5\n+    readiness_probe\n+done", "originalCommit": "e6470a5f2ffe802e384aea69cb3273b37c5ebdcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyNzQ4NQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r377327485", "bodyText": "thanks but I used pre-existing a wait-for-containers.sh file.  It seems most/all of the streams examples use the same format.  IMHO if we make that change, we can do a follow-up PR to change all files to use the same format.", "author": "bbejeck", "createdAt": "2020-02-10T21:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzNTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzODA1Ng==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r376638056", "bodyText": "copy and paste monster...  filtering should be fk-joins", "author": "rspurgeon", "createdAt": "2020-02-07T22:30:25Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/start-compose.adoc", "diffHunk": "@@ -0,0 +1,5 @@\n+And launch it by running:\n+\n++++++\n+<pre class=\"snippet\"><code class=\"shell\">{% include_raw tutorials/filtering/kstreams/code/tutorial-steps/dev/docker-compose-up.sh %}</code></pre>", "originalCommit": "e6470a5f2ffe802e384aea69cb3273b37c5ebdcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyNzQ2OQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r377327469", "bodyText": "ack, thanks for that.", "author": "bbejeck", "createdAt": "2020-02-10T21:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzODA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MTUxMQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r376641511", "bodyText": "typo in trackPurcases", "author": "rspurgeon", "createdAt": "2020-02-07T22:41:56Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-avro-dir.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+This tutorial uses three streams: one called `albums` that holds album reference data, one called `trackPurchases` that holds an update-stream of inbound music track purchases, and one called `musicInterestTable` that holds the result of a foreign-key join between purchases and albums.  In the case the inbound keys are different, but the `trackPurcases` stream has the id of the album in its value, so we can use the `KTable` foreign-key join funcitionality to extract the album id and perform the join.", "originalCommit": "e6470a5f2ffe802e384aea69cb3273b37c5ebdcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MTgxNw==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r376641817", "bodyText": "result of a foreign-key join between purchases and albums\n\nShould this be more explicit and say... 'between trackPurchases and albums'?", "author": "rspurgeon", "createdAt": "2020-02-07T22:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MTUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyNzQ0Mw==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r377327443", "bodyText": "ack", "author": "bbejeck", "createdAt": "2020-02-10T21:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MTUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MzUwNg==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r376643506", "bodyText": "When you join two tables in a relational database, by default you get a new table containing all of the columns of the left table plus all of the columns of the right table. When you join a table and a table, you get a new table, but you must be explicit about the value of that table\u2014the combination between the value in the table and the assocaited value in the table.\n\nThis was difficult to follow, maybe try a revision?", "author": "rspurgeon", "createdAt": "2020-02-07T22:48:44Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-joiner.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+For the ValueJoiner class, create the following file at `src/main/java/io/confluent/developer/MusicInterestJoiner.java`.\n+\n+When you join two tables in a relational database, by default you get a new table containing all of the columns of the left table plus all of the columns of the right table. When you join a table and a table, you get a new table, but you must be explicit about the value of that table\u2014the combination between the value in the table and the assocaited value in the table. The `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/ValueJoiner.html[ValueJoiner]` interface in the Streams API does this work. The single `apply()` method takes the \"left\" table and the \"right\" table values as parameters, and returns the value of the joined table as output. (Their keys are not a part of the equation, because they are equal by definition and do not change in the result.) As you can see here, this is just a matter of creating a `MusicInterest` object and populating it with the relevant fields of the input album and track purchase.", "originalCommit": "e6470a5f2ffe802e384aea69cb3273b37c5ebdcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMyNzQxNg==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r377327416", "bodyText": "ack", "author": "bbejeck", "createdAt": "2020-02-10T21:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MzUwNg=="}], "type": "inlineReview"}, {"oid": "d4a677bc66b4b8faae46dfa7a36003ed27bcf925", "url": "https://github.com/confluentinc/kafka-tutorials/commit/d4a677bc66b4b8faae46dfa7a36003ed27bcf925", "message": "Fix name of test file in harness yml", "committedDate": "2020-02-10T15:40:40Z", "type": "commit"}, {"oid": "db0cbf4811a4e1cdbeb17a81923027734f04fa88", "url": "https://github.com/confluentinc/kafka-tutorials/commit/db0cbf4811a4e1cdbeb17a81923027734f04fa88", "message": "Use TestUtils to create state dir", "committedDate": "2020-02-10T19:54:55Z", "type": "commit"}, {"oid": "7fae29b41f44a4606243a3946fdaedbd05157aa3", "url": "https://github.com/confluentinc/kafka-tutorials/commit/7fae29b41f44a4606243a3946fdaedbd05157aa3", "message": "Fixed Makefile for ci build, other changes per review comments", "committedDate": "2020-02-10T21:29:52Z", "type": "commit"}, {"oid": "8721f5a9f3fd1f53f44befc65e00ace55a1f8825", "url": "https://github.com/confluentinc/kafka-tutorials/commit/8721f5a9f3fd1f53f44befc65e00ace55a1f8825", "message": "Add newlines to output files", "committedDate": "2020-02-10T21:36:58Z", "type": "commit"}, {"oid": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "url": "https://github.com/confluentinc/kafka-tutorials/commit/424c65e4ca88513e5f79d02ccac90d6f7cae8457", "message": "Increase pause to harness for results, add close timeout back to streams, remove spaces from expected output results", "committedDate": "2020-02-10T22:11:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxMDU0MQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378510541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              title: \"How to join a table and a table with a foriegn key\"\n          \n          \n            \n              title: \"How to join a table and a table with a foreign key\"", "author": "colinhicks", "createdAt": "2020-02-12T21:02:41Z", "path": "_data/tutorials.yaml", "diffHunk": "@@ -72,6 +72,15 @@ joining-stream-stream:\n     ksql: enabled\n     kstreams: enabled\n \n+fk-joins:\n+  title: \"How to join a table and a table with a foriegn key\"", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxMTM3MQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378511371", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              meta-description: \"Learn how to use the KTable foriegn key join functionality\"\n          \n          \n            \n              meta-description: \"Learn how to join two tables with different primary keys\"", "author": "colinhicks", "createdAt": "2020-02-12T21:04:38Z", "path": "_data/tutorials.yaml", "diffHunk": "@@ -72,6 +72,15 @@ joining-stream-stream:\n     ksql: enabled\n     kstreams: enabled\n \n+fk-joins:\n+  title: \"How to join a table and a table with a foriegn key\"\n+  meta-description: \"Learn how to use the KTable foriegn key join functionality\"", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxMTg4OA==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378511888", "bodyText": "Changing this here, so that it matches the shortened path segment in the url.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              slug: \"/table-table-foreign-key-joins\"\n          \n          \n            \n              slug: \"/foreign-key-joins\"", "author": "colinhicks", "createdAt": "2020-02-12T21:05:50Z", "path": "_data/tutorials.yaml", "diffHunk": "@@ -72,6 +72,15 @@ joining-stream-stream:\n     ksql: enabled\n     kstreams: enabled\n \n+fk-joins:\n+  title: \"How to join a table and a table with a foriegn key\"\n+  meta-description: \"Learn how to use the KTable foriegn key join functionality\"\n+  slug: \"/table-table-foreign-key-joins\"", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxMjUyMg==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378512522", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              problem: \"you need to join two tables, but the primary keys are different so you need to use a foriegn key to complete the join\"\n          \n          \n            \n              problem: \"you need to join two tables, but they have different primary keys\"", "author": "colinhicks", "createdAt": "2020-02-12T21:07:07Z", "path": "_data/tutorials.yaml", "diffHunk": "@@ -72,6 +72,15 @@ joining-stream-stream:\n     ksql: enabled\n     kstreams: enabled\n \n+fk-joins:\n+  title: \"How to join a table and a table with a foriegn key\"\n+  meta-description: \"Learn how to use the KTable foriegn key join functionality\"\n+  slug: \"/table-table-foreign-key-joins\"\n+  problem: \"you need to join two tables, but the primary keys are different so you need to use a foriegn key to complete the join\"", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxNDc2OQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378514769", "bodyText": "Slight rewording to combine and shorten last two sentences.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              introduction: \"Suppose you are running an internet streaming music service where you offer albums or individual music tracks for sale.  You'd like to track trends in listener preference by joining the track purchases against the table of albums.  The issue is that the track purchase key doesn't align with the primary key for the album table.  But the value of the track purchase contains the id of the album.  Using the KTable-KTable foreign key join functionality, you can extract the album id from the track purchase and complete the join against the album table.\"\n          \n          \n            \n              introduction: \"Suppose you are running an internet streaming music service where you offer albums or individual music tracks for sale.  You'd like to track trends in listener preference by joining the track purchases against the table of albums.  The issue is that the track purchase key doesn't align with the primary key for the album table.  However, since the value of the track purchase contains the id of the album, you can extract the album id from the track purchase and complete a foreign key join against the album table.\"", "author": "colinhicks", "createdAt": "2020-02-12T21:12:02Z", "path": "_data/tutorials.yaml", "diffHunk": "@@ -72,6 +72,15 @@ joining-stream-stream:\n     ksql: enabled\n     kstreams: enabled\n \n+fk-joins:\n+  title: \"How to join a table and a table with a foriegn key\"\n+  meta-description: \"Learn how to use the KTable foriegn key join functionality\"\n+  slug: \"/table-table-foreign-key-joins\"\n+  problem: \"you need to join two tables, but the primary keys are different so you need to use a foriegn key to complete the join\"\n+  introduction: \"Suppose you are running an internet streaming music service where you offer albums or individual music tracks for sale.  You'd like to track trends in listener preference by joining the track purchases against the table of albums.  The issue is that the track purchase key doesn't align with the primary key for the album table.  But the value of the track purchase contains the id of the album.  Using the KTable-KTable foreign key join functionality, you can extract the album id from the track purchase and complete the join against the album table.\"", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxNzMxNQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378517315", "bodyText": "It would be nice to link to the Confluent docs for FK joins. But this is the only thing docs searched returned: https://docs.confluent.io/current/streams/upgrade-guide.html#foreign-key-ktable-ktable-joins\n\nForeign key KTable-KTable joins\nTODO: KIP-213\n\nMaybe there's something else?", "author": "colinhicks", "createdAt": "2020-02-12T21:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxNDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwNzM0NQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r380807345", "bodyText": "ack I'll take a look", "author": "bbejeck", "createdAt": "2020-02-18T17:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxNDc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxOTIyOA==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378519228", "bodyText": "Is the first hyphen intentional, here? It's also in test.properties, but not in prod.properties", "author": "colinhicks", "createdAt": "2020-02-12T21:21:28Z", "path": "_includes/tutorials/fk-joins/kstreams/code/configuration/dev.properties", "diffHunk": "@@ -0,0 +1,16 @@\n+application.id=-fk-joining-app", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxMjQzMQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r380912431", "bodyText": "typo, fixed now.", "author": "bbejeck", "createdAt": "2020-02-18T20:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxOTIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUyMTM1NA==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378521354", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This tutorial uses three streams: one called `albums` that holds album reference data, one called `trackPurchases` that holds an update-stream of inbound music track purchases, and one called `musicInterestTable` that holds the result of a foreign-key join between trackPurchases and albums.  In the case the inbound keys are different, but the `trackPurchases` stream has the id of the album in its value, so we can use the `KTable` foreign-key join funcitionality to extract the album id and perform the join.\n          \n          \n            \n            This tutorial uses three streams: one called `albums` that holds album reference data, one called `trackPurchases` that holds an update-stream of inbound music track purchases, and one called `musicInterestTable` that holds the result of a foreign-key join between `trackPurchases` and `albums`.\n          \n          \n            \n            \n          \n          \n            \n            In this case the inbound keys are different, but the `trackPurchases` stream has the id of the album in its value. We will use the `KTable` foreign-key join functionality to extract the album id and perform the join.", "author": "colinhicks", "createdAt": "2020-02-12T21:25:54Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-avro-dir.adoc", "diffHunk": "@@ -0,0 +1,9 @@\n+This tutorial uses three streams: one called `albums` that holds album reference data, one called `trackPurchases` that holds an update-stream of inbound music track purchases, and one called `musicInterestTable` that holds the result of a foreign-key join between trackPurchases and albums.  In the case the inbound keys are different, but the `trackPurchases` stream has the id of the album in its value, so we can use the `KTable` foreign-key join funcitionality to extract the album id and perform the join.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUyNTE2NA==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378525164", "bodyText": "Suggesting a few wording tweaks and a paragraph break:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.  First each track purchase has a simple `Long` as the key, representing a increasing sequence number for each purchase.  So each purchase is unique and we don't need to worry about later sales replacing earlier purchases by the same customer.  Secondly, we need to join the track purchase with an existing album so we can create trend of which artists and genre seem to be either gaining or losing poplularity.\n          \n          \n            \n            Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.\n          \n          \n            \n            \n          \n          \n            \n            First, each track purchase has a simple `Long` key, representing a increasing sequence number for each purchase.  This means each purchase is unique, and we don't need to worry about later sales replacing earlier purchases by the same customer.  Second, we need to join each track purchase with an existing album so we can create a trend of artists and genres gaining or losing popularity.", "author": "colinhicks", "createdAt": "2020-02-12T21:33:50Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-topology.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+Then create the following file at `src/main/java/io/confluent/developer/FkJoinTableToTable.java`. Let's take a close look at the `buildTopology()` method, which uses the Kafka Streams DSL.\n+\n+The first thing the method does is create an instance of `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html[StreamsBuilder]`, which is the helper object that lets us build our topology. With our builder in hand, there are three things we need to do. First, we call the `table()` method to create a `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KStream]<Long, Album>` object.  In this case, we can use a `KTable` as each we know the topic is keyed by the album id and each album-id is unique.\n+\n+Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.  First each track purchase has a simple `Long` as the key, representing a increasing sequence number for each purchase.  So each purchase is unique and we don't need to worry about later sales replacing earlier purchases by the same customer.  Secondly, we need to join the track purchase with an existing album so we can create trend of which artists and genre seem to be either gaining or losing poplularity.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUyODg3Nw==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378528877", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            But if the key is a monatomically increasing number, how can we join against the album table?  The track-purchase table has the album-id as part of its value payload, so we can use the new overaloaded `KTable.join` method that accepts a `ForiegnKeyExtractor` parameter that allows us to pull the primary-key of the value of one table to enable a join with another table.\n          \n          \n            \n            But if the key is a monotonically increasing number, how can we join against the `album` table?  The `trackPurchases` table has the album id as part of its value payload, so we can use the `KTable.join` method with a `ForeignKeyExtractor` parameter to extract the album id for the join comparison.", "author": "colinhicks", "createdAt": "2020-02-12T21:41:32Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-topology.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+Then create the following file at `src/main/java/io/confluent/developer/FkJoinTableToTable.java`. Let's take a close look at the `buildTopology()` method, which uses the Kafka Streams DSL.\n+\n+The first thing the method does is create an instance of `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html[StreamsBuilder]`, which is the helper object that lets us build our topology. With our builder in hand, there are three things we need to do. First, we call the `table()` method to create a `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KStream]<Long, Album>` object.  In this case, we can use a `KTable` as each we know the topic is keyed by the album id and each album-id is unique.\n+\n+Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.  First each track purchase has a simple `Long` as the key, representing a increasing sequence number for each purchase.  So each purchase is unique and we don't need to worry about later sales replacing earlier purchases by the same customer.  Secondly, we need to join the track purchase with an existing album so we can create trend of which artists and genre seem to be either gaining or losing poplularity.\n+\n+But if the key is a monatomically increasing number, how can we join against the album table?  The track-purchase table has the album-id as part of its value payload, so we can use the new overaloaded `KTable.join` method that accepts a `ForiegnKeyExtractor` parameter that allows us to pull the primary-key of the value of one table to enable a join with another table.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzMDg3OQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378530879", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Creating the `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KTable]<Long,TrackPurchase>` of track purchases looks just like our first step with the albums: we create a table from the topic. Note that we must choose the same key\u2014album ID\u2014for our join to work.  You accomplish this by providing a Java 8 method handle `TrackPurchase::getAlbumId` to extact the correct id for sucessful completion of the join.\n          \n          \n            \n            Creating the `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KTable]<Long,TrackPurchase>` of track purchases looks just like our first step with the albums: we create a table from the topic. Note that we must choose the same key\u2014the album id\u2014for our join to work.  You can accomplish this by providing a Java 8 method handle `TrackPurchase::getAlbumId` to extract the id.", "author": "colinhicks", "createdAt": "2020-02-12T21:45:51Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-topology.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+Then create the following file at `src/main/java/io/confluent/developer/FkJoinTableToTable.java`. Let's take a close look at the `buildTopology()` method, which uses the Kafka Streams DSL.\n+\n+The first thing the method does is create an instance of `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html[StreamsBuilder]`, which is the helper object that lets us build our topology. With our builder in hand, there are three things we need to do. First, we call the `table()` method to create a `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KStream]<Long, Album>` object.  In this case, we can use a `KTable` as each we know the topic is keyed by the album id and each album-id is unique.\n+\n+Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.  First each track purchase has a simple `Long` as the key, representing a increasing sequence number for each purchase.  So each purchase is unique and we don't need to worry about later sales replacing earlier purchases by the same customer.  Secondly, we need to join the track purchase with an existing album so we can create trend of which artists and genre seem to be either gaining or losing poplularity.\n+\n+But if the key is a monatomically increasing number, how can we join against the album table?  The track-purchase table has the album-id as part of its value payload, so we can use the new overaloaded `KTable.join` method that accepts a `ForiegnKeyExtractor` parameter that allows us to pull the primary-key of the value of one table to enable a join with another table.\n+\n+Creating the `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KTable]<Long,TrackPurchase>` of track purchases looks just like our first step with the albums: we create a table from the topic. Note that we must choose the same key\u2014album ID\u2014for our join to work.  You accomplish this by providing a Java 8 method handle `TrackPurchase::getAlbumId` to extact the correct id for sucessful completion of the join.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzMTcxMw==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378531713", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            At this point we should discuss the importance of the order in which we use the `KTable` parameters in the `join()`.  The `trackPurchases` table is the *_calling_* or *_left-side-table_* and is the table where the primary-key is embedded in its value.  So the *_left-side-table_*  always provides the `ForiegnKeyExtractor` function.\n          \n          \n            \n            At this point we should discuss the importance of the order in which we use the `KTable` parameters in the `join()`.  The `trackPurchases` table is the *_calling_* or *_left-side-table_*, and it is the table where the primary key is embedded in its value.  The *_left-side-table_*  always provides the `ForeignKeyExtractor` function.", "author": "colinhicks", "createdAt": "2020-02-12T21:47:34Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-topology.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+Then create the following file at `src/main/java/io/confluent/developer/FkJoinTableToTable.java`. Let's take a close look at the `buildTopology()` method, which uses the Kafka Streams DSL.\n+\n+The first thing the method does is create an instance of `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html[StreamsBuilder]`, which is the helper object that lets us build our topology. With our builder in hand, there are three things we need to do. First, we call the `table()` method to create a `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KStream]<Long, Album>` object.  In this case, we can use a `KTable` as each we know the topic is keyed by the album id and each album-id is unique.\n+\n+Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.  First each track purchase has a simple `Long` as the key, representing a increasing sequence number for each purchase.  So each purchase is unique and we don't need to worry about later sales replacing earlier purchases by the same customer.  Secondly, we need to join the track purchase with an existing album so we can create trend of which artists and genre seem to be either gaining or losing poplularity.\n+\n+But if the key is a monatomically increasing number, how can we join against the album table?  The track-purchase table has the album-id as part of its value payload, so we can use the new overaloaded `KTable.join` method that accepts a `ForiegnKeyExtractor` parameter that allows us to pull the primary-key of the value of one table to enable a join with another table.\n+\n+Creating the `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KTable]<Long,TrackPurchase>` of track purchases looks just like our first step with the albums: we create a table from the topic. Note that we must choose the same key\u2014album ID\u2014for our join to work.  You accomplish this by providing a Java 8 method handle `TrackPurchase::getAlbumId` to extact the correct id for sucessful completion of the join.\n+\n+At this point we should discuss the importance of the order in which we use the `KTable` parameters in the `join()`.  The `trackPurchases` table is the *_calling_* or *_left-side-table_* and is the table where the primary-key is embedded in its value.  So the *_left-side-table_*  always provides the `ForiegnKeyExtractor` function.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzMjU0Ng==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378532546", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `albums` table is the *_right-side-table_* and always has the `primary-key` for the join. So, if you tried `albums.join(trackPurchases..)` the join would never work as the `albums` table has no knowlege of the `trackPurchases` table details.\n          \n          \n            \n            The `albums` table is the *_right-side-table_* and always has the primary key for the join. This is where order matters, for example: if you tried `albums.join(trackPurchases..)` the join would never work as the `albums` table has no knowledge of the `trackPurchases` table details.", "author": "colinhicks", "createdAt": "2020-02-12T21:49:20Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-topology.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+Then create the following file at `src/main/java/io/confluent/developer/FkJoinTableToTable.java`. Let's take a close look at the `buildTopology()` method, which uses the Kafka Streams DSL.\n+\n+The first thing the method does is create an instance of `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html[StreamsBuilder]`, which is the helper object that lets us build our topology. With our builder in hand, there are three things we need to do. First, we call the `table()` method to create a `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KStream]<Long, Album>` object.  In this case, we can use a `KTable` as each we know the topic is keyed by the album id and each album-id is unique.\n+\n+Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.  First each track purchase has a simple `Long` as the key, representing a increasing sequence number for each purchase.  So each purchase is unique and we don't need to worry about later sales replacing earlier purchases by the same customer.  Secondly, we need to join the track purchase with an existing album so we can create trend of which artists and genre seem to be either gaining or losing poplularity.\n+\n+But if the key is a monatomically increasing number, how can we join against the album table?  The track-purchase table has the album-id as part of its value payload, so we can use the new overaloaded `KTable.join` method that accepts a `ForiegnKeyExtractor` parameter that allows us to pull the primary-key of the value of one table to enable a join with another table.\n+\n+Creating the `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KTable]<Long,TrackPurchase>` of track purchases looks just like our first step with the albums: we create a table from the topic. Note that we must choose the same key\u2014album ID\u2014for our join to work.  You accomplish this by providing a Java 8 method handle `TrackPurchase::getAlbumId` to extact the correct id for sucessful completion of the join.\n+\n+At this point we should discuss the importance of the order in which we use the `KTable` parameters in the `join()`.  The `trackPurchases` table is the *_calling_* or *_left-side-table_* and is the table where the primary-key is embedded in its value.  So the *_left-side-table_*  always provides the `ForiegnKeyExtractor` function.\n+\n+The `albums` table is the *_right-side-table_* and always has the `primary-key` for the join. So, if you tried `albums.join(trackPurchases..)` the join would never work as the `albums` table has no knowlege of the `trackPurchases` table details.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzMzM4MQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378533381", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you have a situation where you have two tables where the primary-keys don't match, but *_each_* table has reference to each other's primary key, the the order of the tables in the join method won't matter.  But that scenario seems unlikely in practice.\n          \n          \n            \n            If you have a situation where you have two tables for which the primary keys don't match, yet *_each_* table has a reference to the other's primary key, then the order of the tables in the join method won't matter.  This scenario is probably unlikely in practice.", "author": "colinhicks", "createdAt": "2020-02-12T21:51:10Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-topology.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+Then create the following file at `src/main/java/io/confluent/developer/FkJoinTableToTable.java`. Let's take a close look at the `buildTopology()` method, which uses the Kafka Streams DSL.\n+\n+The first thing the method does is create an instance of `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html[StreamsBuilder]`, which is the helper object that lets us build our topology. With our builder in hand, there are three things we need to do. First, we call the `table()` method to create a `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KStream]<Long, Album>` object.  In this case, we can use a `KTable` as each we know the topic is keyed by the album id and each album-id is unique.\n+\n+Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.  First each track purchase has a simple `Long` as the key, representing a increasing sequence number for each purchase.  So each purchase is unique and we don't need to worry about later sales replacing earlier purchases by the same customer.  Secondly, we need to join the track purchase with an existing album so we can create trend of which artists and genre seem to be either gaining or losing poplularity.\n+\n+But if the key is a monatomically increasing number, how can we join against the album table?  The track-purchase table has the album-id as part of its value payload, so we can use the new overaloaded `KTable.join` method that accepts a `ForiegnKeyExtractor` parameter that allows us to pull the primary-key of the value of one table to enable a join with another table.\n+\n+Creating the `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KTable]<Long,TrackPurchase>` of track purchases looks just like our first step with the albums: we create a table from the topic. Note that we must choose the same key\u2014album ID\u2014for our join to work.  You accomplish this by providing a Java 8 method handle `TrackPurchase::getAlbumId` to extact the correct id for sucessful completion of the join.\n+\n+At this point we should discuss the importance of the order in which we use the `KTable` parameters in the `join()`.  The `trackPurchases` table is the *_calling_* or *_left-side-table_* and is the table where the primary-key is embedded in its value.  So the *_left-side-table_*  always provides the `ForiegnKeyExtractor` function.\n+\n+The `albums` table is the *_right-side-table_* and always has the `primary-key` for the join. So, if you tried `albums.join(trackPurchases..)` the join would never work as the `albums` table has no knowlege of the `trackPurchases` table details.\n+\n+If you have a situation where you have two tables where the primary-keys don't match, but *_each_* table has reference to each other's primary key, the the order of the tables in the join method won't matter.  But that scenario seems unlikely in practice.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzMzcwOQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378533709", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            With the track purchases table and the album table in hand, all that remains is to join them using the `join()` method. It's a wonderfully simply one-liner, but we have concealed a bit of complexity in the form of the `MusicInterestJoiner` class. More on that in a moment.\n          \n          \n            \n            With the `trackPurchases` table and the `albums` table in hand, all that remains is to join them using the `join()` method. It's a wonderfully simply one-liner, but we have concealed a bit of complexity in the form of the `MusicInterestJoiner` class. More on that in a moment.", "author": "colinhicks", "createdAt": "2020-02-12T21:51:48Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/make-topology.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+Then create the following file at `src/main/java/io/confluent/developer/FkJoinTableToTable.java`. Let's take a close look at the `buildTopology()` method, which uses the Kafka Streams DSL.\n+\n+The first thing the method does is create an instance of `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html[StreamsBuilder]`, which is the helper object that lets us build our topology. With our builder in hand, there are three things we need to do. First, we call the `table()` method to create a `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KStream]<Long, Album>` object.  In this case, we can use a `KTable` as each we know the topic is keyed by the album id and each album-id is unique.\n+\n+Now that we have our table of albums, we'll move on to the tracks available for purchase stream.  While it may seem that purchasing music tracks would end up in a `KStream`, there are a couple of circumstances that allow us to represent the track purchases as a table instead.  First each track purchase has a simple `Long` as the key, representing a increasing sequence number for each purchase.  So each purchase is unique and we don't need to worry about later sales replacing earlier purchases by the same customer.  Secondly, we need to join the track purchase with an existing album so we can create trend of which artists and genre seem to be either gaining or losing poplularity.\n+\n+But if the key is a monatomically increasing number, how can we join against the album table?  The track-purchase table has the album-id as part of its value payload, so we can use the new overaloaded `KTable.join` method that accepts a `ForiegnKeyExtractor` parameter that allows us to pull the primary-key of the value of one table to enable a join with another table.\n+\n+Creating the `https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html[KTable]<Long,TrackPurchase>` of track purchases looks just like our first step with the albums: we create a table from the topic. Note that we must choose the same key\u2014album ID\u2014for our join to work.  You accomplish this by providing a Java 8 method handle `TrackPurchase::getAlbumId` to extact the correct id for sucessful completion of the join.\n+\n+At this point we should discuss the importance of the order in which we use the `KTable` parameters in the `join()`.  The `trackPurchases` table is the *_calling_* or *_left-side-table_* and is the table where the primary-key is embedded in its value.  So the *_left-side-table_*  always provides the `ForiegnKeyExtractor` function.\n+\n+The `albums` table is the *_right-side-table_* and always has the `primary-key` for the join. So, if you tried `albums.join(trackPurchases..)` the join would never work as the `albums` table has no knowlege of the `trackPurchases` table details.\n+\n+If you have a situation where you have two tables where the primary-keys don't match, but *_each_* table has reference to each other's primary key, the the order of the tables in the join method won't matter.  But that scenario seems unlikely in practice.\n+\n+With the track purchases table and the album table in hand, all that remains is to join them using the `join()` method. It's a wonderfully simply one-liner, but we have concealed a bit of complexity in the form of the `MusicInterestJoiner` class. More on that in a moment.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNDQ0Mw==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378534443", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You have now joined a table to a table with a foriegn key! Well done.\n          \n          \n            \n            You have now joined a table to a table with a foreign key! Well done.", "author": "colinhicks", "createdAt": "2020-02-12T21:53:24Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/dev/run-track-purchases-producer.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+Run the following in a new terminal window. This process is the most fun if you can see this and the previous terminal (which is consuming the music interest results) at the same time. If your terminal program lets you do horizontal split panes, try it that way:\n+\n++++++\n+<pre class=\"snippet\"><code class=\"shell\">{% include_raw tutorials/fk-joins/kstreams/code/tutorial-steps/dev/console-producer-track-purchases.sh %}</code></pre>\n++++++\n+\n+When the producer starts up, copy and paste these lines into the terminal. Then you can observe the results in the consumer terminal:\n+\n++++++\n+<pre class=\"snippet\"><code class=\"json\">{% include_raw tutorials/fk-joins/kstreams/code/tutorial-steps/dev/track-purchases.json %}</code></pre>\n++++++\n+\n+Please note that do to the nature of how a `KTable` works,  you won't see results simultaneously.  You need to wait roughly 30 seconds or so after pasting the lines above to see any results in the consumer terminal.\n+\n+Speaking of that consumer terminal, these are the results you should see there if you paste in all the albums and track-purchases as shown in this tutorial:\n+\n++++++\n+<pre class=\"snippet\"><code class=\"json\">{% include_raw tutorials/fk-joins/kstreams/code/tutorial-steps/dev/outputs/music-interest.json %}</code></pre>\n++++++\n+\n+You have now joined a table to a table with a foriegn key! Well done.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTAwMg==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378535002", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Create the following file at `src/test/java/io/confluent/developer/MusicInterestJoinerTest.java`. This tests the helper class that merges the value of the album and the track purchase as each purchase is joined to a album. The class has a depenency on the `ValueJoiner` interface, but otherwise does not depend on anything external to our domain; it just needs `Album`, `TrackPurchase`, and `MusicInterest`` domain objects. As such, it's about as testable as code gets:\n          \n          \n            \n            Create the following file at `src/test/java/io/confluent/developer/MusicInterestJoinerTest.java`. This tests the helper class that merges the value of the album and the track purchase as each purchase is joined to an album. The class has a dependency on the `ValueJoiner` interface, but otherwise does not depend on anything external to our domain; it just needs `Album`, `TrackPurchase`, and `MusicInterest`` domain objects. As such, it's about as testable as code gets:", "author": "colinhicks", "createdAt": "2020-02-12T21:54:31Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/test/make-join-test.adoc", "diffHunk": "@@ -0,0 +1,5 @@\n+Create the following file at `src/test/java/io/confluent/developer/MusicInterestJoinerTest.java`. This tests the helper class that merges the value of the album and the track purchase as each purchase is joined to a album. The class has a depenency on the `ValueJoiner` interface, but otherwise does not depend on anything external to our domain; it just needs `Album`, `TrackPurchase`, and `MusicInterest`` domain objects. As such, it's about as testable as code gets:", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTE4MQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378535181", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now create the following file at `src/test/java/io/confluent/developer/FkJoinTableToTableTest.java`. Testing a Kafka streams application requires a bit of test harness code, but happily the `org.apache.kafka.streams.TopologyTestDriver` class makes this much more pleasant that it would otherwise be.\n          \n          \n            \n            Now create the following file at `src/test/java/io/confluent/developer/FkJoinTableToTableTest.java`. Testing a Kafka streams application requires a bit of test harness code, but happily the `org.apache.kafka.streams.TopologyTestDriver` class makes this much more pleasant than it would otherwise be.", "author": "colinhicks", "createdAt": "2020-02-12T21:54:55Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/test/make-topology-test.adoc", "diffHunk": "@@ -0,0 +1,7 @@\n+Now create the following file at `src/test/java/io/confluent/developer/FkJoinTableToTableTest.java`. Testing a Kafka streams application requires a bit of test harness code, but happily the `org.apache.kafka.streams.TopologyTestDriver` class makes this much more pleasant that it would otherwise be.", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTQ4MQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378535481", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        <li><a href=\"table-table-foreign-key-joins/kstreams.html\">Join two tables with a foreign key</a></li>\n          \n          \n            \n                        <li><a href=\"foreign-key-joins/kstreams.html\">Join two tables with a foreign key</a></li>", "author": "colinhicks", "createdAt": "2020-02-12T21:55:37Z", "path": "index.html", "diffHunk": "@@ -70,6 +70,7 @@ <h2 class=\"subtitle\">Apache Kafka is a powerful, scalable, fault-tolerant distri\n             <li><a href=\"join-a-stream-to-a-table/ksql.html\">Join a stream and a table together</a></li>\n             <li><a href=\"join-a-stream-to-a-stream/ksql.html\">Join a stream and a stream together</a></li>\n             <li><a href=\"join-a-table-to-a-table/ksql.html\">Join a table and a table together</a></li>\n+            <li><a href=\"table-table-foreign-key-joins/kstreams.html\">Join two tables with a foreign key</a></li>", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjUxMQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r378536511", "bodyText": "Since this determines the rendered url, I've simplified it. A couple other suggestions correspond to this change. If you think table-to-table-foreign-key-joins would be better, go for it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            permalink: /table-table-foreign-key-joins/kstreams\n          \n          \n            \n            permalink: /foreign-key-joins/kstreams", "author": "colinhicks", "createdAt": "2020-02-12T21:57:50Z", "path": "tutorials/fk-joins/kstreams.html", "diffHunk": "@@ -0,0 +1,6 @@\n+---\n+layout: tutorial\n+permalink: /table-table-foreign-key-joins/kstreams", "originalCommit": "424c65e4ca88513e5f79d02ccac90d6f7cae8457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "20fc124a66ea90d58e4dc35a227a0c498f0b9602", "url": "https://github.com/confluentinc/kafka-tutorials/commit/20fc124a66ea90d58e4dc35a227a0c498f0b9602", "message": "Apply suggestions from code review\n\nCo-Authored-By: Colin Hicks <colin.hicks@confluent.io>", "committedDate": "2020-02-18T17:03:08Z", "type": "commit"}, {"oid": "956e7e7a0b4fa17ded660d8a11c9819f4343f619", "url": "https://github.com/confluentinc/kafka-tutorials/commit/956e7e7a0b4fa17ded660d8a11c9819f4343f619", "message": "Update test to use MockSchemaRegistry", "committedDate": "2020-02-18T19:34:05Z", "type": "commit"}, {"oid": "9fd4e8c8d0fa92ea0c6e7998efca39c0fdfc82f3", "url": "https://github.com/confluentinc/kafka-tutorials/commit/9fd4e8c8d0fa92ea0c6e7998efca39c0fdfc82f3", "message": "fix application-id config", "committedDate": "2020-02-18T20:16:03Z", "type": "commit"}, {"oid": "9ac9691ac78198b9d9f697b64b3f416bca39d52c", "url": "https://github.com/confluentinc/kafka-tutorials/commit/9ac9691ac78198b9d9f697b64b3f416bca39d52c", "message": "updates for using MockSchemaRegistry in unit test", "committedDate": "2020-02-18T20:32:27Z", "type": "commit"}, {"oid": "0cb885c56e71c0a3ab50c65315cc499cedb6f5e2", "url": "https://github.com/confluentinc/kafka-tutorials/commit/0cb885c56e71c0a3ab50c65315cc499cedb6f5e2", "message": "Add short description about the use of MockSchemaRegistry for unit tests", "committedDate": "2020-02-18T23:43:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAwMzc0OQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/198#discussion_r381003749", "bodyText": "just added this bit text as it explains the test configuration for schema registry i.e. using MockSchemaRegistry\n\\cc @colinhicks @rspurgeon", "author": "bbejeck", "createdAt": "2020-02-18T23:51:01Z", "path": "_includes/tutorials/fk-joins/kstreams/markup/test/make-test-file.adoc", "diffHunk": "@@ -0,0 +1,8 @@\n+First, create a test file at `configuration/test.properties`:\n+\n++++++\n+<pre class=\"snippet\"><code class=\"shell\">{% include_raw tutorials/fk-joins/kstreams/code/configuration/test.properties %}</code></pre>\n++++++\n+\n+You should take note of the `schema.registry.url` configuration.  The config is using a special pseudo-protocol `mock://..` which means our test", "originalCommit": "0cb885c56e71c0a3ab50c65315cc499cedb6f5e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}