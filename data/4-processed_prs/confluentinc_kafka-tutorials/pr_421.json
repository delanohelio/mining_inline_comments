{"pr_number": 421, "pr_title": "update aggregation min-max tutorial inline with changes to ksqlDB master", "pr_createdAt": "2020-06-05T09:49:57Z", "pr_url": "https://github.com/confluentinc/kafka-tutorials/pull/421", "timeline": [{"oid": "bc9bc70be9a5a8217e55a03b2c3074f2ea8ca983", "url": "https://github.com/confluentinc/kafka-tutorials/commit/bc9bc70be9a5a8217e55a03b2c3074f2ea8ca983", "message": "update aggregation min-max tutorial inline with changes to ksqlDB master", "committedDate": "2020-06-05T09:49:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk0ODEwMg==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/421#discussion_r435948102", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            With our test data and configuration parameters in place, let\u2019s try a query to compute our ticket totals. A `SELECT` statement with an `EMIT CHANGES` in ksqlDB is called a transient push query, unlike a traditional db query, which returns a single result set, the query continuously streams back results and once we stop it, it is gone and will not keep processing the input stream. That's what we're doing in this step. The counterpart to a transient query is a _persistent_ query, which we'll create a few steps from now.\n          \n          \n            \n            With our test data and configuration parameters in place, let\u2019s try a query to compute our ticket totals. A `SELECT` statement with an `EMIT CHANGES` in ksqlDB is called a transient push query. \n          \n          \n            \n            \n          \n          \n            \n            Unlike a traditional database query, which returns a single result set, the query continuously streams back results. Once we stop it, it is gone and will not keep processing the input stream. That's what we're doing in this step. The counterpart to a transient query is a _persistent_ query, which we'll create a few steps from now.", "author": "colinhicks", "createdAt": "2020-06-05T14:10:00Z", "path": "_includes/tutorials/aggregating-count/ksql/markup/dev/transient-query.adoc", "diffHunk": "@@ -1,6 +1,6 @@\n-With our test data and configuration parameters in place, let\u2019s try a query to compute our ticket totals. A `SELECT` statement all by itself in ksqlDB is called a transient query, meaning that after we stop it, it is gone and will not keep processing the input stream. That's what we're doing in this step. The counterpart to a transient query is a _persistent_ query, which we'll create a few steps from now.\n+With our test data and configuration parameters in place, let\u2019s try a query to compute our ticket totals. A `SELECT` statement with an `EMIT CHANGES` in ksqlDB is called a transient push query, unlike a traditional db query, which returns a single result set, the query continuously streams back results and once we stop it, it is gone and will not keep processing the input stream. That's what we're doing in this step. The counterpart to a transient query is a _persistent_ query, which we'll create a few steps from now.", "originalCommit": "bc9bc70be9a5a8217e55a03b2c3074f2ea8ca983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk0ODkyMw==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/421#discussion_r435948923", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Since the output looks right, the next step is to make the query persistent. This looks exactly like the push query, except we have added a `CREATE TABLE AS` statement to the beginning of it. This statement returns to the CLI prompt right away, having created a persistent stream processing program running in the ksqlDB engine, continuously processing input records and updating the resulting `MOVIE_FIGURES_BY_YEAR` table. Moreover, we don't see the results of the query displayed in the CLI, because they are updating the newly-created table itself. That table is available to other ksqlDB queries for further processing, and by default all its records are produced to a topic having the same name (`MOVIE_FIGURES_BY_YEAR`).\n          \n          \n            \n            Since the output looks right, the next step is to make the query persistent. This looks exactly like the push query, except we have added a `CREATE TABLE AS` statement to the beginning of it. This statement returns to the CLI prompt right away, having created a persistent stream processing program running in the ksqlDB engine, continuously processing input records and updating the resulting `MOVIE_FIGURES_BY_YEAR` table.\n          \n          \n            \n            \n          \n          \n            \n            Moreover, we don't see the results of the query displayed in the CLI, because they are updating the newly-created table itself. That table is available to other ksqlDB queries for further processing, and by default all its records are produced to a topic having the same name (`MOVIE_FIGURES_BY_YEAR`).", "author": "colinhicks", "createdAt": "2020-06-05T14:11:14Z", "path": "_includes/tutorials/aggregating-minmax/ksql/markup/dev/persistent-query.adoc", "diffHunk": "@@ -1,4 +1,4 @@\n-Since the output looks right, the next step is to make the query persistent. This looks exactly like the transient query, except we have added a `CREATE TABLE AS` statement to the beginning of it. This statement returns to the CLI prompt right away, having created a persistent stream processing program running in the ksqlDB engine, continuously processing input records and updating the resulting `MOVIE_FIGURES_BY_YEAR` table. Moreover, we don't see the results of the query displayed in the CLI, because they are updating the newly-created table itself. That table is available to other ksqlDB queries for further processing, and by default all its records are produced to a topic having the same name (`MOVIE_FIGURES_BY_YEAR`).\n+Since the output looks right, the next step is to make the query persistent. This looks exactly like the push query, except we have added a `CREATE TABLE AS` statement to the beginning of it. This statement returns to the CLI prompt right away, having created a persistent stream processing program running in the ksqlDB engine, continuously processing input records and updating the resulting `MOVIE_FIGURES_BY_YEAR` table. Moreover, we don't see the results of the query displayed in the CLI, because they are updating the newly-created table itself. That table is available to other ksqlDB queries for further processing, and by default all its records are produced to a topic having the same name (`MOVIE_FIGURES_BY_YEAR`).", "originalCommit": "bc9bc70be9a5a8217e55a03b2c3074f2ea8ca983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk0OTkyNQ==", "url": "https://github.com/confluentinc/kafka-tutorials/pull/421#discussion_r435949925", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you're minimally familiar with SQL, the text of the query itself is fairly self-explanatory. We are calculating the highest and lowest grossing movie figures by year using `MIN` and `MAX` aggregations on the `TOTAL_SALES` column. This query will keep running, continuing to return results until you hit CTRL-C. Most ksqlDB queries are _continuous queries_ that run forever in this way; there is always potentially more input available in the source stream, so the query never finishes on its own.\n          \n          \n            \n            If you're familiar with SQL, the text of the query itself is fairly self-explanatory. We are calculating the highest and lowest grossing movie figures by year using `MIN` and `MAX` aggregations on the `TOTAL_SALES` column. This query will keep running, continuing to return results until you hit CTRL-C. Most ksqlDB queries are _continuous queries_ that run forever in this way; there is always potentially more input available in the source stream, so the query never finishes on its own.", "author": "colinhicks", "createdAt": "2020-06-05T14:12:51Z", "path": "_includes/tutorials/aggregating-minmax/ksql/markup/dev/transient-query.adoc", "diffHunk": "@@ -1,6 +1,6 @@\n-With our test data in place, let's try a query to compute the min and max. A SELECT statement all by itself in ksqlDB is called a _transient_ query, meaning that after we stop it, it is gone and will not keep processing the input stream. We'll create a _persistent_ query, the contrast to a transient query, a few steps from now.\n+With our test data in place, let's try a query to compute the min and max. A `SELECT` statement with an `EMIT CHANGES` in ksqlDB is called a _transient_ push query, meaning that after we stop it, it is gone and will not keep processing the input stream. We'll create a _persistent_ query, the contrast to a transient push query, a few steps from now.\n \n-If you're minimally familiar with SQL, the text of the query itself is fairly self-explanatory. We are calculating the highest and lowest grossing movie figures by year using `MIN` and `MAX` aggregations on the `TOTAL_SALES` field. This query will keep running, continuing to return results until you hit CTRL-C. Most ksqlDB queries are _continuous queries_ that run forever in this way; there is always potentially more input available in the source stream, so the query never finishes on its own.\n+If you're minimally familiar with SQL, the text of the query itself is fairly self-explanatory. We are calculating the highest and lowest grossing movie figures by year using `MIN` and `MAX` aggregations on the `TOTAL_SALES` column. This query will keep running, continuing to return results until you hit CTRL-C. Most ksqlDB queries are _continuous queries_ that run forever in this way; there is always potentially more input available in the source stream, so the query never finishes on its own.", "originalCommit": "bc9bc70be9a5a8217e55a03b2c3074f2ea8ca983", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a745b2193654639f64f8cb60d5ed275abc00d23", "url": "https://github.com/confluentinc/kafka-tutorials/commit/6a745b2193654639f64f8cb60d5ed275abc00d23", "message": "Update _includes/tutorials/aggregating-count/ksql/markup/dev/transient-query.adoc\n\nCo-authored-by: Colin Hicks <colin.hicks@gmail.com>", "committedDate": "2020-06-08T12:36:17Z", "type": "commit"}, {"oid": "1c21d1d4ff36c5962c3190c6dffdade78309857a", "url": "https://github.com/confluentinc/kafka-tutorials/commit/1c21d1d4ff36c5962c3190c6dffdade78309857a", "message": "Update _includes/tutorials/aggregating-minmax/ksql/markup/dev/persistent-query.adoc\n\nCo-authored-by: Colin Hicks <colin.hicks@gmail.com>", "committedDate": "2020-06-08T12:36:46Z", "type": "commit"}, {"oid": "a3cbcac7b41a11e463eb9e52e2f8a9e8cad63c1f", "url": "https://github.com/confluentinc/kafka-tutorials/commit/a3cbcac7b41a11e463eb9e52e2f8a9e8cad63c1f", "message": "Update _includes/tutorials/aggregating-minmax/ksql/markup/dev/transient-query.adoc\n\nCo-authored-by: Colin Hicks <colin.hicks@gmail.com>", "committedDate": "2020-06-08T12:37:08Z", "type": "commit"}, {"oid": "5d28e4fe922f5531ca29fb377512a4162838122f", "url": "https://github.com/confluentinc/kafka-tutorials/commit/5d28e4fe922f5531ca29fb377512a4162838122f", "message": "Merge branch 'ksqldb-latest' into update_agg_minmax", "committedDate": "2020-06-08T12:37:41Z", "type": "commit"}]}