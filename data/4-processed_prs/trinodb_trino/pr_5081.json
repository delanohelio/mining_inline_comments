{"pr_number": 5081, "pr_title": "Push dynamic filters into DynamicFilterService", "pr_createdAt": "2020-09-04T11:20:53Z", "pr_url": "https://github.com/trinodb/trino/pull/5081", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExNzcyNg==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r486117726", "bodyText": "there's a utility for this in guava : Runnables.doNothing", "author": "rohangarg", "createdAt": "2020-09-10T07:17:36Z", "path": "presto-main/src/test/java/io/prestosql/execution/TestMemoryRevokingScheduler.java", "diffHunk": "@@ -117,15 +117,15 @@ public void testScheduleMemoryRevoking()\n         SqlTask sqlTask1 = newSqlTask();\n         SqlTask sqlTask2 = newSqlTask();\n \n-        TaskContext taskContext1 = sqlTask1.getQueryContext().addTaskContext(new TaskStateMachine(new TaskId(\"q1\", 1, 1), executor), session, false, false, OptionalInt.empty());\n+        TaskContext taskContext1 = sqlTask1.getQueryContext().addTaskContext(new TaskStateMachine(new TaskId(\"q1\", 1, 1), executor), session, () -> {}, false, false, OptionalInt.empty());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "319c4f169818cb1732eee90ec46030acbf49f20c", "url": "https://github.com/trinodb/trino/commit/319c4f169818cb1732eee90ec46030acbf49f20c", "message": "Collect dynamic filters based on notification in DynamicFilterService", "committedDate": "2020-09-17T10:58:12Z", "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNTczNQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491125735", "bodyText": "Depending on what is happening inside of addTaskDynamicFilters this could result in an overwrite with an older version since this is outside of the synchronized block. As safer API would pass the version through to the addTaskDynamicFilters method so the receiver can deal with out of order notifications.", "author": "dain", "createdAt": "2020-09-18T18:36:41Z", "path": "presto-main/src/main/java/io/prestosql/server/remotetask/DynamicFiltersFetcher.java", "diffHunk": "@@ -216,20 +207,19 @@ public void fatal(Throwable cause)\n         }\n     }\n \n-    private synchronized void updateDynamicFilterDomains(VersionedDynamicFilterDomains newDynamicFilterDomains)\n+    private void updateDynamicFilterDomains(VersionedDynamicFilterDomains newDynamicFilterDomains)\n     {\n-        if (localDynamicFiltersVersion >= newDynamicFilterDomains.getVersion()) {\n-            // newer dynamic filters were already received\n-            return;\n-        }\n+        synchronized (this) {\n+            if (localDynamicFiltersVersion >= newDynamicFilterDomains.getVersion()) {\n+                // newer dynamic filters were already received\n+                return;\n+            }\n \n-        dynamicFilterDomains = concat(\n-                dynamicFilterDomains.entrySet().stream(),\n-                newDynamicFilterDomains.getDynamicFilterDomains().entrySet().stream())\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue, Domain::intersect));\n+            localDynamicFiltersVersion = newDynamicFilterDomains.getVersion();\n+            updateDynamicFiltersVersion(localDynamicFiltersVersion);\n+        }\n \n-        localDynamicFiltersVersion = newDynamicFilterDomains.getVersion();\n-        updateDynamicFiltersVersion(localDynamicFiltersVersion);\n+        dynamicFilterService.addTaskDynamicFilters(taskId, newDynamicFilterDomains.getDynamicFilterDomains());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2NDA5Ng==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491164096", "bodyText": "Subsequent DF versions can only be narrowing down. Order in which they are intersected doesn't matter. Therefore out-of-order execution is not an issue. Additionally, currently DF can have just a single version.", "author": "sopel39", "createdAt": "2020-09-18T20:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk4MDcxOQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491980719", "bodyText": "added comment", "author": "sopel39", "createdAt": "2020-09-21T11:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNjY3MA==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491126670", "bodyText": "no ned to wrap for this", "author": "dain", "createdAt": "2020-09-18T18:38:52Z", "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -464,10 +410,52 @@ public void testReplicatedDynamicFilter()\n                                 Domain.singleValue(INTEGER, 1L).toString(session.toConnectorSession()),\n                                 1,\n                                 0)));\n+    }\n \n-        // all dynamic filters have been collected, no need for more requests\n+    @Test\n+    public void testStageCannotScheduleMoreTasks()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId1 = new StageId(queryId, 1);\n+\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of());\n+\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId1, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), new TestingColumnHandle(\"probeColumnA\")));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNjk2MQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491126961", "bodyText": "I'd put this comment before the call to add the filter", "author": "dain", "createdAt": "2020-09-18T18:39:31Z", "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -464,10 +410,52 @@ public void testReplicatedDynamicFilter()\n                                 Domain.singleValue(INTEGER, 1L).toString(session.toConnectorSession()),\n                                 1,\n                                 0)));\n+    }\n \n-        // all dynamic filters have been collected, no need for more requests\n+    @Test\n+    public void testStageCannotScheduleMoreTasks()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId1 = new StageId(queryId, 1);\n+\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of());\n+\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId1, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), new TestingColumnHandle(\"probeColumnA\")));\n+        assertTrue(dynamicFilter.getCurrentPredicate().isAll());\n+        assertFalse(dynamicFilter.isComplete());\n+        CompletableFuture<?> blockedFuture = dynamicFilter.isBlocked();\n+        assertFalse(blockedFuture.isDone());\n+\n+        dynamicFilterService.addTaskDynamicFilters(\n+                new TaskId(stageId1, 0),\n+                ImmutableMap.of(filterId1, singleValue(INTEGER, 1L)));\n+        dynamicFilterService.collectDynamicFilters();\n+\n+        // adding task dynamic filters shouldn't complete dynamic filter", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyNzQ3NQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491127475", "bodyText": "you might want to do a get to verify the completable future doesn't contain an exception", "author": "dain", "createdAt": "2020-09-18T18:40:35Z", "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -464,10 +410,52 @@ public void testReplicatedDynamicFilter()\n                                 Domain.singleValue(INTEGER, 1L).toString(session.toConnectorSession()),\n                                 1,\n                                 0)));\n+    }\n \n-        // all dynamic filters have been collected, no need for more requests\n+    @Test\n+    public void testStageCannotScheduleMoreTasks()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId1 = new StageId(queryId, 1);\n+\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of());\n+\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId1, df1)),\n+                ImmutableMap.of(\n+                        Symbol.from(df1), new TestingColumnHandle(\"probeColumnA\")));\n+        assertTrue(dynamicFilter.getCurrentPredicate().isAll());\n+        assertFalse(dynamicFilter.isComplete());\n+        CompletableFuture<?> blockedFuture = dynamicFilter.isBlocked();\n+        assertFalse(blockedFuture.isDone());\n+\n+        dynamicFilterService.addTaskDynamicFilters(\n+                new TaskId(stageId1, 0),\n+                ImmutableMap.of(filterId1, singleValue(INTEGER, 1L)));\n+        dynamicFilterService.collectDynamicFilters();\n+\n+        // adding task dynamic filters shouldn't complete dynamic filter\n+        assertTrue(dynamicFilter.getCurrentPredicate().isAll());\n+        assertFalse(dynamicFilter.isComplete());\n+        assertFalse(blockedFuture.isDone());\n+\n+        dynamicFilterService.stageCannotScheduleMoreTasks(stageId1, 1);\n         dynamicFilterService.collectDynamicFilters();\n-        assertEquals(dynamicFiltersStageSupplier.getRequestCount(), 1);\n+\n+        // dynamic filter should be completed when stage won't have more tasks\n+        assertEquals(dynamicFilter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new TestingColumnHandle(\"probeColumnA\"),\n+                singleValue(INTEGER, 1L))));\n+        assertTrue(dynamicFilter.isComplete());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMDAzMA==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491130030", "bodyText": "Is a single thread enough for this service?", "author": "dain", "createdAt": "2020-09-18T18:46:12Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -83,33 +78,29 @@\n import static io.prestosql.sql.planner.SystemPartitioningHandle.SOURCE_DISTRIBUTION;\n import static io.prestosql.util.MorePredicates.isInstanceOfAny;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.Executors.newSingleThreadExecutor;\n \n @ThreadSafe\n public class DynamicFilterService\n {\n-    private final Duration dynamicFilteringRefreshInterval;\n-    private final ScheduledExecutorService collectDynamicFiltersExecutor = newSingleThreadScheduledExecutor(daemonThreadsNamed(\"DynamicFilterService\"));\n-\n+    private final ExecutorService executor;\n     private final Map<QueryId, DynamicFilterContext> dynamicFilterContexts = new ConcurrentHashMap<>();\n \n-    @Inject\n-    public DynamicFilterService(FeaturesConfig featuresConfig)\n+    public DynamicFilterService()\n     {\n-        this.dynamicFilteringRefreshInterval = requireNonNull(featuresConfig, \"featuresConfig is null\").getDynamicFilteringRefreshInterval();\n+        this(newSingleThreadExecutor(daemonThreadsNamed(\"DynamicFilterService\")));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3MDUzNg==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491170536", "bodyText": "It's a good point. This is to be tested, but I think I will improve this in subsequent PR. Generally, what happens here should not be that CPU intensive.", "author": "sopel39", "createdAt": "2020-09-18T20:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMDAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwNjg4Mg==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r495306882", "bodyText": "If it's not CPU intensive, does it need to be done asynchronously?", "author": "martint", "createdAt": "2020-09-25T23:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMDAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwNjg4NQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r495806885", "bodyText": "I think it needs more threads now, since there is potentially expensive union operation. Plus we might want to de-cast DFs which would involve calling satured_floor_casts", "author": "sopel39", "createdAt": "2020-09-28T09:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMjQxMQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491132411", "bodyText": "This formatting is a little confusing.  I'd pu the orElse on the previous like so you see this as a single command to start the stream like this:\nreturn selectedFilters.orElseGet(() -> stageDynamicFilters.get(stageId)).stream()\n        .collect(toImmutableMap(...", "author": "dain", "createdAt": "2020-09-18T18:51:14Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -616,21 +605,17 @@ private int getTotalDynamicFilters()\n             return dynamicFilters.size();\n         }\n \n-        private Set<StageId> getStages()\n-        {\n-            return stageDynamicFilters.keySet();\n-        }\n-\n         private OptionalInt getNumberOfTasks(StageId stageId)\n         {\n             return Optional.ofNullable(stageNumberOfTasks.get(stageId))\n                     .map(OptionalInt::of)\n                     .orElse(OptionalInt.empty());\n         }\n \n-        private Map<DynamicFilterId, List<Domain>> getTaskDynamicFilters(StageId stageId)\n+        private Map<DynamicFilterId, List<Domain>> getTaskDynamicFilters(StageId stageId, Optional<Set<DynamicFilterId>> selectedFilters)\n         {\n-            return stageDynamicFilters.get(stageId).stream()\n+            return selectedFilters\n+                    .orElseGet(() -> stageDynamicFilters.get(stageId)).stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzNDU5NA==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491134594", "bodyText": "Add this to the defunct configs", "author": "dain", "createdAt": "2020-09-18T18:55:57Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -782,21 +778,6 @@ public FeaturesConfig setDynamicFilteringMaxPerDriverSize(DataSize dynamicFilter\n         return this;\n     }\n \n-    @MinDuration(\"1ms\")\n-    @MaxDuration(\"10s\")\n-    @NotNull\n-    public Duration getDynamicFilteringRefreshInterval()\n-    {\n-        return dynamicFilteringRefreshInterval;\n-    }\n-\n-    @Config(\"experimental.dynamic-filtering-refresh-interval\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1NzMwNQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491157305", "bodyText": "Functions::identity", "author": "dain", "createdAt": "2020-09-18T19:46:50Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -605,55 +590,88 @@ public int hashCode()\n     private static class DynamicFilterContext\n     {\n         private final Map<DynamicFilterId, Domain> dynamicFilterSummaries = new ConcurrentHashMap<>();\n-        private final Supplier<List<StageDynamicFilters>> dynamicFilterSupplier;\n         private final Set<DynamicFilterId> dynamicFilters;\n         private final Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters;\n         private final Set<DynamicFilterId> replicatedDynamicFilters;\n         private final AtomicBoolean completed = new AtomicBoolean();\n+        private final Map<StageId, Set<DynamicFilterId>> stageDynamicFilters = new ConcurrentHashMap<>();\n+        private final Map<StageId, Integer> stageNumberOfTasks = new ConcurrentHashMap<>();\n+        // when map value for given filter id is empty it means that dynamic filter has already been collected\n+        // and no partial task domains are required\n+        private final Map<DynamicFilterId, Map<TaskId, Domain>> taskDynamicFilters = new ConcurrentHashMap<>();\n \n         private DynamicFilterContext(\n-                Supplier<List<StageDynamicFilters>> dynamicFilterSupplier,\n                 Set<DynamicFilterId> dynamicFilters,\n                 Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters,\n                 Set<DynamicFilterId> replicatedDynamicFilters)\n         {\n-            this.dynamicFilterSupplier = requireNonNull(dynamicFilterSupplier, \"dynamicFilterSupplier is null\");\n             this.dynamicFilters = requireNonNull(dynamicFilters, \"dynamicFilters is null\");\n             this.lazyDynamicFilters = requireNonNull(lazyDynamicFilters, \"lazyDynamicFilters is null\");\n             this.replicatedDynamicFilters = requireNonNull(replicatedDynamicFilters, \"replicatedDynamicFilters is null\");\n+            dynamicFilters.forEach(filter -> taskDynamicFilters.put(filter, new ConcurrentHashMap<>()));\n         }\n \n         private int getTotalDynamicFilters()\n         {\n             return dynamicFilters.size();\n         }\n \n-        private Set<DynamicFilterId> getUncollectedDynamicFilters()\n+        private Set<StageId> getStages()\n+        {\n+            return stageDynamicFilters.keySet();\n+        }\n+\n+        private OptionalInt getNumberOfTasks(StageId stageId)\n         {\n-            return dynamicFilters.stream()\n-                    .filter(filter -> !dynamicFilterSummaries.containsKey(filter))\n-                    .collect(toImmutableSet());\n+            return Optional.ofNullable(stageNumberOfTasks.get(stageId))\n+                    .map(OptionalInt::of)\n+                    .orElse(OptionalInt.empty());\n+        }\n+\n+        private Map<DynamicFilterId, List<Domain>> getTaskDynamicFilters(StageId stageId)\n+        {\n+            return stageDynamicFilters.get(stageId).stream()\n+                    .collect(toImmutableMap(\n+                            filter -> filter,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1ODQ1MQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491158451", "bodyText": "The currency of this class isn't really clear.  The fields use concurrent data structures, but the methods make coordinated changes between these data structures without synchronization.  Maybe the methods are safe but there aren't any comments on why it is a safe or warnings to be careful about changes.", "author": "dain", "createdAt": "2020-09-18T19:49:51Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -605,55 +590,88 @@ public int hashCode()\n     private static class DynamicFilterContext\n     {\n         private final Map<DynamicFilterId, Domain> dynamicFilterSummaries = new ConcurrentHashMap<>();\n-        private final Supplier<List<StageDynamicFilters>> dynamicFilterSupplier;\n         private final Set<DynamicFilterId> dynamicFilters;\n         private final Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters;\n         private final Set<DynamicFilterId> replicatedDynamicFilters;\n         private final AtomicBoolean completed = new AtomicBoolean();\n+        private final Map<StageId, Set<DynamicFilterId>> stageDynamicFilters = new ConcurrentHashMap<>();\n+        private final Map<StageId, Integer> stageNumberOfTasks = new ConcurrentHashMap<>();\n+        // when map value for given filter id is empty it means that dynamic filter has already been collected\n+        // and no partial task domains are required\n+        private final Map<DynamicFilterId, Map<TaskId, Domain>> taskDynamicFilters = new ConcurrentHashMap<>();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE2ODE3NQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r491168175", "bodyText": "It is safe since:\n\nWe are always adding information (task DFs) to DynamicFilterService. Order of how these information arrive doesn't matter.\nOnly when all required task DFa are collected, a summarized DF is constructed and future is done. This can happen only once.\nThere is no \"delete\" in DynamicFilterService, which makes order of execution arbitrary.\n\nDo you think there should be a comment like this here?", "author": "sopel39", "createdAt": "2020-09-18T20:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1ODQ1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyMTE4MA==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r492021180", "bodyText": "Added comments", "author": "sopel39", "createdAt": "2020-09-21T12:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1ODQ1MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwODc3OQ==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r495308779", "bodyText": "Why ImmutableList.copyOf?", "author": "martint", "createdAt": "2020-09-25T23:13:01Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -311,33 +331,28 @@ void collectDynamicFilters()\n                 continue;\n             }\n \n-            Set<DynamicFilterId> uncollectedFilters = context.getUncollectedDynamicFilters();\n             ImmutableMap.Builder<DynamicFilterId, Domain> newDynamicFiltersBuilder = ImmutableMap.builder();\n-            for (StageDynamicFilters stageDynamicFilters : context.getDynamicFilterSupplier().get()) {\n-                StageState stageState = stageDynamicFilters.getStageState();\n-                stageDynamicFilters.getTaskDynamicFilters().stream()\n-                        .flatMap(taskDomains -> taskDomains.entrySet().stream())\n-                        .filter(domain -> uncollectedFilters.contains(domain.getKey()))\n-                        .collect(groupingBy(Map.Entry::getKey, mapping(Map.Entry::getValue, toImmutableList())))\n-                        .entrySet().stream()\n+            for (StageId stageId : context.getStages()) {\n+                OptionalInt stageNumberOfTasks = context.getNumberOfTasks(stageId);\n+                context.getTaskDynamicFilters(stageId).entrySet().stream()\n                         .filter(stageDomains -> {\n                             if (stageDomains.getValue().stream().anyMatch(Domain::isAll)) {\n                                 // if one of the domains is all, we don't need to get dynamic filters from all tasks\n                                 return true;\n                             }\n \n-                            if (context.getReplicatedDynamicFilters().contains(stageDomains.getKey())) {\n+                            if (!stageDomains.getValue().isEmpty() && context.getReplicatedDynamicFilters().contains(stageDomains.getKey())) {\n+                                // for replicated dynamic filters it's enough to get dynamic filter from a single task\n                                 checkState(\n                                         stageDomains.getValue().size() == 1,\n                                         \"Replicated dynamic filter should be collected from single task\");\n-                                // for replicated dynamic filters it's enough to get dynamic filter from a single task\n                                 return true;\n                             }\n \n                             // check if all tasks of a dynamic filter source have reported dynamic filter summary\n-                            return !stageState.canScheduleMoreTasks() && stageDomains.getValue().size() == stageDynamicFilters.getNumberOfTasks();\n+                            return stageNumberOfTasks.isPresent() && stageDomains.getValue().size() == stageNumberOfTasks.getAsInt();\n                         })\n-                        .forEach(stageDomains -> newDynamicFiltersBuilder.put(stageDomains.getKey(), union(stageDomains.getValue())));\n+                        .forEach(stageDomains -> newDynamicFiltersBuilder.put(stageDomains.getKey(), union(ImmutableList.copyOf(stageDomains.getValue()))));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMxNTE5MA==", "url": "https://github.com/trinodb/trino/pull/5081#discussion_r495315190", "bodyText": "formatting:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        stageDynamicFilters.computeIfAbsent(taskId.getStageId(), ignored -> newConcurrentHashSet()).addAll(newDynamicFilters.keySet());\n          \n          \n            \n                        stageDynamicFilters.computeIfAbsent(taskId.getStageId(), ignored -> newConcurrentHashSet())\n          \n          \n            \n                                           .addAll(newDynamicFilters.keySet());", "author": "martint", "createdAt": "2020-09-25T23:26:57Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -605,58 +591,100 @@ public int hashCode()\n         }\n     }\n \n+    /*\n+     * DynamicFilterContext can be fully lock-free since computing dynamic filter summaries\n+     * is idempotent. Concurrent computations of DF summaries should produce exact same result\n+     * when partial (from tasks) DFs are available. Partial DFs are only removed when\n+     * final dynamic filter summary is computed.\n+     */\n     private static class DynamicFilterContext\n     {\n         private final Map<DynamicFilterId, Domain> dynamicFilterSummaries = new ConcurrentHashMap<>();\n-        private final Supplier<List<StageDynamicFilters>> dynamicFilterSupplier;\n         private final Set<DynamicFilterId> dynamicFilters;\n         private final Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters;\n         private final Set<DynamicFilterId> replicatedDynamicFilters;\n         private final AtomicBoolean completed = new AtomicBoolean();\n+        private final Map<StageId, Set<DynamicFilterId>> stageDynamicFilters = new ConcurrentHashMap<>();\n+        private final Map<StageId, Integer> stageNumberOfTasks = new ConcurrentHashMap<>();\n+        // when map value for given filter id is empty it means that dynamic filter has already been collected\n+        // and no partial task domains are required\n+        private final Map<DynamicFilterId, Map<TaskId, Domain>> taskDynamicFilters = new ConcurrentHashMap<>();\n \n         private DynamicFilterContext(\n-                Supplier<List<StageDynamicFilters>> dynamicFilterSupplier,\n                 Set<DynamicFilterId> dynamicFilters,\n                 Map<DynamicFilterId, SettableFuture<?>> lazyDynamicFilters,\n                 Set<DynamicFilterId> replicatedDynamicFilters)\n         {\n-            this.dynamicFilterSupplier = requireNonNull(dynamicFilterSupplier, \"dynamicFilterSupplier is null\");\n             this.dynamicFilters = requireNonNull(dynamicFilters, \"dynamicFilters is null\");\n             this.lazyDynamicFilters = requireNonNull(lazyDynamicFilters, \"lazyDynamicFilters is null\");\n             this.replicatedDynamicFilters = requireNonNull(replicatedDynamicFilters, \"replicatedDynamicFilters is null\");\n+            dynamicFilters.forEach(filter -> taskDynamicFilters.put(filter, new ConcurrentHashMap<>()));\n         }\n \n         private int getTotalDynamicFilters()\n         {\n             return dynamicFilters.size();\n         }\n \n-        private Set<DynamicFilterId> getUncollectedDynamicFilters()\n+        private Set<StageId> getStages()\n+        {\n+            return stageDynamicFilters.keySet();\n+        }\n+\n+        private OptionalInt getNumberOfTasks(StageId stageId)\n         {\n-            return dynamicFilters.stream()\n-                    .filter(filter -> !dynamicFilterSummaries.containsKey(filter))\n-                    .collect(toImmutableSet());\n+            return Optional.ofNullable(stageNumberOfTasks.get(stageId))\n+                    .map(OptionalInt::of)\n+                    .orElse(OptionalInt.empty());\n+        }\n+\n+        private Map<DynamicFilterId, List<Domain>> getTaskDynamicFilters(StageId stageId)\n+        {\n+            return stageDynamicFilters.get(stageId).stream()\n+                    .collect(toImmutableMap(\n+                            identity(),\n+                            filter -> Optional.ofNullable(taskDynamicFilters.get(filter))\n+                                    .map(taskDomains -> ImmutableList.copyOf(taskDomains.values()))\n+                                    // return empty list in case filter has already been collected and task domains have been removed\n+                                    .orElse(ImmutableList.of())));\n         }\n \n         private void addDynamicFilters(Map<DynamicFilterId, Domain> newDynamicFilters)\n         {\n             newDynamicFilters.forEach((filter, domain) -> {\n                 dynamicFilterSummaries.put(filter, domain);\n+                taskDynamicFilters.remove(filter);\n                 Optional.ofNullable(lazyDynamicFilters.get(filter)).ifPresent(future -> future.set(null));\n             });\n \n             // stop collecting dynamic filters for query when all dynamic filters have been collected\n             completed.set(dynamicFilters.stream().allMatch(dynamicFilterSummaries::containsKey));\n         }\n \n-        private Map<DynamicFilterId, Domain> getDynamicFilterSummaries()\n+        private void addTaskDynamicFilters(TaskId taskId, Map<DynamicFilterId, Domain> newDynamicFilters)\n         {\n-            return dynamicFilterSummaries;\n+            stageDynamicFilters.computeIfAbsent(taskId.getStageId(), ignored -> newConcurrentHashSet()).addAll(newDynamicFilters.keySet());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e54b06c717fd6b1b0d14df5903e8223b9979f211", "url": "https://github.com/trinodb/trino/commit/e54b06c717fd6b1b0d14df5903e8223b9979f211", "message": "Rename method to acknowledgeAndGetNewDynamicFilterDomains", "committedDate": "2020-09-28T08:58:25Z", "type": "commit"}, {"oid": "322a3c2681828215a22a7ede75bd6cddf6f464f0", "url": "https://github.com/trinodb/trino/commit/322a3c2681828215a22a7ede75bd6cddf6f464f0", "message": "Push dynamic filters into DynamicFilterService", "committedDate": "2020-09-28T09:14:57Z", "type": "commit"}, {"oid": "b7ed592ef53e11102d9ab305e2ea857bc9cfc2fa", "url": "https://github.com/trinodb/trino/commit/b7ed592ef53e11102d9ab305e2ea857bc9cfc2fa", "message": "Collect dynamic filters based on notification in DynamicFilterService", "committedDate": "2020-09-28T09:24:28Z", "type": "commit"}, {"oid": "4e1e6c2dfd24a648ae7bf3f5d0a6abac22e3ca6b", "url": "https://github.com/trinodb/trino/commit/4e1e6c2dfd24a648ae7bf3f5d0a6abac22e3ca6b", "message": "Assert that future did not finish exceptionally", "committedDate": "2020-09-28T09:24:28Z", "type": "commit"}, {"oid": "480f8f5fde4bdbe8e5391540384aaa0a168bf253", "url": "https://github.com/trinodb/trino/commit/480f8f5fde4bdbe8e5391540384aaa0a168bf253", "message": "Remove unused variable", "committedDate": "2020-09-28T09:25:12Z", "type": "commit"}, {"oid": "993876bdfbc223fd4569bf847366b2eb796a3d9a", "url": "https://github.com/trinodb/trino/commit/993876bdfbc223fd4569bf847366b2eb796a3d9a", "message": "Fix formatting", "committedDate": "2020-09-28T09:25:26Z", "type": "commit"}, {"oid": "993876bdfbc223fd4569bf847366b2eb796a3d9a", "url": "https://github.com/trinodb/trino/commit/993876bdfbc223fd4569bf847366b2eb796a3d9a", "message": "Fix formatting", "committedDate": "2020-09-28T09:25:26Z", "type": "forcePushed"}]}