{"pr_number": 5355, "pr_title": "Add support for OAuth2 authorization in Web UI", "pr_createdAt": "2020-09-30T08:19:28Z", "pr_url": "https://github.com/trinodb/trino/pull/5355", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMzMTg3OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497331879", "bodyText": "Maybe SecureRandomUtils. One might think that using RandomUtils is fast.", "author": "skrzypo987", "createdAt": "2020-09-30T08:26:49Z", "path": "presto-main/src/main/java/io/prestosql/util/RandomUtils.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.util;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.SecureRandom;\n+\n+public final class RandomUtils", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ0MTMxMA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497441310", "bodyText": "or https://stackoverflow.com/a/60997561", "author": "ssheikin", "createdAt": "2020-09-30T11:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMzMTg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQzMzU0Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497433547", "bodyText": "maybe use already defined constant if such exists or extract constant/variable", "author": "ssheikin", "createdAt": "2020-09-30T11:23:45Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtException;\n+import io.prestosql.server.security.Authenticator;\n+import io.prestosql.server.security.RedirectAuthenticationException;\n+import io.prestosql.server.security.oauth2.JWKSSigningKeyResolver.UncheckedJwkException;\n+import io.prestosql.spi.security.Identity;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.Cookie;\n+\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.server.ui.FormWebUiAuthenticationFilter.PRESTO_UI_COOKIE;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Predicate.not;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+\n+public class OAuth2Authenticator\n+        implements Authenticator\n+{\n+    private static final Logger LOG = Logger.get(OAuth2Authenticator.class);\n+\n+    private final OAuth2Service service;\n+\n+    @Inject\n+    public OAuth2Authenticator(OAuth2Service service)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+    }\n+\n+    @Override\n+    public Identity authenticate(ContainerRequestContext request)\n+            throws RedirectAuthenticationException\n+    {\n+        return getAccessToken(request)\n+                .map(token -> Identity.forUser(token.getBody().getSubject()).build())\n+                .orElseThrow(() -> {\n+                    Challenge.Started challenge = service.startChallenge();\n+                    return new RedirectAuthenticationException(\n+                            \"Unauthorized\",\n+                            format(\"Bearer realm=\\\"Presto\\\", authorizationUrl=\\\"%s\\\", status=\\\"%s\\\"\",\n+                                    challenge.getAuthorizationUrl(),\n+                                    challenge.getStatus()),\n+                            challenge.getAuthorizationUrl());\n+                });\n+    }\n+\n+    private Optional<Jws<Claims>> getAccessToken(ContainerRequestContext request)\n+    {\n+        Stream<String> accessTokenSources = Stream.concat(Stream.concat(\n+                getTokenFromCookie(request),\n+                getTokenFromHeader(request)),\n+                getTokenFromQueryParam(request));\n+        return accessTokenSources\n+                .filter(not(String::isBlank))\n+                .map(token -> {\n+                    try {\n+                        return Optional.ofNullable(service.parseClaimsJws(token));\n+                    }\n+                    catch (JwtException | IllegalArgumentException | UncheckedJwkException e) {\n+                        LOG.debug(\"Unable to parse JWT token: \" + e.getMessage(), e);\n+                        return Optional.<Jws<Claims>>empty();\n+                    }\n+                })\n+                .findFirst()\n+                .flatMap(Function.identity());\n+    }\n+\n+    private Stream<String> getTokenFromCookie(ContainerRequestContext request)\n+    {\n+        return Stream\n+                .ofNullable(request.getCookies().get(PRESTO_UI_COOKIE))\n+                .map(Cookie::getValue);\n+    }\n+\n+    private Stream<String> getTokenFromHeader(ContainerRequestContext request)\n+    {\n+        return Stream\n+                .ofNullable(request.getHeaders().get(AUTHORIZATION))\n+                .flatMap(Collection::stream)\n+                .filter(Objects::nonNull)\n+                .filter(header -> header.startsWith(\"Bearer \"))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ0MjM1Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497442352", "bodyText": "static import Duration will be more readable", "author": "ssheikin", "createdAt": "2020-09-30T11:40:46Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestingHydraService.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.prestosql.util.AutoCloseableCloser;\n+import org.testcontainers.containers.FixedHostPortGenericContainer;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testcontainers.containers.wait.strategy.Wait;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import static io.prestosql.util.RandomUtils.randomAlphanumeric;\n+\n+class TestingHydraService\n+        implements Closeable, AutoCloseable\n+{\n+    static final int TTL_ACCESS_TOKEN_IN_SECONDS = 2;\n+    private static final String HYDRA_IMAGE = \"oryd/hydra:v1.4.2\";\n+    private static final String DSN = \"postgres://hydra:mysecretpassword@database:5432/hydra?sslmode=disable\";\n+\n+    private final Network network = Network.newNetwork();\n+\n+    private final PostgreSQLContainer<?> databaseContainer = new PostgreSQLContainer<>()\n+            .withNetwork(network)\n+            .withNetworkAliases(\"database\")\n+            .withUsername(\"hydra\")\n+            .withPassword(\"mysecretpassword\")\n+            .withDatabaseName(\"hydra\");\n+\n+    private final GenericContainer<?> migrationContainer = createHydraContainer()\n+            .withCommand(\"migrate sql --yes \" + DSN)\n+            .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofMinutes(5)));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5NDg3Ng==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497494876", "bodyText": "subject is principal, you need to map it to user:\n            String authenticatedUser = userMapping.mapUser(principal.toString());\n            return Identity.forUser(authenticatedUser)\n                    .withPrincipal(principal)\n                    .build();", "author": "kokosing", "createdAt": "2020-09-30T13:08:21Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtException;\n+import io.prestosql.server.security.Authenticator;\n+import io.prestosql.server.security.RedirectAuthenticationException;\n+import io.prestosql.server.security.oauth2.JWKSSigningKeyResolver.UncheckedJwkException;\n+import io.prestosql.spi.security.Identity;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.Cookie;\n+\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.server.ui.FormWebUiAuthenticationFilter.PRESTO_UI_COOKIE;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Predicate.not;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+\n+public class OAuth2Authenticator\n+        implements Authenticator\n+{\n+    private static final Logger LOG = Logger.get(OAuth2Authenticator.class);\n+\n+    private final OAuth2Service service;\n+\n+    @Inject\n+    public OAuth2Authenticator(OAuth2Service service)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+    }\n+\n+    @Override\n+    public Identity authenticate(ContainerRequestContext request)\n+            throws RedirectAuthenticationException\n+    {\n+        return getAccessToken(request)\n+                .map(token -> Identity.forUser(token.getBody().getSubject()).build())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc2MzEzMw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497763133", "bodyText": "I'm not sure if this is a \"failure\".  I feel like this is more like \"authentication was redirected to...\"... BTW just a nit", "author": "dain", "createdAt": "2020-09-30T19:54:31Z", "path": "presto-main/src/main/java/io/prestosql/server/ui/FormWebUiAuthenticationFilter.java", "diffHunk": "@@ -173,6 +179,11 @@ private static void handleProtocolLoginRequest(Authenticator authenticator, Cont\n         try {\n             authenticatedIdentity = authenticator.authenticate(request);\n         }\n+        catch (RedirectAuthenticationException e) {\n+            sendRedirect(request, e.getLocation());\n+            LOG.debug(format(\"Authentication failed: %s. Redirecting to: %s\", e.getMessage(), e.getLocation()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4Njg2OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497786869", "bodyText": "This inner class retains a live reference to the config object, which is mutable.  Instead, the values should be read out of the config and assigned to fields.", "author": "dain", "createdAt": "2020-09-30T20:40:18Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.github.scribejava.core.builder.ServiceBuilder;\n+import com.github.scribejava.core.builder.api.DefaultApi20;\n+import com.github.scribejava.core.oauth.OAuth20Service;\n+import io.airlift.http.server.HttpServerConfig;\n+import io.prestosql.server.security.Authenticator;\n+import io.prestosql.server.security.RedirectAuthenticationException;\n+import io.prestosql.spi.security.Identity;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import static io.prestosql.util.RandomUtils.randomAlphanumeric;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Authenticator\n+        implements Authenticator\n+{\n+    private final OAuth20Service service;\n+\n+    @Inject\n+    public OAuth2Authenticator(OAuth2Config oauth2Config, HttpServerConfig httpServerConfig)\n+    {\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        requireNonNull(httpServerConfig, \"httpServerConfig is null\");\n+        this.service = new ServiceBuilder(oauth2Config.getClientId())\n+                .apiSecret(oauth2Config.getClientSecret())\n+                .defaultScope(\"openid\")\n+                .callback(format(\"https://127.0.0.1:%s/callback\", httpServerConfig.getHttpsPort()))\n+                .build(new DefaultApi20()\n+                {\n+                    @Override\n+                    public String getAccessTokenEndpoint()\n+                    {\n+                        return oauth2Config.getTokenUrl();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4NjkyMA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497786920", "bodyText": "same", "author": "dain", "createdAt": "2020-09-30T20:40:25Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.github.scribejava.core.builder.ServiceBuilder;\n+import com.github.scribejava.core.builder.api.DefaultApi20;\n+import com.github.scribejava.core.oauth.OAuth20Service;\n+import io.airlift.http.server.HttpServerConfig;\n+import io.prestosql.server.security.Authenticator;\n+import io.prestosql.server.security.RedirectAuthenticationException;\n+import io.prestosql.spi.security.Identity;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import static io.prestosql.util.RandomUtils.randomAlphanumeric;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Authenticator\n+        implements Authenticator\n+{\n+    private final OAuth20Service service;\n+\n+    @Inject\n+    public OAuth2Authenticator(OAuth2Config oauth2Config, HttpServerConfig httpServerConfig)\n+    {\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        requireNonNull(httpServerConfig, \"httpServerConfig is null\");\n+        this.service = new ServiceBuilder(oauth2Config.getClientId())\n+                .apiSecret(oauth2Config.getClientSecret())\n+                .defaultScope(\"openid\")\n+                .callback(format(\"https://127.0.0.1:%s/callback\", httpServerConfig.getHttpsPort()))\n+                .build(new DefaultApi20()\n+                {\n+                    @Override\n+                    public String getAccessTokenEndpoint()\n+                    {\n+                        return oauth2Config.getTokenUrl();\n+                    }\n+\n+                    @Override\n+                    protected String getAuthorizationBaseUrl()\n+                    {\n+                        return oauth2Config.getAuthUrl();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNDk5Mw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497814993", "bodyText": "Is there a pure java OIDC server we can use instead?  I'd prefer to avoid Docker if there is Java one we can use.", "author": "dain", "createdAt": "2020-09-30T21:36:51Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestingHydraService.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.prestosql.util.AutoCloseableCloser;\n+import org.testcontainers.containers.FixedHostPortGenericContainer;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testcontainers.containers.wait.strategy.Wait;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import static io.prestosql.util.RandomUtils.randomAlphanumeric;\n+\n+public class TestingHydraService", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NDY4Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r499754682", "bodyText": "There are a few alternatives such as: https://www.gluu.org/ and https://www.keycloak.org/ and a bunch of solutions built on top of Spring Framework Security lib such as: https://github.com/cloudfoundry/uaa. I've chosen ORY Hydra because it's lightweight, have well built docker image and extracts login & consent flow to an external app which might be handy in the future https://www.ory.sh/hydra/docs/login-consent-flow/.", "author": "lukasz-walkiewicz", "createdAt": "2020-10-05T17:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNDk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNTc1Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497815752", "bodyText": "We already have pem files for localhost that are used by TestWebUI. cert/localhost.pem", "author": "dain", "createdAt": "2020-09-30T21:38:32Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.prestosql.plugin.tpch.TpchPlugin;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.HttpHeaders.WWW_AUTHENTICATE;\n+import static javax.ws.rs.core.Response.Status.FOUND;\n+import static javax.ws.rs.core.Response.Status.UNAUTHORIZED;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2Authenticator\n+{\n+    private static final String TEST_CATALOG = \"test_catalog\";\n+\n+    private static final int HTTPS_PORT = ThreadLocalRandom.current().nextInt(50000, 60000);\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+\n+    public TestOAuth2Authenticator()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);\n+        testingHydraService.start();\n+\n+        createConsumer();\n+\n+        server = TestingPrestoServer.builder()\n+                .setCoordinator(true)\n+                .setAdditionalModule(new WebUiModule())\n+                .setProperties(\n+                        ImmutableMap.<String, String>builder()\n+                                .put(\"web-ui.enabled\", \"true\")\n+                                .put(\"web-ui.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.https.port\", Integer.toString(HTTPS_PORT))\n+                                .put(\"http-server.https.enabled\", \"true\")\n+                                .put(\"http-server.https.keystore.path\", Resources.getResource(\"io/prestosql/security/localhost.keystore\").getPath())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNzE5NQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497817195", "bodyText": "I believe these field names are defined in a specification.  We should note the spec, or at least add a comment saying \"don't change these field names\"", "author": "dain", "createdAt": "2020-09-30T21:41:39Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Error.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Error\n+{\n+    private final String error;\n+    private final Optional<String> errorDescription;\n+    private final Optional<String> errorUri;\n+\n+    @JsonCreator\n+    public OAuth2Error(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgyMTcwOA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497821708", "bodyText": "There is guava method for this Strings.isNullOrEmpty... there might be something in the JVM that does this", "author": "dain", "createdAt": "2020-09-30T21:51:25Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Resource.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.prestosql.server.security.ResourceSecurity;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Cookie;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.SecurityContext;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.server.security.ResourceSecurity.AccessType.PUBLIC;\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_API_PREFIX;\n+import static io.prestosql.server.ui.FormWebUiAuthenticationFilter.PRESTO_UI_COOKIE;\n+import static io.prestosql.server.ui.FormWebUiAuthenticationFilter.UI_LOCATION;\n+import static java.util.Objects.requireNonNull;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.Response.Status.BAD_REQUEST;\n+import static javax.ws.rs.core.Response.Status.FOUND;\n+\n+@Path(OAUTH2_API_PREFIX)\n+public class OAuth2Resource\n+{\n+    static final String OAUTH2_API_PREFIX = \"/oauth2\";\n+    static final String CALLBACK_ENDPOINT = \"/callback\";\n+\n+    private final OAuth2Service service;\n+\n+    @Inject\n+    public OAuth2Resource(OAuth2Service service)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+    }\n+\n+    @ResourceSecurity(PUBLIC)\n+    @GET\n+    @Path(CALLBACK_ENDPOINT)\n+    public Response callback(\n+            @QueryParam(\"state\") String state,\n+            @QueryParam(\"code\") String code,\n+            @QueryParam(\"error\") String error,\n+            @QueryParam(\"error_description\") String errorDescription,\n+            @QueryParam(\"error_uri\") String errorUri,\n+            @Context SecurityContext securityContext)\n+    {\n+        if (error != null && !error.isBlank()) {\n+            return Response\n+                    .status(BAD_REQUEST)\n+                    .entity(new OAuth2Error(error, Optional.ofNullable(errorDescription), Optional.ofNullable(errorUri)))\n+                    .build();\n+        }\n+        if (state == null || state.isBlank()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgyMjg1NA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497822854", "bodyText": "same comment about config objects", "author": "dain", "createdAt": "2020-09-30T21:54:14Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.github.scribejava.core.builder.ServiceBuilder;\n+import com.github.scribejava.core.builder.api.DefaultApi20;\n+import com.github.scribejava.core.oauth.OAuth20Service;\n+import io.airlift.http.server.HttpServerConfig;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.CALLBACK_ENDPOINT;\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_API_PREFIX;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private final HttpServerConfig httpServerConfig;\n+    private final OAuth20Service service;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Config oauth2Config, HttpServerConfig httpServerConfig)\n+    {\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.httpServerConfig = requireNonNull(httpServerConfig, \"httpServerConfig is null\");\n+        this.service = new ServiceBuilder(oauth2Config.getClientId())\n+                .apiSecret(oauth2Config.getClientSecret())\n+                .defaultScope(\"openid\")\n+                .callback(serverUrl() + OAUTH2_API_PREFIX + CALLBACK_ENDPOINT)\n+                .build(new DefaultApi20()\n+                {\n+                    @Override\n+                    public String getAccessTokenEndpoint()\n+                    {\n+                        return oauth2Config.getTokenUrl();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgyMzM1NQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497823355", "bodyText": "Static import", "author": "dain", "createdAt": "2020-09-30T21:55:18Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.github.scribejava.core.builder.ServiceBuilder;\n+import com.github.scribejava.core.builder.api.DefaultApi20;\n+import com.github.scribejava.core.oauth.OAuth20Service;\n+import io.airlift.http.server.HttpServerConfig;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.CALLBACK_ENDPOINT;\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_API_PREFIX;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private final HttpServerConfig httpServerConfig;\n+    private final OAuth20Service service;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Config oauth2Config, HttpServerConfig httpServerConfig)\n+    {\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.httpServerConfig = requireNonNull(httpServerConfig, \"httpServerConfig is null\");\n+        this.service = new ServiceBuilder(oauth2Config.getClientId())\n+                .apiSecret(oauth2Config.getClientSecret())\n+                .defaultScope(\"openid\")\n+                .callback(serverUrl() + OAUTH2_API_PREFIX + CALLBACK_ENDPOINT)\n+                .build(new DefaultApi20()\n+                {\n+                    @Override\n+                    public String getAccessTokenEndpoint()\n+                    {\n+                        return oauth2Config.getTokenUrl();\n+                    }\n+\n+                    @Override\n+                    protected String getAuthorizationBaseUrl()\n+                    {\n+                        return oauth2Config.getAuthUrl();\n+                    }\n+                });\n+    }\n+\n+    Challenge.Started startChallenge()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgyNzA5MQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497827091", "bodyText": "This seems like a long way to get 16 random bytes.  I suggest you use something like this:\nprivate static final SecureRandom SECURE_RANDOM = new SecureRandom();\n\nstatic String randomState()\n{\n    byte[] randomBytes = new byte[16];\n    SECURE_RANDOM.nextBytes(randomBytes);\n    return Base64.getEncoder().encodeToString(randomBytes);\n}\n\nThis skips the round trip through UUID and strings.", "author": "dain", "createdAt": "2020-09-30T22:04:14Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/State.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+\n+class State\n+{\n+    private final String value;\n+\n+    State(String value)\n+    {\n+        this.value = requireNonNull(value, \"values is null\");\n+    }\n+\n+    String get()\n+    {\n+        return value;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        State state = (State) o;\n+        return value.equals(state.value);\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return Objects.hash(value);\n+    }\n+\n+    static State randomState()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgyOTk4NQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497829985", "bodyText": "I would use toString for this, and maybe replace the constructor with a valueOf method.", "author": "dain", "createdAt": "2020-09-30T22:11:39Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/State.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+\n+class State\n+{\n+    private final String value;\n+\n+    State(String value)\n+    {\n+        this.value = requireNonNull(value, \"values is null\");\n+    }\n+\n+    String get()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNTQzOQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497835439", "bodyText": "When doing chaining, don't put a newline for the first call.", "author": "dain", "createdAt": "2020-09-30T22:26:22Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -38,12 +55,62 @@ public OAuth2Authenticator(OAuth2Service service)\n     public Identity authenticate(ContainerRequestContext request)\n             throws RedirectAuthenticationException\n     {\n-        Challenge.Started challenge = service.startChallenge();\n-        throw new RedirectAuthenticationException(\n-                \"Unauthorized\",\n-                format(\"Bearer realm=\\\"Presto\\\", authorizationUrl=\\\"%s\\\", status=\\\"%s\\\"\",\n-                        challenge.getAuthorizationUrl(),\n-                        challenge.getStatus()),\n-                challenge.getAuthorizationUrl());\n+        return getAccessToken(request)\n+                .map(token -> Identity.forUser(token.getBody().getSubject()).build())\n+                .orElseThrow(() -> {\n+                    Challenge.Started challenge = service.startChallenge();\n+                    return new RedirectAuthenticationException(\n+                            \"Unauthorized\",\n+                            format(\"Bearer realm=\\\"Presto\\\", authorizationUrl=\\\"%s\\\", status=\\\"%s\\\"\",\n+                                    challenge.getAuthorizationUrl(),\n+                                    challenge.getStatus()),\n+                            challenge.getAuthorizationUrl());\n+                });\n+    }\n+\n+    private Optional<Jws<Claims>> getAccessToken(ContainerRequestContext request)\n+    {\n+        Stream<String> accessTokenSources = Stream.concat(Stream.concat(\n+                getTokenFromCookie(request),\n+                getTokenFromHeader(request)),\n+                getTokenFromQueryParam(request));\n+        return accessTokenSources\n+                .filter(not(String::isBlank))\n+                .map(token -> {\n+                    try {\n+                        return Optional.ofNullable(service.parseClaimsJws(token));\n+                    }\n+                    catch (JwtException | IllegalArgumentException | UncheckedJwkException e) {\n+                        LOG.debug(\"Unable to parse JWT token: \" + e.getMessage(), e);\n+                        return Optional.<Jws<Claims>>empty();\n+                    }\n+                })\n+                .findFirst()\n+                .flatMap(Function.identity());\n+    }\n+\n+    private Stream<String> getTokenFromCookie(ContainerRequestContext request)\n+    {\n+        return Stream", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNTg4MA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497835880", "bodyText": "This will compile the regular expression for each call.  Instead just do something like header.substring(\"Bearer \".length())", "author": "dain", "createdAt": "2020-09-30T22:27:34Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -38,12 +55,62 @@ public OAuth2Authenticator(OAuth2Service service)\n     public Identity authenticate(ContainerRequestContext request)\n             throws RedirectAuthenticationException\n     {\n-        Challenge.Started challenge = service.startChallenge();\n-        throw new RedirectAuthenticationException(\n-                \"Unauthorized\",\n-                format(\"Bearer realm=\\\"Presto\\\", authorizationUrl=\\\"%s\\\", status=\\\"%s\\\"\",\n-                        challenge.getAuthorizationUrl(),\n-                        challenge.getStatus()),\n-                challenge.getAuthorizationUrl());\n+        return getAccessToken(request)\n+                .map(token -> Identity.forUser(token.getBody().getSubject()).build())\n+                .orElseThrow(() -> {\n+                    Challenge.Started challenge = service.startChallenge();\n+                    return new RedirectAuthenticationException(\n+                            \"Unauthorized\",\n+                            format(\"Bearer realm=\\\"Presto\\\", authorizationUrl=\\\"%s\\\", status=\\\"%s\\\"\",\n+                                    challenge.getAuthorizationUrl(),\n+                                    challenge.getStatus()),\n+                            challenge.getAuthorizationUrl());\n+                });\n+    }\n+\n+    private Optional<Jws<Claims>> getAccessToken(ContainerRequestContext request)\n+    {\n+        Stream<String> accessTokenSources = Stream.concat(Stream.concat(\n+                getTokenFromCookie(request),\n+                getTokenFromHeader(request)),\n+                getTokenFromQueryParam(request));\n+        return accessTokenSources\n+                .filter(not(String::isBlank))\n+                .map(token -> {\n+                    try {\n+                        return Optional.ofNullable(service.parseClaimsJws(token));\n+                    }\n+                    catch (JwtException | IllegalArgumentException | UncheckedJwkException e) {\n+                        LOG.debug(\"Unable to parse JWT token: \" + e.getMessage(), e);\n+                        return Optional.<Jws<Claims>>empty();\n+                    }\n+                })\n+                .findFirst()\n+                .flatMap(Function.identity());\n+    }\n+\n+    private Stream<String> getTokenFromCookie(ContainerRequestContext request)\n+    {\n+        return Stream\n+                .ofNullable(request.getCookies().get(PRESTO_UI_COOKIE))\n+                .map(Cookie::getValue);\n+    }\n+\n+    private Stream<String> getTokenFromHeader(ContainerRequestContext request)\n+    {\n+        return Stream\n+                .ofNullable(request.getHeaders().get(AUTHORIZATION))\n+                .flatMap(Collection::stream)\n+                .filter(Objects::nonNull)\n+                .filter(header -> header.startsWith(\"Bearer \"))\n+                .map(header -> header.replaceFirst(\"^Bearer \", \"\"));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkwODc1OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497908759", "bodyText": "Why both?", "author": "martint", "createdAt": "2020-10-01T01:17:53Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestingHydraService.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.prestosql.util.AutoCloseableCloser;\n+import org.testcontainers.containers.FixedHostPortGenericContainer;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testcontainers.containers.wait.strategy.Wait;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import static io.prestosql.util.RandomUtils.randomAlphanumeric;\n+\n+class TestingHydraService\n+        implements Closeable, AutoCloseable", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxMzA0Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r501513047", "bodyText": "I've removed unnecessary AutoCloseable.", "author": "lukasz-walkiewicz", "createdAt": "2020-10-08T07:45:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkwODc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxMTMwOA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497911308", "bodyText": "These methods look to be part of the public interface of this class, so they should be public", "author": "martint", "createdAt": "2020-10-01T01:21:55Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestingHydraService.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.prestosql.util.AutoCloseableCloser;\n+import org.testcontainers.containers.FixedHostPortGenericContainer;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testcontainers.containers.wait.strategy.Wait;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.time.Duration;\n+\n+import static io.prestosql.util.RandomUtils.randomAlphanumeric;\n+\n+class TestingHydraService\n+        implements Closeable, AutoCloseable\n+{\n+    static final int TTL_ACCESS_TOKEN_IN_SECONDS = 2;\n+    private static final String HYDRA_IMAGE = \"oryd/hydra:v1.4.2\";\n+    private static final String DSN = \"postgres://hydra:mysecretpassword@database:5432/hydra?sslmode=disable\";\n+\n+    private final Network network = Network.newNetwork();\n+\n+    private final PostgreSQLContainer<?> databaseContainer = new PostgreSQLContainer<>()\n+            .withNetwork(network)\n+            .withNetworkAliases(\"database\")\n+            .withUsername(\"hydra\")\n+            .withPassword(\"mysecretpassword\")\n+            .withDatabaseName(\"hydra\");\n+\n+    private final GenericContainer<?> migrationContainer = createHydraContainer()\n+            .withCommand(\"migrate sql --yes \" + DSN)\n+            .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofMinutes(5)));\n+\n+    private final FixedHostPortGenericContainer<?> consentContainer = new FixedHostPortGenericContainer<>(\"oryd/hydra-login-consent-node:v1.4.2\")\n+            .withNetwork(network)\n+            .withNetworkAliases(\"consent\")\n+            .withExposedPorts(3000)\n+            .withEnv(\"HYDRA_ADMIN_URL\", \"http://hydra:4445\")\n+            .withEnv(\"NODE_TLS_REJECT_UNAUTHORIZED\", \"0\")\n+            .waitingFor(Wait.forHttp(\"/\").forStatusCode(200));\n+\n+    private final FixedHostPortGenericContainer<?> hydraContainer = createHydraContainer()\n+            .withNetworkAliases(\"hydra\")\n+            .withExposedPorts(4444, 4445)\n+            .withEnv(\"SECRETS_SYSTEM\", randomAlphanumeric(32))\n+            .withEnv(\"DSN\", DSN)\n+            .withEnv(\"URLS_SELF_ISSUER\", \"http://hydra:4444/\")\n+            .withEnv(\"URLS_CONSENT\", \"http://consent:3000/consent\")\n+            .withEnv(\"URLS_LOGIN\", \"http://consent:3000/login\")\n+            .withEnv(\"OAUTH2_ACCESS_TOKEN_STRATEGY\", \"jwt\")\n+            .withEnv(\"TTL_ACCESS_TOKEN\", TTL_ACCESS_TOKEN_IN_SECONDS + \"s\")\n+            .withCommand(\"serve all --dangerous-force-http\")\n+            .waitingFor(Wait.forHttp(\"/health/ready\").forPort(4444).forStatusCode(200));\n+\n+    private final AutoCloseableCloser closer = AutoCloseableCloser.create();\n+\n+    TestingHydraService()\n+    {\n+        closer.register(network);\n+        closer.register(databaseContainer);\n+        closer.register(migrationContainer);\n+        closer.register(consentContainer);\n+        closer.register(hydraContainer);\n+    }\n+\n+    void start()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxODY1MQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497918651", "bodyText": "Jetty is an implementation detail of Airlift HTTP server. Anything we need from Jetty should be added as an abstraction in Airlift. Adding a specific Jetty version here could conflict when we upgrade in Airlift.", "author": "electrum", "createdAt": "2020-10-01T01:33:57Z", "path": "pom.xml", "diffHunk": "@@ -1170,6 +1183,12 @@\n                 </exclusions>\n             </dependency>\n \n+            <dependency>\n+                <groupId>org.eclipse.jetty</groupId>\n+                <artifactId>jetty-util</artifactId>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxODkzMw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497918933", "bodyText": "Why did we pick this specific library? What alternatives were considered?", "author": "electrum", "createdAt": "2020-10-01T01:34:23Z", "path": "pom.xml", "diffHunk": "@@ -905,6 +906,12 @@\n                 </exclusions>\n             </dependency>\n \n+            <dependency>\n+                <groupId>com.auth0</groupId>\n+                <artifactId>jwks-rsa</artifactId>", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4MjIxNQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r501782215", "bodyText": "I'm going change it to #5419.", "author": "lukasz-walkiewicz", "createdAt": "2020-10-08T14:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxODkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkzNTk1NA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r512935954", "bodyText": "Is this going to be removed?", "author": "dain", "createdAt": "2020-10-27T18:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxODkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxOTAzMw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497919033", "bodyText": "Same question for this.", "author": "electrum", "createdAt": "2020-10-01T01:34:30Z", "path": "pom.xml", "diffHunk": "@@ -936,6 +943,12 @@\n                 <version>${dep.jackson.version}</version>\n             </dependency>\n \n+            <dependency>\n+                <groupId>com.github.scribejava</groupId>\n+                <artifactId>scribejava-core</artifactId>", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM5NjEwOA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r503396108", "bodyText": "Scribe Java (https://github.com/scribejava/scribejava) looks like quite simple, modern and community-driven library.", "author": "lukasz-walkiewicz", "createdAt": "2020-10-12T16:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxOTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxOTI4Mw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497919283", "bodyText": "Why are we excluding this everywhere? This seems wrong.", "author": "electrum", "createdAt": "2020-10-01T01:34:53Z", "path": "presto-accumulo/pom.xml", "diffHunk": "@@ -246,6 +246,12 @@\n             <groupId>io.prestosql</groupId>\n             <artifactId>presto-main</artifactId>\n             <scope>test</scope>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>commons-codec</groupId>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkxOTk2Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497919962", "bodyText": "Why exclude this?", "author": "electrum", "createdAt": "2020-10-01T01:35:43Z", "path": "presto-main/pom.xml", "diffHunk": "@@ -201,6 +206,17 @@\n             <artifactId>jackson-databind</artifactId>\n         </dependency>\n \n+        <dependency>\n+            <groupId>com.github.scribejava</groupId>\n+            <artifactId>scribejava-core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>com.fasterxml.jackson.core</groupId>\n+                    <artifactId>jackson-databind</artifactId>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkyMDcyMg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497920722", "bodyText": "Why are we excluding OkHttp? If this is actually used and it is a versioning conflict, we and we know it is compatible, we should exclude the check from version checker.\nAlso, we generally add exclusions in dependencyManagement, not at the usage site.", "author": "electrum", "createdAt": "2020-10-01T01:36:55Z", "path": "presto-main/pom.xml", "diffHunk": "@@ -400,6 +421,94 @@\n             <artifactId>jmh-generator-annprocess</artifactId>\n             <scope>test</scope>\n         </dependency>\n+\n+        <dependency>\n+            <groupId>org.seleniumhq.selenium</groupId>\n+            <artifactId>selenium-api</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.seleniumhq.selenium</groupId>\n+            <artifactId>selenium-chrome-driver</artifactId>\n+            <scope>test</scope>\n+            <exclusions>\n+                <exclusion>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzMTcwMA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497931700", "bodyText": "UrlJwkProvider is not good. It uses URLConnection which is ancient and has various problems, and doesn't allow configuration of things like TrustStore, proxy, etc., except by setting global system properties (which we clearly do not want users doing). We should write our own using Airlift HTTP client so that users can fully configure it as they do with other components.", "author": "electrum", "createdAt": "2020-10-01T01:54:45Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/JWKSSigningKeyResolver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.auth0.jwk.Jwk;\n+import com.auth0.jwk.JwkException;\n+import com.auth0.jwk.JwkProvider;\n+import com.auth0.jwk.UrlJwkProvider;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.SigningKeyResolver;\n+\n+import java.security.Key;\n+import java.security.PublicKey;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+class JWKSSigningKeyResolver\n+        implements SigningKeyResolver\n+{\n+    private final String idpUrl;\n+\n+    JWKSSigningKeyResolver(String idpUrl)\n+    {\n+        this.idpUrl = requireNonNull(idpUrl, \"idpUrl is null\");\n+    }\n+\n+    @Override\n+    public Key resolveSigningKey(JwsHeader header, Claims claims)\n+    {\n+        return getPublicKey(header.getKeyId());\n+    }\n+\n+    @Override\n+    public Key resolveSigningKey(JwsHeader header, String plaintext)\n+    {\n+        return getPublicKey(header.getKeyId());\n+    }\n+\n+    private PublicKey getPublicKey(String keyId)\n+    {\n+        JwkProvider provider = new UrlJwkProvider(idpUrl);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3NzczOQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r501777739", "bodyText": "I'm going to use @dain's JWK implementation after #5419 has been merged.", "author": "lukasz-walkiewicz", "createdAt": "2020-10-08T14:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzMTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIzNTY5MQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r503235691", "bodyText": "I added auth0 library to presto in our internal version to get JWKS working with Presto. I ended up changing auth0 code to support proxy so that I can access remote JWKS endpoint (not directly accessible from presto production environment). Looks like Dain's work will eliminate this need.", "author": "sajjoseph", "createdAt": "2020-10-12T11:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzMTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzNDM5MQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497934391", "bodyText": "No need to add a new dependency for this. We already use OkHttp in test code, so you can use HttpUrl.", "author": "electrum", "createdAt": "2020-10-01T01:59:04Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.HttpHeaders.WWW_AUTHENTICATE;\n+import static javax.ws.rs.core.Response.Status.FOUND;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.UNAUTHORIZED;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2Authenticator\n+{\n+    private static final int HTTPS_PORT = ThreadLocalRandom.current().nextInt(50000, 60000);\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+\n+    public TestOAuth2Authenticator()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);\n+        testingHydraService.start();\n+\n+        createConsumer();\n+\n+        server = TestingPrestoServer.builder()\n+                .setCoordinator(true)\n+                .setAdditionalModule(new WebUiModule())\n+                .setProperties(\n+                        ImmutableMap.<String, String>builder()\n+                                .put(\"web-ui.enabled\", \"true\")\n+                                .put(\"web-ui.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.https.port\", Integer.toString(HTTPS_PORT))\n+                                .put(\"http-server.https.enabled\", \"true\")\n+                                .put(\"http-server.https.keystore.path\", Resources.getResource(\"io/prestosql/security/localhost.keystore\").getPath())\n+                                .put(\"http-server.https.keystore.key\", \"changeit\")\n+                                .put(\"http-server.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.authentication.oauth2.self-url\", \"https://host.testcontainers.internal:\" + HTTPS_PORT)\n+                                .put(\"http-server.authentication.oauth2.server-url\", \"http://localhost:\" + testingHydraService.getHydraPort())\n+                                .put(\"http-server.authentication.oauth2.auth-url\", \"http://hydra:4444/oauth2/auth\")\n+                                .put(\"http-server.authentication.oauth2.token-url\", format(\"http://localhost:%s/oauth2/token\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.client-id\", \"another-consumer\")\n+                                .put(\"http-server.authentication.oauth2.client-secret\", \"consumer-secret\")\n+                                .build())\n+                .build();\n+        waitForNodeRefresh(server);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        Closeables.closeAll(server, testingHydraService);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedApiCall()\n+            throws IOException\n+    {\n+        Response response = httpClient\n+                .newCall(apiCall().build())\n+                .execute();\n+\n+        assertUnauthorizedApiResponse(response);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedUICall()\n+            throws IOException\n+    {\n+        Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute();\n+\n+        assertThat(response.code()).isEqualTo(FOUND.getStatusCode());\n+        assertRedirectUrl(response.header(LOCATION));\n+    }\n+\n+    @Test\n+    public void testInvalidToken()\n+            throws NoSuchAlgorithmException, IOException\n+    {\n+        KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(\"RSA\");\n+        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.RS256;\n+        keyGenerator.initialize(4096);\n+        String token = Jwts.builder()\n+                .setHeaderParam(\"alg\", \"RS256\")\n+                .setHeaderParam(\"kid\", \"public:f467aa08-1c1b-4cde-ba45-84b0ef5d2ba8\")\n+                .setHeaderParam(\"typ\", \"JWT\")\n+                .setClaims(\n+                        new DefaultClaims(\n+                                ImmutableMap.<String, Object>builder()\n+                                        .put(\"aud\", ImmutableList.of())\n+                                        .put(\"client_id\", \"another-consumer\")\n+                                        .put(\"exp\", System.currentTimeMillis() / 1000L + 60L)\n+                                        .put(\"iat\", System.currentTimeMillis())\n+                                        .put(\"iss\", \"http://hydra:4444/\")\n+                                        .put(\"jti\", UUID.randomUUID())\n+                                        .put(\"nbf\", System.currentTimeMillis() - 60L)\n+                                        .put(\"scp\", ImmutableList.of(\"openid\"))\n+                                        .put(\"sub\", \"foo@bar.com\")\n+                                        .build()))\n+                .signWith(signatureAlgorithm, keyGenerator.generateKeyPair().getPrivate())\n+                .compact();\n+\n+        Response response = httpClient.newCall(\n+                apiCall()\n+                        .header(AUTHORIZATION, \"Bearer \" + token)\n+                        .build())\n+                .execute();\n+        assertUnauthorizedApiResponse(response);\n+    }\n+\n+    @Test\n+    public void testSuccessfulFlow()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication((driver, wait) -> {\n+            assertPrestoCookie(driver.manage().getCookieNamed(\"Presto-UI-Token\"));\n+            String accessToken = driver.manage().getCookieNamed(\"Presto-UI-Token\").getValue();\n+\n+            // pass access token in header\n+            assertThat(httpClient.newCall(\n+                    apiCall()\n+                            .header(AUTHORIZATION, \"Bearer \" + accessToken)\n+                            .build())\n+                    .execute()\n+                    .code())\n+                    .isEqualTo(OK.getStatusCode());\n+\n+            // pass access token in query\n+            assertThat(httpClient.newCall(\n+                    apiCall()\n+                            .url(UriBuilder\n+                                    .fromPath(format(\"https://127.0.0.1:%d/v1/query\", HTTPS_PORT))\n+                                    .queryParam(\"access_token\", accessToken)\n+                                    .build()\n+                                    .toURL())\n+                            .build())\n+                    .execute()\n+                    .code())\n+                    .isEqualTo(OK.getStatusCode());\n+        });\n+    }\n+\n+    @Test\n+    public void testExpiredAccessToken()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication(((driver, wait) -> {\n+            String accessToken = driver.manage().getCookieNamed(\"Presto-UI-Token\").getValue();\n+            Thread.sleep((TTL_ACCESS_TOKEN_IN_SECONDS + 1) * 1000L); // wait for the token expiration\n+            Response response = httpClient.newCall(\n+                    apiCall()\n+                            .header(AUTHORIZATION, \"Bearer \" + accessToken)\n+                            .build())\n+                    .execute();\n+            assertUnauthorizedApiResponse(response);\n+        }));\n+    }\n+\n+    private void createConsumer()\n+    {\n+        testingHydraService.createHydraContainer()\n+                .withCommand(format(\"clients create \" +\n+                        \"--endpoint http://hydra:4445 \" +\n+                        \"--id another-consumer \" +\n+                        \"--secret consumer-secret \" +\n+                        \"-g authorization_code,refresh_token \" +\n+                        \"-r token,code,id_token \" +\n+                        \"--scope openid,offline \" +\n+                        \"--callbacks https://host.testcontainers.internal:%d/oauth2/callback\", HTTPS_PORT))\n+                .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofSeconds(30)))\n+                .start();\n+    }\n+\n+    private static Request.Builder uiCall()\n+    {\n+        return new Request.Builder()\n+                .url(format(\"https://127.0.0.1:%d/ui/\", HTTPS_PORT))\n+                .get();\n+    }\n+\n+    private static Request.Builder apiCall()\n+    {\n+        return new Request.Builder()\n+                .url(format(\"https://127.0.0.1:%d/v1/query\", HTTPS_PORT))\n+                .get();\n+    }\n+\n+    private static void assertUnauthorizedApiResponse(Response response)\n+            throws MalformedURLException\n+    {\n+        assertThat(response.code()).isEqualTo(UNAUTHORIZED.getStatusCode());\n+        String authenticateHeader = response.header(WWW_AUTHENTICATE);\n+        assertThat(authenticateHeader).isNotNull();\n+        Matcher authenticateHeaderMatcher = Pattern.compile(\"^Bearer realm=\\\"Presto\\\", authorizationUrl=\\\"(.*)\\\", status=\\\"STARTED\\\"$\")\n+                .matcher(authenticateHeader);\n+        assertThat(authenticateHeaderMatcher.matches()).isTrue();\n+        assertRedirectUrl(authenticateHeaderMatcher.group(1));\n+    }\n+\n+    private static void assertRedirectUrl(String redirectUrl)\n+            throws MalformedURLException\n+    {\n+        assertThat(redirectUrl).isNotNull();\n+        URL location = new URL(redirectUrl);\n+        assertThat(location.getProtocol()).isEqualTo(\"http\");\n+        assertThat(location.getHost()).isEqualTo(\"hydra\");\n+        assertThat(location.getPort()).isEqualTo(4444);\n+        assertThat(location.getPath()).isEqualTo(\"/oauth2/auth\");\n+        MultiMap<String> parameters = new MultiMap<>();\n+        UrlEncoded.decodeTo(location.getQuery(), parameters, \"UTF-8\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzNjkyMw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497936923", "bodyText": "execute() returns a Response which needs to be used in try-with-resources", "author": "electrum", "createdAt": "2020-10-01T02:03:01Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.HttpHeaders.WWW_AUTHENTICATE;\n+import static javax.ws.rs.core.Response.Status.FOUND;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.UNAUTHORIZED;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2Authenticator\n+{\n+    private static final int HTTPS_PORT = ThreadLocalRandom.current().nextInt(50000, 60000);\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+\n+    public TestOAuth2Authenticator()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);\n+        testingHydraService.start();\n+\n+        createConsumer();\n+\n+        server = TestingPrestoServer.builder()\n+                .setCoordinator(true)\n+                .setAdditionalModule(new WebUiModule())\n+                .setProperties(\n+                        ImmutableMap.<String, String>builder()\n+                                .put(\"web-ui.enabled\", \"true\")\n+                                .put(\"web-ui.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.https.port\", Integer.toString(HTTPS_PORT))\n+                                .put(\"http-server.https.enabled\", \"true\")\n+                                .put(\"http-server.https.keystore.path\", Resources.getResource(\"io/prestosql/security/localhost.keystore\").getPath())\n+                                .put(\"http-server.https.keystore.key\", \"changeit\")\n+                                .put(\"http-server.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.authentication.oauth2.self-url\", \"https://host.testcontainers.internal:\" + HTTPS_PORT)\n+                                .put(\"http-server.authentication.oauth2.server-url\", \"http://localhost:\" + testingHydraService.getHydraPort())\n+                                .put(\"http-server.authentication.oauth2.auth-url\", \"http://hydra:4444/oauth2/auth\")\n+                                .put(\"http-server.authentication.oauth2.token-url\", format(\"http://localhost:%s/oauth2/token\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.client-id\", \"another-consumer\")\n+                                .put(\"http-server.authentication.oauth2.client-secret\", \"consumer-secret\")\n+                                .build())\n+                .build();\n+        waitForNodeRefresh(server);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        Closeables.closeAll(server, testingHydraService);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedApiCall()\n+            throws IOException\n+    {\n+        Response response = httpClient\n+                .newCall(apiCall().build())\n+                .execute();\n+\n+        assertUnauthorizedApiResponse(response);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedUICall()\n+            throws IOException\n+    {\n+        Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute();\n+\n+        assertThat(response.code()).isEqualTo(FOUND.getStatusCode());\n+        assertRedirectUrl(response.header(LOCATION));\n+    }\n+\n+    @Test\n+    public void testInvalidToken()\n+            throws NoSuchAlgorithmException, IOException\n+    {\n+        KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(\"RSA\");\n+        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.RS256;\n+        keyGenerator.initialize(4096);\n+        String token = Jwts.builder()\n+                .setHeaderParam(\"alg\", \"RS256\")\n+                .setHeaderParam(\"kid\", \"public:f467aa08-1c1b-4cde-ba45-84b0ef5d2ba8\")\n+                .setHeaderParam(\"typ\", \"JWT\")\n+                .setClaims(\n+                        new DefaultClaims(\n+                                ImmutableMap.<String, Object>builder()\n+                                        .put(\"aud\", ImmutableList.of())\n+                                        .put(\"client_id\", \"another-consumer\")\n+                                        .put(\"exp\", System.currentTimeMillis() / 1000L + 60L)\n+                                        .put(\"iat\", System.currentTimeMillis())\n+                                        .put(\"iss\", \"http://hydra:4444/\")\n+                                        .put(\"jti\", UUID.randomUUID())\n+                                        .put(\"nbf\", System.currentTimeMillis() - 60L)\n+                                        .put(\"scp\", ImmutableList.of(\"openid\"))\n+                                        .put(\"sub\", \"foo@bar.com\")\n+                                        .build()))\n+                .signWith(signatureAlgorithm, keyGenerator.generateKeyPair().getPrivate())\n+                .compact();\n+\n+        Response response = httpClient.newCall(\n+                apiCall()\n+                        .header(AUTHORIZATION, \"Bearer \" + token)\n+                        .build())\n+                .execute();\n+        assertUnauthorizedApiResponse(response);\n+    }\n+\n+    @Test\n+    public void testSuccessfulFlow()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication((driver, wait) -> {\n+            assertPrestoCookie(driver.manage().getCookieNamed(\"Presto-UI-Token\"));\n+            String accessToken = driver.manage().getCookieNamed(\"Presto-UI-Token\").getValue();\n+\n+            // pass access token in header\n+            assertThat(httpClient.newCall(\n+                    apiCall()\n+                            .header(AUTHORIZATION, \"Bearer \" + accessToken)\n+                            .build())\n+                    .execute()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzNzk2OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497937969", "bodyText": "There is no guarantee the chosen port is unused.", "author": "electrum", "createdAt": "2020-10-01T02:04:46Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.HttpHeaders.WWW_AUTHENTICATE;\n+import static javax.ws.rs.core.Response.Status.FOUND;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.UNAUTHORIZED;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2Authenticator\n+{\n+    private static final int HTTPS_PORT = ThreadLocalRandom.current().nextInt(50000, 60000);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzODM3Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497938372", "bodyText": "Doing this as a global static seems like the wrong way to go. We don't do this anywhere else. Instead, we should start the container and ask for its port.", "author": "electrum", "createdAt": "2020-10-01T02:05:21Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.HttpHeaders.WWW_AUTHENTICATE;\n+import static javax.ws.rs.core.Response.Status.FOUND;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.UNAUTHORIZED;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2Authenticator\n+{\n+    private static final int HTTPS_PORT = ThreadLocalRandom.current().nextInt(50000, 60000);\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+\n+    public TestOAuth2Authenticator()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM5MTk2Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r503391967", "bodyText": "It's a different kind of problem. Here we're exposing the host's port to the selenium-driver container and it has to be done through this static method. Additionally, this method have to be called before the start of the containers so it's sort of \"the chicken or the egg\" problem as the Presto server needs to know the Hydra's port before the start.", "author": "lukasz-walkiewicz", "createdAt": "2020-10-12T16:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzODM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzODU0NQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497938545", "bodyText": "We should not hard code and assume the container is running on 127.0.0.1", "author": "electrum", "createdAt": "2020-10-01T02:05:36Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import javax.ws.rs.core.UriBuilder;\n+\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.UUID;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.HttpHeaders.WWW_AUTHENTICATE;\n+import static javax.ws.rs.core.Response.Status.FOUND;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.UNAUTHORIZED;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2Authenticator\n+{\n+    private static final int HTTPS_PORT = ThreadLocalRandom.current().nextInt(50000, 60000);\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+\n+    public TestOAuth2Authenticator()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);\n+        testingHydraService.start();\n+\n+        createConsumer();\n+\n+        server = TestingPrestoServer.builder()\n+                .setCoordinator(true)\n+                .setAdditionalModule(new WebUiModule())\n+                .setProperties(\n+                        ImmutableMap.<String, String>builder()\n+                                .put(\"web-ui.enabled\", \"true\")\n+                                .put(\"web-ui.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.https.port\", Integer.toString(HTTPS_PORT))\n+                                .put(\"http-server.https.enabled\", \"true\")\n+                                .put(\"http-server.https.keystore.path\", Resources.getResource(\"io/prestosql/security/localhost.keystore\").getPath())\n+                                .put(\"http-server.https.keystore.key\", \"changeit\")\n+                                .put(\"http-server.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.authentication.oauth2.self-url\", \"https://host.testcontainers.internal:\" + HTTPS_PORT)\n+                                .put(\"http-server.authentication.oauth2.server-url\", \"http://localhost:\" + testingHydraService.getHydraPort())\n+                                .put(\"http-server.authentication.oauth2.auth-url\", \"http://hydra:4444/oauth2/auth\")\n+                                .put(\"http-server.authentication.oauth2.token-url\", format(\"http://localhost:%s/oauth2/token\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.client-id\", \"another-consumer\")\n+                                .put(\"http-server.authentication.oauth2.client-secret\", \"consumer-secret\")\n+                                .build())\n+                .build();\n+        waitForNodeRefresh(server);\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        Closeables.closeAll(server, testingHydraService);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedApiCall()\n+            throws IOException\n+    {\n+        Response response = httpClient\n+                .newCall(apiCall().build())\n+                .execute();\n+\n+        assertUnauthorizedApiResponse(response);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedUICall()\n+            throws IOException\n+    {\n+        Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute();\n+\n+        assertThat(response.code()).isEqualTo(FOUND.getStatusCode());\n+        assertRedirectUrl(response.header(LOCATION));\n+    }\n+\n+    @Test\n+    public void testInvalidToken()\n+            throws NoSuchAlgorithmException, IOException\n+    {\n+        KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(\"RSA\");\n+        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.RS256;\n+        keyGenerator.initialize(4096);\n+        String token = Jwts.builder()\n+                .setHeaderParam(\"alg\", \"RS256\")\n+                .setHeaderParam(\"kid\", \"public:f467aa08-1c1b-4cde-ba45-84b0ef5d2ba8\")\n+                .setHeaderParam(\"typ\", \"JWT\")\n+                .setClaims(\n+                        new DefaultClaims(\n+                                ImmutableMap.<String, Object>builder()\n+                                        .put(\"aud\", ImmutableList.of())\n+                                        .put(\"client_id\", \"another-consumer\")\n+                                        .put(\"exp\", System.currentTimeMillis() / 1000L + 60L)\n+                                        .put(\"iat\", System.currentTimeMillis())\n+                                        .put(\"iss\", \"http://hydra:4444/\")\n+                                        .put(\"jti\", UUID.randomUUID())\n+                                        .put(\"nbf\", System.currentTimeMillis() - 60L)\n+                                        .put(\"scp\", ImmutableList.of(\"openid\"))\n+                                        .put(\"sub\", \"foo@bar.com\")\n+                                        .build()))\n+                .signWith(signatureAlgorithm, keyGenerator.generateKeyPair().getPrivate())\n+                .compact();\n+\n+        Response response = httpClient.newCall(\n+                apiCall()\n+                        .header(AUTHORIZATION, \"Bearer \" + token)\n+                        .build())\n+                .execute();\n+        assertUnauthorizedApiResponse(response);\n+    }\n+\n+    @Test\n+    public void testSuccessfulFlow()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication((driver, wait) -> {\n+            assertPrestoCookie(driver.manage().getCookieNamed(\"Presto-UI-Token\"));\n+            String accessToken = driver.manage().getCookieNamed(\"Presto-UI-Token\").getValue();\n+\n+            // pass access token in header\n+            assertThat(httpClient.newCall(\n+                    apiCall()\n+                            .header(AUTHORIZATION, \"Bearer \" + accessToken)\n+                            .build())\n+                    .execute()\n+                    .code())\n+                    .isEqualTo(OK.getStatusCode());\n+\n+            // pass access token in query\n+            assertThat(httpClient.newCall(\n+                    apiCall()\n+                            .url(UriBuilder\n+                                    .fromPath(format(\"https://127.0.0.1:%d/v1/query\", HTTPS_PORT))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzOTAzNQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497939035", "bodyText": "Exception class names normally end in Exception", "author": "electrum", "createdAt": "2020-10-01T02:06:20Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/ChallengeNotFound.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+class ChallengeNotFound", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzkzOTY3Ng==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497939676", "bodyText": "Use the constructor rather than string parsing", "author": "electrum", "createdAt": "2020-10-01T02:07:17Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Config.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.configuration.Config;\n+import io.airlift.configuration.ConfigDescription;\n+import io.airlift.units.Duration;\n+import io.airlift.units.MinDuration;\n+\n+import javax.validation.constraints.NotNull;\n+\n+public class OAuth2Config\n+{\n+    private String selfUrl;\n+    private String serverUrl;\n+    private String authUrl;\n+    private String tokenUrl;\n+    private String clientId;\n+    private String clientSecret;\n+    private Duration challengeTimeout = Duration.valueOf(\"15m\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MDQ1Mw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497940453", "bodyText": "Do we expect to add new states? This trick of trailing comma is used to make it easy to add new enum values in the future. If not, write this as\nenum Status\n{\n    STARTED, SUCCEEDED, FAILED\n}", "author": "electrum", "createdAt": "2020-10-01T02:08:27Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/Status.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+enum Status\n+{\n+    STARTED,\n+    SUCCEEDED,\n+    FAILED,\n+    /**/;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MTIzMg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497941232", "bodyText": "We should leave this choice to the JVM configuration. Instead, just do new SecureRandom() like we do elsewhere.", "author": "electrum", "createdAt": "2020-10-01T02:09:38Z", "path": "presto-main/src/main/java/io/prestosql/util/RandomUtils.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.util;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.SecureRandom;\n+\n+public final class RandomUtils\n+{\n+    private static final SecureRandom secureRandom;\n+\n+    static {\n+        try {\n+            secureRandom = SecureRandom.getInstance(\"SHA1PRNG\", \"SUN\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk0MzE3MA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r497943170", "bodyText": "Since this is just for tests, you could do\nUUID.randomUUID().toString().replace(\" \", \"\");", "author": "electrum", "createdAt": "2020-10-01T02:12:44Z", "path": "presto-main/src/main/java/io/prestosql/util/RandomUtils.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.util;\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.SecureRandom;\n+\n+public final class RandomUtils\n+{\n+    private static final SecureRandom secureRandom;\n+\n+    static {\n+        try {\n+            secureRandom = SecureRandom.getInstance(\"SHA1PRNG\", \"SUN\");\n+        }\n+        catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private RandomUtils() {}\n+\n+    public static String randomAlphanumeric(int length)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "f792a6c9e18db298be51274e31d050fdb2be89b3", "url": "https://github.com/trinodb/trino/commit/f792a6c9e18db298be51274e31d050fdb2be89b3", "message": "Verify OAuth2 user's authentication", "committedDate": "2020-10-14T09:09:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMyNTkwMw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r504325903", "bodyText": "Is OAuth2 the right name for this authenticator?  I believe this assumes assumes that tokens are in JWT format, which I believe is part of the OIDC specification.  If true, should we rename this OidcAuthenticator (and the package to oidc)?", "author": "dain", "createdAt": "2020-10-14T00:04:55Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtException;\n+import io.prestosql.server.security.AuthenticationException;\n+import io.prestosql.server.security.Authenticator;\n+import io.prestosql.server.security.RedirectAuthenticationException;\n+import io.prestosql.server.security.UserMapping;\n+import io.prestosql.server.security.UserMappingException;\n+import io.prestosql.server.security.oauth2.JWKSSigningKeyResolver.UncheckedJwkException;\n+import io.prestosql.spi.security.BasicPrincipal;\n+import io.prestosql.spi.security.Identity;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.Cookie;\n+\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_COOKIE;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Predicate.not;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+\n+public class OAuth2Authenticator", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODkxMw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r508818913", "bodyText": "OIDC is a layer which sits on top of OAuth2 and since this code implements only the OAuth2 spec I think the name is appropriate.", "author": "lukasz-walkiewicz", "createdAt": "2020-10-20T20:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMyNTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMyNjM4OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r504326389", "bodyText": "use oauth2Binder... same for everything below this", "author": "dain", "createdAt": "2020-10-14T00:06:44Z", "path": "presto-main/src/main/java/io/prestosql/server/security/ServerSecurityModule.java", "diffHunk": "@@ -71,6 +77,12 @@ protected void setup(Binder binder)\n         installAuthenticator(\"kerberos\", KerberosAuthenticator.class, KerberosConfig.class);\n         installAuthenticator(\"password\", PasswordAuthenticator.class, PasswordAuthenticatorConfig.class);\n         installAuthenticator(\"jwt\", JsonWebTokenAuthenticator.class, JsonWebTokenConfig.class);\n+        install(authenticatorModule(\"oauth2\", OAuth2Authenticator.class, oauth2Binder -> {\n+            configBinder(oauth2Binder).bindConfig(OAuth2Config.class);\n+            binder.bind(OAuth2Service.class).in(Scopes.SINGLETON);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMyNjc5MQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r504326791", "bodyText": "consider adding a OAuth2SupportModule like is did in the JWK PR where I addedJwtAuthenticatorSupportModule.", "author": "dain", "createdAt": "2020-10-14T00:08:16Z", "path": "presto-main/src/main/java/io/prestosql/server/security/ServerSecurityModule.java", "diffHunk": "@@ -71,6 +77,12 @@ protected void setup(Binder binder)\n         installAuthenticator(\"kerberos\", KerberosAuthenticator.class, KerberosConfig.class);\n         installAuthenticator(\"password\", PasswordAuthenticator.class, PasswordAuthenticatorConfig.class);\n         installAuthenticator(\"jwt\", JsonWebTokenAuthenticator.class, JsonWebTokenConfig.class);\n+        install(authenticatorModule(\"oauth2\", OAuth2Authenticator.class, oauth2Binder -> {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTcxNg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r512961716", "bodyText": "Nothing in this class logs, and I don't think this log message adds value.  If someone were interested in this they can get the information from the http log", "author": "dain", "createdAt": "2020-10-27T19:17:40Z", "path": "presto-main/src/main/java/io/prestosql/server/ui/FormWebUiAuthenticationFilter.java", "diffHunk": "@@ -173,6 +179,11 @@ private static void handleProtocolLoginRequest(Authenticator authenticator, Cont\n         try {\n             authenticatedIdentity = authenticator.authenticate(request);\n         }\n+        catch (RedirectAuthenticationException e) {\n+            sendRedirect(request, e.getLocation());\n+            LOG.debug(format(\"Authentication was redirected to: %s, reason: %s\", e.getLocation(), e.getMessage()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MzY2OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r512963669", "bodyText": "This isn't needed.  The only caller is the FormWebUiAuthenticationFilter and that class already directly calls abortWith", "author": "dain", "createdAt": "2020-10-27T19:21:06Z", "path": "presto-main/src/main/java/io/prestosql/server/ServletSecurityUtils.java", "diffHunk": "@@ -44,6 +46,11 @@ public static void sendWwwAuthenticate(ContainerRequestContext request, String e\n         request.abortWith(authenticateResponse(errorMessage, authenticateHeaders).build());\n     }\n \n+    public static void sendRedirect(ContainerRequestContext request, String location)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2NDI3OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r512964279", "bodyText": "There is a method location method that sets the LOCATION header.  This is similar to the seeOther method we already use in the form authenticator", "author": "dain", "createdAt": "2020-10-27T19:21:48Z", "path": "presto-main/src/main/java/io/prestosql/server/ServletSecurityUtils.java", "diffHunk": "@@ -44,6 +46,11 @@ public static void sendWwwAuthenticate(ContainerRequestContext request, String e\n         request.abortWith(authenticateResponse(errorMessage, authenticateHeaders).build());\n     }\n \n+    public static void sendRedirect(ContainerRequestContext request, String location)\n+    {\n+        request.abortWith(Response.status(FOUND).header(LOCATION, location).build());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwMDcxOQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r513000719", "bodyText": "All of the methods here down can be static", "author": "dain", "createdAt": "2020-10-27T20:13:39Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtException;\n+import io.prestosql.server.security.AuthenticationException;\n+import io.prestosql.server.security.Authenticator;\n+import io.prestosql.server.security.RedirectAuthenticationException;\n+import io.prestosql.server.security.UserMapping;\n+import io.prestosql.server.security.UserMappingException;\n+import io.prestosql.server.security.oauth2.JWKSSigningKeyResolver.UncheckedJwkException;\n+import io.prestosql.spi.security.BasicPrincipal;\n+import io.prestosql.spi.security.Identity;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.Cookie;\n+\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_COOKIE;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Predicate.not;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+\n+public class OAuth2Authenticator\n+        implements Authenticator\n+{\n+    private static final Logger LOG = Logger.get(OAuth2Authenticator.class);\n+\n+    private final OAuth2Service service;\n+    private final UserMapping userMapping;\n+\n+    @Inject\n+    public OAuth2Authenticator(OAuth2Service service, OAuth2Config oauth2Config)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.userMapping = UserMapping.createUserMapping(oauth2Config.getUserMappingPattern(), oauth2Config.getUserMappingFile());\n+    }\n+\n+    @Override\n+    public Identity authenticate(ContainerRequestContext request)\n+            throws AuthenticationException\n+    {\n+        String principal = getAccessToken(request)\n+                .map(token -> token.getBody().getSubject())\n+                .orElseThrow(() -> {\n+                    Challenge.Started challenge = service.startChallenge(request.getUriInfo().getBaseUri());\n+                    return new RedirectAuthenticationException(\n+                            \"Unauthorized\",\n+                            format(\"Bearer realm=\\\"Presto\\\", authorizationUrl=\\\"%s\\\", status=\\\"%s\\\"\",\n+                                    challenge.getAuthorizationUrl(),\n+                                    challenge.getStatus()),\n+                            challenge.getAuthorizationUrl());\n+                });\n+        try {\n+            return Identity.forUser(userMapping.mapUser(principal))\n+                    .withPrincipal(new BasicPrincipal(principal))\n+                    .build();\n+        }\n+        catch (UserMappingException e) {\n+            throw new AuthenticationException(e.getMessage());\n+        }\n+    }\n+\n+    private Optional<Jws<Claims>> getAccessToken(ContainerRequestContext request)\n+    {\n+        Stream<String> accessTokenSources = Stream.concat(Stream.concat(\n+                getTokenFromCookie(request),\n+                getTokenFromHeader(request)),\n+                getTokenFromQueryParam(request));\n+        return accessTokenSources\n+                .filter(not(String::isBlank))\n+                .map(token -> {\n+                    try {\n+                        return Optional.ofNullable(service.parseClaimsJws(token));\n+                    }\n+                    catch (JwtException | IllegalArgumentException | UncheckedJwkException e) {\n+                        LOG.debug(\"Unable to parse JWT token: \" + e.getMessage(), e);\n+                        return Optional.<Jws<Claims>>empty();\n+                    }\n+                })\n+                .findFirst()\n+                .flatMap(Function.identity());\n+    }\n+\n+    private Stream<String> getTokenFromCookie(ContainerRequestContext request)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwMjU0OA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r513002548", "bodyText": "It is not clear why we would need to check anything other than \"cookie\" for this PR", "author": "dain", "createdAt": "2020-10-27T20:16:47Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtException;\n+import io.prestosql.server.security.AuthenticationException;\n+import io.prestosql.server.security.Authenticator;\n+import io.prestosql.server.security.RedirectAuthenticationException;\n+import io.prestosql.server.security.UserMapping;\n+import io.prestosql.server.security.UserMappingException;\n+import io.prestosql.server.security.oauth2.JWKSSigningKeyResolver.UncheckedJwkException;\n+import io.prestosql.spi.security.BasicPrincipal;\n+import io.prestosql.spi.security.Identity;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.Cookie;\n+\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_COOKIE;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Predicate.not;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+\n+public class OAuth2Authenticator\n+        implements Authenticator\n+{\n+    private static final Logger LOG = Logger.get(OAuth2Authenticator.class);\n+\n+    private final OAuth2Service service;\n+    private final UserMapping userMapping;\n+\n+    @Inject\n+    public OAuth2Authenticator(OAuth2Service service, OAuth2Config oauth2Config)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.userMapping = UserMapping.createUserMapping(oauth2Config.getUserMappingPattern(), oauth2Config.getUserMappingFile());\n+    }\n+\n+    @Override\n+    public Identity authenticate(ContainerRequestContext request)\n+            throws AuthenticationException\n+    {\n+        String principal = getAccessToken(request)\n+                .map(token -> token.getBody().getSubject())\n+                .orElseThrow(() -> {\n+                    Challenge.Started challenge = service.startChallenge(request.getUriInfo().getBaseUri());\n+                    return new RedirectAuthenticationException(\n+                            \"Unauthorized\",\n+                            format(\"Bearer realm=\\\"Presto\\\", authorizationUrl=\\\"%s\\\", status=\\\"%s\\\"\",\n+                                    challenge.getAuthorizationUrl(),\n+                                    challenge.getStatus()),\n+                            challenge.getAuthorizationUrl());\n+                });\n+        try {\n+            return Identity.forUser(userMapping.mapUser(principal))\n+                    .withPrincipal(new BasicPrincipal(principal))\n+                    .build();\n+        }\n+        catch (UserMappingException e) {\n+            throw new AuthenticationException(e.getMessage());\n+        }\n+    }\n+\n+    private Optional<Jws<Claims>> getAccessToken(ContainerRequestContext request)\n+    {\n+        Stream<String> accessTokenSources = Stream.concat(Stream.concat(\n+                getTokenFromCookie(request),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyNzk1Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r517527952", "bodyText": "Well, I thought is just a few lines of code but it makes the api more versatile. I can delete it, if you like.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-04T17:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwMjU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwNTM4Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r513005387", "bodyText": "I would follow the style of the other Authenticators and add a needAuthentication method that encapsulates this logic", "author": "dain", "createdAt": "2020-10-27T20:21:48Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Authenticator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtException;\n+import io.prestosql.server.security.AuthenticationException;\n+import io.prestosql.server.security.Authenticator;\n+import io.prestosql.server.security.RedirectAuthenticationException;\n+import io.prestosql.server.security.UserMapping;\n+import io.prestosql.server.security.UserMappingException;\n+import io.prestosql.server.security.oauth2.JWKSSigningKeyResolver.UncheckedJwkException;\n+import io.prestosql.spi.security.BasicPrincipal;\n+import io.prestosql.spi.security.Identity;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.Cookie;\n+\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_COOKIE;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Predicate.not;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+\n+public class OAuth2Authenticator\n+        implements Authenticator\n+{\n+    private static final Logger LOG = Logger.get(OAuth2Authenticator.class);\n+\n+    private final OAuth2Service service;\n+    private final UserMapping userMapping;\n+\n+    @Inject\n+    public OAuth2Authenticator(OAuth2Service service, OAuth2Config oauth2Config)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.userMapping = UserMapping.createUserMapping(oauth2Config.getUserMappingPattern(), oauth2Config.getUserMappingFile());\n+    }\n+\n+    @Override\n+    public Identity authenticate(ContainerRequestContext request)\n+            throws AuthenticationException\n+    {\n+        String principal = getAccessToken(request)\n+                .map(token -> token.getBody().getSubject())\n+                .orElseThrow(() -> {\n+                    Challenge.Started challenge = service.startChallenge(request.getUriInfo().getBaseUri());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAyNTIxOQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r513025219", "bodyText": "You can do checkArgument(code.isPresent() != error.isPresent(), \"Either code or error should be present\"); and combine these", "author": "dain", "createdAt": "2020-10-27T20:57:18Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.github.scribejava.core.model.OAuth2AccessToken;\n+import com.github.scribejava.core.model.OAuth2AccessTokenErrorResponse;\n+import com.github.scribejava.core.model.OAuthConstants;\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.collect.ImmutableMap;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.prestosql.server.security.oauth2.Challenge.Started;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.CALLBACK_ENDPOINT;\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_API_PREFIX;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private final DynamicCallbackOAuth2Service service;\n+    private final JwtParser jwtParser;\n+    private final Cache<State, Started> authorizationChallenges;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Config oauth2Config)\n+    {\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.service = new DynamicCallbackOAuth2Service(\n+                OAuth2Api.create(oauth2Config),\n+                oauth2Config.getClientId(),\n+                oauth2Config.getClientSecret(),\n+                \"openid\");\n+        this.jwtParser = Jwts.parser()\n+                .setSigningKeyResolver(new JWKSSigningKeyResolver(oauth2Config.getServerUrl()));\n+        this.authorizationChallenges = CacheBuilder.newBuilder()\n+                .expireAfterWrite(oauth2Config.getChallengeTimeout().toMillis(), TimeUnit.MILLISECONDS)\n+                .build();\n+    }\n+\n+    Started startChallenge(URI serverUri)\n+    {\n+        State state = State.randomState();\n+        String authorizationUrl = service.getAuthorizationUrl(\n+                ImmutableMap.of(\n+                        OAuthConstants.REDIRECT_URI, serverUri.resolve(OAUTH2_API_PREFIX + CALLBACK_ENDPOINT).toString(),\n+                        OAuthConstants.STATE, state.toString()));\n+        Started challenge = new Started(state, authorizationUrl);\n+        authorizationChallenges.put(state, challenge);\n+        return challenge;\n+    }\n+\n+    Challenge finishChallenge(\n+            URI serverUri,\n+            State state,\n+            Optional<String> code,\n+            Optional<OAuth2ErrorResponse> error)\n+            throws InterruptedException, ExecutionException, IOException\n+    {\n+        requireNonNull(state, \"state is null\");\n+        requireNonNull(code, \"code is null\");\n+        requireNonNull(error, \"error is null\");\n+        checkArgument(code.isPresent() || error.isPresent(), \"Either code or error should be present\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzNzM1Ng==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r513037356", "bodyText": "This will cause the OAuth library to use the JVM HTTP client which we have never used in Presto.  This raises a bunch of questions like how do I configure the trust stores for this client?", "author": "dain", "createdAt": "2020-10-27T21:15:49Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/DynamicCallbackOAuth2Service.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.github.scribejava.core.builder.api.DefaultApi20;\n+import com.github.scribejava.core.model.OAuth2AccessToken;\n+import com.github.scribejava.core.model.OAuthConstants;\n+import com.github.scribejava.core.model.OAuthRequest;\n+import com.github.scribejava.core.oauth.AccessTokenRequestParams;\n+import com.github.scribejava.core.oauth.OAuth20Service;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+\n+public class DynamicCallbackOAuth2Service\n+        extends OAuth20Service\n+{\n+    public DynamicCallbackOAuth2Service(\n+            DefaultApi20 api,\n+            String apiKey,\n+            String apiSecret,\n+            String defaultScope)\n+    {\n+        super(api, apiKey, apiSecret, null, defaultScope, \"code\", null, null, null, null);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUxNjQzOA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r517516438", "bodyText": "ScribeJava supports multiple http clients so I can any from the list: https://github.com/scribejava/scribejava#async-and-other-http-clients", "author": "lukasz-walkiewicz", "createdAt": "2020-11-04T17:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzNzM1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUxNzA0OA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r517517048", "bodyText": "Additional we can add our own implementation of the HttpClient interface but I would prefer not doing this in this PR.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-04T17:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzNzM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzODg4NA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r513038884", "bodyText": "I assume we are still dropping this.", "author": "dain", "createdAt": "2020-10-27T21:19:04Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/JWKSSigningKeyResolver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.auth0.jwk.Jwk;\n+import com.auth0.jwk.JwkException;\n+import com.auth0.jwk.JwkProvider;\n+import com.auth0.jwk.UrlJwkProvider;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.SigningKeyResolver;\n+\n+import java.security.Key;\n+import java.security.PublicKey;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+class JWKSSigningKeyResolver", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0OTk1MQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r513049951", "bodyText": "I'm pretty sure we don't need a cache.  We just need a way to prove that the \"state\" is one generated by this cluster.  We can replace the state with an encrypted value, so we know the cluster created the value.  Then is it is transported/stored in the client.\nBTW, the value of the cache only contains the State and an authorization url which is not used after the original redirection, so we don't need the Started object here.", "author": "dain", "createdAt": "2020-10-27T21:41:44Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.github.scribejava.core.model.OAuth2AccessToken;\n+import com.github.scribejava.core.model.OAuth2AccessTokenErrorResponse;\n+import com.github.scribejava.core.model.OAuthConstants;\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.collect.ImmutableMap;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.prestosql.server.security.oauth2.Challenge.Started;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.CALLBACK_ENDPOINT;\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_API_PREFIX;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private final DynamicCallbackOAuth2Service service;\n+    private final JwtParser jwtParser;\n+    private final Cache<State, Started> authorizationChallenges;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUwNzIyOQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r517507229", "bodyText": "The state stored in the cache is going to be needed by clients such as JDBC/CLI so implementation with an encrypted value won't last long.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-04T17:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA0OTk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NDI3Ng==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r513054276", "bodyText": "I find this code quite difficult to understand. I think the biggest issue is the abstractions as they chop up the logical flow across a bunch of classes.  I think the code would be much easier to understand if this class and the Challenge hierarchy were inlined.\nSpecifically:\n\nstartChallenge can be inlined into OAuth2Authenticator.  This method is really only one line of code.\nfinishChallenge can be inlined into OAuth2Resource.  Once the Challenge code is inlined also, that class could be come much simpler and I will be able to see the full authorization flow much more concisely.", "author": "dain", "createdAt": "2020-10-27T21:50:50Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.github.scribejava.core.model.OAuth2AccessToken;\n+import com.github.scribejava.core.model.OAuth2AccessTokenErrorResponse;\n+import com.github.scribejava.core.model.OAuthConstants;\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.collect.ImmutableMap;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.prestosql.server.security.oauth2.Challenge.Started;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.CALLBACK_ENDPOINT;\n+import static io.prestosql.server.security.oauth2.OAuth2Resource.OAUTH2_API_PREFIX;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUyNjQ3Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r517526477", "bodyText": "I'm not sure if I agree. In my opinion having the logic of a stateful challenge encapsulated in a single class improves the readability. However, I'll try to improve it even further but without inlining since storing challenges in a cache is going to be needed (see: #5355 (comment)).", "author": "lukasz-walkiewicz", "createdAt": "2020-11-04T17:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NDI3Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYyODc2Ng==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527628766", "bodyText": "I would squash that with the commit that relies on it.", "author": "kokosing", "createdAt": "2020-11-20T11:26:56Z", "path": "presto-main/src/main/java/io/prestosql/server/testing/TestingPrestoServer.java", "diffHunk": "@@ -390,6 +390,11 @@ public URI getBaseUrl()\n         return server.getBaseUrl();\n     }\n \n+    public URI getHttpsBaseUrl()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYyODk5NQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527628995", "bodyText": "separate commit?", "author": "kokosing", "createdAt": "2020-11-20T11:27:21Z", "path": "pom.xml", "diffHunk": "@@ -49,15 +49,17 @@\n         <dep.airlift.version>201</dep.airlift.version>\n         <dep.packaging.version>${dep.airlift.version}</dep.packaging.version>\n         <dep.aws-sdk.version>1.11.749</dep.aws-sdk.version>\n-        <dep.okhttp.version>3.9.0</dep.okhttp.version>\n+        <dep.okhttp.version>3.9.1</dep.okhttp.version>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYyOTE2MA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527629160", "bodyText": "Airbase is now at 104.", "author": "kokosing", "createdAt": "2020-11-20T11:27:41Z", "path": "pom.xml", "diffHunk": "@@ -49,15 +49,17 @@\n         <dep.airlift.version>201</dep.airlift.version>\n         <dep.packaging.version>${dep.airlift.version}</dep.packaging.version>\n         <dep.aws-sdk.version>1.11.749</dep.aws-sdk.version>\n-        <dep.okhttp.version>3.9.0</dep.okhttp.version>\n+        <dep.okhttp.version>3.9.1</dep.okhttp.version>\n         <dep.jdbi3.version>3.4.0</dep.jdbi3.version>\n         <dep.oracle.version>19.3.0.0</dep.oracle.version>\n         <dep.drift.version>1.14</dep.drift.version>\n+        <dep.selenium.version>3.12.0</dep.selenium.version>\n         <dep.tempto.version>182</dep.tempto.version>\n         <dep.gcs.version>2.0.0</dep.gcs.version>\n         <dep.errorprone.version>2.4.0</dep.errorprone.version>\n         <dep.testcontainers.version>1.15.0</dep.testcontainers.version>\n         <dep.docker-java.version>3.2.5</dep.docker-java.version>\n+        <!-- TODO remove after changing the airbase version to >= 103 -->", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzYzMzU4Ng==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527633586", "bodyText": "Just Exception", "author": "kokosing", "createdAt": "2020-11-20T11:37:01Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestingHydraService.java", "diffHunk": "@@ -121,4 +127,57 @@ private static String generateSecret()\n         SECURE_RANDOM.nextBytes(randomBytes);\n         return Base64.getEncoder().encodeToString(randomBytes);\n     }\n+\n+    public static void main(String[] args)\n+            throws InterruptedException, IOException", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE0ODQ3Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r520148472", "bodyText": "@NotNull", "author": "dain", "createdAt": "2020-11-09T22:01:31Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Config.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.configuration.Config;\n+import io.airlift.configuration.ConfigDescription;\n+import io.airlift.configuration.validation.FileExists;\n+import io.airlift.units.Duration;\n+import io.airlift.units.MinDuration;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+public class OAuth2Config\n+{\n+    private String serverUrl;\n+    private String authUrl;\n+    private String tokenUrl;\n+    private String jwksUrl;\n+    private String clientId;\n+    private String clientSecret;\n+    private Duration challengeTimeout = new Duration(15, TimeUnit.MINUTES);\n+    private Optional<String> userMappingPattern = Optional.empty();\n+    private Optional<File> userMappingFile = Optional.empty();\n+\n+    @NotNull\n+    public String getServerUrl()\n+    {\n+        return serverUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.server-url\")\n+    @ConfigDescription(\"URL of the authorization server\")\n+    public OAuth2Config setServerUrl(String serverUrl)\n+    {\n+        this.serverUrl = serverUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getAuthUrl()\n+    {\n+        return authUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.auth-url\")\n+    @ConfigDescription(\"URL of the authorization server's authorization endpoint\")\n+    public OAuth2Config setAuthUrl(String authUrl)\n+    {\n+        this.authUrl = authUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getTokenUrl()\n+    {\n+        return tokenUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.token-url\")\n+    @ConfigDescription(\"URL of the authorization server's token endpoint\")\n+    public OAuth2Config setTokenUrl(String tokenUrl)\n+    {\n+        this.tokenUrl = tokenUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getJwksUrl()\n+    {\n+        return jwksUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.jwks-url\")\n+    @ConfigDescription(\"URL of the authorization server's JWKS (JSON Web Key Set) endpoint\")\n+    public OAuth2Config setJwksUrl(String jwksUrl)\n+    {\n+        this.jwksUrl = jwksUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getClientId()\n+    {\n+        return clientId;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.client-id\")\n+    public OAuth2Config setClientId(String clientId)\n+    {\n+        this.clientId = clientId;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getClientSecret()\n+    {\n+        return clientSecret;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.client-secret\")\n+    public OAuth2Config setClientSecret(String clientSecret)\n+    {\n+        this.clientSecret = clientSecret;\n+        return this;\n+    }\n+\n+    @MinDuration(\"1ms\")\n+    public Duration getChallengeTimeout()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxNzAyMA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527917020", "bodyText": "@NotNull", "author": "dain", "createdAt": "2020-11-20T19:12:01Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Config.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.configuration.Config;\n+import io.airlift.configuration.ConfigDescription;\n+import io.airlift.configuration.validation.FileExists;\n+import io.airlift.units.Duration;\n+import io.airlift.units.MinDuration;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+public class OAuth2Config\n+{\n+    private Optional<String> stateKey = Optional.empty();\n+    private String serverUrl;\n+    private String authUrl;\n+    private String tokenUrl;\n+    private String jwksUrl;\n+    private String clientId;\n+    private String clientSecret;\n+    private Duration challengeTimeout = new Duration(15, TimeUnit.MINUTES);\n+    private Optional<String> userMappingPattern = Optional.empty();\n+    private Optional<File> userMappingFile = Optional.empty();\n+\n+    @NotNull\n+    public Optional<String> getStateKey()\n+    {\n+        return stateKey;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.state-key\")\n+    public OAuth2Config setStateKey(String stateKey)\n+    {\n+        this.stateKey = Optional.ofNullable(stateKey);\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getServerUrl()\n+    {\n+        return serverUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.server-url\")\n+    @ConfigDescription(\"URL of the authorization server\")\n+    public OAuth2Config setServerUrl(String serverUrl)\n+    {\n+        this.serverUrl = serverUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getAuthUrl()\n+    {\n+        return authUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.auth-url\")\n+    @ConfigDescription(\"URL of the authorization server's authorization endpoint\")\n+    public OAuth2Config setAuthUrl(String authUrl)\n+    {\n+        this.authUrl = authUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getTokenUrl()\n+    {\n+        return tokenUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.token-url\")\n+    @ConfigDescription(\"URL of the authorization server's token endpoint\")\n+    public OAuth2Config setTokenUrl(String tokenUrl)\n+    {\n+        this.tokenUrl = tokenUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getJwksUrl()\n+    {\n+        return jwksUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.jwks-url\")\n+    @ConfigDescription(\"URL of the authorization server's JWKS (JSON Web Key Set) endpoint\")\n+    public OAuth2Config setJwksUrl(String jwksUrl)\n+    {\n+        this.jwksUrl = jwksUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getClientId()\n+    {\n+        return clientId;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.client-id\")\n+    public OAuth2Config setClientId(String clientId)\n+    {\n+        this.clientId = clientId;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getClientSecret()\n+    {\n+        return clientSecret;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.client-secret\")\n+    public OAuth2Config setClientSecret(String clientSecret)\n+    {\n+        this.clientSecret = clientSecret;\n+        return this;\n+    }\n+\n+    @MinDuration(\"1ms\")\n+    public Duration getChallengeTimeout()\n+    {\n+        return challengeTimeout;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.challenge-timeout\")\n+    public OAuth2Config setChallengeTimeout(Duration challengeTimeout)\n+    {\n+        this.challengeTimeout = challengeTimeout;\n+        return this;\n+    }\n+\n+    public Optional<String> getUserMappingPattern()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxNzE0Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527917147", "bodyText": "@NotNull", "author": "dain", "createdAt": "2020-11-20T19:12:15Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Config.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.configuration.Config;\n+import io.airlift.configuration.ConfigDescription;\n+import io.airlift.configuration.validation.FileExists;\n+import io.airlift.units.Duration;\n+import io.airlift.units.MinDuration;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+public class OAuth2Config\n+{\n+    private Optional<String> stateKey = Optional.empty();\n+    private String serverUrl;\n+    private String authUrl;\n+    private String tokenUrl;\n+    private String jwksUrl;\n+    private String clientId;\n+    private String clientSecret;\n+    private Duration challengeTimeout = new Duration(15, TimeUnit.MINUTES);\n+    private Optional<String> userMappingPattern = Optional.empty();\n+    private Optional<File> userMappingFile = Optional.empty();\n+\n+    @NotNull\n+    public Optional<String> getStateKey()\n+    {\n+        return stateKey;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.state-key\")\n+    public OAuth2Config setStateKey(String stateKey)\n+    {\n+        this.stateKey = Optional.ofNullable(stateKey);\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getServerUrl()\n+    {\n+        return serverUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.server-url\")\n+    @ConfigDescription(\"URL of the authorization server\")\n+    public OAuth2Config setServerUrl(String serverUrl)\n+    {\n+        this.serverUrl = serverUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getAuthUrl()\n+    {\n+        return authUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.auth-url\")\n+    @ConfigDescription(\"URL of the authorization server's authorization endpoint\")\n+    public OAuth2Config setAuthUrl(String authUrl)\n+    {\n+        this.authUrl = authUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getTokenUrl()\n+    {\n+        return tokenUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.token-url\")\n+    @ConfigDescription(\"URL of the authorization server's token endpoint\")\n+    public OAuth2Config setTokenUrl(String tokenUrl)\n+    {\n+        this.tokenUrl = tokenUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getJwksUrl()\n+    {\n+        return jwksUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.jwks-url\")\n+    @ConfigDescription(\"URL of the authorization server's JWKS (JSON Web Key Set) endpoint\")\n+    public OAuth2Config setJwksUrl(String jwksUrl)\n+    {\n+        this.jwksUrl = jwksUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getClientId()\n+    {\n+        return clientId;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.client-id\")\n+    public OAuth2Config setClientId(String clientId)\n+    {\n+        this.clientId = clientId;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getClientSecret()\n+    {\n+        return clientSecret;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.client-secret\")\n+    public OAuth2Config setClientSecret(String clientSecret)\n+    {\n+        this.clientSecret = clientSecret;\n+        return this;\n+    }\n+\n+    @MinDuration(\"1ms\")\n+    public Duration getChallengeTimeout()\n+    {\n+        return challengeTimeout;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.challenge-timeout\")\n+    public OAuth2Config setChallengeTimeout(Duration challengeTimeout)\n+    {\n+        this.challengeTimeout = challengeTimeout;\n+        return this;\n+    }\n+\n+    public Optional<String> getUserMappingPattern()\n+    {\n+        return userMappingPattern;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.user-mapping.pattern\")\n+    public OAuth2Config setUserMappingPattern(String userMappingPattern)\n+    {\n+        this.userMappingPattern = Optional.ofNullable(userMappingPattern);\n+        return this;\n+    }\n+\n+    public Optional<@FileExists File> getUserMappingFile()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxODM3OA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527918378", "bodyText": "The successHtml isn't used in this PR.  Let's remove this code and the file for now", "author": "dain", "createdAt": "2020-11-20T19:14:06Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.hash.Hashing;\n+import com.google.common.io.Resources;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.SigningKeyResolver;\n+import io.prestosql.server.security.oauth2.OAuth2Client.AccessToken;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.SecureRandom;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+\n+import static com.google.common.base.Strings.nullToEmpty;\n+import static com.google.common.base.Verify.verify;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private static final String STATE_AUDIENCE = \"presto_oauth\";\n+    private static final String FAILURE_REPLACEMENT_TEXT = \"<!-- ERROR_MESSAGE -->\";\n+\n+    private final OAuth2Client client;\n+    private final JwtParser jwtParser;\n+\n+    private final String successHtml;\n+    private final String failureHtml;\n+\n+    private final long challengeTimeoutMillis;\n+    private final byte[] stateHmac;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Client client, @ForOAuth2 SigningKeyResolver signingKeyResolver, OAuth2Config oauth2Config)\n+            throws IOException\n+    {\n+        this.client = requireNonNull(client, \"client is null\");\n+        this.jwtParser = Jwts.parser().setSigningKeyResolver(signingKeyResolver);\n+\n+        this.successHtml = Resources.toString(Resources.getResource(getClass(), \"/oauth2/success.html\"), UTF_8);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxOTkwMg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527919902", "bodyText": "I think this needs @Singleton", "author": "dain", "createdAt": "2020-11-20T19:17:13Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2ServiceModule.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.inject.Binder;\n+import com.google.inject.Provides;\n+import com.google.inject.Scopes;\n+import io.airlift.configuration.AbstractConfigurationAwareModule;\n+import io.airlift.http.client.HttpClient;\n+import io.airlift.units.Duration;\n+import io.jsonwebtoken.SigningKeyResolver;\n+import io.prestosql.server.security.jwt.JwkService;\n+import io.prestosql.server.security.jwt.JwkSigningKeyResolver;\n+\n+import java.net.URI;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.inject.multibindings.OptionalBinder.newOptionalBinder;\n+import static io.airlift.configuration.ConfigBinder.configBinder;\n+import static io.airlift.http.client.HttpClientBinder.httpClientBinder;\n+import static io.airlift.jaxrs.JaxrsBinder.jaxrsBinder;\n+\n+public class OAuth2ServiceModule\n+        extends AbstractConfigurationAwareModule\n+{\n+    @Override\n+    protected void setup(Binder binder)\n+    {\n+        jaxrsBinder(binder).bind(OAuth2CallbackResource.class);\n+\n+        configBinder(binder).bindConfig(OAuth2Config.class);\n+        binder.bind(OAuth2Service.class).in(Scopes.SINGLETON);\n+        newOptionalBinder(binder, OAuth2Client.class)\n+                .setDefault()\n+                .to(ScribeJavaOAuth2Client.class)\n+                .in(Scopes.SINGLETON);\n+        httpClientBinder(binder).bindHttpClient(\"oauth2-jwk\", ForOAuth2.class);\n+    }\n+\n+    @Provides\n+    @ForOAuth2\n+    public static SigningKeyResolver createSigningKeyResolver(OAuth2Config oauth2Config, @ForOAuth2 HttpClient httpClient)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMDc2Mw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527920763", "bodyText": "I think this can be package protected instead of public", "author": "dain", "createdAt": "2020-11-20T19:18:55Z", "path": "presto-main/src/main/java/io/prestosql/server/ui/FormWebUiAuthenticationFilter.java", "diffHunk": "@@ -57,8 +57,8 @@\n     static final URI LOGIN_FORM_URI = URI.create(LOGIN_FORM);\n     static final String DISABLED_LOCATION = \"/ui/disabled.html\";\n     static final URI DISABLED_LOCATION_URI = URI.create(DISABLED_LOCATION);\n-    private static final String UI_LOCATION = \"/ui/\";\n-    private static final URI UI_LOCATION_URI = URI.create(UI_LOCATION);\n+    public static final String UI_LOCATION = \"/ui/\";", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyOTcxNA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528629714", "bodyText": "I'm afraid not. UI_LOCATION is used in both: io.prestosql.server.security.oauth2 and io.prestosql.server.ui packages.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-23T11:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMDc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMzI4Mw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r527923283", "bodyText": "Consider adding squashing this into the PR that added TestingHydraService", "author": "dain", "createdAt": "2020-11-20T19:23:55Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestingHydraService.java", "diffHunk": "@@ -13,7 +13,12 @@\n  */\n package io.prestosql.server.security.oauth2;\n \n+import com.google.common.collect.ImmutableMap;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzODAwMQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528938001", "bodyText": "Why this version specifically? It's not the latest 3.x", "author": "electrum", "createdAt": "2020-11-23T19:16:21Z", "path": "pom.xml", "diffHunk": "@@ -53,6 +53,7 @@\n         <dep.jdbi3.version>3.4.0</dep.jdbi3.version>\n         <dep.oracle.version>19.3.0.0</dep.oracle.version>\n         <dep.drift.version>1.14</dep.drift.version>\n+        <dep.selenium.version>3.12.0</dep.selenium.version>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkzOTI4Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528939287", "bodyText": "The latest version is 1.15", "author": "electrum", "createdAt": "2020-11-23T19:18:34Z", "path": "pom.xml", "diffHunk": "@@ -1063,6 +1070,12 @@\n                 <version>1.4</version>\n             </dependency>\n \n+            <dependency>\n+                <groupId>commons-codec</groupId>\n+                <artifactId>commons-codec</artifactId>\n+                <version>1.13</version>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MDQ4Ng==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528940486", "bodyText": "Why are we adding this as a runtime dependency for all of the connectors? Adding OAuth to the engine should not touch all the connectors.\nIf this is related to test dependencies, then this is certainly the wrong scope, but in any case we should consider a strategy that doesn't require adding this to all connectors.", "author": "electrum", "createdAt": "2020-11-23T19:20:46Z", "path": "presto-accumulo/pom.xml", "diffHunk": "@@ -215,6 +215,12 @@\n             </exclusions>\n         </dependency>\n \n+        <dependency>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0MTgyNg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528941826", "bodyText": "These exclusions should go in dependencyManagement", "author": "electrum", "createdAt": "2020-11-23T19:23:25Z", "path": "presto-main/pom.xml", "diffHunk": "@@ -400,6 +405,78 @@\n             <artifactId>jmh-generator-annprocess</artifactId>\n             <scope>test</scope>\n         </dependency>\n+\n+        <dependency>\n+            <groupId>org.seleniumhq.selenium</groupId>\n+            <artifactId>selenium-api</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <dependency>\n+            <groupId>org.seleniumhq.selenium</groupId>\n+            <artifactId>selenium-chrome-driver</artifactId>\n+            <scope>test</scope>\n+            <exclusions>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0Nzg2Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528947867", "bodyText": "Nit: capitalize REST", "author": "electrum", "createdAt": "2020-11-23T19:34:01Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2CallbackResource.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.prestosql.server.security.ResourceSecurity;\n+import io.prestosql.server.security.oauth2.OAuth2Service.OAuthResult;\n+import io.prestosql.server.ui.OAuthWebUiCookie;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.net.URI;\n+\n+import static io.prestosql.server.security.ResourceSecurity.AccessType.PUBLIC;\n+import static io.prestosql.server.ui.FormWebUiAuthenticationFilter.UI_LOCATION;\n+import static java.util.Objects.requireNonNull;\n+import static javax.ws.rs.core.MediaType.TEXT_HTML;\n+\n+@Path(OAuth2CallbackResource.CALLBACK_ENDPOINT)\n+public class OAuth2CallbackResource\n+{\n+    private static final Logger LOG = Logger.get(OAuth2CallbackResource.class);\n+\n+    public static final String CALLBACK_ENDPOINT = \"/oauth2/callback\";\n+\n+    private final OAuth2Service service;\n+\n+    @Inject\n+    public OAuth2CallbackResource(OAuth2Service service)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+    }\n+\n+    @ResourceSecurity(PUBLIC)\n+    @GET\n+    @Produces(TEXT_HTML)\n+    public Response callback(\n+            @QueryParam(\"state\") String state,\n+            @QueryParam(\"code\") String code,\n+            @QueryParam(\"error\") String error,\n+            @QueryParam(\"error_description\") String errorDescription,\n+            @QueryParam(\"error_uri\") String errorUri,\n+            @Context UriInfo uriInfo,\n+            @Context SecurityContext securityContext)\n+    {\n+        // Note: the Web UI may be disabled, so rest requests can not redirect to a success or error page inside of the Web UI", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0ODEwOQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528948109", "bodyText": "This should be error_uri", "author": "electrum", "createdAt": "2020-11-23T19:34:30Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2CallbackResource.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.prestosql.server.security.ResourceSecurity;\n+import io.prestosql.server.security.oauth2.OAuth2Service.OAuthResult;\n+import io.prestosql.server.ui.OAuthWebUiCookie;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.net.URI;\n+\n+import static io.prestosql.server.security.ResourceSecurity.AccessType.PUBLIC;\n+import static io.prestosql.server.ui.FormWebUiAuthenticationFilter.UI_LOCATION;\n+import static java.util.Objects.requireNonNull;\n+import static javax.ws.rs.core.MediaType.TEXT_HTML;\n+\n+@Path(OAuth2CallbackResource.CALLBACK_ENDPOINT)\n+public class OAuth2CallbackResource\n+{\n+    private static final Logger LOG = Logger.get(OAuth2CallbackResource.class);\n+\n+    public static final String CALLBACK_ENDPOINT = \"/oauth2/callback\";\n+\n+    private final OAuth2Service service;\n+\n+    @Inject\n+    public OAuth2CallbackResource(OAuth2Service service)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+    }\n+\n+    @ResourceSecurity(PUBLIC)\n+    @GET\n+    @Produces(TEXT_HTML)\n+    public Response callback(\n+            @QueryParam(\"state\") String state,\n+            @QueryParam(\"code\") String code,\n+            @QueryParam(\"error\") String error,\n+            @QueryParam(\"error_description\") String errorDescription,\n+            @QueryParam(\"error_uri\") String errorUri,\n+            @Context UriInfo uriInfo,\n+            @Context SecurityContext securityContext)\n+    {\n+        // Note: the Web UI may be disabled, so rest requests can not redirect to a success or error page inside of the Web UI\n+\n+        if (error != null) {\n+            String message = String.format(\n+                    \"OAuth server returned an error: error=%s, error_description=%s, error_uri=%s, state=%s\",\n+                    error,\n+                    errorDescription,\n+                    errorDescription,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0ODY1Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528948652", "bodyText": "Do the formatting using the logger, so that we only construct it if the log level is enabled", "author": "electrum", "createdAt": "2020-11-23T19:35:29Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2CallbackResource.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.prestosql.server.security.ResourceSecurity;\n+import io.prestosql.server.security.oauth2.OAuth2Service.OAuthResult;\n+import io.prestosql.server.ui.OAuthWebUiCookie;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.net.URI;\n+\n+import static io.prestosql.server.security.ResourceSecurity.AccessType.PUBLIC;\n+import static io.prestosql.server.ui.FormWebUiAuthenticationFilter.UI_LOCATION;\n+import static java.util.Objects.requireNonNull;\n+import static javax.ws.rs.core.MediaType.TEXT_HTML;\n+\n+@Path(OAuth2CallbackResource.CALLBACK_ENDPOINT)\n+public class OAuth2CallbackResource\n+{\n+    private static final Logger LOG = Logger.get(OAuth2CallbackResource.class);\n+\n+    public static final String CALLBACK_ENDPOINT = \"/oauth2/callback\";\n+\n+    private final OAuth2Service service;\n+\n+    @Inject\n+    public OAuth2CallbackResource(OAuth2Service service)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+    }\n+\n+    @ResourceSecurity(PUBLIC)\n+    @GET\n+    @Produces(TEXT_HTML)\n+    public Response callback(\n+            @QueryParam(\"state\") String state,\n+            @QueryParam(\"code\") String code,\n+            @QueryParam(\"error\") String error,\n+            @QueryParam(\"error_description\") String errorDescription,\n+            @QueryParam(\"error_uri\") String errorUri,\n+            @Context UriInfo uriInfo,\n+            @Context SecurityContext securityContext)\n+    {\n+        // Note: the Web UI may be disabled, so rest requests can not redirect to a success or error page inside of the Web UI\n+\n+        if (error != null) {\n+            String message = String.format(\n+                    \"OAuth server returned an error: error=%s, error_description=%s, error_uri=%s, state=%s\",\n+                    error,\n+                    errorDescription,\n+                    errorDescription,\n+                    state);\n+            LOG.debug(message);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0OTA4Ng==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528949086", "bodyText": "Should we have quotes around the error strings?", "author": "electrum", "createdAt": "2020-11-23T19:36:15Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2CallbackResource.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.prestosql.server.security.ResourceSecurity;\n+import io.prestosql.server.security.oauth2.OAuth2Service.OAuthResult;\n+import io.prestosql.server.ui.OAuthWebUiCookie;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.net.URI;\n+\n+import static io.prestosql.server.security.ResourceSecurity.AccessType.PUBLIC;\n+import static io.prestosql.server.ui.FormWebUiAuthenticationFilter.UI_LOCATION;\n+import static java.util.Objects.requireNonNull;\n+import static javax.ws.rs.core.MediaType.TEXT_HTML;\n+\n+@Path(OAuth2CallbackResource.CALLBACK_ENDPOINT)\n+public class OAuth2CallbackResource\n+{\n+    private static final Logger LOG = Logger.get(OAuth2CallbackResource.class);\n+\n+    public static final String CALLBACK_ENDPOINT = \"/oauth2/callback\";\n+\n+    private final OAuth2Service service;\n+\n+    @Inject\n+    public OAuth2CallbackResource(OAuth2Service service)\n+    {\n+        this.service = requireNonNull(service, \"service is null\");\n+    }\n+\n+    @ResourceSecurity(PUBLIC)\n+    @GET\n+    @Produces(TEXT_HTML)\n+    public Response callback(\n+            @QueryParam(\"state\") String state,\n+            @QueryParam(\"code\") String code,\n+            @QueryParam(\"error\") String error,\n+            @QueryParam(\"error_description\") String errorDescription,\n+            @QueryParam(\"error_uri\") String errorUri,\n+            @Context UriInfo uriInfo,\n+            @Context SecurityContext securityContext)\n+    {\n+        // Note: the Web UI may be disabled, so rest requests can not redirect to a success or error page inside of the Web UI\n+\n+        if (error != null) {\n+            String message = String.format(\n+                    \"OAuth server returned an error: error=%s, error_description=%s, error_uri=%s, state=%s\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4ODMzOQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r529888339", "bodyText": "From my quick search it looks like it's uncommon to wrap error strings in quotes and I would prefer to be coherent.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-24T21:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0OTA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0OTc0OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528949749", "bodyText": "Static import", "author": "electrum", "createdAt": "2020-11-23T19:37:25Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2CallbackResource.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.log.Logger;\n+import io.prestosql.server.security.ResourceSecurity;\n+import io.prestosql.server.security.oauth2.OAuth2Service.OAuthResult;\n+import io.prestosql.server.ui.OAuthWebUiCookie;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.SecurityContext;\n+import javax.ws.rs.core.UriInfo;\n+\n+import java.net.URI;\n+\n+import static io.prestosql.server.security.ResourceSecurity.AccessType.PUBLIC;\n+import static io.prestosql.server.ui.FormWebUiAuthenticationFilter.UI_LOCATION;\n+import static java.util.Objects.requireNonNull;\n+import static javax.ws.rs.core.MediaType.TEXT_HTML;\n+\n+@Path(OAuth2CallbackResource.CALLBACK_ENDPOINT)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0OTkwOQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528949909", "bodyText": "Add @ConfigDescription for all of these new properties", "author": "electrum", "createdAt": "2020-11-23T19:37:43Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Config.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.configuration.Config;\n+import io.airlift.configuration.ConfigDescription;\n+import io.airlift.configuration.validation.FileExists;\n+import io.airlift.units.Duration;\n+import io.airlift.units.MinDuration;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+public class OAuth2Config\n+{\n+    private Optional<String> stateKey = Optional.empty();\n+    private String serverUrl;\n+    private String authUrl;\n+    private String tokenUrl;\n+    private String jwksUrl;\n+    private String clientId;\n+    private String clientSecret;\n+    private Duration challengeTimeout = new Duration(15, TimeUnit.MINUTES);\n+    private Optional<String> userMappingPattern = Optional.empty();\n+    private Optional<File> userMappingFile = Optional.empty();\n+\n+    @NotNull\n+    public Optional<String> getStateKey()\n+    {\n+        return stateKey;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.state-key\")\n+    public OAuth2Config setStateKey(String stateKey)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk0OTk3NQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528949975", "bodyText": "Add @ConfigDescription", "author": "electrum", "createdAt": "2020-11-23T19:37:54Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Config.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.configuration.Config;\n+import io.airlift.configuration.ConfigDescription;\n+import io.airlift.configuration.validation.FileExists;\n+import io.airlift.units.Duration;\n+import io.airlift.units.MinDuration;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+public class OAuth2Config\n+{\n+    private Optional<String> stateKey = Optional.empty();\n+    private String serverUrl;\n+    private String authUrl;\n+    private String tokenUrl;\n+    private String jwksUrl;\n+    private String clientId;\n+    private String clientSecret;\n+    private Duration challengeTimeout = new Duration(15, TimeUnit.MINUTES);\n+    private Optional<String> userMappingPattern = Optional.empty();\n+    private Optional<File> userMappingFile = Optional.empty();\n+\n+    @NotNull\n+    public Optional<String> getStateKey()\n+    {\n+        return stateKey;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.state-key\")\n+    public OAuth2Config setStateKey(String stateKey)\n+    {\n+        this.stateKey = Optional.ofNullable(stateKey);\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getServerUrl()\n+    {\n+        return serverUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.server-url\")\n+    @ConfigDescription(\"URL of the authorization server\")\n+    public OAuth2Config setServerUrl(String serverUrl)\n+    {\n+        this.serverUrl = serverUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getAuthUrl()\n+    {\n+        return authUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.auth-url\")\n+    @ConfigDescription(\"URL of the authorization server's authorization endpoint\")\n+    public OAuth2Config setAuthUrl(String authUrl)\n+    {\n+        this.authUrl = authUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getTokenUrl()\n+    {\n+        return tokenUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.token-url\")\n+    @ConfigDescription(\"URL of the authorization server's token endpoint\")\n+    public OAuth2Config setTokenUrl(String tokenUrl)\n+    {\n+        this.tokenUrl = tokenUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getJwksUrl()\n+    {\n+        return jwksUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.jwks-url\")\n+    @ConfigDescription(\"URL of the authorization server's JWKS (JSON Web Key Set) endpoint\")\n+    public OAuth2Config setJwksUrl(String jwksUrl)\n+    {\n+        this.jwksUrl = jwksUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getClientId()\n+    {\n+        return clientId;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.client-id\")\n+    public OAuth2Config setClientId(String clientId)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1MTA4OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528951089", "bodyText": "I don't think @NotNull is needed for these, since they can't ever be set to null. The purpose of the validation annotations is for the framework to verify the user code used the class correctly, but this would be a bug in the bean class itself.", "author": "electrum", "createdAt": "2020-11-23T19:39:57Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Config.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.configuration.Config;\n+import io.airlift.configuration.ConfigDescription;\n+import io.airlift.configuration.validation.FileExists;\n+import io.airlift.units.Duration;\n+import io.airlift.units.MinDuration;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+public class OAuth2Config\n+{\n+    private Optional<String> stateKey = Optional.empty();\n+    private String serverUrl;\n+    private String authUrl;\n+    private String tokenUrl;\n+    private String jwksUrl;\n+    private String clientId;\n+    private String clientSecret;\n+    private Duration challengeTimeout = new Duration(15, TimeUnit.MINUTES);\n+    private Optional<String> userMappingPattern = Optional.empty();\n+    private Optional<File> userMappingFile = Optional.empty();\n+\n+    @NotNull\n+    public Optional<String> getStateKey()\n+    {\n+        return stateKey;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.state-key\")\n+    public OAuth2Config setStateKey(String stateKey)\n+    {\n+        this.stateKey = Optional.ofNullable(stateKey);\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getServerUrl()\n+    {\n+        return serverUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.server-url\")\n+    @ConfigDescription(\"URL of the authorization server\")\n+    public OAuth2Config setServerUrl(String serverUrl)\n+    {\n+        this.serverUrl = serverUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getAuthUrl()\n+    {\n+        return authUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.auth-url\")\n+    @ConfigDescription(\"URL of the authorization server's authorization endpoint\")\n+    public OAuth2Config setAuthUrl(String authUrl)\n+    {\n+        this.authUrl = authUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getTokenUrl()\n+    {\n+        return tokenUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.token-url\")\n+    @ConfigDescription(\"URL of the authorization server's token endpoint\")\n+    public OAuth2Config setTokenUrl(String tokenUrl)\n+    {\n+        this.tokenUrl = tokenUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getJwksUrl()\n+    {\n+        return jwksUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.jwks-url\")\n+    @ConfigDescription(\"URL of the authorization server's JWKS (JSON Web Key Set) endpoint\")\n+    public OAuth2Config setJwksUrl(String jwksUrl)\n+    {\n+        this.jwksUrl = jwksUrl;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getClientId()\n+    {\n+        return clientId;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.client-id\")\n+    public OAuth2Config setClientId(String clientId)\n+    {\n+        this.clientId = clientId;\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getClientSecret()\n+    {\n+        return clientSecret;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.client-secret\")\n+    public OAuth2Config setClientSecret(String clientSecret)\n+    {\n+        this.clientSecret = clientSecret;\n+        return this;\n+    }\n+\n+    @MinDuration(\"1ms\")\n+    @NotNull\n+    public Duration getChallengeTimeout()\n+    {\n+        return challengeTimeout;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.challenge-timeout\")\n+    public OAuth2Config setChallengeTimeout(Duration challengeTimeout)\n+    {\n+        this.challengeTimeout = challengeTimeout;\n+        return this;\n+    }\n+\n+    @NotNull", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NTQ0OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528975449", "bodyText": "I think I suggested that :(", "author": "dain", "createdAt": "2020-11-23T20:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1MTA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1NTA2Ng==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528955066", "bodyText": "this.stateHmac = oauth2Config.getStateKey()\n        .map(key -> sha256().hashString(key, UTF_8).asBytes())\n        .orElseGet(() -> secureRandomBytes(32));\n\nprivate byte[] secureRandomBytes(int count)\n{\n    byte[] bytes = new byte[count];\n    new SecureRandom().nextBytes(bytes);\n    return bytes;\n}", "author": "electrum", "createdAt": "2020-11-23T19:47:17Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.hash.Hashing;\n+import com.google.common.io.Resources;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.SigningKeyResolver;\n+import io.prestosql.server.security.oauth2.OAuth2Client.AccessToken;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.SecureRandom;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+\n+import static com.google.common.base.Strings.nullToEmpty;\n+import static com.google.common.base.Verify.verify;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private static final String STATE_AUDIENCE = \"presto_oauth\";\n+    private static final String FAILURE_REPLACEMENT_TEXT = \"<!-- ERROR_MESSAGE -->\";\n+\n+    private final OAuth2Client client;\n+    private final JwtParser jwtParser;\n+\n+    private final String failureHtml;\n+\n+    private final long challengeTimeoutMillis;\n+    private final byte[] stateHmac;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Client client, @ForOAuth2 SigningKeyResolver signingKeyResolver, OAuth2Config oauth2Config)\n+            throws IOException\n+    {\n+        this.client = requireNonNull(client, \"client is null\");\n+        this.jwtParser = Jwts.parser().setSigningKeyResolver(signingKeyResolver);\n+\n+        this.failureHtml = Resources.toString(Resources.getResource(getClass(), \"/oauth2/failure.html\"), UTF_8);\n+        verify(failureHtml.contains(FAILURE_REPLACEMENT_TEXT), \"login.html does not contain the replacement text\");\n+\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.challengeTimeoutMillis = oauth2Config.getChallengeTimeout().toMillis();\n+        if (oauth2Config.getStateKey().isPresent()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1OTIzMw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528959233", "bodyText": "Remove one of these lines. You could change this to\nDate.from(ZonedDateTime.now().plus(challengeTimeout).toInstant())\nIf you change challengeTimeout using\nprivate final TemporalAmount challengeTimeout;\n\nchallengeTimeout = java.time.Duration.ofMillis(oauth2Config.getChallengeTimeout().toMillis());", "author": "electrum", "createdAt": "2020-11-23T19:54:58Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.hash.Hashing;\n+import com.google.common.io.Resources;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.SigningKeyResolver;\n+import io.prestosql.server.security.oauth2.OAuth2Client.AccessToken;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.SecureRandom;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+\n+import static com.google.common.base.Strings.nullToEmpty;\n+import static com.google.common.base.Verify.verify;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private static final String STATE_AUDIENCE = \"presto_oauth\";\n+    private static final String FAILURE_REPLACEMENT_TEXT = \"<!-- ERROR_MESSAGE -->\";\n+\n+    private final OAuth2Client client;\n+    private final JwtParser jwtParser;\n+\n+    private final String failureHtml;\n+\n+    private final long challengeTimeoutMillis;\n+    private final byte[] stateHmac;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Client client, @ForOAuth2 SigningKeyResolver signingKeyResolver, OAuth2Config oauth2Config)\n+            throws IOException\n+    {\n+        this.client = requireNonNull(client, \"client is null\");\n+        this.jwtParser = Jwts.parser().setSigningKeyResolver(signingKeyResolver);\n+\n+        this.failureHtml = Resources.toString(Resources.getResource(getClass(), \"/oauth2/failure.html\"), UTF_8);\n+        verify(failureHtml.contains(FAILURE_REPLACEMENT_TEXT), \"login.html does not contain the replacement text\");\n+\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.challengeTimeoutMillis = oauth2Config.getChallengeTimeout().toMillis();\n+        if (oauth2Config.getStateKey().isPresent()) {\n+            stateHmac = Hashing.sha256().hashString(oauth2Config.getStateKey().get(), UTF_8).asBytes();\n+        }\n+        else {\n+            stateHmac = new byte[32];\n+            new SecureRandom().nextBytes(stateHmac);\n+        }\n+    }\n+\n+    public URI startChallenge(URI callbackUri)\n+    {\n+        String state = Jwts.builder()\n+                .signWith(SignatureAlgorithm.HS256, stateHmac)\n+                .setAudience(STATE_AUDIENCE)\n+                .setExpiration(new Date(System.currentTimeMillis() + challengeTimeoutMillis))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2MDAwMQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528960001", "bodyText": "Change this to return directly", "author": "electrum", "createdAt": "2020-11-23T19:56:23Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.hash.Hashing;\n+import com.google.common.io.Resources;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.SigningKeyResolver;\n+import io.prestosql.server.security.oauth2.OAuth2Client.AccessToken;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.SecureRandom;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+\n+import static com.google.common.base.Strings.nullToEmpty;\n+import static com.google.common.base.Verify.verify;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private static final String STATE_AUDIENCE = \"presto_oauth\";\n+    private static final String FAILURE_REPLACEMENT_TEXT = \"<!-- ERROR_MESSAGE -->\";\n+\n+    private final OAuth2Client client;\n+    private final JwtParser jwtParser;\n+\n+    private final String failureHtml;\n+\n+    private final long challengeTimeoutMillis;\n+    private final byte[] stateHmac;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Client client, @ForOAuth2 SigningKeyResolver signingKeyResolver, OAuth2Config oauth2Config)\n+            throws IOException\n+    {\n+        this.client = requireNonNull(client, \"client is null\");\n+        this.jwtParser = Jwts.parser().setSigningKeyResolver(signingKeyResolver);\n+\n+        this.failureHtml = Resources.toString(Resources.getResource(getClass(), \"/oauth2/failure.html\"), UTF_8);\n+        verify(failureHtml.contains(FAILURE_REPLACEMENT_TEXT), \"login.html does not contain the replacement text\");\n+\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.challengeTimeoutMillis = oauth2Config.getChallengeTimeout().toMillis();\n+        if (oauth2Config.getStateKey().isPresent()) {\n+            stateHmac = Hashing.sha256().hashString(oauth2Config.getStateKey().get(), UTF_8).asBytes();\n+        }\n+        else {\n+            stateHmac = new byte[32];\n+            new SecureRandom().nextBytes(stateHmac);\n+        }\n+    }\n+\n+    public URI startChallenge(URI callbackUri)\n+    {\n+        String state = Jwts.builder()\n+                .signWith(SignatureAlgorithm.HS256, stateHmac)\n+                .setAudience(STATE_AUDIENCE)\n+                .setExpiration(new Date(System.currentTimeMillis() + challengeTimeoutMillis))\n+                .setExpiration(Date.from(ZonedDateTime.now().plusMinutes(5).toInstant()))\n+                .compact();\n+\n+        return client.getAuthorizationUri(state, callbackUri);\n+    }\n+\n+    public OAuthResult finishChallenge(String state, String code, URI callbackUri)\n+            throws ChallengeFailedException\n+    {\n+        requireNonNull(callbackUri, \"callbackUri is null\");\n+        requireNonNull(state, \"state is null\");\n+        requireNonNull(code, \"code is null\");\n+\n+        Claims stateClaims = parseState(state);\n+        if (!STATE_AUDIENCE.equals(stateClaims.getAudience())) {\n+            // this is very unlikely, but is a good safety check\n+            throw new ChallengeFailedException(\"Unexpected state audience\");\n+        }\n+\n+        // fetch access token\n+        AccessToken accessToken = client.getAccessToken(code, callbackUri);\n+\n+        // validate access token is trusted by this server\n+        Claims parsedToken = jwtParser.parseClaimsJws(accessToken.getAccessToken()).getBody();\n+\n+        // determine expiration\n+        Instant validUntil = accessToken.getValidUntil()\n+                .map(instant -> Ordering.natural().min(instant, parsedToken.getExpiration().toInstant()))\n+                .orElse(parsedToken.getExpiration().toInstant());\n+\n+        return new OAuthResult(accessToken.getAccessToken(), validUntil);\n+    }\n+\n+    private Claims parseState(String state)\n+            throws ChallengeFailedException\n+    {\n+        Claims stateClaims;\n+        try {\n+            stateClaims = Jwts.parser()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2MTQ0Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528961442", "bodyText": "This results in an empty message when the error code is not handled. Probably want to do\ndefault:\n    message = \"OAuth2 unknown error code: \" + errorCode;\nAlso, you can simplify this by extracting a method\nprivate String getOAuth2ErrorMessage(String errorCode)\n{\n    switch (errorCode) {\n        case \"access_denied\":\n            return \"OAuth2 server denied the login\";\n        ...\n}", "author": "electrum", "createdAt": "2020-11-23T19:59:02Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.hash.Hashing;\n+import com.google.common.io.Resources;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.SigningKeyResolver;\n+import io.prestosql.server.security.oauth2.OAuth2Client.AccessToken;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.SecureRandom;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+\n+import static com.google.common.base.Strings.nullToEmpty;\n+import static com.google.common.base.Verify.verify;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private static final String STATE_AUDIENCE = \"presto_oauth\";\n+    private static final String FAILURE_REPLACEMENT_TEXT = \"<!-- ERROR_MESSAGE -->\";\n+\n+    private final OAuth2Client client;\n+    private final JwtParser jwtParser;\n+\n+    private final String failureHtml;\n+\n+    private final long challengeTimeoutMillis;\n+    private final byte[] stateHmac;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Client client, @ForOAuth2 SigningKeyResolver signingKeyResolver, OAuth2Config oauth2Config)\n+            throws IOException\n+    {\n+        this.client = requireNonNull(client, \"client is null\");\n+        this.jwtParser = Jwts.parser().setSigningKeyResolver(signingKeyResolver);\n+\n+        this.failureHtml = Resources.toString(Resources.getResource(getClass(), \"/oauth2/failure.html\"), UTF_8);\n+        verify(failureHtml.contains(FAILURE_REPLACEMENT_TEXT), \"login.html does not contain the replacement text\");\n+\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.challengeTimeoutMillis = oauth2Config.getChallengeTimeout().toMillis();\n+        if (oauth2Config.getStateKey().isPresent()) {\n+            stateHmac = Hashing.sha256().hashString(oauth2Config.getStateKey().get(), UTF_8).asBytes();\n+        }\n+        else {\n+            stateHmac = new byte[32];\n+            new SecureRandom().nextBytes(stateHmac);\n+        }\n+    }\n+\n+    public URI startChallenge(URI callbackUri)\n+    {\n+        String state = Jwts.builder()\n+                .signWith(SignatureAlgorithm.HS256, stateHmac)\n+                .setAudience(STATE_AUDIENCE)\n+                .setExpiration(new Date(System.currentTimeMillis() + challengeTimeoutMillis))\n+                .setExpiration(Date.from(ZonedDateTime.now().plusMinutes(5).toInstant()))\n+                .compact();\n+\n+        return client.getAuthorizationUri(state, callbackUri);\n+    }\n+\n+    public OAuthResult finishChallenge(String state, String code, URI callbackUri)\n+            throws ChallengeFailedException\n+    {\n+        requireNonNull(callbackUri, \"callbackUri is null\");\n+        requireNonNull(state, \"state is null\");\n+        requireNonNull(code, \"code is null\");\n+\n+        Claims stateClaims = parseState(state);\n+        if (!STATE_AUDIENCE.equals(stateClaims.getAudience())) {\n+            // this is very unlikely, but is a good safety check\n+            throw new ChallengeFailedException(\"Unexpected state audience\");\n+        }\n+\n+        // fetch access token\n+        AccessToken accessToken = client.getAccessToken(code, callbackUri);\n+\n+        // validate access token is trusted by this server\n+        Claims parsedToken = jwtParser.parseClaimsJws(accessToken.getAccessToken()).getBody();\n+\n+        // determine expiration\n+        Instant validUntil = accessToken.getValidUntil()\n+                .map(instant -> Ordering.natural().min(instant, parsedToken.getExpiration().toInstant()))\n+                .orElse(parsedToken.getExpiration().toInstant());\n+\n+        return new OAuthResult(accessToken.getAccessToken(), validUntil);\n+    }\n+\n+    private Claims parseState(String state)\n+            throws ChallengeFailedException\n+    {\n+        Claims stateClaims;\n+        try {\n+            stateClaims = Jwts.parser()\n+                    .setSigningKey(stateHmac)\n+                    .parseClaimsJws(state)\n+                    .getBody();\n+        }\n+        catch (RuntimeException e) {\n+            throw new ChallengeFailedException(\"State validation failed\", e);\n+        }\n+        return stateClaims;\n+    }\n+\n+    public Jws<Claims> parseClaimsJws(String token)\n+    {\n+        return jwtParser.parseClaimsJws(token);\n+    }\n+\n+    public String getCallbackErrorHtml(String errorCode)\n+    {\n+        String message = \"\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NDkyNQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528964925", "bodyText": "Put this on previous line so we don't have unnecessary indentation", "author": "electrum", "createdAt": "2020-11-23T20:05:37Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2WebUiAuthenticationFilter.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.http.client.jetty.JettyHttpClient;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.security.jwt.JwkService;\n+import io.prestosql.server.security.jwt.JwkSigningKeyResolver;\n+import io.prestosql.server.security.jwt.JwtAuthenticatorConfig;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.CookieJar;\n+import okhttp3.HttpUrl;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.SEE_OTHER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2WebUiAuthenticationFilter\n+{\n+    private static final int HTTPS_PORT = findAvailablePort();\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+    private URI serverUri;\n+\n+    public TestOAuth2WebUiAuthenticationFilter()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);\n+        testingHydraService.start();\n+\n+        createConsumer();\n+\n+        server = TestingPrestoServer.builder()\n+                .setCoordinator(true)\n+                .setAdditionalModule(new WebUiModule())\n+                .setProperties(\n+                        ImmutableMap.<String, String>builder()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NTk3Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528965972", "bodyText": "Should this be addressed? Seems like it could be a bug", "author": "electrum", "createdAt": "2020-11-23T20:07:39Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2WebUiAuthenticationFilter.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.http.client.jetty.JettyHttpClient;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.security.jwt.JwkService;\n+import io.prestosql.server.security.jwt.JwkSigningKeyResolver;\n+import io.prestosql.server.security.jwt.JwtAuthenticatorConfig;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.CookieJar;\n+import okhttp3.HttpUrl;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.SEE_OTHER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2WebUiAuthenticationFilter\n+{\n+    private static final int HTTPS_PORT = findAvailablePort();\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+    private URI serverUri;\n+\n+    public TestOAuth2WebUiAuthenticationFilter()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);\n+        testingHydraService.start();\n+\n+        createConsumer();\n+\n+        server = TestingPrestoServer.builder()\n+                .setCoordinator(true)\n+                .setAdditionalModule(new WebUiModule())\n+                .setProperties(\n+                        ImmutableMap.<String, String>builder()\n+                                .put(\"web-ui.enabled\", \"true\")\n+                                .put(\"web-ui.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.https.port\", Integer.toString(HTTPS_PORT))\n+                                .put(\"http-server.https.enabled\", \"true\")\n+                                .put(\"http-server.https.keystore.path\", Resources.getResource(\"cert/localhost.pem\").getPath())\n+                                .put(\"http-server.https.keystore.key\", \"\")\n+                                .put(\"http-server.authentication.oauth2.server-url\", \"http://localhost:\" + testingHydraService.getHydraPort())\n+                                .put(\"http-server.authentication.oauth2.auth-url\", \"http://hydra:4444/oauth2/auth\")\n+                                .put(\"http-server.authentication.oauth2.token-url\", format(\"http://localhost:%s/oauth2/token\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.jwks-url\", format(\"http://localhost:%s/.well-known/jwks.json\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.client-id\", \"another-consumer\")\n+                                .put(\"http-server.authentication.oauth2.client-secret\", \"consumer-secret\")\n+                                .put(\"http-server.authentication.oauth2.user-mapping.pattern\", \"(.*)@.*\")\n+                                .build())\n+                .build();\n+        waitForNodeRefresh(server);\n+        serverUri = server.getHttpsBaseUrl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        Closeables.closeAll(server, testingHydraService);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedApiCall()\n+            throws IOException\n+    {\n+        try (Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testUnauthorizedUICall()\n+            throws IOException\n+    {\n+        try (Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidToken()\n+            throws NoSuchAlgorithmException, IOException\n+    {\n+        KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(\"RSA\");\n+        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.RS256;\n+        keyGenerator.initialize(4096);\n+        String token = Jwts.builder()\n+                .setHeaderParam(\"alg\", \"RS256\")\n+                .setHeaderParam(\"kid\", \"public:f467aa08-1c1b-4cde-ba45-84b0ef5d2ba8\")\n+                .setHeaderParam(\"typ\", \"JWT\")\n+                .setClaims(\n+                        new DefaultClaims(\n+                                ImmutableMap.<String, Object>builder()\n+                                        .put(\"aud\", ImmutableList.of())\n+                                        .put(\"client_id\", \"another-consumer\")\n+                                        .put(\"exp\", System.currentTimeMillis() / 1000L + 60L)\n+                                        .put(\"iat\", System.currentTimeMillis())\n+                                        .put(\"iss\", \"http://hydra:4444/\")\n+                                        .put(\"jti\", UUID.randomUUID())\n+                                        .put(\"nbf\", System.currentTimeMillis() - 60L)\n+                                        .put(\"scp\", ImmutableList.of(\"openid\"))\n+                                        .put(\"sub\", \"foo@bar.com\")\n+                                        .build()))\n+                .signWith(signatureAlgorithm, keyGenerator.generateKeyPair().getPrivate())\n+                .compact();\n+\n+        try (Response response = httpClient.newCall(\n+                uiCall()\n+                        .header(AUTHORIZATION, \"Bearer \" + token)\n+                        .build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulFlow()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication((driver, wait) -> {\n+            Cookie cookie = driver.manage().getCookieNamed(\"Presto-OAuth2-Token\");\n+            assertPrestoCookie(cookie);\n+            assertUICallWithCookie(cookie);\n+        });\n+    }\n+\n+    @Test\n+    public void testExpiredAccessToken()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication(((driver, wait) -> {\n+            String accessToken = driver.manage().getCookieNamed(\"Presto-OAuth2-Token\").getValue();\n+            Thread.sleep((TTL_ACCESS_TOKEN_IN_SECONDS + 1) * 1000L); // wait for the token expiration\n+            try (Response response = httpClient.newCall(\n+                    uiCall()\n+                            .header(AUTHORIZATION, \"Bearer \" + accessToken)\n+                            .build())\n+                    .execute()) {\n+                assertUnauthorizedUICall(response);\n+            }\n+        }));\n+    }\n+\n+    private void createConsumer()\n+    {\n+        testingHydraService.createHydraContainer()\n+                .withCommand(format(\"clients create \" +\n+                        \"--endpoint http://hydra:4445 \" +\n+                        \"--id another-consumer \" +\n+                        \"--secret consumer-secret \" +\n+                        \"-g authorization_code,refresh_token \" +\n+                        \"-r token,code,id_token \" +\n+                        \"--scope openid,offline \" +\n+                        \"--callbacks https://host.testcontainers.internal:%d/oauth2/callback\", HTTPS_PORT))\n+                .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofSeconds(30)))\n+                .start();\n+    }\n+\n+    private Request.Builder uiCall()\n+    {\n+        return new Request.Builder()\n+                .url(serverUri.resolve(\"/ui/\").toString())\n+                .get();\n+    }\n+\n+    private void withSuccessfulAuthentication(AuthenticationAssertion assertion)\n+            throws Exception\n+    {\n+        try (BrowserWebDriverContainer<?> browser = createChromeContainer()) {\n+            WebDriver driver = browser.getWebDriver();\n+            driver.get(format(\"https://host.testcontainers.internal:%d/ui/\", HTTPS_PORT));\n+            WebDriverWait wait = new WebDriverWait(driver, 5);\n+            submitCredentials(driver, \"foo@bar.com\", \"foobar\", wait);\n+            giveConsent(driver, wait);\n+            wait.until(ExpectedConditions.urlMatches(format(\"https://host.testcontainers.internal:%d/ui/\", HTTPS_PORT)));\n+\n+            assertion.assertWith(driver, wait);\n+        }\n+    }\n+\n+    private BrowserWebDriverContainer<?> createChromeContainer()\n+    {\n+        ChromeOptions options = new ChromeOptions();\n+        options.setAcceptInsecureCerts(true);\n+        BrowserWebDriverContainer<?> chromeContainer = new BrowserWebDriverContainer<>()\n+                .withNetwork(testingHydraService.getNetwork())\n+                .withCapabilities(options);\n+        chromeContainer.start();\n+        return chromeContainer;\n+    }\n+\n+    private void submitCredentials(WebDriver driver, String email, String password, WebDriverWait wait)\n+    {\n+        By emailElementLocator = By.id(\"email\");\n+        System.out.println(driver.getCurrentUrl());\n+        System.out.println(driver.getPageSource());\n+        wait.until(elementToBeClickable(emailElementLocator));\n+        WebElement usernameElement = driver.findElement(emailElementLocator);\n+        usernameElement.sendKeys(email);\n+        By passwordElementLocator = By.id(\"password\");\n+        wait.until(elementToBeClickable(passwordElementLocator));\n+        WebElement passwordElement = driver.findElement(passwordElementLocator);\n+        passwordElement.sendKeys(password + \"\\n\");\n+    }\n+\n+    private void giveConsent(WebDriver driver, WebDriverWait wait)\n+    {\n+        By openIdCheckboxLocator = By.id(\"openid\");\n+        wait.until(elementToBeClickable(openIdCheckboxLocator));\n+        WebElement openIdCheckbox = driver.findElement(openIdCheckboxLocator);\n+        openIdCheckbox.click();\n+        By acceptButtonLocator = By.id(\"accept\");\n+        wait.until(elementToBeClickable(acceptButtonLocator));\n+        WebElement acceptButton = driver.findElement(acceptButtonLocator);\n+        acceptButton.click();\n+    }\n+\n+    private void assertPrestoCookie(Cookie cookie)\n+    {\n+        assertThat(cookie.getName()).isEqualTo(\"Presto-OAuth2-Token\");\n+        assertThat(cookie.getDomain()).isEqualTo(\"host.testcontainers.internal\");\n+        assertThat(cookie.getPath()).isEqualTo(\"/ui/\");\n+        assertThat(cookie.isSecure()).isTrue();\n+        assertThat(cookie.isHttpOnly()).isTrue();\n+        assertThat(cookie.getValue()).isNotBlank();\n+        Jws<Claims> jwt = Jwts.parser()\n+                .setSigningKeyResolver(new JwkSigningKeyResolver(new JwkService(\n+                        new JwtAuthenticatorConfig().setKeyFile(\"http://localhost:\" + testingHydraService.getHydraPort() + \"/.well-known/jwks.json\"),\n+                        new JettyHttpClient())))\n+                .parseClaimsJws(cookie.getValue());\n+        // TODO: check source of the difference", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NDIzMA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r529884230", "bodyText": "The difference is only 1 second and I believe it's due to selenium's rounding of the expiration time.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-24T21:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NTk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMzA0MQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r530023041", "bodyText": "Can we change the test to make sure it's within a bound? Say within 5 seconds?", "author": "electrum", "createdAt": "2020-11-25T00:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NTk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NjMwMg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528966302", "bodyText": "Put this on previous line", "author": "electrum", "createdAt": "2020-11-23T20:08:23Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2WebUiAuthenticationFilter.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.http.client.jetty.JettyHttpClient;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.security.jwt.JwkService;\n+import io.prestosql.server.security.jwt.JwkSigningKeyResolver;\n+import io.prestosql.server.security.jwt.JwtAuthenticatorConfig;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.CookieJar;\n+import okhttp3.HttpUrl;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.SEE_OTHER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2WebUiAuthenticationFilter\n+{\n+    private static final int HTTPS_PORT = findAvailablePort();\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+    private URI serverUri;\n+\n+    public TestOAuth2WebUiAuthenticationFilter()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);\n+        testingHydraService.start();\n+\n+        createConsumer();\n+\n+        server = TestingPrestoServer.builder()\n+                .setCoordinator(true)\n+                .setAdditionalModule(new WebUiModule())\n+                .setProperties(\n+                        ImmutableMap.<String, String>builder()\n+                                .put(\"web-ui.enabled\", \"true\")\n+                                .put(\"web-ui.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.https.port\", Integer.toString(HTTPS_PORT))\n+                                .put(\"http-server.https.enabled\", \"true\")\n+                                .put(\"http-server.https.keystore.path\", Resources.getResource(\"cert/localhost.pem\").getPath())\n+                                .put(\"http-server.https.keystore.key\", \"\")\n+                                .put(\"http-server.authentication.oauth2.server-url\", \"http://localhost:\" + testingHydraService.getHydraPort())\n+                                .put(\"http-server.authentication.oauth2.auth-url\", \"http://hydra:4444/oauth2/auth\")\n+                                .put(\"http-server.authentication.oauth2.token-url\", format(\"http://localhost:%s/oauth2/token\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.jwks-url\", format(\"http://localhost:%s/.well-known/jwks.json\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.client-id\", \"another-consumer\")\n+                                .put(\"http-server.authentication.oauth2.client-secret\", \"consumer-secret\")\n+                                .put(\"http-server.authentication.oauth2.user-mapping.pattern\", \"(.*)@.*\")\n+                                .build())\n+                .build();\n+        waitForNodeRefresh(server);\n+        serverUri = server.getHttpsBaseUrl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        Closeables.closeAll(server, testingHydraService);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedApiCall()\n+            throws IOException\n+    {\n+        try (Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testUnauthorizedUICall()\n+            throws IOException\n+    {\n+        try (Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidToken()\n+            throws NoSuchAlgorithmException, IOException\n+    {\n+        KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(\"RSA\");\n+        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.RS256;\n+        keyGenerator.initialize(4096);\n+        String token = Jwts.builder()\n+                .setHeaderParam(\"alg\", \"RS256\")\n+                .setHeaderParam(\"kid\", \"public:f467aa08-1c1b-4cde-ba45-84b0ef5d2ba8\")\n+                .setHeaderParam(\"typ\", \"JWT\")\n+                .setClaims(\n+                        new DefaultClaims(\n+                                ImmutableMap.<String, Object>builder()\n+                                        .put(\"aud\", ImmutableList.of())\n+                                        .put(\"client_id\", \"another-consumer\")\n+                                        .put(\"exp\", System.currentTimeMillis() / 1000L + 60L)\n+                                        .put(\"iat\", System.currentTimeMillis())\n+                                        .put(\"iss\", \"http://hydra:4444/\")\n+                                        .put(\"jti\", UUID.randomUUID())\n+                                        .put(\"nbf\", System.currentTimeMillis() - 60L)\n+                                        .put(\"scp\", ImmutableList.of(\"openid\"))\n+                                        .put(\"sub\", \"foo@bar.com\")\n+                                        .build()))\n+                .signWith(signatureAlgorithm, keyGenerator.generateKeyPair().getPrivate())\n+                .compact();\n+\n+        try (Response response = httpClient.newCall(\n+                uiCall()\n+                        .header(AUTHORIZATION, \"Bearer \" + token)\n+                        .build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulFlow()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication((driver, wait) -> {\n+            Cookie cookie = driver.manage().getCookieNamed(\"Presto-OAuth2-Token\");\n+            assertPrestoCookie(cookie);\n+            assertUICallWithCookie(cookie);\n+        });\n+    }\n+\n+    @Test\n+    public void testExpiredAccessToken()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication(((driver, wait) -> {\n+            String accessToken = driver.manage().getCookieNamed(\"Presto-OAuth2-Token\").getValue();\n+            Thread.sleep((TTL_ACCESS_TOKEN_IN_SECONDS + 1) * 1000L); // wait for the token expiration\n+            try (Response response = httpClient.newCall(\n+                    uiCall()\n+                            .header(AUTHORIZATION, \"Bearer \" + accessToken)\n+                            .build())\n+                    .execute()) {\n+                assertUnauthorizedUICall(response);\n+            }\n+        }));\n+    }\n+\n+    private void createConsumer()\n+    {\n+        testingHydraService.createHydraContainer()\n+                .withCommand(format(\"clients create \" +\n+                        \"--endpoint http://hydra:4445 \" +\n+                        \"--id another-consumer \" +\n+                        \"--secret consumer-secret \" +\n+                        \"-g authorization_code,refresh_token \" +\n+                        \"-r token,code,id_token \" +\n+                        \"--scope openid,offline \" +\n+                        \"--callbacks https://host.testcontainers.internal:%d/oauth2/callback\", HTTPS_PORT))\n+                .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofSeconds(30)))\n+                .start();\n+    }\n+\n+    private Request.Builder uiCall()\n+    {\n+        return new Request.Builder()\n+                .url(serverUri.resolve(\"/ui/\").toString())\n+                .get();\n+    }\n+\n+    private void withSuccessfulAuthentication(AuthenticationAssertion assertion)\n+            throws Exception\n+    {\n+        try (BrowserWebDriverContainer<?> browser = createChromeContainer()) {\n+            WebDriver driver = browser.getWebDriver();\n+            driver.get(format(\"https://host.testcontainers.internal:%d/ui/\", HTTPS_PORT));\n+            WebDriverWait wait = new WebDriverWait(driver, 5);\n+            submitCredentials(driver, \"foo@bar.com\", \"foobar\", wait);\n+            giveConsent(driver, wait);\n+            wait.until(ExpectedConditions.urlMatches(format(\"https://host.testcontainers.internal:%d/ui/\", HTTPS_PORT)));\n+\n+            assertion.assertWith(driver, wait);\n+        }\n+    }\n+\n+    private BrowserWebDriverContainer<?> createChromeContainer()\n+    {\n+        ChromeOptions options = new ChromeOptions();\n+        options.setAcceptInsecureCerts(true);\n+        BrowserWebDriverContainer<?> chromeContainer = new BrowserWebDriverContainer<>()\n+                .withNetwork(testingHydraService.getNetwork())\n+                .withCapabilities(options);\n+        chromeContainer.start();\n+        return chromeContainer;\n+    }\n+\n+    private void submitCredentials(WebDriver driver, String email, String password, WebDriverWait wait)\n+    {\n+        By emailElementLocator = By.id(\"email\");\n+        System.out.println(driver.getCurrentUrl());\n+        System.out.println(driver.getPageSource());\n+        wait.until(elementToBeClickable(emailElementLocator));\n+        WebElement usernameElement = driver.findElement(emailElementLocator);\n+        usernameElement.sendKeys(email);\n+        By passwordElementLocator = By.id(\"password\");\n+        wait.until(elementToBeClickable(passwordElementLocator));\n+        WebElement passwordElement = driver.findElement(passwordElementLocator);\n+        passwordElement.sendKeys(password + \"\\n\");\n+    }\n+\n+    private void giveConsent(WebDriver driver, WebDriverWait wait)\n+    {\n+        By openIdCheckboxLocator = By.id(\"openid\");\n+        wait.until(elementToBeClickable(openIdCheckboxLocator));\n+        WebElement openIdCheckbox = driver.findElement(openIdCheckboxLocator);\n+        openIdCheckbox.click();\n+        By acceptButtonLocator = By.id(\"accept\");\n+        wait.until(elementToBeClickable(acceptButtonLocator));\n+        WebElement acceptButton = driver.findElement(acceptButtonLocator);\n+        acceptButton.click();\n+    }\n+\n+    private void assertPrestoCookie(Cookie cookie)\n+    {\n+        assertThat(cookie.getName()).isEqualTo(\"Presto-OAuth2-Token\");\n+        assertThat(cookie.getDomain()).isEqualTo(\"host.testcontainers.internal\");\n+        assertThat(cookie.getPath()).isEqualTo(\"/ui/\");\n+        assertThat(cookie.isSecure()).isTrue();\n+        assertThat(cookie.isHttpOnly()).isTrue();\n+        assertThat(cookie.getValue()).isNotBlank();\n+        Jws<Claims> jwt = Jwts.parser()\n+                .setSigningKeyResolver(new JwkSigningKeyResolver(new JwkService(\n+                        new JwtAuthenticatorConfig().setKeyFile(\"http://localhost:\" + testingHydraService.getHydraPort() + \"/.well-known/jwks.json\"),\n+                        new JettyHttpClient())))\n+                .parseClaimsJws(cookie.getValue());\n+        // TODO: check source of the difference\n+        //        assertThat(cookie.getExpiry()).isEqualTo(jwt.getBody().getExpiration());\n+        assertAccessToken(jwt);\n+    }\n+\n+    private void assertAccessToken(Jws<Claims> jwt)\n+    {\n+        assertThat(jwt.getBody().getSubject()).isEqualTo(\"foo@bar.com\");\n+        assertThat(jwt.getBody().get(\"client_id\")).isEqualTo(\"another-consumer\");\n+        assertThat(jwt.getBody().getIssuer()).isEqualTo(\"http://hydra:4444/\");\n+    }\n+\n+    private void assertUICallWithCookie(Cookie cookie)\n+            throws IOException\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        httpClientBuilder.cookieJar(new CookieJar()\n+        {\n+            @Override\n+            public void saveFromResponse(HttpUrl url, List<okhttp3.Cookie> cookies)\n+            {\n+            }\n+\n+            @Override\n+            public List<okhttp3.Cookie> loadForRequest(HttpUrl url)\n+            {\n+                return ImmutableList.of(\n+                        new okhttp3.Cookie.Builder()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NzE0Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528967147", "bodyText": "We used to do this and it made tests unreliable. Can we do this a different way?", "author": "electrum", "createdAt": "2020-11-23T20:09:59Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2WebUiAuthenticationFilter.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.http.client.jetty.JettyHttpClient;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.security.jwt.JwkService;\n+import io.prestosql.server.security.jwt.JwkSigningKeyResolver;\n+import io.prestosql.server.security.jwt.JwtAuthenticatorConfig;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.CookieJar;\n+import okhttp3.HttpUrl;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.SEE_OTHER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2WebUiAuthenticationFilter\n+{\n+    private static final int HTTPS_PORT = findAvailablePort();\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+    private URI serverUri;\n+\n+    public TestOAuth2WebUiAuthenticationFilter()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);\n+        testingHydraService.start();\n+\n+        createConsumer();\n+\n+        server = TestingPrestoServer.builder()\n+                .setCoordinator(true)\n+                .setAdditionalModule(new WebUiModule())\n+                .setProperties(\n+                        ImmutableMap.<String, String>builder()\n+                                .put(\"web-ui.enabled\", \"true\")\n+                                .put(\"web-ui.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.https.port\", Integer.toString(HTTPS_PORT))\n+                                .put(\"http-server.https.enabled\", \"true\")\n+                                .put(\"http-server.https.keystore.path\", Resources.getResource(\"cert/localhost.pem\").getPath())\n+                                .put(\"http-server.https.keystore.key\", \"\")\n+                                .put(\"http-server.authentication.oauth2.server-url\", \"http://localhost:\" + testingHydraService.getHydraPort())\n+                                .put(\"http-server.authentication.oauth2.auth-url\", \"http://hydra:4444/oauth2/auth\")\n+                                .put(\"http-server.authentication.oauth2.token-url\", format(\"http://localhost:%s/oauth2/token\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.jwks-url\", format(\"http://localhost:%s/.well-known/jwks.json\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.client-id\", \"another-consumer\")\n+                                .put(\"http-server.authentication.oauth2.client-secret\", \"consumer-secret\")\n+                                .put(\"http-server.authentication.oauth2.user-mapping.pattern\", \"(.*)@.*\")\n+                                .build())\n+                .build();\n+        waitForNodeRefresh(server);\n+        serverUri = server.getHttpsBaseUrl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        Closeables.closeAll(server, testingHydraService);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedApiCall()\n+            throws IOException\n+    {\n+        try (Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testUnauthorizedUICall()\n+            throws IOException\n+    {\n+        try (Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidToken()\n+            throws NoSuchAlgorithmException, IOException\n+    {\n+        KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(\"RSA\");\n+        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.RS256;\n+        keyGenerator.initialize(4096);\n+        String token = Jwts.builder()\n+                .setHeaderParam(\"alg\", \"RS256\")\n+                .setHeaderParam(\"kid\", \"public:f467aa08-1c1b-4cde-ba45-84b0ef5d2ba8\")\n+                .setHeaderParam(\"typ\", \"JWT\")\n+                .setClaims(\n+                        new DefaultClaims(\n+                                ImmutableMap.<String, Object>builder()\n+                                        .put(\"aud\", ImmutableList.of())\n+                                        .put(\"client_id\", \"another-consumer\")\n+                                        .put(\"exp\", System.currentTimeMillis() / 1000L + 60L)\n+                                        .put(\"iat\", System.currentTimeMillis())\n+                                        .put(\"iss\", \"http://hydra:4444/\")\n+                                        .put(\"jti\", UUID.randomUUID())\n+                                        .put(\"nbf\", System.currentTimeMillis() - 60L)\n+                                        .put(\"scp\", ImmutableList.of(\"openid\"))\n+                                        .put(\"sub\", \"foo@bar.com\")\n+                                        .build()))\n+                .signWith(signatureAlgorithm, keyGenerator.generateKeyPair().getPrivate())\n+                .compact();\n+\n+        try (Response response = httpClient.newCall(\n+                uiCall()\n+                        .header(AUTHORIZATION, \"Bearer \" + token)\n+                        .build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulFlow()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication((driver, wait) -> {\n+            Cookie cookie = driver.manage().getCookieNamed(\"Presto-OAuth2-Token\");\n+            assertPrestoCookie(cookie);\n+            assertUICallWithCookie(cookie);\n+        });\n+    }\n+\n+    @Test\n+    public void testExpiredAccessToken()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication(((driver, wait) -> {\n+            String accessToken = driver.manage().getCookieNamed(\"Presto-OAuth2-Token\").getValue();\n+            Thread.sleep((TTL_ACCESS_TOKEN_IN_SECONDS + 1) * 1000L); // wait for the token expiration\n+            try (Response response = httpClient.newCall(\n+                    uiCall()\n+                            .header(AUTHORIZATION, \"Bearer \" + accessToken)\n+                            .build())\n+                    .execute()) {\n+                assertUnauthorizedUICall(response);\n+            }\n+        }));\n+    }\n+\n+    private void createConsumer()\n+    {\n+        testingHydraService.createHydraContainer()\n+                .withCommand(format(\"clients create \" +\n+                        \"--endpoint http://hydra:4445 \" +\n+                        \"--id another-consumer \" +\n+                        \"--secret consumer-secret \" +\n+                        \"-g authorization_code,refresh_token \" +\n+                        \"-r token,code,id_token \" +\n+                        \"--scope openid,offline \" +\n+                        \"--callbacks https://host.testcontainers.internal:%d/oauth2/callback\", HTTPS_PORT))\n+                .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofSeconds(30)))\n+                .start();\n+    }\n+\n+    private Request.Builder uiCall()\n+    {\n+        return new Request.Builder()\n+                .url(serverUri.resolve(\"/ui/\").toString())\n+                .get();\n+    }\n+\n+    private void withSuccessfulAuthentication(AuthenticationAssertion assertion)\n+            throws Exception\n+    {\n+        try (BrowserWebDriverContainer<?> browser = createChromeContainer()) {\n+            WebDriver driver = browser.getWebDriver();\n+            driver.get(format(\"https://host.testcontainers.internal:%d/ui/\", HTTPS_PORT));\n+            WebDriverWait wait = new WebDriverWait(driver, 5);\n+            submitCredentials(driver, \"foo@bar.com\", \"foobar\", wait);\n+            giveConsent(driver, wait);\n+            wait.until(ExpectedConditions.urlMatches(format(\"https://host.testcontainers.internal:%d/ui/\", HTTPS_PORT)));\n+\n+            assertion.assertWith(driver, wait);\n+        }\n+    }\n+\n+    private BrowserWebDriverContainer<?> createChromeContainer()\n+    {\n+        ChromeOptions options = new ChromeOptions();\n+        options.setAcceptInsecureCerts(true);\n+        BrowserWebDriverContainer<?> chromeContainer = new BrowserWebDriverContainer<>()\n+                .withNetwork(testingHydraService.getNetwork())\n+                .withCapabilities(options);\n+        chromeContainer.start();\n+        return chromeContainer;\n+    }\n+\n+    private void submitCredentials(WebDriver driver, String email, String password, WebDriverWait wait)\n+    {\n+        By emailElementLocator = By.id(\"email\");\n+        System.out.println(driver.getCurrentUrl());\n+        System.out.println(driver.getPageSource());\n+        wait.until(elementToBeClickable(emailElementLocator));\n+        WebElement usernameElement = driver.findElement(emailElementLocator);\n+        usernameElement.sendKeys(email);\n+        By passwordElementLocator = By.id(\"password\");\n+        wait.until(elementToBeClickable(passwordElementLocator));\n+        WebElement passwordElement = driver.findElement(passwordElementLocator);\n+        passwordElement.sendKeys(password + \"\\n\");\n+    }\n+\n+    private void giveConsent(WebDriver driver, WebDriverWait wait)\n+    {\n+        By openIdCheckboxLocator = By.id(\"openid\");\n+        wait.until(elementToBeClickable(openIdCheckboxLocator));\n+        WebElement openIdCheckbox = driver.findElement(openIdCheckboxLocator);\n+        openIdCheckbox.click();\n+        By acceptButtonLocator = By.id(\"accept\");\n+        wait.until(elementToBeClickable(acceptButtonLocator));\n+        WebElement acceptButton = driver.findElement(acceptButtonLocator);\n+        acceptButton.click();\n+    }\n+\n+    private void assertPrestoCookie(Cookie cookie)\n+    {\n+        assertThat(cookie.getName()).isEqualTo(\"Presto-OAuth2-Token\");\n+        assertThat(cookie.getDomain()).isEqualTo(\"host.testcontainers.internal\");\n+        assertThat(cookie.getPath()).isEqualTo(\"/ui/\");\n+        assertThat(cookie.isSecure()).isTrue();\n+        assertThat(cookie.isHttpOnly()).isTrue();\n+        assertThat(cookie.getValue()).isNotBlank();\n+        Jws<Claims> jwt = Jwts.parser()\n+                .setSigningKeyResolver(new JwkSigningKeyResolver(new JwkService(\n+                        new JwtAuthenticatorConfig().setKeyFile(\"http://localhost:\" + testingHydraService.getHydraPort() + \"/.well-known/jwks.json\"),\n+                        new JettyHttpClient())))\n+                .parseClaimsJws(cookie.getValue());\n+        // TODO: check source of the difference\n+        //        assertThat(cookie.getExpiry()).isEqualTo(jwt.getBody().getExpiration());\n+        assertAccessToken(jwt);\n+    }\n+\n+    private void assertAccessToken(Jws<Claims> jwt)\n+    {\n+        assertThat(jwt.getBody().getSubject()).isEqualTo(\"foo@bar.com\");\n+        assertThat(jwt.getBody().get(\"client_id\")).isEqualTo(\"another-consumer\");\n+        assertThat(jwt.getBody().getIssuer()).isEqualTo(\"http://hydra:4444/\");\n+    }\n+\n+    private void assertUICallWithCookie(Cookie cookie)\n+            throws IOException\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        httpClientBuilder.cookieJar(new CookieJar()\n+        {\n+            @Override\n+            public void saveFromResponse(HttpUrl url, List<okhttp3.Cookie> cookies)\n+            {\n+            }\n+\n+            @Override\n+            public List<okhttp3.Cookie> loadForRequest(HttpUrl url)\n+            {\n+                return ImmutableList.of(\n+                        new okhttp3.Cookie.Builder()\n+                                .domain(\"localhost\")\n+                                .path(\"/ui/\")\n+                                .name(\"Presto-OAuth2-Token\")\n+                                .value(cookie.getValue())\n+                                .httpOnly()\n+                                .secure()\n+                                .build());\n+            }\n+        });\n+\n+        // pass access token in Presto UI cookie\n+        assertThat(httpClientBuilder.build().newCall(uiCall().build())\n+                .execute()\n+                .code())\n+                .isEqualTo(OK.getStatusCode());\n+    }\n+\n+    private static int findAvailablePort()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwMjAxNw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r529902017", "bodyText": "It's my second attempt to solve this problem. The first one was based on choosing a random port from a wide ranger of ports and you didn't like it either so I'm open to suggestions.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-24T21:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2NzE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2Nzc1NQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528967755", "bodyText": "Let's make this a method on TestingPrestoServer since we do this in several places now", "author": "electrum", "createdAt": "2020-11-23T20:11:11Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestOAuth2WebUiAuthenticationFilter.java", "diffHunk": "@@ -0,0 +1,407 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.airlift.http.client.jetty.JettyHttpClient;\n+import io.airlift.log.Logging;\n+import io.airlift.testing.Closeables;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+import io.prestosql.server.security.jwt.JwkService;\n+import io.prestosql.server.security.jwt.JwkSigningKeyResolver;\n+import io.prestosql.server.security.jwt.JwtAuthenticatorConfig;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import okhttp3.CookieJar;\n+import okhttp3.HttpUrl;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+import org.openqa.selenium.By;\n+import org.openqa.selenium.Cookie;\n+import org.openqa.selenium.WebDriver;\n+import org.openqa.selenium.WebElement;\n+import org.openqa.selenium.chrome.ChromeOptions;\n+import org.openqa.selenium.support.ui.ExpectedConditions;\n+import org.openqa.selenium.support.ui.WebDriverWait;\n+import org.testcontainers.Testcontainers;\n+import org.testcontainers.containers.BrowserWebDriverContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.URL;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.client.OkHttpUtil.setupInsecureSsl;\n+import static io.prestosql.server.security.oauth2.TestingHydraService.TTL_ACCESS_TOKEN_IN_SECONDS;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static javax.ws.rs.core.HttpHeaders.AUTHORIZATION;\n+import static javax.ws.rs.core.HttpHeaders.LOCATION;\n+import static javax.ws.rs.core.Response.Status.OK;\n+import static javax.ws.rs.core.Response.Status.SEE_OTHER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.openqa.selenium.support.ui.ExpectedConditions.elementToBeClickable;\n+\n+@Test(singleThreaded = true)\n+public class TestOAuth2WebUiAuthenticationFilter\n+{\n+    private static final int HTTPS_PORT = findAvailablePort();\n+\n+    private final TestingHydraService testingHydraService = new TestingHydraService();\n+    private final OkHttpClient httpClient;\n+\n+    private TestingPrestoServer server;\n+    private URI serverUri;\n+\n+    public TestOAuth2WebUiAuthenticationFilter()\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        this.httpClient = httpClientBuilder.build();\n+    }\n+\n+    @BeforeClass\n+    public void setup()\n+            throws Exception\n+    {\n+        Logging.initialize();\n+\n+        Testcontainers.exposeHostPorts(HTTPS_PORT);\n+        testingHydraService.start();\n+\n+        createConsumer();\n+\n+        server = TestingPrestoServer.builder()\n+                .setCoordinator(true)\n+                .setAdditionalModule(new WebUiModule())\n+                .setProperties(\n+                        ImmutableMap.<String, String>builder()\n+                                .put(\"web-ui.enabled\", \"true\")\n+                                .put(\"web-ui.authentication.type\", \"oauth2\")\n+                                .put(\"http-server.https.port\", Integer.toString(HTTPS_PORT))\n+                                .put(\"http-server.https.enabled\", \"true\")\n+                                .put(\"http-server.https.keystore.path\", Resources.getResource(\"cert/localhost.pem\").getPath())\n+                                .put(\"http-server.https.keystore.key\", \"\")\n+                                .put(\"http-server.authentication.oauth2.server-url\", \"http://localhost:\" + testingHydraService.getHydraPort())\n+                                .put(\"http-server.authentication.oauth2.auth-url\", \"http://hydra:4444/oauth2/auth\")\n+                                .put(\"http-server.authentication.oauth2.token-url\", format(\"http://localhost:%s/oauth2/token\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.jwks-url\", format(\"http://localhost:%s/.well-known/jwks.json\", testingHydraService.getHydraPort()))\n+                                .put(\"http-server.authentication.oauth2.client-id\", \"another-consumer\")\n+                                .put(\"http-server.authentication.oauth2.client-secret\", \"consumer-secret\")\n+                                .put(\"http-server.authentication.oauth2.user-mapping.pattern\", \"(.*)@.*\")\n+                                .build())\n+                .build();\n+        waitForNodeRefresh(server);\n+        serverUri = server.getHttpsBaseUrl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+            throws IOException\n+    {\n+        Closeables.closeAll(server, testingHydraService);\n+    }\n+\n+    @Test\n+    public void testUnauthorizedApiCall()\n+            throws IOException\n+    {\n+        try (Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testUnauthorizedUICall()\n+            throws IOException\n+    {\n+        try (Response response = httpClient\n+                .newCall(uiCall().build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidToken()\n+            throws NoSuchAlgorithmException, IOException\n+    {\n+        KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(\"RSA\");\n+        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.RS256;\n+        keyGenerator.initialize(4096);\n+        String token = Jwts.builder()\n+                .setHeaderParam(\"alg\", \"RS256\")\n+                .setHeaderParam(\"kid\", \"public:f467aa08-1c1b-4cde-ba45-84b0ef5d2ba8\")\n+                .setHeaderParam(\"typ\", \"JWT\")\n+                .setClaims(\n+                        new DefaultClaims(\n+                                ImmutableMap.<String, Object>builder()\n+                                        .put(\"aud\", ImmutableList.of())\n+                                        .put(\"client_id\", \"another-consumer\")\n+                                        .put(\"exp\", System.currentTimeMillis() / 1000L + 60L)\n+                                        .put(\"iat\", System.currentTimeMillis())\n+                                        .put(\"iss\", \"http://hydra:4444/\")\n+                                        .put(\"jti\", UUID.randomUUID())\n+                                        .put(\"nbf\", System.currentTimeMillis() - 60L)\n+                                        .put(\"scp\", ImmutableList.of(\"openid\"))\n+                                        .put(\"sub\", \"foo@bar.com\")\n+                                        .build()))\n+                .signWith(signatureAlgorithm, keyGenerator.generateKeyPair().getPrivate())\n+                .compact();\n+\n+        try (Response response = httpClient.newCall(\n+                uiCall()\n+                        .header(AUTHORIZATION, \"Bearer \" + token)\n+                        .build())\n+                .execute()) {\n+            assertUnauthorizedUICall(response);\n+        }\n+    }\n+\n+    @Test\n+    public void testSuccessfulFlow()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication((driver, wait) -> {\n+            Cookie cookie = driver.manage().getCookieNamed(\"Presto-OAuth2-Token\");\n+            assertPrestoCookie(cookie);\n+            assertUICallWithCookie(cookie);\n+        });\n+    }\n+\n+    @Test\n+    public void testExpiredAccessToken()\n+            throws Exception\n+    {\n+        withSuccessfulAuthentication(((driver, wait) -> {\n+            String accessToken = driver.manage().getCookieNamed(\"Presto-OAuth2-Token\").getValue();\n+            Thread.sleep((TTL_ACCESS_TOKEN_IN_SECONDS + 1) * 1000L); // wait for the token expiration\n+            try (Response response = httpClient.newCall(\n+                    uiCall()\n+                            .header(AUTHORIZATION, \"Bearer \" + accessToken)\n+                            .build())\n+                    .execute()) {\n+                assertUnauthorizedUICall(response);\n+            }\n+        }));\n+    }\n+\n+    private void createConsumer()\n+    {\n+        testingHydraService.createHydraContainer()\n+                .withCommand(format(\"clients create \" +\n+                        \"--endpoint http://hydra:4445 \" +\n+                        \"--id another-consumer \" +\n+                        \"--secret consumer-secret \" +\n+                        \"-g authorization_code,refresh_token \" +\n+                        \"-r token,code,id_token \" +\n+                        \"--scope openid,offline \" +\n+                        \"--callbacks https://host.testcontainers.internal:%d/oauth2/callback\", HTTPS_PORT))\n+                .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofSeconds(30)))\n+                .start();\n+    }\n+\n+    private Request.Builder uiCall()\n+    {\n+        return new Request.Builder()\n+                .url(serverUri.resolve(\"/ui/\").toString())\n+                .get();\n+    }\n+\n+    private void withSuccessfulAuthentication(AuthenticationAssertion assertion)\n+            throws Exception\n+    {\n+        try (BrowserWebDriverContainer<?> browser = createChromeContainer()) {\n+            WebDriver driver = browser.getWebDriver();\n+            driver.get(format(\"https://host.testcontainers.internal:%d/ui/\", HTTPS_PORT));\n+            WebDriverWait wait = new WebDriverWait(driver, 5);\n+            submitCredentials(driver, \"foo@bar.com\", \"foobar\", wait);\n+            giveConsent(driver, wait);\n+            wait.until(ExpectedConditions.urlMatches(format(\"https://host.testcontainers.internal:%d/ui/\", HTTPS_PORT)));\n+\n+            assertion.assertWith(driver, wait);\n+        }\n+    }\n+\n+    private BrowserWebDriverContainer<?> createChromeContainer()\n+    {\n+        ChromeOptions options = new ChromeOptions();\n+        options.setAcceptInsecureCerts(true);\n+        BrowserWebDriverContainer<?> chromeContainer = new BrowserWebDriverContainer<>()\n+                .withNetwork(testingHydraService.getNetwork())\n+                .withCapabilities(options);\n+        chromeContainer.start();\n+        return chromeContainer;\n+    }\n+\n+    private void submitCredentials(WebDriver driver, String email, String password, WebDriverWait wait)\n+    {\n+        By emailElementLocator = By.id(\"email\");\n+        System.out.println(driver.getCurrentUrl());\n+        System.out.println(driver.getPageSource());\n+        wait.until(elementToBeClickable(emailElementLocator));\n+        WebElement usernameElement = driver.findElement(emailElementLocator);\n+        usernameElement.sendKeys(email);\n+        By passwordElementLocator = By.id(\"password\");\n+        wait.until(elementToBeClickable(passwordElementLocator));\n+        WebElement passwordElement = driver.findElement(passwordElementLocator);\n+        passwordElement.sendKeys(password + \"\\n\");\n+    }\n+\n+    private void giveConsent(WebDriver driver, WebDriverWait wait)\n+    {\n+        By openIdCheckboxLocator = By.id(\"openid\");\n+        wait.until(elementToBeClickable(openIdCheckboxLocator));\n+        WebElement openIdCheckbox = driver.findElement(openIdCheckboxLocator);\n+        openIdCheckbox.click();\n+        By acceptButtonLocator = By.id(\"accept\");\n+        wait.until(elementToBeClickable(acceptButtonLocator));\n+        WebElement acceptButton = driver.findElement(acceptButtonLocator);\n+        acceptButton.click();\n+    }\n+\n+    private void assertPrestoCookie(Cookie cookie)\n+    {\n+        assertThat(cookie.getName()).isEqualTo(\"Presto-OAuth2-Token\");\n+        assertThat(cookie.getDomain()).isEqualTo(\"host.testcontainers.internal\");\n+        assertThat(cookie.getPath()).isEqualTo(\"/ui/\");\n+        assertThat(cookie.isSecure()).isTrue();\n+        assertThat(cookie.isHttpOnly()).isTrue();\n+        assertThat(cookie.getValue()).isNotBlank();\n+        Jws<Claims> jwt = Jwts.parser()\n+                .setSigningKeyResolver(new JwkSigningKeyResolver(new JwkService(\n+                        new JwtAuthenticatorConfig().setKeyFile(\"http://localhost:\" + testingHydraService.getHydraPort() + \"/.well-known/jwks.json\"),\n+                        new JettyHttpClient())))\n+                .parseClaimsJws(cookie.getValue());\n+        // TODO: check source of the difference\n+        //        assertThat(cookie.getExpiry()).isEqualTo(jwt.getBody().getExpiration());\n+        assertAccessToken(jwt);\n+    }\n+\n+    private void assertAccessToken(Jws<Claims> jwt)\n+    {\n+        assertThat(jwt.getBody().getSubject()).isEqualTo(\"foo@bar.com\");\n+        assertThat(jwt.getBody().get(\"client_id\")).isEqualTo(\"another-consumer\");\n+        assertThat(jwt.getBody().getIssuer()).isEqualTo(\"http://hydra:4444/\");\n+    }\n+\n+    private void assertUICallWithCookie(Cookie cookie)\n+            throws IOException\n+    {\n+        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();\n+        setupInsecureSsl(httpClientBuilder);\n+        httpClientBuilder.followRedirects(false);\n+        httpClientBuilder.cookieJar(new CookieJar()\n+        {\n+            @Override\n+            public void saveFromResponse(HttpUrl url, List<okhttp3.Cookie> cookies)\n+            {\n+            }\n+\n+            @Override\n+            public List<okhttp3.Cookie> loadForRequest(HttpUrl url)\n+            {\n+                return ImmutableList.of(\n+                        new okhttp3.Cookie.Builder()\n+                                .domain(\"localhost\")\n+                                .path(\"/ui/\")\n+                                .name(\"Presto-OAuth2-Token\")\n+                                .value(cookie.getValue())\n+                                .httpOnly()\n+                                .secure()\n+                                .build());\n+            }\n+        });\n+\n+        // pass access token in Presto UI cookie\n+        assertThat(httpClientBuilder.build().newCall(uiCall().build())\n+                .execute()\n+                .code())\n+                .isEqualTo(OK.getStatusCode());\n+    }\n+\n+    private static int findAvailablePort()\n+    {\n+        try (ServerSocket tempSocket = new ServerSocket(0)) {\n+            return tempSocket.getLocalPort();\n+        }\n+        catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private static void waitForNodeRefresh(TestingPrestoServer server)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODU1OQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528968559", "bodyText": "Change this class to implement AutoCloseable, then this catch block is not needed", "author": "electrum", "createdAt": "2020-11-23T20:12:45Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestingHydraService.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import io.prestosql.util.AutoCloseableCloser;\n+import org.testcontainers.containers.FixedHostPortGenericContainer;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testcontainers.containers.wait.strategy.Wait;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.util.Base64;\n+\n+import static java.time.Duration.ofMinutes;\n+\n+public class TestingHydraService\n+        implements Closeable\n+{\n+    static final int TTL_ACCESS_TOKEN_IN_SECONDS = 5;\n+    private static final String HYDRA_IMAGE = \"oryd/hydra:v1.4.2\";\n+    private static final String DSN = \"postgres://hydra:mysecretpassword@database:5432/hydra?sslmode=disable\";\n+    private static final SecureRandom SECURE_RANDOM = new SecureRandom();\n+\n+    private final Network network = Network.newNetwork();\n+\n+    private final PostgreSQLContainer<?> databaseContainer = new PostgreSQLContainer<>()\n+            .withNetwork(network)\n+            .withNetworkAliases(\"database\")\n+            .withUsername(\"hydra\")\n+            .withPassword(\"mysecretpassword\")\n+            .withDatabaseName(\"hydra\");\n+\n+    private final GenericContainer<?> migrationContainer = createHydraContainer()\n+            .withCommand(\"migrate sql --yes \" + DSN)\n+            .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(ofMinutes(5)));\n+\n+    private final FixedHostPortGenericContainer<?> consentContainer = new FixedHostPortGenericContainer<>(\"oryd/hydra-login-consent-node:v1.4.2\")\n+            .withNetwork(network)\n+            .withNetworkAliases(\"consent\")\n+            .withExposedPorts(3000)\n+            .withEnv(\"HYDRA_ADMIN_URL\", \"http://hydra:4445\")\n+            .withEnv(\"NODE_TLS_REJECT_UNAUTHORIZED\", \"0\")\n+            .waitingFor(Wait.forHttp(\"/\").forStatusCode(200));\n+\n+    private final FixedHostPortGenericContainer<?> hydraContainer = createHydraContainer()\n+            .withNetworkAliases(\"hydra\")\n+            .withExposedPorts(4444, 4445)\n+            .withEnv(\"SECRETS_SYSTEM\", generateSecret())\n+            .withEnv(\"DSN\", DSN)\n+            .withEnv(\"URLS_SELF_ISSUER\", \"http://hydra:4444/\")\n+            .withEnv(\"URLS_CONSENT\", \"http://consent:3000/consent\")\n+            .withEnv(\"URLS_LOGIN\", \"http://consent:3000/login\")\n+            .withEnv(\"OAUTH2_ACCESS_TOKEN_STRATEGY\", \"jwt\")\n+            .withEnv(\"TTL_ACCESS_TOKEN\", TTL_ACCESS_TOKEN_IN_SECONDS + \"s\")\n+            .withCommand(\"serve all --dangerous-force-http\")\n+            .waitingFor(Wait.forHttp(\"/health/ready\").forPort(4444).forStatusCode(200));\n+\n+    private final AutoCloseableCloser closer = AutoCloseableCloser.create();\n+\n+    TestingHydraService()\n+    {\n+        closer.register(network);\n+        closer.register(databaseContainer);\n+        closer.register(migrationContainer);\n+        closer.register(consentContainer);\n+        closer.register(hydraContainer);\n+    }\n+\n+    public void start()\n+    {\n+        databaseContainer.start();\n+        migrationContainer.start();\n+        consentContainer.start();\n+        hydraContainer.start();\n+    }\n+\n+    public FixedHostPortGenericContainer<?> createHydraContainer()\n+    {\n+        return new FixedHostPortGenericContainer<>(HYDRA_IMAGE).withNetwork(network);\n+    }\n+\n+    public Network getNetwork()\n+    {\n+        return network;\n+    }\n+\n+    public int getHydraPort()\n+    {\n+        return hydraContainer.getMappedPort(4444);\n+    }\n+\n+    @Override\n+    public void close()\n+            throws IOException\n+    {\n+        try {\n+            closer.close();\n+        }\n+        catch (Exception e) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkwNDYyNQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r529904625", "bodyText": "Changing it to AutoCloseable makes harder to use it in our case which involves: Closeables.closeAll(server, testingHydraService).", "author": "lukasz-walkiewicz", "createdAt": "2020-11-24T21:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODU1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMzI4Mg==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r530023282", "bodyText": "Closeables supports AutoCloseable now", "author": "electrum", "createdAt": "2020-11-25T00:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODU1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE5MzU4NQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r530193585", "bodyText": "That's right, changed.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-25T08:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2OTMyOA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528969328", "bodyText": "This code is duplicated with TestOAuth2WebUiAuthenticationFilter. Would it make sense to add a method on TestingHydraService to do this?", "author": "electrum", "createdAt": "2020-11-23T20:14:22Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestingHydraService.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import io.prestosql.util.AutoCloseableCloser;\n+import org.testcontainers.containers.FixedHostPortGenericContainer;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testcontainers.containers.wait.strategy.Wait;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.util.Base64;\n+\n+import static java.time.Duration.ofMinutes;\n+\n+public class TestingHydraService\n+        implements Closeable\n+{\n+    static final int TTL_ACCESS_TOKEN_IN_SECONDS = 5;\n+    private static final String HYDRA_IMAGE = \"oryd/hydra:v1.4.2\";\n+    private static final String DSN = \"postgres://hydra:mysecretpassword@database:5432/hydra?sslmode=disable\";\n+    private static final SecureRandom SECURE_RANDOM = new SecureRandom();\n+\n+    private final Network network = Network.newNetwork();\n+\n+    private final PostgreSQLContainer<?> databaseContainer = new PostgreSQLContainer<>()\n+            .withNetwork(network)\n+            .withNetworkAliases(\"database\")\n+            .withUsername(\"hydra\")\n+            .withPassword(\"mysecretpassword\")\n+            .withDatabaseName(\"hydra\");\n+\n+    private final GenericContainer<?> migrationContainer = createHydraContainer()\n+            .withCommand(\"migrate sql --yes \" + DSN)\n+            .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(ofMinutes(5)));\n+\n+    private final FixedHostPortGenericContainer<?> consentContainer = new FixedHostPortGenericContainer<>(\"oryd/hydra-login-consent-node:v1.4.2\")\n+            .withNetwork(network)\n+            .withNetworkAliases(\"consent\")\n+            .withExposedPorts(3000)\n+            .withEnv(\"HYDRA_ADMIN_URL\", \"http://hydra:4445\")\n+            .withEnv(\"NODE_TLS_REJECT_UNAUTHORIZED\", \"0\")\n+            .waitingFor(Wait.forHttp(\"/\").forStatusCode(200));\n+\n+    private final FixedHostPortGenericContainer<?> hydraContainer = createHydraContainer()\n+            .withNetworkAliases(\"hydra\")\n+            .withExposedPorts(4444, 4445)\n+            .withEnv(\"SECRETS_SYSTEM\", generateSecret())\n+            .withEnv(\"DSN\", DSN)\n+            .withEnv(\"URLS_SELF_ISSUER\", \"http://hydra:4444/\")\n+            .withEnv(\"URLS_CONSENT\", \"http://consent:3000/consent\")\n+            .withEnv(\"URLS_LOGIN\", \"http://consent:3000/login\")\n+            .withEnv(\"OAUTH2_ACCESS_TOKEN_STRATEGY\", \"jwt\")\n+            .withEnv(\"TTL_ACCESS_TOKEN\", TTL_ACCESS_TOKEN_IN_SECONDS + \"s\")\n+            .withCommand(\"serve all --dangerous-force-http\")\n+            .waitingFor(Wait.forHttp(\"/health/ready\").forPort(4444).forStatusCode(200));\n+\n+    private final AutoCloseableCloser closer = AutoCloseableCloser.create();\n+\n+    TestingHydraService()\n+    {\n+        closer.register(network);\n+        closer.register(databaseContainer);\n+        closer.register(migrationContainer);\n+        closer.register(consentContainer);\n+        closer.register(hydraContainer);\n+    }\n+\n+    public void start()\n+    {\n+        databaseContainer.start();\n+        migrationContainer.start();\n+        consentContainer.start();\n+        hydraContainer.start();\n+    }\n+\n+    public FixedHostPortGenericContainer<?> createHydraContainer()\n+    {\n+        return new FixedHostPortGenericContainer<>(HYDRA_IMAGE).withNetwork(network);\n+    }\n+\n+    public Network getNetwork()\n+    {\n+        return network;\n+    }\n+\n+    public int getHydraPort()\n+    {\n+        return hydraContainer.getMappedPort(4444);\n+    }\n+\n+    @Override\n+    public void close()\n+            throws IOException\n+    {\n+        try {\n+            closer.close();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String generateSecret()\n+    {\n+        byte[] randomBytes = new byte[32];\n+        SECURE_RANDOM.nextBytes(randomBytes);\n+        return Base64.getEncoder().encodeToString(randomBytes);\n+    }\n+\n+    public static void main(String[] args)\n+            throws Exception\n+    {\n+        try (TestingHydraService service = new TestingHydraService()) {\n+            // expose containers ports & override environment variables\n+            service.consentContainer\n+                    .withFixedExposedPort(9020, 3000);\n+            service.hydraContainer\n+                    .withFixedExposedPort(9001, 4444)\n+                    .withFixedExposedPort(9002, 4445)\n+                    .withEnv(\"URLS_SELF_ISSUER\", \"http://localhost:9001/\")\n+                    .withEnv(\"URLS_CONSENT\", \"http://localhost:9020/consent\")\n+                    .withEnv(\"URLS_LOGIN\", \"http://localhost:9020/login\")\n+                    .withEnv(\"TTL_ACCESS_TOKEN\", \"30m\");\n+            service.start();\n+\n+            // create a client for Presto in Hydra\n+            service.createHydraContainer()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2OTgyNA==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r528969824", "bodyText": "This code is also duplicated in TestOAuth2WebUiAuthenticationFilter. Can we move it somewhere common?\nWhile duplication is not always a problem, since this is a main() method, it's not tested, so having it use tested code is better.", "author": "electrum", "createdAt": "2020-11-23T20:15:16Z", "path": "presto-main/src/test/java/io/prestosql/server/security/oauth2/TestingHydraService.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.io.Resources;\n+import io.prestosql.server.testing.TestingPrestoServer;\n+import io.prestosql.server.ui.WebUiModule;\n+import io.prestosql.util.AutoCloseableCloser;\n+import org.testcontainers.containers.FixedHostPortGenericContainer;\n+import org.testcontainers.containers.GenericContainer;\n+import org.testcontainers.containers.Network;\n+import org.testcontainers.containers.PostgreSQLContainer;\n+import org.testcontainers.containers.startupcheck.OneShotStartupCheckStrategy;\n+import org.testcontainers.containers.wait.strategy.Wait;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.util.Base64;\n+\n+import static java.time.Duration.ofMinutes;\n+\n+public class TestingHydraService\n+        implements Closeable\n+{\n+    static final int TTL_ACCESS_TOKEN_IN_SECONDS = 5;\n+    private static final String HYDRA_IMAGE = \"oryd/hydra:v1.4.2\";\n+    private static final String DSN = \"postgres://hydra:mysecretpassword@database:5432/hydra?sslmode=disable\";\n+    private static final SecureRandom SECURE_RANDOM = new SecureRandom();\n+\n+    private final Network network = Network.newNetwork();\n+\n+    private final PostgreSQLContainer<?> databaseContainer = new PostgreSQLContainer<>()\n+            .withNetwork(network)\n+            .withNetworkAliases(\"database\")\n+            .withUsername(\"hydra\")\n+            .withPassword(\"mysecretpassword\")\n+            .withDatabaseName(\"hydra\");\n+\n+    private final GenericContainer<?> migrationContainer = createHydraContainer()\n+            .withCommand(\"migrate sql --yes \" + DSN)\n+            .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(ofMinutes(5)));\n+\n+    private final FixedHostPortGenericContainer<?> consentContainer = new FixedHostPortGenericContainer<>(\"oryd/hydra-login-consent-node:v1.4.2\")\n+            .withNetwork(network)\n+            .withNetworkAliases(\"consent\")\n+            .withExposedPorts(3000)\n+            .withEnv(\"HYDRA_ADMIN_URL\", \"http://hydra:4445\")\n+            .withEnv(\"NODE_TLS_REJECT_UNAUTHORIZED\", \"0\")\n+            .waitingFor(Wait.forHttp(\"/\").forStatusCode(200));\n+\n+    private final FixedHostPortGenericContainer<?> hydraContainer = createHydraContainer()\n+            .withNetworkAliases(\"hydra\")\n+            .withExposedPorts(4444, 4445)\n+            .withEnv(\"SECRETS_SYSTEM\", generateSecret())\n+            .withEnv(\"DSN\", DSN)\n+            .withEnv(\"URLS_SELF_ISSUER\", \"http://hydra:4444/\")\n+            .withEnv(\"URLS_CONSENT\", \"http://consent:3000/consent\")\n+            .withEnv(\"URLS_LOGIN\", \"http://consent:3000/login\")\n+            .withEnv(\"OAUTH2_ACCESS_TOKEN_STRATEGY\", \"jwt\")\n+            .withEnv(\"TTL_ACCESS_TOKEN\", TTL_ACCESS_TOKEN_IN_SECONDS + \"s\")\n+            .withCommand(\"serve all --dangerous-force-http\")\n+            .waitingFor(Wait.forHttp(\"/health/ready\").forPort(4444).forStatusCode(200));\n+\n+    private final AutoCloseableCloser closer = AutoCloseableCloser.create();\n+\n+    TestingHydraService()\n+    {\n+        closer.register(network);\n+        closer.register(databaseContainer);\n+        closer.register(migrationContainer);\n+        closer.register(consentContainer);\n+        closer.register(hydraContainer);\n+    }\n+\n+    public void start()\n+    {\n+        databaseContainer.start();\n+        migrationContainer.start();\n+        consentContainer.start();\n+        hydraContainer.start();\n+    }\n+\n+    public FixedHostPortGenericContainer<?> createHydraContainer()\n+    {\n+        return new FixedHostPortGenericContainer<>(HYDRA_IMAGE).withNetwork(network);\n+    }\n+\n+    public Network getNetwork()\n+    {\n+        return network;\n+    }\n+\n+    public int getHydraPort()\n+    {\n+        return hydraContainer.getMappedPort(4444);\n+    }\n+\n+    @Override\n+    public void close()\n+            throws IOException\n+    {\n+        try {\n+            closer.close();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String generateSecret()\n+    {\n+        byte[] randomBytes = new byte[32];\n+        SECURE_RANDOM.nextBytes(randomBytes);\n+        return Base64.getEncoder().encodeToString(randomBytes);\n+    }\n+\n+    public static void main(String[] args)\n+            throws Exception\n+    {\n+        try (TestingHydraService service = new TestingHydraService()) {\n+            // expose containers ports & override environment variables\n+            service.consentContainer\n+                    .withFixedExposedPort(9020, 3000);\n+            service.hydraContainer\n+                    .withFixedExposedPort(9001, 4444)\n+                    .withFixedExposedPort(9002, 4445)\n+                    .withEnv(\"URLS_SELF_ISSUER\", \"http://localhost:9001/\")\n+                    .withEnv(\"URLS_CONSENT\", \"http://localhost:9020/consent\")\n+                    .withEnv(\"URLS_LOGIN\", \"http://localhost:9020/login\")\n+                    .withEnv(\"TTL_ACCESS_TOKEN\", \"30m\");\n+            service.start();\n+\n+            // create a client for Presto in Hydra\n+            service.createHydraContainer()\n+                    .withCommand(\"clients create \" +\n+                            \"--endpoint http://hydra:4445 \" +\n+                            \"--id another-consumer \" +\n+                            \"--secret consumer-secret \" +\n+                            \"-g authorization_code,refresh_token \" +\n+                            \"-r token,code,id_token \" +\n+                            \"--scope openid,offline \" +\n+                            \"--callbacks https://localhost:8443/oauth2/callback\")\n+                    .withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofSeconds(30)))\n+                    .start();\n+            try (TestingPrestoServer ignored = TestingPrestoServer.builder()\n+                    .setCoordinator(true)\n+                    .setAdditionalModule(new WebUiModule())\n+                    .setProperties(\n+                            ImmutableMap.<String, String>builder()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkxMDIyNw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r529910227", "bodyText": "It's not so straight forward as in the previous case and there are quite a few differences between those two places and I would prefer to leave it as it is.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-24T21:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2OTgyNA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwMzkzNQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r530703935", "bodyText": "How is this different than the other URLs? Can you clarify this with something like the below (replacing it with the proper description)\n\nURL of the authorization server's main UI page", "author": "electrum", "createdAt": "2020-11-26T00:15:39Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Config.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import io.airlift.configuration.Config;\n+import io.airlift.configuration.ConfigDescription;\n+import io.airlift.configuration.validation.FileExists;\n+import io.airlift.units.Duration;\n+import io.airlift.units.MinDuration;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import java.io.File;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+public class OAuth2Config\n+{\n+    private Optional<String> stateKey = Optional.empty();\n+    private String serverUrl;\n+    private String authUrl;\n+    private String tokenUrl;\n+    private String jwksUrl;\n+    private String clientId;\n+    private String clientSecret;\n+    private Duration challengeTimeout = new Duration(15, TimeUnit.MINUTES);\n+    private Optional<String> userMappingPattern = Optional.empty();\n+    private Optional<File> userMappingFile = Optional.empty();\n+\n+    public Optional<String> getStateKey()\n+    {\n+        return stateKey;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.state-key\")\n+    @ConfigDescription(\"A secret key used by HMAC algorithm to sign the state parameter\")\n+    public OAuth2Config setStateKey(String stateKey)\n+    {\n+        this.stateKey = Optional.ofNullable(stateKey);\n+        return this;\n+    }\n+\n+    @NotNull\n+    public String getServerUrl()\n+    {\n+        return serverUrl;\n+    }\n+\n+    @Config(\"http-server.authentication.oauth2.server-url\")\n+    @ConfigDescription(\"URL of the authorization server\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDkxNjA0NQ==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r530916045", "bodyText": "It wasn't being used since we've added jwks url, removed.", "author": "lukasz-walkiewicz", "createdAt": "2020-11-26T10:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwMzkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwNDYwMw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r530704603", "bodyText": "Do we need ZonedDateTime here, or can this be\nDate.from(Instant.now().plus(challengeTimeout))", "author": "electrum", "createdAt": "2020-11-26T00:18:41Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.io.Resources;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.SigningKeyResolver;\n+import io.prestosql.server.security.oauth2.OAuth2Client.AccessToken;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.TemporalAmount;\n+import java.util.Date;\n+\n+import static com.google.common.base.Strings.nullToEmpty;\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.hash.Hashing.sha256;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private static final String STATE_AUDIENCE = \"presto_oauth\";\n+    private static final String FAILURE_REPLACEMENT_TEXT = \"<!-- ERROR_MESSAGE -->\";\n+\n+    private final OAuth2Client client;\n+    private final JwtParser jwtParser;\n+\n+    private final String failureHtml;\n+\n+    private final TemporalAmount challengeTimeout;\n+    private final byte[] stateHmac;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Client client, @ForOAuth2 SigningKeyResolver signingKeyResolver, OAuth2Config oauth2Config)\n+            throws IOException\n+    {\n+        this.client = requireNonNull(client, \"client is null\");\n+        this.jwtParser = Jwts.parser().setSigningKeyResolver(signingKeyResolver);\n+\n+        this.failureHtml = Resources.toString(Resources.getResource(getClass(), \"/oauth2/failure.html\"), UTF_8);\n+        verify(failureHtml.contains(FAILURE_REPLACEMENT_TEXT), \"login.html does not contain the replacement text\");\n+\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.challengeTimeout = Duration.ofMillis(oauth2Config.getChallengeTimeout().toMillis());\n+        this.stateHmac = oauth2Config.getStateKey()\n+                .map(key -> sha256().hashString(key, UTF_8).asBytes())\n+                .orElseGet(() -> secureRandomBytes(32));\n+    }\n+\n+    public URI startChallenge(URI callbackUri)\n+    {\n+        String state = Jwts.builder()\n+                .signWith(SignatureAlgorithm.HS256, stateHmac)\n+                .setAudience(STATE_AUDIENCE)\n+                .setExpiration(Date.from(ZonedDateTime.now().plus(challengeTimeout).toInstant()))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDcwNDg2Nw==", "url": "https://github.com/trinodb/trino/pull/5355#discussion_r530704867", "bodyText": "Include the claim audience in the message? Or log here for debugging? If this does occur, I expect the administrator will want to know the value.", "author": "electrum", "createdAt": "2020-11-26T00:19:48Z", "path": "presto-main/src/main/java/io/prestosql/server/security/oauth2/OAuth2Service.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.security.oauth2;\n+\n+import com.google.common.collect.Ordering;\n+import com.google.common.io.Resources;\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.Jws;\n+import io.jsonwebtoken.JwtParser;\n+import io.jsonwebtoken.Jwts;\n+import io.jsonwebtoken.SignatureAlgorithm;\n+import io.jsonwebtoken.SigningKeyResolver;\n+import io.prestosql.server.security.oauth2.OAuth2Client.AccessToken;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.security.SecureRandom;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.TemporalAmount;\n+import java.util.Date;\n+\n+import static com.google.common.base.Strings.nullToEmpty;\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.hash.Hashing.sha256;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OAuth2Service\n+{\n+    private static final String STATE_AUDIENCE = \"presto_oauth\";\n+    private static final String FAILURE_REPLACEMENT_TEXT = \"<!-- ERROR_MESSAGE -->\";\n+\n+    private final OAuth2Client client;\n+    private final JwtParser jwtParser;\n+\n+    private final String failureHtml;\n+\n+    private final TemporalAmount challengeTimeout;\n+    private final byte[] stateHmac;\n+\n+    @Inject\n+    public OAuth2Service(OAuth2Client client, @ForOAuth2 SigningKeyResolver signingKeyResolver, OAuth2Config oauth2Config)\n+            throws IOException\n+    {\n+        this.client = requireNonNull(client, \"client is null\");\n+        this.jwtParser = Jwts.parser().setSigningKeyResolver(signingKeyResolver);\n+\n+        this.failureHtml = Resources.toString(Resources.getResource(getClass(), \"/oauth2/failure.html\"), UTF_8);\n+        verify(failureHtml.contains(FAILURE_REPLACEMENT_TEXT), \"login.html does not contain the replacement text\");\n+\n+        requireNonNull(oauth2Config, \"oauth2Config is null\");\n+        this.challengeTimeout = Duration.ofMillis(oauth2Config.getChallengeTimeout().toMillis());\n+        this.stateHmac = oauth2Config.getStateKey()\n+                .map(key -> sha256().hashString(key, UTF_8).asBytes())\n+                .orElseGet(() -> secureRandomBytes(32));\n+    }\n+\n+    public URI startChallenge(URI callbackUri)\n+    {\n+        String state = Jwts.builder()\n+                .signWith(SignatureAlgorithm.HS256, stateHmac)\n+                .setAudience(STATE_AUDIENCE)\n+                .setExpiration(Date.from(ZonedDateTime.now().plus(challengeTimeout).toInstant()))\n+                .compact();\n+\n+        return client.getAuthorizationUri(state, callbackUri);\n+    }\n+\n+    public OAuthResult finishChallenge(String state, String code, URI callbackUri)\n+            throws ChallengeFailedException\n+    {\n+        requireNonNull(callbackUri, \"callbackUri is null\");\n+        requireNonNull(state, \"state is null\");\n+        requireNonNull(code, \"code is null\");\n+\n+        Claims stateClaims = parseState(state);\n+        if (!STATE_AUDIENCE.equals(stateClaims.getAudience())) {\n+            // this is very unlikely, but is a good safety check\n+            throw new ChallengeFailedException(\"Unexpected state audience\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "59056f4d35ef977a0f222cd00b4632326c2d0bf5", "url": "https://github.com/trinodb/trino/commit/59056f4d35ef977a0f222cd00b4632326c2d0bf5", "message": "Ensure static web assets are always visible", "committedDate": "2020-11-30T13:03:54Z", "type": "commit"}, {"oid": "e735652ce32f672a9ad336fb5ce30e8bc8d5b716", "url": "https://github.com/trinodb/trino/commit/e735652ce32f672a9ad336fb5ce30e8bc8d5b716", "message": "Expose http server https uri in TestingPrestoServer", "committedDate": "2020-11-30T13:03:55Z", "type": "commit"}, {"oid": "a2d0fecee7382daa0897d251a800e693b0e28f94", "url": "https://github.com/trinodb/trino/commit/a2d0fecee7382daa0897d251a800e693b0e28f94", "message": "Extract waiting for the node refresh", "committedDate": "2020-11-30T13:03:55Z", "type": "commit"}, {"oid": "9d9e9dab8afe181b061b38bdeae2c54baa4313bd", "url": "https://github.com/trinodb/trino/commit/9d9e9dab8afe181b061b38bdeae2c54baa4313bd", "message": "Add OAuth2 WebUI authenticator", "committedDate": "2020-11-30T13:03:55Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "9d9e9dab8afe181b061b38bdeae2c54baa4313bd", "url": "https://github.com/trinodb/trino/commit/9d9e9dab8afe181b061b38bdeae2c54baa4313bd", "message": "Add OAuth2 WebUI authenticator", "committedDate": "2020-11-30T13:03:55Z", "type": "forcePushed"}]}