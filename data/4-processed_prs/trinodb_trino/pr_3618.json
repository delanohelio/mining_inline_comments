{"pr_number": 3618, "pr_title": "Convert LIKE to ranges", "pr_createdAt": "2020-05-04T20:08:04Z", "pr_url": "https://github.com/trinodb/trino/pull/3618", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "beac60af82b0ce3ccab679fcc98ea712d694a24b", "url": "https://github.com/trinodb/trino/commit/beac60af82b0ce3ccab679fcc98ea712d694a24b", "message": "Use Optional instead of @Nullable parameter", "committedDate": "2020-05-06T22:11:01Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNTcxNw==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421205717", "bodyText": "Why not return true directly here? It's more explicit and doesn't require additional reasoning about what the condition in the return clause below says.", "author": "martint", "createdAt": "2020-05-07T02:41:41Z", "path": "presto-main/src/main/java/io/prestosql/type/LikeFunctions.java", "diffHunk": "@@ -133,11 +135,12 @@ else if (escaped) {\n                 escaped = false;\n             }\n             else if ((currentChar == '%') || (currentChar == '_')) {\n-                isLikePattern = true;\n+                break;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2MTAzOQ==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421261039", "bodyText": "that function used to validate wellformedness, but yeah, i don't think it's necessary (nor preserved)", "author": "findepi", "createdAt": "2020-05-07T06:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNjA5Mw==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421206093", "bodyText": "Extract lengthOfCodePoint(currentChar) above the if and reuse in the else branch.", "author": "martint", "createdAt": "2020-05-07T02:43:25Z", "path": "presto-main/src/main/java/io/prestosql/type/LikeFunctions.java", "diffHunk": "@@ -146,20 +149,27 @@ public static Slice unescapeLiteralLikePattern(Slice pattern, Optional<Slice> es\n             return pattern;\n         }\n \n-        char escapeChar = getEscapeCharacter(escape).get();\n-        String stringPattern = pattern.toStringUtf8();\n-        StringBuilder unescapedPattern = new StringBuilder(stringPattern.length());\n+        int escapeChar = getEscapeCharacter(escape)\n+                .map(c -> (int) c)\n+                .orElse(-1);\n+\n+        @SuppressWarnings(\"resource\")\n+        DynamicSliceOutput output = new DynamicSliceOutput(pattern.length());\n         boolean escaped = false;\n-        for (int currentChar : stringPattern.codePoints().toArray()) {\n+        int position = 0;\n+        while (position < pattern.length()) {\n+            int currentChar = getCodePointAt(pattern, position);\n             if (!escaped && (currentChar == escapeChar)) {\n                 escaped = true;\n             }\n             else {\n-                unescapedPattern.append(Character.toChars(currentChar));\n+                output.writeBytes(pattern, position, lengthOfCodePoint(currentChar));\n                 escaped = false;\n             }\n+            position += lengthOfCodePoint(currentChar);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwODYyOA==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421208628", "bodyText": "typo", "author": "martint", "createdAt": "2020-05-07T02:52:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMTI3Ng==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421211276", "bodyText": "This should never really happen. Like expressions with constant patterns are turned into comparison expressions when ExpressionInterpreter is used to optimize expressions.", "author": "martint", "createdAt": "2020-05-07T03:02:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar\n+                return Optional.empty();\n+            }\n+            VarcharType varcharType = (VarcharType) type;\n+\n+            Symbol symbol = Symbol.from(node.getValue());\n+            Slice pattern = ((StringLiteral) node.getPattern()).getSlice();\n+            Optional<Slice> escape = node.getEscape()\n+                    .map(StringLiteral.class::cast)\n+                    .map(StringLiteral::getSlice);\n+\n+            int patternConstantPrefixBytes = LikeFunctions.patternConstantPrefixBytes(pattern, escape);\n+            if (patternConstantPrefixBytes == pattern.length()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2MTk5MA==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421261990", "bodyText": "Yes, I know. At the same time, it didn't feel right to fail or give up here.\nI will add a comment.", "author": "findepi", "createdAt": "2020-05-07T06:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMjM5OQ==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421212399", "bodyText": "This comment is redundant. It'd be useful to, instead, explain why only varchar is supported (the only other option is char)", "author": "martint", "createdAt": "2020-05-07T03:07:08Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5OTgxOQ==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421399819", "bodyText": "replaced with TODO support CharType", "author": "findepi", "createdAt": "2020-05-07T10:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMjM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMzcwNQ==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421213705", "bodyText": "This comment confused me at first reading. I thought it meant that the prefix had to be all ASCII, but the code below says otherwise (i.e., find the last ASCII character).", "author": "martint", "createdAt": "2020-05-07T03:12:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -857,6 +867,88 @@ protected ExtractionResult visitBetweenPredicate(BetweenPredicate node, Boolean\n                     new ComparisonExpression(LESS_THAN_OR_EQUAL, node.getValue(), node.getMax())), complement);\n         }\n \n+        @Override\n+        protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            Optional<ExtractionResult> result = tryVisitLikePredicate(node, complement);\n+            if (result.isPresent()) {\n+                return result.get();\n+            }\n+            return super.visitLikePredicate(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitLikePredicate(LikePredicate node, Boolean complement)\n+        {\n+            if (!(node.getValue() instanceof SymbolReference)) {\n+                // LIKE not on a symbol\n+                return Optional.empty();\n+            }\n+\n+            if (!(node.getPattern() instanceof StringLiteral)) {\n+                // dyamic pattern\n+                return Optional.empty();\n+            }\n+\n+            if (node.getEscape().isPresent() && !(node.getEscape().get() instanceof StringLiteral)) {\n+                // dynamic escape\n+                return Optional.empty();\n+            }\n+\n+            Type type = typeAnalyzer.getType(session, types, node.getValue());\n+            if (!(type instanceof VarcharType)) {\n+                // not varchar\n+                return Optional.empty();\n+            }\n+            VarcharType varcharType = (VarcharType) type;\n+\n+            Symbol symbol = Symbol.from(node.getValue());\n+            Slice pattern = ((StringLiteral) node.getPattern()).getSlice();\n+            Optional<Slice> escape = node.getEscape()\n+                    .map(StringLiteral.class::cast)\n+                    .map(StringLiteral::getSlice);\n+\n+            int patternConstantPrefixBytes = LikeFunctions.patternConstantPrefixBytes(pattern, escape);\n+            if (patternConstantPrefixBytes == pattern.length()) {\n+                Slice literal = LikeFunctions.unescapeLiteralLikePattern(pattern, escape);\n+                ValueSet valueSet;\n+                if (varcharType.isUnbounded() || countCodePoints(literal) <= varcharType.getBoundedLength()) {\n+                    valueSet = ValueSet.of(type, literal);\n+                }\n+                else {\n+                    // impossible to satisfy\n+                    valueSet = ValueSet.none(type);\n+                }\n+                Domain domain = Domain.create(complementIfNecessary(valueSet, complement), false);\n+                return Optional.of(new ExtractionResult(TupleDomain.withColumnDomains(ImmutableMap.of(symbol, domain)), TRUE_LITERAL));\n+            }\n+\n+            if (complement || patternConstantPrefixBytes == 0) {\n+                // TODO\n+                return Optional.empty();\n+            }\n+\n+            Slice constantPrefix = LikeFunctions.unescapeLiteralLikePattern(pattern.slice(0, patternConstantPrefixBytes), escape);\n+\n+            int lastIncrementable = -1;\n+            for (int position = 0; position < constantPrefix.length(); position += lengthOfCodePoint(constantPrefix, position)) {\n+                // stay within ASCII to be on the safe side with connectors TODO remove this limitation", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwMzkyNw==", "url": "https://github.com/trinodb/trino/pull/3618#discussion_r421403927", "bodyText": "reworded", "author": "findepi", "createdAt": "2020-05-07T10:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMzcwNQ=="}], "type": "inlineReview"}, {"oid": "46cd3c97b7326b25e5ab28e1a7fec2ac4759d976", "url": "https://github.com/trinodb/trino/commit/46cd3c97b7326b25e5ab28e1a7fec2ac4759d976", "message": "Operate on Slice directly", "committedDate": "2020-05-07T10:31:44Z", "type": "commit"}, {"oid": "a16d750f741276be360cac50d61998d6fb659841", "url": "https://github.com/trinodb/trino/commit/a16d750f741276be360cac50d61998d6fb659841", "message": "Add patternConstantPrefixBytes", "committedDate": "2020-05-07T10:31:44Z", "type": "commit"}, {"oid": "5f903a8c7edc30f0d2c4dc684a85e16976d1cdcd", "url": "https://github.com/trinodb/trino/commit/5f903a8c7edc30f0d2c4dc684a85e16976d1cdcd", "message": "Use JDK Predicate interface", "committedDate": "2020-05-07T10:31:44Z", "type": "commit"}, {"oid": "f3ceb7d707298f794c3c255c9d2a802bac0e2bd1", "url": "https://github.com/trinodb/trino/commit/f3ceb7d707298f794c3c255c9d2a802bac0e2bd1", "message": "Fix indentation", "committedDate": "2020-05-07T10:31:44Z", "type": "commit"}, {"oid": "d7df815e4b662175d8ee6c7c65b111cbf9c67f75", "url": "https://github.com/trinodb/trino/commit/d7df815e4b662175d8ee6c7c65b111cbf9c67f75", "message": "Translate LIKE predicate to Domain", "committedDate": "2020-05-07T10:31:44Z", "type": "commit"}, {"oid": "d7df815e4b662175d8ee6c7c65b111cbf9c67f75", "url": "https://github.com/trinodb/trino/commit/d7df815e4b662175d8ee6c7c65b111cbf9c67f75", "message": "Translate LIKE predicate to Domain", "committedDate": "2020-05-07T10:31:44Z", "type": "forcePushed"}]}