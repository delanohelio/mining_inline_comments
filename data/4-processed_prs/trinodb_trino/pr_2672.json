{"pr_number": 2672, "pr_title": "Dereference Projection Pushdown in Query Plan", "pr_createdAt": "2020-01-29T21:34:43Z", "pr_url": "https://github.com/trinodb/trino/pull/2672", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDc4Nw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406970787", "bodyText": "Why do we need this?", "author": "martint", "createdAt": "2020-04-10T22:37:14Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -497,6 +527,8 @@ public PlanOptimizers(\n                         estimatedExchangesCostCalculator,\n                         ImmutableSet.of(new PushPredicateIntoTableScan(metadata, typeAnalyzer))),\n                 projectionPushDown,\n+                new StatsRecordingPlanOptimizer(optimizerStats, new PredicatePushDown(metadata, typeAnalyzer, true, false)),\n+                simplifyOptimizer,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMzg1OA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r408613858", "bodyText": "#2672 (comment)", "author": "phd3", "createdAt": "2020-04-15T06:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0NTYyNA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417445624", "bodyText": "Add a comment explaining this is here for that reason, so that when we revisit things in the future we know why we added it", "author": "martint", "createdAt": "2020-04-29T16:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDg2Mw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406970863", "bodyText": "Why do we need this?", "author": "martint", "createdAt": "2020-04-10T22:37:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -585,6 +617,9 @@ public PlanOptimizers(\n                 costCalculator,\n                 ImmutableSet.of(new RemoveRedundantTableScanPredicate(metadata))));\n         builder.add(projectionPushDown);\n+        builder.add(new StatsRecordingPlanOptimizer(optimizerStats, new PredicatePushDown(metadata, typeAnalyzer, true, true)));\n+        builder.add(new RemoveUnsupportedDynamicFilters(metadata));\n+        builder.add(simplifyOptimizer);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMzgxNA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r408613814", "bodyText": "#2672 (comment)", "author": "phd3", "createdAt": "2020-04-15T06:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0NjA1MA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417446050", "bodyText": "Same here", "author": "martint", "createdAt": "2020-04-29T16:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MjE1OA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406972158", "bodyText": "There are some cleanups of this rule in #3350. Can you check to make sure they are compatible with the code below?", "author": "martint", "createdAt": "2020-04-10T22:42:57Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushProjectionThroughExchange.java", "diffHunk": "@@ -84,13 +86,37 @@ public Result apply(ProjectNode project, Captures captures, Context context)\n         ExchangeNode exchange = captures.get(CHILD);\n         Set<Symbol> partitioningColumns = exchange.getPartitioningScheme().getPartitioning().getColumns();\n \n+        // Prepare new partitioning scheme for the exchange node", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NDEwNw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r410454107", "bodyText": "Removed this commit, since other PR already covered this fix.", "author": "phd3", "createdAt": "2020-04-17T20:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MjE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3NDEyMg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406974122", "bodyText": "I find it easier to see what the resulting plan structure is if the construction is explicit about the nesting:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ProjectNode projectNode = new ProjectNode(context.getIdAllocator().getNextId(), source, assignments);\n          \n          \n            \n            \n          \n          \n            \n                    FilterNode filterNode = new FilterNode(\n          \n          \n            \n                            context.getIdAllocator().getNextId(),\n          \n          \n            \n                            projectNode,\n          \n          \n            \n                            ExpressionTreeRewriter.rewriteWith(new PushDownDereferencesUtil.DereferenceReplacer(expressions), node.getPredicate()));\n          \n          \n            \n            \n          \n          \n            \n                    return Result.ofPlanNode(new ProjectNode(\n          \n          \n            \n                            context.getIdAllocator().getNextId(),\n          \n          \n            \n                            filterNode,\n          \n          \n            \n                            Assignments.builder().putIdentities(node.getOutputSymbols()).build()));\n          \n          \n            \n                    return Result.ofPlanNode(new ProjectNode(\n          \n          \n            \n                            context.getIdAllocator().getNextId(),\n          \n          \n            \n                            new FilterNode(\n          \n          \n            \n                                    context.getIdAllocator().getNextId(),\n          \n          \n            \n                                    new ProjectNode(context.getIdAllocator().getNextId(), source, assignments),\n          \n          \n            \n                                    ExpressionTreeRewriter.rewriteWith(new PushDownDereferencesUtil.DereferenceReplacer(expressions), node.getPredicate())),\n          \n          \n            \n                            Assignments.identity(node.getOutputSymbols())));", "author": "martint", "createdAt": "2020-04-10T22:51:55Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/ExtractDereferencesFromFilterAboveScan.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionExtractor;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Extracts all dereference expressions from a filter node located above a table scan. This enables pushdown of\n+ * dereference projections from the filter node into table scan using the {@link io.prestosql.sql.planner.iterative.rule.PushProjectionIntoTableScan} rule.\n+ */\n+public class ExtractDereferencesFromFilterAboveScan\n+        implements Rule<FilterNode>\n+{\n+    private final TypeAnalyzer typeAnalyzer;\n+    private final Capture<TableScanNode> targetCapture = newCapture();\n+\n+    public ExtractDereferencesFromFilterAboveScan(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return filter()\n+                .with(source().matching(tableScan().capturedAs(targetCapture)));\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode node, Captures captures, Context context)\n+    {\n+        BiMap<DereferenceExpression, Symbol> expressions =\n+                HashBiMap.create(validDereferences(ExpressionExtractor.extractExpressionsNonRecursive(node), context, typeAnalyzer, false));\n+\n+        if (expressions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = node.getSource();\n+        Assignments assignments = Assignments.builder()\n+                .putIdentities(source.getOutputSymbols())\n+                .putAll(expressions.inverse())\n+                .build();\n+        ProjectNode projectNode = new ProjectNode(context.getIdAllocator().getNextId(), source, assignments);\n+\n+        FilterNode filterNode = new FilterNode(\n+                context.getIdAllocator().getNextId(),\n+                projectNode,\n+                ExpressionTreeRewriter.rewriteWith(new PushDownDereferencesUtil.DereferenceReplacer(expressions), node.getPredicate()));\n+\n+        return Result.ofPlanNode(new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                filterNode,\n+                Assignments.builder().putIdentities(node.getOutputSymbols()).build()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3NDMyNQ==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406974325", "bodyText": "There's a shorthand version for this:\nAssignments.identity(node.getOutputSymbols())));", "author": "martint", "createdAt": "2020-04-10T22:52:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/ExtractDereferencesFromFilterAboveScan.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionExtractor;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Extracts all dereference expressions from a filter node located above a table scan. This enables pushdown of\n+ * dereference projections from the filter node into table scan using the {@link io.prestosql.sql.planner.iterative.rule.PushProjectionIntoTableScan} rule.\n+ */\n+public class ExtractDereferencesFromFilterAboveScan\n+        implements Rule<FilterNode>\n+{\n+    private final TypeAnalyzer typeAnalyzer;\n+    private final Capture<TableScanNode> targetCapture = newCapture();\n+\n+    public ExtractDereferencesFromFilterAboveScan(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return filter()\n+                .with(source().matching(tableScan().capturedAs(targetCapture)));\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode node, Captures captures, Context context)\n+    {\n+        BiMap<DereferenceExpression, Symbol> expressions =\n+                HashBiMap.create(validDereferences(ExpressionExtractor.extractExpressionsNonRecursive(node), context, typeAnalyzer, false));\n+\n+        if (expressions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = node.getSource();\n+        Assignments assignments = Assignments.builder()\n+                .putIdentities(source.getOutputSymbols())\n+                .putAll(expressions.inverse())\n+                .build();\n+        ProjectNode projectNode = new ProjectNode(context.getIdAllocator().getNextId(), source, assignments);\n+\n+        FilterNode filterNode = new FilterNode(\n+                context.getIdAllocator().getNextId(),\n+                projectNode,\n+                ExpressionTreeRewriter.rewriteWith(new PushDownDereferencesUtil.DereferenceReplacer(expressions), node.getPredicate()));\n+\n+        return Result.ofPlanNode(new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                filterNode,\n+                Assignments.builder().putIdentities(node.getOutputSymbols()).build()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3NDg3NQ==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406974875", "bodyText": "Why doesn't ExpressionNodeInliner.replaceExpression work here? Why do we need a dedicated inliner for dereference expressions?", "author": "martint", "createdAt": "2020-04-10T22:55:20Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/ExtractDereferencesFromFilterAboveScan.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionExtractor;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Extracts all dereference expressions from a filter node located above a table scan. This enables pushdown of\n+ * dereference projections from the filter node into table scan using the {@link io.prestosql.sql.planner.iterative.rule.PushProjectionIntoTableScan} rule.\n+ */\n+public class ExtractDereferencesFromFilterAboveScan\n+        implements Rule<FilterNode>\n+{\n+    private final TypeAnalyzer typeAnalyzer;\n+    private final Capture<TableScanNode> targetCapture = newCapture();\n+\n+    public ExtractDereferencesFromFilterAboveScan(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return filter()\n+                .with(source().matching(tableScan().capturedAs(targetCapture)));\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode node, Captures captures, Context context)\n+    {\n+        BiMap<DereferenceExpression, Symbol> expressions =\n+                HashBiMap.create(validDereferences(ExpressionExtractor.extractExpressionsNonRecursive(node), context, typeAnalyzer, false));\n+\n+        if (expressions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = node.getSource();\n+        Assignments assignments = Assignments.builder()\n+                .putIdentities(source.getOutputSymbols())\n+                .putAll(expressions.inverse())\n+                .build();\n+        ProjectNode projectNode = new ProjectNode(context.getIdAllocator().getNextId(), source, assignments);\n+\n+        FilterNode filterNode = new FilterNode(\n+                context.getIdAllocator().getNextId(),\n+                projectNode,\n+                ExpressionTreeRewriter.rewriteWith(new PushDownDereferencesUtil.DereferenceReplacer(expressions), node.getPredicate()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MjQ3Nw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r407782477", "bodyText": "I wasn't aware of this class. Thanks for the suggestion. Replaced all invocations and removed the class.", "author": "phd3", "createdAt": "2020-04-13T23:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3NDg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3NTM1Mw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406975353", "bodyText": "Add a comment explaining why we need this dedicated rule instead of having one that extracts dereferences from filters into a Project under the filter, which would then be pushed into the tablescan by the PushProjectionIntoTablescan rule.", "author": "martint", "createdAt": "2020-04-10T22:57:52Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/ExtractDereferencesFromFilterAboveScan.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionExtractor;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Extracts all dereference expressions from a filter node located above a table scan. This enables pushdown of\n+ * dereference projections from the filter node into table scan using the {@link io.prestosql.sql.planner.iterative.rule.PushProjectionIntoTableScan} rule.\n+ */\n+public class ExtractDereferencesFromFilterAboveScan", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0MzIyMg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r407843222", "bodyText": "The general approach followed in these rules is that we always push down the optimal dereferences. i.e. if we have a.y and a.y.z projected out of a node, we only push a.y down. This is to avoid duplicate shuffling/copying in the execution.\nFollowing that logic, we can not extract such differences from  filternode itself, without a projection on top of it. This is because since output symbols of a filternode are the same as input ones. For example, consider the following:\nFilterNode (a.x = 5)\n\tNode (a)\n\nThen, just looking at this node, we won't be able to pushdown a.x since a might also be required up the tree, and we're duplicating the propagation of a.x. If there is an explicit Project on top of this FilterNode projecting a.x, we can push it down.\nAn example of why extracting dereferences from a FilterNode can be suboptimal:\nSELECT T1.a FROM T1, T2 ON T1.x = T2.X WHERE T1.a.b > T2.y\nBefore\nFilterNode(T1.a.b > T2.y)\n\tJoin(T1.x = T2.x)\n\t\tT1 (x, a)\n\t\tT2 (y)\n\nIf we extract dereferences without projection, we end up with the following:\nFilterNode(q > y)\n\tJoin(T1.x = T2.x)\n\t\tProject (q := a.b, x, a)\n\t\t\tT1(x, a)\n\n\nHere, we're replicating a.b in potential shuffle, which is not optimal. The more optimal thing  would be to not push down a.b. That's why we don't extract dereferences from filter.\nIf there is a Project(d:=a.b) on top of the FilterNode, it'd make sense to push it down. This is taken care of by PushDownDereferencesThroughFilter rule.\nThe case of ExtractDereferencesFromFilterAboveScan is special because we want to leverage applyProjection and applyFilter. Even if there's no projection above the FilterNode-->TableScan combo, we'd still like to pushdown the dereferences so that applyProjection can create virtual columns. And the next invocation of applyFilter would push the predicates down.\nI think I can summarize as the following comment in the code, if the explanation looks good to you:\n\n\nExtracting dereferences from a Filter (eg. FilterNode(a.x = 5)) can be suboptimal if columns are being accessed up the plan tree (eg. a), because it results in replication of fields (eg. a.x). So it's safer to pushdown dereferences from Filter only when there's an explicit projection on top of the filter node (Ref PushProjectionIntoTableScan).\n\n\nIn case of a FilterNode on top of TableScanNode, we want to push all dereferences into a new ProjectNode below, so that PushProjectionIntoTableScan optimizer can push those columns in the connector, and provide new column handles for subcolumns. PushPredicateIntoTableScan optimizer can then push predicates on these subcolumns into the connector.", "author": "phd3", "createdAt": "2020-04-14T03:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3NTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MDI2Ng==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r408490266", "bodyText": "Excellent explanation!", "author": "martint", "createdAt": "2020-04-14T23:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3NTM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3OTc2Mw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406979763", "bodyText": "Rename aClass to nodeClass", "author": "martint", "createdAt": "2020-04-10T23:16:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThrough.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validPushdownThroughProject;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(a_x := a.x)\n+ *    TargetNode(a)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(a_x := symbol)\n+ *    TargetNode(symbol)\n+ *      Project(symbol := a.x)\n+ * </pre>\n+ *\n+ * The dereference projections on symbols coming from the sources of TargetNode are pushed down. Projections on symbols\n+ * being synthesized within the TargetNode remain unaffected.\n+ */\n+public class PushDownDereferenceThrough<N extends PlanNode>\n+        implements Rule<ProjectNode>\n+{\n+    private final Capture<N> targetCapture = newCapture();\n+    private final Pattern<N> targetPattern;\n+\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThrough(Class<N> aClass, TypeAnalyzer typeAnalyzer)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MDAxMg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406980012", "bodyText": "Using requireNonNull inline pollutes the expression and makes the code harder to read. Pull it out into a separate line:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    targetPattern = Pattern.typeOf(requireNonNull(aClass, \"aClass is null\"));\n          \n          \n            \n                    requireNonNull(aClass, \"aClass is null\")\n          \n          \n            \n                    targetPattern = Pattern.typeOf(aClass);", "author": "martint", "createdAt": "2020-04-10T23:18:11Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThrough.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validPushdownThroughProject;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(a_x := a.x)\n+ *    TargetNode(a)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(a_x := symbol)\n+ *    TargetNode(symbol)\n+ *      Project(symbol := a.x)\n+ * </pre>\n+ *\n+ * The dereference projections on symbols coming from the sources of TargetNode are pushed down. Projections on symbols\n+ * being synthesized within the TargetNode remain unaffected.\n+ */\n+public class PushDownDereferenceThrough<N extends PlanNode>\n+        implements Rule<ProjectNode>\n+{\n+    private final Capture<N> targetCapture = newCapture();\n+    private final Pattern<N> targetPattern;\n+\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThrough(Class<N> aClass, TypeAnalyzer typeAnalyzer)\n+    {\n+        targetPattern = Pattern.typeOf(requireNonNull(aClass, \"aClass is null\"));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MjA5Mw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406982093", "bodyText": "Why not ExpressionNodeInliner?", "author": "martint", "createdAt": "2020-04-10T23:28:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThrough.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validPushdownThroughProject;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(a_x := a.x)\n+ *    TargetNode(a)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(a_x := symbol)\n+ *    TargetNode(symbol)\n+ *      Project(symbol := a.x)\n+ * </pre>\n+ *\n+ * The dereference projections on symbols coming from the sources of TargetNode are pushed down. Projections on symbols\n+ * being synthesized within the TargetNode remain unaffected.\n+ */\n+public class PushDownDereferenceThrough<N extends PlanNode>\n+        implements Rule<ProjectNode>\n+{\n+    private final Capture<N> targetCapture = newCapture();\n+    private final Pattern<N> targetPattern;\n+\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThrough(Class<N> aClass, TypeAnalyzer typeAnalyzer)\n+    {\n+        targetPattern = Pattern.typeOf(requireNonNull(aClass, \"aClass is null\"));\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<ProjectNode> getPattern()\n+    {\n+        return project()\n+                .with(source().matching(targetPattern.capturedAs(targetCapture)));\n+    }\n+\n+    @Override\n+    public Result apply(ProjectNode node, Captures captures, Context context)\n+    {\n+        N child = captures.get(targetCapture);\n+        Map<DereferenceExpression, Symbol> pushdownDereferences = validPushdownThroughProject(context, node, child, typeAnalyzer);\n+\n+        if (pushdownDereferences.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = getOnlyElement(child.getSources());\n+\n+        ProjectNode projectNode = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                source,\n+                Assignments.builder()\n+                    .putIdentities(source.getOutputSymbols())\n+                    .putAll(HashBiMap.create(pushdownDereferences).inverse())\n+                    .build());\n+\n+        PlanNode newChildNode = child.replaceChildren(ImmutableList.of(projectNode));\n+\n+        // Sanity check to ensure propagation of new symbols through the new child\n+        pushdownDereferences.values().stream()\n+                .forEach(symbol -> checkState(\n+                    newChildNode.getOutputSymbols().contains(symbol),\n+                    \"output symbols of the new child don't contain %s\",\n+                    symbol));\n+\n+        Assignments assignments = node.getAssignments().rewrite(new PushDownDereferencesUtil.DereferenceReplacer(pushdownDereferences));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MjI1Nw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406982257", "bodyText": "Use List<Expression> as the declared type.", "author": "martint", "createdAt": "2020-04-10T23:28:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThroughFilter.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+\n+import java.util.Map;\n+\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+public class PushDownDereferenceThroughFilter\n+        implements Rule<ProjectNode>\n+{\n+    private final Capture<FilterNode> targetCapture = newCapture();\n+\n+    public PushDownDereferenceThroughFilter(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    @Override\n+    public Pattern<ProjectNode> getPattern()\n+    {\n+        return project()\n+                .with(source().matching(filter().capturedAs(targetCapture)));\n+    }\n+\n+    @Override\n+    public Result apply(ProjectNode node, Captures captures, Rule.Context context)\n+    {\n+        FilterNode filterNode = captures.get(targetCapture);\n+\n+        // Pushdown superset of dereference expressions from projections and filtering predicate\n+        ImmutableList<Expression> expressions = ImmutableList.<Expression>builder()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4MzMxOQ==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406983319", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    pushdownDereferences.values().stream()\n          \n          \n            \n                            .forEach(symbol -> checkState(\n          \n          \n            \n                    pushdownDereferences.values()\n          \n          \n            \n                            .forEach(symbol -> checkState(", "author": "martint", "createdAt": "2020-04-10T23:33:52Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThrough.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validPushdownThroughProject;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(a_x := a.x)\n+ *    TargetNode(a)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(a_x := symbol)\n+ *    TargetNode(symbol)\n+ *      Project(symbol := a.x)\n+ * </pre>\n+ *\n+ * The dereference projections on symbols coming from the sources of TargetNode are pushed down. Projections on symbols\n+ * being synthesized within the TargetNode remain unaffected.\n+ */\n+public class PushDownDereferenceThrough<N extends PlanNode>\n+        implements Rule<ProjectNode>\n+{\n+    private final Capture<N> targetCapture = newCapture();\n+    private final Pattern<N> targetPattern;\n+\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThrough(Class<N> aClass, TypeAnalyzer typeAnalyzer)\n+    {\n+        targetPattern = Pattern.typeOf(requireNonNull(aClass, \"aClass is null\"));\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<ProjectNode> getPattern()\n+    {\n+        return project()\n+                .with(source().matching(targetPattern.capturedAs(targetCapture)));\n+    }\n+\n+    @Override\n+    public Result apply(ProjectNode node, Captures captures, Context context)\n+    {\n+        N child = captures.get(targetCapture);\n+        Map<DereferenceExpression, Symbol> pushdownDereferences = validPushdownThroughProject(context, node, child, typeAnalyzer);\n+\n+        if (pushdownDereferences.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = getOnlyElement(child.getSources());\n+\n+        ProjectNode projectNode = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                source,\n+                Assignments.builder()\n+                    .putIdentities(source.getOutputSymbols())\n+                    .putAll(HashBiMap.create(pushdownDereferences).inverse())\n+                    .build());\n+\n+        PlanNode newChildNode = child.replaceChildren(ImmutableList.of(projectNode));\n+\n+        // Sanity check to ensure propagation of new symbols through the new child\n+        pushdownDereferences.values().stream()\n+                .forEach(symbol -> checkState(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NDU3Nw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406984577", "bodyText": "This can be static. Capture objects are markers. They don't hold any state. Also, I'd rename it to CHILD, as that is what is being captured in the pattern.", "author": "martint", "createdAt": "2020-04-10T23:40:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThroughFilter.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+\n+import java.util.Map;\n+\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+public class PushDownDereferenceThroughFilter\n+        implements Rule<ProjectNode>\n+{\n+    private final Capture<FilterNode> targetCapture = newCapture();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NDgwMg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r406984802", "bodyText": "This can be static. Capture objects are markers. They don't hold any state. Also, I'd rename it to CHILD, as that is what is being captured in the pattern.", "author": "martint", "createdAt": "2020-04-10T23:41:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThrough.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validPushdownThroughProject;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(a_x := a.x)\n+ *    TargetNode(a)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(a_x := symbol)\n+ *    TargetNode(symbol)\n+ *      Project(symbol := a.x)\n+ * </pre>\n+ *\n+ * The dereference projections on symbols coming from the sources of TargetNode are pushed down. Projections on symbols\n+ * being synthesized within the TargetNode remain unaffected.\n+ */\n+public class PushDownDereferenceThrough<N extends PlanNode>\n+        implements Rule<ProjectNode>\n+{\n+    private final Capture<N> targetCapture = newCapture();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4MTQxMA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r407781410", "bodyText": "The reference to the type variable is non-static, so java doesn't allow to make this variable static. Renamed it to child.", "author": "phd3", "createdAt": "2020-04-13T23:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NDgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MDQ4OQ==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r408490489", "bodyText": "Ah yes, you're totally right.", "author": "martint", "createdAt": "2020-04-14T23:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk4NDgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI1NzI1NA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r407257254", "bodyText": "Missing call to RemoveUnsupportedDynamicFilters here is causing this query to be 4x slower:\n                     new RemoveUnsupportedDynamicFilters(metadata),", "author": "JamesRTaylor", "createdAt": "2020-04-12T21:58:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -497,6 +527,8 @@ public PlanOptimizers(\n                         estimatedExchangesCostCalculator,\n                         ImmutableSet.of(new PushPredicateIntoTableScan(metadata, typeAnalyzer))),\n                 projectionPushDown,\n+                new StatsRecordingPlanOptimizer(optimizerStats, new PredicatePushDown(metadata, typeAnalyzer, true, false)),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4NjgwNA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r408486804", "bodyText": "Upon closer examination, performance is the same without the RemoveUnsupportedDynamicFilters. Sorry for the noise.", "author": "JamesRTaylor", "createdAt": "2020-04-14T23:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI1NzI1NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "5259429e761205470cdb0ff1d0747b15fe10378b", "url": "https://github.com/trinodb/trino/commit/5259429e761205470cdb0ff1d0747b15fe10378b", "message": "(drop this commit) Verify behavior of TestDereferencePushdown tests in hive", "committedDate": "2020-04-22T04:49:27Z", "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0ODE2NA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417448164", "bodyText": "ExpressionExtractor.extractExpressionsNonRecursive(node) is equivalent to node.getPredicate(). Since we know the concrete type of the node, there's no need to use the generic ExpressionExtractor.", "author": "martint", "createdAt": "2020-04-29T16:27:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/ExtractDereferencesFromFilterAboveScan.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionExtractor;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.ExpressionNodeInliner.replaceExpression;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * This optimizer extracts all dereference expressions from a filter node located above a table scan into a ProjectNode.\n+ *\n+ * Extracting dereferences from a filter (eg. FilterNode(a.x = 5)) can be suboptimal if full columns are being accessed up the\n+ * plan tree (eg. a), because it can result in replicated shuffling of fields (eg. a.x). So it is safer to pushdown dereferences from\n+ * Filter only when there's an explicit projection on top of the filter node (Ref PushDereferencesThroughFilter).\n+ *\n+ * In case of a FilterNode on top of TableScanNode, we want to push all dereferences into a new ProjectNode below, so that\n+ * PushProjectionIntoTableScan optimizer can push those columns in the connector, and provide new column handles for the\n+ * projected subcolumns. PushPredicateIntoTableScan optimizer can then push predicates on these subcolumns into the connector.\n+ */\n+public class ExtractDereferencesFromFilterAboveScan\n+        implements Rule<FilterNode>\n+{\n+    private final TypeAnalyzer typeAnalyzer;\n+    private final Capture<TableScanNode> targetCapture = newCapture();\n+\n+    public ExtractDereferencesFromFilterAboveScan(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return filter()\n+                .with(source().matching(tableScan().capturedAs(targetCapture)));\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode node, Captures captures, Context context)\n+    {\n+        BiMap<DereferenceExpression, Symbol> expressions =\n+                HashBiMap.create(validDereferences(ExpressionExtractor.extractExpressionsNonRecursive(node), context, typeAnalyzer, false));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MDMxMA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417450310", "bodyText": "Rename this class to DereferencePushdown and make it package private", "author": "martint", "createdAt": "2020-04-29T16:30:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferencesUtil.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.PlanNodeIdAllocator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+public class PushDownDereferencesUtil", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MzQwNw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417453407", "bodyText": "Make this public. It's part of the interface of this class. The intent of limiting access to classes in this package is described by the class itself being package private.", "author": "martint", "createdAt": "2020-04-29T16:35:45Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferencesUtil.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.PlanNodeIdAllocator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+public class PushDownDereferencesUtil\n+{\n+    private PushDownDereferencesUtil() {}\n+\n+    /**\n+     * Create new symbols for those dereference expressions in the projections of {@param projectNode}, whose base symbol comes\n+     * from output symbols of the sources of {@param projectNode}'s child.\n+     */\n+    static Map<DereferenceExpression, Symbol> validPushdownThroughProject(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MzQ4Mg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417453482", "bodyText": "Same here", "author": "martint", "createdAt": "2020-04-29T16:35:52Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferencesUtil.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.PlanNodeIdAllocator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+public class PushDownDereferencesUtil\n+{\n+    private PushDownDereferencesUtil() {}\n+\n+    /**\n+     * Create new symbols for those dereference expressions in the projections of {@param projectNode}, whose base symbol comes\n+     * from output symbols of the sources of {@param projectNode}'s child.\n+     */\n+    static Map<DereferenceExpression, Symbol> validPushdownThroughProject(\n+            Rule.Context context,\n+            ProjectNode projectNode,\n+            PlanNode child,\n+            TypeAnalyzer typeAnalyzer)\n+    {\n+        Map<DereferenceExpression, Symbol> allDereferencesInProject = validDereferences(projectNode.getAssignments().getExpressions(), context, typeAnalyzer, true);\n+\n+        Set<Symbol> childSourceSymbols = child.getSources().stream()\n+                .flatMap(node -> node.getOutputSymbols().stream())\n+                .collect(toImmutableSet());\n+\n+        return allDereferencesInProject.entrySet().stream()\n+                .filter(entry -> childSourceSymbols.contains(getBase(entry.getKey())))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    static Map<DereferenceExpression, Symbol> validDereferences(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1Mzc0MQ==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417453741", "bodyText": "Same here", "author": "martint", "createdAt": "2020-04-29T16:36:16Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferencesUtil.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.PlanNodeIdAllocator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+public class PushDownDereferencesUtil\n+{\n+    private PushDownDereferencesUtil() {}\n+\n+    /**\n+     * Create new symbols for those dereference expressions in the projections of {@param projectNode}, whose base symbol comes\n+     * from output symbols of the sources of {@param projectNode}'s child.\n+     */\n+    static Map<DereferenceExpression, Symbol> validPushdownThroughProject(\n+            Rule.Context context,\n+            ProjectNode projectNode,\n+            PlanNode child,\n+            TypeAnalyzer typeAnalyzer)\n+    {\n+        Map<DereferenceExpression, Symbol> allDereferencesInProject = validDereferences(projectNode.getAssignments().getExpressions(), context, typeAnalyzer, true);\n+\n+        Set<Symbol> childSourceSymbols = child.getSources().stream()\n+                .flatMap(node -> node.getOutputSymbols().stream())\n+                .collect(toImmutableSet());\n+\n+        return allDereferencesInProject.entrySet().stream()\n+                .filter(entry -> childSourceSymbols.contains(getBase(entry.getKey())))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)\n+                .collect(Collectors.toSet());\n+\n+        return dereferencesToPushdown.stream()\n+                .collect(toImmutableMap(Function.identity(), expression -> newSymbol(expression, context, typeAnalyzer)));\n+    }\n+\n+    static Symbol getBase(DereferenceExpression expression)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MzgwMg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417453802", "bodyText": "Same here", "author": "martint", "createdAt": "2020-04-29T16:36:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferencesUtil.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.PlanNodeIdAllocator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+public class PushDownDereferencesUtil\n+{\n+    private PushDownDereferencesUtil() {}\n+\n+    /**\n+     * Create new symbols for those dereference expressions in the projections of {@param projectNode}, whose base symbol comes\n+     * from output symbols of the sources of {@param projectNode}'s child.\n+     */\n+    static Map<DereferenceExpression, Symbol> validPushdownThroughProject(\n+            Rule.Context context,\n+            ProjectNode projectNode,\n+            PlanNode child,\n+            TypeAnalyzer typeAnalyzer)\n+    {\n+        Map<DereferenceExpression, Symbol> allDereferencesInProject = validDereferences(projectNode.getAssignments().getExpressions(), context, typeAnalyzer, true);\n+\n+        Set<Symbol> childSourceSymbols = child.getSources().stream()\n+                .flatMap(node -> node.getOutputSymbols().stream())\n+                .collect(toImmutableSet());\n+\n+        return allDereferencesInProject.entrySet().stream()\n+                .filter(entry -> childSourceSymbols.contains(getBase(entry.getKey())))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)\n+                .collect(Collectors.toSet());\n+\n+        return dereferencesToPushdown.stream()\n+                .collect(toImmutableMap(Function.identity(), expression -> newSymbol(expression, context, typeAnalyzer)));\n+    }\n+\n+    static Symbol getBase(DereferenceExpression expression)\n+    {\n+        return getOnlyElement(extractAll(expression));\n+    }\n+\n+    static PlanNode createProjectNodeIfRequired(PlanNode planNode, Assignments dereferences, PlanNodeIdAllocator idAllocator)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3OTAxMg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417479012", "bodyText": "This rule needs to be constrained further. We're in the process of migrating PruneUnreferencedOutputs to rules and I believe the current logic in this rule will cause the optimizer to loop forever.\nThe way we're reimplementing that optimization is via a combination of \"prune node outputs\" and \"prune node sources' outputs\" rules:\n\nPrune node sources' outputs\n\nAny(x)\n   Any(x,y)\n\nis rewritten to:\nAny(x)\n  Project(x)\n    Any(x, y)\n\n\nPrune node outputs\n\nProject(x)\n   Any(x, y)\n\nis rewritten to\nAny(x)\n\nYou can think of it as progressively trickling down the constraining projection without having to implement NxM rules for each combination of node type.\nUnder the current implementation of PushDownDereferenceThroughProject, we can end up in the following situation:\nGiven:\n1. Project(x = r0.x)\n2.  Source(r0, r1)\n\nprune project source columns will rewrite it to:\n1. Project(x = r0.x)\n2.  Project(r0)\n3.    Source(r0, r1)\n\nthen dereference pushdown will rewrite it to:\n1. Project(x = $0)\n2.  Project(r0 = r0, $0 = r0.x)\n3.    Source(r0, r1)\n\nprune project source columns will fire on node 2 and rewrite it to:\n1. Project(x = $0)\n2.  Project($0 = r0.x)\n3.    Project(r0)\n4.      Source(r0, r1)\n\n... bringing us back to square one.\nWe should probably constrain the rule to not fire when the child projections is a pure identity projection.\ncc @kasiafi, who's working on migrating PruneUnreferencedOutputs", "author": "martint", "createdAt": "2020-04-29T17:15:00Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThroughProject.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.PushDownDereferencesUtil.validPushdownThroughProject;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(msg_x := msg.x)\n+ *    Project(msg := msg)\n+ *      Source(msg)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(msg_x := symbol)\n+ *    Project(msg := msg, symbol := msg.x)\n+ *      Source(msg)\n+ * </pre>\n+ */\n+public class PushDownDereferenceThroughProject", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYyNzg2Ng==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417627866", "bodyText": "Under the current implementation of PushDownDereferenceThroughProject, we can end up in the following situation:\nGiven:\n\n1. Project(x = r0.x)\n  2.  Source(r0, r1)\n\n\nprune project source columns will rewrite it to:\n\n1. Project(x = r0.x)\n  2.  Project(r0)\n    3.    Source(r0, r1)\n\n\nThat's not what we do. We don't prune Project source columns by inserting a pruning projection below.\nThe non-identity projection x = r0.x is a pruning projection itself.\nAs such, it will trigger a project-off rule on Source (to drop symbol r1). The resulting plan might be:\n1.  Project(x = r0.x)\n  2.  Source(r0)\n    3.  Project(r0)\n\nI think it wouldn't interfere with dereference pushdown. Neither I see a chance for an optimizer loop here. Regardless of the order of rule application (dereference pushdown and column pruning), the resulting plan is the same.\nWe shouldn't give up dereference pushdown when we encounter an identity projection.", "author": "kasiafi", "createdAt": "2020-04-29T21:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3OTAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1Mjg5Mw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417652893", "bodyText": "Thanks @kasiafi. I forgot the detail about not doing this for projections.", "author": "martint", "createdAt": "2020-04-29T22:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3OTAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4Nzc2Ng==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417487766", "bodyText": "SELECT * in the nested query should not be necessary. You can use VALUES directly", "author": "martint", "createdAt": "2020-04-29T17:29:15Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.sql.planner.assertions.BasePlanTest;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.anyTree;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.equiJoinClause;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.join;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.semiJoin;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.strictProject;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.unnest;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+\n+public class TestDereferencePushDown\n+        extends BasePlanTest\n+{\n+    @Test\n+    public void testDereferencePushdownMultiLevel()\n+    {\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE)))) \" +\n+                \"SELECT a.msg.x, a.msg, b.msg.y FROM t a cross join t b\",\n+                output(ImmutableList.of(\"a_msg_x\", \"a_msg\", \"b_msg_y\"),\n+                    strictProject(\n+                        ImmutableMap.of(\n+                            \"a_msg_x\", PlanMatchPattern.expression(\"a_msg.x\"),\n+                            \"a_msg\", PlanMatchPattern.expression(\"a_msg\"),\n+                            \"b_msg_y\", PlanMatchPattern.expression(\"b_msg_y\")),\n+                        join(INNER, ImmutableList.of(),\n+                            values(\"a_msg\"),\n+                            strictProject(\n+                                ImmutableMap.of(\"b_msg_y\", PlanMatchPattern.expression(\"b_msg.y\")),\n+                                values(\"b_msg\"))))));\n+    }\n+\n+    @Test\n+    public void testDereferencePushdownJoin()\n+    {\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE))))\" +\n+                        \"SELECT b.msg.x \" +\n+                        \"FROM t a, t b \" +\n+                        \"WHERE a.msg.y = b.msg.y\",\n+                output(ImmutableList.of(\"b_x\"),\n+                        join(INNER, ImmutableList.of(equiJoinClause(\"a_y\", \"b_y\")),\n+                                anyTree(\n+                                        strictProject(ImmutableMap.of(\"a_y\", expression(\"msg.y\")),\n+                                                values(\"msg\"))),\n+                                anyTree(\n+                                        strictProject(ImmutableMap.of(\"b_y\", expression(\"msg.y\"), \"b_x\", expression(\"msg.x\")),\n+                                                values(\"msg\"))))));\n+\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE))))\" +\n+                        \"SELECT a.msg.y \" +\n+                        \"FROM t a JOIN t b ON a.msg.y = b.msg.y \" +\n+                        \"WHERE a.msg.x > bigint '5'\",\n+                output(ImmutableList.of(\"a_y\"),\n+                        join(INNER, ImmutableList.of(equiJoinClause(\"a_y\", \"b_y\")),\n+                                anyTree(\n+                                        strictProject(ImmutableMap.of(\"a_y\", expression(\"msg.y\")),\n+                                                filter(\"msg.x > bigint '5'\",\n+                                                        values(\"msg\")))),\n+                                anyTree(\n+                                        strictProject(ImmutableMap.of(\"b_y\", expression(\"msg.y\")),\n+                                                values(\"msg\"))))));\n+\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE))))\" +\n+                        \"SELECT b.msg.x \" +\n+                        \"FROM t a JOIN t b ON a.msg.y = b.msg.y \" +\n+                        \"WHERE a.msg.x + b.msg.x < BIGINT '10'\",\n+                output(ImmutableList.of(\"b_x\"),\n+                        join(INNER, ImmutableList.of(equiJoinClause(\"a_y\", \"b_y\")), Optional.of(\"a_x + b_x < bigint '10'\"),\n+                                anyTree(\n+                                        strictProject(ImmutableMap.of(\"a_y\", expression(\"msg.y\"), \"a_x\", expression(\"msg.x\")),\n+                                                values(\"msg\"))),\n+                                anyTree(\n+                                        strictProject(ImmutableMap.of(\"b_y\", expression(\"msg.y\"), \"b_x\", expression(\"msg.x\")),\n+                                                values(\"msg\"))))));\n+    }\n+\n+    @Test\n+    public void testDereferencePushdownFilter()\n+    {\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE))))\" +\n+                        \"SELECT a.msg.y, b.msg.x \" +\n+                        \"FROM t a CROSS JOIN t b \" +\n+                        \"WHERE a.msg.x = 7 OR IS_FINITE(b.msg.y)\",\n+                anyTree(\n+                        join(INNER, ImmutableList.of(),\n+                                strictProject(ImmutableMap.of(\"a_x\", expression(\"msg.x\"), \"a_y\", expression(\"msg.y\")),\n+                                        values(\"msg\")),\n+                                strictProject(ImmutableMap.of(\"b_x\", expression(\"msg.x\"), \"b_y\", expression(\"msg.y\")),\n+                                        values(\"msg\")))));\n+    }\n+\n+    @Test\n+    public void testDereferencePushdownWindow()\n+    {\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE))))\" +\n+                        \"SELECT msg.x AS x, ROW_NUMBER() OVER (PARTITION BY msg.y ORDER BY msg.y) AS rn \" +\n+                        \"FROM t \",\n+                anyTree(\n+                        strictProject(ImmutableMap.of(\"a_x\", expression(\"msg.x\"), \"a_y\", expression(\"msg.y\")),\n+                                values(\"msg\"))));\n+    }\n+\n+    @Test\n+    public void testDereferencePushdownSemiJoin()\n+    {\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0, 3) AS ROW(x BIGINT, y DOUBLE, z BIGINT)))) \" +\n+                        \"SELECT msg.y \" +\n+                        \"FROM t \" +\n+                        \"WHERE \" +\n+                        \"msg.x IN (SELECT msg.z FROM t)\",\n+                anyTree(\n+                        semiJoin(\"a_x\", \"b_z\", \"semi_join_symbol\",\n+                                anyTree(\n+                                        strictProject(ImmutableMap.of(\"a_x\", expression(\"msg.x\"), \"a_y\", expression(\"msg.y\")),\n+                                                values(\"msg\"))),\n+                                anyTree(\n+                                        strictProject(ImmutableMap.of(\"b_z\", expression(\"msg.z\")),\n+                                                values(\"msg\"))))));\n+    }\n+\n+    @Test\n+    public void testDereferencePushdownLimit()\n+    {\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE))))\" +\n+                        \"SELECT b.msg.x \" +\n+                        \"FROM t a, t b \" +\n+                        \"WHERE a.msg.y = b.msg.y \" +\n+                        \"LIMIT 100\",\n+                anyTree(join(INNER, ImmutableList.of(equiJoinClause(\"a_y\", \"b_y\")),\n+                        anyTree(\n+                                strictProject(ImmutableMap.of(\"a_y\", expression(\"msg.y\")),\n+                                        values(\"msg\"))),\n+                        anyTree(\n+                                strictProject(ImmutableMap.of(\"b_y\", expression(\"msg.y\"), \"b_x\", expression(\"msg.x\")),\n+                                        values(\"msg\"))))));\n+\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE))))\" +\n+                        \"SELECT a.msg.y \" +\n+                        \"FROM t a JOIN t b ON a.msg.y = b.msg.y \" +\n+                        \"WHERE a.msg.x > BIGINT '5' \" +\n+                        \"LIMIT 100\",\n+                anyTree(join(INNER, ImmutableList.of(equiJoinClause(\"a_y\", \"b_y\")),\n+                        anyTree(\n+                                strictProject(ImmutableMap.of(\"a_y\", expression(\"msg.y\")),\n+                                        filter(\"msg.x > bigint '5'\",\n+                                                values(\"msg\")))),\n+                        anyTree(\n+                                strictProject(ImmutableMap.of(\"b_y\", expression(\"msg.y\")),\n+                                        values(\"msg\"))))));\n+\n+        assertPlan(\"WITH t(msg) AS (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE))))\" +\n+                        \"SELECT b.msg.x \" +\n+                        \"FROM t a JOIN t b ON a.msg.y = b.msg.y \" +\n+                        \"WHERE a.msg.x + b.msg.x < BIGINT '10' \" +\n+                        \"LIMIT 100\",\n+                anyTree(join(INNER, ImmutableList.of(equiJoinClause(\"a_y\", \"b_y\")), Optional.of(\"a_x + b_x < bigint '10'\"),\n+                        anyTree(\n+                                strictProject(ImmutableMap.of(\"a_y\", expression(\"msg.y\"), \"a_x\", expression(\"msg.x\")),\n+                                        values(\"msg\"))),\n+                        anyTree(\n+                                strictProject(ImmutableMap.of(\"b_y\", expression(\"msg.y\"), \"b_x\", expression(\"msg.x\")),\n+                                        values(\"msg\"))))));\n+    }\n+\n+    @Test\n+    public void testDereferencePushdownUnnest()\n+    {\n+        assertPlan(\"WITH t(msg, array) AS (SELECT * FROM (VALUES ROW(CAST(ROW(1, 2.0) AS ROW(x BIGINT, y DOUBLE)), ARRAY[1, 2, 3]))) \" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyODkxNw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r417528917", "bodyText": "We can't do this generically. The meaning of how the outputs of a node map to its inputs is node-specific, and we can't make inferences based on the fact that symbols are named the same way. It is legal for symbols to be named the same as long as they have the same type, even if they don't represent the same concept.\nAlso, for nodes such as Union, there's an internal remapping of inputs to outputs that changes the symbol names associated with they columns, so this would fail to identify them.\nAdditionally, this won't work for nodes such as Apply or SemiJoin. \"Source\" generally just means \"an input that the operation consumes to achieve its result\". In the case of Apply or Semijoin, the right side can be thought of as a subquery that gets applied for every row on the left side. In the case of Apply, there's some internal reduction operation that's done on top of the results of the subquery (semantically speaking). All this is to say that we can't generically map the dereferences in the project to the \"sources\" of a node -- it has to be done case-by-case.", "author": "martint", "createdAt": "2020-04-29T18:37:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferencesUtil.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.PlanNodeIdAllocator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+public class PushDownDereferencesUtil\n+{\n+    private PushDownDereferencesUtil() {}\n+\n+    /**\n+     * Create new symbols for those dereference expressions in the projections of {@param projectNode}, whose base symbol comes\n+     * from output symbols of the sources of {@param projectNode}'s child.\n+     */\n+    static Map<DereferenceExpression, Symbol> validPushdownThroughProject(\n+            Rule.Context context,\n+            ProjectNode projectNode,\n+            PlanNode child,\n+            TypeAnalyzer typeAnalyzer)\n+    {\n+        Map<DereferenceExpression, Symbol> allDereferencesInProject = validDereferences(projectNode.getAssignments().getExpressions(), context, typeAnalyzer, true);\n+\n+        Set<Symbol> childSourceSymbols = child.getSources().stream()\n+                .flatMap(node -> node.getOutputSymbols().stream())\n+                .collect(toImmutableSet());\n+\n+        return allDereferencesInProject.entrySet().stream()\n+                .filter(entry -> childSourceSymbols.contains(getBase(entry.getKey())))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU3Mzg0OA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r420573848", "bodyText": "Thanks @martint, that makes sense. This has been incorporated now by adding separate rules for every node, rather than trying to overfit a generic pattern. I think this suggestion has also helped with code readability and reasoning.\nAll the rules now follow the following algorithm at a high level:\nProjectNode P\n    Node N\n        sources S\n\n\n\nExtract dereference projections (and create new symbols) from E1 U E2 where (1) E1: projection assignment expressions and (2) E2: set of expressions being used in the node N. (eg predicate in FilterNode or function expressions in WindowNode). The logic for extraction is DereferencePushdown::validDereferences.\n\n\nExclude those dereference expressions, for which, the base is used as-is in the node N itself. Say the remaining dereferences are E'.\n\n\nPushdown E' by creating project nodes between N and S. Rewrite assignments in P and expressions in N to replace dereference expressions with new symbols.", "author": "phd3", "createdAt": "2020-05-06T06:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyODkxNw=="}], "type": "inlineReview"}, {"oid": "86e5d867cf745a1e010a1dcb1b2d4971470e62a5", "url": "https://github.com/trinodb/trino/commit/86e5d867cf745a1e010a1dcb1b2d4971470e62a5", "message": "(drop this commit before merging) Verify behavior of TestDereferencePushdown tests in hive", "committedDate": "2020-05-06T17:59:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyMzI4Nw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423223287", "bodyText": "Referring to this as \"dereference chain\" is more idiomatic.", "author": "martint", "createdAt": "2020-05-11T18:06:32Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)\n+                .collect(Collectors.toSet());\n+\n+        return dereferencesToPushdown.stream()\n+                .collect(toImmutableMap(Function.identity(), expression -> newSymbol(expression, context, typeAnalyzer)));\n+    }\n+\n+    public static Symbol getBase(DereferenceExpression expression)\n+    {\n+        return getOnlyElement(extractAll(expression));\n+    }\n+\n+    /**\n+     * Extract the sub-expressions of type {@link DereferenceExpression} or {@link SymbolReference} from the {@param expression}\n+     * in a top-down manner. The expressions within the base of a valid {@link DereferenceExpression} sequence are not extracted.\n+     */\n+    private static List<Expression> getSymbolReferencesAndDereferences(Expression expression)\n+    {\n+        ImmutableList.Builder<Expression> builder = ImmutableList.builder();\n+\n+        new DefaultExpressionTraversalVisitor<ImmutableList.Builder<Expression>>()\n+        {\n+            @Override\n+            protected Void visitDereferenceExpression(DereferenceExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                if (isDereferenceSequence(node)) {\n+                    context.add(node);\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitSymbolReference(SymbolReference node, ImmutableList.Builder<Expression> context)\n+            {\n+                context.add(node);\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitLambdaExpression(LambdaExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                return null;\n+            }\n+        }.process(expression, builder);\n+\n+        return builder.build();\n+    }\n+\n+    private static boolean isDereferenceSequence(DereferenceExpression expression)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyNjczMA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423226730", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .filter(expression -> (expression instanceof DereferenceExpression))\n          \n          \n            \n                            .map(expression -> (DereferenceExpression) expression)\n          \n          \n            \n                            .filter(DereferenceExpression.class::isInstance)\n          \n          \n            \n                            .map(DereferenceExpression.class::cast)", "author": "martint", "createdAt": "2020-05-11T18:12:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIzNTIxNw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423235217", "bodyText": "Pass the session and symbol allocator directly instead of Rule.Context. Creating a symbol does not inherently need a rule context.", "author": "martint", "createdAt": "2020-05-11T18:28:04Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)\n+                .collect(Collectors.toSet());\n+\n+        return dereferencesToPushdown.stream()\n+                .collect(toImmutableMap(Function.identity(), expression -> newSymbol(expression, context, typeAnalyzer)));\n+    }\n+\n+    public static Symbol getBase(DereferenceExpression expression)\n+    {\n+        return getOnlyElement(extractAll(expression));\n+    }\n+\n+    /**\n+     * Extract the sub-expressions of type {@link DereferenceExpression} or {@link SymbolReference} from the {@param expression}\n+     * in a top-down manner. The expressions within the base of a valid {@link DereferenceExpression} sequence are not extracted.\n+     */\n+    private static List<Expression> getSymbolReferencesAndDereferences(Expression expression)\n+    {\n+        ImmutableList.Builder<Expression> builder = ImmutableList.builder();\n+\n+        new DefaultExpressionTraversalVisitor<ImmutableList.Builder<Expression>>()\n+        {\n+            @Override\n+            protected Void visitDereferenceExpression(DereferenceExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                if (isDereferenceSequence(node)) {\n+                    context.add(node);\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitSymbolReference(SymbolReference node, ImmutableList.Builder<Expression> context)\n+            {\n+                context.add(node);\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitLambdaExpression(LambdaExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                return null;\n+            }\n+        }.process(expression, builder);\n+\n+        return builder.build();\n+    }\n+\n+    private static boolean isDereferenceSequence(DereferenceExpression expression)\n+    {\n+        return (expression.getBase() instanceof SymbolReference) ||\n+            ((expression.getBase() instanceof DereferenceExpression) && isDereferenceSequence((DereferenceExpression) (expression.getBase())));\n+    }\n+\n+    private static Symbol newSymbol(Expression expression, Rule.Context context, TypeAnalyzer typeAnalyzer)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIzNTcwNA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423235704", "bodyText": "It'd be cleaner to split this method into two -- currently it's doing too much:\n\nextractDereferences(Collection<Expression> expressions, boolean noOverlap)\ncreateAssignments(Collection<Expression>,  session, symbolAllocator, typeAnalyzer)\n\nDepending on how the result of the latter is being used, it could even go into the Assignments class and return an Assignments object or builder directly:\npublic static Assignments of(Collection<? extends Expression> expressions, Session session, SymbolAllocator symbolAllocator, TypeAnalyzer typeAnalyzer)\n{\n    Assignments.Builder assignments = Assignments.builder();\n\n    for (Expression expression : expressions) {\n        Type type = typeAnalyzer.getType(session, symbolAllocator.getTypes(), expression);\n        assignments.put(symbolAllocator.newSymbol(expression, type), expression);\n    }                                                                                    \n\n    return assignments.build();\n}", "author": "martint", "createdAt": "2020-05-11T18:28:52Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI0MTEwNA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423241104", "bodyText": "Switch to allowOverlap. Trying to read double-negatives is more confusing: validaDereferences(...., noOverlap = false) vs validDereferences(..., allowOverlap = true)", "author": "martint", "createdAt": "2020-05-11T18:39:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1MTg1NA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423251854", "bodyText": "With the suggestions in DereferencePushdown, this could become:\nSet<DereferenceExpression> dereferences = extractDereferences(ImmutableList.of(node.getPredicate()), false);\nif (dereferences.isEmpty()) {\n    return Result.empty();\n}\n\nAssignments assignments = Assignments.of(dereferences, context.getSession(), context.getSymbolAllocator(), typeAnalyzer);\nMap<Expression, SymbolReference> mappings = HashBiMap.create(assignments.getMap())\n        .inverse()\n        .entrySet().stream()\n        .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue().toSymbolReference()));\n\nPlanNode source = node.getSource();\nreturn Result.ofPlanNode(new ProjectNode(\n        context.getIdAllocator().getNextId(),\n        new FilterNode(\n                context.getIdAllocator().getNextId(),\n                new ProjectNode(\n                        context.getIdAllocator().getNextId(),\n                        source,\n                        Assignments.builder()\n                                .putIdentities(source.getOutputSymbols())\n                                .putAll(assignments)\n                                .build()),\n                replaceExpression(node.getPredicate(), mappings)),\n        Assignments.identity(node.getOutputSymbols())));", "author": "martint", "createdAt": "2020-05-11T18:57:53Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/ExtractDereferencesFromFilterAboveScan.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.ExpressionNodeInliner.replaceExpression;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * This optimizer extracts all dereference expressions from a filter node located above a table scan into a ProjectNode.\n+ *\n+ * Extracting dereferences from a filter (eg. FilterNode(a.x = 5)) can be suboptimal if full columns are being accessed up the\n+ * plan tree (eg. a), because it can result in replicated shuffling of fields (eg. a.x). So it is safer to pushdown dereferences from\n+ * Filter only when there's an explicit projection on top of the filter node (Ref PushDereferencesThroughFilter).\n+ *\n+ * In case of a FilterNode on top of TableScanNode, we want to push all dereferences into a new ProjectNode below, so that\n+ * PushProjectionIntoTableScan optimizer can push those columns in the connector, and provide new column handles for the\n+ * projected subcolumns. PushPredicateIntoTableScan optimizer can then push predicates on these subcolumns into the connector.\n+ */\n+public class ExtractDereferencesFromFilterAboveScan\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<TableScanNode> CHILD = newCapture();\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public ExtractDereferencesFromFilterAboveScan(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return filter()\n+                .with(source().matching(tableScan().capturedAs(CHILD)));\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode node, Captures captures, Context context)\n+    {\n+        BiMap<DereferenceExpression, Symbol> expressions =\n+                HashBiMap.create(validDereferences(ImmutableList.of(node.getPredicate()), context, typeAnalyzer, false));\n+\n+        if (expressions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = node.getSource();\n+        Assignments assignments = Assignments.builder()\n+                .putIdentities(source.getOutputSymbols())\n+                .putAll(expressions.inverse())\n+                .build();\n+\n+        return Result.ofPlanNode(new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                new FilterNode(\n+                        context.getIdAllocator().getNextId(),\n+                        new ProjectNode(context.getIdAllocator().getNextId(), source, assignments),\n+                        replaceExpression(\n+                                node.getPredicate(),\n+                                expressions.entrySet().stream()\n+                                        .collect(toImmutableMap(Map.Entry::getKey, mapping -> mapping.getValue().toSymbolReference())))),\n+                Assignments.identity(node.getOutputSymbols())));\n+    }", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2MDAyMw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423260023", "bodyText": "Why not just ExpressionNodeInliner.replaceExpression(filterNode.getPredicate(), <mappings>)?", "author": "martint", "createdAt": "2020-05-11T19:12:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThroughFilter.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(a_x := a.x, b := b)\n+ *      Filter(a.x.y = 5 AND b.m = 3)\n+ *          Source(a, b)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(a_x := expr, b := b)\n+ *      Filter(expr.y = 5 AND b.m = 3)\n+ *          Project(a := a, b := b, expr := a.x)\n+ *              Source(a, b)\n+ * </pre>\n+ *\n+ * Pushes down dereference projections in project node assignments and filter node predicate.\n+ */\n+public class PushDownDereferenceThroughFilter\n+        implements Rule<ProjectNode>\n+{\n+    private static final Capture<FilterNode> CHILD = newCapture();\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThroughFilter(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<ProjectNode> getPattern()\n+    {\n+        return project()\n+                .with(source().matching(filter().capturedAs(CHILD)));\n+    }\n+\n+    @Override\n+    public Result apply(ProjectNode node, Captures captures, Rule.Context context)\n+    {\n+        FilterNode filterNode = captures.get(CHILD);\n+\n+        // Pushdown superset of dereference expressions from projections and filtering predicate\n+        List<Expression> expressions = ImmutableList.<Expression>builder()\n+                .addAll(node.getAssignments().getExpressions())\n+                .add(filterNode.getPredicate())\n+                .build();\n+\n+        Map<DereferenceExpression, Symbol> pushdownDereferences = validDereferences(expressions, context, typeAnalyzer, true);\n+\n+        if (pushdownDereferences.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = filterNode.getSource();\n+\n+        ProjectNode projectNode = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                source,\n+                Assignments.builder()\n+                    .putIdentities(source.getOutputSymbols())\n+                    .putAll(HashBiMap.create(pushdownDereferences).inverse())\n+                    .build());\n+\n+        ExpressionNodeInliner dereferenceReplacer = new ExpressionNodeInliner(pushdownDereferences.entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, mapping -> mapping.getValue().toSymbolReference())));\n+\n+        PlanNode newFilterNode = new FilterNode(\n+                context.getIdAllocator().getNextId(),\n+                projectNode,\n+                ExpressionTreeRewriter.rewriteWith(dereferenceReplacer, filterNode.getPredicate()));", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2MjU4NA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423262584", "bodyText": "You can use the Function<Expression, Expression> variant of Assignments.rewrite():\nAssignments assignments = node.getAssignments().rewrite(expression -> replaceExpression(expression, mappings))", "author": "martint", "createdAt": "2020-05-11T19:17:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThroughProject.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.getBase;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(msg_x := msg.x)\n+ *    Project(msg := msg)\n+ *      Source(msg)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(msg_x := symbol)\n+ *    Project(msg := msg, symbol := msg.x)\n+ *      Source(msg)\n+ * </pre>\n+ */\n+public class PushDownDereferenceThroughProject\n+        implements Rule<ProjectNode>\n+{\n+    private static final Capture<ProjectNode> CHILD = newCapture();\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThroughProject(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<ProjectNode> getPattern()\n+    {\n+        return project()\n+                .with(source().matching(project().capturedAs(CHILD)));\n+    }\n+\n+    @Override\n+    public Result apply(ProjectNode node, Captures captures, Context context)\n+    {\n+        ProjectNode child = captures.get(CHILD);\n+\n+        // Extract dereferences from assignments for pushdown\n+        Map<DereferenceExpression, Symbol> dereferences = validDereferences(node.getAssignments().getExpressions(), context, typeAnalyzer, true).entrySet().stream()\n+                .filter(entry -> child.getSource().getOutputSymbols().contains(getBase(entry.getKey()))) // exclude dereferences on symbols being synthesized within child\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        if (dereferences.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // Prepare new assignments replacing dereferences with new symbols\n+        Assignments assignments = node.getAssignments().rewrite(new ExpressionNodeInliner(dereferences.entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, mapping -> mapping.getValue().toSymbolReference()))));", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM4NjQ4OA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423386488", "bodyText": "It'd be worth adding more projections to the example, otherwise it's not immediately obvious why the rule doesn't just push the whole projection below the limit:\nProject(msg_x := msg.x, y = f(...))\n   Limit\n\n->\n\nProject(msg_x := symbol, y = f(...))\n   Limit\n      Project(msg := msg, symbol := msg.x)\n\nThe same comment applies to all other examples.", "author": "martint", "createdAt": "2020-05-12T00:00:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferencesThroughLimit.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.limit;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(msg_x := msg.x)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2NzQ1Mg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423467452", "bodyText": "Why are these commented out? Remove them if no longer relevant", "author": "martint", "createdAt": "2020-05-12T05:18:05Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushProjectionThroughUnion.java", "diffHunk": "@@ -73,29 +80,37 @@ public void test()\n                     Symbol a = p.symbol(\"a\");\n                     Symbol b = p.symbol(\"b\");\n                     Symbol c = p.symbol(\"c\");\n+                    Symbol d = p.symbol(\"d\", MSG_TYPE);\n                     Symbol cTimes3 = p.symbol(\"c_times_3\");\n+                    Symbol dX = p.symbol(\"d_x\");\n+                    Symbol z = p.symbol(\"z\", MSG_TYPE);\n+                    Symbol w = p.symbol(\"w\", MSG_TYPE);\n                     return p.project(\n-                            Assignments.of(cTimes3, new ArithmeticBinaryExpression(ArithmeticBinaryExpression.Operator.MULTIPLY, c.toSymbolReference(), new LongLiteral(\"3\"))),\n+                            Assignments.of(\n+                                    cTimes3, new ArithmeticBinaryExpression(ArithmeticBinaryExpression.Operator.MULTIPLY, c.toSymbolReference(), new LongLiteral(\"3\")),\n+                                    dX, PlanBuilder.expression(\"d.x\")),\n                             p.union(\n                                     ImmutableListMultimap.<Symbol, Symbol>builder()\n                                             .put(c, a)\n                                             .put(c, b)\n+                                            .put(d, z)\n+                                            .put(d, w)\n                                             .build(),\n                                     ImmutableList.of(\n-                                            p.values(a),\n-                                            p.values(b))));\n+                                            p.values(a, z),\n+                                            p.values(b, w))));\n                 })\n                 .matches(\n                         union(\n                                 project(\n-                                        ImmutableMap.of(\"a_times_3\", expression(\"a * 3\")),\n-                                        values(ImmutableList.of(\"a\"))),\n+                                        ImmutableMap.of(\"a_times_3\", expression(\"a * 3\"), \"z_x\", expression(\"z.x\")),\n+                                        values(ImmutableList.of(\"a\", \"z\"))),\n                                 project(\n-                                        ImmutableMap.of(\"b_times_3\", expression(\"b * 3\")),\n-                                        values(ImmutableList.of(\"b\"))))\n-                                // verify that data originally on symbols aliased as x1 and x2 is part of exchange output\n-                                .withNumberOfOutputColumns(1)\n-                                .withAlias(\"a_times_3\")\n-                                .withAlias(\"b_times_3\"));\n+                                        ImmutableMap.of(\"b_times_3\", expression(\"b * 3\"), \"w_x\", expression(\"w.x\")),\n+                                        values(ImmutableList.of(\"b\", \"w\")))));\n+//                                // verify that data originally on symbols aliased as x1 and x2 is part of exchange output\n+//                                .withNumberOfOutputColumns(1)\n+//                                .withAlias(\"a_times_3\")\n+//                                .withAlias(\"b_times_3\"));", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNjkxMg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r427006912", "bodyText": "@martint I made this public since we also use one method from this class in PushLimitThroughProject and PushTopNThroughProject. This isn't ideal, should we pull out all classes from io.prestosql.sql.planner.iterative.rule.dereference to io.prestosql.sql.planner.iterative.rule package instead?", "author": "phd3", "createdAt": "2020-05-19T03:19:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -26,51 +23,49 @@\n \n import java.util.Collection;\n import java.util.List;\n-import java.util.Map;\n import java.util.Set;\n-import java.util.function.Function;\n import java.util.stream.Collectors;\n \n import static com.google.common.base.Verify.verify;\n-import static com.google.common.collect.ImmutableMap.toImmutableMap;\n import static com.google.common.collect.Iterables.getOnlyElement;\n import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n \n /**\n  * Provides helper methods to push down dereferences in the query plan.\n  */\n-class DereferencePushdown\n+public class DereferencePushdown", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAzODIyOA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r427038228", "bodyText": "Yeah, let\u2019s move them up", "author": "martint", "createdAt": "2020-05-19T05:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNjkxMg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwNDIyMg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r428204222", "bodyText": "Do these changes belong to a separate commit?", "author": "martint", "createdAt": "2020-05-20T17:59:58Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/test/PlanBuilder.java", "diffHunk": "@@ -64,11 +64,9 @@\n import io.prestosql.sql.planner.plan.MarkDistinctNode;\n import io.prestosql.sql.planner.plan.OffsetNode;\n import io.prestosql.sql.planner.plan.OutputNode;\n-import io.prestosql.sql.planner.plan.PlanFragmentId;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e1e576d234eb7e6d8a876c8ea3576f1766bf02b", "url": "https://github.com/trinodb/trino/commit/6e1e576d234eb7e6d8a876c8ea3576f1766bf02b", "message": "Remove unused method", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "8b1ef81409b543076e283aadcab6b30754dc127e", "url": "https://github.com/trinodb/trino/commit/8b1ef81409b543076e283aadcab6b30754dc127e", "message": "Fix error message in WindowNode.Function constructor", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "8389ea85979249e9ac2ec20de2a44ee565fb81fe", "url": "https://github.com/trinodb/trino/commit/8389ea85979249e9ac2ec20de2a44ee565fb81fe", "message": "Support multiple unnest outputs in unnest matcher", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "0163c39cafa7ad4b6a4e271f19c2d2398707cd5c", "url": "https://github.com/trinodb/trino/commit/0163c39cafa7ad4b6a4e271f19c2d2398707cd5c", "message": "Pushdown dereference expressions in the query plan\n\nCo-authored-by: qqibrow <qqibrow@gmail.com>\nCo-authored-by: Zhenxiao Luo <luoz@uber.com>", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "f95f644432676d0b00eaa20a73f4aa980cd87e29", "url": "https://github.com/trinodb/trino/commit/f95f644432676d0b00eaa20a73f4aa980cd87e29", "message": "Plan assertions for end to end dereference pushdown in hive", "committedDate": "2020-05-21T16:40:53Z", "type": "commit"}, {"oid": "f95f644432676d0b00eaa20a73f4aa980cd87e29", "url": "https://github.com/trinodb/trino/commit/f95f644432676d0b00eaa20a73f4aa980cd87e29", "message": "Plan assertions for end to end dereference pushdown in hive", "committedDate": "2020-05-21T16:40:53Z", "type": "forcePushed"}]}