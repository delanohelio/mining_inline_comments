{"pr_number": 2484, "pr_title": "Allow overriding required workers and required workers max wait time through system session properties", "pr_createdAt": "2020-01-13T09:13:55Z", "pr_url": "https://github.com/trinodb/trino/pull/2484", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkyNzA1NQ==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369927055", "bodyText": "My understanding of this method is used to determine if the execution needs workers.  For example, DDL commands do not need any workers.  In that case, I would expect if we don't need to wait for workers, we simply call startExecution(queryExecution).  So this code would become something like:\naddSuccessCallback(queryExecutionFuture, queryExecution -> {\n    if (queryExecution.shouldWaitForMinWorkers()) {\n        startExecution(queryExecution);\n    }\n    ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers(getRequiredWorkers(session), getRequiredWorkersMaxWait(session));\n    // when worker requirement is met, start the execution\n    addSuccessCallback(minimumWorkerFuture, () -> startExecution(queryExecution));\n    addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n});", "author": "dain", "createdAt": "2020-01-23T04:29:50Z", "path": "presto-main/src/main/java/io/prestosql/dispatcher/LocalDispatchQuery.java", "diffHunk": "@@ -93,10 +95,18 @@ public void startWaitingForResources()\n \n     private void waitForMinimumWorkers()\n     {\n-        ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers();\n-        // when worker requirement is met, wait for query execution to finish construction and then start the execution\n-        addSuccessCallback(minimumWorkerFuture, () -> addSuccessCallback(queryExecutionFuture, this::startExecution));\n-        addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n+        // wait for query execution to finish construction\n+        addSuccessCallback(queryExecutionFuture, queryExecution -> {\n+            Session session = stateMachine.getSession();\n+            int executionMinCount = 1; // always wait for 1 node to be up\n+            if (queryExecution.shouldWaitForMinWorkers()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk1NDMzOQ==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369954339", "bodyText": "When node-scheduler.include-coordinator is disabled, then I think we need to wait for 1 worker to be present to execute any command. That's why I was falling back to calling clusterSizeMonitor.waitForMinimumWorkers(1, ...) even when it's a DDL command.", "author": "raunaqmorarka", "createdAt": "2020-01-23T06:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkyNzA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc4NzMyNQ==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370787325", "bodyText": "I think that is only true for select queries.  For DDL, like show tables, I believe they run entirely on the coordinator.  For select queries, the same might be true if you don't have any table scans (only VALUES sources), but we should check.  Lets find out for sure.", "author": "dain", "createdAt": "2020-01-24T18:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkyNzA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMDI2Mg==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370800262", "bodyText": "I've done a bunch of digging into this.  Currently the required minimum (and default) value for query-manager.required-workers is 1.  For statements executed with DataDefinitionExecution(e.g., start transaction, commit, create table), this should not be needed, but is currently enforced.  For all other statements, the scheduler throws if there are no workers.  This should not be required for statements like SHOW CATALOGS or VALUES(1,2,3), but the scheduler can not make this decision itself.  Instead we would need a way in the planner to tag fragments as \"ok to run on the coordinator if no workers are available\".\nFor now, the behavior you have in this PR is consistent with the existing behavior of Presto, so I think we should leave it alone.", "author": "dain", "createdAt": "2020-01-24T19:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkyNzA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgxMDM1Ng==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370810356", "bodyText": "Instead we would need a way in the planner to tag fragments as \"ok to run on the coordinator if no workers are available\".\n\n\"single\" distribution should be sufficient for determining that.", "author": "martint", "createdAt": "2020-01-24T19:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkyNzA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzMTE0NA==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369931144", "bodyText": "I'm not sure about the implications of this matcher rule.  I'd like to hear from @martint and @david on this part.", "author": "dain", "createdAt": "2020-01-23T04:57:09Z", "path": "presto-main/src/main/java/io/prestosql/execution/SqlQueryExecution.java", "diffHunk": "@@ -599,6 +602,27 @@ private QueryInfo buildQueryInfo(SqlQueryScheduler scheduler)\n         return queryInfo;\n     }\n \n+    @Override\n+    public boolean shouldWaitForMinWorkers()\n+    {\n+        return shouldWaitForMinWorkers(analysis.getStatement());\n+    }\n+\n+    private boolean shouldWaitForMinWorkers(Statement statement)\n+    {\n+        if (statement instanceof Query) {\n+            // Allow set session statements and queries on internal system connectors to run without waiting\n+            Collection<TableHandle> tables = analysis.getTables();\n+            if (tables.isEmpty()) {\n+                return false;\n+            }\n+            return !tables.stream()\n+                    .map(TableHandle::getCatalogName)\n+                    .allMatch(CatalogName::isInternalSystemConnector);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzOTgzMg==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369939832", "bodyText": "This seems correct. However, the check for an empty collection is not needed, as allMatch() returns true for that.", "author": "electrum", "createdAt": "2020-01-23T05:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzMTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAzNDM4OA==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370034388", "bodyText": "I've now simplified this by removing the empty collection check.", "author": "raunaqmorarka", "createdAt": "2020-01-23T10:18:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzMTE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzMTQ1Nw==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369931457", "bodyText": "I believe that pure explain (not analyze queries) shouldn't wait either.", "author": "dain", "createdAt": "2020-01-23T04:59:06Z", "path": "presto-main/src/main/java/io/prestosql/execution/SqlQueryExecution.java", "diffHunk": "@@ -599,6 +602,27 @@ private QueryInfo buildQueryInfo(SqlQueryScheduler scheduler)\n         return queryInfo;\n     }\n \n+    @Override\n+    public boolean shouldWaitForMinWorkers()\n+    {\n+        return shouldWaitForMinWorkers(analysis.getStatement());\n+    }\n+\n+    private boolean shouldWaitForMinWorkers(Statement statement)\n+    {\n+        if (statement instanceof Query) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk0MDc1OA==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369940758", "bodyText": "Also, DDL statements should not wait. We can classify these using QueryType via StatementUtils. Waiting can always be skipped for DATA_DEFINITION, DESCRIBE, EXPLAIN.", "author": "electrum", "createdAt": "2020-01-23T05:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzMTQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk0MTA1Mg==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369941052", "bodyText": "Actually, I don't think this is a problems, since SqlQueryExecution does not happen for DDL, and by the time we get here, EXPLAIN has already been rewritten (at least I think so ... double check this).", "author": "electrum", "createdAt": "2020-01-23T05:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzMTQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NzMwMQ==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369987301", "bodyText": "@electrum is right. There's also a test case testInsufficientWorkerNodesInternalSystemQuery which checks that we don't wait for EXPLAIN query.", "author": "raunaqmorarka", "createdAt": "2020-01-23T08:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzMTQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNDY4OQ==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369934689", "bodyText": "supplyAsync uses the ForkJoinPool.commonPool() which is not managed, so we do not use this method.   Instead, we have the tests create an executor, directly managed the executions, and shutdown the pool.", "author": "dain", "createdAt": "2020-01-23T05:12:05Z", "path": "presto-testing/src/main/java/io/prestosql/testing/DistributedQueryRunner.java", "diffHunk": "@@ -380,6 +410,11 @@ public MaterializedResult execute(Session session, @Language(\"SQL\") String sql)\n         }\n     }\n \n+    public CompletableFuture<ResultWithQueryId<MaterializedResult>> executeAsync(Session session, @Language(\"SQL\") String sql)\n+    {\n+        return supplyAsync(() -> executeWithQueryId(session, sql));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNTYwNQ==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369935605", "bodyText": "Also, we only use ComputableFuture in the SPI because it is built in the JVM and does not require a library dependency.  For main Presto we use Guava's ListenableFuture framework because it is easier to understand making our code more readable.  Please switch to that framework.", "author": "dain", "createdAt": "2020-01-23T05:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNDY4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAzNDAxOA==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370034018", "bodyText": "I've changed this to use ListenableFuture and a managed ExecutorService", "author": "raunaqmorarka", "createdAt": "2020-01-23T10:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNDY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNzM2Mw==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369937363", "bodyText": "Lets name these: required_workers_count and required_workers_max_wait_time", "author": "dain", "createdAt": "2020-01-23T05:24:25Z", "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -125,6 +125,8 @@\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_ROW_COUNT = \"dynamic_filtering_max_per_driver_row_count\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_SIZE = \"dynamic_filtering_max_per_driver_size\";\n     public static final String IGNORE_DOWNSTREAM_PREFERENCES = \"ignore_downstream_preferences\";\n+    public static final String REQUIRED_WORKERS = \"required_workers\";\n+    public static final String REQUIRED_WORKERS_MAX_WAIT = \"required_workers_max_wait\";", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MzEzNA==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r369983134", "bodyText": "I don't mind changing it, however this would make the session property names slightly inconsistent with the existing config property names query-manager.required-workers, query-manager.required-workers-max-wait. Would that be ok ?", "author": "raunaqmorarka", "createdAt": "2020-01-23T08:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNzM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI3ODYxNg==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370278616", "bodyText": "That's a good point, though I was thinking it's better to have them consistent with other session properties like hash_partition_count and query_max_execution_time, hence the _count and _time suffixes. Session properties are more \"user facing\" than config properties, so consistency is good.", "author": "electrum", "createdAt": "2020-01-23T18:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNzM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MDE5Nw==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370290197", "bodyText": "Please go with the names Dain posted.", "author": "electrum", "createdAt": "2020-01-23T18:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNzM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxMzExOQ==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370313119", "bodyText": "Done, changed to required_workers_count and required_workers_max_wait_time", "author": "raunaqmorarka", "createdAt": "2020-01-23T19:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkzNzM2Mw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzQ3Mg==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370807472", "bodyText": "There is a much simpler way to do the background work:\nListeningExecutorService queryExecutor = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(1));\n\nListenableFuture<ResultWithQueryId<MaterializedResult>> queryFuture1 = service.submit(() -> queryRunner.executeWithQueryId(session,  \"SELECT COUNT(*) from lineitem\"));\n\nWith that code, we no longer need the new executeAsync on DistributedQueryRunner.\nBTW. The Guava site has excellent documentation on ListenableFuture usage: https://github.com/google/guava/wiki/ListenableFutureExplained#creation", "author": "dain", "createdAt": "2020-01-24T19:36:02Z", "path": "presto-tests/src/test/java/io/prestosql/tests/TestMinWorkerRequirement.java", "diffHunk": "@@ -69,18 +107,136 @@ public void testInsufficientWorkerNodesAfterDrop()\n                         .build())\n                 .setNodeCount(4)\n                 .build()) {\n-            queryRunner.execute(\"SELECT 1\");\n+            queryRunner.execute(\"SELECT COUNT(*) from lineitem\");\n             assertEquals(queryRunner.getCoordinator().refreshNodes().getActiveNodes().size(), 4);\n \n             try {\n-                // Query should still be allowed to run if active workers drop down below the minimum required nodes\n+                // Query should not be allowed to run if active workers drop down below the minimum required nodes\n                 queryRunner.getServers().get(0).close();\n                 assertEquals(queryRunner.getCoordinator().refreshNodes().getActiveNodes().size(), 3);\n-                queryRunner.execute(\"SELECT 1\");\n+                queryRunner.execute(\"SELECT COUNT(*) from lineitem\");\n+                fail(\"Expected exception due to insufficient active worker nodes\");\n             }\n             catch (RuntimeException e) {\n                 assertEquals(e.getMessage(), \"Insufficient active worker nodes. Waited 1.00ns for at least 4 workers, but only 3 workers are active\");\n             }\n         }\n     }\n+\n+    @Test(expectedExceptions = RuntimeException.class, expectedExceptionsMessageRegExp = \"Insufficient active worker nodes. Waited 99.00ns for at least 3 workers, but only 2 workers are active\")\n+    public void testRequiredNodesMaxWaitSessionOverride()\n+            throws Exception\n+    {\n+        try (DistributedQueryRunner queryRunner = TpchQueryRunnerBuilder.builder()\n+                .setCoordinatorProperties(ImmutableMap.<String, String>builder()\n+                        .put(\"query-manager.required-workers\", \"3\")\n+                        .put(\"query-manager.required-workers-max-wait\", \"1ns\")\n+                        .build())\n+                .setNodeCount(2)\n+                .build()) {\n+            Session session = testSessionBuilder()\n+                    .setSystemProperty(REQUIRED_WORKERS_COUNT, \"3\")\n+                    .setSystemProperty(REQUIRED_WORKERS_MAX_WAIT_TIME, \"99ns\")\n+                    .setCatalog(\"tpch\")\n+                    .setSchema(\"tiny\")\n+                    .build();\n+            queryRunner.execute(session, \"SELECT COUNT(*) from lineitem\");\n+            fail(\"Expected exception due to insufficient active worker nodes\");\n+        }\n+    }\n+\n+    @Test\n+    public void testRequiredWorkerNodesSessionOverride()\n+            throws Exception\n+    {\n+        try (DistributedQueryRunner queryRunner = TpchQueryRunnerBuilder.builder()\n+                .setCoordinatorProperties(ImmutableMap.<String, String>builder()\n+                        .put(\"query-manager.required-workers\", \"5\")\n+                        .put(\"query-manager.required-workers-max-wait\", \"1ns\")\n+                        .build())\n+                .setNodeCount(4)\n+                .build()) {\n+            // Query should be allowed to run if session override allows it\n+            Session session = testSessionBuilder()\n+                    .setSystemProperty(REQUIRED_WORKERS_COUNT, \"4\")\n+                    .setCatalog(\"tpch\")\n+                    .setSchema(\"tiny\")\n+                    .build();\n+            queryRunner.execute(session, \"SELECT COUNT(*) from lineitem\");\n+\n+            // Query should not be allowed to run because we are 2 nodes short of requirement\n+            session = Session.builder(session)\n+                    .setSystemProperty(REQUIRED_WORKERS_COUNT, \"6\")\n+                    .build();\n+            try {\n+                queryRunner.execute(session, \"SELECT COUNT(*) from lineitem\");\n+                fail(\"Expected exception due to insufficient active worker nodes\");\n+            }\n+            catch (RuntimeException e) {\n+                assertEquals(e.getMessage(), \"Insufficient active worker nodes. Waited 1.00ns for at least 6 workers, but only 4 workers are active\");\n+            }\n+\n+            // After adding 2 nodes, query should run\n+            queryRunner.addServers(2);\n+            assertEquals(queryRunner.getCoordinator().refreshNodes().getActiveNodes().size(), 6);\n+            queryRunner.execute(session, \"SELECT COUNT(*) from lineitem\");\n+        }\n+    }\n+\n+    @Test\n+    public void testMultipleRequiredWorkerNodesSessionOverride()\n+            throws Exception\n+    {\n+        ExecutorService queryExecutor = newFixedThreadPool(3);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NTE3Mg==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370895172", "bodyText": "Thanks, I've now simplified this to use ListeningExecutorService and removed executeAsync from DistributedQueryRunner", "author": "raunaqmorarka", "createdAt": "2020-01-25T00:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwNzQ3Mg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NzcxMw==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r370897713", "bodyText": "@dain I noticed that minimumWorkerFuture is not cancelled if user cancels the query, ClusterSizeMonitor keeps reporting requirement of the cancelled query.\nWould it be correct to add below code here to handle that ?\nstateMachine.addStateChangeListener(state -> {\n    if (state.isDone()) {\n        minimumWorkerFuture.cancel(true);\n    }\n});", "author": "raunaqmorarka", "createdAt": "2020-01-25T00:40:27Z", "path": "presto-main/src/main/java/io/prestosql/dispatcher/LocalDispatchQuery.java", "diffHunk": "@@ -93,10 +95,18 @@ public void startWaitingForResources()\n \n     private void waitForMinimumWorkers()\n     {\n-        ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers();\n-        // when worker requirement is met, wait for query execution to finish construction and then start the execution\n-        addSuccessCallback(minimumWorkerFuture, () -> addSuccessCallback(queryExecutionFuture, this::startExecution));\n-        addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n+        // wait for query execution to finish construction\n+        addSuccessCallback(queryExecutionFuture, queryExecution -> {\n+            Session session = stateMachine.getSession();\n+            int executionMinCount = 1; // always wait for 1 node to be up\n+            if (queryExecution.shouldWaitForMinWorkers()) {\n+                executionMinCount = getRequiredWorkers(session);\n+            }\n+            ListenableFuture<?> minimumWorkerFuture = clusterSizeMonitor.waitForMinimumWorkers(executionMinCount, getRequiredWorkersMaxWait(session));\n+            // when worker requirement is met, start the execution\n+            addSuccessCallback(minimumWorkerFuture, () -> startExecution(queryExecution));\n+            addExceptionCallback(minimumWorkerFuture, throwable -> queryExecutor.execute(() -> stateMachine.transitionToFailed(throwable)));\n+        });", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExMzgzOA==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r371113838", "bodyText": "Yes.  The current PR would rely on the timeout, but since that is user settable, we should have a way to cleanup if the query fails for some reason.\nIt doesn't look like there is code to remove a canceled minWorkerFuture from the futures list.  Maybe add a listener before adding to the queue, here https://github.com/prestosql/presto/pull/2484/files#diff-e3ac2786dd162579f58ae9f8c7c644ccR108", "author": "dain", "createdAt": "2020-01-27T08:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NzcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyMzg2MA==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r371123860", "bodyText": "I think the code here https://github.com/prestosql/presto/pull/2484/files#diff-e3ac2786dd162579f58ae9f8c7c644ccR122 makes sure that minWorkerFuture is removed from futuresQueue in case it is cancelled.\nI've checked that it gets called on query cancellation once I add the listener on query state here.", "author": "raunaqmorarka", "createdAt": "2020-01-27T09:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NzcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEzNjIzOA==", "url": "https://github.com/trinodb/trino/pull/2484#discussion_r371136238", "bodyText": "Oh yes you are correct", "author": "dain", "createdAt": "2020-01-27T09:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NzcxMw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "da1cfa352f4d9fe45dfb0b8e647da61033f78080", "url": "https://github.com/trinodb/trino/commit/da1cfa352f4d9fe45dfb0b8e647da61033f78080", "message": "Allow overriding required workers and required workers max wait time through system session properties", "committedDate": "2020-01-27T09:10:24Z", "type": "commit"}, {"oid": "da1cfa352f4d9fe45dfb0b8e647da61033f78080", "url": "https://github.com/trinodb/trino/commit/da1cfa352f4d9fe45dfb0b8e647da61033f78080", "message": "Allow overriding required workers and required workers max wait time through system session properties", "committedDate": "2020-01-27T09:10:24Z", "type": "forcePushed"}]}