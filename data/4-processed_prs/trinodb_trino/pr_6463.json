{"pr_number": 6463, "pr_title": "Fix memory revoking accounting", "pr_createdAt": "2020-12-29T15:39:26Z", "pr_url": "https://github.com/trinodb/trino/pull/6463", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY4MDY2MA==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r553680660", "bodyText": "Why \"snapshot\" in the name? TaskState is an enum with no mutable or complex state, so the notion of a snapshot is awkward. I would just rename it to getTaskState.", "author": "martint", "createdAt": "2021-01-08T00:59:43Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -203,6 +203,16 @@ public SqlTaskIoStats getIoStats()\n         return taskHolderReference.get().getIoStats();\n     }\n \n+    public TaskState getTaskStateSnapshot()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE4NTYxOQ==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554185619", "bodyText": "Since other places in the code were so careful about the progression of task status I thought it might be merited, but if you don't think so I'll just rename.", "author": "pettyjamesm", "createdAt": "2021-01-08T20:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY4MDY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY4MTM5MA==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r553681390", "bodyText": "The renaming of this local variable seems unrelated to the main purpose of this commit. Pull it out into a separate commit.", "author": "martint", "createdAt": "2021-01-08T01:02:07Z", "path": "core/trino-main/src/main/java/io/trino/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -187,26 +189,29 @@ private void scheduleRevoking()\n     private synchronized void runMemoryRevoking()\n     {\n         if (checkPending.getAndSet(false)) {\n-            Collection<SqlTask> sqlTasks = null;\n+            Collection<SqlTask> allTasks = null;\n             for (MemoryPool memoryPool : memoryPools) {\n                 if (!memoryRevokingNeeded(memoryPool)) {\n                     continue;\n                 }\n \n-                if (sqlTasks == null) {\n-                    sqlTasks = requireNonNull(currentTasksSupplier.get());\n+                if (allTasks == null) {\n+                    allTasks = requireNonNull(currentTasksSupplier.get());\n                 }\n \n-                requestMemoryRevoking(memoryPool, sqlTasks);\n+                requestMemoryRevoking(memoryPool, allTasks);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE4NzQ0MA==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554187440", "bodyText": "I thought it helped clarify the transformation state now that we don't re-traverse the tasks at once. allTasks has not been filtered until findRunningTasksInMemoryPool does the filter and sorting at which point you wouldn't want to accidentally traverse allTasks instead of runningTasksInMemoryPool. Granted, I also changed the type signatures to make that harder to do by accident but it did feel related to the refactor.", "author": "pettyjamesm", "createdAt": "2021-01-08T20:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY4MTM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1Mjg4Mg==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554152882", "bodyText": "Rename this to getTaskContext. The fact that it returns an Optional is indication enough that it will return one if present.", "author": "martint", "createdAt": "2021-01-08T19:41:30Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -578,4 +578,13 @@ public QueryContext getQueryContext()\n     {\n         return queryContext;\n     }\n+\n+    public Optional<TaskContext> getTaskContextIfPresent()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE4NzUyMg==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554187522", "bodyText": "Sure, works for me", "author": "pettyjamesm", "createdAt": "2021-01-08T20:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1Mjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1Mzc5MA==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554153790", "bodyText": "Alternatively,\n        return Optional.ofNullable(taskExecution)\n                .map(SqlTaskExecution::getTaskContext);", "author": "martint", "createdAt": "2021-01-08T19:43:32Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -578,4 +578,13 @@ public QueryContext getQueryContext()\n     {\n         return queryContext;\n     }\n+\n+    public Optional<TaskContext> getTaskContextIfPresent()\n+    {\n+        SqlTaskExecution taskExecution = taskHolderReference.get().getTaskExecution();\n+        if (taskExecution == null) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(taskExecution.getTaskContext());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE5NTY0OQ==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554195649", "bodyText": "Could do and will do if you feel strongly. I'm a little uneasy with the contract that Optional#map uses in the presence of nulls so I typically avoid it when there are @Nullable annotations floating around in the vicinity. Also: micro-optimizations!", "author": "pettyjamesm", "createdAt": "2021-01-08T21:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1Mzc5MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE5NTA0Mw==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554195043", "bodyText": "Just curious, is a negative value legitimate, or are you really protecting against calls when the value is zero?", "author": "dain", "createdAt": "2021-01-08T21:16:15Z", "path": "core/trino-main/src/main/java/io/trino/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -187,26 +189,29 @@ private void scheduleRevoking()\n     private synchronized void runMemoryRevoking()\n     {\n         if (checkPending.getAndSet(false)) {\n-            Collection<SqlTask> sqlTasks = null;\n+            Collection<SqlTask> allTasks = null;\n             for (MemoryPool memoryPool : memoryPools) {\n                 if (!memoryRevokingNeeded(memoryPool)) {\n                     continue;\n                 }\n \n-                if (sqlTasks == null) {\n-                    sqlTasks = requireNonNull(currentTasksSupplier.get());\n+                if (allTasks == null) {\n+                    allTasks = requireNonNull(currentTasksSupplier.get());\n                 }\n \n-                requestMemoryRevoking(memoryPool, sqlTasks);\n+                requestMemoryRevoking(memoryPool, allTasks);\n             }\n         }\n     }\n \n-    private void requestMemoryRevoking(MemoryPool memoryPool, Collection<SqlTask> sqlTasks)\n+    private void requestMemoryRevoking(MemoryPool memoryPool, Collection<SqlTask> allTasks)\n     {\n         long remainingBytesToRevoke = (long) (-memoryPool.getFreeBytes() + (memoryPool.getMaxBytes() * (1.0 - memoryRevokingTarget)));\n-        remainingBytesToRevoke -= getMemoryAlreadyBeingRevoked(sqlTasks, memoryPool);\n-        requestRevoking(memoryPool, sqlTasks, remainingBytesToRevoke);\n+        List<SqlTask> runningTasksInPool = findRunningTasksInMemoryPool(allTasks, memoryPool);\n+        remainingBytesToRevoke -= getMemoryAlreadyBeingRevoked(runningTasksInPool, remainingBytesToRevoke);\n+        if (remainingBytesToRevoke > 0) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE5OTY2MQ==", "url": "https://github.com/trinodb/trino/pull/6463#discussion_r554199661", "bodyText": "I think it's legitimate and it wouldn't necessarily cause problems to pass a negative here, this is just an early return without traversing the task tree if no revoking is going to occur. How this might happen:\n\nmemory revoking is triggered and initiates a bunch of memory revoking\nmore memory is allocated triggering another attempted revoking pass\nthe memory in the process of still being revoked is larger than the delta between the current pool's memory and the revoking target", "author": "pettyjamesm", "createdAt": "2021-01-08T21:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE5NTA0Mw=="}], "type": "inlineReview"}, {"oid": "ded9bb20ee3370c3d41cf9b3338a33d1c9e92bc9", "url": "https://github.com/trinodb/trino/commit/ded9bb20ee3370c3d41cf9b3338a33d1c9e92bc9", "message": "Add SqlTask#getTaskState() and SqlTask#getTaskCreateTime()\n\nAvoids using comparatively more expensive methods like getTaskStats()\nor getTaskStatus() when only these specific fields are required and\nno particular synchronization order is being enforced.", "committedDate": "2021-01-08T21:28:56Z", "type": "commit"}, {"oid": "b7fd4b8834f7f35735ff99a285a7d05a9125231d", "url": "https://github.com/trinodb/trino/commit/b7fd4b8834f7f35735ff99a285a7d05a9125231d", "message": "Refactor MemoryRevokingScheduler to avoid redundant work\n\nAvoids repeatedly traversing the tasks collection to filter running\ntasks for the given memory pool and sorting them between summing the\nin progress revoking and initiating subsequent revoking actions on\noperators", "committedDate": "2021-01-08T21:28:56Z", "type": "commit"}, {"oid": "26cc959b89fcc2557aa0ef8a22e9699277cb0575", "url": "https://github.com/trinodb/trino/commit/26cc959b89fcc2557aa0ef8a22e9699277cb0575", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler would find running tasks and operate\non them by traversing through their QueryContext. This led to two\nsignificant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query through all other tasks in that query.\n- MemoryRevokingScheduler would repeatedly traverse the same tasks\n  and attempt to revoke memory from the same operators if the number\n  of tasks in a given query was > 1 on the current node", "committedDate": "2021-01-08T21:28:57Z", "type": "commit"}, {"oid": "26cc959b89fcc2557aa0ef8a22e9699277cb0575", "url": "https://github.com/trinodb/trino/commit/26cc959b89fcc2557aa0ef8a22e9699277cb0575", "message": "Fix MemoryRevokingScheduler from re-visiting tasks for the same query\n\nPreviously, MemoryRevokingScheduler would find running tasks and operate\non them by traversing through their QueryContext. This led to two\nsignificant problems:\n- MemoryRevokingScheduler would over-count the amount of memory that\n  was already being revoked since it would traverse each task for a\n  given query through all other tasks in that query.\n- MemoryRevokingScheduler would repeatedly traverse the same tasks\n  and attempt to revoke memory from the same operators if the number\n  of tasks in a given query was > 1 on the current node", "committedDate": "2021-01-08T21:28:57Z", "type": "forcePushed"}]}