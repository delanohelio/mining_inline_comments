{"pr_number": 5017, "pr_title": "Dynamic filtering for semi-joins: execution and testing", "pr_createdAt": "2020-08-29T20:26:36Z", "pr_url": "https://github.com/trinodb/trino/pull/5017", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4OTIwMg==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r479789202", "bodyText": "Since semi-join build side is not partitioned right now, I think it will be better to use higher limits on filter size here (maybe 4x).", "author": "raunaqmorarka", "createdAt": "2020-08-30T16:28:55Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2235,6 +2241,26 @@ public PhysicalOperation visitSemiJoin(SemiJoinNode node, LocalExecutionPlanCont\n             int probeChannel = probeSource.getLayout().get(node.getSourceJoinSymbol());\n             int buildChannel = buildSource.getLayout().get(node.getFilteringSourceJoinSymbol());\n \n+            ImmutableList.Builder<OperatorFactory> buildOperatorFactories = new ImmutableList.Builder<>();\n+            buildOperatorFactories.addAll(buildSource.getOperatorFactories());\n+\n+            node.getDynamicFilterId().ifPresent(filterId -> {\n+                // Add a DynamicFilterSourceOperatorFactory to build operator factories\n+                log.debug(\"[Semi-join] Dynamic filter: %s\", node.getDynamicFilterId().get());\n+                LocalDynamicFilterConsumer filterConsumer = new LocalDynamicFilterConsumer(\n+                        ImmutableMap.of(filterId, buildChannel),\n+                        ImmutableMap.of(filterId, buildSource.getTypes().get(buildChannel)),\n+                        1);\n+                addSuccessCallback(filterConsumer.getDynamicFilterDomains(), context::addDynamicFilter);\n+                buildOperatorFactories.add(new DynamicFilterSourceOperatorFactory(\n+                        buildContext.getNextOperatorId(),\n+                        node.getId(),\n+                        filterConsumer.getTupleDomainConsumer(),\n+                        ImmutableList.of(new DynamicFilterSourceOperator.Channel(filterId, buildSource.getTypes().get(buildChannel), buildChannel)),\n+                        getDynamicFilteringMaxPerDriverRowCount(context.getSession()),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODc1Mw==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r480098753", "bodyText": "Makes sense. This could be separate PR. Maybe we want to rethink per driver limits and use node global limit (which we could divide between drivers).", "author": "sopel39", "createdAt": "2020-08-31T12:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc4OTIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTc5MDEyMA==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r479790120", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            log.debug(\"[Semi-join] Dynamic filter: %s\", node.getDynamicFilterId().get());\n          \n          \n            \n                            log.debug(\"[Semi-join] Dynamic filter: %s\", filterId);", "author": "rzeyde-varada", "createdAt": "2020-08-30T16:38:17Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2235,6 +2241,26 @@ public PhysicalOperation visitSemiJoin(SemiJoinNode node, LocalExecutionPlanCont\n             int probeChannel = probeSource.getLayout().get(node.getSourceJoinSymbol());\n             int buildChannel = buildSource.getLayout().get(node.getFilteringSourceJoinSymbol());\n \n+            ImmutableList.Builder<OperatorFactory> buildOperatorFactories = new ImmutableList.Builder<>();\n+            buildOperatorFactories.addAll(buildSource.getOperatorFactories());\n+\n+            node.getDynamicFilterId().ifPresent(filterId -> {\n+                // Add a DynamicFilterSourceOperatorFactory to build operator factories\n+                log.debug(\"[Semi-join] Dynamic filter: %s\", node.getDynamicFilterId().get());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA2ODkyMQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r480068921", "bodyText": "just make LINEITEM_COUNT and others ints", "author": "sopel39", "createdAt": "2020-08-31T11:29:34Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -90,52 +97,34 @@ public void testSelect()\n     @Test\n     public void testJoinDynamicFilteringNone()\n     {\n-        Session session = Session.builder(getSession())\n-                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n-                .build();\n-        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n-        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n-                session,\n-                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\");\n-        assertEquals(result.getResult().getRowCount(), 0);\n-\n         // Probe-side is not scanned at all, due to dynamic filtering:\n-        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId());\n-        assertEquals(rowsRead, ImmutableSet.of(0L, ORDERS_COUNT));\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                0,\n+                ImmutableSet.of(0L, ORDERS_COUNT));\n     }\n \n     @Test\n     public void testJoinLargeBuildSideNoDynamicFiltering()\n     {\n-        Session session = Session.builder(getSession())\n-                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n-                .build();\n-        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n-        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n-                session,\n-                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey\");\n-        assertEquals(result.getResult().getRowCount(), LINEITEM_COUNT);\n-\n         // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n-        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId());\n-        assertEquals(rowsRead, ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                toIntExact(LINEITEM_COUNT),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5NzY3Mg==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r480097672", "bodyText": "please extract buildContext.getDriverInstanceCount().orElse(1) above as partitionCount", "author": "sopel39", "createdAt": "2020-08-31T12:30:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2235,6 +2241,26 @@ public PhysicalOperation visitSemiJoin(SemiJoinNode node, LocalExecutionPlanCont\n             int probeChannel = probeSource.getLayout().get(node.getSourceJoinSymbol());\n             int buildChannel = buildSource.getLayout().get(node.getFilteringSourceJoinSymbol());\n \n+            ImmutableList.Builder<OperatorFactory> buildOperatorFactories = new ImmutableList.Builder<>();\n+            buildOperatorFactories.addAll(buildSource.getOperatorFactories());\n+\n+            node.getDynamicFilterId().ifPresent(filterId -> {\n+                // Add a DynamicFilterSourceOperatorFactory to build operator factories\n+                log.debug(\"[Semi-join] Dynamic filter: %s\", node.getDynamicFilterId().get());\n+                LocalDynamicFilterConsumer filterConsumer = new LocalDynamicFilterConsumer(\n+                        ImmutableMap.of(filterId, buildChannel),\n+                        ImmutableMap.of(filterId, buildSource.getTypes().get(buildChannel)),\n+                        1);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5OTU1MQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r480099551", "bodyText": "please add a seperate test case for it", "author": "sopel39", "createdAt": "2020-08-31T12:34:39Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -95,40 +95,55 @@ public void testSelect()\n     }\n \n     @Test\n-    public void testJoinDynamicFilteringNone()\n+    public void testJoinAndSemiJoinDynamicFilteringNone()\n     {\n         // Probe-side is not scanned at all, due to dynamic filtering:\n         assertDynamicFiltering(\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n                 ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n                 0,\n                 ImmutableSet.of(0L, ORDERS_COUNT));\n+        assertDynamicFiltering(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5OTY0NA==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r480099644", "bodyText": "please add a separate test case", "author": "sopel39", "createdAt": "2020-08-31T12:34:51Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -95,40 +95,55 @@ public void testSelect()\n     }\n \n     @Test\n-    public void testJoinDynamicFilteringNone()\n+    public void testJoinAndSemiJoinDynamicFilteringNone()\n     {\n         // Probe-side is not scanned at all, due to dynamic filtering:\n         assertDynamicFiltering(\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n                 ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n                 0,\n                 ImmutableSet.of(0L, ORDERS_COUNT));\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                0,\n+                ImmutableSet.of(0L, ORDERS_COUNT));\n     }\n \n     @Test\n-    public void testJoinLargeBuildSideNoDynamicFiltering()\n+    public void testJoinAndSemiJoinLargeBuildSideNoDynamicFiltering()\n     {\n         // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n         assertDynamicFiltering(\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey\",\n                 ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n                 toIntExact(LINEITEM_COUNT),\n                 ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+        assertDynamicFiltering(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5OTc2OQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r480099769", "bodyText": "please add a separate test case", "author": "sopel39", "createdAt": "2020-08-31T12:35:03Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -95,40 +95,55 @@ public void testSelect()\n     }\n \n     @Test\n-    public void testJoinDynamicFilteringNone()\n+    public void testJoinAndSemiJoinDynamicFilteringNone()\n     {\n         // Probe-side is not scanned at all, due to dynamic filtering:\n         assertDynamicFiltering(\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n                 ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n                 0,\n                 ImmutableSet.of(0L, ORDERS_COUNT));\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                0,\n+                ImmutableSet.of(0L, ORDERS_COUNT));\n     }\n \n     @Test\n-    public void testJoinLargeBuildSideNoDynamicFiltering()\n+    public void testJoinAndSemiJoinLargeBuildSideNoDynamicFiltering()\n     {\n         // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n         assertDynamicFiltering(\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey\",\n                 ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n                 toIntExact(LINEITEM_COUNT),\n                 ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders)\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                toIntExact(LINEITEM_COUNT),\n+                ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n     }\n \n     @Test\n-    public void testPartitionedJoinNoDynamicFiltering()\n+    public void testPartitionedJoinAndSemiJoinNoDynamicFiltering()\n     {\n         // Probe-side is fully scanned, because local dynamic filtering does not work for partitioned joins:\n         assertDynamicFiltering(\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n                 ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()),\n                 0,\n                 ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+        assertDynamicFiltering(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5OTg3MQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r480099871", "bodyText": "ditto", "author": "sopel39", "createdAt": "2020-08-31T12:35:12Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -142,13 +157,23 @@ public void testJoinDynamicFilteringSingleValue()\n                 ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n                 6,\n                 ImmutableSet.of(6L, ORDERS_COUNT));\n+        assertDynamicFiltering(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5OTkwMQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r480099901", "bodyText": "ditto", "author": "sopel39", "createdAt": "2020-08-31T12:35:15Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -142,13 +157,23 @@ public void testJoinDynamicFilteringSingleValue()\n                 ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n                 6,\n                 ImmutableSet.of(6L, ORDERS_COUNT));\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.comment = 'nstructions sleep furiously among ')\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                6,\n+                ImmutableSet.of(6L, ORDERS_COUNT));\n \n         // Join lineitem with a single row of part\n         assertDynamicFiltering(\n                 \"SELECT l.comment FROM  lineitem l, part p WHERE p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n                 ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n                 39,\n                 ImmutableSet.of(39L, PART_COUNT));\n+        assertDynamicFiltering(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEwMDY0Ng==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r480100646", "bodyText": "please also add test cases to AbstractCoordinatorDynamicFilteringTest", "author": "sopel39", "createdAt": "2020-08-31T12:36:45Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -95,40 +95,55 @@ public void testSelect()\n     }\n \n     @Test\n-    public void testJoinDynamicFilteringNone()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcxNjE0Mw==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r482716143", "bodyText": "Thanks for the pointer; added. Also made some changes to DynamicFilterService to register semi-join dynamic filters. Rebased to master to fix a file conflict.", "author": "lxynov", "createdAt": "2020-09-03T05:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEwMDY0Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1NzAzMg==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r482757032", "bodyText": "Would be better to have Session session as parameter instead of Map<String, String> sessionProperties, then we can use withBroadcastJoin() or withPartitionedJoin() as input", "author": "raunaqmorarka", "createdAt": "2020-09-03T07:13:51Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -147,52 +136,112 @@ public void testJoinDynamicFilteringSingleValue()\n         assertQueryResult(\"SELECT partkey FROM part WHERE comment = 'onic deposits'\", 1552L);\n         assertQueryResult(\"SELECT COUNT() FROM lineitem WHERE partkey = 1552\", 39L);\n \n-        Session session = Session.builder(getSession())\n-                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n-                .build();\n-        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n-\n         // Join lineitem with a single row of orders\n-        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n-                session,\n-                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\");\n-        assertEquals(result.getResult().getRowCount(), 6);\n-        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), ImmutableSet.of(6L, ORDERS_COUNT));\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                6,\n+                ImmutableSet.of(6, ORDERS_COUNT));\n \n         // Join lineitem with a single row of part\n-        result = runner.executeWithQueryId(\n-                session,\n-                \"SELECT l.comment FROM  lineitem l, part p WHERE p.partkey = l.partkey AND p.comment = 'onic deposits'\");\n-        assertEquals(result.getResult().getRowCount(), 39);\n-        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), ImmutableSet.of(39L, PART_COUNT));\n+        assertDynamicFiltering(\n+                \"SELECT l.comment FROM  lineitem l, part p WHERE p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                39,\n+                ImmutableSet.of(39, PART_COUNT));\n     }\n \n     @Test\n     public void testJoinDynamicFilteringBlockProbeSide()\n     {\n-        Session session = Session.builder(getSession())\n-                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n-                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n-                .build();\n-        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n         // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n-        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n-                session,\n+        assertDynamicFiltering(\n                 \"SELECT l.comment\" +\n                         \" FROM  lineitem l, part p, orders o\" +\n                         \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n-                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\");\n-        assertEquals(result.getResult().getRowCount(), 1);\n-        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), ImmutableSet.of(1L, ORDERS_COUNT, PART_COUNT));\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name(), JOIN_REORDERING_STRATEGY, NONE.name()),\n+                1,\n+                ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                0,\n+                ImmutableSet.of(0, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testSemiJoinLargeBuildSideNoDynamicFiltering()\n+    {\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders)\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                toIntExact(LINEITEM_COUNT),\n+                ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testPartitionedSemiJoinNoDynamicFiltering()\n+    {\n+        // Probe-side is fully scanned, because local dynamic filtering does not work for partitioned joins:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()),\n+                0,\n+                ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringSingleValue()\n+    {\n+        assertQueryResult(\"SELECT orderkey FROM orders WHERE comment = 'nstructions sleep furiously among '\", 1L);\n+        assertQueryResult(\"SELECT COUNT() FROM lineitem WHERE orderkey = 1\", 6L);\n+\n+        assertQueryResult(\"SELECT partkey FROM part WHERE comment = 'onic deposits'\", 1552L);\n+        assertQueryResult(\"SELECT COUNT() FROM lineitem WHERE partkey = 1552\", 39L);\n+\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.comment = 'nstructions sleep furiously among ')\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                6,\n+                ImmutableSet.of(6, ORDERS_COUNT));\n+\n+        // Join lineitem with a single row of part\n+        assertDynamicFiltering(\n+                \"SELECT l.comment FROM lineitem l WHERE l.partkey IN (SELECT p.partkey FROM part p WHERE p.comment = 'onic deposits')\",\n+                ImmutableMap.of(JOIN_DISTRIBUTION_TYPE, BROADCAST.name()),\n+                39,\n+                ImmutableSet.of(39, PART_COUNT));\n+    }\n+\n+    private void assertDynamicFiltering(String selectQuery, Map<String, String> sessionProperties, int expectedRowCount, Set<Integer> expectedOperatorRowsRead)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwNjYyMQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r483306621", "bodyText": "Sounds good. Will update once @sopel39 makes more comments.", "author": "lxynov", "createdAt": "2020-09-03T23:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1NzAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NDQ0Nw==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r483494447", "bodyText": "please extract\n                    if (node instanceof JoinNode) {\n                        return ((JoinNode) node).getDynamicFilters().keySet().stream();\n                    }\n                    return ((SemiJoinNode) node).getDynamicFilterId().map(ImmutableSet::of).orElse(ImmutableSet.of()).stream();\n\nas a separate method", "author": "sopel39", "createdAt": "2020-09-04T09:14:22Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -323,19 +326,34 @@ void collectDynamicFilters()\n     private static Set<DynamicFilterId> getReplicatedDynamicFilters(PlanNode planNode)\n     {\n         return PlanNodeSearcher.searchFrom(planNode)\n-                .where(JoinNode.class::isInstance)\n-                .<JoinNode>findAll().stream()\n-                .filter(JoinUtils::isBuildSideReplicated)\n-                .flatMap(node -> node.getDynamicFilters().keySet().stream())\n+                .where(isInstanceOfAny(JoinNode.class, SemiJoinNode.class))\n+                .findAll().stream()\n+                .filter(node -> {\n+                    if (node instanceof JoinNode) {\n+                        return isBuildSideReplicated((JoinNode) node);\n+                    }\n+                    return isBuildSideReplicated((SemiJoinNode) node);\n+                })\n+                .flatMap(node -> {\n+                    if (node instanceof JoinNode) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ5NTAwMQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r483495001", "bodyText": "Please add isBuildSideReplicated(PlanNode node). Then we wouldn't need to do ifs in DynamicFilterService", "author": "sopel39", "createdAt": "2020-09-04T09:15:22Z", "path": "presto-main/src/main/java/io/prestosql/operator/JoinUtils.java", "diffHunk": "@@ -65,6 +67,16 @@ public static boolean isBuildSideReplicated(JoinNode joinNode)\n                 .matches();\n     }\n \n+    public static boolean isBuildSideReplicated(SemiJoinNode semiJoinNode)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "28ee57e0b6d86dace4825c1ce4cf3847654b474e", "url": "https://github.com/trinodb/trino/commit/28ee57e0b6d86dace4825c1ce4cf3847654b474e", "message": "Extract common function in TestMemorySmoke", "committedDate": "2020-09-08T16:53:40Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MzY0NQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r485583645", "bodyText": "you can use\n.filter(JoinUtils::isBuildSideReplicated)\n\nnow", "author": "sopel39", "createdAt": "2020-09-09T12:48:44Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -323,22 +326,43 @@ void collectDynamicFilters()\n     private static Set<DynamicFilterId> getReplicatedDynamicFilters(PlanNode planNode)\n     {\n         return PlanNodeSearcher.searchFrom(planNode)\n-                .where(JoinNode.class::isInstance)\n-                .<JoinNode>findAll().stream()\n-                .filter(JoinUtils::isBuildSideReplicated)\n-                .flatMap(node -> node.getDynamicFilters().keySet().stream())\n+                .where(isInstanceOfAny(JoinNode.class, SemiJoinNode.class))\n+                .findAll().stream()\n+                .filter(node -> {\n+                    if (node instanceof JoinNode) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc3NzYyMQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r485777621", "bodyText": "oh my bad..", "author": "lxynov", "createdAt": "2020-09-09T16:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4MzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NDMwOQ==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r485584309", "bodyText": "you can use:\n.flatMap(node -> getDynamicFiltersProducedInPlanNode(node).stream())\n\nhere", "author": "sopel39", "createdAt": "2020-09-09T12:49:42Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -323,22 +326,43 @@ void collectDynamicFilters()\n     private static Set<DynamicFilterId> getReplicatedDynamicFilters(PlanNode planNode)\n     {\n         return PlanNodeSearcher.searchFrom(planNode)\n-                .where(JoinNode.class::isInstance)\n-                .<JoinNode>findAll().stream()\n-                .filter(JoinUtils::isBuildSideReplicated)\n-                .flatMap(node -> node.getDynamicFilters().keySet().stream())\n+                .where(isInstanceOfAny(JoinNode.class, SemiJoinNode.class))\n+                .findAll().stream()\n+                .filter(node -> {\n+                    if (node instanceof JoinNode) {\n+                        return isBuildSideReplicated((JoinNode) node);\n+                    }\n+                    return isBuildSideReplicated((SemiJoinNode) node);\n+                })\n+                .flatMap(node -> {\n+                    if (node instanceof JoinNode) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NDY5Nw==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r485584697", "bodyText": "throw new IllegalStateException() here", "author": "sopel39", "createdAt": "2020-09-09T12:50:11Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -323,22 +326,43 @@ void collectDynamicFilters()\n     private static Set<DynamicFilterId> getReplicatedDynamicFilters(PlanNode planNode)\n     {\n         return PlanNodeSearcher.searchFrom(planNode)\n-                .where(JoinNode.class::isInstance)\n-                .<JoinNode>findAll().stream()\n-                .filter(JoinUtils::isBuildSideReplicated)\n-                .flatMap(node -> node.getDynamicFilters().keySet().stream())\n+                .where(isInstanceOfAny(JoinNode.class, SemiJoinNode.class))\n+                .findAll().stream()\n+                .filter(node -> {\n+                    if (node instanceof JoinNode) {\n+                        return isBuildSideReplicated((JoinNode) node);\n+                    }\n+                    return isBuildSideReplicated((SemiJoinNode) node);\n+                })\n+                .flatMap(node -> {\n+                    if (node instanceof JoinNode) {\n+                        return ((JoinNode) node).getDynamicFilters().keySet().stream();\n+                    }\n+                    return ((SemiJoinNode) node).getDynamicFilterId().map(ImmutableSet::of).orElse(ImmutableSet.of()).stream();\n+                })\n                 .collect(toImmutableSet());\n     }\n \n     private static Set<DynamicFilterId> getProducedDynamicFilters(PlanNode planNode)\n     {\n         return PlanNodeSearcher.searchFrom(planNode)\n-                .where(JoinNode.class::isInstance)\n-                .<JoinNode>findAll().stream()\n-                .flatMap(node -> node.getDynamicFilters().keySet().stream())\n+                .where(isInstanceOfAny(JoinNode.class, SemiJoinNode.class))\n+                .findAll().stream()\n+                .flatMap(node -> getDynamicFiltersProducedInPlanNode(node).stream())\n                 .collect(toImmutableSet());\n     }\n \n+    private static Set<DynamicFilterId> getDynamicFiltersProducedInPlanNode(PlanNode planNode)\n+    {\n+        if (planNode instanceof JoinNode) {\n+            return ((JoinNode) planNode).getDynamicFilters().keySet();\n+        }\n+        if (planNode instanceof SemiJoinNode) {\n+            return ((SemiJoinNode) planNode).getDynamicFilterId().map(ImmutableSet::of).orElse(ImmutableSet.of());\n+        }\n+        return ImmutableSet.of();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4Njc4Nw==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r485586787", "bodyText": "no need to check it twice, it's already checked as part of testJoinDynamicFilteringSingleValue", "author": "sopel39", "createdAt": "2020-09-09T12:53:17Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -162,6 +162,63 @@ public void testJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testSemiJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testSemiJoinLargeBuildSideNoDynamicFiltering()\n+    {\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders)\",\n+                withBroadcastJoin(),\n+                toIntExact(LINEITEM_COUNT),\n+                ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testPartitionedSemiJoinNoDynamicFiltering()\n+    {\n+        // Probe-side is fully scanned, because local dynamic filtering does not work for partitioned joins:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringSingleValue()\n+    {\n+        assertQueryResult(\"SELECT orderkey FROM orders WHERE comment = 'nstructions sleep furiously among '\", 1L);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4Nzg0Nw==", "url": "https://github.com/trinodb/trino/pull/5017#discussion_r485587847", "bodyText": "there is also testJoinDynamicFilteringBlockProbeSide. We should add testSemiJoinDynamicFilteringBlockProbeSide", "author": "sopel39", "createdAt": "2020-09-09T12:54:56Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -162,6 +162,63 @@ public void testJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testSemiJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testSemiJoinLargeBuildSideNoDynamicFiltering()\n+    {\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders)\",\n+                withBroadcastJoin(),\n+                toIntExact(LINEITEM_COUNT),\n+                ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testPartitionedSemiJoinNoDynamicFiltering()\n+    {\n+        // Probe-side is fully scanned, because local dynamic filtering does not work for partitioned joins:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringSingleValue()\n+    {\n+        assertQueryResult(\"SELECT orderkey FROM orders WHERE comment = 'nstructions sleep furiously among '\", 1L);\n+        assertQueryResult(\"SELECT COUNT() FROM lineitem WHERE orderkey = 1\", 6L);\n+\n+        assertQueryResult(\"SELECT partkey FROM part WHERE comment = 'onic deposits'\", 1552L);\n+        assertQueryResult(\"SELECT COUNT() FROM lineitem WHERE partkey = 1552\", 39L);\n+\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.comment = 'nstructions sleep furiously among ')\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, ORDERS_COUNT));\n+\n+        // Join lineitem with a single row of part\n+        assertDynamicFiltering(\n+                \"SELECT l.comment FROM lineitem l WHERE l.partkey IN (SELECT p.partkey FROM part p WHERE p.comment = 'onic deposits')\",\n+                withBroadcastJoin(),\n+                39,\n+                ImmutableSet.of(39, PART_COUNT));\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "376dc9f98cea8b6a99701f89e2ffd9d986b1c6fc", "url": "https://github.com/trinodb/trino/commit/376dc9f98cea8b6a99701f89e2ffd9d986b1c6fc", "message": "Implement dynamic filtering for semi-joins", "committedDate": "2020-09-09T17:30:47Z", "type": "commit"}, {"oid": "376dc9f98cea8b6a99701f89e2ffd9d986b1c6fc", "url": "https://github.com/trinodb/trino/commit/376dc9f98cea8b6a99701f89e2ffd9d986b1c6fc", "message": "Implement dynamic filtering for semi-joins", "committedDate": "2020-09-09T17:30:47Z", "type": "forcePushed"}]}