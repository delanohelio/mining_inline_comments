{"pr_number": 6017, "pr_title": "Do not collect mask for restricted columns", "pr_createdAt": "2020-11-19T13:46:26Z", "pr_url": "https://github.com/trinodb/trino/pull/6017", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc3MzM1NQ==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r529773355", "bodyText": "I don't like that this is deferring the analysis until planning time. One downside is that it can mess tracking of analysis timings, mask or hide certain issues (e.g, if the mask contains complex queries, analyzing it will require accessing metadata, resolving tables, etc)", "author": "martint", "createdAt": "2020-11-24T18:00:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1284,7 +1284,12 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     List<ViewExpression> masks = accessControl.getColumnMasks(session.toSecurityContext(), name, field.getName().get(), field.getType());\n                     columnMasks.put(field, masks);\n \n-                    masks.forEach(mask -> analyzeColumnMask(session.getIdentity().getUser(), table, name, field, accessControlScope, mask));\n+                    masks.forEach(mask -> analysis.addColumnMask(\n+                            table,\n+                            field.getName().get(),\n+                            new ColumnMask(\n+                                    () -> analyzeColumnMask(session.getIdentity().getUser(), table, name, field, accessControlScope, mask),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1NzIwNg==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r531457206", "bodyText": "Why is it forbidden to insert or delete from table with a mask?", "author": "skrzypo987", "createdAt": "2020-11-27T08:46:23Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestColumnMask.java", "diffHunk": "@@ -492,4 +494,44 @@ public void testJoin()\n \n         assertThat(assertions.query(\"SELECT count(*) FROM orders JOIN orders USING (orderkey)\")).matches(\"VALUES BIGINT '15000'\");\n     }\n+\n+    @Test\n+    public void testColumnMaskingUsingRestrictedColumn()\n+    {\n+        accessControl.reset();\n+        accessControl.deny(privilege(\"orders.custkey\", SELECT_COLUMN));\n+        accessControl.columnMask(\n+                new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                \"orderkey\",\n+                USER,\n+                new ViewExpression(USER, Optional.empty(), Optional.empty(), \"custkey\"));\n+        assertThatThrownBy(() -> assertions.query(\"SELECT orderkey FROM orders\"))\n+                .hasMessageMatching(\"\\\\QAccess Denied: Cannot select from columns [orderkey, custkey] in table or view local.tiny.orders\");\n+    }\n+\n+    @Test\n+    public void testInsertWithColumnMasking()\n+    {\n+        accessControl.reset();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDE3NDk2MQ==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534174961", "bodyText": "Because to INSERT row you would need to unmask the value :)\nAnything that has row filters or column masks is a bit similar to views, and you cannot simply insert or delete from view. See: #6154 (comment)", "author": "kokosing", "createdAt": "2020-12-02T13:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1NzIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1ODg4NQ==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r531458885", "bodyText": "You can replace those two lines with:\n`flatMap(field -> field.getName().stream())", "author": "skrzypo987", "createdAt": "2020-11-27T08:49:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,27 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .filter(field -> field.getName().isPresent())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMzODQwNA==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534338404", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (field.getName().isEmpty()) {\n          \n          \n            \n                                continue;\n          \n          \n            \n                            }\n          \n          \n            \n                            // do not collect mask for not accessible columns to prevent unnecessary semantic analysis\n          \n          \n            \n                            if (!visibleColumns.contains(field.getName().orElseThrow())) {\n          \n          \n            \n                                continue;\n          \n          \n            \n                            }\n          \n          \n            \n                            if (field.getName().isPresent() && visibleColumns.contains(field.getName().orElseThrow())) {", "author": "martint", "createdAt": "2020-12-02T17:12:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,26 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .flatMap(field -> field.getName().stream())\n+                    .collect(toImmutableSet());\n+\n+            Set<String> visibleColumns = accessControl.filterColumns(session.toSecurityContext(), name.asCatalogSchemaTableName(), allColumns);\n+\n             ImmutableMap.Builder<Field, List<ViewExpression>> columnMasks = ImmutableMap.builder();\n             for (Field field : fields) {\n-                if (field.getName().isPresent()) {\n-                    List<ViewExpression> masks = accessControl.getColumnMasks(session.toSecurityContext(), name, field.getName().get(), field.getType());\n-                    columnMasks.put(field, masks);\n-\n-                    masks.forEach(mask -> analyzeColumnMask(session.getIdentity().getUser(), table, name, field, accessControlScope, mask));\n+                if (field.getName().isEmpty()) {\n+                    continue;\n+                }\n+                // do not collect mask for not accessible columns to prevent unnecessary semantic analysis\n+                if (!visibleColumns.contains(field.getName().orElseThrow())) {\n+                    continue;\n                 }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534340450", "bodyText": "This assumes that filterColumns agrees with the \"has select permissions\" on those columns. I'm not sure that's guaranteed to be always true. In the worst case (if filterColumns is more restrictive), we might miss adding a mask over a field that has one.", "author": "martint", "createdAt": "2020-12-02T17:15:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1278,14 +1278,26 @@ private void analyzeFiltersAndMasks(Table table, QualifiedObjectName name, Optio\n                     .withRelationType(RelationId.anonymous(), new RelationType(fields))\n                     .build();\n \n+            Set<String> allColumns = fields.stream()\n+                    .flatMap(field -> field.getName().stream())\n+                    .collect(toImmutableSet());\n+\n+            Set<String> visibleColumns = accessControl.filterColumns(session.toSecurityContext(), name.asCatalogSchemaTableName(), allColumns);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODAwOA==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534378008", "bodyText": "Identity can see the column if they has any privilege to that column. Typically select. But it could be insert too. So we don't collect masks only if identity is not allowed to see a columns, when they has no access to column.", "author": "kokosing", "createdAt": "2020-12-02T18:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQxODY0Ng==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534418646", "bodyText": "The case you are describing might cause that DESCRIBE x could return less columns than SELECT * FROM x, which does not make sense to me.", "author": "kokosing", "createdAt": "2020-12-02T19:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2NTg4Nw==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r534465887", "bodyText": "There's nothing preventing that from happening, though. I think that's a deficiency in the access control APIs -- there should be a single method to get/check for permissions for columns.", "author": "martint", "createdAt": "2020-12-02T20:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAwNTg0OA==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r535005848", "bodyText": "That is correct, the custom SPI implementation is out of our control. However we do require certain contract in many SPI parts. To me it is one place like that. The only problem here is that we don't have generic tests for access controls, where one could verify contract implementation. Such tests are impossible to write at the moment because, we can't simply \"insert\" authorization rules.\nWhat do you suggest then? Previously I had called checkCanSelectFromColumns with one column at a time in a loop, but this was so ugly...", "author": "kokosing", "createdAt": "2020-12-03T09:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAxNTc3NA==", "url": "https://github.com/trinodb/trino/pull/6017#discussion_r541015774", "bodyText": "I think it\u2019s better to rely on chrckCanSelect. Someone may choose to use filterColumns as a way to obfuscate the available columns without preventing access to them, and the result would be a security bypass if there are column masks involved.", "author": "martint", "createdAt": "2020-12-11T15:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM0MDQ1MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "c7c0a81b531073bc924e17d54e121d13ffbfb86e", "url": "https://github.com/trinodb/trino/commit/c7c0a81b531073bc924e17d54e121d13ffbfb86e", "message": "Throw AccessDeniedException when access is denied", "committedDate": "2020-12-15T09:43:45Z", "type": "commit"}, {"oid": "eecb8dcd81b8251b09c03588e253b0f49de3ba24", "url": "https://github.com/trinodb/trino/commit/eecb8dcd81b8251b09c03588e253b0f49de3ba24", "message": "Test access control for DESCRIBE", "committedDate": "2020-12-15T09:43:46Z", "type": "commit"}, {"oid": "31abfc071cea84a6c67eedc075b25631e677ba46", "url": "https://github.com/trinodb/trino/commit/31abfc071cea84a6c67eedc075b25631e677ba46", "message": "Make ViewAccessControl to extend ForwardingAccessControl\n\nThat way instead of denying access that could lead unexpected behaviour,\nit will fail loudly indicating the bug in the code.", "committedDate": "2020-12-15T09:43:47Z", "type": "commit"}, {"oid": "39975389bf7d8ef369ac26fbf436ce5415772550", "url": "https://github.com/trinodb/trino/commit/39975389bf7d8ef369ac26fbf436ce5415772550", "message": "Add more tests to TestColumnMask\n\nTest that:\n - that restricted column cannot be used in mask\n - column masks cannot be used with INSERT or DELETE", "committedDate": "2020-12-15T09:43:49Z", "type": "commit"}, {"oid": "2772e59f91907e48ada021eabcc13dded8c12ee9", "url": "https://github.com/trinodb/trino/commit/2772e59f91907e48ada021eabcc13dded8c12ee9", "message": "Do not collect mask for restricted columns", "committedDate": "2020-12-15T09:43:50Z", "type": "commit"}, {"oid": "2772e59f91907e48ada021eabcc13dded8c12ee9", "url": "https://github.com/trinodb/trino/commit/2772e59f91907e48ada021eabcc13dded8c12ee9", "message": "Do not collect mask for restricted columns", "committedDate": "2020-12-15T09:43:50Z", "type": "forcePushed"}]}