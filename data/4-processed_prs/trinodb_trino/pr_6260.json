{"pr_number": 6260, "pr_title": "More contention reductions", "pr_createdAt": "2020-12-08T19:18:15Z", "pr_url": "https://github.com/trinodb/trino/pull/6260", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1ODg5OQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540858899", "bodyText": "future for partitionFunction is already cached", "author": "sopel39", "createdAt": "2020-12-11T10:49:33Z", "path": "presto-main/src/main/java/io/prestosql/operator/PartitionedOutputOperator.java", "diffHunk": "@@ -261,8 +262,13 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        ListenableFuture<?> blocked = partitionFunction.isFull();\n-        return blocked.isDone() ? NOT_BLOCKED : blocked;\n+        if (isBlocked.isDone()) {\n+            isBlocked = partitionFunction.isFull();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkyMTQ0Mw==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540921443", "bodyText": "If you mean the cached future in OutputBufferMemoryManager then you're technically correct, except that retrieving that instance is through OutputBufferMemoryManager#getBufferBlockedFuture() which needs to synchronize on the lock on each access.\nThis is especially painful since each thread working through the same task's driver loop necessarily shares the output buffer instance and will each call 3 different methods in rapid succession that all check whether the operator is currently blocked (isBlocked(), needsInput(), isFinished()). This is on top of:\n\nHTTP threads decrementing memory when acknowledging pages\nother worker threads incrementing memory after enqueuing pages\nMemory tracker future callbacks\nConstant checks against OutputBufferMemoryManager#isOverutilized()\nThe fact that this call into the system memory context is in effect entering a single global lock tree for every memory tracker update. The same root lock that will be contended on as part of any memory update from any and all other queries / tasks / pipelines / drivers / operators (and of course other output buffers). As a result, the thread holding this output buffer lock can and does often block while holding it because of a failure to acquire the full chain of parent memory tracking object locks which prevents other threads from calling any synchronized method for the duration, including OutputBufferMemoryManager#getBufferBlockedFuture().\n\nThis change somewhat reduces the pain of all of that by caching the future in the operator itself when blocked so that subsequent checks don't re-enter the same massive bottleneck, but offers no improvement when not blocked. I'm in the process of putting together a proprosal to address the memory tracking and output buffer issues now.", "author": "pettyjamesm", "createdAt": "2020-12-11T12:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk2ODQ0MQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540968441", "bodyText": "Please add a comment in code before if (isBlocked.isDone()) {", "author": "sopel39", "createdAt": "2020-12-11T14:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1ODg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAxMDg3NA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r541010874", "bodyText": "Added", "author": "pettyjamesm", "createdAt": "2020-12-11T15:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1ODg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1OTEzMg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540859132", "bodyText": "future of output buffer is already cached", "author": "sopel39", "createdAt": "2020-12-11T10:49:56Z", "path": "presto-main/src/main/java/io/prestosql/operator/TaskOutputOperator.java", "diffHunk": "@@ -122,8 +123,13 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        ListenableFuture<?> blocked = outputBuffer.isFull();\n-        return blocked.isDone() ? NOT_BLOCKED : blocked;\n+        if (isBlocked.isDone()) {\n+            isBlocked = outputBuffer.isFull();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkzNDE0MQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540934141", "bodyText": "Same justification as my reply about PartitionedOutputOperator", "author": "pettyjamesm", "createdAt": "2020-12-11T13:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1OTEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1OTcwOQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540859709", "bodyText": "future of sink is already cached", "author": "sopel39", "createdAt": "2020-12-11T10:50:56Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSinkOperator.java", "diffHunk": "@@ -128,7 +129,13 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        return sink.waitForWriting();\n+        if (isBlocked.isDone()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkzNjIyNQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540936225", "bodyText": "Slightly different context, but essentially is the same justification as my reply for PartitionedOutputOperator, except with LocalExchangeMemoryManager instead of OutputBufferMemoryManager. Admittedly, the problem is not nearly as bad there because it doesn't call into the memory tracking system but synchronizing on each access is still unnecessary.", "author": "pettyjamesm", "createdAt": "2020-12-11T13:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1OTcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MDAyMA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540860020", "bodyText": "future of source is already cached", "author": "sopel39", "createdAt": "2020-12-11T10:51:29Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSourceOperator.java", "diffHunk": "@@ -103,7 +104,13 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        return source.waitForReading();\n+        if (isBlocked.isDone()) {\n+            isBlocked = source.waitForReading();\n+            if (isBlocked.isDone()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkzNzIzOA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540937238", "bodyText": "Similar justification here as for LocalExchangeSinkOperator.", "author": "pettyjamesm", "createdAt": "2020-12-11T13:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MDAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MTI1Ng==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r540861256", "bodyText": "Change commit name Cache ExchangeClient#isBlocked future. Add explanation why io.prestosql.operator.ExchangeClient#isBlocked creates a new future every time (because they can be cancelled in io.prestosql.server.protocol.Query#waitForResults)", "author": "sopel39", "createdAt": "2020-12-11T10:53:26Z", "path": "presto-main/src/main/java/io/prestosql/operator/ExchangeOperator.java", "diffHunk": "@@ -92,6 +92,7 @@ public void noMoreOperators()\n     private final PlanNodeId sourceId;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMxNDkwOA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544314908", "bodyText": "nit: double space after //", "author": "sopel39", "createdAt": "2020-12-16T13:53:21Z", "path": "presto-main/src/main/java/io/prestosql/operator/ExchangeOperator.java", "diffHunk": "@@ -152,11 +153,14 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        ListenableFuture<?> blocked = exchangeClient.isBlocked();\n-        if (blocked.isDone()) {\n-            return NOT_BLOCKED;\n+        //  Avoid registering a new callback in the ExchangeClient when one is already pending", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyODExOA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544328118", "bodyText": "I don't think this buys anything. I would continue to use buffers.size()", "author": "sopel39", "createdAt": "2020-12-16T14:11:08Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/BroadcastExchanger.java", "diffHunk": "@@ -27,19 +28,23 @@\n {\n     private final List<Consumer<PageReference>> buffers;\n     private final LocalExchangeMemoryManager memoryManager;\n+    private final LongConsumer onPageReleased;\n+    private final int bufferCount;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyODg5Mw==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544328893", "bodyText": "Changing from Runnable to LongConsumer doesn't improve anything. Undo. Alternatively make it Consumer<Page> as it's more explicit than generic long.", "author": "sopel39", "createdAt": "2020-12-16T14:12:09Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -17,24 +17,28 @@\n \n import javax.annotation.concurrent.ThreadSafe;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.function.LongConsumer;\n \n+import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n-class PageReference\n+final class PageReference\n {\n+    private static final AtomicIntegerFieldUpdater<PageReference> REFERENCE_COUNT_UPDATER = AtomicIntegerFieldUpdater.newUpdater(PageReference.class, \"referenceCount\");\n+\n     private final Page page;\n-    private final Runnable onFree;\n-    private final AtomicInteger referenceCount;\n+    private final LongConsumer onPageReleased;\n+    private volatile int referenceCount;\n \n-    public PageReference(Page page, int referenceCount, Runnable onFree)\n+    public PageReference(Page page, int referenceCount, LongConsumer onPageReleased)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3NTA0OA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544475048", "bodyText": "Runnable requires that each PageReference instance is initialized with a lambda that captures state from the creating context in order to perform cleanup. a single LongConsumer can be created per exchange sink and used for all created instances.\nConsumer<Page> might be ok, but also opens the door to accidental ambiguity like whether Page#getRetainedSizeInBytes() or Page#getSizeInBytes() should be used as the decrement.", "author": "pettyjamesm", "createdAt": "2020-12-16T17:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyODg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MDc0Mg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547240742", "bodyText": "Runnable requires that each PageReference instance is initialized with a lambda that captures state from the creating context in order to perform cleanup. a single LongConsumer can be created per exchange sink and used for all created instances.\n\nYou could make it Consumer<PageReference>\nThen lambda can be:\nreference -> doSomething(reference.getRetainedSizeInBytes()\n\nIt's cleaner and more explicit than generic long.", "author": "sopel39", "createdAt": "2020-12-22T12:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyODg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyOTc3NA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544329774", "bodyText": "unrelated change. Extract to separate commit", "author": "sopel39", "createdAt": "2020-12-16T14:13:20Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -17,24 +17,28 @@\n \n import javax.annotation.concurrent.ThreadSafe;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.function.LongConsumer;\n \n+import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n-class PageReference\n+final class PageReference", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3Nzk5OA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544477998", "bodyText": "It's material to the change to using AtomicIntegerFieldUpdater which will not work as expected with subclasses.", "author": "pettyjamesm", "createdAt": "2020-12-16T17:17:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMyOTc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMDA0MQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544330041", "bodyText": "extract to separate commit", "author": "sopel39", "createdAt": "2020-12-16T14:13:44Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -44,11 +48,26 @@ public long getRetainedSizeInBytes()\n \n     public Page removePage()\n     {\n-        int referenceCount = this.referenceCount.decrementAndGet();\n+        int referenceCount = REFERENCE_COUNT_UPDATER.decrementAndGet(this);\n         checkArgument(referenceCount >= 0, \"Page reference count is negative\");\n         if (referenceCount == 0) {\n-            onFree.run();\n+            onPageReleased.accept(page.getRetainedSizeInBytes());\n         }\n         return page;\n     }\n+\n+    @Override", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3OTY1Ng==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544479656", "bodyText": "This was a bit of a hack, without adding this toString() implementation the referenceCount field is detected as unused and fails the build.", "author": "pettyjamesm", "createdAt": "2020-12-16T17:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MTI5NA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547241294", "bodyText": "You could add toString without referenceCount in previous commit and then add referenceCount to toString in this commit", "author": "sopel39", "createdAt": "2020-12-22T12:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMDA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMTI4Mg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544331282", "bodyText": "this is binding PageReference code with LocalExchangeMemoryManager unnecessarily.", "author": "sopel39", "createdAt": "2020-12-16T14:15:21Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -44,11 +48,26 @@ public long getRetainedSizeInBytes()\n \n     public Page removePage()\n     {\n-        int referenceCount = this.referenceCount.decrementAndGet();\n+        int referenceCount = REFERENCE_COUNT_UPDATER.decrementAndGet(this);\n         checkArgument(referenceCount >= 0, \"Page reference count is negative\");\n         if (referenceCount == 0) {\n-            onFree.run();\n+            onPageReleased.accept(page.getRetainedSizeInBytes());\n         }\n         return page;\n     }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)\n+                .add(\"size\", getRetainedSizeInBytes())\n+                .add(\"referenceCount\", referenceCount)\n+                .toString();\n+    }\n+\n+    public static LongConsumer releaseListenerForExchangeMemoryManager(LocalExchangeMemoryManager memoryManager)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ4NDk5OA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544484998", "bodyText": "This avoids accidentally creating a megamorphic call site inside of removePage(). Currently, there are only two implementations used- this one and the anonymous one created by PassthroughExchanger. If each exchanger created their own lambda it would be megamorphic.", "author": "pettyjamesm", "createdAt": "2020-12-16T17:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMTI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwMzQ5Mw==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547103493", "bodyText": "This is certainly an interesting idea, but does this actually make a difference? Presto is pretty much built around pushing megamorphic call sites to page-sized granularities. If this needs to be specialized like this, we probably have much bigger issues throughout the entire engine.", "author": "erichwang", "createdAt": "2020-12-22T07:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMTI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MzU5NQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547243595", "bodyText": "I agree with @erichwang . We should not obscure readability for negligible perf improvements", "author": "sopel39", "createdAt": "2020-12-22T12:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMTI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMjAwMg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544332002", "bodyText": "I don't think AtomicInteger is a problem. Page granularity is not such a big deal. If there was AtomicInteger per row that would be a problem", "author": "sopel39", "createdAt": "2020-12-16T14:16:11Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/PageReference.java", "diffHunk": "@@ -17,24 +17,28 @@\n \n import javax.annotation.concurrent.ThreadSafe;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.function.LongConsumer;\n \n+import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n-class PageReference\n+final class PageReference\n {\n+    private static final AtomicIntegerFieldUpdater<PageReference> REFERENCE_COUNT_UPDATER = AtomicIntegerFieldUpdater.newUpdater(PageReference.class, \"referenceCount\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ3OTE2OA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544479168", "bodyText": "It's still an extra allocation (with object headers and alignment overhead) and extra pointer indirection at usage time. The improvement is minor but enough of these are created through local exchanges that embedding the counter is worthwhile.", "author": "pettyjamesm", "createdAt": "2020-12-16T17:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMjAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MDM5Mg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544340392", "bodyText": "nit: extra space after //", "author": "sopel39", "createdAt": "2020-12-16T14:26:54Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +49,37 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                //  if we have no callback waiting, return early", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MTA1OQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544341059", "bodyText": "use notFullFuture.isDone()", "author": "sopel39", "createdAt": "2020-12-16T14:27:42Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +49,37 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                //  if we have no callback waiting, return early\n+                if (notFullFuture == NOT_FULL) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ4NzgyMg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544487822", "bodyText": "NOT_FULL is the sentinel value for \"no listeners\". Any other value is a future that might not be done, but that check can occur outside of the synchronized block and without stalling to do a volatile read against that future's isDone() state. Redudant set(null) calls are benign but this implementation preserves the ability to alias check the NOT_FULL sentinel to detect listener registration.", "author": "pettyjamesm", "createdAt": "2020-12-16T17:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MTA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU2NDg4NQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544564885", "bodyText": "Replaced with null check instead.", "author": "pettyjamesm", "createdAt": "2020-12-16T19:28:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MTA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MjI3Mw==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544342273", "bodyText": "recheck if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone())", "author": "sopel39", "createdAt": "2020-12-16T14:29:17Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +49,37 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                //  if we have no callback waiting, return early\n+                if (notFullFuture == NOT_FULL) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ4Mjk5Nw==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544482997", "bodyText": "It's necessary to not re-check inside of the synchronized block in order to preserve existing semantics. Re-checks can race with concurrent modifications whereas previously all modifications were serialized through the object monitor. The effect was that previously the transition edge from above-full to below full always unblocked any waiters, and not doing so here (even if we've transitioned back up above the full boundary in the mean time) is a departure from that behavior.", "author": "pettyjamesm", "createdAt": "2020-12-16T17:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MjI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODE3MQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544348171", "bodyText": "simplify:\n// optionally\nif (bufferedBytes.get() <= maxBufferedBytes) {\n  return NOT_BLOCKED;\n}\nif (notFullFuture.isDone()) {\n  notFullFuture = SettableFuture.create();\n}", "author": "sopel39", "createdAt": "2020-12-16T14:37:00Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +49,37 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                //  if we have no callback waiting, return early\n+                if (notFullFuture == NOT_FULL) {\n+                    return;\n+                }\n+                future = notFullFuture;\n+                notFullFuture = NOT_FULL;\n             }\n-\n-            // otherwise, we are not full, so complete the future\n-            future = notFullFuture;\n-            notFullFuture = NOT_FULL;\n+            // complete future outside of lock since this can invoke callbacks\n+            future.set(null);\n         }\n-\n-        // complete future outside of lock since this can invoke callbacks\n-        future.set(null);\n     }\n \n-    public synchronized ListenableFuture<?> getNotFullFuture()\n+    public ListenableFuture<?> getNotFullFuture()\n     {\n-        // if we are full and the current not full future is already complete, create a new one\n-        if (bufferedBytes.get() > maxBufferedBytes && notFullFuture.isDone()) {\n-            notFullFuture = SettableFuture.create();\n+        if (bufferedBytes.get() <= maxBufferedBytes) {\n+            return NOT_BLOCKED;\n+        }\n+        SettableFuture<?> future;\n+        synchronized (this) {\n+            // if we are full and the current not full future is already complete, create a new one\n+            if ((notFullFuture == NOT_FULL || notFullFuture.isDone()) && bufferedBytes.get() > maxBufferedBytes) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ5NjUzNA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544496534", "bodyText": "Simplified, also realized that the notFullFuture.isDone() check is not correct as it can race with the callback. Updated to now only use the  notFullFuture == NOT_DONE alias check for callback registration.", "author": "pettyjamesm", "createdAt": "2020-12-16T17:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU2NTgzNg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544565836", "bodyText": "Updated again to use a null sentinel and this becomes a null check.", "author": "pettyjamesm", "createdAt": "2020-12-16T19:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0ODE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM1NjY4NA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544356684", "bodyText": "let's remove this. This makes he code unnecessarily complicated.", "author": "sopel39", "createdAt": "2020-12-16T14:47:18Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -22,10 +22,12 @@\n import java.util.concurrent.atomic.AtomicLong;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n \n @ThreadSafe\n public class LocalExchangeMemoryManager\n {\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);\n     private static final SettableFuture<?> NOT_FULL;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDUxMDUwMg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r544510502", "bodyText": "After migrating all checks against the NOT_FULL sentinel, it became clear that null would be a more clear fit. I've changed it to avoid having NOT_FULL and using null to represent no callback registered instead.", "author": "pettyjamesm", "createdAt": "2020-12-16T18:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM1NjY4NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MzkzNg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547093936", "bodyText": "The question I have here is why the ExchangeClient is in fact returning a different Future for each call to isBlocked()? The whole point of ListenableFutures is that a single instance is capable of delegating completion to multiple listeners already without creating a new instance each time. That might be something we should also fix in ExchangeClient.", "author": "erichwang", "createdAt": "2020-12-22T06:32:04Z", "path": "presto-main/src/main/java/io/prestosql/operator/ExchangeOperator.java", "diffHunk": "@@ -152,11 +153,14 @@ public boolean isFinished()\n     @Override\n     public ListenableFuture<?> isBlocked()\n     {\n-        ListenableFuture<?> blocked = exchangeClient.isBlocked();\n-        if (blocked.isDone()) {\n-            return NOT_BLOCKED;\n+        //  Avoid registering a new callback in the ExchangeClient when one is already pending", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzNTUyNg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547235526", "bodyText": "isBlocked can be called from io.prestosql.server.protocol.Query#getFutureStateChange, which is called from io.prestosql.server.protocol.Query#waitForResults with future timeout. This means that returned future can be cancelled and we need to protect against that.\nSimilar concept is done in io.prestosql.execution.FutureStateChange which is used by long pooling from REST resources.", "author": "sopel39", "createdAt": "2020-12-22T11:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MzkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwODQxMA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547108410", "bodyText": "the default constructor value for AtomicBoolean is already false.", "author": "erichwang", "createdAt": "2020-12-22T07:16:31Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -19,41 +19,37 @@\n import io.prestosql.operator.WorkProcessor.ProcessState;\n import io.prestosql.spi.Page;\n \n+import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Consumer;\n \n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n public class LocalExchangeSource\n {\n-    private static final SettableFuture<?> NOT_EMPTY;\n-\n-    static {\n-        NOT_EMPTY = SettableFuture.create();\n-        NOT_EMPTY.set(null);\n-    }\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);\n \n     private final Consumer<LocalExchangeSource> onFinish;\n \n-    private final BlockingQueue<PageReference> buffer = new LinkedBlockingDeque<>();\n+    private final LinkedBlockingDeque<PageReference> buffer = new LinkedBlockingDeque<>();\n     private final AtomicLong bufferedBytes = new AtomicLong();\n \n-    private final Object lock = new Object();\n-\n-    @GuardedBy(\"lock\")\n-    private SettableFuture<?> notEmptyFuture = NOT_EMPTY;\n+    @Nullable\n+    @GuardedBy(\"this\")\n+    private SettableFuture<?> notEmptyFuture; // null indicates no callback has been registered\n \n-    @GuardedBy(\"lock\")\n-    private boolean finishing;\n+    @GuardedBy(\"this\")\n+    private final AtomicBoolean finishing = new AtomicBoolean(false);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MjU0NA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547252544", "bodyText": "I would just use volatile boolean finishing", "author": "sopel39", "createdAt": "2020-12-22T12:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwODQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1Njk3MQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547356971", "bodyText": "Sure, will make this a volatile boolean instead.", "author": "pettyjamesm", "createdAt": "2020-12-22T15:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwODQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzExMDEzOA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547110138", "bodyText": "Why do we need to change BlockingQueue to LinkedBlockingDeque?", "author": "erichwang", "createdAt": "2020-12-22T07:21:32Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -19,41 +19,37 @@\n import io.prestosql.operator.WorkProcessor.ProcessState;\n import io.prestosql.spi.Page;\n \n+import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicLong;\n import java.util.function.Consumer;\n \n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n public class LocalExchangeSource\n {\n-    private static final SettableFuture<?> NOT_EMPTY;\n-\n-    static {\n-        NOT_EMPTY = SettableFuture.create();\n-        NOT_EMPTY.set(null);\n-    }\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);\n \n     private final Consumer<LocalExchangeSource> onFinish;\n \n-    private final BlockingQueue<PageReference> buffer = new LinkedBlockingDeque<>();\n+    private final LinkedBlockingDeque<PageReference> buffer = new LinkedBlockingDeque<>();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NDAwMw==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547354003", "bodyText": "Accidentally left this behind, I changed it because it was easier to navigate into the implementation of LinkedBlockingDeque methods in my IDE if the field was declared with the exact type. Will revert it to the previous declaration.", "author": "pettyjamesm", "createdAt": "2020-12-22T15:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzExMDEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEyMDkxOA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547120918", "bodyText": "Any reason making notEmptyFuture nullable is better than what we had before? This seems bulkier without notable benefit?", "author": "erichwang", "createdAt": "2020-12-22T07:49:28Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -164,18 +178,20 @@ public void finish()\n         checkNotHoldsLock();\n \n         SettableFuture<?> notEmptyFuture;\n-        synchronized (lock) {\n-            if (finishing) {\n+        synchronized (this) {\n+            if (!finishing.compareAndSet(false, true)) {\n                 return;\n             }\n-            finishing = true;\n \n+            //  Unblock any waiters\n             notEmptyFuture = this.notEmptyFuture;\n-            this.notEmptyFuture = NOT_EMPTY;\n+            this.notEmptyFuture = null;\n         }\n \n         // notify readers outside of lock since this may result in a callback\n-        notEmptyFuture.set(null);\n+        if (notEmptyFuture != null) {\n+            notEmptyFuture.set(null);\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2ODk4MA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547368980", "bodyText": "Compared to what was happening before, this is indeed better in terms of performance:\n\nOverwriting this.notEmptyFuture unconditionally is an additional (potentially irrelevant) store operation that must be flushed to memory as part of releasing the monitor. Skipping the store if the field is already null (ie: no listener is registered) avoids that.\nUnconditionally calling SettableFuture#set(null) in the previous implementation required a volatile CAS even when no listener was registered which performs poorly compared to a null check (which are exceedingly cheap)\n\nI think the previous use of having the static final SettableFuture<?> NOT_EMPTY constant was arguable less clear about what was going on. Conceptually, this field has two states: listener registered and no listener registered. You could make them appear the same by using the constant, but then other parts of code are always checking isDone() which is expensive (volatile read) and in my opinion creates a hazard for race conditions since set(null) can race with the isDone() checks without paying close attention to subtle details of what happens inside of the syncronized sections.", "author": "pettyjamesm", "createdAt": "2020-12-22T16:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEyMDkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDkzNA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547244934", "bodyText": "please initialize it with NOT_BLOCKED", "author": "sopel39", "createdAt": "2020-12-22T12:16:37Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -16,28 +16,26 @@\n import com.google.common.util.concurrent.ListenableFuture;\n import com.google.common.util.concurrent.SettableFuture;\n \n+import javax.annotation.Nullable;\n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.concurrent.atomic.AtomicLong;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n \n @ThreadSafe\n public class LocalExchangeMemoryManager\n {\n-    private static final SettableFuture<?> NOT_FULL;\n-\n-    static {\n-        NOT_FULL = SettableFuture.create();\n-        NOT_FULL.set(null);\n-    }\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);\n \n     private final long maxBufferedBytes;\n     private final AtomicLong bufferedBytes = new AtomicLong();\n \n+    @Nullable\n     @GuardedBy(\"this\")\n-    private SettableFuture<?> notFullFuture = NOT_FULL;\n+    private SettableFuture<?> notFullFuture; // null represents \"no callback registered\"", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2OTc5NA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547369794", "bodyText": "NOT_BLOCKED is not a SettableFuture<?> but rather a ListenableFuture<?> which can't be set (it's already completed). See #6260 (comment) for some additional detail around this implementation strategy.", "author": "pettyjamesm", "createdAt": "2020-12-22T16:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0ODIzNA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547248234", "bodyText": "This optimization reduces readability of concurrent code for little benefit. In practice, we already synchronized on this, so doing extra checks like notFullFuture.isDone() is not a big issue. Also, we should recheck that buffer is still not full before triggering future. That check is cheap, but waking up drivers to do empty processing is not.\n\nThe effect was that previously the transition edge from above-full to below full always unblocked any waiters, and not doing so here (even if we've transitioned back up above the full boundary in the mean time) is a departure from that behavior.\n\nWe cold not transition back to above in the meantime because all methods in LocalExchangeMemoryManager are synchronized. We could transition to above immediately after future was set, but that's slightly different behavior.", "author": "sopel39", "createdAt": "2020-12-22T12:24:15Z", "path": "presto-main/src/main/java/io/prestosql/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -47,31 +45,39 @@ public LocalExchangeMemoryManager(long maxBufferedBytes)\n \n     public void updateMemoryUsage(long bytesAdded)\n     {\n-        SettableFuture<?> future;\n-        synchronized (this) {\n-            bufferedBytes.addAndGet(bytesAdded);\n-\n-            // if we are full, then breakout\n-            if (bufferedBytes.get() > maxBufferedBytes || notFullFuture.isDone()) {\n-                return;\n+        long bufferedBytes = this.bufferedBytes.addAndGet(bytesAdded);\n+        // detect the transition from above to below the full boundary\n+        if (bufferedBytes <= maxBufferedBytes && (bufferedBytes - bytesAdded) > maxBufferedBytes) {\n+            SettableFuture<?> future;\n+            synchronized (this) {\n+                // if we have no callback waiting, return early", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQwMDc0OA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r547400748", "bodyText": "This optimization reduces readability of concurrent code...\n\nI disagree. The prior implementation seemed \"simpler\" in that there was no null checking, but it was also masking a subtle problem: checking isDone() while holding the lock can race with future.set(null) which occurs outside of the synchronized section. This happens to be ok because the field is overwritten inside the synchronized section, but is much more subtle than a null check IMO.\n\n... so doing extra checks like notFullFuture.isDone() is not a big issue\n\nIt's significantly more expensive than a null check because it requires a volatile read (while holding the lock) of the value at the other end of the current reference, meaning that having acquired the object monitor is insufficient to have brought that memory into the CPU cache and will at best need to read it from a shared CPU cache if not from main memory.\nNow, will the extra cycles incurred in doing that dominate performance? Not likely, but there is an Amdahl's law component to the duration that any thread spends in the synchronized section of updateMemoryUsage(long) or getNotFullFuture().\n\nThat check is cheap, but waking up drivers to do empty processing is not.\n\nI agree, the question is whether changing the semantics are a good idea as part of this refactor. Previously, all modifications were linearized by the object monitor. Now, they linearize on the bufferedBytes atomic to accomplish the same goal and the synchronized block is establishing a consistent view of the callback field. I can't say how many workloads today depend on \"fluttering\" against the full vs not-full state and whether they would all benefit from having some of those unblocking notifications suppressed. In the interest of being conservative, I would prefer to keep the previous semantics (but with less lock contention) than potentially regress performance.", "author": "pettyjamesm", "createdAt": "2020-12-22T17:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0ODIzNA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIwODk4OA==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r554208988", "bodyText": "In this case, why not exit early at the top of the method?", "author": "dain", "createdAt": "2021-01-08T21:49:32Z", "path": "core/trino-main/src/main/java/io/trino/operator/ExchangeClient.java", "diffHunk": "@@ -322,52 +323,73 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        // Fast path pre-check\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n-            return Futures.immediateFuture(true);\n+            return NOT_BLOCKED;\n+        }\n+        synchronized (this) {\n+            // Recheck after acquiring the lock\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return NOT_BLOCKED;\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n-        if (isClosed() || isFailed()) {\n-            return false;\n+        // Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n         }\n \n-        pageBuffer.addAll(pages);\n+        List<SettableFuture<?>> notify = ImmutableList.of();\n+        synchronized (this) {\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n \n-        if (!pages.isEmpty()) {\n-            // notify all blocked callers\n-            notifyBlockedCallers();\n-        }\n+            pageBuffer.addAll(pages);\n \n-        long pagesRetainedSizeInBytes = pages.stream()\n-                .mapToLong(SerializedPage::getRetainedSizeInBytes)\n-                .sum();\n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = Math.max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            // AVG_n = AVG_(n-1) * (n-1)/n + VALUE_n / n\n+            averageBytesPerRequest = (long) (1.0 * averageBytesPerRequest * (successfulRequests - 1) / successfulRequests + responseSize / successfulRequests);\n \n-        bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n-        maxBufferRetainedSizeInBytes = Math.max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n-        systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n-        successfulRequests++;\n+            if (!pages.isEmpty()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI1MDIwNw==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r554250207", "bodyText": "I think you\u2019re on to something here. Comments elsewhere suggest that updating the per-request and request count stats must occur even when no pages are added, but there is a real opportunity to skip the memory tracker update of 0 bytes (huge contention bottleneck, although there might be more early returns on 0) and the buffer lock as part of passing an empty list argument to addAll.", "author": "pettyjamesm", "createdAt": "2021-01-08T23:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIwODk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE3MTEzNg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r555171136", "bodyText": "Reorganized the method to only call pageBuffer.addAll and update system memory when the pages list is not empty.", "author": "pettyjamesm", "createdAt": "2021-01-11T16:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIwODk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIzMjEzMg==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r554232132", "bodyText": "Don't we already have a constant for this?", "author": "dain", "createdAt": "2021-01-08T22:42:16Z", "path": "core/trino-main/src/main/java/io/trino/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -30,30 +31,24 @@\n import java.util.function.Consumer;\n \n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n public class LocalExchangeSource\n {\n-    private static final SettableFuture<?> NOT_EMPTY;\n-\n-    static {\n-        NOT_EMPTY = SettableFuture.create();\n-        NOT_EMPTY.set(null);\n-    }\n+    private static final ListenableFuture<?> NOT_BLOCKED = immediateFuture(null);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI0OTA0OQ==", "url": "https://github.com/trinodb/trino/pull/6260#discussion_r554249049", "bodyText": "Under the hood it\u2019s already a static singleton (which is not publicly exported) so between adding a new static final reference to this class or statically importing that same constant  reference from, say, the Operator interface it seems more straightforward duplicate the constant reference here.", "author": "pettyjamesm", "createdAt": "2021-01-08T23:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIzMjEzMg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "02e79f6964057b23f3e4483dac2701a7e84ce6a2", "url": "https://github.com/trinodb/trino/commit/02e79f6964057b23f3e4483dac2701a7e84ce6a2", "message": "Cache isBlocked in various operators\n\nAvoids re-checking the same isBlocked condition when the operator\nblocks which reduces contention for locks and registering duplicate\nisBlocked callback events.", "committedDate": "2021-01-11T18:47:58Z", "type": "commit"}, {"oid": "1b51b67b4c9e154be7e48515b7d6bbb6d5b52b06", "url": "https://github.com/trinodb/trino/commit/1b51b67b4c9e154be7e48515b7d6bbb6d5b52b06", "message": "Add unsynchronized fast paths to reduce contention in ExchangeClient", "committedDate": "2021-01-11T18:47:58Z", "type": "commit"}, {"oid": "d8ebd11abad1bcfb2464ef72109e5ad13f17460f", "url": "https://github.com/trinodb/trino/commit/d8ebd11abad1bcfb2464ef72109e5ad13f17460f", "message": "Refactor ExchangeClient#pollPage\n\nMerges ExchangeClient#postProcessPage into ExchangeClient#pollPage\n(its only usage) to avoid a redundant lock holder check, removes\na redundant peek into the pagesBuffer for NO_MORE_PAGES, and coalesces\nthe synchronized section of scheduleRequestIfNecessary into the\nsynchronized block that immediately preceeded it anyway", "committedDate": "2021-01-11T18:47:58Z", "type": "commit"}, {"oid": "826a58b7e30c9f7bef6024db48a491edad74ce3b", "url": "https://github.com/trinodb/trino/commit/826a58b7e30c9f7bef6024db48a491edad74ce3b", "message": "Use AtomicIntegerFieldUpdater for LocalExchange PageReference", "committedDate": "2021-01-11T18:47:58Z", "type": "commit"}, {"oid": "9670b2e74e5ad2391608b6b0081c50fd73984c50", "url": "https://github.com/trinodb/trino/commit/9670b2e74e5ad2391608b6b0081c50fd73984c50", "message": "Reduce synchronization in LocalExchangeMemoryManager", "committedDate": "2021-01-11T18:47:58Z", "type": "commit"}, {"oid": "e2826474ef67b143f91c424d9b25db2dc3373e93", "url": "https://github.com/trinodb/trino/commit/e2826474ef67b143f91c424d9b25db2dc3373e93", "message": "Improve LocalExchangeSource locking behaviors\n\nAdds an unsynchronized fast path to LocalExchangeSource#waitForReading()\nand LocalExchangeSource#isFinished(). Also removes an unnecessary \"lock\"\nObject which was obscuring this particular contention point in profiling\noriginally.", "committedDate": "2021-01-11T18:47:58Z", "type": "commit"}, {"oid": "019802cb8bf96c707dbf1ac909cbbfc0c49e5eb8", "url": "https://github.com/trinodb/trino/commit/019802cb8bf96c707dbf1ac909cbbfc0c49e5eb8", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-11T18:47:58Z", "type": "commit"}, {"oid": "019802cb8bf96c707dbf1ac909cbbfc0c49e5eb8", "url": "https://github.com/trinodb/trino/commit/019802cb8bf96c707dbf1ac909cbbfc0c49e5eb8", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-11T18:47:58Z", "type": "forcePushed"}]}