{"pr_number": 2860, "pr_title": "Handle serialization errors gracefully on server side", "pr_createdAt": "2020-02-17T15:43:01Z", "pr_url": "https://github.com/trinodb/trino/pull/2860", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NDAzNA==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r416754034", "bodyText": "Use full sentences (capitalize and period) for multi-line comments, since that makes it obvious it's a single item and not separate comments.", "author": "electrum", "createdAt": "2020-04-28T16:28:34Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/Query.java", "diffHunk": "@@ -391,11 +393,15 @@ private synchronized QueryResults getNextResult(long token, UriInfo uriInfo, Str\n         // client while holding the lock because the query may transition to the finished state when the\n         // last page is removed.  If another thread observes this state before the response is cached\n         // the pages will be lost.\n-        Iterable<List<Object>> data = null;\n+        QueryResultRows.Builder resultBuilder = QueryResultRows\n+                .builder(session.toConnectorSession())\n+                // intercept serialization exceptions and fail query if it's still possible", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NDM5OQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r416754399", "bodyText": "Wrapping here looks funny. It's not too long, so put on the previous line", "author": "electrum", "createdAt": "2020-04-28T16:29:04Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/Query.java", "diffHunk": "@@ -391,11 +393,15 @@ private synchronized QueryResults getNextResult(long token, UriInfo uriInfo, Str\n         // client while holding the lock because the query may transition to the finished state when the\n         // last page is removed.  If another thread observes this state before the response is cached\n         // the pages will be lost.\n-        Iterable<List<Object>> data = null;\n+        QueryResultRows.Builder resultBuilder = QueryResultRows\n+                .builder(session.toConnectorSession())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NDg1Nw==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426184857", "bodyText": "The original \"data\" is more accurate since we're talking about data in the exchange client (if it's not closed then there might more data)", "author": "electrum", "createdAt": "2020-05-16T19:46:40Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/Query.java", "diffHunk": "@@ -405,49 +411,39 @@ private synchronized QueryResults getNextResult(long token, UriInfo uriInfo, Str\n \n                 Page page = serde.deserialize(serializedPage);\n                 bytes += page.getLogicalSizeInBytes();\n-                rows += page.getPositionCount();\n-                pages.add(new RowIterable(session.toConnectorSession(), types, page));\n-            }\n-            if (rows > 0) {\n-                // client implementations do not properly handle empty list of data\n-                data = Iterables.concat(pages.build());\n+                resultBuilder.add(page);\n             }\n         }\n         catch (Throwable cause) {\n             queryManager.failQuery(queryId, cause);\n         }\n \n+        QueryResultRows resultRows = resultBuilder.build();\n+\n         // get the query info before returning\n         // force update if query manager is closed\n         QueryInfo queryInfo = queryManager.getFullQueryInfo(queryId);\n         queryManager.recordHeartbeat(queryId);\n \n-        // TODO: figure out a better way to do this\n         // grab the update count for non-queries\n-        if ((data != null) && (queryInfo.getUpdateType() != null) && (updateCount == null) &&\n-                (columns.size() == 1) && (columns.get(0).getType().equals(StandardTypes.BIGINT))) {\n-            Iterator<List<Object>> iterator = data.iterator();\n-            if (iterator.hasNext()) {\n-                Number number = (Number) iterator.next().get(0);\n-                if (number != null) {\n-                    updateCount = number.longValue();\n-                }\n-            }\n+        if ((queryInfo.getUpdateType() != null) && (updateCount == null) && resultRows.hasUpdateCount()) {\n+            updateCount = resultRows.getUpdateCount();\n         }\n \n         closeExchangeClientIfNecessary(queryInfo);\n \n         // for queries with no output, return a fake result for clients that require it\n         if ((queryInfo.getState() == QueryState.FINISHED) && !queryInfo.getOutputStage().isPresent()) {\n-            columns = ImmutableList.of(createColumn(\"result\", BooleanType.BOOLEAN));\n-            data = ImmutableSet.of(ImmutableList.of(true));\n+            resultRows = QueryResultRows.builder(session.toConnectorSession())\n+                    .withSingleBooleanValue(createColumn(\"result\", BooleanType.BOOLEAN), true)\n+                    .build();\n         }\n \n         // advance next token\n         // only return a next if\n         // (1) the query is not done AND the query state is not FAILED\n         //   OR\n-        // (2)there is more data to send (due to buffering)\n+        // (2)there is more resultRows to send (due to buffering)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTI2Nw==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426185267", "bodyText": "Do you have a stack trace or reproduction? This doesn't seem possibly based on my reading of the code. If it does, that seems like a bug, as the existing callers don't appear to handle or expect this.", "author": "electrum", "createdAt": "2020-05-16T19:51:34Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/Query.java", "diffHunk": "@@ -516,6 +512,21 @@ private synchronized void closeExchangeClientIfNecessary(QueryInfo queryInfo)\n         }\n     }\n \n+    private void handleSerializationException(Throwable exception)\n+    {\n+        // failQuery can throw exception if query has already finished", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg3Mjg1OA==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r427872858", "bodyText": "It happens on the first query execution (doesn't happen afterwards).", "author": "wendigo", "createdAt": "2020-05-20T09:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg3MzI0Mw==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r427873243", "bodyText": "I'll post stacktrace", "author": "wendigo", "createdAt": "2020-05-20T09:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTMwNw==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426185307", "bodyText": "This should be RuntimeException since failQuery() doesn't throw any checked exceptions", "author": "electrum", "createdAt": "2020-05-16T19:52:11Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/Query.java", "diffHunk": "@@ -516,6 +512,21 @@ private synchronized void closeExchangeClientIfNecessary(QueryInfo queryInfo)\n         }\n     }\n \n+    private void handleSerializationException(Throwable exception)\n+    {\n+        // failQuery can throw exception if query has already finished\n+        try {\n+            queryManager.failQuery(queryId, exception);\n+        }\n+        catch (Exception e) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTQ5OQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426185499", "bodyText": "Can use exception.isEmpty() now", "author": "electrum", "createdAt": "2020-05-16T19:54:39Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/Query.java", "diffHunk": "@@ -709,17 +720,20 @@ private static StageStats toStageStats(StageInfo stageInfo)\n         return Optional.of(stage.getStageId().getId());\n     }\n \n-    private static QueryError toQueryError(QueryInfo queryInfo)\n+    private static QueryError toQueryError(QueryInfo queryInfo, Optional<Throwable> exception)\n     {\n         QueryState state = queryInfo.getState();\n-        if (state != FAILED) {\n+        if (state != FAILED && !exception.isPresent()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTUyNQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426185525", "bodyText": "Can use exception.isEmpty() now", "author": "electrum", "createdAt": "2020-05-16T19:54:55Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/Query.java", "diffHunk": "@@ -516,6 +512,21 @@ private synchronized void closeExchangeClientIfNecessary(QueryInfo queryInfo)\n         }\n     }\n \n+    private void handleSerializationException(Throwable exception)\n+    {\n+        // failQuery can throw exception if query has already finished\n+        try {\n+            queryManager.failQuery(queryId, exception);\n+        }\n+        catch (Exception e) {\n+            log.debug(\"Could not fail query\", e);\n+        }\n+\n+        if (!typeSerializationException.isPresent()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTY1NA==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426185654", "bodyText": "I'd invert this and return early", "author": "electrum", "createdAt": "2020-05-16T19:56:14Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()\n+    {\n+        if (hasUpdateCount()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTY3NQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426185675", "bodyText": "Remove this since there's no description", "author": "electrum", "createdAt": "2020-05-16T19:56:23Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE4NTcyMA==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426185720", "bodyText": "Maybe rename method to getExpectedRowCount. Also, this method should probably be @VisibleForTesting since it's only used in tests", "author": "electrum", "createdAt": "2020-05-16T19:56:49Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwNjg5Nw==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426306897", "bodyText": "The coupling of these methods is a bit strange. Based on the behavior, the method should be named like couldHaveUpdateCount, since it's checking if an update count is possible. It might be better to inline it into getUpdateCount, since there's no reason to expose this separately.", "author": "electrum", "createdAt": "2020-05-17T21:28:44Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()\n+    {\n+        if (hasUpdateCount()) {\n+            requireNonNull(currentPage, \"currentPage is null\");\n+\n+            Block block = currentPage.getBlock(0);\n+            Number value = (Number) types.get(0).getObjectValue(session, block, 0);\n+\n+            if (value != null) {\n+                return value.longValue();\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean hasUpdateCount()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwNzAzMg==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426307032", "bodyText": "Let's change this and the usage in Query to OptionalLong or Optional<Long> (the latter is often preferable as it allows map and conversion to/from null).", "author": "electrum", "createdAt": "2020-05-17T21:30:18Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwNzMxNg==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426307316", "bodyText": "This implements is redundant since AbstractIterator declares the same", "author": "electrum", "createdAt": "2020-05-17T21:33:56Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkwMjMwMw==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r427902303", "bodyText": "It's not (iterator() method is not defined in AbstractIterator)", "author": "wendigo", "createdAt": "2020-05-20T10:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwNzMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwNzM1OQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426307359", "bodyText": "The \"else\" is redundant since the above \"if\" returns unconditionally", "author": "electrum", "createdAt": "2020-05-17T21:34:41Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()\n+    {\n+        if (hasUpdateCount()) {\n+            requireNonNull(currentPage, \"currentPage is null\");\n+\n+            Block block = currentPage.getBlock(0);\n+            Number value = (Number) types.get(0).getObjectValue(session, block, 0);\n+\n+            if (value != null) {\n+                return value.longValue();\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean hasUpdateCount()\n+    {\n+        return !isEmpty() && columns.size() == 1 && columns.get(0).getType().equals(StandardTypes.BIGINT);\n+    }\n+\n+    @Override\n+    protected List<Object> computeNext()\n+    {\n+        loop:\n+        while (true) {\n+            inPageIndex++;\n+\n+            if (currentPage == null || (pages.isEmpty() && inPageIndex >= currentPage.getPositionCount())) {\n+                return endOfData();\n+            }\n+            else if (inPageIndex >= currentPage.getPositionCount()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwODQ0NA==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426308444", "bodyText": "We can avoid these redundant checks if we restructure the code like\nif (currentPage == null) {\n    return endOfData();\n}\nif (inPageIndex >= currentPage.getPositionCount()) {\n    currentPage = pages.pollFirst();\n    if (currentPage == null) {\n        return endOfData();\n    }\n    inPageIndex = 0;\n}", "author": "electrum", "createdAt": "2020-05-17T21:46:55Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()\n+    {\n+        if (hasUpdateCount()) {\n+            requireNonNull(currentPage, \"currentPage is null\");\n+\n+            Block block = currentPage.getBlock(0);\n+            Number value = (Number) types.get(0).getObjectValue(session, block, 0);\n+\n+            if (value != null) {\n+                return value.longValue();\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean hasUpdateCount()\n+    {\n+        return !isEmpty() && columns.size() == 1 && columns.get(0).getType().equals(StandardTypes.BIGINT);\n+    }\n+\n+    @Override\n+    protected List<Object> computeNext()\n+    {\n+        loop:\n+        while (true) {\n+            inPageIndex++;\n+\n+            if (currentPage == null || (pages.isEmpty() && inPageIndex >= currentPage.getPositionCount())) {\n+                return endOfData();\n+            }\n+            else if (inPageIndex >= currentPage.getPositionCount()) {\n+                currentPage = pages.pollFirst();\n+                requireNonNull(currentPage, \"currentPage is null\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwODU3OQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426308579", "bodyText": "Extract a method getRowValues() so that we don't need a labeled loop. Those are generally confusing and we don't use them in Presto. (the one usage in DelimiterLexer is forked from ANTLR)", "author": "electrum", "createdAt": "2020-05-17T21:48:22Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()\n+    {\n+        if (hasUpdateCount()) {\n+            requireNonNull(currentPage, \"currentPage is null\");\n+\n+            Block block = currentPage.getBlock(0);\n+            Number value = (Number) types.get(0).getObjectValue(session, block, 0);\n+\n+            if (value != null) {\n+                return value.longValue();\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean hasUpdateCount()\n+    {\n+        return !isEmpty() && columns.size() == 1 && columns.get(0).getType().equals(StandardTypes.BIGINT);\n+    }\n+\n+    @Override\n+    protected List<Object> computeNext()\n+    {\n+        loop:\n+        while (true) {\n+            inPageIndex++;\n+\n+            if (currentPage == null || (pages.isEmpty() && inPageIndex >= currentPage.getPositionCount())) {\n+                return endOfData();\n+            }\n+            else if (inPageIndex >= currentPage.getPositionCount()) {\n+                currentPage = pages.pollFirst();\n+                requireNonNull(currentPage, \"currentPage is null\");\n+                inPageIndex = 0;\n+            }\n+\n+            rowPosition++;\n+            List<Object> values = new ArrayList<>(columns.size());\n+\n+            for (int channel = 0; channel < currentPage.getChannelCount(); channel++) {\n+                Type type = types.get(channel);\n+                Block block = currentPage.getBlock(channel);\n+\n+                try {\n+                    values.add(channel, type.getObjectValue(session, block, inPageIndex));\n+                }\n+                catch (Throwable throwable) {\n+                    storeLastException(rowPosition, channel, throwable);\n+                    // if row contains unserializable value - skip row entirely\n+                    continue loop;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwODgzMQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426308831", "bodyText": "We don't use final on parameters or local variables", "author": "electrum", "createdAt": "2020-05-17T21:51:02Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()\n+    {\n+        if (hasUpdateCount()) {\n+            requireNonNull(currentPage, \"currentPage is null\");\n+\n+            Block block = currentPage.getBlock(0);\n+            Number value = (Number) types.get(0).getObjectValue(session, block, 0);\n+\n+            if (value != null) {\n+                return value.longValue();\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean hasUpdateCount()\n+    {\n+        return !isEmpty() && columns.size() == 1 && columns.get(0).getType().equals(StandardTypes.BIGINT);\n+    }\n+\n+    @Override\n+    protected List<Object> computeNext()\n+    {\n+        loop:\n+        while (true) {\n+            inPageIndex++;\n+\n+            if (currentPage == null || (pages.isEmpty() && inPageIndex >= currentPage.getPositionCount())) {\n+                return endOfData();\n+            }\n+            else if (inPageIndex >= currentPage.getPositionCount()) {\n+                currentPage = pages.pollFirst();\n+                requireNonNull(currentPage, \"currentPage is null\");\n+                inPageIndex = 0;\n+            }\n+\n+            rowPosition++;\n+            List<Object> values = new ArrayList<>(columns.size());\n+\n+            for (int channel = 0; channel < currentPage.getChannelCount(); channel++) {\n+                Type type = types.get(channel);\n+                Block block = currentPage.getBlock(channel);\n+\n+                try {\n+                    values.add(channel, type.getObjectValue(session, block, inPageIndex));\n+                }\n+                catch (Throwable throwable) {\n+                    storeLastException(rowPosition, channel, throwable);\n+                    // if row contains unserializable value - skip row entirely\n+                    continue loop;\n+                }\n+            }\n+\n+            return unmodifiableList(values);\n+        }\n+    }\n+\n+    private void storeLastException(final int row, final int column, final Throwable cause)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwODg1Mg==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426308852", "bodyText": "Format like\nString message = format(\"Could not serialize type '%s' value at position %d:%d\", columns.get(column).getType(), row + 1, column + 1);\nPrestoException exception = new PrestoException(SERIALIZATION_ERROR, message, cause);", "author": "electrum", "createdAt": "2020-05-17T21:51:17Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()\n+    {\n+        if (hasUpdateCount()) {\n+            requireNonNull(currentPage, \"currentPage is null\");\n+\n+            Block block = currentPage.getBlock(0);\n+            Number value = (Number) types.get(0).getObjectValue(session, block, 0);\n+\n+            if (value != null) {\n+                return value.longValue();\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean hasUpdateCount()\n+    {\n+        return !isEmpty() && columns.size() == 1 && columns.get(0).getType().equals(StandardTypes.BIGINT);\n+    }\n+\n+    @Override\n+    protected List<Object> computeNext()\n+    {\n+        loop:\n+        while (true) {\n+            inPageIndex++;\n+\n+            if (currentPage == null || (pages.isEmpty() && inPageIndex >= currentPage.getPositionCount())) {\n+                return endOfData();\n+            }\n+            else if (inPageIndex >= currentPage.getPositionCount()) {\n+                currentPage = pages.pollFirst();\n+                requireNonNull(currentPage, \"currentPage is null\");\n+                inPageIndex = 0;\n+            }\n+\n+            rowPosition++;\n+            List<Object> values = new ArrayList<>(columns.size());\n+\n+            for (int channel = 0; channel < currentPage.getChannelCount(); channel++) {\n+                Type type = types.get(channel);\n+                Block block = currentPage.getBlock(channel);\n+\n+                try {\n+                    values.add(channel, type.getObjectValue(session, block, inPageIndex));\n+                }\n+                catch (Throwable throwable) {\n+                    storeLastException(rowPosition, channel, throwable);\n+                    // if row contains unserializable value - skip row entirely\n+                    continue loop;\n+                }\n+            }\n+\n+            return unmodifiableList(values);\n+        }\n+    }\n+\n+    private void storeLastException(final int row, final int column, final Throwable cause)\n+    {\n+        // columns and rows are 0-indexed\n+        PrestoException exception = new PrestoException(SERIALIZATION_ERROR,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwOTE2Nw==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426309167", "bodyText": "Use Optional instead of a nullable field", "author": "electrum", "createdAt": "2020-05-17T21:55:03Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()\n+    {\n+        if (hasUpdateCount()) {\n+            requireNonNull(currentPage, \"currentPage is null\");\n+\n+            Block block = currentPage.getBlock(0);\n+            Number value = (Number) types.get(0).getObjectValue(session, block, 0);\n+\n+            if (value != null) {\n+                return value.longValue();\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean hasUpdateCount()\n+    {\n+        return !isEmpty() && columns.size() == 1 && columns.get(0).getType().equals(StandardTypes.BIGINT);\n+    }\n+\n+    @Override\n+    protected List<Object> computeNext()\n+    {\n+        loop:\n+        while (true) {\n+            inPageIndex++;\n+\n+            if (currentPage == null || (pages.isEmpty() && inPageIndex >= currentPage.getPositionCount())) {\n+                return endOfData();\n+            }\n+            else if (inPageIndex >= currentPage.getPositionCount()) {\n+                currentPage = pages.pollFirst();\n+                requireNonNull(currentPage, \"currentPage is null\");\n+                inPageIndex = 0;\n+            }\n+\n+            rowPosition++;\n+            List<Object> values = new ArrayList<>(columns.size());\n+\n+            for (int channel = 0; channel < currentPage.getChannelCount(); channel++) {\n+                Type type = types.get(channel);\n+                Block block = currentPage.getBlock(channel);\n+\n+                try {\n+                    values.add(channel, type.getObjectValue(session, block, inPageIndex));\n+                }\n+                catch (Throwable throwable) {\n+                    storeLastException(rowPosition, channel, throwable);\n+                    // if row contains unserializable value - skip row entirely\n+                    continue loop;\n+                }\n+            }\n+\n+            return unmodifiableList(values);\n+        }\n+    }\n+\n+    private void storeLastException(final int row, final int column, final Throwable cause)\n+    {\n+        // columns and rows are 0-indexed\n+        PrestoException exception = new PrestoException(SERIALIZATION_ERROR,\n+                format(\"Could not serialize type '%s' value at position %d:%d\", columns.get(column).getType(), row + 1, column + 1),\n+                cause);\n+\n+        lastException = exception;\n+\n+        if (exceptionConsumer != null) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwOTUxMw==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426309513", "bodyText": "Only use assertTrue for boolean conditions. Use a more specific assert otherwise, as that provides a better error message:\nassertThat(rows).as(\"rows\").isEmpty();", "author": "electrum", "createdAt": "2020-05-17T21:59:07Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwOTY0MA==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426309640", "bodyText": "This can be\nassertThat(rows.iterator()).isExhausted();", "author": "electrum", "createdAt": "2020-05-17T22:00:37Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");\n+        assertThat(getAllValues(rows)).hasSize(0);\n+        assertThat(rows.getColumns()).hasSize(0);\n+        assertThat(rows.iterator().hasNext()).isFalse();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwOTcxMg==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426309712", "bodyText": "assertThat(rows).as(\"rows\").isNotEmpty();", "author": "electrum", "createdAt": "2020-05-17T22:01:21Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");\n+        assertThat(getAllValues(rows)).hasSize(0);\n+        assertThat(rows.getColumns()).hasSize(0);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnSingleValue()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, true)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwOTg2OQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426309869", "bodyText": "This can be\nassertThat(getAllValues(rows)).containsExactly(true);\nNo need to duplicate the size check", "author": "electrum", "createdAt": "2020-05-17T22:03:09Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");\n+        assertThat(getAllValues(rows)).hasSize(0);\n+        assertThat(rows.getColumns()).hasSize(0);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnSingleValue()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, true)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(true));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwOTg5MQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426309891", "bodyText": "Please update below assertions based on above comments.", "author": "electrum", "createdAt": "2020-05-17T22:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwOTg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMDE1MA==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426310150", "bodyText": "Use shouldNot instead of a contraction when naming methods", "author": "electrum", "createdAt": "2020-05-17T22:06:31Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");\n+        assertThat(getAllValues(rows)).hasSize(0);\n+        assertThat(rows.getColumns()).hasSize(0);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnSingleValue()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, true)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(true));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BIGINT, new ClientTypeSignature(BIGINT));\n+        long value = 10123;\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(ImmutableList.of(column), ImmutableList.of(BigintType.BIGINT))\n+                .add(createLongPage(value))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertTrue(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(value);\n+\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(value));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldntHaveUpdateCount()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMDM1OA==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426310358", "bodyText": "We should validate the ordering as well\nassertThat(getAllValues(rows)).containsExactly(\n        ImmutableList.of(0, 10L),\n        ImmutableList.of(1, 11L),\n        ...);", "author": "electrum", "createdAt": "2020-05-17T22:08:37Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");\n+        assertThat(getAllValues(rows)).hasSize(0);\n+        assertThat(rows.getColumns()).hasSize(0);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnSingleValue()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, true)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(true));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BIGINT, new ClientTypeSignature(BIGINT));\n+        long value = 10123;\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(ImmutableList.of(column), ImmutableList.of(BigintType.BIGINT))\n+                .add(createLongPage(value))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertTrue(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(value);\n+\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(value));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldntHaveUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, false)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertFalse(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(null);\n+        assertTrue(rows.iterator().hasNext());\n+    }\n+\n+    @Test\n+    public void shouldReadAllValuesFromMultiplePages()\n+    {\n+        List<Column> columns = ImmutableList.of(new Column(\"_col0\", INTEGER, new ClientTypeSignature(INTEGER)), new Column(\"_col1\", BIGINT, new ClientTypeSignature(BIGINT)));\n+        List<Type> types = ImmutableList.of(IntegerType.INTEGER, BigintType.BIGINT);\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(columns, types)\n+                .add(createPage(ImmutableList.of(ImmutableList.of(0, 1, 2, 3, 4), ImmutableList.of(10L, 11L, 12L, 13L, 14L)), types))\n+                .add(createPage(ImmutableList.of(ImmutableList.of(100, 101, 102, 103, 104), ImmutableList.of(110L, 111L, 112L, 113L, 114L)), types))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are empty\");\n+        assertThat(rows.getTotalRows()).isEqualTo(10);\n+        assertThat(rows.getColumns()).isEqualTo(columns);\n+        assertFalse(rows.hasUpdateCount());\n+\n+        assertThat(getAllValues(rows))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMDQ0NQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426310445", "bodyText": "We don't use final on local variables", "author": "electrum", "createdAt": "2020-05-17T22:09:50Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");\n+        assertThat(getAllValues(rows)).hasSize(0);\n+        assertThat(rows.getColumns()).hasSize(0);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnSingleValue()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, true)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(true));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BIGINT, new ClientTypeSignature(BIGINT));\n+        long value = 10123;\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(ImmutableList.of(column), ImmutableList.of(BigintType.BIGINT))\n+                .add(createLongPage(value))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertTrue(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(value);\n+\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(value));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldntHaveUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, false)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertFalse(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(null);\n+        assertTrue(rows.iterator().hasNext());\n+    }\n+\n+    @Test\n+    public void shouldReadAllValuesFromMultiplePages()\n+    {\n+        List<Column> columns = ImmutableList.of(new Column(\"_col0\", INTEGER, new ClientTypeSignature(INTEGER)), new Column(\"_col1\", BIGINT, new ClientTypeSignature(BIGINT)));\n+        List<Type> types = ImmutableList.of(IntegerType.INTEGER, BigintType.BIGINT);\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(columns, types)\n+                .add(createPage(ImmutableList.of(ImmutableList.of(0, 1, 2, 3, 4), ImmutableList.of(10L, 11L, 12L, 13L, 14L)), types))\n+                .add(createPage(ImmutableList.of(ImmutableList.of(100, 101, 102, 103, 104), ImmutableList.of(110L, 111L, 112L, 113L, 114L)), types))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are empty\");\n+        assertThat(rows.getTotalRows()).isEqualTo(10);\n+        assertThat(rows.getColumns()).isEqualTo(columns);\n+        assertFalse(rows.hasUpdateCount());\n+\n+        assertThat(getAllValues(rows))\n+                .hasSize(10)\n+                .contains(ImmutableList.of(0, 10L))\n+                .contains(ImmutableList.of(1, 11L))\n+                .contains(ImmutableList.of(2, 12L))\n+                .contains(ImmutableList.of(3, 13L))\n+                .contains(ImmutableList.of(4, 14L))\n+                .contains(ImmutableList.of(100, 110L))\n+                .contains(ImmutableList.of(101, 111L))\n+                .contains(ImmutableList.of(102, 112L))\n+                .contains(ImmutableList.of(103, 113L))\n+                .contains(ImmutableList.of(104, 114L));\n+\n+        assertThat(rows.getLastSerializationException()).isEmpty();\n+    }\n+\n+    @Test\n+    public void shouldOmitBadRows()\n+    {\n+        List<Column> columns = ImmutableList.of(new Column(\"_col0\", INTEGER, new ClientTypeSignature(INTEGER)), new Column(\"_col1\", BOOLEAN, new ClientTypeSignature(BOOLEAN)));\n+        List<Type> types = ImmutableList.of(IntegerType.INTEGER, BogusType.BOGUS_TYPE);\n+        final List<Throwable> exceptions = new ArrayList<>();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMDcyNQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426310725", "bodyText": "This \"last exception\" seems to only be used for testing. Let's remove it, since we can and already do use the consumer for testing.", "author": "electrum", "createdAt": "2020-05-17T22:12:53Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.AbstractIterator;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static io.prestosql.spi.StandardErrorCode.SERIALIZATION_ERROR;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class QueryResultRows\n+        extends AbstractIterator<List<Object>>\n+        implements Iterable<List<Object>>\n+{\n+    private final ConnectorSession session;\n+    private final List<Type> types;\n+    private final List<Column> columns;\n+    private final Deque<Page> pages;\n+    private final int totalRows;\n+\n+    private Page currentPage;\n+    private Throwable lastException;\n+    private Consumer<Throwable> exceptionConsumer;\n+\n+    private int rowPosition = -1;\n+    private int inPageIndex = -1;\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages)\n+    {\n+        this(session, types, columns, pages, null);\n+    }\n+\n+    private QueryResultRows(ConnectorSession session, List<Type> types, List<Column> columns, List<Page> pages, Consumer<Throwable> exceptionConsumer)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.types = requireNonNull(types, \"types is null\");\n+        this.columns = requireNonNull(columns, \"columns is null\");\n+        this.pages = new ArrayDeque<>(requireNonNull(pages, \"pages is null\"));\n+        this.exceptionConsumer = exceptionConsumer;\n+        this.totalRows = countRows(pages);\n+        this.currentPage = this.pages.pollFirst();\n+\n+        verify(this.types.size() == this.columns.size(), \"columns and types sizes mismatch\");\n+    }\n+\n+    public boolean isEmpty()\n+    {\n+        return totalRows == 0;\n+    }\n+\n+    public List<Column> getColumns()\n+    {\n+        return columns;\n+    }\n+\n+    public QueryResultRows getSelfOrNull()\n+    {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Returns expected row count (we don't know yet if every row is serializable)\n+     *\n+     * @return int\n+     */\n+    public int getTotalRows()\n+    {\n+        return totalRows;\n+    }\n+\n+    public Long getUpdateCount()\n+    {\n+        if (hasUpdateCount()) {\n+            requireNonNull(currentPage, \"currentPage is null\");\n+\n+            Block block = currentPage.getBlock(0);\n+            Number value = (Number) types.get(0).getObjectValue(session, block, 0);\n+\n+            if (value != null) {\n+                return value.longValue();\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean hasUpdateCount()\n+    {\n+        return !isEmpty() && columns.size() == 1 && columns.get(0).getType().equals(StandardTypes.BIGINT);\n+    }\n+\n+    @Override\n+    protected List<Object> computeNext()\n+    {\n+        loop:\n+        while (true) {\n+            inPageIndex++;\n+\n+            if (currentPage == null || (pages.isEmpty() && inPageIndex >= currentPage.getPositionCount())) {\n+                return endOfData();\n+            }\n+            else if (inPageIndex >= currentPage.getPositionCount()) {\n+                currentPage = pages.pollFirst();\n+                requireNonNull(currentPage, \"currentPage is null\");\n+                inPageIndex = 0;\n+            }\n+\n+            rowPosition++;\n+            List<Object> values = new ArrayList<>(columns.size());\n+\n+            for (int channel = 0; channel < currentPage.getChannelCount(); channel++) {\n+                Type type = types.get(channel);\n+                Block block = currentPage.getBlock(channel);\n+\n+                try {\n+                    values.add(channel, type.getObjectValue(session, block, inPageIndex));\n+                }\n+                catch (Throwable throwable) {\n+                    storeLastException(rowPosition, channel, throwable);\n+                    // if row contains unserializable value - skip row entirely\n+                    continue loop;\n+                }\n+            }\n+\n+            return unmodifiableList(values);\n+        }\n+    }\n+\n+    private void storeLastException(final int row, final int column, final Throwable cause)\n+    {\n+        // columns and rows are 0-indexed\n+        PrestoException exception = new PrestoException(SERIALIZATION_ERROR,\n+                format(\"Could not serialize type '%s' value at position %d:%d\", columns.get(column).getType(), row + 1, column + 1),\n+                cause);\n+\n+        lastException = exception;\n+\n+        if (exceptionConsumer != null) {\n+            exceptionConsumer.accept(exception);\n+        }\n+    }\n+\n+    public Optional<Throwable> getLastSerializationException()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMDk2Ng==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426310966", "bodyText": "No need for this utility -- use RowPagesBuilder instead", "author": "electrum", "createdAt": "2020-05-17T22:15:58Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");\n+        assertThat(getAllValues(rows)).hasSize(0);\n+        assertThat(rows.getColumns()).hasSize(0);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnSingleValue()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, true)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(true));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BIGINT, new ClientTypeSignature(BIGINT));\n+        long value = 10123;\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(ImmutableList.of(column), ImmutableList.of(BigintType.BIGINT))\n+                .add(createLongPage(value))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertTrue(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(value);\n+\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(value));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldntHaveUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, false)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertFalse(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(null);\n+        assertTrue(rows.iterator().hasNext());\n+    }\n+\n+    @Test\n+    public void shouldReadAllValuesFromMultiplePages()\n+    {\n+        List<Column> columns = ImmutableList.of(new Column(\"_col0\", INTEGER, new ClientTypeSignature(INTEGER)), new Column(\"_col1\", BIGINT, new ClientTypeSignature(BIGINT)));\n+        List<Type> types = ImmutableList.of(IntegerType.INTEGER, BigintType.BIGINT);\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(columns, types)\n+                .add(createPage(ImmutableList.of(ImmutableList.of(0, 1, 2, 3, 4), ImmutableList.of(10L, 11L, 12L, 13L, 14L)), types))\n+                .add(createPage(ImmutableList.of(ImmutableList.of(100, 101, 102, 103, 104), ImmutableList.of(110L, 111L, 112L, 113L, 114L)), types))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are empty\");\n+        assertThat(rows.getTotalRows()).isEqualTo(10);\n+        assertThat(rows.getColumns()).isEqualTo(columns);\n+        assertFalse(rows.hasUpdateCount());\n+\n+        assertThat(getAllValues(rows))\n+                .hasSize(10)\n+                .contains(ImmutableList.of(0, 10L))\n+                .contains(ImmutableList.of(1, 11L))\n+                .contains(ImmutableList.of(2, 12L))\n+                .contains(ImmutableList.of(3, 13L))\n+                .contains(ImmutableList.of(4, 14L))\n+                .contains(ImmutableList.of(100, 110L))\n+                .contains(ImmutableList.of(101, 111L))\n+                .contains(ImmutableList.of(102, 112L))\n+                .contains(ImmutableList.of(103, 113L))\n+                .contains(ImmutableList.of(104, 114L));\n+\n+        assertThat(rows.getLastSerializationException()).isEmpty();\n+    }\n+\n+    @Test\n+    public void shouldOmitBadRows()\n+    {\n+        List<Column> columns = ImmutableList.of(new Column(\"_col0\", INTEGER, new ClientTypeSignature(INTEGER)), new Column(\"_col1\", BOOLEAN, new ClientTypeSignature(BOOLEAN)));\n+        List<Type> types = ImmutableList.of(IntegerType.INTEGER, BogusType.BOGUS_TYPE);\n+        final List<Throwable> exceptions = new ArrayList<>();\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(columns, types)\n+                .withExceptionConsumer(exceptions::add)\n+                .add(createPage(ImmutableList.of(ImmutableList.of(0, 1, 2, 3, 4), ImmutableList.of(true, false, true, false, true)), types))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are empty\");\n+        assertThat(rows.getTotalRows()).isEqualTo(5);\n+        assertThat(rows.getColumns()).isEqualTo(columns);\n+        assertFalse(rows.hasUpdateCount());\n+\n+        assertThat(getAllValues(rows))\n+                .hasSize(2)\n+                .contains(ImmutableList.of(1, false))\n+                .contains(ImmutableList.of(3, false));\n+\n+        assertThat(rows.getLastSerializationException())\n+                .isPresent();\n+\n+        assertThat(rows.getLastSerializationException().get())\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 5:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+\n+        assertThat(exceptions)\n+                .hasSize(3);\n+\n+        assertThat(exceptions.get(0))\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 1:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+\n+        assertThat(exceptions.get(1))\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 3:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+\n+        assertThat(exceptions.get(2))\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 5:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+    }\n+\n+    private static List<List<Object>> getAllValues(QueryResultRows rows)\n+    {\n+        ImmutableList.Builder<List<Object>> builder = ImmutableList.builder();\n+\n+        for (List<Object> values : rows) {\n+            builder.add(values);\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    private static ConnectorSession getSession()\n+    {\n+        return TestingConnectorSession.builder()\n+                .build();\n+    }\n+\n+    private static Page createLongPage(long value)\n+    {\n+        BlockBuilder blockBuilder = BigintType.BIGINT.createBlockBuilder(null, 1);\n+        BigintType.BIGINT.writeLong(blockBuilder, value);\n+        return new Page(blockBuilder.build());\n+    }\n+\n+    private static Page createPage(List<List<Object>> values, List<Type> types)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTA4Ng==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426311086", "bodyText": "return rowPagesBuilder(BIGINT).row(value).build();", "author": "electrum", "createdAt": "2020-05-17T22:17:31Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");\n+        assertThat(getAllValues(rows)).hasSize(0);\n+        assertThat(rows.getColumns()).hasSize(0);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnSingleValue()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, true)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(true));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BIGINT, new ClientTypeSignature(BIGINT));\n+        long value = 10123;\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(ImmutableList.of(column), ImmutableList.of(BigintType.BIGINT))\n+                .add(createLongPage(value))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertTrue(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(value);\n+\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(value));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldntHaveUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, false)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertFalse(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(null);\n+        assertTrue(rows.iterator().hasNext());\n+    }\n+\n+    @Test\n+    public void shouldReadAllValuesFromMultiplePages()\n+    {\n+        List<Column> columns = ImmutableList.of(new Column(\"_col0\", INTEGER, new ClientTypeSignature(INTEGER)), new Column(\"_col1\", BIGINT, new ClientTypeSignature(BIGINT)));\n+        List<Type> types = ImmutableList.of(IntegerType.INTEGER, BigintType.BIGINT);\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(columns, types)\n+                .add(createPage(ImmutableList.of(ImmutableList.of(0, 1, 2, 3, 4), ImmutableList.of(10L, 11L, 12L, 13L, 14L)), types))\n+                .add(createPage(ImmutableList.of(ImmutableList.of(100, 101, 102, 103, 104), ImmutableList.of(110L, 111L, 112L, 113L, 114L)), types))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are empty\");\n+        assertThat(rows.getTotalRows()).isEqualTo(10);\n+        assertThat(rows.getColumns()).isEqualTo(columns);\n+        assertFalse(rows.hasUpdateCount());\n+\n+        assertThat(getAllValues(rows))\n+                .hasSize(10)\n+                .contains(ImmutableList.of(0, 10L))\n+                .contains(ImmutableList.of(1, 11L))\n+                .contains(ImmutableList.of(2, 12L))\n+                .contains(ImmutableList.of(3, 13L))\n+                .contains(ImmutableList.of(4, 14L))\n+                .contains(ImmutableList.of(100, 110L))\n+                .contains(ImmutableList.of(101, 111L))\n+                .contains(ImmutableList.of(102, 112L))\n+                .contains(ImmutableList.of(103, 113L))\n+                .contains(ImmutableList.of(104, 114L));\n+\n+        assertThat(rows.getLastSerializationException()).isEmpty();\n+    }\n+\n+    @Test\n+    public void shouldOmitBadRows()\n+    {\n+        List<Column> columns = ImmutableList.of(new Column(\"_col0\", INTEGER, new ClientTypeSignature(INTEGER)), new Column(\"_col1\", BOOLEAN, new ClientTypeSignature(BOOLEAN)));\n+        List<Type> types = ImmutableList.of(IntegerType.INTEGER, BogusType.BOGUS_TYPE);\n+        final List<Throwable> exceptions = new ArrayList<>();\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(columns, types)\n+                .withExceptionConsumer(exceptions::add)\n+                .add(createPage(ImmutableList.of(ImmutableList.of(0, 1, 2, 3, 4), ImmutableList.of(true, false, true, false, true)), types))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are empty\");\n+        assertThat(rows.getTotalRows()).isEqualTo(5);\n+        assertThat(rows.getColumns()).isEqualTo(columns);\n+        assertFalse(rows.hasUpdateCount());\n+\n+        assertThat(getAllValues(rows))\n+                .hasSize(2)\n+                .contains(ImmutableList.of(1, false))\n+                .contains(ImmutableList.of(3, false));\n+\n+        assertThat(rows.getLastSerializationException())\n+                .isPresent();\n+\n+        assertThat(rows.getLastSerializationException().get())\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 5:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+\n+        assertThat(exceptions)\n+                .hasSize(3);\n+\n+        assertThat(exceptions.get(0))\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 1:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+\n+        assertThat(exceptions.get(1))\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 3:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+\n+        assertThat(exceptions.get(2))\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 5:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+    }\n+\n+    private static List<List<Object>> getAllValues(QueryResultRows rows)\n+    {\n+        ImmutableList.Builder<List<Object>> builder = ImmutableList.builder();\n+\n+        for (List<Object> values : rows) {\n+            builder.add(values);\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    private static ConnectorSession getSession()\n+    {\n+        return TestingConnectorSession.builder()\n+                .build();\n+    }\n+\n+    private static Page createLongPage(long value)\n+    {\n+        BlockBuilder blockBuilder = BigintType.BIGINT.createBlockBuilder(null, 1);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTIxMw==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426311213", "bodyText": "You can simplify this by extending AbstractLongType", "author": "electrum", "createdAt": "2020-05-17T22:18:46Z", "path": "presto-main/src/test/java/io/prestosql/server/protocol/TestQueryResultRows.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.server.protocol;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.client.ClientTypeSignature;\n+import io.prestosql.client.Column;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.ByteArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.type.BigintType;\n+import io.prestosql.spi.type.BooleanType;\n+import io.prestosql.spi.type.FixedWidthType;\n+import io.prestosql.spi.type.IntegerType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.prestosql.client.ClientStandardTypes.BIGINT;\n+import static io.prestosql.client.ClientStandardTypes.BOOLEAN;\n+import static io.prestosql.client.ClientStandardTypes.INTEGER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestQueryResultRows\n+{\n+    @Test\n+    public void shouldNotReturnValues()\n+    {\n+        QueryResultRows rows = QueryResultRows.empty(getSession());\n+\n+        assertTrue(rows.isEmpty(), \"rows are empty\");\n+        assertThat(getAllValues(rows)).hasSize(0);\n+        assertThat(rows.getColumns()).hasSize(0);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnSingleValue()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, true)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(true));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldReturnUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BIGINT, new ClientTypeSignature(BIGINT));\n+        long value = 10123;\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(ImmutableList.of(column), ImmutableList.of(BigintType.BIGINT))\n+                .add(createLongPage(value))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertTrue(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(value);\n+\n+        assertThat(getAllValues(rows)).hasSize(1).containsOnly(ImmutableList.of(value));\n+        assertThat(rows.getColumns()).containsOnly(column);\n+        assertThat(rows.iterator().hasNext()).isFalse();\n+    }\n+\n+    @Test\n+    public void shouldntHaveUpdateCount()\n+    {\n+        Column column = new Column(\"_col0\", BOOLEAN, new ClientTypeSignature(BOOLEAN));\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withSingleBooleanValue(column, false)\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are not empty\");\n+        assertFalse(rows.hasUpdateCount(), \"has update count\");\n+        assertThat(rows.getUpdateCount()).isEqualTo(null);\n+        assertTrue(rows.iterator().hasNext());\n+    }\n+\n+    @Test\n+    public void shouldReadAllValuesFromMultiplePages()\n+    {\n+        List<Column> columns = ImmutableList.of(new Column(\"_col0\", INTEGER, new ClientTypeSignature(INTEGER)), new Column(\"_col1\", BIGINT, new ClientTypeSignature(BIGINT)));\n+        List<Type> types = ImmutableList.of(IntegerType.INTEGER, BigintType.BIGINT);\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(columns, types)\n+                .add(createPage(ImmutableList.of(ImmutableList.of(0, 1, 2, 3, 4), ImmutableList.of(10L, 11L, 12L, 13L, 14L)), types))\n+                .add(createPage(ImmutableList.of(ImmutableList.of(100, 101, 102, 103, 104), ImmutableList.of(110L, 111L, 112L, 113L, 114L)), types))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are empty\");\n+        assertThat(rows.getTotalRows()).isEqualTo(10);\n+        assertThat(rows.getColumns()).isEqualTo(columns);\n+        assertFalse(rows.hasUpdateCount());\n+\n+        assertThat(getAllValues(rows))\n+                .hasSize(10)\n+                .contains(ImmutableList.of(0, 10L))\n+                .contains(ImmutableList.of(1, 11L))\n+                .contains(ImmutableList.of(2, 12L))\n+                .contains(ImmutableList.of(3, 13L))\n+                .contains(ImmutableList.of(4, 14L))\n+                .contains(ImmutableList.of(100, 110L))\n+                .contains(ImmutableList.of(101, 111L))\n+                .contains(ImmutableList.of(102, 112L))\n+                .contains(ImmutableList.of(103, 113L))\n+                .contains(ImmutableList.of(104, 114L));\n+\n+        assertThat(rows.getLastSerializationException()).isEmpty();\n+    }\n+\n+    @Test\n+    public void shouldOmitBadRows()\n+    {\n+        List<Column> columns = ImmutableList.of(new Column(\"_col0\", INTEGER, new ClientTypeSignature(INTEGER)), new Column(\"_col1\", BOOLEAN, new ClientTypeSignature(BOOLEAN)));\n+        List<Type> types = ImmutableList.of(IntegerType.INTEGER, BogusType.BOGUS_TYPE);\n+        final List<Throwable> exceptions = new ArrayList<>();\n+\n+        QueryResultRows rows = QueryResultRows.builder(getSession())\n+                .withColumns(columns, types)\n+                .withExceptionConsumer(exceptions::add)\n+                .add(createPage(ImmutableList.of(ImmutableList.of(0, 1, 2, 3, 4), ImmutableList.of(true, false, true, false, true)), types))\n+                .build();\n+\n+        assertFalse(rows.isEmpty(), \"rows are empty\");\n+        assertThat(rows.getTotalRows()).isEqualTo(5);\n+        assertThat(rows.getColumns()).isEqualTo(columns);\n+        assertFalse(rows.hasUpdateCount());\n+\n+        assertThat(getAllValues(rows))\n+                .hasSize(2)\n+                .contains(ImmutableList.of(1, false))\n+                .contains(ImmutableList.of(3, false));\n+\n+        assertThat(rows.getLastSerializationException())\n+                .isPresent();\n+\n+        assertThat(rows.getLastSerializationException().get())\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 5:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+\n+        assertThat(exceptions)\n+                .hasSize(3);\n+\n+        assertThat(exceptions.get(0))\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 1:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+\n+        assertThat(exceptions.get(1))\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 3:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+\n+        assertThat(exceptions.get(2))\n+                .isInstanceOf(PrestoException.class)\n+                .hasMessage(\"Could not serialize type 'boolean' value at position 5:2\")\n+                .hasRootCauseMessage(\"This is bogus exception\");\n+    }\n+\n+    private static List<List<Object>> getAllValues(QueryResultRows rows)\n+    {\n+        ImmutableList.Builder<List<Object>> builder = ImmutableList.builder();\n+\n+        for (List<Object> values : rows) {\n+            builder.add(values);\n+        }\n+\n+        return builder.build();\n+    }\n+\n+    private static ConnectorSession getSession()\n+    {\n+        return TestingConnectorSession.builder()\n+                .build();\n+    }\n+\n+    private static Page createLongPage(long value)\n+    {\n+        BlockBuilder blockBuilder = BigintType.BIGINT.createBlockBuilder(null, 1);\n+        BigintType.BIGINT.writeLong(blockBuilder, value);\n+        return new Page(blockBuilder.build());\n+    }\n+\n+    private static Page createPage(List<List<Object>> values, List<Type> types)\n+    {\n+        ImmutableList.Builder<Block> blocks = ImmutableList.builder();\n+\n+        for (int i = 0; i < types.size(); i++) {\n+            Type currentType = types.get(i);\n+            BlockBuilder blockBuilder = currentType.createBlockBuilder(null, values.get(i).size());\n+\n+            for (Object value : values.get(i)) {\n+                if (currentType instanceof BigintType) {\n+                    BigintType.BIGINT.writeLong(blockBuilder, (Long) value);\n+                }\n+\n+                if (currentType instanceof BooleanType) {\n+                    BooleanType.BOOLEAN.writeBoolean(blockBuilder, (Boolean) value);\n+                }\n+\n+                if (currentType instanceof IntegerType) {\n+                    IntegerType.INTEGER.writeLong(blockBuilder, (Integer) value);\n+                }\n+\n+                if (currentType instanceof BogusType) {\n+                    BogusType.BOGUS_TYPE.writeBoolean(blockBuilder, (Boolean) value);\n+                }\n+            }\n+\n+            blocks.add(blockBuilder.build());\n+        }\n+\n+        return new Page(blocks.build().toArray(new Block[0]));\n+    }\n+\n+    public static final class BogusType\n+            extends AbstractType", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTI0OQ==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426311249", "bodyText": "Put the initialization at the start of the class", "author": "electrum", "createdAt": "2020-05-17T22:19:33Z", "path": "presto-tests/src/test/java/io/prestosql/tests/TestQuerySerializationFailures.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.tests;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractVariableWidthType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import org.testng.annotations.Test;\n+\n+import java.util.Set;\n+\n+import static io.prestosql.spi.type.StandardTypes.BOOLEAN;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestQuerySerializationFailures\n+        extends AbstractTestQueryFramework\n+{\n+    @Test\n+    public void shouldFailOnFirstSerializationError()\n+    {\n+        assertQueryFails(\"SELECT * FROM ( VALUES BOGUS(true), BOGUS(false), BOGUS(true) )\", \"Could not serialize type 'Bogus' value at position 1:1\");\n+    }\n+\n+    @Test\n+    public void shouldPass()\n+    {\n+        assertQuerySucceeds(\"SELECT * FROM ( VALUES BOGUS(false) )\");\n+    }\n+\n+    @Override", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTM4NA==", "url": "https://github.com/trinodb/trino/pull/2860#discussion_r426311384", "bodyText": "Make BogusType a top level test class in presto-main, then we can reuse it here (this module depends on the test-jar from presto-main)", "author": "electrum", "createdAt": "2020-05-17T22:20:55Z", "path": "presto-tests/src/test/java/io/prestosql/tests/TestQuerySerializationFailures.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.tests;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.Plugin;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractVariableWidthType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import org.testng.annotations.Test;\n+\n+import java.util.Set;\n+\n+import static io.prestosql.spi.type.StandardTypes.BOOLEAN;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestQuerySerializationFailures\n+        extends AbstractTestQueryFramework\n+{\n+    @Test\n+    public void shouldFailOnFirstSerializationError()\n+    {\n+        assertQueryFails(\"SELECT * FROM ( VALUES BOGUS(true), BOGUS(false), BOGUS(true) )\", \"Could not serialize type 'Bogus' value at position 1:1\");\n+    }\n+\n+    @Test\n+    public void shouldPass()\n+    {\n+        assertQuerySucceeds(\"SELECT * FROM ( VALUES BOGUS(false) )\");\n+    }\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        DistributedQueryRunner queryRunner = DistributedQueryRunner\n+                .builder(testSessionBuilder().build())\n+                .setNodeCount(4)\n+                .build();\n+\n+        queryRunner.installPlugin(new BogusPlugin());\n+\n+        return queryRunner;\n+    }\n+\n+    public static class BogusPlugin\n+            implements Plugin\n+    {\n+        @Override\n+        public Iterable<Type> getTypes()\n+        {\n+            return ImmutableList.of(BogusType.BOGUS_TYPE);\n+        }\n+\n+        @Override\n+        public Set<Class<?>> getFunctions()\n+        {\n+            return ImmutableSet.of(BogusFunctions.class);\n+        }\n+    }\n+\n+    public static final class BogusType", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "52af8c321efaa84fc72654820ead51598b05f708", "url": "https://github.com/trinodb/trino/commit/52af8c321efaa84fc72654820ead51598b05f708", "message": "Handle serialization errors gracefully on server side", "committedDate": "2020-06-07T20:24:45Z", "type": "commit"}, {"oid": "52af8c321efaa84fc72654820ead51598b05f708", "url": "https://github.com/trinodb/trino/commit/52af8c321efaa84fc72654820ead51598b05f708", "message": "Handle serialization errors gracefully on server side", "committedDate": "2020-06-07T20:24:45Z", "type": "forcePushed"}]}