{"pr_number": 4100, "pr_title": "Avoid busy waiting in the JDBC client.", "pr_createdAt": "2020-06-19T16:28:34Z", "pr_url": "https://github.com/trinodb/trino/pull/4100", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAyMDgwNQ==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r443020805", "bodyText": "Nit: we don't abbreviate variable names. Please call this semaphore.", "author": "electrum", "createdAt": "2020-06-19T19:58:33Z", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/PrestoResultSet.java", "diffHunk": "@@ -1807,29 +1808,31 @@ private static Number toNumber(Object value)\n         private final StatementClient client;\n         private final BlockingQueue<T> rowQueue = new ArrayBlockingQueue<>(MAX_QUEUED_ROWS);\n         private final CompletableFuture<Void> future;\n+        private final Semaphore s = new Semaphore(0);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2NTI5OQ==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r443065299", "bodyText": "Fair enough on this being hacky. :)\nI had a version with a sentinel... The problem with a sentinel on a blocking queue is that the queue might be full at the time you try to place the sentinel, then placing the sentinel itself would block.\nAnother way out is to go back to good old wait/notify.", "author": "lhofhansl", "createdAt": "2020-06-19T22:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAyMDgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2ODU4Mw==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r446668583", "bodyText": "move next to rowQueue and document semaphore meaning with a code comment (ie what does a permit represent)", "author": "findepi", "createdAt": "2020-06-28T16:08:26Z", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/PrestoResultSet.java", "diffHunk": "@@ -1807,23 +1808,25 @@ private static Number toNumber(Object value)\n         private final StatementClient client;\n         private final BlockingQueue<T> rowQueue = new ArrayBlockingQueue<>(MAX_QUEUED_ROWS);\n         private final CompletableFuture<Void> future;\n-        private Thread parent;\n+        private final Semaphore semaphore = new Semaphore(0);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2OTAwNg==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r446669006", "bodyText": "That is not correct from Iterator's API perspective.\nhasNext() can be invoked once, multiple times or not at all.\nSo, calling hasNext() must have no visible side effects.\n(It can still change the internal state as it is eg in com.google.common.base.AbstractIterator).\nBTW using that class could make the code simpler.\nThen perhaps all you would need is blocking on rowQueue, without a need for a semaphore?", "author": "findepi", "createdAt": "2020-06-28T16:12:18Z", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/PrestoResultSet.java", "diffHunk": "@@ -1842,16 +1845,15 @@ public void interrupt(InterruptedException e)\n         @Override\n         public boolean hasNext()\n         {\n-            if (!rowQueue.isEmpty()) {\n-                return true;\n+            try {\n+                semaphore.acquire();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc4NDkxMg==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r446784912", "bodyText": "You are right, and that is one place where AbstractIterator helps.\nI do not think I can get rid of the Semaphore, though. (See comments above, about the case when the queue is full. In that case the Future couldn't finish, without failing to indicate to the consumer that it is done.)", "author": "lhofhansl", "createdAt": "2020-06-29T05:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2OTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg4NzQ4NA==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r446887484", "bodyText": "Right.\nThis is where Either would be a fit, to represent a poison pill\nIn Java terms, this could be Optional with empty being the pill.\nAdmittedly not beautiful, but simplifies the flow.\nwdyt?", "author": "findepi", "createdAt": "2020-06-29T11:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2OTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMjY5Nw==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r447122697", "bodyText": "The problem is that you cannot always place the poison pill on the queue.\nI actually had a version with this, but I realized it would be tricky to get right when I added the code placing the poison pill (I called it Sentinel, but it's the same) to the Future, because that now might throw an InterruptedException, I couldn't figure out what to do in that case (loop until you can place the pill - the Future might never end? give up - the consumer might never get notified?) - without busy waiting for two conditions at least.\nOr do you mean some \"outside\" poison pill (not placed on the queue)? In that case it'd be necessary to have synchronization for this as well.", "author": "lhofhansl", "createdAt": "2020-06-29T17:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2OTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1ODI1Ng==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r447258256", "bodyText": "@lhofhansl thanks. We could assume the InterruptedException won't fly when queue is not full and then adding a volatile hasFailed could perhaps be sufficient technically, but this wouldn't make the code look pretty.", "author": "findepi", "createdAt": "2020-06-29T21:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2OTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxOTUxMA==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r447319510", "bodyText": "You'd have to somehow wait for that volatile to be changed and the queue. :)\n(I can't believe how tedious this is, and Java - and Guava - have no pattern for this readily available. All you need is a BlockingQueue that you can poke upon ending - something like a close() method that would unblock a waiting take() call or something.)", "author": "lhofhansl", "createdAt": "2020-06-29T23:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2OTAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1Njk5MA==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r447256990", "bodyText": "Just this:\n// If we got here and the queue is empty the future must be done. Check status. \n[MoreFutures.]getDone(future);", "author": "findepi", "createdAt": "2020-06-29T21:12:22Z", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/PrestoResultSet.java", "diffHunk": "@@ -1840,18 +1845,17 @@ public void interrupt(InterruptedException e)\n         }\n \n         @Override\n-        public boolean hasNext()\n+        protected T computeNext()\n         {\n-            if (!rowQueue.isEmpty()) {\n-                return true;\n+            try {\n+                semaphore.acquire();\n             }\n-            while (rowQueue.isEmpty() && !future.isDone()) {\n-                // making sure rowQueue has some records to process or return false\n-                if (parent.isInterrupted()) {\n-                    interrupt(new InterruptedException(\"parent thread interrupted\"));\n-                }\n+            catch (InterruptedException e) {\n+                interrupt(e);\n             }\n-            if (future.isCompletedExceptionally()) {\n+            if (rowQueue.isEmpty()) {\n+                // If we got here and the queue is empty the future must be done.\n+                // Check for ExecutionExceptions.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMDUyNg==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r447310526", "bodyText": "Thanks. Can't do the getDone for two reasons:\n\nThe future might not be done, yet. I.e. the work is done, but it might not be marked done yet, depending on thread scheduling. So we need to wait just in case.\nThe outside code expects to exceptions to be thrown as before", "author": "lhofhansl", "createdAt": "2020-06-29T23:11:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1Njk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMTAyMw==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r447311023", "bodyText": "I did fix the comment.", "author": "lhofhansl", "createdAt": "2020-06-29T23:13:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1Njk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxMTE3MQ==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r447311171", "bodyText": "you're right again. Please update the comment then. It should not be saying \"future must be done\".", "author": "findepi", "createdAt": "2020-06-29T23:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1Njk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxODM2MA==", "url": "https://github.com/trinodb/trino/pull/4100#discussion_r447318360", "bodyText": "Updated the comment again to be more precise.", "author": "lhofhansl", "createdAt": "2020-06-29T23:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1Njk5MA=="}], "type": "inlineReview"}, {"oid": "cb6511632b5c251e9da9cc4da74993de50ab73e4", "url": "https://github.com/trinodb/trino/commit/cb6511632b5c251e9da9cc4da74993de50ab73e4", "message": "Avoid busy waiting in the JDBC client.", "committedDate": "2020-06-29T23:35:11Z", "type": "commit"}]}