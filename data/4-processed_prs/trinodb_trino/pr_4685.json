{"pr_number": 4685, "pr_title": "Support for lazy dynamic filters for replicated joins", "pr_createdAt": "2020-08-04T16:30:08Z", "pr_url": "https://github.com/trinodb/trino/pull/4685", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNjU3Ng==", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488136576", "bodyText": "I'd inline this", "author": "dain", "createdAt": "2020-09-14T18:27:17Z", "path": "presto-main/src/main/java/io/prestosql/execution/scheduler/SourcePartitionedScheduler.java", "diffHunk": "@@ -478,6 +501,16 @@ public void close()\n         return newTasks.build();\n     }\n \n+    private Set<RemoteTask> createTaskOnRandomNode()\n+    {\n+        List<InternalNode> allNodes = splitPlacementPolicy.allNodes();\n+        checkState(allNodes.size() > 0, \"No nodes available\");\n+        int position = ThreadLocalRandom.current().nextInt(0, allNodes.size());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNjkzOA==", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488136938", "bodyText": "Should stage.getScheduledNodes() be empty?  If so, I'd check it at the start of the method.", "author": "dain", "createdAt": "2020-09-14T18:27:59Z", "path": "presto-main/src/main/java/io/prestosql/execution/scheduler/SourcePartitionedScheduler.java", "diffHunk": "@@ -478,6 +501,16 @@ public void close()\n         return newTasks.build();\n     }\n \n+    private Set<RemoteTask> createTaskOnRandomNode()\n+    {\n+        List<InternalNode> allNodes = splitPlacementPolicy.allNodes();\n+        checkState(allNodes.size() > 0, \"No nodes available\");\n+        int position = ThreadLocalRandom.current().nextInt(0, allNodes.size());\n+        InternalNode node = allNodes.get(position);\n+        checkState(!stage.getScheduledNodes().contains(node), \"Stage task is already scheduled on node\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzOTUyNw==", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488139527", "bodyText": "rename plan to fragment", "author": "dain", "createdAt": "2020-09-14T18:32:45Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -189,6 +192,41 @@ public void removeQuery(QueryId queryId)\n         dynamicFilterContexts.remove(queryId);\n     }\n \n+    /**\n+     * Dynamic filters are collected in same stage as the join operator. This can result in deadlock\n+     * for source stage joins and connectors that wait for dynamic filters before generating splits\n+     * (probe splits might be blocked on dynamic filters which require at least one probe task in order to be collected).\n+     * To overcome this issue an initial task is created for source stages running broadcast join operator.\n+     * This task allows for dynamic filters collection without any probe side splits being scheduled.\n+     */\n+    public boolean needsDynamicFiltersCollectingTask(QueryId queryId, PlanFragment plan)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MDcwNg==", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488140706", "bodyText": "I find the name needs... to be a bit strange.  It sounds like the command I need....  Consider renaming to isCollectingTaskNeeded.  Given this is the DynamicFilterService the DynamicFilter in the name seems redundant.", "author": "dain", "createdAt": "2020-09-14T18:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzOTUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0MjQ3Nw==", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488142477", "bodyText": "Sets.difference and Sets.union return a \"view\" which is computed for each iteration and will change when the underlying sets change.  I would make a defensive copy here using ImmutableSet.", "author": "dain", "createdAt": "2020-09-14T18:38:11Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -327,8 +365,28 @@ void collectDynamicFilters()\n \n     private static Set<DynamicFilterId> getLazyDynamicFilters(PlanFragment plan)\n     {\n-        // lazy dynamic filters cannot be consumed by the same stage where they are produced as it would result in query deadlock\n-        return difference(getProducedDynamicFilters(plan.getRoot()), getConsumedDynamicFilters(plan.getRoot()));\n+        // To prevent deadlock dynamic filter can be lazy only when:\n+        // 1. it's consumed by different stage from where it's produced\n+        // 2. or it's produced by replicated join in source stage. In such case an extra\n+        //    task is created that will collect dynamic filter and prevent deadlock.\n+        Set<DynamicFilterId> interStageDynamicFilters = difference(getProducedDynamicFilters(plan.getRoot()), getConsumedDynamicFilters(plan.getRoot()));\n+        return union(interStageDynamicFilters, getSourceStageInnerLazyDynamicFilters(plan));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0Njg3MQ==", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488146871", "bodyText": "same comment about Sets returning views", "author": "dain", "createdAt": "2020-09-14T18:46:15Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -327,8 +365,28 @@ void collectDynamicFilters()\n \n     private static Set<DynamicFilterId> getLazyDynamicFilters(PlanFragment plan)\n     {\n-        // lazy dynamic filters cannot be consumed by the same stage where they are produced as it would result in query deadlock\n-        return difference(getProducedDynamicFilters(plan.getRoot()), getConsumedDynamicFilters(plan.getRoot()));\n+        // To prevent deadlock dynamic filter can be lazy only when:\n+        // 1. it's consumed by different stage from where it's produced\n+        // 2. or it's produced by replicated join in source stage. In such case an extra\n+        //    task is created that will collect dynamic filter and prevent deadlock.\n+        Set<DynamicFilterId> interStageDynamicFilters = difference(getProducedDynamicFilters(plan.getRoot()), getConsumedDynamicFilters(plan.getRoot()));\n+        return union(interStageDynamicFilters, getSourceStageInnerLazyDynamicFilters(plan));\n+    }\n+\n+    @VisibleForTesting\n+    static Set<DynamicFilterId> getSourceStageInnerLazyDynamicFilters(PlanFragment plan)\n+    {\n+        if (!plan.getPartitioning().equals(SOURCE_DISTRIBUTION)) {\n+            // Only non-fixed source stages can have (replicated) lazy dynamic filters that are\n+            // produced and consumed within stage. This is because for such stages an extra\n+            // dynamic filtering collecting task can be added.\n+            return ImmutableSet.of();\n+        }\n+\n+        PlanNode planNode = plan.getRoot();\n+        Set<DynamicFilterId> innerStageDynamicFilters = intersection(getProducedDynamicFilters(planNode), getConsumedDynamicFilters(planNode));\n+        Set<DynamicFilterId> replicatedDynamicFilters = getReplicatedDynamicFilters(planNode);\n+        return intersection(innerStageDynamicFilters, replicatedDynamicFilters);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1MDA4Ng==", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488150086", "bodyText": "I'm pretty sure this can just be new SymbolReference(\"DF_SYMBOL1\")", "author": "dain", "createdAt": "2020-09-14T18:52:00Z", "path": "presto-main/src/test/java/io/prestosql/execution/scheduler/TestSourcePartitionedScheduler.java", "diffHunk": "@@ -446,6 +462,49 @@ public void testNoNewTaskScheduledWhenChildStageBufferIsOverutilized()\n         assertEquals(scheduleResult.getSplitsScheduled(), 0);\n     }\n \n+    @Test\n+    public void testDynamicFiltersUnblockedOnBlockedBuildSource()\n+    {\n+        StageExecutionPlan plan = createPlan(createBlockedSplitSource());\n+        NodeTaskMap nodeTaskMap = new NodeTaskMap(finalizerService);\n+        SqlStageExecution stage = createSqlStageExecution(plan, nodeTaskMap);\n+        NodeScheduler nodeScheduler = new NodeScheduler(new UniformNodeSelectorFactory(nodeManager, new NodeSchedulerConfig().setIncludeCoordinator(false), nodeTaskMap));\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        dynamicFilterService.registerQuery(\n+                QUERY_ID,\n+                ImmutableList::of,\n+                ImmutableSet.of(DYNAMIC_FILTER_ID),\n+                ImmutableSet.of(DYNAMIC_FILTER_ID),\n+                ImmutableSet.of(DYNAMIC_FILTER_ID));\n+        StageScheduler scheduler = newSourcePartitionedSchedulerAsStageScheduler(\n+                stage,\n+                Iterables.getOnlyElement(plan.getSplitSources().keySet()),\n+                Iterables.getOnlyElement(plan.getSplitSources().values()),\n+                new DynamicSplitPlacementPolicy(nodeScheduler.createNodeSelector(Optional.of(CONNECTOR_ID)), stage::getAllTasks),\n+                2,\n+                dynamicFilterService,\n+                () -> true);\n+\n+        Expression df1 = expression(\"DF_SYMBOL1\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1MDQwNQ==", "url": "https://github.com/trinodb/trino/pull/4685#discussion_r488150405", "bodyText": "no need for the line wrap here and the next one", "author": "dain", "createdAt": "2020-09-14T18:52:34Z", "path": "presto-main/src/test/java/io/prestosql/execution/scheduler/TestSourcePartitionedScheduler.java", "diffHunk": "@@ -446,6 +462,49 @@ public void testNoNewTaskScheduledWhenChildStageBufferIsOverutilized()\n         assertEquals(scheduleResult.getSplitsScheduled(), 0);\n     }\n \n+    @Test\n+    public void testDynamicFiltersUnblockedOnBlockedBuildSource()\n+    {\n+        StageExecutionPlan plan = createPlan(createBlockedSplitSource());\n+        NodeTaskMap nodeTaskMap = new NodeTaskMap(finalizerService);\n+        SqlStageExecution stage = createSqlStageExecution(plan, nodeTaskMap);\n+        NodeScheduler nodeScheduler = new NodeScheduler(new UniformNodeSelectorFactory(nodeManager, new NodeSchedulerConfig().setIncludeCoordinator(false), nodeTaskMap));\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(new FeaturesConfig());\n+        dynamicFilterService.registerQuery(\n+                QUERY_ID,\n+                ImmutableList::of,\n+                ImmutableSet.of(DYNAMIC_FILTER_ID),\n+                ImmutableSet.of(DYNAMIC_FILTER_ID),\n+                ImmutableSet.of(DYNAMIC_FILTER_ID));\n+        StageScheduler scheduler = newSourcePartitionedSchedulerAsStageScheduler(\n+                stage,\n+                Iterables.getOnlyElement(plan.getSplitSources().keySet()),\n+                Iterables.getOnlyElement(plan.getSplitSources().values()),\n+                new DynamicSplitPlacementPolicy(nodeScheduler.createNodeSelector(Optional.of(CONNECTOR_ID)), stage::getAllTasks),\n+                2,\n+                dynamicFilterService,\n+                () -> true);\n+\n+        Expression df1 = expression(\"DF_SYMBOL1\");\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                QUERY_ID,\n+                ImmutableList.of(\n+                        new DynamicFilters.Descriptor(DYNAMIC_FILTER_ID, df1)),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5f8b4d50becd1961ff70535c16f27113aeee9874", "url": "https://github.com/trinodb/trino/commit/5f8b4d50becd1961ff70535c16f27113aeee9874", "message": "Support for lazy dynamic filters for replicated joins", "committedDate": "2020-09-15T12:33:04Z", "type": "commit"}, {"oid": "5b18e277e919f015a25c0c07c329f0c80567603c", "url": "https://github.com/trinodb/trino/commit/5b18e277e919f015a25c0c07c329f0c80567603c", "message": "Simplify TestCoordinatorDynamicFiltering tests", "committedDate": "2020-09-15T12:33:04Z", "type": "commit"}, {"oid": "5b18e277e919f015a25c0c07c329f0c80567603c", "url": "https://github.com/trinodb/trino/commit/5b18e277e919f015a25c0c07c329f0c80567603c", "message": "Simplify TestCoordinatorDynamicFiltering tests", "committedDate": "2020-09-15T12:33:04Z", "type": "forcePushed"}]}