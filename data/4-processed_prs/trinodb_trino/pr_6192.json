{"pr_number": 6192, "pr_title": "Support WINDOW clause", "pr_createdAt": "2020-12-03T12:49:50Z", "pr_url": "https://github.com/trinodb/trino/pull/6192", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1Mjk4MQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r536452981", "bodyText": "I think we need to do the following:\n\nRename Window to Over. Over would have an Expression and a Window as children.\nWindow becomes an interface which could be either a WindowReference that contains an Identifier or a WindowSpecification. WindowSpecification would contain existingWindowName, partitionBy, orderBy and frame.\nWindowDefinition would contain an Identifier (the name) and a WiindowSpecification.\n\nSo,\nclass Over\n    Expression expression\n    Window window\n\ninterface Window\n\nclass WindowReference implements Window\n    Identifier name\n\nclass WindowSpecification implements Window\n    Identifier existingWindowName\n    List<Expression> partitionBy\n    Expression orderBy\n    WindowFrame frame\n\nclass WindowDefinition\n    Identifier name\n    WindowSpecification specification", "author": "martint", "createdAt": "2020-12-05T00:02:14Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/Window.java", "diffHunk": "@@ -20,33 +20,55 @@\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n public class Window\n         extends Node\n {\n+    private final Optional<Identifier> existingWindowName;\n+    private final boolean specification;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwNzI2OQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r537107269", "bodyText": "What is Expression in class Over?\nWhy is the current flat structure no good?", "author": "kasiafi", "createdAt": "2020-12-06T19:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1Mjk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYxMzQ3MQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r537613471", "bodyText": "What is Expression in class Over?\n\nSorry, I was thinking about Window/Over as a node that contains a FunctionCall, but it's the other way around.\n\nWhy is the current flat structure no good?\n\nWhy I don't like about it is that it mixes two usages into a single union structure. Specifically, it encodes both a simple reference to a window:\n\nf() OVER w\nf() OVER (w PARTITION BY x ORDER BY y)\n\nThese are very different syntactic structures. In the first one, it's a window function with a window reference. In the second one, it's a window function with an inline specification.\nFor instance, in the current structure, it would be possible to create a WindowDefinition with Window that is not a specification programmatically, and that would be syntactically invalid. It'd be equivalent to: WINDOW x AS y\nGiven the above, the structure would be:\ninterface Window\n\nclass WindowReference implements Window\n    Identifier name\n\nclass WindowSpecification implements Window\n    Identifier existingWindowName\n    List<Expression> partitionBy\n    Expression orderBy\n    WindowFrame frame\n\nclass WindowDefinition\n    Identifier name\n    WindowSpecification specification\n\nSo no need for an Over class.", "author": "martint", "createdAt": "2020-12-07T15:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1Mjk4MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODIwNw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557788207", "bodyText": "I don't think this is necessary. The cast below will produce a similar message if it can't be performed.", "author": "martint", "createdAt": "2021-01-15T00:32:20Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -970,7 +972,14 @@ protected Type visitNullLiteral(NullLiteral node, StackableAstVisitorContext<Con\n         protected Type visitFunctionCall(FunctionCall node, StackableAstVisitorContext<Context> context)\n         {\n             if (node.getWindow().isPresent()) {\n-                Window window = node.getWindow().get();\n+                Window windowReferenceOrSpecification = node.getWindow().get();\n+\n+                if (windowReferenceOrSpecification instanceof WindowReference || windowReferenceOrSpecification instanceof WindowSpecification && ((WindowSpecification) windowReferenceOrSpecification).getExistingWindowName().isPresent()) {\n+                    throw semanticException(NOT_SUPPORTED, (Node) windowReferenceOrSpecification, \"Reference to other window definition is not yet supported\");\n+                }\n+\n+                checkState(windowReferenceOrSpecification instanceof WindowSpecification, \"unexpected window: \" + windowReferenceOrSpecification.getClass().getSimpleName());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ1NTg0OQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r558455849", "bodyText": "This check is introduced in the first commit, which adds support for WINDOW clause in grammar and AST. It is removed in the second commit, where WINDOW clause is implemented. I think the two commits will be eventually squashed and the redundant check will vanish.", "author": "kasiafi", "createdAt": "2021-01-15T17:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODU5Mw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557788593", "bodyText": "Same here. This check is unnecessary, as the cast below will fail with a similar error if it can't be performed.", "author": "martint", "createdAt": "2021-01-15T00:33:47Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1975,7 +1981,12 @@ private void analyzeWindowFunctions(QuerySpecification node, List<Expression> ou\n                     throw semanticException(NOT_SUPPORTED, windowFunction, \"Window function with ORDER BY is not supported\");\n                 }\n \n-                Window window = windowFunction.getWindow().get();\n+                Window windowReferenceOrSpecification = windowFunction.getWindow().get();\n+                if (windowReferenceOrSpecification instanceof WindowReference || windowReferenceOrSpecification instanceof WindowSpecification && ((WindowSpecification) windowReferenceOrSpecification).getExistingWindowName().isPresent()) {\n+                    throw semanticException(NOT_SUPPORTED, (Node) windowReferenceOrSpecification, \"Reference to other window definition is not yet supported\");\n+                }\n+                checkState(windowReferenceOrSpecification instanceof WindowSpecification, \"unexpected window: \" + windowReferenceOrSpecification.getClass().getSimpleName());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ2MzMxMw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r558463313", "bodyText": "same as above", "author": "kasiafi", "createdAt": "2021-01-15T17:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODY5Nw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557788697", "bodyText": "Check is unnecessary. See comments above.", "author": "martint", "createdAt": "2021-01-15T00:34:12Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/QueryPlanner.java", "diffHunk": "@@ -814,7 +819,12 @@ private PlanBuilder window(Node node, PlanBuilder subPlan, List<FunctionCall> wi\n         for (FunctionCall windowFunction : scopeAwareDistinct(subPlan, windowFunctions)) {\n             checkArgument(windowFunction.getFilter().isEmpty(), \"Window functions cannot have filter\");\n \n-            Window window = windowFunction.getWindow().get();\n+            Window windowReferenceOrSpecification = windowFunction.getWindow().get();\n+            if (windowReferenceOrSpecification instanceof WindowReference || windowReferenceOrSpecification instanceof WindowSpecification && ((WindowSpecification) windowReferenceOrSpecification).getExistingWindowName().isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, (Node) windowReferenceOrSpecification, \"Reference to other window definition is not yet supported\");\n+            }\n+            checkState(windowReferenceOrSpecification instanceof WindowSpecification, \"unexpected window: \" + windowReferenceOrSpecification.getClass().getSimpleName());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ2MzM0OQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r558463349", "bodyText": "same as above", "author": "kasiafi", "createdAt": "2021-01-15T17:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MDQ0Ng==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557790446", "bodyText": "What if they are both a WindowReference that match each other? This will cause them to return false always.", "author": "martint", "createdAt": "2021-01-15T00:39:43Z", "path": "core/trino-main/src/test/java/io/trino/sql/planner/assertions/FunctionCallProvider.java", "diffHunk": "@@ -138,7 +139,8 @@ public boolean equals(Object object)\n \n             return Objects.equals(name, other.getName()) &&\n                     other.getWindow().isPresent() &&\n-                    Objects.equals(frame, other.getWindow().get().getFrame()) &&\n+                    other.getWindow().get() instanceof WindowSpecification &&", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ1NTY1OQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r558455659", "bodyText": "This Provider is used for plan assertions involving WindowNode. The provided FunctionCall is a way of describing what WindowNode.Function is expected. Because FunctionCall and WindowNode.Function are different abstractions, the Provider is constructed with Frame and not with Window (other window properties do not belong in WindowNode.Function).\nThe equals method should never be called on ExpectedWindowFunctionCall. I don't see a purpose for it and it's not even symmetric.\nAlso, the Frame passed to the Provider is never accessed or compared with the actual value.\nI suggest that we clean up this class as a follow-up.\nFor now, I believe it is fair to adjust the equals() method the way I did, since the left-hand-side FunctionCall cannot have a WindowReference.", "author": "kasiafi", "createdAt": "2021-01-15T17:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MDQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MDk1MA==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557790950", "bodyText": "Unrelated change", "author": "martint", "createdAt": "2021-01-15T00:41:09Z", "path": "core/trino-parser/src/main/java/io/trino/sql/ExpressionFormatter.java", "diffHunk": "@@ -712,7 +659,7 @@ protected String visitRowDataType(RowDataType node, Void context)\n         {\n             return node.getFields().stream()\n                     .map(this::process)\n-                    .collect(Collectors.joining(\", \", \"ROW(\", \")\"));\n+                    .collect(joining(\", \", \"ROW(\", \")\"));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTEwMw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557791103", "bodyText": "Unnecessary check. See comments above.", "author": "martint", "createdAt": "2021-01-15T00:41:42Z", "path": "core/trino-parser/src/main/java/io/trino/sql/ExpressionFormatter.java", "diffHunk": "@@ -849,6 +796,74 @@ private static String formatSortItems(List<SortItem> sortItems)\n                 .iterator());\n     }\n \n+    private static String formatWindow(Window window)\n+    {\n+        if (window instanceof WindowReference) {\n+            return formatExpression(((WindowReference) window).getName());\n+        }\n+\n+        checkState(window instanceof WindowSpecification, \"unexpected window: \" + window.getClass().getSimpleName());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MzQ0OA==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557793448", "bodyText": "Unrelated change", "author": "martint", "createdAt": "2021-01-15T00:48:48Z", "path": "core/trino-parser/src/main/java/io/trino/sql/ExpressionFormatter.java", "diffHunk": "@@ -739,7 +686,7 @@ protected String visitGenericDataType(GenericDataType node, Void context)\n             if (!node.getArguments().isEmpty()) {\n                 result.append(node.getArguments().stream()\n                         .map(this::process)\n-                        .collect(Collectors.joining(\", \", \"(\", \")\")));\n+                        .collect(joining(\", \", \"(\", \")\")));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5NDMyMw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557794323", "bodyText": "Break the .append chain across multiple lines for clarity", "author": "martint", "createdAt": "2021-01-15T00:51:46Z", "path": "core/trino-parser/src/main/java/io/trino/sql/ExpressionFormatter.java", "diffHunk": "@@ -849,6 +796,74 @@ private static String formatSortItems(List<SortItem> sortItems)\n                 .iterator());\n     }\n \n+    private static String formatWindow(Window window)\n+    {\n+        if (window instanceof WindowReference) {\n+            return formatExpression(((WindowReference) window).getName());\n+        }\n+\n+        checkState(window instanceof WindowSpecification, \"unexpected window: \" + window.getClass().getSimpleName());\n+        return formatWindowSpecification((WindowSpecification) window);\n+    }\n+\n+    static String formatWindowSpecification(WindowSpecification windowSpecification)\n+    {\n+        List<String> parts = new ArrayList<>();\n+\n+        if (windowSpecification.getExistingWindowName().isPresent()) {\n+            parts.add(formatExpression(windowSpecification.getExistingWindowName().get()));\n+        }\n+        if (!windowSpecification.getPartitionBy().isEmpty()) {\n+            parts.add(\"PARTITION BY \" + windowSpecification.getPartitionBy().stream()\n+                    .map(ExpressionFormatter::formatExpression)\n+                    .collect(joining(\", \")));\n+        }\n+        if (windowSpecification.getOrderBy().isPresent()) {\n+            parts.add(formatOrderBy(windowSpecification.getOrderBy().get()));\n+        }\n+        if (windowSpecification.getFrame().isPresent()) {\n+            parts.add(formatFrame(windowSpecification.getFrame().get()));\n+        }\n+\n+        return '(' + Joiner.on(' ').join(parts) + ')';\n+    }\n+\n+    private static String formatFrame(WindowFrame windowFrame)\n+    {\n+        StringBuilder builder = new StringBuilder();\n+\n+        builder.append(windowFrame.getType().toString()).append(' ');", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5NDk0Nw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557794947", "bodyText": "We may want to format these across multiple lines if there are many:\nWINDOW x AS (....)\n\nor\nWINDOW\n     x AS (...),\n     y AS (...),\n     ...", "author": "martint", "createdAt": "2021-01-15T00:54:00Z", "path": "core/trino-parser/src/main/java/io/trino/sql/SqlFormatter.java", "diffHunk": "@@ -314,6 +315,13 @@ protected Void visitQuerySpecification(QuerySpecification node, Integer indent)\n                         .append('\\n');\n             }\n \n+            if (!node.getWindows().isEmpty()) {\n+                append(indent, \"WINDOW \" + node.getWindows().stream()\n+                        .map(definition -> formatExpression(definition.getName()) + \" AS \" + formatWindowSpecification(definition.getWindow()))\n+                        .collect(joining(\", \")))\n+                        .append('\\n');", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5NjEzMg==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557796132", "bodyText": "window.ifPresent(xxx -> checkArgument(....))", "author": "martint", "createdAt": "2021-01-15T00:57:33Z", "path": "core/trino-parser/src/main/java/io/trino/sql/tree/FunctionCall.java", "diffHunk": "@@ -55,6 +56,9 @@ public FunctionCall(\n         super(location);\n         requireNonNull(name, \"name is null\");\n         requireNonNull(window, \"window is null\");\n+        if (window.isPresent()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5OTE4Mw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557799183", "bodyText": "Unrelated change? Move to a separate commit", "author": "martint", "createdAt": "2021-01-15T01:07:27Z", "path": "core/trino-main/src/test/java/io/trino/sql/analyzer/TestAnalyzer.java", "diffHunk": "@@ -651,7 +654,7 @@ public void testNonAggregate()\n                 .hasErrorCode(EXPRESSION_NOT_AGGREGATE);\n         assertFails(\"SELECT count(*) over (ORDER BY count(*) ROWS BETWEEN b PRECEDING AND a PRECEDING) FROM t1 GROUP BY b\")\n                 .hasErrorCode(EXPRESSION_NOT_AGGREGATE);\n-        assertFails(\"SELECT count(*) over (ORDER BY count(*) ROWS BETWEEN a PRECEDING AND UNBOUNDED PRECEDING) FROM t1 GROUP BY b\")\n+        assertFails(\"SELECT count(*) over (ORDER BY count(*) ROWS BETWEEN a PRECEDING AND UNBOUNDED FOLLOWING) FROM t1 GROUP BY b\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5OTk2Nw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557799967", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n          \n          \n            \n                        windowDefinitions.put(NodeRef.of(query), new LinkedHashMap<>());\n          \n          \n            \n                    }\n          \n          \n            \n                    windowDefinitions.get(NodeRef.of(query)).put(name, window);\n          \n          \n            \n                    windowDefinitions.computeIfAbsent(NodeRef.of(query), LinkedHashMap::new)\n          \n          \n            \n                            .put(name, window);", "author": "martint", "createdAt": "2021-01-15T01:09:45Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/Analysis.java", "diffHunk": "@@ -449,6 +457,40 @@ public void recordSubqueries(Node node, ExpressionAnalysis expressionAnalysis)\n         return unmodifiableList(quantifiedComparisonSubqueries.get(NodeRef.of(node)));\n     }\n \n+    public void addWindowDefinition(QuerySpecification query, String name, ResolvedWindow window)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            windowDefinitions.put(NodeRef.of(query), new LinkedHashMap<>());\n+        }\n+        windowDefinitions.get(NodeRef.of(query)).put(name, window);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgwMDc1MQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557800751", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n          \n          \n            \n                        return null;\n          \n          \n            \n                    }\n          \n          \n            \n                    return windowDefinitions.get(NodeRef.of(query)).get(name);\n          \n          \n            \n                    Map<String, ResolvedWindow> windows = windowDefinitions.get(NodeRef.of(query));\n          \n          \n            \n                    if (windows != null) {\n          \n          \n            \n                        return windows.get(name);\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    return null;\n          \n      \n    \n    \n  \n\nNot sure we should return null (vs fail), though. If this method is called for a non-existent name, it's probably an indication of an analyzer bug.", "author": "martint", "createdAt": "2021-01-15T01:12:15Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/Analysis.java", "diffHunk": "@@ -449,6 +457,40 @@ public void recordSubqueries(Node node, ExpressionAnalysis expressionAnalysis)\n         return unmodifiableList(quantifiedComparisonSubqueries.get(NodeRef.of(node)));\n     }\n \n+    public void addWindowDefinition(QuerySpecification query, String name, ResolvedWindow window)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            windowDefinitions.put(NodeRef.of(query), new LinkedHashMap<>());\n+        }\n+        windowDefinitions.get(NodeRef.of(query)).put(name, window);\n+    }\n+\n+    public ResolvedWindow getWindowDefinition(QuerySpecification query, String name)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            return null;\n+        }\n+        return windowDefinitions.get(NodeRef.of(query)).get(name);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2OTA3MA==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r558569070", "bodyText": "If this method is called and the result is expected (i.e. not null is expected), the call is always followed by a check.\nI didn't inline the check, because there is another use of this method which actually should return null. This is when I need to assert that there's no duplicate name of window definition.", "author": "kasiafi", "createdAt": "2021-01-15T20:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgwMDc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgwMTEwOA==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r557801108", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (windowDefinitions.containsKey(NodeRef.of(query))) {\n          \n          \n            \n                        return ImmutableList.copyOf(windowDefinitions.get(NodeRef.of(query)).values());\n          \n          \n            \n                    }\n          \n          \n            \n                    return ImmutableList.of();\n          \n          \n            \n                    Map<String, ResolvedWindow> windows = windowDefinitions.get(NodeRef.of(query));\n          \n          \n            \n            \n          \n          \n            \n                    if (windows != null) {\n          \n          \n            \n                        return ImmutableList.copyOf(windows.values());\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return ImmutableList.of();", "author": "martint", "createdAt": "2021-01-15T01:13:26Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/Analysis.java", "diffHunk": "@@ -449,6 +457,40 @@ public void recordSubqueries(Node node, ExpressionAnalysis expressionAnalysis)\n         return unmodifiableList(quantifiedComparisonSubqueries.get(NodeRef.of(node)));\n     }\n \n+    public void addWindowDefinition(QuerySpecification query, String name, ResolvedWindow window)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            windowDefinitions.put(NodeRef.of(query), new LinkedHashMap<>());\n+        }\n+        windowDefinitions.get(NodeRef.of(query)).put(name, window);\n+    }\n+\n+    public ResolvedWindow getWindowDefinition(QuerySpecification query, String name)\n+    {\n+        if (!windowDefinitions.containsKey(NodeRef.of(query))) {\n+            return null;\n+        }\n+        return windowDefinitions.get(NodeRef.of(query)).get(name);\n+    }\n+\n+    public List<ResolvedWindow> getWindowDefinitions(QuerySpecification query)\n+    {\n+        if (windowDefinitions.containsKey(NodeRef.of(query))) {\n+            return ImmutableList.copyOf(windowDefinitions.get(NodeRef.of(query)).values());\n+        }\n+        return ImmutableList.of();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2OTcyNA==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560569724", "bodyText": "We should resolve window names using proper SQL identifier semantics.", "author": "martint", "createdAt": "2021-01-19T23:27:29Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1955,6 +1969,134 @@ else if (actualType instanceof RowType) {\n             return createAndAssignScope(node, scope, fields);\n         }\n \n+        private void analyzeWindowDefinitions(QuerySpecification node, Scope scope)\n+        {\n+            for (WindowDefinition windowDefinition : node.getWindows()) {\n+                String name = windowDefinition.getName().getValue().toLowerCase(ENGLISH);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY1MTA0MA==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562651040", "bodyText": "It seems from the spec that we generally do not compare identifiers correctly (spec p. 193, 27 and following).\nThis comparison here is consistent with what we do in other places (e.g. when analyzing WITH queries).\nI think we'd rather fix the issue globally than special-case for WINDOW.", "author": "kasiafi", "createdAt": "2021-01-22T14:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2OTcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjcyMzAxNw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562723017", "bodyText": "This is a new, independent feature, so let\u2019s do it right. I agree that we need to fix it elsewhere, too (it\u2019s complicated due to connectors), but if we don\u2019t do this one correctly from the get go, we\u2019ll be breaking backward compatibility in the future.", "author": "martint", "createdAt": "2021-01-22T15:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU2OTcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3MTIxMg==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560571212", "bodyText": "Is the resolution scope for window names strictly within a \"query specification\", or can they come from an outer query specification (e.g., when there are no column references involved)?", "author": "martint", "createdAt": "2021-01-19T23:31:17Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1955,6 +1969,134 @@ else if (actualType instanceof RowType) {\n             return createAndAssignScope(node, scope, fields);\n         }\n \n+        private void analyzeWindowDefinitions(QuerySpecification node, Scope scope)\n+        {\n+            for (WindowDefinition windowDefinition : node.getWindows()) {\n+                String name = windowDefinition.getName().getValue().toLowerCase(ENGLISH);\n+\n+                if (analysis.getWindowDefinition(node, name) != null) {\n+                    throw semanticException(DUPLICATE_WINDOW_NAME, windowDefinition, \"WINDOW name '%s' specified more than once\", name);\n+                }\n+\n+                ResolvedWindow resolvedWindow = resolveWindowSpecification(node, windowDefinition.getWindow());\n+\n+                // Analyze window after it is resolved, because resolving might provide necessary information, e.g. ORDER BY necessary for frame analysis.\n+                // Analyze only newly introduced window properties. Properties of the referenced window have been already analyzed.\n+                analyzeWindow(node, resolvedWindow, scope, windowDefinition.getWindow());\n+\n+                analysis.addWindowDefinition(node, name, resolvedWindow);\n+            }\n+        }\n+\n+        private ResolvedWindow resolveWindowSpecification(QuerySpecification querySpecification, Window window)\n+        {\n+            if (window instanceof WindowReference) {\n+                WindowReference windowReference = (WindowReference) window;\n+                String referencedName = windowReference.getName().getValue().toLowerCase(ENGLISH);\n+                ResolvedWindow referencedWindow = analysis.getWindowDefinition(querySpecification, referencedName);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU3MTI4Nw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562571287", "bodyText": "As we discussed, outer window references are not allowed.", "author": "kasiafi", "createdAt": "2021-01-22T11:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3MTIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU3MTg2NA==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560571864", "bodyText": "This check is unnecessary due to the cast below.", "author": "martint", "createdAt": "2021-01-19T23:33:13Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1955,6 +1969,134 @@ else if (actualType instanceof RowType) {\n             return createAndAssignScope(node, scope, fields);\n         }\n \n+        private void analyzeWindowDefinitions(QuerySpecification node, Scope scope)\n+        {\n+            for (WindowDefinition windowDefinition : node.getWindows()) {\n+                String name = windowDefinition.getName().getValue().toLowerCase(ENGLISH);\n+\n+                if (analysis.getWindowDefinition(node, name) != null) {\n+                    throw semanticException(DUPLICATE_WINDOW_NAME, windowDefinition, \"WINDOW name '%s' specified more than once\", name);\n+                }\n+\n+                ResolvedWindow resolvedWindow = resolveWindowSpecification(node, windowDefinition.getWindow());\n+\n+                // Analyze window after it is resolved, because resolving might provide necessary information, e.g. ORDER BY necessary for frame analysis.\n+                // Analyze only newly introduced window properties. Properties of the referenced window have been already analyzed.\n+                analyzeWindow(node, resolvedWindow, scope, windowDefinition.getWindow());\n+\n+                analysis.addWindowDefinition(node, name, resolvedWindow);\n+            }\n+        }\n+\n+        private ResolvedWindow resolveWindowSpecification(QuerySpecification querySpecification, Window window)\n+        {\n+            if (window instanceof WindowReference) {\n+                WindowReference windowReference = (WindowReference) window;\n+                String referencedName = windowReference.getName().getValue().toLowerCase(ENGLISH);\n+                ResolvedWindow referencedWindow = analysis.getWindowDefinition(querySpecification, referencedName);\n+                if (referencedWindow == null) {\n+                    throw semanticException(INVALID_WINDOW_REFERENCE, windowReference.getName(), \"Cannot resolve WINDOW name \" + referencedName);\n+                }\n+\n+                return new ResolvedWindow(\n+                        referencedWindow.getPartitionBy(),\n+                        referencedWindow.getOrderBy(),\n+                        referencedWindow.getFrame(),\n+                        !referencedWindow.getPartitionBy().isEmpty(),\n+                        referencedWindow.getOrderBy().isPresent(),\n+                        referencedWindow.getFrame().isPresent());\n+            }\n+\n+            checkArgument(window instanceof WindowSpecification, \"unexpected window: \" + window.getClass().getSimpleName());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4Mjg2NQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560582865", "bodyText": "Technically, any exact numeric type with scale 0 is allowed (e.g., TINYINT, SMALLINT, DECIMAL(p, 0))", "author": "martint", "createdAt": "2021-01-20T00:02:49Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1137,17 +1077,138 @@ else if (node.getArguments().size() > 127) {\n             return setExpressionType(node, type);\n         }\n \n-        private void analyzeFrameRangeOffset(Expression offsetValue, FrameBound.Type boundType, StackableAstVisitorContext<Context> context, WindowSpecification window)\n+        private void analyzeWindow(ResolvedWindow window, StackableAstVisitorContext<Context> context, Node originalNode)\n+        {\n+            // check no nested window functions\n+            ImmutableList.Builder<Node> childNodes = ImmutableList.builder();\n+            if (!window.isPartitionByInherited()) {\n+                childNodes.addAll(window.getPartitionBy());\n+            }\n+            if (!window.isOrderByInherited()) {\n+                window.getOrderBy().ifPresent(orderBy -> childNodes.addAll(orderBy.getSortItems()));\n+            }\n+            if (!window.isFrameInherited()) {\n+                window.getFrame().ifPresent(childNodes::add);\n+            }\n+            List<FunctionCall> nestedWindowFunctions = extractWindowFunctions(childNodes.build());\n+            if (!nestedWindowFunctions.isEmpty()) {\n+                throw semanticException(NESTED_WINDOW, nestedWindowFunctions.get(0), \"Cannot nest window functions inside window specification\");\n+            }\n+\n+            if (!window.isPartitionByInherited()) {\n+                for (Expression expression : window.getPartitionBy()) {\n+                    process(expression, context);\n+                    Type type = getExpressionType(expression);\n+                    if (!type.isComparable()) {\n+                        throw semanticException(TYPE_MISMATCH, expression, \"%s is not comparable, and therefore cannot be used in window function PARTITION BY\", type);\n+                    }\n+                }\n+            }\n+\n+            if (!window.isOrderByInherited()) {\n+                for (SortItem sortItem : getSortItemsFromOrderBy(window.getOrderBy())) {\n+                    process(sortItem.getSortKey(), context);\n+                    Type type = getExpressionType(sortItem.getSortKey());\n+                    if (!type.isOrderable()) {\n+                        throw semanticException(TYPE_MISMATCH, sortItem, \"%s is not orderable, and therefore cannot be used in window function ORDER BY\", type);\n+                    }\n+                }\n+            }\n+\n+            if (window.getFrame().isPresent() && !window.isFrameInherited()) {\n+                WindowFrame frame = window.getFrame().get();\n+\n+                // validate frame start and end types\n+                FrameBound.Type startType = frame.getStart().getType();\n+                FrameBound.Type endType = frame.getEnd().orElse(new FrameBound(CURRENT_ROW)).getType();\n+                if (startType == UNBOUNDED_FOLLOWING) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame start cannot be UNBOUNDED FOLLOWING\");\n+                }\n+                if (endType == UNBOUNDED_PRECEDING) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame end cannot be UNBOUNDED PRECEDING\");\n+                }\n+                if ((startType == CURRENT_ROW) && (endType == PRECEDING)) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame starting from CURRENT ROW cannot end with PRECEDING\");\n+                }\n+                if ((startType == FOLLOWING) && (endType == PRECEDING)) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame starting from FOLLOWING cannot end with PRECEDING\");\n+                }\n+                if ((startType == FOLLOWING) && (endType == CURRENT_ROW)) {\n+                    throw semanticException(INVALID_WINDOW_FRAME, frame, \"Window frame starting from FOLLOWING cannot end with CURRENT ROW\");\n+                }\n+\n+                // analyze frame offset values\n+                if (frame.getType() == ROWS) {\n+                    if (frame.getStart().getValue().isPresent()) {\n+                        Expression startValue = frame.getStart().getValue().get();\n+                        Type type = process(startValue, context);\n+                        if (!type.equals(INTEGER) && !type.equals(BIGINT)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU3NDA3Ng==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562574076", "bodyText": "Right. However this is a preexisting issue (I only extracted this code to a separate method). This could be fixed in a separate follow-up PR.", "author": "kasiafi", "createdAt": "2021-01-22T11:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU4Mjg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDU5OTU3OQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560599579", "bodyText": "Place the Analysis argument in the first position for clarity.", "author": "martint", "createdAt": "2021-01-20T00:52:05Z", "path": "core/trino-main/src/main/java/io/trino/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1956,6 +2031,23 @@ public static ExpressionAnalysis analyzeExpression(\n                 analyzer.getWindowFunctions());\n     }\n \n+    private static void updateAnalysis(ExpressionAnalyzer analyzer, Analysis analysis, Session session, AccessControl accessControl)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMjI1NQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560602255", "bodyText": "Technically, this should happen after aggregations.", "author": "martint", "createdAt": "2021-01-20T00:59:41Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/QueryPlanner.java", "diffHunk": "@@ -367,6 +363,7 @@ protected PlanNode visitPlan(PlanNode node, RewriteContext<Void> context)\n     public RelationPlan plan(QuerySpecification node)\n     {\n         PlanBuilder builder = planFrom(node);\n+        builder = planWindowDefinitions(builder, analysis.getWindowDefinitions(node), node);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU4MTM2OQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562581369", "bodyText": "I found out this is not needed at all.\nBecause all the window specifications of WINDOW clause were analyzed in the right scope (which is the FROM scope), then thanks to TranslationMap they should be planned properly (that is, using source symbols) no matter where they appear. There's no need to plan them \"in advance\" at the bottom of the plan.\nLazy planning will also solve the issue of unnecessarily planning window specifications which are never referenced.", "author": "kasiafi", "createdAt": "2021-01-22T11:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwMjI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwNDI1Nw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560604257", "bodyText": "We should verify that any subquery in a window clause that's not being referenced is eventually removed from the plan.", "author": "martint", "createdAt": "2021-01-20T01:05:21Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/QueryPlanner.java", "diffHunk": "@@ -505,6 +502,39 @@ private PlanBuilder planFrom(QuerySpecification node)\n                 new ValuesNode(idAllocator.getNextId(), 1));\n     }\n \n+    // TODO this could be optimized to plan only the window specification parts that are actually used", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU4MTg1OQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562581859", "bodyText": "See the previous comment.", "author": "kasiafi", "createdAt": "2021-01-22T11:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwNDI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwNzE3Mg==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560607172", "bodyText": "Add a test for the opposite case: a window in the outer query cannot be referenced by the inner query.", "author": "martint", "createdAt": "2021-01-20T01:13:41Z", "path": "core/trino-main/src/test/java/io/trino/sql/analyzer/TestAnalyzer.java", "diffHunk": "@@ -876,6 +879,196 @@ public void testNaturalJoinNotSupported()\n                 .hasErrorCode(NOT_SUPPORTED);\n     }\n \n+    @Test\n+    public void testWindowClause()\n+    {\n+        assertFails(\"SELECT * FROM t1 WINDOW w AS (PARTITION BY a), w AS (PARTITION BY a)\")\n+                .hasErrorCode(DUPLICATE_WINDOW_NAME);\n+\n+        assertFails(\"SELECT * FROM t1 WINDOW w AS (PARTITION BY a), w AS (ORDER BY b)\")\n+                .hasErrorCode(DUPLICATE_WINDOW_NAME);\n+\n+        assertFails(\"SELECT * FROM t1 WINDOW w AS (), w1 as (), w AS (w)\")\n+                .hasErrorCode(DUPLICATE_WINDOW_NAME);\n+\n+        // window definitions with the same names are allowed in different query specifications (in this case, outer and inner query)\n+        analyze(\"SELECT * FROM (SELECT * FROM t1 WINDOW w AS (PARTITION BY a)) \" +\n+                \"WINDOW w AS (PARTITION BY a)\");\n+\n+        // window definition in inner query is not visible in outer query", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwODYwNQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560608605", "bodyText": "Why did this change?", "author": "martint", "createdAt": "2021-01-20T01:17:56Z", "path": "core/trino-main/src/test/java/io/trino/sql/analyzer/TestAnalyzer.java", "diffHunk": "@@ -990,7 +1183,7 @@ public void testWindowFrameTypeRange()\n \n         assertFails(\"SELECT array_agg(x) OVER (RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING) FROM (VALUES 1) T(x)\")\n                 .hasErrorCode(MISSING_ORDER_BY)\n-                .hasMessage(\"line 1:21: Window frame of type RANGE PRECEDING or FOLLOWING requires ORDER BY\");\n+                .hasMessage(\"line 1:27: Window frame of type RANGE PRECEDING or FOLLOWING requires ORDER BY\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY2MDk0Mw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562660943", "bodyText": "The error points to the beginning of window specification instead of the word OVER because not every window specification is now preceded with OVER.", "author": "kasiafi", "createdAt": "2021-01-22T14:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwODYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwODc4Mw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560608783", "bodyText": "What's in this new projection?", "author": "martint", "createdAt": "2021-01-20T01:18:20Z", "path": "core/trino-main/src/test/java/io/trino/sql/planner/TestRecursiveCte.java", "diffHunk": "@@ -61,15 +61,15 @@ public void testRecursiveQuery()\n                                 // base term\n                                 project(project(project(\n                                         ImmutableMap.of(\"expr\", expression(\"1\")),\n-                                        values()))),\n+                                        project(values())))),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU4NTMxMg==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562585312", "bodyText": "This new projection is a result of planWindowDefinitions(). There are no window definitions in this query, so it is just an identity projection. It shows up in the plan, because it is in stage CREATED (not optimized).\nAs I said in previous comments, I'm going to remove planWindowDefinitions(), and this projection will disappear.", "author": "kasiafi", "createdAt": "2021-01-22T12:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYwODc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYyMDE5Nw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560620197", "bodyText": "lower case table alias: t(a)", "author": "martint", "createdAt": "2021-01-20T01:52:04Z", "path": "core/trino-main/src/test/java/io/trino/sql/planner/TestWindowClause.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.trino.spi.connector.SortOrder;\n+import io.trino.sql.planner.assertions.BasePlanTest;\n+import io.trino.sql.planner.assertions.PlanMatchPattern;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.tree.FunctionCall;\n+import io.trino.sql.tree.QualifiedName;\n+import io.trino.sql.tree.SymbolReference;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.trino.metadata.MetadataManager.createTestMetadataManager;\n+import static io.trino.spi.type.IntegerType.INTEGER;\n+import static io.trino.sql.analyzer.TypeSignatureProvider.fromTypes;\n+import static io.trino.sql.planner.LogicalPlanner.Stage.CREATED;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.any;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.anyTree;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.functionCall;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.node;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.sort;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.specification;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.window;\n+import static io.trino.sql.planner.assertions.PlanMatchPattern.windowFrame;\n+import static io.trino.sql.tree.FrameBound.Type.CURRENT_ROW;\n+import static io.trino.sql.tree.FrameBound.Type.FOLLOWING;\n+import static io.trino.sql.tree.FrameBound.Type.PRECEDING;\n+import static io.trino.sql.tree.SortItem.NullOrdering.LAST;\n+import static io.trino.sql.tree.SortItem.Ordering.ASCENDING;\n+import static io.trino.sql.tree.WindowFrame.Type.RANGE;\n+\n+public class TestWindowClause\n+        extends BasePlanTest\n+{\n+    @Test\n+    public void testPreprojectExpression()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT max(b) OVER w FROM (VALUES (1, 1)) t(a, b) WINDOW w AS (PARTITION BY a + 1)\";\n+        PlanMatchPattern pattern =\n+                anyTree(\n+                        window(\n+                                windowMatcherBuilder -> windowMatcherBuilder\n+                                        .specification(specification(\n+                                                ImmutableList.of(\"expr\"),\n+                                                ImmutableList.of(),\n+                                                ImmutableMap.of()))\n+                                        .addFunction(\n+                                                \"max_result\",\n+                                                functionCall(\"max\", ImmutableList.of(\"b\"))),\n+                                anyTree(project(\n+                                        ImmutableMap.of(\"expr\", expression(\"a + 1\")),\n+                                        anyTree(values(\"a\", \"b\"))))));\n+\n+        assertPlan(sql, CREATED, pattern);\n+    }\n+\n+    @Test\n+    public void testPreprojectExpressions()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT max(b) OVER w3 FROM (VALUES (1, 1, 1)) t(a, b, c) WINDOW w1 AS (PARTITION BY a + 1), w2 AS (w1 ORDER BY b + 2), w3 AS (w2 RANGE c + 3 PRECEDING)\";\n+        PlanMatchPattern pattern =\n+                anyTree(\n+                        window(\n+                                windowMatcherBuilder -> windowMatcherBuilder\n+                                        .specification(specification(\n+                                                ImmutableList.of(\"expr_a\"),\n+                                                ImmutableList.of(\"expr_b\"),\n+                                                ImmutableMap.of(\"expr_b\", SortOrder.ASC_NULLS_LAST)))\n+                                        .addFunction(\n+                                                \"max_result\",\n+                                                functionCall(\"max\", ImmutableList.of(\"b\")),\n+                                                createTestMetadataManager().resolveFunction(QualifiedName.of(\"max\"), fromTypes(INTEGER)),\n+                                                windowFrame(\n+                                                        RANGE,\n+                                                        PRECEDING,\n+                                                        Optional.of(\"frame_start\"),\n+                                                        Optional.of(\"expr_b\"),\n+                                                        CURRENT_ROW,\n+                                                        Optional.empty(),\n+                                                        Optional.empty())),\n+                                project(\n+                                        ImmutableMap.of(\"frame_start\", expression(new FunctionCall(QualifiedName.of(\"$operator$subtract\"), ImmutableList.of(new SymbolReference(\"expr_b\"), new SymbolReference(\"expr_c\"))))),\n+                                        anyTree(project(\n+                                                ImmutableMap.of(\"expr_a\", expression(\"a + 1\"), \"expr_b\", expression(\"b + 2\"), \"expr_c\", expression(\"c + 3\")),\n+                                                anyTree(values(\"a\", \"b\", \"c\")))))));\n+\n+        assertPlan(sql, CREATED, pattern);\n+    }\n+\n+    @Test\n+    public void testWindowFunctionsInSelectAndOrderBy()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT array_agg(a) OVER (w ORDER BY a + 1), -a a FROM (VALUES 1, 2, 3) T(a) WINDOW w AS () ORDER BY max(a) OVER (w ORDER BY a + 1)\";\n+        PlanMatchPattern pattern =\n+                anyTree(sort(\n+                        ImmutableList.of(sort(\"max_result\", ASCENDING, LAST)),\n+                        any(window(\n+                                windowMatcherBuilder -> windowMatcherBuilder\n+                                        .specification(specification(\n+                                                ImmutableList.of(),\n+                                                ImmutableList.of(\"order_by_window_sortkey\"),\n+                                                ImmutableMap.of(\"order_by_window_sortkey\", SortOrder.ASC_NULLS_LAST)))\n+                                        .addFunction(\n+                                                \"max_result\",\n+                                                functionCall(\"max\", ImmutableList.of(\"minus_a\"))),\n+                                any(project(\n+                                        ImmutableMap.of(\"order_by_window_sortkey\", expression(\"minus_a + 1\")),\n+                                        project(\n+                                                ImmutableMap.of(\"minus_a\", expression(\"-a\")),\n+                                                window(\n+                                                        windowMatcherBuilder -> windowMatcherBuilder\n+                                                                .specification(specification(\n+                                                                        ImmutableList.of(),\n+                                                                        ImmutableList.of(\"select_window_sortkey\"),\n+                                                                        ImmutableMap.of(\"select_window_sortkey\", SortOrder.ASC_NULLS_LAST)))\n+                                                                .addFunction(\n+                                                                        \"array_agg_result\",\n+                                                                        functionCall(\"array_agg\", ImmutableList.of(\"a\"))),\n+                                                        anyTree(project(\n+                                                                ImmutableMap.of(\"select_window_sortkey\", expression(\"a + 1\")),\n+                                                                anyTree(values(\"a\"))))))))))));\n+\n+        assertPlan(sql, CREATED, pattern);\n+    }\n+\n+    @Test\n+    public void testWindowWithFrameCoercions()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT a old_a, 2e0 a FROM (VALUES -100, -99, -98) T(a) WINDOW w AS (ORDER BY a + 1) ORDER BY count(*) OVER (w RANGE BETWEEN CURRENT ROW AND a + 1e0 FOLLOWING)\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYyMDQ3Nw==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560620477", "bodyText": "lower case table alias: t(a)", "author": "martint", "createdAt": "2021-01-20T01:53:03Z", "path": "testing/trino-tests/src/test/java/io/trino/tests/AbstractTestEngineOnlyQueries.java", "diffHunk": "@@ -4288,6 +4288,78 @@ public void testGroupingInTableSubquery()\n                         \"       (37415, NULL, 986.63, 0)\");\n     }\n \n+    @Test\n+    public void testWindow()\n+    {\n+        // reference to named window\n+        assertQuery(\n+                \"SELECT array_agg(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a)\",\n+                \"VALUES ARRAY['a', 'b'], ARRAY['a', 'b'], ARRAY['c']\");\n+\n+        assertQuery(\n+                \"SELECT first_value(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a ORDER BY b DESC)\",\n+                \"VALUES 'b', 'b', 'c'\");\n+\n+        assertQuery(\n+                \"SELECT first_value(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a ORDER BY b DESC ROWS CURRENT ROW)\",\n+                \"VALUES 'a', 'b', 'c'\");\n+\n+        assertQuery(\n+                \"SELECT first_value(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a ORDER BY b DESC ROWS CURRENT ROW)\",\n+                \"VALUES 'a', 'b', 'c'\");\n+\n+        // in-line window specification based on named window in SELECT expression\n+        assertQuery(\n+                \"SELECT first_value(b) OVER (w ORDER BY b DESC ROWS CURRENT ROW) FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a)\",\n+                \"VALUES 'a', 'b', 'c'\");\n+\n+        assertQuery(\n+                \"SELECT first_value(b) OVER (w ROWS CURRENT ROW) FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a ORDER BY b DESC)\",\n+                \"VALUES 'a', 'b', 'c'\");\n+\n+        // in-line window specification based on named window in ORDER BY expression\n+        assertQueryOrdered(\n+                \"SELECT * FROM (VALUES (1, 'a'), (1, 'b'), (2, 'c'), (2, 'd')) t(a, b) WINDOW w AS (PARTITION BY a) ORDER BY row_number() OVER (w ORDER BY b DESC), b\",\n+                \"VALUES (1, 'b'), (2, 'd'), (1, 'a'), (2, 'c')\");\n+\n+        assertQueryOrdered(\n+                \"SELECT * FROM (VALUES (1, 'a'), (1, 'b'), (2, 'c'), (2, 'd')) t(a, b) WINDOW w AS (PARTITION BY a) ORDER BY max(b) OVER (w ROWS CURRENT ROW), b\",\n+                \"VALUES (1, 'a'), (1, 'b'), (2, 'c'), (2, 'd')\");\n+\n+        // in-line window specification based on named window in ORDER BY expression, resolved against output scope\n+        assertQueryOrdered(\"SELECT -a a, b FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) t(a, b) WINDOW w AS () ORDER BY row_number() OVER (w ORDER BY a)\",\n+                \"VALUES (-3, 'c'), (-2, 'b'), (-1, 'a')\");\n+\n+        assertQueryOrdered(\"SELECT a old_a, 2 a FROM (VALUES -100, -99, -98) t(a) WINDOW w AS (ORDER BY a) ORDER BY count(*) OVER (w RANGE BETWEEN CURRENT ROW AND a FOLLOWING)\",\n+                \"VALUES (-98, 2), (-99, 2), (-100, 2)\");\n+\n+        // two syntactically identical window specifications in different scopes\n+        assertQueryOrdered(\"SELECT array_agg(a) OVER (w ORDER BY a), -a a FROM (VALUES 1, 2, 3) T(a) WINDOW w AS () ORDER BY lead(a, 0) OVER (w ORDER BY a)\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYyMDgwNg==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r560620806", "bodyText": "These would be easier to read if you break them across multiple lines:\nSELECT array_agg(b) OVER w \nFROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) \nWINDOW w AS (PARTITION BY a)", "author": "martint", "createdAt": "2021-01-20T01:54:03Z", "path": "testing/trino-tests/src/test/java/io/trino/tests/AbstractTestEngineOnlyQueries.java", "diffHunk": "@@ -4288,6 +4288,78 @@ public void testGroupingInTableSubquery()\n                         \"       (37415, NULL, 986.63, 0)\");\n     }\n \n+    @Test\n+    public void testWindow()\n+    {\n+        // reference to named window\n+        assertQuery(\n+                \"SELECT array_agg(b) OVER w FROM (VALUES (1, 'a'), (1, 'b'), (3, 'c')) t(a, b) WINDOW w AS (PARTITION BY a)\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkxNDgxNQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562914815", "bodyText": "Add some tests for window name resolution that involve SQL identifier canonicalization semantics.", "author": "martint", "createdAt": "2021-01-22T21:15:15Z", "path": "core/trino-main/src/test/java/io/trino/sql/analyzer/TestAnalyzer.java", "diffHunk": "@@ -892,6 +892,26 @@ public void testWindowClause()\n                 .hasErrorCode(DUPLICATE_WINDOW_NAME);\n     }\n \n+    @Test\n+    public void testWindowNames()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkyOTUyMg==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562929522", "bodyText": "This method checks how identifiers are compared (uppercase vs lowercase, non-delimited vs delimited). What is missing?", "author": "kasiafi", "createdAt": "2021-01-22T21:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkxNDgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk0NzA3OQ==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562947079", "bodyText": "I was thinking of tests like:\nSELECT xxx() OVER w FROM t WINDOW W AS ...\n\nSELECT xxx() OVER \"w\" FROM t WINDOW W AS ...\n\nSELECT xxx() OVER w FROM t WINDOW \"w\" AS ...\n\netc.\n\nand some including existing window reference names mixing delimited/undelimited identifiers.", "author": "martint", "createdAt": "2021-01-22T22:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkxNDgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk1MDM2Mg==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562950362", "bodyText": "You mean analyzer tests involving named window references or query tests?", "author": "kasiafi", "createdAt": "2021-01-22T22:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkxNDgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk1Mjc4MA==", "url": "https://github.com/trinodb/trino/pull/6192#discussion_r562952780", "bodyText": "Either would be fine", "author": "martint", "createdAt": "2021-01-22T22:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkxNDgxNQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "d9518dcdc6142a71c4122675d0beaa6e47b0fc04", "url": "https://github.com/trinodb/trino/commit/d9518dcdc6142a71c4122675d0beaa6e47b0fc04", "message": "Add static import", "committedDate": "2021-01-26T20:38:21Z", "type": "commit"}, {"oid": "7ed75c77bb6ef0f2c7f2f4127e50e51fa8d5d353", "url": "https://github.com/trinodb/trino/commit/7ed75c77bb6ef0f2c7f2f4127e50e51fa8d5d353", "message": "Fix test case", "committedDate": "2021-01-26T20:38:22Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "7a49453113cf984d8abb9e4a065b505f5261ae63", "url": "https://github.com/trinodb/trino/commit/7a49453113cf984d8abb9e4a065b505f5261ae63", "message": "Support WINDOW clause", "committedDate": "2021-01-26T21:00:29Z", "type": "commit"}, {"oid": "7a49453113cf984d8abb9e4a065b505f5261ae63", "url": "https://github.com/trinodb/trino/commit/7a49453113cf984d8abb9e4a065b505f5261ae63", "message": "Support WINDOW clause", "committedDate": "2021-01-26T21:00:29Z", "type": "forcePushed"}]}