{"pr_number": 4381, "pr_title": "Implement variable-precision time type", "pr_createdAt": "2020-07-08T02:33:38Z", "pr_url": "https://github.com/trinodb/trino/pull/4381", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIwNDI4MA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463204280", "bodyText": "Is there a helper to round and rescale in one shot?", "author": "dain", "createdAt": "2020-07-30T18:54:21Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.Timestamps.MINUTES_PER_HOUR;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.Timestamps.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.Timestamps.parseTime;\n+import static io.prestosql.type.Timestamps.rescale;\n+import static io.prestosql.type.Timestamps.round;\n+import static io.prestosql.type.Timestamps.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = round(interval, MAX_PRECISION - 3);\n+        interval = rescale(interval, MAX_PRECISION, 3);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDQwOA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463330408", "bodyText": "Not yet, but I'll add one", "author": "martint", "createdAt": "2020-07-30T23:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIwNDI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIyOTkzOQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463229939", "bodyText": "milliis?", "author": "dain", "createdAt": "2020-07-30T19:44:16Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampWithTimeZoneCast.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.type.Timestamps.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.Timestamps.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.Timestamps.SECONDS_PER_DAY;\n+import static io.prestosql.type.Timestamps.rescale;\n+import static io.prestosql.type.Timestamps.round;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampWithTimeZoneCast\n+{\n+    private TimeToTimestampWithTimeZoneCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        ZoneId zoneId = session.getTimeZoneKey().getZoneId();\n+        long epochSeconds = getEpochSeconds(session, time, zoneId);\n+        long picoFraction = getPicoFraction(sourcePrecision, targetPrecision, time);\n+        long epochMillis = computeEpochMilliis(session, zoneId, epochSeconds, picoFraction);\n+\n+        return packDateTimeWithZone(epochMillis, session.getTimeZoneKey());\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision) with time zone\")\n+    public static LongTimestampWithTimeZone castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        ZoneId zoneId = session.getTimeZoneKey().getZoneId();\n+        long epochSeconds = getEpochSeconds(session, time, zoneId);\n+        long picoFraction = getPicoFraction(sourcePrecision, targetPrecision, time);\n+        long epochMillis = computeEpochMilliis(session, zoneId, epochSeconds, picoFraction);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzOTQ4MA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463239480", "bodyText": "Consider moving these inside of the try", "author": "dain", "createdAt": "2020-07-30T20:02:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -826,14 +839,24 @@ protected Type visitGenericLiteral(GenericLiteral node, StackableAstVisitorConte\n         @Override\n         protected Type visitTimeLiteral(TimeLiteral node, StackableAstVisitorContext<Context> context)\n         {\n-            boolean hasTimeZone;\n+            Type type;\n             try {\n-                hasTimeZone = timeHasTimeZone(node.getValue());\n+                if (timeHasTimeZone(node.getValue())) {\n+                    type = TIME_WITH_TIME_ZONE;\n+                }\n+                else {\n+                    int precision = extractTimePrecision(node.getValue());\n+                    type = createTimeType(precision);\n+                    parseTime(node.getValue());\n+                }\n+            }\n+            catch (PrestoException e) {\n+                throw new PrestoException(e::getErrorCode, extractLocation(node), e.getMessage(), e);\n             }\n             catch (IllegalArgumentException e) {\n                 throw semanticException(INVALID_LITERAL, node, \"'%s' is not a valid time literal\", node.getValue());\n             }\n-            Type type = hasTimeZone ? TIME_WITH_TIME_ZONE : TIME;\n+\n             return setExpressionType(node, type);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTQ0MA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463331440", "bodyText": "This should never fail (at least not in a way that should cause an \"invalid literal\" error).", "author": "martint", "createdAt": "2020-07-30T23:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIzOTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI1MzE0MQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463253141", "bodyText": "maybe we should rename this DateTimes or such so it is clear that this isn't just timesamp utilities.", "author": "dain", "createdAt": "2020-07-30T20:30:09Z", "path": "presto-main/src/main/java/io/prestosql/type/Timestamps.java", "diffHunk": "@@ -68,14 +72,23 @@\n     };\n \n     public static final int MILLISECONDS_PER_SECOND = 1000;\n+    public static final long MILLISECONDS_PER_DAY = 24 * 60 * 60 * MILLISECONDS_PER_SECOND;\n     public static final int MICROSECONDS_PER_SECOND = 1_000_000;\n     public static final int MICROSECONDS_PER_MILLISECOND = 1000;\n+    public static final long MICROSECONDS_PER_DAY = MILLISECONDS_PER_DAY * MICROSECONDS_PER_MILLISECOND;\n     public static final long PICOSECONDS_PER_SECOND = 1_000_000_000_000L;\n     public static final int NANOSECONDS_PER_MILLISECOND = 1_000_000;\n     public static final int NANOSECONDS_PER_MICROSECOND = 1_000;\n     public static final int PICOSECONDS_PER_MILLISECOND = 1_000_000_000;\n     public static final int PICOSECONDS_PER_MICROSECOND = 1_000_000;\n     public static final int PICOSECONDS_PER_NANOSECOND = 1000;\n+    public static final long SECONDS_PER_MINUTE = 60;\n+    public static final long MINUTES_PER_HOUR = 60;\n+    public static final long HOURS_PER_DAY = 24;\n+    public static final long PICOSECONDS_PER_MINUTE = PICOSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\n+    public static final long PICOSECONDS_PER_HOUR = PICOSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n+    public static final long PICOSECONDS_PER_DAY = PICOSECONDS_PER_HOUR * HOURS_PER_DAY;\n+    public static final long SECONDS_PER_DAY = SECONDS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_DAY;\n \n     private Timestamps() {}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMjU1MA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463302550", "bodyText": "I'm not sure about this TZ, but it would be good to test on a day with an extra hour or one fewer hour due to tz shifts", "author": "dain", "createdAt": "2020-07-30T22:18:01Z", "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timestamptz/TestTimestampWithTimeZone.java", "diffHunk": "@@ -352,39 +352,386 @@ public void testCastFromDate()\n     }\n \n     @Test\n-    public void testCastFromTime()\n+    public void testCastToTime()\n     {\n-        // TODO: date part should be 2020-05-01. See https://github.com/prestosql/presto/issues/3845\n-\n-        // round down\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(0) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(1) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.1 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(2) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.11 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(3) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.111 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(4) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.1110 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(5) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.11100 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(6) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.111000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(7) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.1110000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(8) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.11100000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(9) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.111000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(10) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.1110000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(11) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.11100000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.111' AS TIMESTAMP(12) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.111000000000 Pacific/Apia'\");\n-\n-        // round up\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(0) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:57 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(1) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.6 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(2) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.56 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(3) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.555 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(4) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.5550 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(5) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.55500 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(6) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.555000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(7) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.5550000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(8) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.55500000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(9) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.555000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(10) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.5550000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(11) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.55500000000 Pacific/Apia'\");\n-        assertThat(assertions.expression(\"CAST(TIME '12:34:56.555' AS TIMESTAMP(12) WITH TIME ZONE)\")).matches(\"TIMESTAMP '1970-01-01 12:34:56.555000000000 Pacific/Apia'\");\n+        // source = target\n+        assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 12:34:56 Asia/Kathmandu' AS TIME(0))\")).matches(\"TIME '12:34:56'\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNTQyNw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463305427", "bodyText": "This could be simplified to time.getTime() * PICOSECONDS_PER_MILLISECOND % PICOSECONDS_PER_DAY (and toLocalTime could be removed).\nIf we want to guarantee an error for negative times (as currently occurs), we could check the value of time.getTime() explicitly.", "author": "jirassimok", "createdAt": "2020-07-30T22:25:33Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -271,26 +276,15 @@ public static LongWriteFunction dateWriteFunction()\n      * {@link #timeColumnMapping} instead.\n      */\n     @Deprecated\n-    public static ColumnMapping timeColumnMappingUsingSqlTime(ConnectorSession session)\n+    public static ColumnMapping timeColumnMappingUsingSqlTime()\n     {\n-        if (session.isLegacyTimestamp()) {\n-            ZoneId sessionZone = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ColumnMapping.longMapping(\n-                    TIME,\n-                    (resultSet, columnIndex) -> {\n-                        Time time = resultSet.getTime(columnIndex);\n-                        return toPrestoLegacyTimestamp(toLocalTime(time).atDate(LocalDate.ofEpochDay(0)), sessionZone);\n-                    },\n-                    timeWriteFunctionUsingSqlTime(session));\n-        }\n-\n         return ColumnMapping.longMapping(\n                 TIME,\n                 (resultSet, columnIndex) -> {\n                     Time time = resultSet.getTime(columnIndex);\n-                    return NANOSECONDS.toMillis(toLocalTime(time).toNanoOfDay());\n+                    return (roundDiv(toLocalTime(time).toNanoOfDay(), NANOSECONDS_PER_MILLISECOND) * PICOSECONDS_PER_MILLISECOND) % PICOSECONDS_PER_DAY;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MzM4OA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463353388", "bodyText": "Good suggestion, thanks!", "author": "martint", "createdAt": "2020-07-31T01:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwNTQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwOTEzMg==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463309132", "bodyText": "Given that this expression shows up a few times, I think it should be extracted to a function.\nWe should at least have functions to convert the internal representation to and from nanoseconds (which lets us use TimeUnit for anything else). Functions for milliseconds could also be useful, but are less important, because we can always go through nanoseconds to get there.\n(I also think DateTimeUtils or DateTimes might be a better place for these functions, semantically speaking, but toPrestoTimestamp and the others are already here.)", "author": "jirassimok", "createdAt": "2020-07-30T22:34:17Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -322,35 +312,31 @@ private static Time toSqlTime(LocalTime localTime)\n         return new Time(Time.valueOf(localTime).getTime() + NANOSECONDS.toMillis(localTime.getNano()));\n     }\n \n-    public static ColumnMapping timeColumnMapping(ConnectorSession session)\n+    public static ColumnMapping timeColumnMapping()\n     {\n-        if (session.isLegacyTimestamp()) {\n-            ZoneId sessionZone = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ColumnMapping.longMapping(\n-                    TIME,\n-                    (resultSet, columnIndex) -> {\n-                        LocalTime time = resultSet.getObject(columnIndex, LocalTime.class);\n-                        return toPrestoLegacyTimestamp(time.atDate(LocalDate.ofEpochDay(0)), sessionZone);\n-                    },\n-                    timeWriteFunction(session));\n-        }\n+        return ColumnMapping.longMapping(\n+                TIME,\n+                (resultSet, columnIndex) -> {\n+                    LocalTime time = resultSet.getObject(columnIndex, LocalTime.class);\n+                    return (roundDiv(time.toNanoOfDay(), NANOSECONDS_PER_MILLISECOND) * PICOSECONDS_PER_MILLISECOND) % PICOSECONDS_PER_DAY;\n+                },", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1NTUyMA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463355520", "bodyText": "This expression is only used in one place. It also has very specific semantics that I don't think apply in general (they are an artifact of JDBC connectors only supporting time(3)). Essentially it converts nanoseconds to milliseconds with rounding and then scales to picoseconds to match the internal representation expected by the engine.", "author": "martint", "createdAt": "2020-07-31T01:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwOTEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM2MzM5NA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463363394", "bodyText": "That's fair. I do still think this should be exposed as toPrestoTime (possibly along with truncatingToPrestoTime); those are both useful for implementing new JDBC connectors (and it would make #4558 completely unnecessary).\n(There were two uses of this originally; the other is the one that used to go through toLocalTime, and I misread the truncating version as a third, oops.)", "author": "jirassimok", "createdAt": "2020-07-31T01:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwOTEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMzAzNQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463333035", "bodyText": "Why did you keep the four functions following this one?\n(parseLegacyTime, printTimeWithTimeZone (\u00d72), and printTimeWithoutTimeZone)", "author": "jirassimok", "createdAt": "2020-07-30T23:52:43Z", "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -176,19 +176,6 @@ public static long parseTimeWithTimeZone(String timeWithTimeZone)\n         return packDateTimeWithZone(dateTime);\n     }\n \n-    /**\n-     * Parse a string (without a zone) as a value of TIME type.\n-     * <p>\n-     * For example: {@code \"01:23:00\"} is parsed to TIME {@code 01:23:00}\n-     * and {@code \"01:23:00 +01:23\"} is rejected.\n-     *\n-     * @return stack representation of TIME type\n-     */\n-    public static long parseTimeWithoutTimeZone(String value)\n-    {\n-        return TIME_FORMATTER.parseMillis(value);\n-    }\n-", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MTgwMw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463351803", "bodyText": "Probably an oversight. I'll update it.", "author": "martint", "createdAt": "2020-07-31T01:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMzAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM1MjY4MA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463352680", "bodyText": "Ah, no, parseLegacyTime is still used by some connectors. The other methods are for \"time with time zone\", which didn't change with this PR", "author": "martint", "createdAt": "2020-07-31T01:06:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMzAzNQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxMjI3NA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463512274", "bodyText": "time.getTime() is an instant that, if interpreted in JVM zone, refers to hour/minute/second represented.\nto obtain number of millis/nanos since midnight you need to  time.toLocalTime().toNanoOfDay()", "author": "findepi", "createdAt": "2020-07-31T09:42:15Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -271,34 +276,15 @@ public static LongWriteFunction dateWriteFunction()\n      * {@link #timeColumnMapping} instead.\n      */\n     @Deprecated\n-    public static ColumnMapping timeColumnMappingUsingSqlTime(ConnectorSession session)\n+    public static ColumnMapping timeColumnMappingUsingSqlTime()\n     {\n-        if (session.isLegacyTimestamp()) {\n-            ZoneId sessionZone = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ColumnMapping.longMapping(\n-                    TIME,\n-                    (resultSet, columnIndex) -> {\n-                        Time time = resultSet.getTime(columnIndex);\n-                        return toPrestoLegacyTimestamp(toLocalTime(time).atDate(LocalDate.ofEpochDay(0)), sessionZone);\n-                    },\n-                    timeWriteFunctionUsingSqlTime(session));\n-        }\n-\n         return ColumnMapping.longMapping(\n                 TIME,\n                 (resultSet, columnIndex) -> {\n                     Time time = resultSet.getTime(columnIndex);\n-                    return NANOSECONDS.toMillis(toLocalTime(time).toNanoOfDay());\n+                    return time.getTime() * PICOSECONDS_PER_MILLISECOND % PICOSECONDS_PER_DAY;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYxNDY0Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463614646", "bodyText": "getTime is in milliseconds since the epoch, (and java.sql.Time specifies that the hidden day/month/year should be set to the epoch).\ntoLocalTime only copies hours/minutes/seconds.\nThe JDBC driver's handling for time zones for types without zones can affect the correctness of these conversions, though.", "author": "jirassimok", "createdAt": "2020-07-31T13:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxMjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MDAxNw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463680017", "bodyText": "@jirassimok right, time.toLocalTime() loses subsecond information.\nMy point is -- time.getTime() is not the value we want. It's different from the value we want by JVM zone's offset on 1970-01-01", "author": "findepi", "createdAt": "2020-07-31T15:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxMjI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNDE4NQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463514185", "bodyText": "Add a javadoc what kind of truncation is expected.\nAlso, when there is truncation, you likely want to disable predicate pushdown (ColumnMapping.DISABLE_PUSHDOWN) as well", "author": "findepi", "createdAt": "2020-07-31T09:46:14Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -322,35 +304,32 @@ private static Time toSqlTime(LocalTime localTime)\n         return new Time(Time.valueOf(localTime).getTime() + NANOSECONDS.toMillis(localTime.getNano()));\n     }\n \n-    public static ColumnMapping timeColumnMapping(ConnectorSession session)\n+    public static ColumnMapping timeColumnMapping()\n     {\n-        if (session.isLegacyTimestamp()) {\n-            ZoneId sessionZone = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ColumnMapping.longMapping(\n-                    TIME,\n-                    (resultSet, columnIndex) -> {\n-                        LocalTime time = resultSet.getObject(columnIndex, LocalTime.class);\n-                        return toPrestoLegacyTimestamp(time.atDate(LocalDate.ofEpochDay(0)), sessionZone);\n-                    },\n-                    timeWriteFunction(session));\n-        }\n+        return ColumnMapping.longMapping(\n+                TIME,\n+                (resultSet, columnIndex) -> {\n+                    LocalTime time = resultSet.getObject(columnIndex, LocalTime.class);\n+                    long nanos = time.toNanoOfDay();\n+                    return (roundDiv(nanos, NANOSECONDS_PER_MILLISECOND) * PICOSECONDS_PER_MILLISECOND) % PICOSECONDS_PER_DAY;\n+                },\n+                timeWriteFunction());\n+    }\n \n+    public static ColumnMapping timeColumnMappingWithTruncation()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNDk2NQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463514965", "bodyText": "% NANOSECONDS_PER_DAY looks redundant.\nit should matter only when the value is out of allowed range, which is a bad value anyway (eg TimeOperators#equal does not do %)\nif it's not redundant, add a comment", "author": "findepi", "createdAt": "2020-07-31T09:48:02Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -454,6 +433,11 @@ public static LocalDateTime fromPrestoTimestamp(long value)\n         return Instant.ofEpochMilli(value).atZone(UTC).toLocalDateTime();\n     }\n \n+    public static LocalTime fromPrestoTime(long value)\n+    {\n+        return LocalTime.ofNanoOfDay(roundDiv(value, PICOSECONDS_PER_NANOSECOND) % NANOSECONDS_PER_DAY);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgwNTc1Nw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463805757", "bodyText": "It's needed because of roundDiv, which can round up to NANOSECONDS_PER_DAY", "author": "martint", "createdAt": "2020-07-31T20:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNDk2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0OTY1OQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463849659", "bodyText": "then please add a comment", "author": "findepi", "createdAt": "2020-07-31T21:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNDk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNjM0Mg==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463516342", "bodyText": "Rounding should not be necessary here, since Iceberg supports time(3)\nif it were to support time(>6), would the bucket function need to be changed?", "author": "findepi", "createdAt": "2020-07-31T09:50:48Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/PartitionTransforms.java", "diffHunk": "@@ -323,8 +325,9 @@ private static Block bucketDate(Block block, int count)\n     private static Block bucketTime(Block block, int count)\n     {\n         return bucketBlock(block, count, position -> {\n-            long value = TIME.getLong(block, position);\n-            return bucketHash(MILLISECONDS.toMicros(value));\n+            long picos = TIME.getLong(block, position);\n+            long micros = roundDiv(picos, PICOSECONDS_PER_MICROSECOND);\n+            return bucketHash(micros);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNzU1Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463517556", "bodyText": "Does the second part need to be optional?\nWill the server ever return 12:34 instead of 12:34:00?", "author": "findepi", "createdAt": "2020-07-31T09:53:23Z", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -83,6 +84,10 @@\n             \"(?: (?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:\\\\.(?<fraction>\\\\d+))?)?)?\" +\n             \"\\\\s*(?<timezone>.+)?\");\n \n+    public static final Pattern TIME_PATTERN = Pattern.compile(\"\" +\n+            \"(?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:\\\\.(?<fraction>\\\\d+))?)?\" +", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcyODM4NA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463728384", "bodyText": "That's right. I copied from the pattern we use to parse internally. I'll update", "author": "martint", "createdAt": "2020-07-31T17:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNzU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNzY4OQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463517689", "bodyText": "What is timezone here for?\n(you discard it later btw)", "author": "findepi", "createdAt": "2020-07-31T09:53:43Z", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/AbstractPrestoResultSet.java", "diffHunk": "@@ -83,6 +84,10 @@\n             \"(?: (?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:\\\\.(?<fraction>\\\\d+))?)?)?\" +\n             \"\\\\s*(?<timezone>.+)?\");\n \n+    public static final Pattern TIME_PATTERN = Pattern.compile(\"\" +\n+            \"(?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:\\\\.(?<fraction>\\\\d+))?)?\" +\n+            \"\\\\s*(?<timezone>.+)?\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzczOTA3OA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463739078", "bodyText": "Same comment as above. I copied it from the internal pattern. I'll remove it for now. (I may need to reintroduce it when I add time(p) with time zone)", "author": "martint", "createdAt": "2020-07-31T17:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUxNzY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyMjM1Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463522356", "bodyText": "roundDiv(value, PICOSECONDS_PER_NANOSECOND) ?", "author": "findepi", "createdAt": "2020-07-31T10:03:38Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/FormatFunction.java", "diffHunk": "@@ -259,14 +257,10 @@ else if (type.getJavaType() == Slice.class) {\n         return (session, block) -> convertToString(handle, function.apply(session, block));\n     }\n \n-    private static LocalTime toLocalTime(ConnectorSession session, long value)\n+    private static LocalTime toLocalTime(long value)\n     {\n-        if (session.isLegacyTimestamp()) {\n-            Instant instant = Instant.ofEpochMilli(value);\n-            ZoneId zoneId = ZoneId.of(session.getTimeZoneKey().getId());\n-            return ZonedDateTime.ofInstant(instant, zoneId).toLocalTime();\n-        }\n-        return LocalTime.ofNanoOfDay(MILLISECONDS.toNanos(value));\n+        long nanoOfDay = roundToNearest(value, PICOSECONDS_PER_NANOSECOND) / PICOSECONDS_PER_NANOSECOND;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNTEyMg==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463525122", "bodyText": "Check for overflows, the user provided value can be anything", "author": "findepi", "createdAt": "2020-07-31T10:10:15Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeFunctions.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.round;\n+import static java.util.Locale.ENGLISH;\n+\n+public class TimeFunctions\n+{\n+    private TimeFunctions() {}\n+\n+    @Description(\"Millisecond of the second of the given time\")\n+    @ScalarFunction(\"millisecond\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long millisecond(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MILLISECOND) % MILLISECONDS_PER_SECOND;\n+    }\n+\n+    @Description(\"Second of the minute of the given time\")\n+    @ScalarFunction(\"second\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long second(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_SECOND) % SECONDS_PER_MINUTE;\n+    }\n+\n+    @Description(\"Minute of the hour of the given time\")\n+    @ScalarFunction(\"minute\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long minute(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n+    }\n+\n+    @Description(\"Hour of the day of the given time\")\n+    @ScalarFunction(\"hour\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hour(@SqlType(\"time(p)\") long time)\n+    {\n+        return time / PICOSECONDS_PER_HOUR;\n+    }\n+\n+    @Description(\"Truncate to the specified precision in the session timezone\")\n+    @ScalarFunction(\"date_trunc\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long truncate(@SqlType(\"varchar(x)\") Slice unit, @SqlType(\"time(p)\") long time)\n+    {\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+\n+        switch (unitString) {\n+            case \"millisecond\":\n+                return time / PICOSECONDS_PER_MILLISECOND * PICOSECONDS_PER_MILLISECOND;\n+            case \"second\":\n+                return time / PICOSECONDS_PER_SECOND * PICOSECONDS_PER_SECOND;\n+            case \"minute\":\n+                return time / PICOSECONDS_PER_MINUTE * PICOSECONDS_PER_MINUTE;\n+            case \"hour\":\n+                return time / PICOSECONDS_PER_HOUR * PICOSECONDS_PER_HOUR;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+    }\n+\n+    @Description(\"Add the specified amount of time to the given time\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @ScalarFunction(\"date_add\")\n+    @SqlType(\"time(p)\")\n+    public static long dateAdd(\n+            @LiteralParameter(\"p\") long precision,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"time(p)\") long time)\n+    {\n+        long delta = value;\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+        switch (unitString) {\n+            case \"millisecond\":\n+                delta *= PICOSECONDS_PER_MILLISECOND;\n+                break;\n+            case \"second\":\n+                delta *= PICOSECONDS_PER_SECOND;\n+                break;\n+            case \"minute\":\n+                delta *= PICOSECONDS_PER_MINUTE;\n+                break;\n+            case \"hour\":\n+                delta *= PICOSECONDS_PER_HOUR;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzMjg4Mw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463832883", "bodyText": "Good catch. I'll update to do the math modulo 24h.", "author": "martint", "createdAt": "2020-07-31T20:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNTEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNTk3Nw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463525977", "bodyText": "Add a comment\n} else {\n // No rounding is needed, since the delta precision is 3\n}", "author": "findepi", "createdAt": "2020-07-31T10:12:14Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeFunctions.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.round;\n+import static java.util.Locale.ENGLISH;\n+\n+public class TimeFunctions\n+{\n+    private TimeFunctions() {}\n+\n+    @Description(\"Millisecond of the second of the given time\")\n+    @ScalarFunction(\"millisecond\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long millisecond(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MILLISECOND) % MILLISECONDS_PER_SECOND;\n+    }\n+\n+    @Description(\"Second of the minute of the given time\")\n+    @ScalarFunction(\"second\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long second(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_SECOND) % SECONDS_PER_MINUTE;\n+    }\n+\n+    @Description(\"Minute of the hour of the given time\")\n+    @ScalarFunction(\"minute\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long minute(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n+    }\n+\n+    @Description(\"Hour of the day of the given time\")\n+    @ScalarFunction(\"hour\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hour(@SqlType(\"time(p)\") long time)\n+    {\n+        return time / PICOSECONDS_PER_HOUR;\n+    }\n+\n+    @Description(\"Truncate to the specified precision in the session timezone\")\n+    @ScalarFunction(\"date_trunc\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long truncate(@SqlType(\"varchar(x)\") Slice unit, @SqlType(\"time(p)\") long time)\n+    {\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+\n+        switch (unitString) {\n+            case \"millisecond\":\n+                return time / PICOSECONDS_PER_MILLISECOND * PICOSECONDS_PER_MILLISECOND;\n+            case \"second\":\n+                return time / PICOSECONDS_PER_SECOND * PICOSECONDS_PER_SECOND;\n+            case \"minute\":\n+                return time / PICOSECONDS_PER_MINUTE * PICOSECONDS_PER_MINUTE;\n+            case \"hour\":\n+                return time / PICOSECONDS_PER_HOUR * PICOSECONDS_PER_HOUR;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+    }\n+\n+    @Description(\"Add the specified amount of time to the given time\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @ScalarFunction(\"date_add\")\n+    @SqlType(\"time(p)\")\n+    public static long dateAdd(\n+            @LiteralParameter(\"p\") long precision,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"time(p)\") long time)\n+    {\n+        long delta = value;\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+        switch (unitString) {\n+            case \"millisecond\":\n+                delta *= PICOSECONDS_PER_MILLISECOND;\n+                break;\n+            case \"second\":\n+                delta *= PICOSECONDS_PER_SECOND;\n+                break;\n+            case \"minute\":\n+                delta *= PICOSECONDS_PER_MINUTE;\n+                break;\n+            case \"hour\":\n+                delta *= PICOSECONDS_PER_HOUR;\n+                break;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+\n+        long result = TimeOperators.add(time, delta);\n+\n+        if (precision <= 3) {\n+            return round(result, (int) (MAX_PRECISION - precision)) % PICOSECONDS_PER_DAY;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNjcxMg==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463526712", "bodyText": "This will return negative result if  delta is \"very negative\", because TimeOperators.add has\nif (result < 0) {\n\nand not e.g.\nwhile (result < 0) {", "author": "findepi", "createdAt": "2020-07-31T10:13:57Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeFunctions.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.type.DateTimes.MILLISECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.round;\n+import static java.util.Locale.ENGLISH;\n+\n+public class TimeFunctions\n+{\n+    private TimeFunctions() {}\n+\n+    @Description(\"Millisecond of the second of the given time\")\n+    @ScalarFunction(\"millisecond\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long millisecond(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MILLISECOND) % MILLISECONDS_PER_SECOND;\n+    }\n+\n+    @Description(\"Second of the minute of the given time\")\n+    @ScalarFunction(\"second\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long second(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_SECOND) % SECONDS_PER_MINUTE;\n+    }\n+\n+    @Description(\"Minute of the hour of the given time\")\n+    @ScalarFunction(\"minute\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long minute(@SqlType(\"time(p)\") long time)\n+    {\n+        return (time / PICOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR;\n+    }\n+\n+    @Description(\"Hour of the day of the given time\")\n+    @ScalarFunction(\"hour\")\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hour(@SqlType(\"time(p)\") long time)\n+    {\n+        return time / PICOSECONDS_PER_HOUR;\n+    }\n+\n+    @Description(\"Truncate to the specified precision in the session timezone\")\n+    @ScalarFunction(\"date_trunc\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long truncate(@SqlType(\"varchar(x)\") Slice unit, @SqlType(\"time(p)\") long time)\n+    {\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+\n+        switch (unitString) {\n+            case \"millisecond\":\n+                return time / PICOSECONDS_PER_MILLISECOND * PICOSECONDS_PER_MILLISECOND;\n+            case \"second\":\n+                return time / PICOSECONDS_PER_SECOND * PICOSECONDS_PER_SECOND;\n+            case \"minute\":\n+                return time / PICOSECONDS_PER_MINUTE * PICOSECONDS_PER_MINUTE;\n+            case \"hour\":\n+                return time / PICOSECONDS_PER_HOUR * PICOSECONDS_PER_HOUR;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+    }\n+\n+    @Description(\"Add the specified amount of time to the given time\")\n+    @LiteralParameters({\"x\", \"p\"})\n+    @ScalarFunction(\"date_add\")\n+    @SqlType(\"time(p)\")\n+    public static long dateAdd(\n+            @LiteralParameter(\"p\") long precision,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"time(p)\") long time)\n+    {\n+        long delta = value;\n+        String unitString = unit.toStringUtf8().toLowerCase(ENGLISH);\n+        switch (unitString) {\n+            case \"millisecond\":\n+                delta *= PICOSECONDS_PER_MILLISECOND;\n+                break;\n+            case \"second\":\n+                delta *= PICOSECONDS_PER_SECOND;\n+                break;\n+            case \"minute\":\n+                delta *= PICOSECONDS_PER_MINUTE;\n+                break;\n+            case \"hour\":\n+                delta *= PICOSECONDS_PER_HOUR;\n+                break;\n+            default:\n+                throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"'\" + unitString + \"' is not a valid Time field\");\n+        }\n+\n+        long result = TimeOperators.add(time, delta);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc4NjExNA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463786114", "bodyText": "add performs math modulo 24h", "author": "martint", "createdAt": "2020-07-31T19:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNjcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNzA2MA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463527060", "bodyText": "I guess  this could be declared as returning boolean, not Boolean\n(same below)", "author": "findepi", "createdAt": "2020-07-31T10:14:49Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.parseTime;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = rescaleWithRounding(interval, MAX_PRECISION, 3);\n+\n+        return interval;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean equal(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc0MTQyNw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463741427", "bodyText": "No, the implementation of the equal operator needs to return Boolean (long story)", "author": "martint", "createdAt": "2020-07-31T17:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyNzA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyODgxNw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463528817", "bodyText": "% PICOSECONDS_PER_DAY seems redundant\nadd a comment if it's not", "author": "findepi", "createdAt": "2020-07-31T10:18:57Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.parseTime;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = rescaleWithRounding(interval, MAX_PRECISION, 3);\n+\n+        return interval;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean equal(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left == right;\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean notEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left != right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left < right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left <= right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left > right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left >= right;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n+    public static long castToTimeWithTimeZone(ConnectorSession session, @SqlType(\"time(p)\") long value)\n+    {\n+        long millis = rescaleWithRounding(value, MAX_PRECISION, 3);\n+\n+        ISOChronology localChronology = getChronology(session.getTimeZoneKey());\n+        millis = localChronology.getZone().convertLocalToUTC(millis, false);\n+        return packDateTimeWithZone(millis, session.getTimeZoneKey());\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long castFromVarchar(@LiteralParameter(\"p\") long precision, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        try {\n+            long picos = parseTime(value.toStringUtf8());\n+            return round(picos, (int) (MAX_PRECISION - precision)) % PICOSECONDS_PER_DAY;\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to time: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @ScalarOperator(HASH_CODE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hashCode(@SqlType(\"time(p)\") long value)\n+    {\n+        return AbstractLongType.hash(value);\n+    }\n+\n+    @ScalarOperator(XX_HASH_64)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long xxHash64(@SqlType(\"time(p)\") long value)\n+    {\n+        return XxHash64.hash(value);\n+    }\n+\n+    @ScalarOperator(IS_DISTINCT_FROM)\n+    public static final class TimeDistinctFromOperator\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @SqlType(\"time(p)\") long left,\n+                @IsNull boolean leftNull,\n+                @SqlType(\"time(p)\") long right,\n+                @IsNull boolean rightNull)\n+        {\n+            if (leftNull != rightNull) {\n+                return true;\n+            }\n+            if (leftNull) {\n+                return false;\n+            }\n+            return notEqual(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block left,\n+                @BlockIndex int leftPosition,\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block right,\n+                @BlockIndex int rightPosition)\n+        {\n+            if (left.isNull(leftPosition) != right.isNull(rightPosition)) {\n+                return true;\n+            }\n+            if (left.isNull(leftPosition)) {\n+                return false;\n+            }\n+            return notEqual(TIME.getLong(left, leftPosition), TIME.getLong(right, rightPosition));\n+        }\n+    }\n+\n+    @ScalarOperator(INDETERMINATE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean indeterminate(@SqlType(\"time(p)\") long value, @IsNull boolean isNull)\n+    {\n+        return isNull;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long castToTime(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        if (sourcePrecision <= targetPrecision) {\n+            return time;\n+        }\n+\n+        return round(time, (int) (MAX_PRECISION - targetPrecision)) % PICOSECONDS_PER_DAY;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NDQyNw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463754427", "bodyText": "It's needed because round can round up. So a time like 23:59:59.9 will round to 24:00:00, which needs to turn into 00:00:00", "author": "martint", "createdAt": "2020-07-31T18:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyODgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2NzM3Nw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463767377", "bodyText": "Co cast(TIME '23:59:59.9' AS time(0)) returns 00:00:00 rather than closes representable value, 23:59:59?", "author": "findepi", "createdAt": "2020-07-31T18:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyODgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc4MjMyNA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463782324", "bodyText": "Yes, all operations on time are done modulo 24h (as required by the spec). Since we use rounding semantics, that's the reasonable thing to do.", "author": "martint", "createdAt": "2020-07-31T19:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyODgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0Nzg5Mg==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463847892", "bodyText": "I bet this will bite us. Maybe just because this is behavior that I could hardly foresee as possible.", "author": "findepi", "createdAt": "2020-07-31T21:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyODgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NDEzOQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463884139", "bodyText": "That's just how the type works in the spec. It says:\n\nb) If SD is TIME WITHOUT TIME ZONE, then TV is SV, with implementation-defined rounding or truncation if necessary.\n\nAlso, elsewhere:\n\nif the data type of the <datetime term> or <datetime value expression> is time with or without time zone, then arithmetic on the HOUR <primary datetime field> is undertaken modulo 24.\n\nSince we chose rounding, then this behavior follows from it. This is consistent with this, too:\npresto:default> select cast(timestamp '2020-01-01 23:59:59.999999' as timestamp(0));\n        _col0\n---------------------\n 2020-01-02 00:00:00\n(1 row)\n\nIt would be very surprising if these expressions produced different results:\nCAST(CAST(timestamp '2020-01-01 23:59:59.999999' as timestamp(0)) AS time(0))\nCAST(CAST(timestamp '2020-01-01 23:59:59.999999' AS time(6)) AS time(0))\nCAST(timestamp '2020-01-01 23:59:59.999999' AS time(0))", "author": "martint", "createdAt": "2020-07-31T23:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyODgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5Nzg2MQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463997861", "bodyText": "Thanks @martint for taking time to explain this.\nIt's seem consequential...\nDo you think we could document this somewhere?\nDocs or internally? I bet I or someone else will \"rediscover\" this some day,\nand would be nice to be able to refer to something.", "author": "findepi", "createdAt": "2020-08-01T20:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyODgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMjY1OA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r464122658", "bodyText": "FWIW\nPostgreSQL 12.3\ntest=# SELECT CAST(TIME '23:59:59.999' AS time(1));\n   time\n----------\n 24:00:00\n(1 row)\n\nOracle 11g r2 XE\nSQL> SELECT CAST(TIME '23:59:59.999' AS time(1)) FROM dual;\n\nCAST(TIME'23:59:59.999'ASTIME(1))\n---------------------------------------------------------------------------\n12.00.00.0 AM\n\n12 AM is 00:00:00\nSQL> SELECT to_char(CAST(TIME '23:59:59.999' AS time(1)), 'hh24:mi:ss') FROM dual;\n\nTO_CHAR(\n--------\n00:00:00\n\nSQL Server 2017\n1> SELECT CAST('23:59:59.999' AS time);\n2> GO\n\n----------------------\n      23:59:59.9990000\n\n1> SELECT CAST(CAST('23:59:59.999' AS time) AS time(1));\n2> GO\n\n----------------------\n            23:59:59.9", "author": "findepi", "createdAt": "2020-08-02T20:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyODgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyOTIyMg==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463529222", "bodyText": "Seems like this can return invalid time value (negative), when interval is longer than a day (eg 3 days)", "author": "findepi", "createdAt": "2020-07-31T10:19:58Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.parseTime;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = rescaleWithRounding(interval, MAX_PRECISION, 3);\n+\n+        return interval;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean equal(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left == right;\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean notEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left != right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left < right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left <= right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left > right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left >= right;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n+    public static long castToTimeWithTimeZone(ConnectorSession session, @SqlType(\"time(p)\") long value)\n+    {\n+        long millis = rescaleWithRounding(value, MAX_PRECISION, 3);\n+\n+        ISOChronology localChronology = getChronology(session.getTimeZoneKey());\n+        millis = localChronology.getZone().convertLocalToUTC(millis, false);\n+        return packDateTimeWithZone(millis, session.getTimeZoneKey());\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long castFromVarchar(@LiteralParameter(\"p\") long precision, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        try {\n+            long picos = parseTime(value.toStringUtf8());\n+            return round(picos, (int) (MAX_PRECISION - precision)) % PICOSECONDS_PER_DAY;\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to time: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @ScalarOperator(HASH_CODE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hashCode(@SqlType(\"time(p)\") long value)\n+    {\n+        return AbstractLongType.hash(value);\n+    }\n+\n+    @ScalarOperator(XX_HASH_64)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long xxHash64(@SqlType(\"time(p)\") long value)\n+    {\n+        return XxHash64.hash(value);\n+    }\n+\n+    @ScalarOperator(IS_DISTINCT_FROM)\n+    public static final class TimeDistinctFromOperator\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @SqlType(\"time(p)\") long left,\n+                @IsNull boolean leftNull,\n+                @SqlType(\"time(p)\") long right,\n+                @IsNull boolean rightNull)\n+        {\n+            if (leftNull != rightNull) {\n+                return true;\n+            }\n+            if (leftNull) {\n+                return false;\n+            }\n+            return notEqual(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block left,\n+                @BlockIndex int leftPosition,\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block right,\n+                @BlockIndex int rightPosition)\n+        {\n+            if (left.isNull(leftPosition) != right.isNull(rightPosition)) {\n+                return true;\n+            }\n+            if (left.isNull(leftPosition)) {\n+                return false;\n+            }\n+            return notEqual(TIME.getLong(left, leftPosition), TIME.getLong(right, rightPosition));\n+        }\n+    }\n+\n+    @ScalarOperator(INDETERMINATE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean indeterminate(@SqlType(\"time(p)\") long value, @IsNull boolean isNull)\n+    {\n+        return isNull;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long castToTime(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        if (sourcePrecision <= targetPrecision) {\n+            return time;\n+        }\n+\n+        return round(time, (int) (MAX_PRECISION - targetPrecision)) % PICOSECONDS_PER_DAY;\n+    }\n+\n+    @ScalarOperator(ADD)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long timePlusIntervalDayToSecond(@SqlType(\"time(p)\") long time, @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+    {\n+        return add(time, interval * PICOSECONDS_PER_MILLISECOND);\n+    }\n+\n+    @ScalarOperator(ADD)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long intervalDayToSecondPlusTime(@SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval, @SqlType(\"time(p)\") long time)\n+    {\n+        return timePlusIntervalDayToSecond(time, interval);\n+    }\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long timeMinusIntervalDayToSecond(@SqlType(\"time(p)\") long time, @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+    {\n+        return add(time, -interval * PICOSECONDS_PER_MILLISECOND);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc0NDE1MQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463744151", "bodyText": "No, it can't. add performs the sum modulo 24h (% PICOSECONDS_PER_DAY)", "author": "martint", "createdAt": "2020-07-31T17:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyOTIyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2NjU0Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463766546", "bodyText": "right, i misread the add", "author": "findepi", "createdAt": "2020-07-31T18:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyOTIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyOTc2OQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463529769", "bodyText": "As commented earlier, the if here may be insufficient for large negative delta", "author": "findepi", "createdAt": "2020-07-31T10:21:18Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeOperators.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.airlift.slice.DynamicSliceOutput;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.IS_DISTINCT_FROM;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.type.DateTimes.MINUTES_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_MINUTE;\n+import static io.prestosql.type.DateTimes.parseTime;\n+import static io.prestosql.type.DateTimes.rescaleWithRounding;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleFactor;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.String.format;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public final class TimeOperators\n+{\n+    private TimeOperators() {}\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND)\n+    public static long subtract(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        long interval = left - right;\n+\n+        interval = rescaleWithRounding(interval, MAX_PRECISION, 3);\n+\n+        return interval;\n+    }\n+\n+    @ScalarOperator(EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean equal(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left == right;\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    @SqlNullable\n+    public static Boolean notEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left != right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left < right;\n+    }\n+\n+    @ScalarOperator(LESS_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean lessThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left <= right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThan(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left > right;\n+    }\n+\n+    @ScalarOperator(GREATER_THAN_OR_EQUAL)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean greaterThanOrEqual(@SqlType(\"time(p)\") long left, @SqlType(\"time(p)\") long right)\n+    {\n+        return left >= right;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.TIME_WITH_TIME_ZONE)\n+    public static long castToTimeWithTimeZone(ConnectorSession session, @SqlType(\"time(p)\") long value)\n+    {\n+        long millis = rescaleWithRounding(value, MAX_PRECISION, 3);\n+\n+        ISOChronology localChronology = getChronology(session.getTimeZoneKey());\n+        millis = localChronology.getZone().convertLocalToUTC(millis, false);\n+        return packDateTimeWithZone(millis, session.getTimeZoneKey());\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"time(p)\")\n+    public static long castFromVarchar(@LiteralParameter(\"p\") long precision, @SqlType(\"varchar(x)\") Slice value)\n+    {\n+        try {\n+            long picos = parseTime(value.toStringUtf8());\n+            return round(picos, (int) (MAX_PRECISION - precision)) % PICOSECONDS_PER_DAY;\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_CAST_ARGUMENT, \"Value cannot be cast to time: \" + value.toStringUtf8(), e);\n+        }\n+    }\n+\n+    @ScalarOperator(HASH_CODE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long hashCode(@SqlType(\"time(p)\") long value)\n+    {\n+        return AbstractLongType.hash(value);\n+    }\n+\n+    @ScalarOperator(XX_HASH_64)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BIGINT)\n+    public static long xxHash64(@SqlType(\"time(p)\") long value)\n+    {\n+        return XxHash64.hash(value);\n+    }\n+\n+    @ScalarOperator(IS_DISTINCT_FROM)\n+    public static final class TimeDistinctFromOperator\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @SqlType(\"time(p)\") long left,\n+                @IsNull boolean leftNull,\n+                @SqlType(\"time(p)\") long right,\n+                @IsNull boolean rightNull)\n+        {\n+            if (leftNull != rightNull) {\n+                return true;\n+            }\n+            if (leftNull) {\n+                return false;\n+            }\n+            return notEqual(left, right);\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static boolean isDistinctFrom(\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block left,\n+                @BlockIndex int leftPosition,\n+                @BlockPosition @SqlType(value = \"time(p)\", nativeContainerType = long.class) Block right,\n+                @BlockIndex int rightPosition)\n+        {\n+            if (left.isNull(leftPosition) != right.isNull(rightPosition)) {\n+                return true;\n+            }\n+            if (left.isNull(leftPosition)) {\n+                return false;\n+            }\n+            return notEqual(TIME.getLong(left, leftPosition), TIME.getLong(right, rightPosition));\n+        }\n+    }\n+\n+    @ScalarOperator(INDETERMINATE)\n+    @LiteralParameters(\"p\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean indeterminate(@SqlType(\"time(p)\") long value, @IsNull boolean isNull)\n+    {\n+        return isNull;\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"time(targetPrecision)\")\n+    public static long castToTime(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        if (sourcePrecision <= targetPrecision) {\n+            return time;\n+        }\n+\n+        return round(time, (int) (MAX_PRECISION - targetPrecision)) % PICOSECONDS_PER_DAY;\n+    }\n+\n+    @ScalarOperator(ADD)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long timePlusIntervalDayToSecond(@SqlType(\"time(p)\") long time, @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+    {\n+        return add(time, interval * PICOSECONDS_PER_MILLISECOND);\n+    }\n+\n+    @ScalarOperator(ADD)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long intervalDayToSecondPlusTime(@SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval, @SqlType(\"time(p)\") long time)\n+    {\n+        return timePlusIntervalDayToSecond(time, interval);\n+    }\n+\n+    @ScalarOperator(SUBTRACT)\n+    @LiteralParameters({\"p\", \"u\"})\n+    @SqlType(\"time(u)\")\n+    @Constraint(variable = \"u\", expression = \"max(3, p)\") // interval is currently p = 3\n+    public static long timeMinusIntervalDayToSecond(@SqlType(\"time(p)\") long time, @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval)\n+    {\n+        return add(time, -interval * PICOSECONDS_PER_MILLISECOND);\n+    }\n+\n+    @ScalarOperator(CAST)\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"varchar(x)\")\n+    public static Slice castToVarchar(@LiteralParameter(\"p\") long precision, @SqlType(\"time(p)\") long value)\n+    {\n+        int size = (int) (8 + // hour:minute:second\n+                        (precision > 0 ? 1 : 0) + // period\n+                        precision); // fraction\n+\n+        DynamicSliceOutput output = new DynamicSliceOutput(size);\n+\n+        output.appendBytes(format(\"%02d\", value / PICOSECONDS_PER_HOUR).getBytes(UTF_8));\n+        output.appendByte(':');\n+        output.appendBytes(format(\"%02d\", (value / PICOSECONDS_PER_MINUTE) % MINUTES_PER_HOUR).getBytes(UTF_8));\n+        output.appendByte(':');\n+        output.appendBytes(format(\"%02d\", (value / PICOSECONDS_PER_SECOND) % SECONDS_PER_MINUTE).getBytes(UTF_8));\n+\n+        if (precision > 0) {\n+            long scaledFraction = (value % PICOSECONDS_PER_SECOND) / scaleFactor((int) precision, MAX_PRECISION);\n+            output.appendByte('.');\n+            output.appendBytes(format(\"%0\" + precision + \"d\", scaledFraction).getBytes(UTF_8));\n+        }\n+\n+        return output.slice();\n+    }\n+\n+    public static long add(long time, long delta)\n+    {\n+        long result = (time + delta) % PICOSECONDS_PER_DAY;\n+        if (result < 0) {\n+            result += PICOSECONDS_PER_DAY;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc0NDM0OQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463744349", "bodyText": "See  % PICOSECONDS_PER_DAY in the line above.", "author": "martint", "createdAt": "2020-07-31T17:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyOTc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzMDM4Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463530386", "bodyText": "\"compute\" doesn't add information and \"epochMicros\" alone is not fully meaningful either.\nCan we name the method more declaratively?\nAlso, remove annotations from args", "author": "findepi", "createdAt": "2020-07-31T10:22:35Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc0NTA1Nw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463745057", "bodyText": "Also, remove annotations from args\n\nGood catch. Intellij preserves them when you do an \"extract method\", and I forgot to remove them.", "author": "martint", "createdAt": "2020-07-31T17:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzMDM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzMTIzMw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463531233", "bodyText": "Since this can be invoked per row, we should avoid java.time. here.\nI am OK with this as is, but a TODO/issue would be nice.", "author": "findepi", "createdAt": "2020-07-31T10:24:36Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzMjgxOA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463532818", "bodyText": "When there are 2 offsets the latter one usually wins (eg when parsing string), so Iterables.getLast(offsets).\nAlso, add a comment why we do not need to handle the case when offsets.isEmpty()\nPerhaps\nepochSeconds = ZonedDateTime.ofInstant(Instant.ofEpochSecond(epochSeconds), ZoneOffset.UTC)\n                    .withZoneSameLocal(session.getTimeZoneKey().getZoneId())\n                    .toInstant().getEpochSecond();\n\nwould avoid having a comment", "author": "findepi", "createdAt": "2020-07-31T10:27:51Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())\n+                .toEpochDay();\n+\n+        long epochSeconds = multiplyExact(epochDay, SECONDS_PER_DAY) + time / PICOSECONDS_PER_SECOND;\n+\n+        if (session.isLegacyTimestamp()) {\n+            Instant instant = Instant.ofEpochSecond(epochSeconds);\n+            LocalDateTime dateTime = LocalDateTime.ofInstant(instant, session.getTimeZoneKey().getZoneId());\n+            List<ZoneOffset> offsets = session.getTimeZoneKey().getZoneId().getRules().getValidOffsets(dateTime);\n+            epochSeconds -= offsets.get(0).getTotalSeconds();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNDQ3Nw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463534477", "bodyText": "epochSeconds -> epochSecond", "author": "findepi", "createdAt": "2020-07-31T10:31:32Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())\n+                .toEpochDay();\n+\n+        long epochSeconds = multiplyExact(epochDay, SECONDS_PER_DAY) + time / PICOSECONDS_PER_SECOND;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNTAxMw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463535013", "bodyText": "I don't understand the comment. Especially since this method is called in to-short and to-long cases", "author": "findepi", "createdAt": "2020-07-31T10:32:52Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/time/TimeToTimestampCast.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.time;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeType;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.type.DateTimes.MICROSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_MICROSECOND;\n+import static io.prestosql.type.DateTimes.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.type.DateTimes.SECONDS_PER_DAY;\n+import static io.prestosql.type.DateTimes.rescale;\n+import static io.prestosql.type.DateTimes.round;\n+import static io.prestosql.type.DateTimes.scaleEpochMicrosToMillis;\n+import static java.lang.Math.multiplyExact;\n+\n+@ScalarOperator(CAST)\n+public final class TimeToTimestampCast\n+{\n+    private TimeToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long castToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        if (targetPrecision <= 3) {\n+            return scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static LongTimestamp castToLong(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            ConnectorSession session,\n+            @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochMicros = computeEpochMicros(sourcePrecision, targetPrecision, session, time);\n+        return new LongTimestamp(epochMicros, (int) (time % PICOSECONDS_PER_MICROSECOND));\n+    }\n+\n+    private static long computeEpochMicros(@LiteralParameter(\"sourcePrecision\") long sourcePrecision, @LiteralParameter(\"targetPrecision\") long targetPrecision, ConnectorSession session, @SqlType(\"time(sourcePrecision)\") long time)\n+    {\n+        long epochDay = LocalDate.ofInstant(session.getStart(), session.getTimeZoneKey().getZoneId())\n+                .toEpochDay();\n+\n+        long epochSeconds = multiplyExact(epochDay, SECONDS_PER_DAY) + time / PICOSECONDS_PER_SECOND;\n+\n+        if (session.isLegacyTimestamp()) {\n+            Instant instant = Instant.ofEpochSecond(epochSeconds);\n+            LocalDateTime dateTime = LocalDateTime.ofInstant(instant, session.getTimeZoneKey().getZoneId());\n+            List<ZoneOffset> offsets = session.getTimeZoneKey().getZoneId().getRules().getValidOffsets(dateTime);\n+            epochSeconds -= offsets.get(0).getTotalSeconds();\n+        }\n+\n+        long picoFraction = time % PICOSECONDS_PER_SECOND;\n+        if (sourcePrecision > targetPrecision) {\n+            picoFraction = round(picoFraction, (int) (TimeType.MAX_PRECISION - targetPrecision));\n+        }\n+\n+        // target precision is > 6 for long timestamp\n+        long microFraction = rescale(picoFraction, TimeType.MAX_PRECISION, 6);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2NjQ5Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463766496", "bodyText": "Leftover from before I extracted the method. I'll remove the comment.", "author": "martint", "createdAt": "2020-07-31T18:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNTAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNzExMg==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463537112", "bodyText": "JDBC 339 declares that is supportsParametricDateTime, but it was not updated.\nDoes it work with time(>3) as well?", "author": "findepi", "createdAt": "2020-07-31T10:37:50Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -201,6 +203,10 @@ private Object getLegacyValue(Object value, Type type)\n             if (type instanceof TimestampWithTimeZoneType) {\n                 return ((SqlTimestampWithTimeZone) value).roundTo(3);\n             }\n+\n+            if (type instanceof TimeType) {\n+                value = ((SqlTime) value).roundTo(3);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4OTU0MA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463889540", "bodyText": "That was an oversight -- and a tricky issue. Supporting that to future-proof the client before the type extended is complicated. Not sure what to do here. We can add another capability for TIME(p) and, later, yet another one for TIME(p) W/ TZ, or we can document the next couple of versions as not being forward compatible with the upcoming changes to TIME(p) and TIME(p) W/ TZ types.\nGiven that those types are currently utterly broken, I'm not sure it's such a big deal to take that kind of exception. Thoughts?", "author": "martint", "createdAt": "2020-07-31T23:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNzExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODE0Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463998146", "bodyText": "What is the failure mode? does JDBC 339 can read time values produced by 340+ server at all?\nie is it about data or \"just\" metadata (various metadata APIs, let's not go into details now)?\ni am OK with new capability, and OK with a breaking change for TIME. To me, it's most\nimportant that we make this decision consciously.", "author": "findepi", "createdAt": "2020-08-01T20:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzNzExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzODg4Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463538886", "bodyText": "should we limit fraction value to 12 digits?", "author": "findepi", "createdAt": "2020-07-31T10:42:15Z", "path": "presto-main/src/main/java/io/prestosql/type/DateTimes.java", "diffHunk": "@@ -474,6 +494,57 @@ private static long toEpochSecond(String year, String month, String day, String\n         return timestamp.toEpochSecond(offsets.get(0));\n     }\n \n+    public static boolean timeHasTimeZone(String value)\n+    {\n+        Matcher matcher = TIME_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(format(\"Invalid time '%s'\", value));\n+        }\n+\n+        return matcher.group(\"timezone\") != null;\n+    }\n+\n+    public static int extractTimePrecision(String value)\n+    {\n+        Matcher matcher = TIME_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(format(\"Invalid time '%s'\", value));\n+        }\n+\n+        String fraction = matcher.group(\"fraction\");\n+        if (fraction == null) {\n+            return 0;\n+        }\n+\n+        return fraction.length();\n+    }\n+\n+    public static long parseTime(String value)\n+    {\n+        Matcher matcher = TIME_PATTERN.matcher(value);\n+        if (!matcher.matches() || matcher.group(\"timezone\") != null) {\n+            throw new IllegalArgumentException(\"Invalid time: \" + value);\n+        }\n+\n+        int hour = Integer.parseInt(matcher.group(\"hour\"));\n+        int minute = Integer.parseInt(matcher.group(\"minute\"));\n+        int second = matcher.group(\"second\") == null ? 0 : Integer.parseInt(matcher.group(\"second\"));\n+\n+        if (hour > 23 || minute > 59 || second > 59) {\n+            throw new IllegalArgumentException(\"Invalid time: \" + value);\n+        }\n+\n+        int precision = 0;\n+        String fraction = matcher.group(\"fraction\");\n+        long fractionValue = 0;\n+        if (fraction != null) {\n+            precision = fraction.length();\n+            fractionValue = Long.parseLong(fraction);\n+        }\n+\n+        return (((hour * 60) + minute) * 60 + second) * PICOSECONDS_PER_SECOND + rescale(fractionValue, precision, 12);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc3MDQ3Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463770476", "bodyText": "Yes, great point. I'll update and add tests.", "author": "martint", "createdAt": "2020-07-31T18:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUzODg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MDA2Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463540066", "bodyText": "That looks wrong. The millis should be interpreted in the zone packed in value:\nLocalTime.ofInstant(Instant.ofEpochMilli(millis), unpackZoneKey(value).getZoneId())", "author": "findepi", "createdAt": "2020-07-31T10:45:09Z", "path": "presto-main/src/main/java/io/prestosql/type/TimeWithTimeZoneOperators.java", "diffHunk": "@@ -106,12 +117,23 @@ public static boolean greaterThanOrEqual(@SqlType(StandardTypes.TIME_WITH_TIME_Z\n     }\n \n     @ScalarOperator(CAST)\n-    @SqlType(StandardTypes.TIME)\n-    public static long castToTime(ConnectorSession session, @SqlType(StandardTypes.TIME_WITH_TIME_ZONE) long value)\n+    @LiteralParameters(\"p\")\n+    @SqlType(\"time(p)\")\n+    public static long castToTime(@LiteralParameter(\"p\") long precision, @SqlType(StandardTypes.TIME_WITH_TIME_ZONE) long value)\n     {\n-        // This is exactly the same operation as for TIME WITH TIME ZONE -> TIMESTAMP, as the representations\n-        // of those types are aligned in range that is covered by TIME WITH TIME ZONE.\n-        return TimeWithTimezoneToTimestampCast.cast(3, session, value);\n+        long millis = unpackMillisUtc(value);\n+        if (millis < 0) {\n+            millis += MILLISECONDS_PER_DAY;\n+        }\n+        LocalDateTime localDateTime = LocalDateTime.of(LocalDate.ofEpochDay(0), LocalTime.ofNanoOfDay(millis / PICOSECONDS_PER_NANOSECOND));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MDgzNQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463540835", "bodyText": "Why this moved in your PR?", "author": "findepi", "createdAt": "2020-07-31T10:47:00Z", "path": "presto-main/src/main/java/io/prestosql/util/JsonUtil.java", "diffHunk": "@@ -91,9 +91,9 @@\n import static io.prestosql.spi.type.RealType.REAL;\n import static io.prestosql.spi.type.SmallintType.SMALLINT;\n import static io.prestosql.spi.type.TinyintType.TINYINT;\n-import static io.prestosql.type.JsonType.JSON;\n import static io.prestosql.type.DateTimes.formatTimestamp;\n import static io.prestosql.type.DateTimes.scaleEpochMillisToMicros;\n+import static io.prestosql.type.JsonType.JSON;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc4NjY1Mw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463786653", "bodyText": "Git getting confused because of a split change across the two commits. I'll update.", "author": "martint", "createdAt": "2020-07-31T19:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MDgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MjY1MQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463542651", "bodyText": "add a case with as time(1) and as time(9) as well", "author": "findepi", "createdAt": "2020-07-31T10:51:20Z", "path": "presto-main/src/test/java/io/prestosql/type/TestTimeWithTimeZoneBase.java", "diffHunk": "@@ -198,7 +200,12 @@ public void testBetween()\n     }\n \n     @Test\n-    public abstract void testCastToTime();\n+    public void testCastToTime()\n+    {\n+        assertFunction(\"cast(TIME '03:04:05.321 +07:09' as time)\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgwNDg5NA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463804894", "bodyText": "There are a bunch of tests in io.prestosql.operator.scalar.time.TestTime.testCastFromTimeWithTimeZone", "author": "martint", "createdAt": "2020-07-31T19:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MjY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MjczMQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463542731", "bodyText": "add a case with as time(1) and as time(9) as well", "author": "findepi", "createdAt": "2020-07-31T10:51:34Z", "path": "presto-main/src/test/java/io/prestosql/type/TestTimestampWithTimeZoneBase.java", "diffHunk": "@@ -267,7 +269,16 @@ public void testCastToDate()\n     }\n \n     @Test\n-    public abstract void testCastToTime();\n+    public void testCastToTime()\n+    {\n+        assertFunction(\"cast(TIMESTAMP '2001-1-22 03:04:05.321 +07:09' as time)\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc4OTM0OA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463789348", "bodyText": "There are a bunch of tests for this in TestTimestampWithTimeZone.testCastToTime", "author": "martint", "createdAt": "2020-07-31T19:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MjczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0MzQ3OA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463543478", "bodyText": "this  should not need to round, it should just \"represent\"\nso maybe checkArgument instead?", "author": "findepi", "createdAt": "2020-07-31T10:53:28Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/SqlTime.java", "diffHunk": "@@ -15,100 +15,80 @@\n \n import com.fasterxml.jackson.annotation.JsonValue;\n \n-import java.time.Instant;\n-import java.time.ZoneId;\n-import java.time.ZoneOffset;\n-import java.time.format.DateTimeFormatter;\n import java.util.Objects;\n-import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.Timestamps.MINUTES_PER_HOUR;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.spi.type.Timestamps.POWERS_OF_TEN;\n+import static io.prestosql.spi.type.Timestamps.SECONDS_PER_MINUTE;\n+import static io.prestosql.spi.type.Timestamps.round;\n+import static java.lang.String.format;\n \n public final class SqlTime\n {\n-    private static final DateTimeFormatter JSON_FORMATTER = DateTimeFormatter.ofPattern(\"HH:mm:ss.SSS\");\n-\n-    private final long millis;\n-    private final Optional<TimeZoneKey> sessionTimeZoneKey;\n-\n-    public SqlTime(long millis)\n-    {\n-        this.millis = millis;\n-        this.sessionTimeZoneKey = Optional.empty();\n-    }\n+    private final int precision;\n+    private final long picos;\n \n-    @Deprecated\n-    public SqlTime(long millisUtc, TimeZoneKey sessionTimeZoneKey)\n+    public static SqlTime newInstance(int precision, long picos)\n     {\n-        this.millis = millisUtc;\n-        this.sessionTimeZoneKey = Optional.of(sessionTimeZoneKey);\n+        return new SqlTime(precision, round(picos, 12 - precision));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NDAyMw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463544023", "bodyText": "can overflow?\nalso, depending on what getMillis() above does, this needs to round to [0, PICOS_PER_DAY)", "author": "findepi", "createdAt": "2020-07-31T10:54:54Z", "path": "presto-record-decoder/src/main/java/io/prestosql/decoder/json/AbstractDateTimeJsonValueProvider.java", "diffHunk": "@@ -66,7 +67,10 @@ public final long getLong()\n         if (type.equals(DATE)) {\n             return TimeUnit.MILLISECONDS.toDays(millis);\n         }\n-        if (type.equals(TIMESTAMP) || type.equals(TIME)) {\n+        if (type.equals(TIME)) {\n+            return millis * PICOSECONDS_PER_MILLISECOND;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgwNDI5NA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463804294", "bodyText": "It shouldn't. If it's a TIME, the value should be between [0, MILLIS_PER_DAY]. See the check above: if (millis < 0 || millis >= TimeUnit.DAYS.toMillis(1)) { ... }", "author": "martint", "createdAt": "2020-07-31T19:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NDAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NDg4Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463544886", "bodyText": "this can overlfow, because millis and PICOSECONDS_PER_MILLISECOND are both ints\nalso, this needs to round to [0, PICOS_OF_DAY)", "author": "findepi", "createdAt": "2020-07-31T10:57:05Z", "path": "presto-mongodb/src/main/java/io/prestosql/plugin/mongodb/MongoPageSource.java", "diffHunk": "@@ -183,7 +184,8 @@ else if (type.equals(DATE)) {\n                     type.writeLong(output, TimeUnit.MILLISECONDS.toDays(utcMillis));\n                 }\n                 else if (type.equals(TIME)) {\n-                    type.writeLong(output, UTC_CHRONOLOGY.millisOfDay().get(((Date) value).getTime()));\n+                    int millis = UTC_CHRONOLOGY.millisOfDay().get(((Date) value).getTime());\n+                    type.writeLong(output, millis * PICOSECONDS_PER_MILLISECOND);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgwMzA0MA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463803040", "bodyText": "also, this needs to round to [0, PICOS_OF_DAY)\n\nmillis comes from millisOfDay, so it has to be in the range [0, MILLIS_PER_DAY]. So millis * PICOSECONDS_PER_MILLISECOND is guaranteed to be in the range [0, PICOS_OF_DAY)", "author": "martint", "createdAt": "2020-07-31T19:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NDg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0OTA3Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463849076", "bodyText": "you're correct. OTOH, you could save reader's time adorning this with a comment or doing multiplyExact -- just to consider", "author": "findepi", "createdAt": "2020-07-31T21:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU0NDg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxNTYyOA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463815628", "bodyText": "This class seems to nearly be a susbet of DateTimes. Could the rest of its functionality be moved here (and then this class could also be renamed DateTimes)?\nIf that's too much to move, the two classes should at least define the same set of conversion constants and functions, and have comments referring to each other (and a todo to merge them).\n(This class should probably be renamed to DateTimes either way, given that the conversion constants seem to be used at least as much for times as for timestamps.)\n\n(The constants' definitions could also be a bit nicer.)\nThis is the minimal definition for all of the constants currently in either class:\npublic static final int PICOSECONDS_PER_NANOSECOND = 1000;\npublic static final int NANOSECONDS_PER_MICROSECOND = 1000;\npublic static final int MICROSECONDS_PER_MILLISECOND = 1000;\npublic static final int MILLISECONDS_PER_SECOND = 1000;\npublic static final int SECONDS_PER_MINUTE = 60;\npublic static final int MINUTES_PER_HOUR = 60;\npublic static final int HOURS_PER_DAY = 24;\n\npublic static final int SECONDS_PER_DAY = SECONDS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int MILLISECONDS_PER_DAY = MILLISECONDS_PER_SECOND * SECONDS_PER_DAY;\n\npublic static final int MICROSECONDS_PER_SECOND = MICROSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final long MICROSECONDS_PER_DAY = (long) MICROSECONDS_PER_MILLISECOND * MILLISECONDS_PER_DAY;\n\npublic static final int NANOSECONDS_PER_MILLISECOND = NANOSECONDS_PER_MICROSECOND * MICROSECONDS_PER_MILLISECOND;\npublic static final long NANOSECONDS_PER_DAY = (long) NANOSECONDS_PER_MILLISECOND * MILLISECONDS_PER_DAY;\n\npublic static final int PICOSECONDS_PER_MICROSECOND = PICOSECONDS_PER_NANOSECOND * NANOSECONDS_PER_MICROSECOND;\npublic static final int PICOSECONDS_PER_MILLISECOND = PICOSECONDS_PER_MICROSECOND * MICROSECONDS_PER_MILLISECOND;\npublic static final long PICOSECONDS_PER_SECOND = (long) PICOSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final long PICOSECONDS_PER_MINUTE = PICOSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final long PICOSECONDS_PER_HOUR = PICOSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final long PICOSECONDS_PER_DAY = PICOSECONDS_PER_HOUR * HOURS_PER_DAY;\n\n(There are 9 additional constants not specified in either class.)\nHere's the full set, if you want them:\npublic static final int PICOSECONDS_PER_NANOSECOND = 1000;\npublic static final int NANOSECONDS_PER_MICROSECOND = 1000;\npublic static final int MICROSECONDS_PER_MILLISECOND = 1000;\npublic static final int MILLISECONDS_PER_SECOND = 1000;\npublic static final int SECONDS_PER_MINUTE = 60;\npublic static final int MINUTES_PER_HOUR = 60;\npublic static final int HOURS_PER_DAY = 24;\n\npublic static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int MILLISECONDS_PER_MINUTE = MILLISECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final int MILLISECONDS_PER_HOUR = MILLISECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final int MILLISECONDS_PER_DAY = MILLISECONDS_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int MICROSECONDS_PER_SECOND = MICROSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final int MICROSECONDS_PER_MINUTE = MICROSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final long MICROSECONDS_PER_HOUR = (long) MICROSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final long MICROSECONDS_PER_DAY = MICROSECONDS_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int NANOSECONDS_PER_MILLISECOND = NANOSECONDS_PER_MICROSECOND * MICROSECONDS_PER_MILLISECOND;\npublic static final int NANOSECONDS_PER_SECOND = NANOSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final long NANOSECONDS_PER_MINUTE = (long) NANOSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final long NANOSECONDS_PER_HOUR = NANOSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final long NANOSECONDS_PER_DAY = NANOSECONDS_PER_HOUR * HOURS_PER_DAY;\n\npublic static final int PICOSECONDS_PER_MICROSECOND = PICOSECONDS_PER_NANOSECOND * NANOSECONDS_PER_MICROSECOND;\npublic static final int PICOSECONDS_PER_MILLISECOND = PICOSECONDS_PER_MICROSECOND * MICROSECONDS_PER_MILLISECOND;\npublic static final long PICOSECONDS_PER_SECOND = (long) PICOSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\npublic static final long PICOSECONDS_PER_MINUTE = PICOSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\npublic static final long PICOSECONDS_PER_HOUR = PICOSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\npublic static final long PICOSECONDS_PER_DAY = PICOSECONDS_PER_HOUR * HOURS_PER_DAY;", "author": "jirassimok", "createdAt": "2020-07-31T20:17:24Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/Timestamps.java", "diffHunk": "@@ -22,10 +22,11 @@\n import static java.lang.Math.floorMod;\n import static java.lang.String.format;\n \n-class Timestamps\n+public class Timestamps", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg3ODU1Ng==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463878556", "bodyText": "Yes, agreed. There is some functionality that is internal to the engine that should not be exposed to connectors, hence it's not in the SPI. We also try to keep the SPI as \"implementation-free\" as possible, but some things are needed for the basic type implementation.\nOnce we're done adding time(p) and time(p) with time zone, we should do some cleanup. Some of the things that make sense when I added timestamp(p) stopped making sense as I rolled in support for other types.", "author": "martint", "createdAt": "2020-07-31T22:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxNTYyOA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODYwOA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463998608", "bodyText": "Can we also check that picos is within [0, 86,400,000,000,000)?", "author": "findepi", "createdAt": "2020-08-01T20:44:08Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/SqlTime.java", "diffHunk": "@@ -15,100 +15,85 @@\n \n import com.fasterxml.jackson.annotation.JsonValue;\n \n-import java.time.Instant;\n-import java.time.ZoneId;\n-import java.time.ZoneOffset;\n-import java.time.format.DateTimeFormatter;\n import java.util.Objects;\n-import java.util.Optional;\n+\n+import static io.prestosql.spi.type.TimeType.MAX_PRECISION;\n+import static io.prestosql.spi.type.Timestamps.MINUTES_PER_HOUR;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_HOUR;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_MINUTE;\n+import static io.prestosql.spi.type.Timestamps.PICOSECONDS_PER_SECOND;\n+import static io.prestosql.spi.type.Timestamps.POWERS_OF_TEN;\n+import static io.prestosql.spi.type.Timestamps.SECONDS_PER_MINUTE;\n+import static io.prestosql.spi.type.Timestamps.rescale;\n+import static io.prestosql.spi.type.Timestamps.round;\n+import static java.lang.String.format;\n \n public final class SqlTime\n {\n-    private static final DateTimeFormatter JSON_FORMATTER = DateTimeFormatter.ofPattern(\"HH:mm:ss.SSS\");\n-\n-    private final long millis;\n-    private final Optional<TimeZoneKey> sessionTimeZoneKey;\n-\n-    public SqlTime(long millis)\n-    {\n-        this.millis = millis;\n-        this.sessionTimeZoneKey = Optional.empty();\n-    }\n+    private final int precision;\n+    private final long picos;\n \n-    @Deprecated\n-    public SqlTime(long millisUtc, TimeZoneKey sessionTimeZoneKey)\n+    public static SqlTime newInstance(int precision, long picos)\n     {\n-        this.millis = millisUtc;\n-        this.sessionTimeZoneKey = Optional.of(sessionTimeZoneKey);\n-    }\n+        if (rescale(rescale(picos, 12, precision), precision, 12) != picos) {\n+            throw new IllegalArgumentException(\"picos contains data beyond specified precision: \" + precision);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODc3Nw==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r463998777", "bodyText": "I think you can  skip this check. It's internal and ArrayIndexOutOfBoundsException below will be good enough", "author": "findepi", "createdAt": "2020-08-01T20:45:48Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/Timestamps.java", "diffHunk": "@@ -43,16 +44,53 @@\n \n     public static final int MILLISECONDS_PER_SECOND = 1_000;\n     public static final int MICROSECONDS_PER_SECOND = 1_000_000;\n+    public static final int NANOSECONDS_PER_MILLISECOND = 1_000_000;\n+    public static final long NANOSECONDS_PER_DAY = 1_000_000_000L * 60 * 60 * 24;\n+    public static final int PICOSECONDS_PER_NANOSECOND = 1_000;\n     public static final int PICOSECONDS_PER_MICROSECOND = 1_000_000;\n     public static final int PICOSECONDS_PER_MILLISECOND = 1_000_000_000;\n+    public static final long PICOSECONDS_PER_SECOND = 1_000_000_000_000L;\n+    public static final long PICOSECONDS_PER_MINUTE = PICOSECONDS_PER_SECOND * 60;\n+    public static final long PICOSECONDS_PER_HOUR = PICOSECONDS_PER_MINUTE * 60;\n+    public static final long PICOSECONDS_PER_DAY = PICOSECONDS_PER_HOUR * 24;\n+    public static final long SECONDS_PER_MINUTE = 60;\n+    public static final long MINUTES_PER_HOUR = 60;\n \n     private Timestamps() {}\n \n-    public static long round(long value, int magnitude)\n+    static long round(long value, int magnitude)\n     {\n         return roundDiv(value, POWERS_OF_TEN[magnitude]) * POWERS_OF_TEN[magnitude];\n     }\n \n+    /**\n+     * Rescales a value of the given precision to another precision by adding 0s or truncating.\n+     */\n+    static long rescale(long value, int fromPrecision, int toPrecision)\n+    {\n+        if (value < 0) {\n+            throw new IllegalArgumentException(\"value must be >= 0\");\n+        }\n+\n+        if (fromPrecision <= toPrecision) {\n+            value *= scaleFactor(fromPrecision, toPrecision);\n+        }\n+        else {\n+            value /= scaleFactor(toPrecision, fromPrecision);\n+        }\n+\n+        return value;\n+    }\n+\n+    private static long scaleFactor(int fromPrecision, int toPrecision)\n+    {\n+        if (fromPrecision > toPrecision) {\n+            throw new IllegalArgumentException(\"fromPrecision must be <= toPrecision\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyNDc5MA==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r464524790", "bodyText": "I wanted a more user-friendly error in case there are bugs", "author": "martint", "createdAt": "2020-08-03T16:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODc3Nw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMjY4MQ==", "url": "https://github.com/trinodb/trino/pull/4381#discussion_r467322681", "bodyText": "Why does this translation go through milliseconds? Shouldn't this be the same?\ntoLocalTime(time).toNanoOfDay() * PICOSECONDS_PER_NANOSECOND\n\nThe millisecond conversion serves to truncate the time, but toLocalTime returns a value with nothing more precise than nanoseconds, so the truncation never does anything.", "author": "jirassimok", "createdAt": "2020-08-07T23:10:53Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -282,11 +282,19 @@ public static ColumnMapping timeColumnMappingUsingSqlTime()\n                 TIME,\n                 (resultSet, columnIndex) -> {\n                     Time time = resultSet.getTime(columnIndex);\n-                    return time.getTime() * PICOSECONDS_PER_MILLISECOND % PICOSECONDS_PER_DAY;\n+                    return (roundDiv(toLocalTime(time).toNanoOfDay(), NANOSECONDS_PER_MILLISECOND) * PICOSECONDS_PER_MILLISECOND) % PICOSECONDS_PER_DAY;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "1b9938891d79fafc52d8cd92af332f593c01eb05", "url": "https://github.com/trinodb/trino/commit/1b9938891d79fafc52d8cd92af332f593c01eb05", "message": "Disable TIME type tests for older driver versions\n\nWe're intentionally breaking compatibility as part of fixing\nthe semantics of TIME type and adding variable-precision support.", "committedDate": "2020-08-11T06:38:17Z", "type": "commit"}, {"oid": "31ba61d169474afc6fc4bd2cbe72f8110f66d8bd", "url": "https://github.com/trinodb/trino/commit/31ba61d169474afc6fc4bd2cbe72f8110f66d8bd", "message": "Rename Timestamps to DateTimes\n\nThis class will contain functions for dealing with TIME type, too.", "committedDate": "2020-08-11T06:38:17Z", "type": "commit"}, {"oid": "19811d3d58e908d145639b1975ec111a0002e138", "url": "https://github.com/trinodb/trino/commit/19811d3d58e908d145639b1975ec111a0002e138", "message": "Implement variable-precision time type\n\n* Removes support for legacy semantics for time type.\n* Changes the internal representation of time type to picoseconds since midnight. This is a backward\n  incompatible change but since time type is broken in many ways today to the point of being almost\n  unusable, this is not such a big problem.", "committedDate": "2020-08-11T06:38:17Z", "type": "commit"}, {"oid": "19811d3d58e908d145639b1975ec111a0002e138", "url": "https://github.com/trinodb/trino/commit/19811d3d58e908d145639b1975ec111a0002e138", "message": "Implement variable-precision time type\n\n* Removes support for legacy semantics for time type.\n* Changes the internal representation of time type to picoseconds since midnight. This is a backward\n  incompatible change but since time type is broken in many ways today to the point of being almost\n  unusable, this is not such a big problem.", "committedDate": "2020-08-11T06:38:17Z", "type": "forcePushed"}]}