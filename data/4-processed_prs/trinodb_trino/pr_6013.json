{"pr_number": 6013, "pr_title": "Improve handling of NaN in comparisons", "pr_createdAt": "2020-11-19T07:22:55Z", "pr_url": "https://github.com/trinodb/trino/pull/6013", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4NzE3NA==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535887174", "bodyText": "Since these are for the COMPARISON_UNORDERED_LAST operator, should we name the function name to match as well?", "author": "erichwang", "createdAt": "2020-12-04T07:22:04Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/VarcharType.java", "diffHunk": "@@ -255,13 +255,13 @@ private static long xxHash64Operator(@BlockPosition Block block, @BlockIndex int\n         return block.hash(position, 0, block.getSliceLength(position));\n     }\n \n-    @ScalarOperator(COMPARISON)\n+    @ScalarOperator(COMPARISON_UNORDERED_LAST)\n     private static long comparisonOperator(Slice left, Slice right)\n     {\n         return left.compareTo(right);\n     }\n \n-    @ScalarOperator(COMPARISON)\n+    @ScalarOperator(COMPARISON_UNORDERED_LAST)\n     private static long comparisonOperator(@BlockPosition Block leftBlock, @BlockIndex int leftPosition, @BlockPosition Block rightBlock, @BlockIndex int rightPosition)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjIxODg3MQ==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r702218871", "bodyText": "These types do not have unordered values, so the concept of placing them first or last is meaning less", "author": "dain", "createdAt": "2021-09-04T02:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4NzE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4ODg2MQ==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535888861", "bodyText": "Are we sure that we want to provide the opposite unordered value ordering if we can't find the right one defined? That seems to suggest that a caller requesting COMPARISON_UNORDERED_FIRST for a specific type is an optional preference and not a requirement?", "author": "erichwang", "createdAt": "2020-12-04T07:26:05Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TypeOperators.java", "diffHunk": "@@ -245,11 +255,24 @@ private OperatorMethodHandle selectOperatorMethodHandleToAdapt(OperatorConventio\n                         return List.of(defaultIndeterminateOperator(operatorConvention.getType().getJavaType()));\n                     }\n                     return indeterminateOperators;\n-                case COMPARISON:\n+                case COMPARISON_UNORDERED_LAST:\n                     if (operatorConvention.getSortOrder().isPresent()) {\n                         return List.of(generateOrderingOperator(operatorConvention));\n                     }\n-                    return typeOperatorDeclaration.getComparisonOperators();\n+                    Collection<OperatorMethodHandle> comparisonUnorderedLastOperators = typeOperatorDeclaration.getComparisonUnorderedLastOperators();\n+                    if (comparisonUnorderedLastOperators.isEmpty()) {\n+                        return typeOperatorDeclaration.getComparisonUnorderedFirstOperators();\n+                    }\n+                    return comparisonUnorderedLastOperators;\n+                case COMPARISON_UNORDERED_FIRST:\n+                    if (operatorConvention.getSortOrder().isPresent()) {\n+                        return List.of(generateOrderingOperator(operatorConvention));\n+                    }\n+                    Collection<OperatorMethodHandle> comparisonUnorderedFirstOperators = typeOperatorDeclaration.getComparisonUnorderedFirstOperators();\n+                    if (comparisonUnorderedFirstOperators.isEmpty()) {\n+                        return typeOperatorDeclaration.getComparisonUnorderedLastOperators();\n+                    }\n+                    return comparisonUnorderedFirstOperators;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjIxODgzNA==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r702218834", "bodyText": "This is common for the type operatorrs to be generated from other operators.  I this case the only difference between the two ordering is the placement of the \"unordered\" values.  Most types do not have unordered values and thus should not have multiple methods.", "author": "dain", "createdAt": "2021-09-04T02:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg4ODg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5MTc4Nw==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535891787", "bodyText": "You can flatten this into a 3 line ternary:\nMethodHandle handle = isMin\n  ? typeOperators.getComparisonUnorderedLastOperator(type, convention)\n  : typeOperators.getComparisonUnorderedFirstOperator(type, convention);\n\nAlso in this context, I have a slight preference for \"min\" to be called \"isMin\"", "author": "erichwang", "createdAt": "2020-12-04T07:32:50Z", "path": "presto-main/src/main/java/io/prestosql/util/MinMaxCompare.java", "diffHunk": "@@ -52,6 +53,18 @@ public static MethodHandle getMinMaxCompare(FunctionDependencies dependencies, T\n         return filterReturnValue(handle, min ? MIN_FUNCTION : MAX_FUNCTION);\n     }\n \n+    public static MethodHandle getMinMaxCompare(TypeOperators typeOperators, Type type, InvocationConvention convention, boolean min)\n+    {\n+        MethodHandle handle;\n+        if (min) {\n+            handle = typeOperators.getComparisonUnorderedLastOperator(type, convention);\n+        }\n+        else {\n+            handle = typeOperators.getComparisonUnorderedFirstOperator(type, convention);\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjIxODk2Ng==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r702218966", "bodyText": "I prefer the if/else when it is multiline like that", "author": "dain", "createdAt": "2021-09-04T02:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5MTc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5OTgwMQ==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535899801", "bodyText": "this comment was a bit confusing to read, until i realized you meant: \"this is a greater than operator, so we swap the object order and negate the result\"\nI think using the word \"negate\" here might be a bit more clear.", "author": "erichwang", "createdAt": "2020-12-04T07:49:47Z", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/TypedKeyValueHeap.java", "diffHunk": "@@ -218,4 +220,16 @@ private void compactIfNecessary()\n         keyBlockBuilder = newHeapKeyBlockBuilder;\n         valueBlockBuilder = newHeapValueBlockBuilder;\n     }\n+\n+    private boolean keyGreaterThanOrEqual(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        try {\n+            // this is a greater than operator, so we swap the object order and not the result", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNTkzOQ==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535905939", "bodyText": "Rather than hard coding this directly here, it feels a bit better to pull it out directly from the MinMaxNStateSerializer which should be the one defining this intermediate type. Maybe add a static method to MinMaxNStateSerializer to fetch this?", "author": "erichwang", "createdAt": "2020-12-04T08:02:04Z", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxNAggregationFunction.java", "diffHunk": "@@ -84,31 +89,36 @@ protected AbstractMinMaxNAggregationFunction(String name, Function<Type, BlockPo\n                         AGGREGATE),\n                 true,\n                 false);\n-        requireNonNull(typeToComparison);\n-        this.typeToComparator = typeToComparison;\n+        this.min = min;\n     }\n \n     @Override\n     public List<TypeSignature> getIntermediateTypes(FunctionBinding functionBinding)\n     {\n         Type type = functionBinding.getTypeVariable(\"E\");\n-        return ImmutableList.of(new MinMaxNStateSerializer(typeToComparator.apply(type), type).getSerializedType().getTypeSignature());\n+        return ImmutableList.of(RowType.anonymous(ImmutableList.of(BIGINT, type)).getTypeSignature());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjIyMjI5Mg==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r702222292", "bodyText": "Ya this code is a bit of a mess.  I clean this up as part of the function refactoring code.", "author": "dain", "createdAt": "2021-09-04T02:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNTkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxMDk0MA==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r535910940", "bodyText": "So it's interesting that the nulls ordering is handled through an operator adapter, rather than a separate operator. Would it make sense to have the unordered first/last also be an InvocationConvention as well rather than a separate operator? Not sure if that breaks anything we are trying to do here, but it seems to more closely fit the usage where we have some basic behavior for types that may need to be specialized in some cases.", "author": "erichwang", "createdAt": "2020-12-04T08:11:38Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TypeOperators.java", "diffHunk": "@@ -116,20 +117,29 @@ public MethodHandle getIndeterminateOperator(Type type, InvocationConvention cal\n         return getOperatorAdaptor(type, callingConvention, OperatorType.INDETERMINATE).get();\n     }\n \n-    public MethodHandle getComparisonOperator(Type type, InvocationConvention callingConvention)\n+    public MethodHandle getComparisonUnorderedLastOperator(Type type, InvocationConvention callingConvention)\n     {\n         if (!type.isOrderable()) {\n             throw new UnsupportedOperationException(type + \" is not orderable\");\n         }\n-        return getOperatorAdaptor(type, callingConvention, COMPARISON).get();\n+        return getOperatorAdaptor(type, callingConvention, COMPARISON_UNORDERED_LAST).get();\n+    }\n+\n+    public MethodHandle getComparisonUnorderedFirstOperator(Type type, InvocationConvention callingConvention)\n+    {\n+        if (!type.isOrderable()) {\n+            throw new UnsupportedOperationException(type + \" is not orderable\");\n+        }\n+        return getOperatorAdaptor(type, callingConvention, COMPARISON_UNORDERED_FIRST).get();\n     }\n \n     public MethodHandle getOrderingOperator(Type type, SortOrder sortOrder, InvocationConvention callingConvention)\n     {\n         if (!type.isOrderable()) {\n             throw new UnsupportedOperationException(type + \" is not orderable\");\n         }\n-        return getOperatorAdaptor(type, Optional.of(sortOrder), callingConvention, COMPARISON).get();\n+        OperatorType comparisonType = sortOrder.isNullsFirst() ? COMPARISON_UNORDERED_LAST : COMPARISON_UNORDERED_FIRST;\n+        return getOperatorAdaptor(type, Optional.of(sortOrder), callingConvention, comparisonType).get();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMjIyMjk0Mw==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r702222943", "bodyText": "The invocation convention is really about the shape and capabilitties of the callsite, and not really about the desired target linkage method.  Also, I expect that would be a much bigger change.", "author": "dain", "createdAt": "2021-09-04T02:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxMDk0MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "986dc7637cae318364f7f8a72afcf4f2c70b4ca7", "url": "https://github.com/trinodb/trino/commit/986dc7637cae318364f7f8a72afcf4f2c70b4ca7", "message": "Remove unused BlockPositionComparison.reversed()", "committedDate": "2021-09-04T02:29:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzgyMTg5MA==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r703821890", "bodyText": "Add a comment explaining why this is ok.", "author": "martint", "createdAt": "2021-09-07T20:52:28Z", "path": "core/trino-spi/src/main/java/io/trino/spi/type/TypeOperators.java", "diffHunk": "@@ -245,11 +255,24 @@ private OperatorMethodHandle selectOperatorMethodHandleToAdapt(OperatorConventio\n                         return List.of(defaultIndeterminateOperator(operatorConvention.getType().getJavaType()));\n                     }\n                     return indeterminateOperators;\n-                case COMPARISON:\n+                case COMPARISON_UNORDERED_LAST:\n                     if (operatorConvention.getSortOrder().isPresent()) {\n                         return List.of(generateOrderingOperator(operatorConvention));\n                     }\n-                    return typeOperatorDeclaration.getComparisonOperators();\n+                    Collection<OperatorMethodHandle> comparisonUnorderedLastOperators = typeOperatorDeclaration.getComparisonUnorderedLastOperators();\n+                    if (comparisonUnorderedLastOperators.isEmpty()) {\n+                        return typeOperatorDeclaration.getComparisonUnorderedFirstOperators();", "originalCommit": "e1c0fa6ce7cda8c5c4a12a8ef26a6c7a4035b00f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzgyNDEzMA==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r703824130", "bodyText": "In every place where the choice is arbitrary, we should have a comment so that future readers can understand why a choice was made. Or introduce a constant or method that makes the choice of a comparison that doesn't care whether unorderable values go explicit.", "author": "martint", "createdAt": "2021-09-07T20:56:21Z", "path": "core/trino-main/src/main/java/io/trino/operator/SimplePagesHashStrategy.java", "diffHunk": "@@ -60,7 +60,7 @@ public SimplePagesHashStrategy(\n     {\n         this.types = ImmutableList.copyOf(requireNonNull(types, \"types is null\"));\n         this.comparisonOperators = types.stream()\n-                .map(type -> type.isOrderable() ? Optional.of(blockTypeOperators.getComparisonOperator(type)) : Optional.<BlockPositionComparison>empty())\n+                .map(type -> type.isOrderable() ? Optional.of(blockTypeOperators.getComparisonUnorderedLastOperator(type)) : Optional.<BlockPositionComparison>empty())", "originalCommit": "e1c0fa6ce7cda8c5c4a12a8ef26a6c7a4035b00f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzg5NTEzMA==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r703895130", "bodyText": "Add some documentation about what \"unordered last/first\" means", "author": "martint", "createdAt": "2021-09-07T22:28:03Z", "path": "core/trino-spi/src/main/java/io/trino/spi/function/OperatorType.java", "diffHunk": "@@ -22,7 +22,8 @@\n     MODULUS(\"%\", 2),\n     NEGATION(\"-\", 1),\n     EQUAL(\"=\", 2),\n-    COMPARISON(\"COMPARISON\", 2),\n+    COMPARISON_UNORDERED_LAST(\"COMPARISON_UNORDERED_LAST\", 2),", "originalCommit": "e1c0fa6ce7cda8c5c4a12a8ef26a6c7a4035b00f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMzg5NjEwNg==", "url": "https://github.com/trinodb/trino/pull/6013#discussion_r703896106", "bodyText": "This operator for the boolean type doesn't really deal with unordered values (since there's no such a thing for booleans), so the fact that it's being declared as \"unordered last\" is a bit misleading.", "author": "martint", "createdAt": "2021-09-07T22:30:27Z", "path": "core/trino-spi/src/main/java/io/trino/spi/type/BooleanType.java", "diffHunk": "@@ -154,7 +154,7 @@ private static long xxHash64Operator(boolean value)\n         return value ? TRUE_XX_HASH : FALSE_XX_HASH;\n     }\n \n-    @ScalarOperator(COMPARISON)\n+    @ScalarOperator(COMPARISON_UNORDERED_LAST)", "originalCommit": "e1c0fa6ce7cda8c5c4a12a8ef26a6c7a4035b00f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "07bc1ff5b67c13e6acc83def7200c9664c7cb394", "url": "https://github.com/trinodb/trino/commit/07bc1ff5b67c13e6acc83def7200c9664c7cb394", "message": "Split comparison into unordered first and last", "committedDate": "2021-10-09T03:32:15Z", "type": "commit"}, {"oid": "cf1a0c254eccb61099bcffa397c9b928c5f151a2", "url": "https://github.com/trinodb/trino/commit/cf1a0c254eccb61099bcffa397c9b928c5f151a2", "message": "Convert min/max by N aggregation to MinMaxCompare helper", "committedDate": "2021-10-09T03:32:17Z", "type": "commit"}, {"oid": "381c5e351ec5dfbfae8cc58ab0cf14fce99f8c81", "url": "https://github.com/trinodb/trino/commit/381c5e351ec5dfbfae8cc58ab0cf14fce99f8c81", "message": "Convert min/max N aggregation to MinMaxCompare helper", "committedDate": "2021-10-09T03:32:30Z", "type": "commit"}, {"oid": "41a2620ddd7dbd0e558dc3324d6be54b4d07b30e", "url": "https://github.com/trinodb/trino/commit/41a2620ddd7dbd0e558dc3324d6be54b4d07b30e", "message": "Remove unused BlockPositionComparison.reversed()", "committedDate": "2021-10-09T03:32:31Z", "type": "commit"}, {"oid": "41a2620ddd7dbd0e558dc3324d6be54b4d07b30e", "url": "https://github.com/trinodb/trino/commit/41a2620ddd7dbd0e558dc3324d6be54b4d07b30e", "message": "Remove unused BlockPositionComparison.reversed()", "committedDate": "2021-10-09T03:32:31Z", "type": "forcePushed"}]}