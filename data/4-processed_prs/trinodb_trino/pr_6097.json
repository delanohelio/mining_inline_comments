{"pr_number": 6097, "pr_title": "Reduce output buffer lock contention", "pr_createdAt": "2020-11-25T15:54:47Z", "pr_url": "https://github.com/trinodb/trino/pull/6097", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxMjcwNg==", "url": "https://github.com/trinodb/trino/pull/6097#discussion_r537912706", "bodyText": "I think this needs more explanation.  This is a write once field, so an unsynchronized volatile read that returns a non-null value is safe, but it returns null, you have to do a synchronized read. At least, I think that is how all of the code is written", "author": "dain", "createdAt": "2020-12-07T23:26:22Z", "path": "presto-main/src/main/java/io/prestosql/execution/buffer/LazyOutputBuffer.java", "diffHunk": "@@ -54,8 +55,9 @@\n     private final Executor executor;\n     private final Runnable notifyStatusChanged;\n \n+    // Note: this field is safe to read without synchronizing but must only be written to from a synchronized block", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMzMjkzMQ==", "url": "https://github.com/trinodb/trino/pull/6097#discussion_r538332931", "bodyText": "Updated the comment.", "author": "pettyjamesm", "createdAt": "2020-12-08T12:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxMjcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMTc3Nw==", "url": "https://github.com/trinodb/trino/pull/6097#discussion_r537931777", "bodyText": "why manually count pages when you can just use pages.size()?", "author": "dain", "createdAt": "2020-12-08T00:11:18Z", "path": "presto-main/src/main/java/io/prestosql/execution/buffer/ClientBuffer.java", "diffHunk": "@@ -151,14 +155,18 @@ public void enqueuePages(Collection<SerializedPageReference> pages)\n \n     private synchronized void addPages(Collection<SerializedPageReference> pages)\n     {\n-        pages.forEach(SerializedPageReference::addReference);\n+        long rowCount = 0;\n+        long bytesAdded = 0;\n+        int pageCount = 0;\n+        for (SerializedPageReference page : pages) {\n+            page.addReference();\n+            pageCount++;\n+            rowCount += page.getPositionCount();\n+            bytesAdded += page.getRetainedSizeInBytes();\n+        }\n         this.pages.addAll(pages);\n-\n-        long rowCount = pages.stream().mapToLong(SerializedPageReference::getPositionCount).sum();\n         rowsAdded.addAndGet(rowCount);\n-        pagesAdded.addAndGet(pages.size());\n-\n-        long bytesAdded = pages.stream().mapToLong(SerializedPageReference::getRetainedSizeInBytes).sum();\n+        pagesAdded.addAndGet(pageCount);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMzNDcyNw==", "url": "https://github.com/trinodb/trino/pull/6097#discussion_r538334727", "bodyText": "Since we're accepting any Collection<SerializedPageReference> implemetation and iterating through it already it seemed safer in terms of the performance cliff to count during iteration than to assume a (cheap) O(1) Collection#size() implementation.", "author": "pettyjamesm", "createdAt": "2020-12-08T12:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMTc3Nw=="}], "type": "inlineReview"}, {"oid": "020b8d084e8374c9d980ffe52ffee47cc1519a1d", "url": "https://github.com/trinodb/trino/commit/020b8d084e8374c9d980ffe52ffee47cc1519a1d", "message": "Avoid unnecessary synchronization in LazyOutputBuffer\n\nAdds an initial dereference attempt against the delegate output\nbuffer before synchronizing so that the common case of having already\nset the delegate output buffer might avoid unnecessarily synchronizing\non the LazyOutputBuffer itself.", "committedDate": "2020-12-08T12:50:44Z", "type": "commit"}, {"oid": "aa1ca36474bf9622924213a0e6cbd711c2b1c0d8", "url": "https://github.com/trinodb/trino/commit/aa1ca36474bf9622924213a0e6cbd711c2b1c0d8", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis.", "committedDate": "2020-12-08T12:50:44Z", "type": "commit"}, {"oid": "aa1ca36474bf9622924213a0e6cbd711c2b1c0d8", "url": "https://github.com/trinodb/trino/commit/aa1ca36474bf9622924213a0e6cbd711c2b1c0d8", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis.", "committedDate": "2020-12-08T12:50:44Z", "type": "forcePushed"}]}