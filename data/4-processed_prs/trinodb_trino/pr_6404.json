{"pr_number": 6404, "pr_title": "Implement dynamic filtering for joins using IS NOT DISTINCT FROM", "pr_createdAt": "2020-12-21T08:44:03Z", "pr_url": "https://github.com/trinodb/trino/pull/6404", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MDQ1Ng==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547260456", "bodyText": "you can compare enums by equality, e.g: operator == EQUAL", "author": "sopel39", "createdAt": "2020-12-22T12:51:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -177,12 +208,20 @@ public ExtractResult(List<Expression> staticConjuncts, List<Descriptor> dynamicC\n         private final DynamicFilterId id;\n         private final Expression input;\n         private final ComparisonExpression.Operator operator;\n+        private final boolean nullAllowed;\n \n-        public Descriptor(DynamicFilterId id, Expression input, ComparisonExpression.Operator operator)\n+        public Descriptor(DynamicFilterId id, Expression input, ComparisonExpression.Operator operator, boolean nullAllowed)\n         {\n             this.id = requireNonNull(id, \"id is null\");\n             this.input = requireNonNull(input, \"input is null\");\n             this.operator = requireNonNull(operator, \"operator is null\");\n+            checkArgument(!nullAllowed || operator.equals(EQUAL), \"nullAllowed should be true only with EQUAL operator\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MTI3NQ==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547261275", "bodyText": "requireNotNull(comparison, \"comparison is null\")", "author": "sopel39", "createdAt": "2020-12-22T12:53:32Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -677,6 +698,33 @@ private DynamicFiltersResult createDynamicFilters(\n             return Stream.of(clause);\n         }\n \n+        private static class DynamicFilterExpression\n+        {\n+            private final ComparisonExpression comparison;\n+            private final boolean nullAllowed;\n+\n+            private DynamicFilterExpression(ComparisonExpression comparison)\n+            {\n+                this(comparison, false);\n+            }\n+\n+            private DynamicFilterExpression(ComparisonExpression comparison, boolean nullAllowed)\n+            {\n+                this.comparison = comparison;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2Mzk0Ng==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547263946", "bodyText": "inline with previous line", "author": "sopel39", "createdAt": "2020-12-22T12:59:03Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -612,23 +616,38 @@ private DynamicFiltersResult createDynamicFilters(\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n-            List<ComparisonExpression> clauses = Streams.concat(\n+            List<DynamicFilterExpression> clauses = Streams.concat(\n                     equiJoinClauses\n                             .stream()\n-                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                            .map(clause -> new DynamicFilterExpression(\n+                                    new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))),\n                     joinFilterClauses.stream()\n                             .flatMap(Rewriter::tryConvertBetweenIntoComparisons)\n-                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))\n-                            .map(ComparisonExpression.class::cast)\n-                            .filter(comparison -> comparison.getLeft() instanceof SymbolReference && comparison.getRight() instanceof SymbolReference)\n-                            .map(comparison -> {\n+                            .filter(clause -> joinDynamicFilteringExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols()))\n+                            .map(expression -> {\n+                                if (expression instanceof NotExpression) {\n+                                    NotExpression notExpression = ((NotExpression) expression);\n+                                    ComparisonExpression comparison = (ComparisonExpression) notExpression.getValue();\n+                                    return new DynamicFilterExpression(\n+                                            new ComparisonExpression(EQUAL, comparison.getLeft(), comparison.getRight()), true);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NTUyMg==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547265522", "bodyText": "make joinDynamicFilteringExpression validate that requirement", "author": "sopel39", "createdAt": "2020-12-22T13:02:38Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -612,23 +616,38 @@ private DynamicFiltersResult createDynamicFilters(\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n-            List<ComparisonExpression> clauses = Streams.concat(\n+            List<DynamicFilterExpression> clauses = Streams.concat(\n                     equiJoinClauses\n                             .stream()\n-                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                            .map(clause -> new DynamicFilterExpression(\n+                                    new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))),\n                     joinFilterClauses.stream()\n                             .flatMap(Rewriter::tryConvertBetweenIntoComparisons)\n-                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))\n-                            .map(ComparisonExpression.class::cast)\n-                            .filter(comparison -> comparison.getLeft() instanceof SymbolReference && comparison.getRight() instanceof SymbolReference)\n-                            .map(comparison -> {\n+                            .filter(clause -> joinDynamicFilteringExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols()))\n+                            .map(expression -> {\n+                                if (expression instanceof NotExpression) {\n+                                    NotExpression notExpression = ((NotExpression) expression);\n+                                    ComparisonExpression comparison = (ComparisonExpression) notExpression.getValue();\n+                                    return new DynamicFilterExpression(\n+                                            new ComparisonExpression(EQUAL, comparison.getLeft(), comparison.getRight()), true);\n+                                }\n+                                return new DynamicFilterExpression((ComparisonExpression) expression);\n+                            })\n+                            .filter(expression -> {\n+                                ComparisonExpression comparison = expression.getComparison();\n+                                return comparison.getLeft() instanceof SymbolReference && comparison.getRight() instanceof SymbolReference;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3NTkxOQ==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547275919", "bodyText": "I think we might want to whitelist support for IS NOT DISTINCT FROM to types where we know that it can be translated into EQUALS with nulls. The reason is that within io.prestosql.spi.function.OperatorType there is a dedicated operator type for EQUAL and IS_DISTINCT_FROM, so these can have different implementations. For most of the types, we know the semantics, but for user types this might be different and we don't use NOT(IS_DISTINCT_FROM) explicitly within DF code.", "author": "sopel39", "createdAt": "2020-12-22T13:25:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -1209,6 +1257,24 @@ private boolean joinEqualityExpression(Expression expression, Collection<Symbol>\n             return joinComparisonExpression(expression, leftSymbols, rightSymbols, ImmutableSet.of(EQUAL));\n         }\n \n+        private boolean joinDynamicFilteringExpression(Expression expression, Collection<Symbol> leftSymbols, Collection<Symbol> rightSymbols)\n+        {\n+            if (expression instanceof NotExpression) {\n+                NotExpression notExpression = (NotExpression) expression;\n+                boolean isDistinctFrom = joinComparisonExpression(notExpression.getValue(), leftSymbols, rightSymbols, ImmutableSet.of(IS_DISTINCT_FROM));\n+                if (!isDistinctFrom) {\n+                    return false;\n+                }\n+                ComparisonExpression comparison = (ComparisonExpression) notExpression.getValue();\n+                Set<Type> expressionTypes = ImmutableSet.of(\n+                        typeAnalyzer.getType(session, types, comparison.getLeft()),\n+                        typeAnalyzer.getType(session, types, comparison.getRight()));\n+                // Dynamic filtering is not supported with IS NOT DISTINCT FROM clause on REAL or DOUBLE types to avoid dealing with NaN values", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MjQwNQ==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547282405", "bodyText": "why not existing table from tpch?", "author": "sopel39", "createdAt": "2020-12-22T13:38:40Z", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -93,11 +95,14 @@ public void setup()\n         // create lineitem table in test connector\n         getQueryRunner().installPlugin(new TestPlugin());\n         getQueryRunner().installPlugin(new TpchPlugin());\n+        getQueryRunner().installPlugin(new TpcdsPlugin());\n         getQueryRunner().installPlugin(new MemoryPlugin());\n         getQueryRunner().createCatalog(\"test\", \"test\", ImmutableMap.of());\n         getQueryRunner().createCatalog(\"tpch\", \"tpch\", ImmutableMap.of());\n+        getQueryRunner().createCatalog(\"tpcds\", \"tpcds\", ImmutableMap.of());\n         getQueryRunner().createCatalog(\"memory\", \"memory\", ImmutableMap.of());\n         computeActual(\"CREATE TABLE lineitem AS SELECT * FROM tpch.tiny.lineitem\");\n+        computeActual(\"CREATE TABLE store_sales AS SELECT * FROM tpcds.tiny.store_sales\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ0MzcwOA==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547443708", "bodyText": "I didn't see NULLs in tpch tables, i'm ok to use a table from there if there are NULLs in some table in it.", "author": "raunaqmorarka", "createdAt": "2020-12-22T18:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MjQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0MDI5Nw==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547840297", "bodyText": "IIRC, TPC-H tables do not contain NULL values...", "author": "rzeyde-varada", "createdAt": "2020-12-23T09:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MjQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg3NzMzMg==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547877332", "bodyText": "Does it increase test runtime?", "author": "sopel39", "createdAt": "2020-12-23T10:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MjQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyMzk0OA==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547923948", "bodyText": "It adds a few seconds, but not too much.", "author": "raunaqmorarka", "createdAt": "2020-12-23T11:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MjQwNQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg3NDA2OA==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547874068", "bodyText": "nit: we should static import these", "author": "sopel39", "createdAt": "2020-12-23T09:56:15Z", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -49,26 +51,47 @@\n import static io.prestosql.spi.type.StandardTypes.BOOLEAN;\n import static io.prestosql.spi.type.StandardTypes.VARCHAR;\n import static io.prestosql.sql.ExpressionUtils.extractConjuncts;\n+import static io.prestosql.sql.tree.BooleanLiteral.FALSE_LITERAL;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n import static java.util.Objects.requireNonNull;\n \n public final class DynamicFilters\n {\n     private DynamicFilters() {}\n \n-    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, SymbolReference input, ComparisonExpression.Operator operator)\n+    public static Expression createDynamicFilterExpression(\n+            Metadata metadata,\n+            DynamicFilterId id,\n+            Type inputType,\n+            SymbolReference input,\n+            ComparisonExpression.Operator operator,\n+            boolean nullAllowed)\n     {\n-        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input, operator);\n+        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input, operator, nullAllowed);\n     }\n \n     @VisibleForTesting\n     public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input, ComparisonExpression.Operator operator)\n+    {\n+        return createDynamicFilterExpression(metadata, id, inputType, input, operator, false);\n+    }\n+\n+    @VisibleForTesting\n+    public static Expression createDynamicFilterExpression(\n+            Metadata metadata,\n+            DynamicFilterId id,\n+            Type inputType,\n+            Expression input,\n+            ComparisonExpression.Operator operator,\n+            boolean nullAllowed)\n     {\n         return new FunctionCallBuilder(metadata)\n                 .setName(QualifiedName.of(Function.NAME))\n                 .addArgument(inputType, input)\n                 .addArgument(VarcharType.VARCHAR, new StringLiteral(operator.toString()))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkyMjg0Nw==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547922847", "bodyText": "We're static importing StandardTypes.BOOLEAN and StandardTypes.VARCHAR in this file, so need to qualify these", "author": "raunaqmorarka", "createdAt": "2020-12-23T11:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg3NDA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg3NjYzNA==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547876634", "bodyText": "Could we translate that into new NotExpression(new CompaisonExpression(IS_DISTINCT_FROM, ...).\nTranslating it into new NotExpression(new ComparisonExpression(EQUAL),  as it is now is hacky", "author": "sopel39", "createdAt": "2020-12-23T10:01:37Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/JoinMatcher.java", "diffHunk": "@@ -155,11 +156,15 @@ private boolean matchDynamicFilters(JoinNode joinNode, SymbolAliases symbolAlias\n             if (build == null) {\n                 return false;\n             }\n-            actual.add(new ComparisonExpression(descriptor.getOperator(), probe.toSymbolReference(), build.toSymbolReference()));\n+            Expression expression = new ComparisonExpression(descriptor.getOperator(), probe.toSymbolReference(), build.toSymbolReference());\n+            if (descriptor.isNullAllowed()) {\n+                expression = new NotExpression(expression);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg3NzAyMg==", "url": "https://github.com/trinodb/trino/pull/6404#discussion_r547877022", "bodyText": "let's translate it into proper not(comparison(IS_DISTRINCT_FROM, ...)", "author": "sopel39", "createdAt": "2020-12-23T10:02:40Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -1109,20 +1110,31 @@ public static GroupingSetDescriptor singleGroupingSet(List<String> groupingKeys)\n         private final SymbolAlias probe;\n         private final ComparisonExpression.Operator operator;\n         private final SymbolAlias build;\n+        private final boolean nullAllowed;\n \n-        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias, boolean nullAllowed)\n         {\n             this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n             this.operator = requireNonNull(operator, \"operator is null\");\n             this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+            this.nullAllowed = nullAllowed;\n+        }\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this(probeAlias, operator, buildAlias, false);\n         }\n \n-        ComparisonExpression getComparisonExpression(SymbolAliases aliases)\n+        Expression getExpression(SymbolAliases aliases)\n         {\n-            return new ComparisonExpression(\n+            ComparisonExpression comparison = new ComparisonExpression(\n                     operator,\n                     probe.toSymbol(aliases).toSymbolReference(),\n                     build.toSymbol(aliases).toSymbolReference());\n+            if (!nullAllowed) {\n+                return comparison;\n+            }\n+            return new NotExpression(comparison);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "642586fe6d57029f38c80c9f9497c2e942022f7a", "url": "https://github.com/trinodb/trino/commit/642586fe6d57029f38c80c9f9497c2e942022f7a", "message": "Implement dynamic filtering for joins using IS NOT DISTINCT FROM\n\nImproves performance for joins explcitly using IS NOT DISTINCT FROM\ncondition for the join criteria", "committedDate": "2020-12-23T11:53:18Z", "type": "commit"}, {"oid": "642586fe6d57029f38c80c9f9497c2e942022f7a", "url": "https://github.com/trinodb/trino/commit/642586fe6d57029f38c80c9f9497c2e942022f7a", "message": "Implement dynamic filtering for joins using IS NOT DISTINCT FROM\n\nImproves performance for joins explcitly using IS NOT DISTINCT FROM\ncondition for the join criteria", "committedDate": "2020-12-23T11:53:18Z", "type": "forcePushed"}]}