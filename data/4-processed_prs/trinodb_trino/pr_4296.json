{"pr_number": 4296, "pr_title": "Try compacting table multiple times if compaction has failed", "pr_createdAt": "2020-07-01T12:18:42Z", "pr_url": "https://github.com/trinodb/trino/pull/4296", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2MjM3Ng==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448862376", "bodyText": "should we take all and then assert that the size of list is either 0 or 1", "author": "losipiuk", "createdAt": "2020-07-02T09:12:16Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +183,58 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(\"Could not compact table, retries \" + event.getAttemptCount(), event.getFailure());\n+                })\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, timeout));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))\n+                    .filter(row -> Long.parseLong(row.get(\"start time\")) >= beforeCompactionStart)\n+                    .findFirst();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NTMxNA==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448945314", "bodyText": "We are filtering compaction that started after beforeCompactionStart so there should be exactly [0;1] compaction in state {running,failed,completed,cleaning up}.", "author": "wendigo", "createdAt": "2020-07-02T11:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2MjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NzY4MA==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448947680", "bodyText": "Yeah - I know. Just it would be nice to assert that. Not blindly take first.", "author": "losipiuk", "createdAt": "2020-07-02T11:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg2MjM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MDQ2NQ==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448880465", "bodyText": "move to Try compacting table multiple times if compaction has failed", "author": "losipiuk", "createdAt": "2020-07-02T09:43:01Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -183,13 +187,16 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n         Failsafe.with(\n                 new RetryPolicy<>()\n                         .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n                         .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n                 .onFailure(event -> {\n-                    throw new IllegalStateException(\"Could not compact table, retries \" + event.getAttemptCount(), event.getFailure());\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448881223", "bodyText": "nit: i think logging at INFO is enough for that to show in CI logs. Higher severity is kinda not in-line with what testng does as even test-failure is logged as INFO.", "author": "losipiuk", "createdAt": "2020-07-02T09:44:20Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -218,11 +227,13 @@ private static void tryCompactingTable(CompactionMode compactMode, String tableN\n                     .findFirst();\n \n             if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NTUzOA==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448895538", "bodyText": "Also, how many log lines do we produce per test run?\nHow many log lines per this test class?\nis there a risk of bloating the test output?\n(this could make viewing test logs in the browser harder)", "author": "findepi", "createdAt": "2020-07-02T10:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NTczMA==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448945730", "bodyText": "@findepi not much, couple of extra lines per test run", "author": "wendigo", "createdAt": "2020-07-02T11:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1MTc2MA==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448951760", "bodyText": "I'll remove that log line. Does not bring much of a value", "author": "wendigo", "createdAt": "2020-07-02T12:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MTIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTcyNg==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448891726", "bodyText": "why reduce?", "author": "findepi", "createdAt": "2020-07-02T10:02:36Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -80,7 +83,7 @@ public void testReadFullAcid(boolean isPartitioned, BucketingType bucketingType)\n \n             // test minor compacted data read\n             onHive().executeQuery(\"INSERT INTO TABLE \" + tableName + hivePartitionString + \" VALUES (20, 3)\");\n-            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NTkxOQ==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448945919", "bodyText": "compaction takes around 20-30 seconds", "author": "wendigo", "createdAt": "2020-07-02T11:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1MTU1NA==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448951554", "bodyText": "I could bound that in 1m", "author": "wendigo", "createdAt": "2020-07-02T12:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkwOQ==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448891909", "bodyText": "why reduce?", "author": "findepi", "createdAt": "2020-07-02T10:02:54Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -125,7 +128,7 @@ public void testReadInsertOnly(boolean isPartitioned, BucketingType bucketingTyp\n             assertThat(query(selectFromOnePartitionsSql)).containsExactly(row(1), row(2));\n \n             // test minor compacted data read\n-            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+            compactTableAndWait(MINOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NjAyMw==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448946023", "bodyText": "compaction takes around 20-30 seconds tops", "author": "wendigo", "createdAt": "2020-07-02T11:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkzOQ==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448891939", "bodyText": "why reduce?", "author": "findepi", "createdAt": "2020-07-02T10:02:58Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -137,7 +140,7 @@ public void testReadInsertOnly(boolean isPartitioned, BucketingType bucketingTyp\n \n                 // test major compaction\n                 onHive().executeQuery(\"INSERT INTO TABLE \" + tableName + hivePartitionString + \" SELECT 4\");\n-                compactTableAndWait(MAJOR, tableName, hivePartitionString, Duration.valueOf(\"5m\"));\n+                compactTableAndWait(MAJOR, tableName, hivePartitionString, Duration.valueOf(\"3m\"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NjEwOQ==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448946109", "bodyText": "compaction takes around 60-90 seconds on my local machine. On GHA i can see times around 20-30 seconds.", "author": "wendigo", "createdAt": "2020-07-02T11:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MTkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MjkxMw==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448892913", "bodyText": "is 90s enough? what's typical time it takes on CI?", "author": "findepi", "createdAt": "2020-07-02T10:04:41Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0OTY4OA==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448949688", "bodyText": "~20-30 seconds on GHA:\nMINOR:\nPT34.838358153S\nPT30.844574209S\nPT29.576314653S\nPT31.662333431S\nPT32.115200646S\nPT32.932911889S\nPT33.893968919S\nPT29.637382943S\nPT3.384991089S\nPT6.792642366S\nPT3.277330249S\nPT5.378576046S\nPT6.337980713S\nPT4.7940377S\nPT5.384031019S\nPT5.475184157S\nPT22.72873679S\nPT22.162208904S\nPT20.25416786S\nPT28.962255175S\nPT20.369906495S\nPT20.36921996S\nPT25.370782901S\nPT21.177042401S\nPT9.567928944S\nPT8.48389606S\nPT8.445362006S\nPT10.563044679S\nPT10.54838043S\nPT6.392878269S\nPT5.366843937S\nPT5.411921104S\nPT22.50301294S\nPT21.209129968S\nPT23.706054989S\nPT28.109694148S\nPT19.413351215S\nPT24.236665704S\nPT23.882030693S\nPT25.434501155S\nPT3.470249565S\nPT4.540120403S\nPT1.292804921S\nPT5.375794887S\nPT5.472470425S\nPT8.654503554S\nPT6.425966434S\nPT6.408570237S\nPT31.023044459S\nPT24.549324998S\nPT28.908349388S\nPT28.839517233S\nPT25.091203992S\nPT24.729353252S\nPT24.728750437S\nPT21.367408401S\nPT2.676350984S\nPT6.433613682S\nPT6.800652414S\nPT5.835448164S\nPT5.359681922S\nPT6.436965362S\nPT4.375353378S\nPT5.390717631S\nPT25.930694265S\nPT22.174943204S\nPT24.251963387S\nPT18.069997819S\nPT21.13523818S\nPT23.32611175S\nPT21.484904459S\nPT25.693757204S\nPT6.402732506S\nPT10.529744223S\nPT6.753379343S\nPT7.800682509S\nPT6.482521267S\nPT6.772835094S\nPT10.488767769S\nPT7.495694755S\nPT25.937212248S\nPT18.261208232S\nPT29.76267732S\nPT24.525648134S\nPT24.777551591S\nPT29.647508626S\nPT20.467010381S\nPT24.691764453S\nPT3.290379089S\nPT3.306461549S\nPT5.762540276S\nPT1.651054048S\nPT1.289065089S\nPT3.740514872S\nPT5.395394702S\nPT5.374730286S\nPT29.95287575S\nPT19.395009562S\nPT24.513842613S\nPT29.871213374S\nPT19.313993858S\nPT26.507932332S\nPT24.39135613S\nPT24.543590796S\nPT8.915620955S\nPT8.524092371S\nPT7.836225487S\nPT6.478680622S\nPT5.522861469S\nPT5.800177765S\nPT6.480432644S\nPT5.85404512S\nPT25.69831208S\nPT20.698268428S\nPT29.107473986S\nPT27.216014399S\nPT27.000289095S\nPT24.051333288S\nPT29.803226643S\nPT28.584425318S\nPT3.316932009S\nPT7.48672612S\nPT5.401890444S\nPT5.630835785S\nPT5.355070023S\nPT5.42534251S\nPT4.353071406S\nPT6.516268257S\n\nMAJOR:\nPT35.491362277S\nPT27.040763797S\nPT35.31016765S\nPT36.626785954S\nPT36.653313653S\nPT35.163148959S\nPT39.572599944S\nPT35.06559024S\nPT23.29204194S\nPT22.201155344S\nPT26.901805328S\nPT28.072207201S\nPT26.915338869S\nPT25.916837113S\nPT23.751669051S\nPT25.962492511S\nPT22.141980261S\nPT17.177667464S\nPT26.184159558S\nPT25.635737023S\nPT26.720874883S\nPT26.237793639S\nPT27.078842519S\nPT26.006621506S\nPT21.297192303S\nPT22.391867352S\nPT25.822026411S\nPT25.632236496S\nPT21.89423386S\nPT26.494759405S\nPT25.551515357S\nPT25.109847925S\nPT22.197301312S\nPT22.376736998S\nPT22.586709815S\nPT26.586578429S\nPT27.712236441S\nPT26.955078837S\nPT22.787868064S\nPT30.576637061S\nPT21.46546404S\nPT17.084862765S\nPT25.873188493S\nPT26.453920875S\nPT25.179263581S\nPT29.925661268S\nPT26.802172906S\nPT26.463805746S\nPT22.791848413S\nPT22.346346515S\nPT28.961529438S\nPT26.614371831S\nPT26.398776127S\nPT26.839003049S\nPT22.701335815S\nPT26.656246586S\nPT22.696022337S\nPT21.443843753S\nPT29.963166471S\nPT25.706105172S\nPT26.305594413S\nPT27.54011601S\nPT25.764195308S\nPT24.92160194S", "author": "wendigo", "createdAt": "2020-07-02T11:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MjkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MzM4MA==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448893380", "bodyText": "The clocks are in sync (single host), so you can use System.currentTimeMillis", "author": "findepi", "createdAt": "2020-07-02T10:05:29Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5MzY5NQ==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448893695", "bodyText": "add Thread.currentThread().interrupt();", "author": "findepi", "createdAt": "2020-07-02T10:06:05Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NDcxMA==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448894710", "bodyText": "I'd rather have this two-step\n\nfind ours compaction (getTableCompactions + filter by time)\n\nit must exists and must be exactly one\n\n\n(sep stmt) verify it's \"state\" (\"initiated\" or sth else)", "author": "findepi", "createdAt": "2020-07-02T10:07:58Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1NDA1Nw==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448954057", "bodyText": "I know why I've filtered out initiated compactions as the first step. They don't have start time (it's ---)", "author": "wendigo", "createdAt": "2020-07-02T12:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NDcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg5NTA2Mg==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r448895062", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            log.error(\"Compaction has timed out: %s\", startedCompaction.get());\n          \n          \n            \n                            log.error(\"Waiting for compaction has timed out: %s\", startedCompaction.get());", "author": "findepi", "createdAt": "2020-07-02T10:08:41Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,19 +187,66 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"90s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        // Hive's unix_timestamp() returns millis\n+        long beforeCompactionStart = (Long) onHive().executeQuery(\"SELECT unix_timestamp()\").row(0).get(0) * 1000;\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName).collect(toImmutableList()));\n+\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            Optional<Map<String, String>> startedCompaction = getTableCompactions(compactMode, tableName)\n+                    .filter(row -> !row.get(\"state\").equals(\"initiated\"))\n+                    .filter(row -> Long.parseLong(row.get(\"start time\")) >= beforeCompactionStart)\n+                    .findFirst();\n \n-            verify(!compaction.get(\"state\").equals(\"failed\"), \"compaction has failed\");\n-            assertEquals(compaction.get(\"state\"), \"succeeded\");\n-        });\n+            if (startedCompaction.isEmpty()) {\n+                log.warn(\"Compaction has not started yet\");\n+                continue;\n+            }\n+\n+            String compactionState = startedCompaction.get().get(\"state\");\n+            if (compactionState.equals(\"failed\")) {\n+                log.error(\"Compaction has failed: %s\", startedCompaction.get());\n+                // This will retry compacting table\n+                throw new IllegalStateException(\"Compaction has failed\");\n+            }\n+\n+            if (compactionState.equals(\"succeeded\")) {\n+                return;\n+            }\n+\n+            if (Duration.nanosSince(loopStart).compareTo(timeout) > 0) {\n+                log.error(\"Compaction has timed out: %s\", startedCompaction.get());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "url": "https://github.com/trinodb/trino/commit/db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "message": "Try compacting table multiple times if compaction has failed", "committedDate": "2020-07-03T11:04:00Z", "type": "commit"}, {"oid": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "url": "https://github.com/trinodb/trino/commit/db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "message": "Try compacting table multiple times if compaction has failed", "committedDate": "2020-07-03T11:04:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU2OTM3OQ==", "url": "https://github.com/trinodb/trino/pull/4296#discussion_r449569379", "bodyText": "nit: getOnlyElement()", "author": "losipiuk", "createdAt": "2020-07-03T12:55:30Z", "path": "presto-product-tests/src/main/java/io/prestosql/tests/hive/TestHiveTransactionalTable.java", "diffHunk": "@@ -184,25 +189,82 @@ private static String hiveTableProperties(TransactionalTableType transactionalTa\n \n     private static void compactTableAndWait(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n     {\n-        assertEquals(getTableCompactions(compactMode, tableName).count(), 0);\n+        log.info(\"Running %s compaction on %s\", compactMode, tableName);\n+\n+        Failsafe.with(\n+                new RetryPolicy<>()\n+                        .withMaxDuration(java.time.Duration.ofMillis(timeout.toMillis()))\n+                        .withMaxAttempts(Integer.MAX_VALUE))  // limited by MaxDuration\n+                .onFailure(event -> {\n+                    throw new IllegalStateException(format(\"Could not compact table %s in %d retries\", tableName, event.getAttemptCount()), event.getFailure());\n+                })\n+                .onSuccess(event -> log.info(\"Finished %s compaction on %s in %s (%d tries)\", compactMode, tableName, event.getElapsedTime(), event.getAttemptCount()))\n+                .run(() -> tryCompactingTable(compactMode, tableName, partitionString, Duration.valueOf(\"60s\")));\n+    }\n+\n+    private static void tryCompactingTable(CompactionMode compactMode, String tableName, String partitionString, Duration timeout)\n+            throws TimeoutException\n+    {\n+        long beforeCompactionStart = Instant.now().getEpochSecond();\n         onHive().executeQuery(format(\"ALTER TABLE %s %s COMPACT '%s'\", tableName, partitionString, compactMode.name())).getRowsCount();\n \n-        // Since we disabled table auto compaction and we checked that there are no compaction to the table\n-        // we can assume that every compaction from now on is triggered in this test\n-        // and all compaction should complete successfully before proceeding.\n-        assertEventually(timeout, () -> {\n-            Map<String, String> compaction = getOnlyElement(getTableCompactions(compactMode, tableName)\n-                    .collect(toImmutableList()));\n+        log.info(\"Started compactions: %s\", getTableCompactions(compactMode, tableName, OptionalLong.empty()));\n \n-            verify(!compaction.get(\"state\").equals(\"failed\"), \"compaction has failed\");\n-            assertEquals(compaction.get(\"state\"), \"succeeded\");\n-        });\n+        long loopStart = System.nanoTime();\n+        while (true) {\n+            try {\n+                // Compaction takes couple of second so there is no need to check state more frequent than 1s\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new RuntimeException(e);\n+            }\n+\n+            // Since we disabled auto compaction for uniquely named table and every compaction is triggered in this test\n+            // we can expect that single compaction in given mode should complete before proceeding.\n+            List<Map<String, String>> startedCompactions = getTableCompactions(compactMode, tableName, OptionalLong.of(beforeCompactionStart));\n+            verify(startedCompactions.size() < 2, \"Expected at most 1 compaction\");\n+\n+            if (startedCompactions.isEmpty()) {\n+                log.info(\"Compaction has not started yet\");\n+                continue;\n+            }\n+\n+            String compactionState = startedCompactions.get(0).get(\"state\");", "originalCommit": "db95f5cc55cd8f78ecde3480f9d80d1c50ee7851", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}