{"pr_number": 2759, "pr_title": "Fix predicate pushdown in Iceberg connector", "pr_createdAt": "2020-02-07T17:43:19Z", "pr_url": "https://github.com/trinodb/trino/pull/2759", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzI4NA==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r376693284", "bodyText": "nit: use stream", "author": "vrozov", "createdAt": "2020-02-08T07:08:36Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,16 +49,14 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n         tupleDomain.getDomains().get().forEach((column, domain) -> {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NzQ4MQ==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r376757481", "bodyText": "or use Maps.transformValues().", "author": "vrozov", "createdAt": "2020-02-09T05:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMzkwNw==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384723907", "bodyText": "Agreed, using Maps.transformValues() here would avoid this error. But I'd do that refactoring separately, as a different commit.", "author": "electrum", "createdAt": "2020-02-26T19:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzMxMg==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r376693312", "bodyText": "avoid System.out.", "author": "vrozov", "createdAt": "2020-02-08T07:09:03Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,16 +49,14 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n         tupleDomain.getDomains().get().forEach((column, domain) -> {\n             ValueSet valueSet = domain.getValues();\n             ValueSet transformedValueSet = valueSet;\n             Type type = domain.getType();\n             if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n+                System.out.println(valueSet);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMzIzMA==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384723230", "bodyText": "Yes, please remove", "author": "electrum", "createdAt": "2020-02-26T19:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzYyMA==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r376693620", "bodyText": "There is no need to introduce a local variable, use predicate member variable.", "author": "vrozov", "createdAt": "2020-02-08T07:16:20Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergSplitSource.java", "diffHunk": "@@ -75,7 +74,7 @@ public IcebergSplitSource(\n     {\n         // TODO: move this to a background thread\n         List<ConnectorSplit> splits = new ArrayList<>();\n-        TupleDomain<IcebergColumnHandle> predicate = convertTupleDomainTypes(this.predicate);\n+        TupleDomain<IcebergColumnHandle> predicate = this.predicate;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1MTkyMg==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379051922", "bodyText": "Please remove local variable.", "author": "vrozov", "createdAt": "2020-02-13T18:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MzYyMA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA0OTI0Mg==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379049242", "bodyText": "nit: consider converting this to a static method for code readability.", "author": "vrozov", "createdAt": "2020-02-13T18:45:13Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,46 +50,45 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n-        tupleDomain.getDomains().get().forEach((column, domain) -> {\n-            ValueSet valueSet = domain.getValues();\n-            ValueSet transformedValueSet = valueSet;\n-            Type type = domain.getType();\n-            if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n-                if (valueSet instanceof EquatableValueSet) {\n-                    EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n-                    Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n-                            .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n-                            .collect(toImmutableSet());\n-                    transformedValueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n-                }\n-                else if (valueSet instanceof SortedRangeSet) {\n-                    List<Range> ranges = new ArrayList<>();\n-                    for (Range range : valueSet.getRanges().getOrderedRanges()) {\n-                        Marker low = range.getLow();\n-                        if (low.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n-                            low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n+        return TupleDomain.withColumnDomains(Maps.transformValues(\n+                tupleDomain.getDomains().get(),\n+                (domain) -> {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA0OTk3NA==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379049974", "bodyText": "nit: introduction of transformedValueSet is not required, valueSet can be used instead.", "author": "vrozov", "createdAt": "2020-02-13T18:46:36Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,46 +50,45 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n-        tupleDomain.getDomains().get().forEach((column, domain) -> {\n-            ValueSet valueSet = domain.getValues();\n-            ValueSet transformedValueSet = valueSet;\n-            Type type = domain.getType();\n-            if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n-                if (valueSet instanceof EquatableValueSet) {\n-                    EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n-                    Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n-                            .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n-                            .collect(toImmutableSet());\n-                    transformedValueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n-                }\n-                else if (valueSet instanceof SortedRangeSet) {\n-                    List<Range> ranges = new ArrayList<>();\n-                    for (Range range : valueSet.getRanges().getOrderedRanges()) {\n-                        Marker low = range.getLow();\n-                        if (low.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n-                            low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n+        return TupleDomain.withColumnDomains(Maps.transformValues(\n+                tupleDomain.getDomains().get(),\n+                (domain) -> {\n+                    ValueSet valueSet = domain.getValues();\n+                    ValueSet transformedValueSet = valueSet;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA1Mzk5OQ==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379053999", "bodyText": "Once iceberg supports IN predicate, it is not necessary to simplify(). Can you add TODO comment and explain why simplify() is necessary.", "author": "vrozov", "createdAt": "2020-02-13T18:53:54Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -550,7 +550,11 @@ public void rollback()\n     public Optional<ConstraintApplicationResult<ConnectorTableHandle>> applyFilter(ConnectorSession session, ConnectorTableHandle handle, Constraint constraint)\n     {\n         IcebergTableHandle table = (IcebergTableHandle) handle;\n-        TupleDomain<IcebergColumnHandle> newDomain = convertTupleDomainTypes(constraint.getSummary().transform(IcebergColumnHandle.class::cast));\n+        TupleDomain<IcebergColumnHandle> newDomain = convertTupleDomainTypes(\n+                constraint.getSummary()\n+                        .transform(IcebergColumnHandle.class::cast)\n+                        .simplify())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzA2Mw==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r379503063", "bodyText": "It is better to avoid creating a new Domain object and return the original domain here.  It will also be more clear that  domain is not changed for the majority of Types.", "author": "vrozov", "createdAt": "2020-02-14T15:48:00Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -49,46 +50,46 @@ private DomainConverter() {}\n         if (tupleDomain.isAll() || tupleDomain.isNone()) {\n             return tupleDomain;\n         }\n-        if (!tupleDomain.getDomains().isPresent()) {\n-            return tupleDomain;\n-        }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n-        tupleDomain.getDomains().get().forEach((column, domain) -> {\n-            ValueSet valueSet = domain.getValues();\n-            ValueSet transformedValueSet = valueSet;\n-            Type type = domain.getType();\n-            if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n-                if (valueSet instanceof EquatableValueSet) {\n-                    EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n-                    Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n-                            .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n-                            .collect(toImmutableSet());\n-                    transformedValueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n-                }\n-                else if (valueSet instanceof SortedRangeSet) {\n-                    List<Range> ranges = new ArrayList<>();\n-                    for (Range range : valueSet.getRanges().getOrderedRanges()) {\n-                        Marker low = range.getLow();\n-                        if (low.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n-                            low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n-                        }\n+        return TupleDomain.withColumnDomains(Maps.transformValues(\n+                tupleDomain.getDomains().get(),\n+                DomainConverter::translateDomain));\n+    }\n \n-                        Marker high = range.getHigh();\n-                        if (high.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getHigh().getValue()));\n-                            high = new Marker(range.getType(), Optional.of(value), range.getHigh().getBound());\n-                        }\n+    private static Domain translateDomain(Domain domain)\n+    {\n+        ValueSet valueSet = domain.getValues();\n+        Type type = domain.getType();\n+        if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n+            if (valueSet instanceof EquatableValueSet) {\n+                EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n+                Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n+                        .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n+                        .collect(toImmutableSet());\n+                valueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n+            }\n+            else if (valueSet instanceof SortedRangeSet) {\n+                List<Range> ranges = new ArrayList<>();\n+                for (Range range : valueSet.getRanges().getOrderedRanges()) {\n+                    Marker low = range.getLow();\n+                    if (low.getValueBlock().isPresent()) {\n+                        Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n+                        low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n+                    }\n \n-                        ranges.add(new Range(low, high));\n+                    Marker high = range.getHigh();\n+                    if (high.getValueBlock().isPresent()) {\n+                        Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getHigh().getValue()));\n+                        high = new Marker(range.getType(), Optional.of(value), range.getHigh().getBound());\n                     }\n-                    transformedValueSet = SortedRangeSet.copyOf(valueSet.getType(), ranges);\n+\n+                    ranges.add(new Range(low, high));\n                 }\n-                transformedMap.put(column, Domain.create(transformedValueSet, domain.isNullAllowed()));\n+                valueSet = SortedRangeSet.copyOf(valueSet.getType(), ranges);\n             }\n-        });\n-        return TupleDomain.withColumnDomains(transformedMap);\n+        }\n+        return Domain.create(valueSet, domain.isNullAllowed());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyNjE0OA==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384726148", "bodyText": "For all of these where the expected and actual are identical, let's add a new method like assertTupleDomainUnchanged so we don't need to repeat the value.\nprivate void assertTupleDomainUnchanged(TupleDomain<IcebergColumnHandle> domain)\n{\n    assertTupleDomain(domain, domain);\n}\nThat will make it easier to spot the ones that are different.", "author": "electrum", "createdAt": "2020-02-26T19:49:39Z", "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestDomainConverter.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.iceberg;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slices;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.iceberg.DomainConverter.convertTupleDomainTypes;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimestampType.TIMESTAMP;\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainConverter\n+{\n+    private static final Function<Type, IcebergColumnHandle> ICEBERG_COLUMN_PROVIDER = type -> new IcebergColumnHandle(0, \"column\", type, Optional.empty());\n+\n+    @Test\n+    public void testSimple()\n+    {\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testBoolean()\n+    {\n+        assertTupleDomain(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyNzYwNA==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384727604", "bodyText": "It's cleaner to write these tests with a fixed timestamp like 1_234_567_890_123L", "author": "electrum", "createdAt": "2020-02-26T19:52:18Z", "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestDomainConverter.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.iceberg;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slices;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.iceberg.DomainConverter.convertTupleDomainTypes;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimestampType.TIMESTAMP;\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainConverter\n+{\n+    private static final Function<Type, IcebergColumnHandle> ICEBERG_COLUMN_PROVIDER = type -> new IcebergColumnHandle(0, \"column\", type, Optional.empty());\n+\n+    @Test\n+    public void testSimple()\n+    {\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testBoolean()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, true))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, true))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, false))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, false))));\n+    }\n+\n+    @Test\n+    public void testDate()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.singleValue(DATE, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.singleValue(DATE, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.multipleValues(DATE, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.multipleValues(DATE, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testVarbinary()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.singleValue(VARBINARY, Slices.utf8Slice(\"apple\")))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.singleValue(VARBINARY, Slices.utf8Slice(\"apple\")))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.multipleValues(VARBINARY, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.multipleValues(VARBINARY, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))));\n+    }\n+\n+    @Test\n+    public void testDouble()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.singleValue(DOUBLE, 1.0d))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.singleValue(DOUBLE, 1.0d))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.multipleValues(DOUBLE, ImmutableList.of(1.0d, 2.0d, 3.0d)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.multipleValues(DOUBLE, ImmutableList.of(1.0d, 2.0d, 3.0d)))));\n+    }\n+\n+    @Test\n+    public void testBigint()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(BIGINT, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(BIGINT, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testReal()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.singleValue(REAL, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.singleValue(REAL, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.multipleValues(REAL, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.multipleValues(REAL, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testInteger()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(INTEGER, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(INTEGER, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(INTEGER, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(INTEGER, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testVarchar()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"apple\")))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"apple\")))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.multipleValues(VARCHAR, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.multipleValues(VARCHAR, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))));\n+    }\n+\n+    @Test\n+    public void testTimestamp()\n+    {\n+        long time = System.currentTimeMillis();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyODE3Nw==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384728177", "bodyText": "After changing to a fixed timestamp, write the expected literals here, so the expected behavior is more obvious (and easier to tell there isn't a bug in the test code) 1_234_567_890_123_000L", "author": "electrum", "createdAt": "2020-02-26T19:53:13Z", "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestDomainConverter.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.iceberg;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slices;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.iceberg.DomainConverter.convertTupleDomainTypes;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimestampType.TIMESTAMP;\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainConverter\n+{\n+    private static final Function<Type, IcebergColumnHandle> ICEBERG_COLUMN_PROVIDER = type -> new IcebergColumnHandle(0, \"column\", type, Optional.empty());\n+\n+    @Test\n+    public void testSimple()\n+    {\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+        assertTupleDomain(TupleDomain.all(), TupleDomain.all());\n+    }\n+\n+    @Test\n+    public void testBoolean()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, true))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, true))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, false))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BOOLEAN), Domain.singleValue(BOOLEAN, false))));\n+    }\n+\n+    @Test\n+    public void testDate()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.singleValue(DATE, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.singleValue(DATE, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.multipleValues(DATE, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DATE), Domain.multipleValues(DATE, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testVarbinary()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.singleValue(VARBINARY, Slices.utf8Slice(\"apple\")))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.singleValue(VARBINARY, Slices.utf8Slice(\"apple\")))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.multipleValues(VARBINARY, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARBINARY), Domain.multipleValues(VARBINARY, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))));\n+    }\n+\n+    @Test\n+    public void testDouble()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.singleValue(DOUBLE, 1.0d))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.singleValue(DOUBLE, 1.0d))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.multipleValues(DOUBLE, ImmutableList.of(1.0d, 2.0d, 3.0d)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(DOUBLE), Domain.multipleValues(DOUBLE, ImmutableList.of(1.0d, 2.0d, 3.0d)))));\n+    }\n+\n+    @Test\n+    public void testBigint()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(BIGINT, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(BIGINT, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testReal()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.singleValue(REAL, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.singleValue(REAL, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.multipleValues(REAL, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(REAL), Domain.multipleValues(REAL, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testInteger()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(INTEGER, 1L))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.singleValue(INTEGER, 1L))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(INTEGER, ImmutableList.of(1L, 2L, 3L)))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(BIGINT), Domain.multipleValues(INTEGER, ImmutableList.of(1L, 2L, 3L)))));\n+    }\n+\n+    @Test\n+    public void testVarchar()\n+    {\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"apple\")))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.singleValue(VARCHAR, Slices.utf8Slice(\"apple\")))));\n+\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.multipleValues(VARCHAR, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(VARCHAR), Domain.multipleValues(VARCHAR, ImmutableList.of(Slices.utf8Slice(\"apple\"), Slices.utf8Slice(\"banana\"))))));\n+    }\n+\n+    @Test\n+    public void testTimestamp()\n+    {\n+        long time = System.currentTimeMillis();\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(TIMESTAMP), Domain.singleValue(TIMESTAMP, time))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(TIMESTAMP), Domain.singleValue(TIMESTAMP, MILLISECONDS.toMicros(time)))));\n+\n+        List<Long> list = ImmutableList.of(System.currentTimeMillis(), System.currentTimeMillis() - 1000);\n+        assertTupleDomain(\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(TIMESTAMP), Domain.multipleValues(TIMESTAMP, list))),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(ICEBERG_COLUMN_PROVIDER.apply(TIMESTAMP), Domain.multipleValues(TIMESTAMP, list.stream().map(MILLISECONDS::toMicros).collect(toImmutableList())))));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyOTQxNw==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384729417", "bodyText": "Can you move this refactoring to a separate commit? It's hard to tell if this is simply a refactor or is introducing changes to the logic", "author": "electrum", "createdAt": "2020-02-26T19:55:12Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/DomainConverter.java", "diffHunk": "@@ -51,45 +52,45 @@ private DomainConverter() {}\n         }\n \n         Map<IcebergColumnHandle, Domain> transformedMap = new HashMap<>();\n-        tupleDomain.getDomains().get().forEach((column, domain) -> {\n-            ValueSet valueSet = domain.getValues();\n-            ValueSet transformedValueSet = valueSet;\n-            Type type = domain.getType();\n-            if (type instanceof TimestampType || type instanceof TimestampWithTimeZoneType || type instanceof TimeType || type instanceof TimeWithTimeZoneType) {\n-                System.out.println(valueSet);\n-                if (valueSet instanceof EquatableValueSet) {\n-                    EquatableValueSet equatableValueSet = (EquatableValueSet) valueSet;\n-                    Set<ValueEntry> values = equatableValueSet.getEntries().stream()\n-                            .map(value -> ValueEntry.create(value.getType(), convertToMicros(type, (long) value.getValue())))\n-                            .collect(toImmutableSet());\n-                    transformedValueSet = new EquatableValueSet(equatableValueSet.getType(), equatableValueSet.isWhiteList(), values);\n-                }\n-                else if (valueSet instanceof SortedRangeSet) {\n-                    List<Range> ranges = new ArrayList<>();\n-                    for (Range range : valueSet.getRanges().getOrderedRanges()) {\n-                        Marker low = range.getLow();\n-                        if (low.getValueBlock().isPresent()) {\n-                            Block value = nativeValueToBlock(type, convertToMicros(type, (long) range.getLow().getValue()));\n-                            low = new Marker(range.getType(), Optional.of(value), range.getLow().getBound());\n-                        }\n+        return TupleDomain.withColumnDomains(Maps.transformValues(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTkwNg==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384731906", "bodyText": "I don't understand this. simplify() reduces the number of ranges, but can still have multiple ranges. If Iceberg doesn't support IN expressions at all, how does this work?", "author": "electrum", "createdAt": "2020-02-26T19:59:40Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -550,7 +550,12 @@ public void rollback()\n     public Optional<ConstraintApplicationResult<ConnectorTableHandle>> applyFilter(ConnectorSession session, ConnectorTableHandle handle, Constraint constraint)\n     {\n         IcebergTableHandle table = (IcebergTableHandle) handle;\n-        TupleDomain<IcebergColumnHandle> newDomain = convertTupleDomainTypes(constraint.getSummary().transform(IcebergColumnHandle.class::cast));\n+        // TODO: Remove TupleDomain#simplify once Iceberg supports IN expression", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMjc2MQ==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384732761", "bodyText": "Also, is this related to removing the extra convert call in IcebergSplitSource?", "author": "electrum", "createdAt": "2020-02-26T20:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2MzkyMA==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384863920", "bodyText": "As Iceberg does not support IN, it is converted to multiple OR in ExpressionConverter and with a large number of values in the IN set, it causes stack overflow when Iceberg tries to evaluate deeply nested OR.", "author": "vrozov", "createdAt": "2020-02-27T01:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjExMjMwNQ==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r386112305", "bodyText": "Actually Iceberg converts it to OR expression but when iceberg logs that translated expression then it throws stack overflow expression.", "author": "Praveen2112", "createdAt": "2020-03-01T14:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczMTkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2MTU0Mg==", "url": "https://github.com/trinodb/trino/pull/2759#discussion_r384861542", "bodyText": "The newer version of Iceberg will allow Long->Date conversion, so conversion to int won't be necessary. Please see apache/iceberg@eb9c75e.", "author": "vrozov", "createdAt": "2020-02-27T01:12:18Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/ExpressionConverter.java", "diffHunk": "@@ -174,6 +176,10 @@ private static Object getValue(Type type, Marker marker, ConnectorSession sessio\n             return MILLISECONDS.toMicros((Long) marker.getValue());\n         }\n \n+        if (type instanceof DateType) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "de338a8299c32e1bd7b1665040a70daecea96546", "url": "https://github.com/trinodb/trino/commit/de338a8299c32e1bd7b1665040a70daecea96546", "message": "Enable Predicate pushdown for non Timstamp/Time column", "committedDate": "2020-03-02T10:54:27Z", "type": "commit"}, {"oid": "5c9252b8802c1f0f0b0e727ba256b0f9cb297100", "url": "https://github.com/trinodb/trino/commit/5c9252b8802c1f0f0b0e727ba256b0f9cb297100", "message": "Refactor  DomainConverter", "committedDate": "2020-03-02T10:54:33Z", "type": "commit"}, {"oid": "b353a125040c6bb18bdb8d21c9dd5b0636fa57ec", "url": "https://github.com/trinodb/trino/commit/b353a125040c6bb18bdb8d21c9dd5b0636fa57ec", "message": "Push compacted TupleDomain for Iceberg filter", "committedDate": "2020-03-02T10:55:23Z", "type": "commit"}, {"oid": "abc502df19bd38c20127339f2121906493809af1", "url": "https://github.com/trinodb/trino/commit/abc502df19bd38c20127339f2121906493809af1", "message": "Fix predicate pushdown for columns of type Timestamp/Time\n\nThe conversion from millisecond to microsecond happens once again in the\nIcerbergSplitManager", "committedDate": "2020-03-02T10:55:23Z", "type": "commit"}, {"oid": "abc502df19bd38c20127339f2121906493809af1", "url": "https://github.com/trinodb/trino/commit/abc502df19bd38c20127339f2121906493809af1", "message": "Fix predicate pushdown for columns of type Timestamp/Time\n\nThe conversion from millisecond to microsecond happens once again in the\nIcerbergSplitManager", "committedDate": "2020-03-02T10:55:23Z", "type": "forcePushed"}]}