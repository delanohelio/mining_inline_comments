{"pr_number": 4224, "pr_title": "Add support for lazy dynamic filters on coordinator", "pr_createdAt": "2020-06-25T15:18:50Z", "pr_url": "https://github.com/trinodb/trino/pull/4224", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg0NzA0OA==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r449847048", "bodyText": "I am probably missing something, but I am not sure why can't we check JoinNode#getDistributionType below?", "author": "rzeyde-varada", "createdAt": "2020-07-05T07:54:02Z", "path": "presto-main/src/main/java/io/prestosql/operator/JoinUtils.java", "diffHunk": "@@ -41,4 +52,54 @@ private JoinUtils() {}\n         }\n         return pagesBuilder.build();\n     }\n+", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5Nzg0Ng==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r450097846", "bodyText": "The real source of truth about distribution is the plan with exchanges added. For example AddExchanges might choose partitioned join even though CBO selected replicated join (https://github.com/prestosql/presto/blob/6d9d47e0909b3fe9367584ba8450827dbbb8e1d7/presto-main/src/main/java/io/prestosql/sql/planner/optimizations/AddExchanges.java#L670). This definitely can be improved though.", "author": "sopel39", "createdAt": "2020-07-06T09:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg0NzA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg1MDU0MQ==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r449850541", "bodyText": "Maybe we can consolidate the maps above into a single map, e.g.:\nMap<QueryId, PerQueryDynamicFilterInformation> dynamicFilters;", "author": "rzeyde-varada", "createdAt": "2020-07-05T08:31:25Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -62,16 +70,18 @@\n @ThreadSafe\n public class DynamicFilterService\n {\n-    private final Map<SourceDescriptor, Domain> dynamicFilterSummaries = new ConcurrentHashMap<>();\n-\n     private final Duration statusRefreshMaxWait;\n-    @GuardedBy(\"this\")\n-    private final Map<QueryId, Supplier<List<StageDynamicFilters>>> queries = new HashMap<>();\n-    @GuardedBy(\"this\")\n-    private final Map<QueryId, Set<SourceDescriptor>> queryDynamicFilters = new HashMap<>();\n-\n     private final ScheduledExecutorService collectDynamicFiltersExecutor = newSingleThreadScheduledExecutor(daemonThreadsNamed(\"DynamicFilterService\"));\n \n+    @GuardedBy(\"this\") // for updates\n+    private final Map<QueryId, Map<DynamicFilterId, SettableFuture<Domain>>> dynamicFilterSummaries = new ConcurrentHashMap<>();\n+    @GuardedBy(\"this\") // for updates\n+    private final Map<QueryId, Supplier<List<StageDynamicFilters>>> dynamicFilterSuppliers = new ConcurrentHashMap<>();\n+    @GuardedBy(\"this\") // for updates\n+    private final Map<QueryId, Set<DynamicFilterId>> queryRepartitionedDynamicFilters = new ConcurrentHashMap<>();\n+    @GuardedBy(\"this\") // for updates\n+    private final Map<QueryId, Set<DynamicFilterId>> queryReplicatedDynamicFilters = new ConcurrentHashMap<>();\n+", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5OTIxMw==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r450099213", "bodyText": "Yup. Although, separate PR/commit would be better so that it is isolated change.", "author": "sopel39", "createdAt": "2020-07-06T09:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg1MDU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg1MTE1MA==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r449851150", "bodyText": "nit: the following can be precomputed outside the DynamicFilter#isBlocked method:\ndynamicFilters.stream()\n    .filter(repartitionedDynamicFilters::contains)\n    .map(dynamicFilterFutures::get)", "author": "rzeyde-varada", "createdAt": "2020-07-05T08:38:52Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -93,101 +103,200 @@ public void stop()\n     public void registerQuery(SqlQueryExecution sqlQueryExecution)\n     {\n         // register query only if it contains dynamic filters\n-        Set<SourceDescriptor> dynamicFilters = PlanNodeSearcher.searchFrom(sqlQueryExecution.getQueryPlan().getRoot())\n+        ImmutableSet.Builder<DynamicFilterId> dynamicFiltersBuilder = ImmutableSet.builder();\n+        ImmutableSet.Builder<DynamicFilterId> repartitionedDynamicFiltersBuilder = ImmutableSet.builder();\n+        ImmutableSet.Builder<DynamicFilterId> replicatedDynamicFiltersBuilder = ImmutableSet.builder();\n+        PlanNodeSearcher.searchFrom(sqlQueryExecution.getQueryPlan().getRoot())\n                 .where(JoinNode.class::isInstance)\n-                .<JoinNode>findAll().stream()\n-                .flatMap(node -> node.getDynamicFilters().keySet().stream())\n-                .map(dynamicFilter -> SourceDescriptor.of(sqlQueryExecution.getQueryId(), dynamicFilter))\n-                .collect(toImmutableSet());\n+                .<JoinNode>findAll()\n+                .forEach(node -> {\n+                    node.getDynamicFilters().keySet()\n+                            .forEach(dynamicFiltersBuilder::add);\n+                    if (isBuildSideReplicated(node)) {\n+                        replicatedDynamicFiltersBuilder.addAll(node.getDynamicFilters().keySet());\n+                    }\n+                    if (isBuildSideRepartitioned(node)) {\n+                        repartitionedDynamicFiltersBuilder.addAll(node.getDynamicFilters().keySet());\n+                    }\n+                });\n+        Set<DynamicFilterId> dynamicFilters = dynamicFiltersBuilder.build();\n         if (!dynamicFilters.isEmpty()) {\n-            registerQuery(sqlQueryExecution.getQueryId(), sqlQueryExecution::getStageDynamicFilters, dynamicFilters);\n+            registerQuery(\n+                    sqlQueryExecution.getQueryId(),\n+                    sqlQueryExecution::getStageDynamicFilters,\n+                    dynamicFilters,\n+                    repartitionedDynamicFiltersBuilder.build(),\n+                    replicatedDynamicFiltersBuilder.build());\n         }\n     }\n \n     @VisibleForTesting\n-    synchronized void registerQuery(QueryId queryId, Supplier<List<StageDynamicFilters>> stageDynamicFiltersSupplier, Set<SourceDescriptor> dynamicFilters)\n+    void registerQuery(\n+            QueryId queryId,\n+            Supplier<List<StageDynamicFilters>> stageDynamicFiltersSupplier,\n+            Set<DynamicFilterId> dynamicFilters,\n+            Set<DynamicFilterId> repartitionedDynamicFilters,\n+            Set<DynamicFilterId> replicatedDynamicFilters)\n     {\n-        queries.putIfAbsent(queryId, stageDynamicFiltersSupplier);\n-        queryDynamicFilters.put(queryId, dynamicFilters);\n+        Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilterFutures = dynamicFilters.stream()\n+                .collect(toImmutableMap(filter -> filter, filter -> SettableFuture.create()));\n+        synchronized (this) {\n+            if (dynamicFilterSummaries.containsKey(queryId)) {\n+                // query is already registered\n+                return;\n+            }\n+\n+            dynamicFilterSummaries.put(queryId, dynamicFilterFutures);\n+            dynamicFilterSuppliers.put(queryId, stageDynamicFiltersSupplier);\n+            queryRepartitionedDynamicFilters.put(queryId, repartitionedDynamicFilters);\n+            queryReplicatedDynamicFilters.put(queryId, replicatedDynamicFilters);\n+        }\n     }\n \n     public synchronized void removeQuery(QueryId queryId)\n     {\n-        dynamicFilterSummaries.keySet().removeIf(sourceDescriptor -> sourceDescriptor.getQueryId().equals(queryId));\n-        queries.remove(queryId);\n-        queryDynamicFilters.remove(queryId);\n+        dynamicFilterSummaries.remove(queryId);\n+        dynamicFilterSuppliers.remove(queryId);\n+        queryRepartitionedDynamicFilters.remove(queryId);\n+        queryReplicatedDynamicFilters.remove(queryId);\n+    }\n+\n+    public DynamicFilter createDynamicFilter(QueryId queryId, List<DynamicFilters.Descriptor> dynamicFilterDescriptors, Map<Symbol, ColumnHandle> columnHandles)\n+    {\n+        Map<DynamicFilterId, ColumnHandle> sourceColumnHandles = extractSourceColumnHandles(dynamicFilterDescriptors, columnHandles);\n+        Set<DynamicFilterId> dynamicFilters = dynamicFilterDescriptors.stream()\n+                .map(DynamicFilters.Descriptor::getId)\n+                .collect(toImmutableSet());\n+        Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilterFutures = dynamicFilterSummaries.get(queryId);\n+        Set<DynamicFilterId> repartitionedDynamicFilters = queryRepartitionedDynamicFilters.getOrDefault(queryId, ImmutableSet.of());\n+\n+        if (dynamicFilterFutures == null) {\n+            // query has been removed\n+            return EMPTY;\n+        }\n+\n+        return new DynamicFilter()\n+        {\n+            @Override\n+            public CompletableFuture<?> isBlocked()\n+            {\n+                // wait for any of the requested dynamic filter domains to be completed\n+                List<ListenableFuture<?>> undoneFutures = dynamicFilters.stream()\n+                        .filter(repartitionedDynamicFilters::contains)\n+                        .map(dynamicFilterFutures::get)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg1MTMwMA==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r449851300", "bodyText": "nit: the following can be precomputed outside the DynamicFilter#isBlocked method:\ndynamicFilters.stream()\n    .map(dynamicFilterFutures::get)", "author": "rzeyde-varada", "createdAt": "2020-07-05T08:40:23Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -93,101 +103,200 @@ public void stop()\n     public void registerQuery(SqlQueryExecution sqlQueryExecution)\n     {\n         // register query only if it contains dynamic filters\n-        Set<SourceDescriptor> dynamicFilters = PlanNodeSearcher.searchFrom(sqlQueryExecution.getQueryPlan().getRoot())\n+        ImmutableSet.Builder<DynamicFilterId> dynamicFiltersBuilder = ImmutableSet.builder();\n+        ImmutableSet.Builder<DynamicFilterId> repartitionedDynamicFiltersBuilder = ImmutableSet.builder();\n+        ImmutableSet.Builder<DynamicFilterId> replicatedDynamicFiltersBuilder = ImmutableSet.builder();\n+        PlanNodeSearcher.searchFrom(sqlQueryExecution.getQueryPlan().getRoot())\n                 .where(JoinNode.class::isInstance)\n-                .<JoinNode>findAll().stream()\n-                .flatMap(node -> node.getDynamicFilters().keySet().stream())\n-                .map(dynamicFilter -> SourceDescriptor.of(sqlQueryExecution.getQueryId(), dynamicFilter))\n-                .collect(toImmutableSet());\n+                .<JoinNode>findAll()\n+                .forEach(node -> {\n+                    node.getDynamicFilters().keySet()\n+                            .forEach(dynamicFiltersBuilder::add);\n+                    if (isBuildSideReplicated(node)) {\n+                        replicatedDynamicFiltersBuilder.addAll(node.getDynamicFilters().keySet());\n+                    }\n+                    if (isBuildSideRepartitioned(node)) {\n+                        repartitionedDynamicFiltersBuilder.addAll(node.getDynamicFilters().keySet());\n+                    }\n+                });\n+        Set<DynamicFilterId> dynamicFilters = dynamicFiltersBuilder.build();\n         if (!dynamicFilters.isEmpty()) {\n-            registerQuery(sqlQueryExecution.getQueryId(), sqlQueryExecution::getStageDynamicFilters, dynamicFilters);\n+            registerQuery(\n+                    sqlQueryExecution.getQueryId(),\n+                    sqlQueryExecution::getStageDynamicFilters,\n+                    dynamicFilters,\n+                    repartitionedDynamicFiltersBuilder.build(),\n+                    replicatedDynamicFiltersBuilder.build());\n         }\n     }\n \n     @VisibleForTesting\n-    synchronized void registerQuery(QueryId queryId, Supplier<List<StageDynamicFilters>> stageDynamicFiltersSupplier, Set<SourceDescriptor> dynamicFilters)\n+    void registerQuery(\n+            QueryId queryId,\n+            Supplier<List<StageDynamicFilters>> stageDynamicFiltersSupplier,\n+            Set<DynamicFilterId> dynamicFilters,\n+            Set<DynamicFilterId> repartitionedDynamicFilters,\n+            Set<DynamicFilterId> replicatedDynamicFilters)\n     {\n-        queries.putIfAbsent(queryId, stageDynamicFiltersSupplier);\n-        queryDynamicFilters.put(queryId, dynamicFilters);\n+        Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilterFutures = dynamicFilters.stream()\n+                .collect(toImmutableMap(filter -> filter, filter -> SettableFuture.create()));\n+        synchronized (this) {\n+            if (dynamicFilterSummaries.containsKey(queryId)) {\n+                // query is already registered\n+                return;\n+            }\n+\n+            dynamicFilterSummaries.put(queryId, dynamicFilterFutures);\n+            dynamicFilterSuppliers.put(queryId, stageDynamicFiltersSupplier);\n+            queryRepartitionedDynamicFilters.put(queryId, repartitionedDynamicFilters);\n+            queryReplicatedDynamicFilters.put(queryId, replicatedDynamicFilters);\n+        }\n     }\n \n     public synchronized void removeQuery(QueryId queryId)\n     {\n-        dynamicFilterSummaries.keySet().removeIf(sourceDescriptor -> sourceDescriptor.getQueryId().equals(queryId));\n-        queries.remove(queryId);\n-        queryDynamicFilters.remove(queryId);\n+        dynamicFilterSummaries.remove(queryId);\n+        dynamicFilterSuppliers.remove(queryId);\n+        queryRepartitionedDynamicFilters.remove(queryId);\n+        queryReplicatedDynamicFilters.remove(queryId);\n+    }\n+\n+    public DynamicFilter createDynamicFilter(QueryId queryId, List<DynamicFilters.Descriptor> dynamicFilterDescriptors, Map<Symbol, ColumnHandle> columnHandles)\n+    {\n+        Map<DynamicFilterId, ColumnHandle> sourceColumnHandles = extractSourceColumnHandles(dynamicFilterDescriptors, columnHandles);\n+        Set<DynamicFilterId> dynamicFilters = dynamicFilterDescriptors.stream()\n+                .map(DynamicFilters.Descriptor::getId)\n+                .collect(toImmutableSet());\n+        Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilterFutures = dynamicFilterSummaries.get(queryId);\n+        Set<DynamicFilterId> repartitionedDynamicFilters = queryRepartitionedDynamicFilters.getOrDefault(queryId, ImmutableSet.of());\n+\n+        if (dynamicFilterFutures == null) {\n+            // query has been removed\n+            return EMPTY;\n+        }\n+\n+        return new DynamicFilter()\n+        {\n+            @Override\n+            public CompletableFuture<?> isBlocked()\n+            {\n+                // wait for any of the requested dynamic filter domains to be completed\n+                List<ListenableFuture<?>> undoneFutures = dynamicFilters.stream()\n+                        .filter(repartitionedDynamicFilters::contains)\n+                        .map(dynamicFilterFutures::get)\n+                        .filter(future -> !future.isDone())\n+                        .collect(toImmutableList());\n+\n+                if (undoneFutures.isEmpty()) {\n+                    return NOT_BLOCKED;\n+                }\n+\n+                return toCompletableFuture(whenAnyComplete(undoneFutures));\n+            }\n+\n+            @Override\n+            public boolean isComplete()\n+            {\n+                return dynamicFilters.stream()\n+                        .map(dynamicFilterFutures::get)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg1MTU5OA==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r449851598", "bodyText": "Should we cache the result here (in case all the futures are done)?", "author": "rzeyde-varada", "createdAt": "2020-07-05T08:43:38Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -93,101 +103,200 @@ public void stop()\n     public void registerQuery(SqlQueryExecution sqlQueryExecution)\n     {\n         // register query only if it contains dynamic filters\n-        Set<SourceDescriptor> dynamicFilters = PlanNodeSearcher.searchFrom(sqlQueryExecution.getQueryPlan().getRoot())\n+        ImmutableSet.Builder<DynamicFilterId> dynamicFiltersBuilder = ImmutableSet.builder();\n+        ImmutableSet.Builder<DynamicFilterId> repartitionedDynamicFiltersBuilder = ImmutableSet.builder();\n+        ImmutableSet.Builder<DynamicFilterId> replicatedDynamicFiltersBuilder = ImmutableSet.builder();\n+        PlanNodeSearcher.searchFrom(sqlQueryExecution.getQueryPlan().getRoot())\n                 .where(JoinNode.class::isInstance)\n-                .<JoinNode>findAll().stream()\n-                .flatMap(node -> node.getDynamicFilters().keySet().stream())\n-                .map(dynamicFilter -> SourceDescriptor.of(sqlQueryExecution.getQueryId(), dynamicFilter))\n-                .collect(toImmutableSet());\n+                .<JoinNode>findAll()\n+                .forEach(node -> {\n+                    node.getDynamicFilters().keySet()\n+                            .forEach(dynamicFiltersBuilder::add);\n+                    if (isBuildSideReplicated(node)) {\n+                        replicatedDynamicFiltersBuilder.addAll(node.getDynamicFilters().keySet());\n+                    }\n+                    if (isBuildSideRepartitioned(node)) {\n+                        repartitionedDynamicFiltersBuilder.addAll(node.getDynamicFilters().keySet());\n+                    }\n+                });\n+        Set<DynamicFilterId> dynamicFilters = dynamicFiltersBuilder.build();\n         if (!dynamicFilters.isEmpty()) {\n-            registerQuery(sqlQueryExecution.getQueryId(), sqlQueryExecution::getStageDynamicFilters, dynamicFilters);\n+            registerQuery(\n+                    sqlQueryExecution.getQueryId(),\n+                    sqlQueryExecution::getStageDynamicFilters,\n+                    dynamicFilters,\n+                    repartitionedDynamicFiltersBuilder.build(),\n+                    replicatedDynamicFiltersBuilder.build());\n         }\n     }\n \n     @VisibleForTesting\n-    synchronized void registerQuery(QueryId queryId, Supplier<List<StageDynamicFilters>> stageDynamicFiltersSupplier, Set<SourceDescriptor> dynamicFilters)\n+    void registerQuery(\n+            QueryId queryId,\n+            Supplier<List<StageDynamicFilters>> stageDynamicFiltersSupplier,\n+            Set<DynamicFilterId> dynamicFilters,\n+            Set<DynamicFilterId> repartitionedDynamicFilters,\n+            Set<DynamicFilterId> replicatedDynamicFilters)\n     {\n-        queries.putIfAbsent(queryId, stageDynamicFiltersSupplier);\n-        queryDynamicFilters.put(queryId, dynamicFilters);\n+        Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilterFutures = dynamicFilters.stream()\n+                .collect(toImmutableMap(filter -> filter, filter -> SettableFuture.create()));\n+        synchronized (this) {\n+            if (dynamicFilterSummaries.containsKey(queryId)) {\n+                // query is already registered\n+                return;\n+            }\n+\n+            dynamicFilterSummaries.put(queryId, dynamicFilterFutures);\n+            dynamicFilterSuppliers.put(queryId, stageDynamicFiltersSupplier);\n+            queryRepartitionedDynamicFilters.put(queryId, repartitionedDynamicFilters);\n+            queryReplicatedDynamicFilters.put(queryId, replicatedDynamicFilters);\n+        }\n     }\n \n     public synchronized void removeQuery(QueryId queryId)\n     {\n-        dynamicFilterSummaries.keySet().removeIf(sourceDescriptor -> sourceDescriptor.getQueryId().equals(queryId));\n-        queries.remove(queryId);\n-        queryDynamicFilters.remove(queryId);\n+        dynamicFilterSummaries.remove(queryId);\n+        dynamicFilterSuppliers.remove(queryId);\n+        queryRepartitionedDynamicFilters.remove(queryId);\n+        queryReplicatedDynamicFilters.remove(queryId);\n+    }\n+\n+    public DynamicFilter createDynamicFilter(QueryId queryId, List<DynamicFilters.Descriptor> dynamicFilterDescriptors, Map<Symbol, ColumnHandle> columnHandles)\n+    {\n+        Map<DynamicFilterId, ColumnHandle> sourceColumnHandles = extractSourceColumnHandles(dynamicFilterDescriptors, columnHandles);\n+        Set<DynamicFilterId> dynamicFilters = dynamicFilterDescriptors.stream()\n+                .map(DynamicFilters.Descriptor::getId)\n+                .collect(toImmutableSet());\n+        Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilterFutures = dynamicFilterSummaries.get(queryId);\n+        Set<DynamicFilterId> repartitionedDynamicFilters = queryRepartitionedDynamicFilters.getOrDefault(queryId, ImmutableSet.of());\n+\n+        if (dynamicFilterFutures == null) {\n+            // query has been removed\n+            return EMPTY;\n+        }\n+\n+        return new DynamicFilter()\n+        {\n+            @Override\n+            public CompletableFuture<?> isBlocked()\n+            {\n+                // wait for any of the requested dynamic filter domains to be completed\n+                List<ListenableFuture<?>> undoneFutures = dynamicFilters.stream()\n+                        .filter(repartitionedDynamicFilters::contains)\n+                        .map(dynamicFilterFutures::get)\n+                        .filter(future -> !future.isDone())\n+                        .collect(toImmutableList());\n+\n+                if (undoneFutures.isEmpty()) {\n+                    return NOT_BLOCKED;\n+                }\n+\n+                return toCompletableFuture(whenAnyComplete(undoneFutures));\n+            }\n+\n+            @Override\n+            public boolean isComplete()\n+            {\n+                return dynamicFilters.stream()\n+                        .map(dynamicFilterFutures::get)\n+                        .allMatch(future -> future.isDone());\n+            }\n+\n+            @Override\n+            public TupleDomain<ColumnHandle> getCurrentPredicate()\n+            {\n+                return dynamicFilters.stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg1MzY4Ng==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r449853686", "bodyText": "Consider verifying that the same future is not set twice:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    dynamicFilters.forEach((filter, domain) -> dynamicFilterFutures.get(filter).set(domain));\n          \n          \n            \n                    dynamicFilters.forEach((filter, domain) -> {\n          \n          \n            \n                        SettableFuture<Domain> future = requireNonNull(dynamicFilterFutures.get(filter), \"Future not found\");\n          \n          \n            \n                        verify(future.set(domain), \"Same future set twice\");\n          \n          \n            \n                    });", "author": "rzeyde-varada", "createdAt": "2020-07-05T09:05:02Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -93,101 +103,200 @@ public void stop()\n     public void registerQuery(SqlQueryExecution sqlQueryExecution)\n     {\n         // register query only if it contains dynamic filters\n-        Set<SourceDescriptor> dynamicFilters = PlanNodeSearcher.searchFrom(sqlQueryExecution.getQueryPlan().getRoot())\n+        ImmutableSet.Builder<DynamicFilterId> dynamicFiltersBuilder = ImmutableSet.builder();\n+        ImmutableSet.Builder<DynamicFilterId> repartitionedDynamicFiltersBuilder = ImmutableSet.builder();\n+        ImmutableSet.Builder<DynamicFilterId> replicatedDynamicFiltersBuilder = ImmutableSet.builder();\n+        PlanNodeSearcher.searchFrom(sqlQueryExecution.getQueryPlan().getRoot())\n                 .where(JoinNode.class::isInstance)\n-                .<JoinNode>findAll().stream()\n-                .flatMap(node -> node.getDynamicFilters().keySet().stream())\n-                .map(dynamicFilter -> SourceDescriptor.of(sqlQueryExecution.getQueryId(), dynamicFilter))\n-                .collect(toImmutableSet());\n+                .<JoinNode>findAll()\n+                .forEach(node -> {\n+                    node.getDynamicFilters().keySet()\n+                            .forEach(dynamicFiltersBuilder::add);\n+                    if (isBuildSideReplicated(node)) {\n+                        replicatedDynamicFiltersBuilder.addAll(node.getDynamicFilters().keySet());\n+                    }\n+                    if (isBuildSideRepartitioned(node)) {\n+                        repartitionedDynamicFiltersBuilder.addAll(node.getDynamicFilters().keySet());\n+                    }\n+                });\n+        Set<DynamicFilterId> dynamicFilters = dynamicFiltersBuilder.build();\n         if (!dynamicFilters.isEmpty()) {\n-            registerQuery(sqlQueryExecution.getQueryId(), sqlQueryExecution::getStageDynamicFilters, dynamicFilters);\n+            registerQuery(\n+                    sqlQueryExecution.getQueryId(),\n+                    sqlQueryExecution::getStageDynamicFilters,\n+                    dynamicFilters,\n+                    repartitionedDynamicFiltersBuilder.build(),\n+                    replicatedDynamicFiltersBuilder.build());\n         }\n     }\n \n     @VisibleForTesting\n-    synchronized void registerQuery(QueryId queryId, Supplier<List<StageDynamicFilters>> stageDynamicFiltersSupplier, Set<SourceDescriptor> dynamicFilters)\n+    void registerQuery(\n+            QueryId queryId,\n+            Supplier<List<StageDynamicFilters>> stageDynamicFiltersSupplier,\n+            Set<DynamicFilterId> dynamicFilters,\n+            Set<DynamicFilterId> repartitionedDynamicFilters,\n+            Set<DynamicFilterId> replicatedDynamicFilters)\n     {\n-        queries.putIfAbsent(queryId, stageDynamicFiltersSupplier);\n-        queryDynamicFilters.put(queryId, dynamicFilters);\n+        Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilterFutures = dynamicFilters.stream()\n+                .collect(toImmutableMap(filter -> filter, filter -> SettableFuture.create()));\n+        synchronized (this) {\n+            if (dynamicFilterSummaries.containsKey(queryId)) {\n+                // query is already registered\n+                return;\n+            }\n+\n+            dynamicFilterSummaries.put(queryId, dynamicFilterFutures);\n+            dynamicFilterSuppliers.put(queryId, stageDynamicFiltersSupplier);\n+            queryRepartitionedDynamicFilters.put(queryId, repartitionedDynamicFilters);\n+            queryReplicatedDynamicFilters.put(queryId, replicatedDynamicFilters);\n+        }\n     }\n \n     public synchronized void removeQuery(QueryId queryId)\n     {\n-        dynamicFilterSummaries.keySet().removeIf(sourceDescriptor -> sourceDescriptor.getQueryId().equals(queryId));\n-        queries.remove(queryId);\n-        queryDynamicFilters.remove(queryId);\n+        dynamicFilterSummaries.remove(queryId);\n+        dynamicFilterSuppliers.remove(queryId);\n+        queryRepartitionedDynamicFilters.remove(queryId);\n+        queryReplicatedDynamicFilters.remove(queryId);\n+    }\n+\n+    public DynamicFilter createDynamicFilter(QueryId queryId, List<DynamicFilters.Descriptor> dynamicFilterDescriptors, Map<Symbol, ColumnHandle> columnHandles)\n+    {\n+        Map<DynamicFilterId, ColumnHandle> sourceColumnHandles = extractSourceColumnHandles(dynamicFilterDescriptors, columnHandles);\n+        Set<DynamicFilterId> dynamicFilters = dynamicFilterDescriptors.stream()\n+                .map(DynamicFilters.Descriptor::getId)\n+                .collect(toImmutableSet());\n+        Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilterFutures = dynamicFilterSummaries.get(queryId);\n+        Set<DynamicFilterId> repartitionedDynamicFilters = queryRepartitionedDynamicFilters.getOrDefault(queryId, ImmutableSet.of());\n+\n+        if (dynamicFilterFutures == null) {\n+            // query has been removed\n+            return EMPTY;\n+        }\n+\n+        return new DynamicFilter()\n+        {\n+            @Override\n+            public CompletableFuture<?> isBlocked()\n+            {\n+                // wait for any of the requested dynamic filter domains to be completed\n+                List<ListenableFuture<?>> undoneFutures = dynamicFilters.stream()\n+                        .filter(repartitionedDynamicFilters::contains)\n+                        .map(dynamicFilterFutures::get)\n+                        .filter(future -> !future.isDone())\n+                        .collect(toImmutableList());\n+\n+                if (undoneFutures.isEmpty()) {\n+                    return NOT_BLOCKED;\n+                }\n+\n+                return toCompletableFuture(whenAnyComplete(undoneFutures));\n+            }\n+\n+            @Override\n+            public boolean isComplete()\n+            {\n+                return dynamicFilters.stream()\n+                        .map(dynamicFilterFutures::get)\n+                        .allMatch(future -> future.isDone());\n+            }\n+\n+            @Override\n+            public TupleDomain<ColumnHandle> getCurrentPredicate()\n+            {\n+                return dynamicFilters.stream()\n+                        .map(filter -> getSummary(dynamicFilterFutures.get(filter))\n+                                .map(summary -> translateSummaryToTupleDomain(filter, summary, sourceColumnHandles)))\n+                        .filter(Optional::isPresent)\n+                        .map(Optional::get)\n+                        .reduce(TupleDomain.all(), TupleDomain::intersect);\n+            }\n+        };\n     }\n \n     @VisibleForTesting\n-    public void collectDynamicFilters()\n+    void collectDynamicFilters()\n     {\n-        for (Map.Entry<QueryId, Supplier<List<StageDynamicFilters>>> entry : getQueries().entrySet()) {\n+        for (Map.Entry<QueryId, Supplier<List<StageDynamicFilters>>> entry : getDynamicFilterSuppliers().entrySet()) {\n             QueryId queryId = entry.getKey();\n-            ImmutableMap.Builder<SourceDescriptor, Domain> newDynamicFiltersBuilder = ImmutableMap.builder();\n+            Set<DynamicFilterId> replicatedDynamicFilters = queryReplicatedDynamicFilters.getOrDefault(queryId, ImmutableSet.of());\n+            Set<DynamicFilterId> uncollectedFilters = getUncollectedDynamicFilters(queryId);\n+            ImmutableMap.Builder<DynamicFilterId, Domain> newDynamicFiltersBuilder = ImmutableMap.builder();\n             for (StageDynamicFilters stageDynamicFilters : entry.getValue().get()) {\n                 StageState stageState = stageDynamicFilters.getStageState();\n-                // wait until stage has finished scheduling tasks\n-                if (stageState.canScheduleMoreTasks()) {\n-                    continue;\n-                }\n                 stageDynamicFilters.getTaskDynamicFilters().stream()\n                         .flatMap(taskDomains -> taskDomains.entrySet().stream())\n-                        .filter(domain -> !dynamicFilterSummaries.containsKey(SourceDescriptor.of(queryId, domain.getKey())))\n+                        .filter(domain -> uncollectedFilters.contains(domain.getKey()))\n                         .collect(groupingBy(Map.Entry::getKey, mapping(Map.Entry::getValue, toImmutableList())))\n                         .entrySet().stream()\n-                        // check if all tasks of a dynamic filter source have reported dynamic filter summary\n-                        .filter(stageDomains -> stageDomains.getValue().size() == stageDynamicFilters.getNumberOfTasks())\n-                        .forEach(stageDomains -> newDynamicFiltersBuilder.put(\n-                                SourceDescriptor.of(queryId, stageDomains.getKey()),\n-                                Domain.union(stageDomains.getValue())));\n+                        .filter(stageDomains -> {\n+                            if (replicatedDynamicFilters.contains(stageDomains.getKey())) {\n+                                // for replicated dynamic filters it's enough to get dynamic filter from a single task\n+                                return true;\n+                            }\n+\n+                            // check if all tasks of a repartitioned dynamic filter source have reported dynamic filter summary\n+                            return !stageState.canScheduleMoreTasks() && stageDomains.getValue().size() == stageDynamicFilters.getNumberOfTasks();\n+                        })\n+                        .forEach(stageDomains -> newDynamicFiltersBuilder.put(stageDomains.getKey(), union(stageDomains.getValue())));\n             }\n \n-            Map<SourceDescriptor, Domain> newDynamicFilters = newDynamicFiltersBuilder.build();\n+            Map<DynamicFilterId, Domain> newDynamicFilters = newDynamicFiltersBuilder.build();\n             if (!newDynamicFilters.isEmpty()) {\n                 addDynamicFilters(queryId, newDynamicFilters);\n             }\n         }\n     }\n \n-    public Supplier<TupleDomain<ColumnHandle>> createDynamicFilterSupplier(QueryId queryId, List<DynamicFilters.Descriptor> dynamicFilters, Map<Symbol, ColumnHandle> columnHandles)\n+    @VisibleForTesting\n+    Optional<Domain> getSummary(QueryId queryId, DynamicFilterId filterId)\n     {\n-        Map<DynamicFilterId, ColumnHandle> sourceColumnHandles = extractSourceColumnHandles(dynamicFilters, columnHandles);\n-\n-        return () -> dynamicFilters.stream()\n-                .map(filter -> getSummary(queryId, filter.getId())\n-                        .map(summary -> translateSummaryToTupleDomain(filter.getId(), summary, sourceColumnHandles)))\n-                .filter(Optional::isPresent)\n-                .map(Optional::get)\n-                .reduce(TupleDomain.all(), TupleDomain::intersect);\n+        return getSummary(dynamicFilterSummaries.get(queryId).get(filterId));\n     }\n \n-    @VisibleForTesting\n-    Optional<Domain> getSummary(QueryId queryId, DynamicFilterId filterId)\n+    private Optional<Domain> getSummary(ListenableFuture<Domain> future)\n     {\n-        return Optional.ofNullable(dynamicFilterSummaries.get(SourceDescriptor.of(queryId, filterId)));\n+        if (!future.isDone()) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(getDone(future));\n     }\n \n-    private synchronized Map<QueryId, Supplier<List<StageDynamicFilters>>> getQueries()\n+    private Map<QueryId, Supplier<List<StageDynamicFilters>>> getDynamicFilterSuppliers()\n     {\n-        return ImmutableMap.copyOf(queries);\n+        return ImmutableMap.copyOf(dynamicFilterSuppliers);\n     }\n \n-    private synchronized void addDynamicFilters(QueryId queryId, Map<SourceDescriptor, Domain> dynamicFilters)\n+    private synchronized void addDynamicFilters(QueryId queryId, Map<DynamicFilterId, Domain> dynamicFilters)\n     {\n-        // query might have been removed while we collected dynamic filters asynchronously\n-        if (!queries.containsKey(queryId)) {\n+        Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilterFutures = dynamicFilterSummaries.get(queryId);\n+        if (dynamicFilterFutures == null) {\n+            // query might have been removed while filters were collected asynchronously\n             return;\n         }\n \n-        dynamicFilterSummaries.putAll(dynamicFilters);\n+        dynamicFilters.forEach((filter, domain) -> dynamicFilterFutures.get(filter).set(domain));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "e2730efef2249c4cfbeea59f45bdd6be1ed39e15", "url": "https://github.com/trinodb/trino/commit/e2730efef2249c4cfbeea59f45bdd6be1ed39e15", "message": "Add support for lazy dynamic filters on coordinator", "committedDate": "2020-07-09T14:33:58Z", "type": "commit"}, {"oid": "0018542180c57962c3665fd23d59bd581eee503e", "url": "https://github.com/trinodb/trino/commit/0018542180c57962c3665fd23d59bd581eee503e", "message": "Improve DynamicFilterService concurrency", "committedDate": "2020-07-09T14:33:58Z", "type": "commit"}, {"oid": "dbfd69957ddce4a31002a1c6d191c8abab8ccf80", "url": "https://github.com/trinodb/trino/commit/dbfd69957ddce4a31002a1c6d191c8abab8ccf80", "message": "Allow only repartitioned dynamic filters to be lazy\n\nCurrently for broadcast join there will be a deadlock when:\n\n1. build side source tasks cannot flush their output buffers\n2. broadcast join probe side source cannot schedule more splits\n\nCurrently such deadlock is detected and resolved by fixing task-to-node assignments.\nThis allows build side tasks to finish and flush their output buffers.\n\nIf probe side was waiting for dynamic fitlers to materialize such\ndeadlock would be permanent since netiher splits would be generated\nnor DF would be collected.", "committedDate": "2020-07-09T14:33:58Z", "type": "commit"}, {"oid": "dbfd69957ddce4a31002a1c6d191c8abab8ccf80", "url": "https://github.com/trinodb/trino/commit/dbfd69957ddce4a31002a1c6d191c8abab8ccf80", "message": "Allow only repartitioned dynamic filters to be lazy\n\nCurrently for broadcast join there will be a deadlock when:\n\n1. build side source tasks cannot flush their output buffers\n2. broadcast join probe side source cannot schedule more splits\n\nCurrently such deadlock is detected and resolved by fixing task-to-node assignments.\nThis allows build side tasks to finish and flush their output buffers.\n\nIf probe side was waiting for dynamic fitlers to materialize such\ndeadlock would be permanent since netiher splits would be generated\nnor DF would be collected.", "committedDate": "2020-07-09T14:33:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM2MzkwMw==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r452363903", "bodyText": "Is this used anywhere other than in tests?", "author": "martint", "createdAt": "2020-07-09T17:04:26Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/DynamicFilter.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.predicate.TupleDomain;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface DynamicFilter\n+{\n+    CompletableFuture<?> NOT_BLOCKED = CompletableFuture.completedFuture(null);\n+\n+    DynamicFilter EMPTY = new DynamicFilter()\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return NOT_BLOCKED;\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();  // no filtering\n+        }\n+    };\n+\n+    /**\n+     * Block until dynamic filter is narrowed down.\n+     * Dynamic filter might be narrowed down multiple times during query runtime.\n+     */\n+    CompletableFuture<?> isBlocked();", "originalCommit": "e2730efef2249c4cfbeea59f45bdd6be1ed39e15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyNDU2OQ==", "url": "https://github.com/trinodb/trino/pull/4224#discussion_r452424569", "bodyText": "Is this used anywhere other than in tests?\n\nNot yet.", "author": "sopel39", "createdAt": "2020-07-09T18:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM2MzkwMw=="}], "type": "inlineReview"}]}