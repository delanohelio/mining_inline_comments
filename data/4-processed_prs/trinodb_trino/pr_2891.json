{"pr_number": 2891, "pr_title": "Add support for row filtering and column masking", "pr_createdAt": "2020-02-20T20:14:56Z", "pr_url": "https://github.com/trinodb/trino/pull/2891", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1MjM4OA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382452388", "bodyText": "rnn, because you don't support null values in equals method", "author": "kokosing", "createdAt": "2020-02-21T08:29:15Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -895,4 +927,36 @@ public String toString()\n             return format(\"AccessControl: %s, Identity: %s\", accessControl.getClass(), identity);\n         }\n     }\n+\n+    private static class RowFilterScopeEntry\n+    {\n+        private final QualifiedObjectName table;\n+        private final String identity;\n+\n+        public RowFilterScopeEntry(QualifiedObjectName table, String identity)\n+        {\n+            this.table = table;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1NDgyMg==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382454822", "bodyText": "these 3 variables are not used in this commit (row filter support)", "author": "kokosing", "createdAt": "2020-02-21T08:35:48Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -479,6 +484,18 @@ protected Scope visitDelete(Delete node, Optional<Scope> scope)\n \n             accessControl.checkCanDeleteFromTable(session.toSecurityContext(), tableName);\n \n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, node, \"Delete from table with row filter\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> new TableNotFoundException(tableName.asSchemaTableName()));\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+            List<String> columns = tableMetadata.getColumns().stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1NjA4OA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382456088", "bodyText": "do you have a test where row filter tries to access symbols that are within query, but shouldn't be visible row filter (because they are not table output symbols)?", "author": "kokosing", "createdAt": "2020-02-21T08:38:53Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -991,9 +1008,15 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n                 analysis.setColumn(field, columnHandle);\n             }\n \n+            List<Field> outputFields = fields.build();\n+            Scope accessControlScope = createAndAssignScope(table, Optional.empty(), outputFields);\n+\n+            accessControl.getRowFilters(session.toSecurityContext(), name)\n+                    .forEach(filter -> analyzeRowFilter(session.getIdentity().getUser(), table, name, accessControlScope, filter));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0NjQ2MA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382846460", "bodyText": "No, but I'll add one that attempts to reference a column from the outer scope in a correlated subquery.", "author": "martint", "createdAt": "2020-02-21T23:01:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1NjA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1NjgzOA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382456838", "bodyText": "Do you have a test where row filters are applied to tables used within the table defined with WITH?", "author": "kokosing", "createdAt": "2020-02-21T08:40:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1083,6 +1106,11 @@ private Scope createScopeForView(Table table, QualifiedObjectName name, Optional\n \n             analysis.addRelationCoercion(table, outputFields.stream().map(Field::getType).toArray(Type[]::new));\n \n+            Scope accessControlScope = createAndAssignScope(table, Optional.empty(), outputFields);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1MjkyMg==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382852922", "bodyText": "I'll add one", "author": "martint", "createdAt": "2020-02-21T23:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1NjgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1OTM0Mg==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382459342", "bodyText": "Can you please add a test where RowFilterScopeEntry#identity matters. Like there would be 2 level recursive row filter but each row filter would be applied for different identity.", "author": "kokosing", "createdAt": "2020-02-21T08:46:41Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestRowFilter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.plugin.tpch.TpchConnectorFactory;\n+import io.prestosql.spi.security.Identity;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingAccessControlManager;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestRowFilter", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0NzIyMw==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382847223", "bodyText": "There's already a test for that: testDifferentIdentity. It runs the query as \"user\", which results in a filter orderkey IN (SELECT orderkey FROM orders) being applied. That filter needs to be evaluated as user run-as-user, which then results in another filter being applied to the nested reference to orders: orderkey = 1", "author": "martint", "createdAt": "2020-02-21T23:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1OTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1OTkyMg==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382459922", "bodyText": "maybe extract the below block as method, so you don't have uninitialized variable.", "author": "kokosing", "createdAt": "2020-02-21T08:48:08Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2357,6 +2371,58 @@ private ExpressionAnalysis analyzeExpression(Expression expression, Scope scope)\n                     warningCollector);\n         }\n \n+        private void analyzeRowFilter(String currentIdentity, Table table, QualifiedObjectName name, Scope scope, ViewExpression filter)\n+        {\n+            if (analysis.hasRowFilter(name, currentIdentity)) {\n+                throw new PrestoException(INVALID_ROW_FILTER, extractLocation(table), format(\"Row filter for '%s' is recursive\", name), null);\n+            }\n+\n+            Expression expression;\n+            try {\n+                expression = sqlParser.createExpression(filter.getExpression(), createParsingOptions(session));\n+            }\n+            catch (ParsingException e) {\n+                throw new PrestoException(INVALID_ROW_FILTER, extractLocation(table), format(\"Invalid row filter for '%s': %s\", name, e.getErrorMessage()), e);\n+            }\n+\n+            ExpressionAnalysis expressionAnalysis;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0Mjc0MA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382842740", "bodyText": "I think that's overkill. It makes the code harder to follow, as you have to navigate multiple methods to understand what this is doing, and it doesn't really save much other than that variable declaration.", "author": "martint", "createdAt": "2020-02-21T22:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ1OTkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MDI0Mg==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382460242", "bodyText": "can you please add a test for this?", "author": "kokosing", "createdAt": "2020-02-21T08:48:56Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2357,6 +2371,58 @@ private ExpressionAnalysis analyzeExpression(Expression expression, Scope scope)\n                     warningCollector);\n         }\n \n+        private void analyzeRowFilter(String currentIdentity, Table table, QualifiedObjectName name, Scope scope, ViewExpression filter)\n+        {\n+            if (analysis.hasRowFilter(name, currentIdentity)) {\n+                throw new PrestoException(INVALID_ROW_FILTER, extractLocation(table), format(\"Row filter for '%s' is recursive\", name), null);\n+            }\n+\n+            Expression expression;\n+            try {\n+                expression = sqlParser.createExpression(filter.getExpression(), createParsingOptions(session));\n+            }\n+            catch (ParsingException e) {\n+                throw new PrestoException(INVALID_ROW_FILTER, extractLocation(table), format(\"Invalid row filter for '%s': %s\", name, e.getErrorMessage()), e);\n+            }\n+\n+            ExpressionAnalysis expressionAnalysis;\n+            analysis.registerTableForRowFiltering(name, currentIdentity);\n+            try {\n+                expressionAnalysis = ExpressionAnalyzer.analyzeExpression(\n+                        createViewSession(filter.getCatalog(), filter.getSchema(), Identity.forUser(filter.getIdentity()).build(), session.getPath()), // TODO: path should be included in row filter\n+                        metadata,\n+                        accessControl,\n+                        sqlParser,\n+                        scope,\n+                        analysis,\n+                        expression,\n+                        warningCollector);\n+            }\n+            catch (PrestoException e) {\n+                throw new PrestoException(e::getErrorCode, extractLocation(table), format(\"Invalid row filter for '%s': %s\", name, e.getRawMessage()), e);\n+            }\n+            finally {\n+                analysis.unregisterTableForRowFiltering(name, currentIdentity);\n+            }\n+\n+            verifyNoAggregateWindowOrGroupingFunctions(metadata, expression, format(\"Row filter for '%s'\", name));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MTE2MQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382461161", "bodyText": "rnn", "author": "kokosing", "createdAt": "2020-02-21T08:51:16Z", "path": "presto-main/src/main/java/io/prestosql/testing/TestingAccessControlManager.java", "diffHunk": "@@ -443,4 +463,36 @@ public String toString()\n                     .toString();\n         }\n     }\n+\n+    private static class RowFilterKey\n+    {\n+        private final String identity;\n+        private final QualifiedObjectName table;\n+\n+        public RowFilterKey(String identity, QualifiedObjectName table)\n+        {\n+            this.identity = identity;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MTk5NA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382461994", "bodyText": "move this constructor down as last constructor", "author": "kokosing", "createdAt": "2020-02-21T08:53:11Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/QueryAssertions.java", "diffHunk": "@@ -42,6 +43,11 @@\n {\n     private final QueryRunner runner;\n \n+    public QueryAssertions(QueryRunner runner)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MzcwNQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382463705", "bodyText": "it would be nice to pass session here, so it would be obvious from reading the test which row filter is going to be applied", "author": "kokosing", "createdAt": "2020-02-21T08:57:04Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestRowFilter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.plugin.tpch.TpchConnectorFactory;\n+import io.prestosql.spi.security.Identity;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingAccessControlManager;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestRowFilter\n+{\n+    private static final String CATALOG = \"local\";\n+    private static final String USER = \"user\";\n+    private static final String RUN_AS_USER = \"run-as-user\";\n+\n+    private QueryAssertions assertions;\n+    private TestingAccessControlManager accessControl;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(CATALOG)\n+                .setSchema(TINY_SCHEMA_NAME)\n+                .setIdentity(Identity.forUser(USER).build())\n+                .build();\n+\n+        LocalQueryRunner runner = LocalQueryRunner.builder(session)\n+                .build();\n+\n+        runner.createCatalog(CATALOG, new TpchConnectorFactory(1), ImmutableMap.of());\n+\n+        assertions = new QueryAssertions(runner);\n+        accessControl = assertions.getQueryRunner().getAccessControl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testSimpleFilter()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey < 10\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"NULL\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '0'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testCorrelatedSubquery()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"EXISTS (SELECT 1 FROM nation WHERE nationkey = orderkey)\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testRecursion()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+\n+        // different reference style to same table\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT local.tiny.orderkey FROM orders)\"));\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+    }\n+\n+    @Test\n+    public void testOtherSchema()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"(SELECT count(*) FROM customer) = 150000\")); // Filter is TRUE only if evaluating against sf1.customer\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '15000'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testDifferentIdentity()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    RUN_AS_USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey = 1\"));\n+\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '1'\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0OTE1Nw==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382849157", "bodyText": "Indeed, but it requires some refactoring to how we build sessions and how the methods are invoked to make it reasonably clean. We can do that as a follow up. I don't want to extend the scope of this PR.", "author": "martint", "createdAt": "2020-02-21T23:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MzcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NDY5OQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382464699", "bodyText": "Consider a test case like:\n     // subquery \"sql-injection\"\n        assertRowFiltering(\n                \"WITH region(regionkey, name) AS (VALUES (0, 'ASIA'), (1, 'ASIA'), (2, 'ASIA'), (3, 'ASIA'), (4, 'ASIA'))\" +\n                        \"SELECT name FROM nation ORDER BY name LIMIT 1\",\n                \"SELECT 'CHINA'\", // if sql-injection would work then query would return ALGERIA\n                rowFilter(\"nation\", \"regionkey IN (SELECT regionkey FROM region WHERE name = 'ASIA')\", getSession().getUser()));", "author": "kokosing", "createdAt": "2020-02-21T08:59:06Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestRowFilter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.plugin.tpch.TpchConnectorFactory;\n+import io.prestosql.spi.security.Identity;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingAccessControlManager;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestRowFilter\n+{\n+    private static final String CATALOG = \"local\";\n+    private static final String USER = \"user\";\n+    private static final String RUN_AS_USER = \"run-as-user\";\n+\n+    private QueryAssertions assertions;\n+    private TestingAccessControlManager accessControl;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(CATALOG)\n+                .setSchema(TINY_SCHEMA_NAME)\n+                .setIdentity(Identity.forUser(USER).build())\n+                .build();\n+\n+        LocalQueryRunner runner = LocalQueryRunner.builder(session)\n+                .build();\n+\n+        runner.createCatalog(CATALOG, new TpchConnectorFactory(1), ImmutableMap.of());\n+\n+        assertions = new QueryAssertions(runner);\n+        accessControl = assertions.getQueryRunner().getAccessControl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testSimpleFilter()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey < 10\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"NULL\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '0'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testCorrelatedSubquery()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"EXISTS (SELECT 1 FROM nation WHERE nationkey = orderkey)\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testRecursion()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+\n+        // different reference style to same table\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT local.tiny.orderkey FROM orders)\"));\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+    }\n+\n+    @Test\n+    public void testOtherSchema()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"(SELECT count(*) FROM customer) = 150000\")); // Filter is TRUE only if evaluating against sf1.customer\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '15000'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testDifferentIdentity()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    RUN_AS_USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey = 1\"));\n+\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '1'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testInvalidFilter()\n+    {\n+        // parse error\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"$$$\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \"\\\\Qline 1:22: Invalid row filter for 'local.tiny.orders': mismatched input '$'. Expecting: <expression>\\\\E\");\n+        });\n+\n+        // unknown column\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"unknown_column\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \"\\\\Qline 1:22: Invalid row filter for 'local.tiny.orders': Column 'unknown_column' cannot be resolved\\\\E\");\n+        });\n+\n+        // invalid type\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(RUN_AS_USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"1\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \"\\\\Qline 1:22: Expected row filter for 'local.tiny.orders' to be of type BOOLEAN, but was integer\\\\E\");\n+        });\n+    }\n+\n+    @Test\n+    public void testMultipleFilters()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey < 10\"));\n+\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey > 5\"));\n+\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '2'\");\n+        });\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1MjI4MA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382852280", "bodyText": "That's a clever test. Thanks! I'll add it", "author": "martint", "createdAt": "2020-02-21T23:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NDY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTc2MA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382465760", "bodyText": "As I understand it will use RowFilterKey from TestingAccessControlManager. It would be nice to have a test that would require using different keys in analysis based on identity.", "author": "kokosing", "createdAt": "2020-02-21T09:01:23Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestRowFilter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.plugin.tpch.TpchConnectorFactory;\n+import io.prestosql.spi.security.Identity;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingAccessControlManager;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestRowFilter\n+{\n+    private static final String CATALOG = \"local\";\n+    private static final String USER = \"user\";\n+    private static final String RUN_AS_USER = \"run-as-user\";\n+\n+    private QueryAssertions assertions;\n+    private TestingAccessControlManager accessControl;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        Session session = testSessionBuilder()\n+                .setCatalog(CATALOG)\n+                .setSchema(TINY_SCHEMA_NAME)\n+                .setIdentity(Identity.forUser(USER).build())\n+                .build();\n+\n+        LocalQueryRunner runner = LocalQueryRunner.builder(session)\n+                .build();\n+\n+        runner.createCatalog(CATALOG, new TpchConnectorFactory(1), ImmutableMap.of());\n+\n+        assertions = new QueryAssertions(runner);\n+        accessControl = assertions.getQueryRunner().getAccessControl();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testSimpleFilter()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"orderkey < 10\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.empty(), Optional.empty(), \"NULL\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '0'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testCorrelatedSubquery()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"EXISTS (SELECT 1 FROM nation WHERE nationkey = orderkey)\"));\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '7'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testRecursion()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT orderkey FROM orders)\"));\n+\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+\n+        // different reference style to same table\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"tiny\"), \"orderkey IN (SELECT local.tiny.orderkey FROM orders)\"));\n+            assertions.assertFails(\"SELECT count(*) FROM orders\", \".*\\\\QRow filter for 'local.tiny.orders' is recursive\\\\E.*\");\n+        });\n+    }\n+\n+    @Test\n+    public void testOtherSchema()\n+    {\n+        assertions.executeExclusively(() -> {\n+            accessControl.reset();\n+            accessControl.rowFilter(\n+                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n+                    USER,\n+                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"(SELECT count(*) FROM customer) = 150000\")); // Filter is TRUE only if evaluating against sf1.customer\n+            assertions.assertQuery(\"SELECT count(*) FROM orders\", \"VALUES BIGINT '15000'\");\n+        });\n+    }\n+\n+    @Test\n+    public void testDifferentIdentity()\n+    {\n+        assertions.executeExclusively(() -> {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0OTQ0Nw==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382849447", "bodyText": "Not sure I understand. This test does that -- it applies to different filters to two different instances of the orders table based on the identity being used to evaluate the tables.", "author": "martint", "createdAt": "2020-02-21T23:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMTY4NA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383221684", "bodyText": "yes, but you return only a single row filter from TestingAccessControlManager basing on identity.\nI was thinking about using view together with regular table, so during single query execution there would be two row filters collected for the same table but for different identities (query user and view owner).\n       assertions.executeExclusively(() -> {\n            accessControl.reset();\n            accessControl.rowFilter(\n                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n                    USER,\n                    new ViewExpression(USER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"orderkey = 1\"));\n            accessControl.rowFilter(\n                    new QualifiedObjectName(CATALOG, \"tiny\", \"orders\"),\n                    VIEW_OWNER,\n                    new ViewExpression(VIEW_OWNER, Optional.of(CATALOG), Optional.of(\"sf1\"), \"orderkey = 2\"));\n             assertions.assertUpdate(VIEW_OWNER, \"CREATE VIEW v_orders AS SELECT * FROM orders\");\n             assertions.assertQuery(USER, \"SELECT o1.orderkey, o2.orderkey FROM orders o1, v_orders o2\", \"SELECT 1,2\");\n        });", "author": "kokosing", "createdAt": "2020-02-24T11:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MjU2OA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383282568", "bodyText": "Unfortunately, anything involving views would require a connector that supports them AND supports filters/masks. We don\u2019t have any.", "author": "martint", "createdAt": "2020-02-24T14:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NjEwMw==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382466103", "bodyText": "s/identity/user\nhere and everywhere else", "author": "kokosing", "createdAt": "2020-02-21T09:02:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -663,6 +669,32 @@ public boolean isOrderByRedundant(OrderBy orderBy)\n         return redundantOrderBy.contains(NodeRef.of(orderBy));\n     }\n \n+    public boolean hasRowFilter(QualifiedObjectName table, String identity)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0NDA3NQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382844075", "bodyText": "No, because this is actually a SQL authorization identifier. Eventually, it will be either a user or a role, as expected by standard SQL authorization model.", "author": "martint", "createdAt": "2020-02-21T22:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NjEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxNTYwMg==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383215602", "bodyText": "So then I think you should use io.prestosql.spi.security.PrestoPrincipal", "author": "kokosing", "createdAt": "2020-02-24T11:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NjEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3OTcxMA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383279710", "bodyText": "No, principal has way too much stuff. This is just an authorization identifier as described by the SQL spec.", "author": "martint", "createdAt": "2020-02-24T14:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NjEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NjYwMg==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382466602", "bodyText": "s/identity/user", "author": "kokosing", "createdAt": "2020-02-21T09:03:08Z", "path": "presto-spi/src/main/java/io/prestosql/spi/security/ViewExpression.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.security;\n+\n+import java.util.Optional;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class ViewExpression\n+{\n+    private final String identity;\n+    private final Optional<String> catalog;\n+    private final Optional<String> schema;\n+    private final String expression;\n+\n+    public ViewExpression(String identity, Optional<String> catalog, Optional<String> schema, String expression)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NzUwMw==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382467503", "bodyText": "I don't think that connector should return catalog. Connector is only aware of catalog name it is using, don't know anything about other catalogs. Do we need ConnectorViewExpression and SystemViewExpression?", "author": "kokosing", "createdAt": "2020-02-21T09:05:15Z", "path": "presto-spi/src/main/java/io/prestosql/spi/security/ViewExpression.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.security;\n+\n+import java.util.Optional;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class ViewExpression\n+{\n+    private final String identity;\n+    private final Optional<String> catalog;\n+    private final Optional<String> schema;\n+    private final String expression;\n+\n+    public ViewExpression(String identity, Optional<String> catalog, Optional<String> schema, String expression)\n+    {\n+        this.identity = requireNonNull(identity, \"identity is null\");\n+        this.catalog = requireNonNull(catalog, \"catalog is null\");\n+        this.schema = requireNonNull(schema, \"schema is null\");\n+        this.expression = requireNonNull(expression, \"expression is null\");\n+\n+        if (!catalog.isPresent() && schema.isPresent()) {\n+            throw new IllegalArgumentException(\"catalog must be present if schema is present\");\n+        }\n+    }\n+\n+    public String getIdentity()\n+    {\n+        return identity;\n+    }\n+\n+    public Optional<String> getCatalog()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0NDY5Mg==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382844692", "bodyText": "The catalog/schema/identity make up the \"environment\" under which the filter or mask should be evaluated. They are needed for the purpose of resolving relative table references, and it's exactly the same mechanism we use for views. In a way, row filters and masks behave like dynamic views.", "author": "martint", "createdAt": "2020-02-21T22:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NzUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2OTAyNA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382469024", "bodyText": "if row filters and column masks are using same mechanism during semantic analysis, should we extract common code as some entity?", "author": "kokosing", "createdAt": "2020-02-21T09:08:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -139,6 +139,9 @@\n     private final Multiset<RowFilterScopeEntry> rowFilterScopes = HashMultiset.create();\n     private final Map<NodeRef<Table>, List<Expression>> rowFilters = new LinkedHashMap<>();\n \n+    private final Multiset<ColumnMaskScopeEntry> columnMaskScopes = HashMultiset.create();\n+    private final Map<NodeRef<Table>, Map<String, List<Expression>>> columnMasks = new LinkedHashMap<>();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1MDY5NQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382850695", "bodyText": "I don't think that saves us much and introduces unnecessary abstraction. We'd need a generic holder class parameterized on the scope entry type and the container (List<Expression> vs Map<String, List<Expression>). We also still have to have the register/unregister/hasXXX/getXXX methods, the logic to create the keys, etc., in Analysis.", "author": "martint", "createdAt": "2020-02-21T23:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2OTAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3MDY2Nw==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382470667", "bodyText": "rnn", "author": "kokosing", "createdAt": "2020-02-21T09:12:27Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -959,4 +989,39 @@ public int hashCode()\n             return Objects.hash(table, identity);\n         }\n     }\n+\n+    private static class ColumnMaskScopeEntry\n+    {\n+        private final QualifiedObjectName table;\n+        private final String column;\n+        private final String identity;\n+\n+        public ColumnMaskScopeEntry(QualifiedObjectName table, String column, String identity)\n+        {\n+            this.table = table;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3MjU3NQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382472575", "bodyText": "Shouldn't getColumnMasks() return Multimap?", "author": "kokosing", "createdAt": "2020-02-21T09:16:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -192,6 +194,40 @@ private RelationPlan addRowFilters(Table node, RelationPlan plan)\n         return new RelationPlan(planBuilder.getRoot(), plan.getScope(), plan.getFieldMappings());\n     }\n \n+    private RelationPlan addColumnMasks(Table table, RelationPlan plan)\n+    {\n+        Map<String, List<Expression>> columnMasks = analysis.getColumnMasks(table);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0NTA5NQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382845095", "bodyText": "I wanted to be explicit about the ordering of the expressions, so a Map with a List seemed more appropriate.", "author": "martint", "createdAt": "2020-02-21T22:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3MjU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382474297", "bodyText": "Add a test where there are two column masks (one connector level and one system level) and where we could notice the order in which they were applied.", "author": "kokosing", "createdAt": "2020-02-21T09:20:04Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -192,6 +194,40 @@ private RelationPlan addRowFilters(Table node, RelationPlan plan)\n         return new RelationPlan(planBuilder.getRoot(), plan.getScope(), plan.getFieldMappings());\n     }\n \n+    private RelationPlan addColumnMasks(Table table, RelationPlan plan)\n+    {\n+        Map<String, List<Expression>> columnMasks = analysis.getColumnMasks(table);\n+\n+        PlanNode root = plan.getRoot();\n+        List<Symbol> mappings = plan.getFieldMappings();\n+\n+        TranslationMap translations = new TranslationMap(plan, analysis, lambdaDeclarationToSymbolMap);\n+        translations.setFieldMappings(mappings);\n+\n+        PlanBuilder planBuilder = new PlanBuilder(translations, root);\n+\n+        for (int i = 0; i < plan.getDescriptor().getAllFieldCount(); i++) {\n+            Field field = plan.getDescriptor().getFieldByIndex(i);\n+\n+            for (Expression mask : columnMasks.getOrDefault(field.getName().get(), ImmutableList.of())) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0NTQ5Ng==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r382845496", "bodyText": "Unfortunately, we don't have infrastructure to do that. It would require implementing masking support in real connectors. The tests rely on simulating the ordering of the masks by explicitly registering them in TestingAccessControl", "author": "martint", "createdAt": "2020-02-21T22:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3MjE4OQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383272189", "bodyText": "Then I think we need to write TestAccessControl unit tests where you could inject some fake system and connector access control to test (concrete) the order.", "author": "kokosing", "createdAt": "2020-02-24T13:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MDc5OQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383280799", "bodyText": "Do you have a suggestion about where to do it! I don\u2019t believe we have anything where we can inject fake connectors like that and still be able to run reasonable queries.", "author": "martint", "createdAt": "2020-02-24T14:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4MjE1Mg==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383282152", "bodyText": "Maybe we could add column mask support for file based access controls, then we could use both of them in single test.", "author": "kokosing", "createdAt": "2020-02-24T14:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI4NDAyMQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383284021", "bodyText": "That\u2019s an option, but it increases the scope of this change (we need to design how we want to represent them in the files, etc)", "author": "martint", "createdAt": "2020-02-24T14:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI5NTU2Mw==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383295563", "bodyText": "Another option is to add a test to io.prestosql.security.TestAccessControlManager where you could inject your custom plugins, like: https://github.com/prestosql/presto/pull/2924/files#diff-969c42278114183bfc24a2cde29f7289R200", "author": "kokosing", "createdAt": "2020-02-24T14:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NzAxOQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383387019", "bodyText": "That kind of test is super brittle. But ok, added it.", "author": "martint", "createdAt": "2020-02-24T16:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NDI5Nw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMjk5NQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383222995", "bodyText": "Why ViewExpression contains identity? We are already passing identity to access control. It is like \"give me a row filter for bob\", and getting a response \"here is a row filter FOR BOB\" (instead of just \"here is a row filter that you requested\").", "author": "kokosing", "createdAt": "2020-02-24T11:53:52Z", "path": "presto-spi/src/main/java/io/prestosql/spi/security/ViewExpression.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.security;\n+\n+import java.util.Optional;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class ViewExpression\n+{\n+    private final String identity;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3ODc2OQ==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383278769", "bodyText": "The identity attached to the filter is the identity that should be used to evaluate any tables referenced by the filter. If you ask: \u201cgive me a filter for table T for Bob\u201d, you might get \u201chere\u2019s the filter, and any tables referenced in sub queries in that filter should be resolved as user Admin\u201d. This can be useful to constrain permissions based on data contained in lookup tables only accessible to users with more privileges.\nIt\u2019s no different than how views work.", "author": "martint", "createdAt": "2020-02-24T13:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0NTQyNA==", "url": "https://github.com/trinodb/trino/pull/2891#discussion_r383845424", "bodyText": "Makes sense. Thanks", "author": "kokosing", "createdAt": "2020-02-25T12:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMjk5NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "7d80f748a5239adfd5c05b0b5d641adb249a2163", "url": "https://github.com/trinodb/trino/commit/7d80f748a5239adfd5c05b0b5d641adb249a2163", "message": "Import method statically", "committedDate": "2020-02-24T17:37:53Z", "type": "commit"}, {"oid": "7efb49ca76782ef83b347b8d51ea422057bca1e0", "url": "https://github.com/trinodb/trino/commit/7efb49ca76782ef83b347b8d51ea422057bca1e0", "message": "Add support for row filtering", "committedDate": "2020-02-24T17:37:53Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "b03700bc0b0a1b2ccdcb368f052b371813456dc4", "url": "https://github.com/trinodb/trino/commit/b03700bc0b0a1b2ccdcb368f052b371813456dc4", "message": "Add support for column masking", "committedDate": "2020-02-24T17:39:40Z", "type": "commit"}, {"oid": "b03700bc0b0a1b2ccdcb368f052b371813456dc4", "url": "https://github.com/trinodb/trino/commit/b03700bc0b0a1b2ccdcb368f052b371813456dc4", "message": "Add support for column masking", "committedDate": "2020-02-24T17:39:40Z", "type": "forcePushed"}]}