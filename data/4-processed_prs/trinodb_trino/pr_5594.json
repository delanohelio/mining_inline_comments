{"pr_number": 5594, "pr_title": "Wait for and build split with dynamic filter in Kudu", "pr_createdAt": "2020-10-19T10:12:21Z", "pr_url": "https://github.com/trinodb/trino/pull/5594", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzNDQ3NA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r507634474", "bodyText": "We can modify QueryRunner createKuduQueryRunnerTpch(TestingKuduServer kuduServer, Optional<String> kuduSchemaEmulationPrefix, Iterable<TpchTable<?>> tables) to re-use this method", "author": "Praveen2112", "createdAt": "2020-10-19T10:19:41Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/KuduQueryRunnerFactory.java", "diffHunk": "@@ -97,6 +97,38 @@ public static QueryRunner createKuduQueryRunnerTpch(TestingKuduServer kuduServer\n         }\n     }\n \n+    public static QueryRunner createKuduQueryRunnerTpch(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2OTkyNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r508169926", "bodyText": "Modified.", "author": "lzeiming", "createdAt": "2020-10-20T02:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzNDQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzNDg0Ng==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r507634846", "bodyText": "We can import SessionBuilder", "author": "Praveen2112", "createdAt": "2020-10-19T10:20:14Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/KuduQueryRunnerFactory.java", "diffHunk": "@@ -121,6 +153,16 @@ private static void installKuduConnector(HostAndPort masterAddress, QueryRunner\n         }\n     }\n \n+    public static Session createSession(String schema, Map<String, String> systemProperties, Map<String, String> kuduSessionProperties)\n+    {\n+        Session.SessionBuilder builder = testSessionBuilder()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE3MDIyMA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r508170220", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-20T02:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzNDg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NDY4Ng==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r507674686", "bodyText": "Probe is pretty technical term. Also, in theory, DF can be a result of something else.\nwhat about\nkudu.dynamic-filtering.wait-timeout\n\n?", "author": "findepi", "createdAt": "2020-10-19T11:33:22Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduClientConfig.java", "diffHunk": "@@ -151,4 +155,18 @@ public boolean isGroupedExecutionEnabled()\n     {\n         return groupedExecutionEnabled;\n     }\n+\n+    @NotNull\n+    public Duration getDynamicFilteringProbeBlockingTimeout()\n+    {\n+        return dynamicFilteringProbeBlockingTimeout;\n+    }\n+\n+    @Config(\"kudu.dynamic-filtering-probe-blocking-timeout\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE3MDI3Mg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r508170272", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-20T02:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NDY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NDg2OA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r507674868", "bodyText": "in the spirit of the above, perhaps something like\n@ConfigDescription(\"Duration to wait for completion of dynamic filters\")\n\n?", "author": "findepi", "createdAt": "2020-10-19T11:33:44Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduClientConfig.java", "diffHunk": "@@ -151,4 +155,18 @@ public boolean isGroupedExecutionEnabled()\n     {\n         return groupedExecutionEnabled;\n     }\n+\n+    @NotNull\n+    public Duration getDynamicFilteringProbeBlockingTimeout()\n+    {\n+        return dynamicFilteringProbeBlockingTimeout;\n+    }\n+\n+    @Config(\"kudu.dynamic-filtering-probe-blocking-timeout\")\n+    @ConfigDescription(\"Duration to wait for completion of dynamic filters during page source generation for probe side table\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE3MDI5NQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r508170295", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-20T02:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NDg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkwMTc3Nw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r507901777", "bodyText": "Why not just intersect this with tableHandle.getConstraint() above ?", "author": "raunaqmorarka", "createdAt": "2020-10-19T16:48:13Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduClientSession.java", "diffHunk": "@@ -157,6 +158,11 @@ public Schema getTableSchema(KuduTableHandle tableHandle)\n             return ImmutableList.of();\n         }\n         addConstraintPredicates(table, builder, constraint);\n+        TupleDomain<ColumnHandle> dynamicConstraint = dynamicFilter.getCurrentPredicate();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE3MDM0NQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r508170345", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-20T02:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkwMTc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkwMzAyOA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r507903028", "bodyText": "Use ImmutableMap.of", "author": "raunaqmorarka", "createdAt": "2020-10-19T16:50:13Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import io.prestosql.server.DynamicFilterService;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+    extends AbstractTestQueryFramework\n+{\n+    private static final String DYNAMIC_FILTERING_PROBE_BLOCKING_TIMEOUT = \"dynamic_filtering_probe_blocking_timeout\";\n+    private static final long LINEITEM_COUNT = 60175;\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+        throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+            kuduServer, Optional.of(\"\"),\n+            Map.of(JOIN_REORDERING_STRATEGY, NONE.name(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE3MDM4Ng==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r508170386", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-20T02:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkwMzAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyNTQxNQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r507925415", "bodyText": "I think you can use directExecutor, unless you ran into some issue which led to using thread pool here ?", "author": "raunaqmorarka", "createdAt": "2020-10-19T17:26:14Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -45,10 +60,26 @@ public ConnectorSplitSource getSplits(\n             ConnectorTableHandle table,\n             SplitSchedulingStrategy splitSchedulingStrategy,\n             DynamicFilter dynamicFilter)\n+    {\n+        if (dynamicFilter.isComplete() || !dynamicFilter.isAwaitable()) {\n+            return getSplitSource(table, splitSchedulingStrategy, dynamicFilter);\n+        }\n+        long blockingTimeoutMillis = getDynamicFilteringProbeBlockingTimeout(session).toMillis();\n+        if (blockingTimeoutMillis <= 0) {\n+            return getSplitSource(table, splitSchedulingStrategy, dynamicFilter);\n+        }\n+        CompletableFuture<ConnectorSplitSource> future = dynamicFilter.isBlocked()\n+            .completeOnTimeout(null, blockingTimeoutMillis, TimeUnit.MILLISECONDS)\n+            .thenApplyAsync(o -> getSplitSource(table, splitSchedulingStrategy, dynamicFilter), executor);\n+        return new AsyncDelegate(future, executor);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE3MDQwNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r508170406", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-20T02:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyNTQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk2MjkxNA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r507962914", "bodyText": "Can be simplified by removing the conditions above and modifying this to if (blockingTimeoutMillis <= 0 || !dynamicFilter.isAwaitable())", "author": "raunaqmorarka", "createdAt": "2020-10-19T18:10:45Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -45,10 +60,26 @@ public ConnectorSplitSource getSplits(\n             ConnectorTableHandle table,\n             SplitSchedulingStrategy splitSchedulingStrategy,\n             DynamicFilter dynamicFilter)\n+    {\n+        if (dynamicFilter.isComplete() || !dynamicFilter.isAwaitable()) {\n+            return getSplitSource(table, splitSchedulingStrategy, dynamicFilter);\n+        }\n+        long blockingTimeoutMillis = getDynamicFilteringProbeBlockingTimeout(session).toMillis();\n+        if (blockingTimeoutMillis <= 0) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE3MDQzOQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r508170439", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-20T02:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk2MjkxNA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4ODgyOA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r510388828", "bodyText": "We don't need any of the assertions around dynamicFiltersStats as these are connector agnostic and already getting tested in DynamicFilterService", "author": "raunaqmorarka", "createdAt": "2020-10-22T18:59:22Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.server.DynamicFilterService;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final String DYNAMIC_FILTERING_WAIT_TIMEOUT = \"dynamic_filtering_wait_timeout\";\n+    private static final long LINEITEM_COUNT = 60175;\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+            kuduServer, Optional.of(\"\"),\n+            ImmutableMap.of(JOIN_REORDERING_STRATEGY, NONE.name(),\n+                JOIN_DISTRIBUTION_TYPE, PARTITIONED.name(),\n+                ENABLE_LARGE_DYNAMIC_FILTERS, \"true\"),\n+            ImmutableMap.of(DYNAMIC_FILTERING_WAIT_TIMEOUT, \"1h\"),\n+            ImmutableMap.of(\"dynamic-filtering.large-partitioned.max-distinct-values-per-driver\", \"100\",\n+                \"dynamic-filtering.large-partitioned.range-row-limit-per-driver\", \"100000\"),\n+            TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        // TODO bring back OperatorStats assertions from https://github.com/prestosql/presto/commit/1feaa0f928a02f577c8ac9ef6cc0c8ec2008a46d\n+        // after https://github.com/prestosql/presto/issues/5120 is fixed\n+\n+        DynamicFilterService.DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTQ2Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r510555463", "bodyText": "The test case is most like TestHiveDynamicPartitionPruning.\nI think we assert dynamicFiltersCompleted so we know dynamic_filtering_wait_timeout takes effect. Otherwise the query might finised with dynamicFilters not Completed.", "author": "lzeiming", "createdAt": "2020-10-23T02:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU4MjM2MA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r510582360", "bodyText": "Right, collection of dynamic filters may or may not complete if the probe side does not wait for it. Still the utilisation of dynamic filters by the connector remains untested. Ideally if we were able to test that then the assertions about dynamicFiltersStats will not be needed here, it's enough to have them tested once in TestHiveDynamicPartitionPruning.\nPlease try adding assertions about rows read from Kudu in the tests here similar to the way assertDynamicFiltering is used in TestMemorySmoke.", "author": "raunaqmorarka", "createdAt": "2020-10-23T04:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3OTYyNA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r510679624", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-23T07:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4ODgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMzc2OA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r510403768", "bodyText": "Please check if adding assertions along the lines of assertDynamicFiltering in TestMemorySmoke works", "author": "raunaqmorarka", "createdAt": "2020-10-22T19:26:28Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.server.DynamicFilterService;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final String DYNAMIC_FILTERING_WAIT_TIMEOUT = \"dynamic_filtering_wait_timeout\";\n+    private static final long LINEITEM_COUNT = 60175;\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+            kuduServer, Optional.of(\"\"),\n+            ImmutableMap.of(JOIN_REORDERING_STRATEGY, NONE.name(),\n+                JOIN_DISTRIBUTION_TYPE, PARTITIONED.name(),\n+                ENABLE_LARGE_DYNAMIC_FILTERS, \"true\"),\n+            ImmutableMap.of(DYNAMIC_FILTERING_WAIT_TIMEOUT, \"1h\"),\n+            ImmutableMap.of(\"dynamic-filtering.large-partitioned.max-distinct-values-per-driver\", \"100\",\n+                \"dynamic-filtering.large-partitioned.range-row-limit-per-driver\", \"100000\"),\n+            TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        // TODO bring back OperatorStats assertions from https://github.com/prestosql/presto/commit/1feaa0f928a02f577c8ac9ef6cc0c8ec2008a46d", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MzY0Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r510563643", "bodyText": "Added in the second commit", "author": "lzeiming", "createdAt": "2020-10-23T02:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMzc2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU3ODUwNw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r510578507", "bodyText": "Sorry for the misunderstanding, I actually meant adding assertions about rows read from Kudu in the tests here similar to the way assertDynamicFiltering works in TestMemorySmoke.", "author": "raunaqmorarka", "createdAt": "2020-10-23T03:50:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMzc2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3ODY4Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r510678683", "bodyText": "Got it", "author": "lzeiming", "createdAt": "2020-10-23T07:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwMzc2OA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0NDE1Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r511044153", "bodyText": "If I'm understanding this correctly, this will wait for narrowing down of dynamic filter only twice, ideally we want to wait for dynamic filter to complete.", "author": "raunaqmorarka", "createdAt": "2020-10-23T17:48:37Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -45,10 +50,25 @@ public ConnectorSplitSource getSplits(\n             ConnectorTableHandle table,\n             SplitSchedulingStrategy splitSchedulingStrategy,\n             DynamicFilter dynamicFilter)\n+    {\n+        long blockingTimeoutMillis = getDynamicFilteringWaitTimeout(session).toMillis();\n+        if (blockingTimeoutMillis <= 0 || !dynamicFilter.isAwaitable()) {\n+            return getSplitSource(table, splitSchedulingStrategy, dynamicFilter);\n+        }\n+        // wait narrowing down twice\n+        CompletableFuture<ConnectorSplitSource> future = dynamicFilter.isBlocked()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczNTMwMA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r511735300", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-26T06:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0NDE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0NzUwMQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r511047501", "bodyText": "We could rename this to KuduDynamicFilteringSplitSource.\nInstead of the future, we could take the delegate split source and dynamic filter as parameters.\nYou could then implement the waiting logic in the methods here using the dynamic filter and delegate split source.", "author": "raunaqmorarka", "createdAt": "2020-10-23T17:54:42Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +79,56 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private static class AsyncDelegate", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY4NDE5OQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r511684199", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-26T01:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczODYyMw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r511738623", "bodyText": "I was thinking of something along the lines of DynamicFilteringPageSource in MemoryPageSourceProvider but adapted to ConnectorSplitSource and implementing a timeout instead of blocking until completion.\nI think your current way works too, but doing it that way could be cleaner.", "author": "raunaqmorarka", "createdAt": "2020-10-26T06:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0NzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc0NTQyMQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r511745421", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-26T06:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0NzUwMQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY4OTAyOQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r512689029", "bodyText": "Let's make it kudu.dynamic-filtering.wait-timeout", "author": "sopel39", "createdAt": "2020-10-27T13:26:38Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduClientConfig.java", "diffHunk": "@@ -151,4 +155,18 @@ public boolean isGroupedExecutionEnabled()\n     {\n         return groupedExecutionEnabled;\n     }\n+\n+    @NotNull\n+    public Duration getDynamicFilteringWaitTimeout()\n+    {\n+        return dynamicFilteringWaitTimeout;\n+    }\n+\n+    @Config(\"kudu.dynamic-filtering-wait-timeout\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNzkwOA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r513137908", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-28T02:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY4OTAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY4OTU0MQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r512689541", "bodyText": "do we simplify domains somewhere?", "author": "sopel39", "createdAt": "2020-10-27T13:27:18Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduClientSession.java", "diffHunk": "@@ -146,13 +147,14 @@ public Schema getTableSchema(KuduTableHandle tableHandle)\n         return KuduTableProperties.toMap(table);\n     }\n \n-    public List<KuduSplit> buildKuduSplits(KuduTableHandle tableHandle)\n+    public List<KuduSplit> buildKuduSplits(KuduTableHandle tableHandle, DynamicFilter dynamicFilter)\n     {\n         KuduTable table = tableHandle.getTable(this);\n         int primaryKeyColumnCount = table.getSchema().getPrimaryKeyColumnCount();\n         KuduScanToken.KuduScanTokenBuilder builder = client.newScanTokenBuilder(table);\n \n-        TupleDomain<ColumnHandle> constraint = tableHandle.getConstraint();\n+        TupleDomain<ColumnHandle> constraint = tableHandle.getConstraint()\n+                .intersect(dynamicFilter.getCurrentPredicate());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNzk0Ng==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r513137946", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-28T02:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY4OTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMTM2Mg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r513211362", "bodyText": "I don't see any simplification of domains taking place in Kudu connector, so we don't have any point of reference for how big a predicate Kudu can handle.\nI would suggest\nTupleDomain<ColumnHandle> constraint = tableHandle.getConstraint()\n                .intersect(dynamicFilter.getCurrentPredicate().simplify(100));\n\nThis way we don't change existing behaviour without DF and put a reasonable limit on DFs.", "author": "raunaqmorarka", "createdAt": "2020-10-28T06:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY4OTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI4MjE0Mg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r513282142", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-28T09:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY4OTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MTA2OQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r512691069", "bodyText": "Let's use @MinDuration(\"0ms\") annotation", "author": "sopel39", "createdAt": "2020-10-27T13:29:12Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduClientConfig.java", "diffHunk": "@@ -151,4 +155,18 @@ public boolean isGroupedExecutionEnabled()\n     {\n         return groupedExecutionEnabled;\n     }\n+\n+    @NotNull\n+    public Duration getDynamicFilteringWaitTimeout()\n+    {\n+        return dynamicFilteringWaitTimeout;\n+    }\n+\n+    @Config(\"kudu.dynamic-filtering-wait-timeout\")\n+    @ConfigDescription(\"Duration to wait for completion of dynamic filters\")\n+    public KuduClientConfig setDynamicFilteringWaitTimeout(Duration dynamicFilteringWaitTimeout)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNjMxNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r513136316", "bodyText": "Added @MinDuration(\"0ms\") on the getter as other config", "author": "lzeiming", "createdAt": "2020-10-28T02:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MTM2Mg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r512691362", "bodyText": "please validate that provided timeout >= 0", "author": "sopel39", "createdAt": "2020-10-27T13:29:35Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSessionProperties.java", "diffHunk": "@@ -38,6 +42,11 @@ public KuduSessionProperties(KuduClientConfig kuduConfig)\n                 \"Enable grouped execution.\",\n                 kuduConfig.isGroupedExecutionEnabled(),\n                 false))\n+            .add(durationProperty(\n+                DYNAMIC_FILTERING_WAIT_TIMEOUT,\n+                \"Duration to wait for completion of dynamic filters\",\n+                kuduConfig.getDynamicFilteringWaitTimeout(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNjc4Ng==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r513136786", "bodyText": "@MinDuration(\"0ms\") on the getter should do the validation", "author": "lzeiming", "createdAt": "2020-10-28T02:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MTM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4MjAwMQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r514982001", "bodyText": "not really, @MinDuration(\"0ms\") works only for feature config, not session properties set manually.", "author": "sopel39", "createdAt": "2020-10-30T09:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MTM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0NDEwMA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515444100", "bodyText": "added validation in decoder", "author": "lzeiming", "createdAt": "2020-10-31T02:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MTM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1NDk5NA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515654994", "bodyText": "@sopel39 do we really need special handling for negative values ? I see that Duration.valueof will either fail in the pattern match step or a negative value check in the constructor of Duration.\nE.g.:\nset session hive.dynamic_filtering_probe_blocking_timeout='-1s';\nQuery 20201101_182134_00005_ydqyw failed: duration is not a valid data duration string: -1s", "author": "raunaqmorarka", "createdAt": "2020-11-01T18:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MTM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MjEwOQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r512692109", "bodyText": "static import MILLISECONDS", "author": "sopel39", "createdAt": "2020-10-27T13:30:34Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +74,72 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<ConnectorSplitSource> future;\n+\n+        private KuduDynamicFilteringSplitSource(\n+                ConnectorTableHandle table,\n+                SplitSchedulingStrategy splitSchedulingStrategy,\n+                DynamicFilter dynamicFilter,\n+                long blockingTimeoutMillis)\n+        {\n+            this.future = whenCompleted(dynamicFilter)\n+                    .completeOnTimeout(null, blockingTimeoutMillis, TimeUnit.MILLISECONDS)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNzk3OQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r513137979", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-28T02:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MjEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MjgwMQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r512692801", "bodyText": "nit: each arg in newline", "author": "sopel39", "createdAt": "2020-10-27T13:31:26Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -45,10 +50,20 @@ public ConnectorSplitSource getSplits(\n             ConnectorTableHandle table,\n             SplitSchedulingStrategy splitSchedulingStrategy,\n             DynamicFilter dynamicFilter)\n+    {\n+        long blockingTimeoutMillis = getDynamicFilteringWaitTimeout(session).toMillis();\n+        if (blockingTimeoutMillis <= 0 || !dynamicFilter.isAwaitable()) {\n+            return getSplitSource(table, splitSchedulingStrategy, dynamicFilter);\n+        }\n+        return new KuduDynamicFilteringSplitSource(table, splitSchedulingStrategy, dynamicFilter, blockingTimeoutMillis);\n+    }\n+\n+    private ConnectorSplitSource getSplitSource(\n+            ConnectorTableHandle table, SplitSchedulingStrategy splitSchedulingStrategy, DynamicFilter dynamicFilter)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzODAwOA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r513138008", "bodyText": "Modified", "author": "lzeiming", "createdAt": "2020-10-28T02:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5MjgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5NDI1NA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r512694254", "bodyText": "DF could be narrowed down multiple times (you need to create future in getNextBatch). You could also use approach as in io.prestosql.plugin.hive.BackgroundHiveSplitLoader.HiveSplitLoaderTask#process", "author": "sopel39", "createdAt": "2020-10-27T13:33:22Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +74,72 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<ConnectorSplitSource> future;\n+\n+        private KuduDynamicFilteringSplitSource(\n+                ConnectorTableHandle table,\n+                SplitSchedulingStrategy splitSchedulingStrategy,\n+                DynamicFilter dynamicFilter,\n+                long blockingTimeoutMillis)\n+        {\n+            this.future = whenCompleted(dynamicFilter)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEzNzE4Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r513137183", "bodyText": "whenCompleted() is a recursive method which wait for narrowing multiple times until not awaitable.", "author": "lzeiming", "createdAt": "2020-10-28T02:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5NDI1NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4MzU5MA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r514983590", "bodyText": "blockingTimeoutMillis should not be negative", "author": "sopel39", "createdAt": "2020-10-30T09:55:52Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -45,10 +50,22 @@ public ConnectorSplitSource getSplits(\n             ConnectorTableHandle table,\n             SplitSchedulingStrategy splitSchedulingStrategy,\n             DynamicFilter dynamicFilter)\n+    {\n+        long blockingTimeoutMillis = getDynamicFilteringWaitTimeout(session).toMillis();\n+        if (blockingTimeoutMillis <= 0 || !dynamicFilter.isAwaitable()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0NDIyNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515444226", "bodyText": "added verify", "author": "lzeiming", "createdAt": "2020-10-31T02:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4MzU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4NDc1OA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r514984758", "bodyText": "don't use aberrations o", "author": "sopel39", "createdAt": "2020-10-30T09:58:04Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +76,72 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<ConnectorSplitSource> future;\n+\n+        private KuduDynamicFilteringSplitSource(\n+                ConnectorTableHandle table,\n+                SplitSchedulingStrategy splitSchedulingStrategy,\n+                DynamicFilter dynamicFilter,\n+                long blockingTimeoutMillis)\n+        {\n+            this.future = whenCompleted(dynamicFilter)\n+                    .completeOnTimeout(null, blockingTimeoutMillis, MILLISECONDS)\n+                    .thenApply(o -> getSplitSource(table, splitSchedulingStrategy, dynamicFilter));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0NDI2Nw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515444267", "bodyText": "updated", "author": "lzeiming", "createdAt": "2020-10-31T02:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4NDc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4NTA0MA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r514985040", "bodyText": "don't use aberrations s, rename to splitSource", "author": "sopel39", "createdAt": "2020-10-30T09:58:35Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +76,72 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<ConnectorSplitSource> future;\n+\n+        private KuduDynamicFilteringSplitSource(\n+                ConnectorTableHandle table,\n+                SplitSchedulingStrategy splitSchedulingStrategy,\n+                DynamicFilter dynamicFilter,\n+                long blockingTimeoutMillis)\n+        {\n+            this.future = whenCompleted(dynamicFilter)\n+                    .completeOnTimeout(null, blockingTimeoutMillis, MILLISECONDS)\n+                    .thenApply(o -> getSplitSource(table, splitSchedulingStrategy, dynamicFilter));\n+        }\n+\n+        @Override\n+        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+        {\n+            return future.thenCompose(s -> s.getNextBatch(partitionHandle, maxSize));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0NDI3Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515444273", "bodyText": "updated", "author": "lzeiming", "createdAt": "2020-10-31T02:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4NTA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4NjYxNw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r514986617", "bodyText": "This is prone to race condition, future could complete just after future.isDone() is checked", "author": "sopel39", "createdAt": "2020-10-30T10:01:23Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +76,72 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<ConnectorSplitSource> future;\n+\n+        private KuduDynamicFilteringSplitSource(\n+                ConnectorTableHandle table,\n+                SplitSchedulingStrategy splitSchedulingStrategy,\n+                DynamicFilter dynamicFilter,\n+                long blockingTimeoutMillis)\n+        {\n+            this.future = whenCompleted(dynamicFilter)\n+                    .completeOnTimeout(null, blockingTimeoutMillis, MILLISECONDS)\n+                    .thenApply(o -> getSplitSource(table, splitSchedulingStrategy, dynamicFilter));\n+        }\n+\n+        @Override\n+        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+        {\n+            return future.thenCompose(s -> s.getNextBatch(partitionHandle, maxSize));\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            if (future.isDone()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0NDI4Mg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515444282", "bodyText": "updated", "author": "lzeiming", "createdAt": "2020-10-31T02:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4NjYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4ODUwNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r514988506", "bodyText": "extract new KuduDynamicFilteringSplitSource(table, splitSchedulingStrategy, dynamicFilter, blockingTimeoutMillis); to internal method and don't call top-level getSplitSource (it creases tricky recursive flow)", "author": "sopel39", "createdAt": "2020-10-30T10:04:59Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +76,72 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<ConnectorSplitSource> future;\n+\n+        private KuduDynamicFilteringSplitSource(\n+                ConnectorTableHandle table,\n+                SplitSchedulingStrategy splitSchedulingStrategy,\n+                DynamicFilter dynamicFilter,\n+                long blockingTimeoutMillis)\n+        {\n+            this.future = whenCompleted(dynamicFilter)\n+                    .completeOnTimeout(null, blockingTimeoutMillis, MILLISECONDS)\n+                    .thenApply(o -> getSplitSource(table, splitSchedulingStrategy, dynamicFilter));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0NDI5Ng==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515444296", "bodyText": "updated", "author": "lzeiming", "createdAt": "2020-10-31T02:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4ODUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4OTI0Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r514989243", "bodyText": "this case is redundant", "author": "sopel39", "createdAt": "2020-10-30T10:06:26Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinLargeBuildSideDynamicFiltering()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey and orders.custkey BETWEEN 300 AND 700\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedJoinDynamicFiltering()\n+    {\n+        // Probe-side is not scanned at all\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+\n+        // Join lineitem with a single row of part\n+        assertDynamicFiltering(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0NDMxMg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515444312", "bodyText": "removed the case", "author": "lzeiming", "createdAt": "2020-10-31T02:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4OTI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4OTQyNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r514989426", "bodyText": "This case is redundent. Coercion is already tested in different places", "author": "sopel39", "createdAt": "2020-10-30T10:06:49Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinLargeBuildSideDynamicFiltering()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey and orders.custkey BETWEEN 300 AND 700\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedJoinDynamicFiltering()\n+    {\n+        // Probe-side is not scanned at all\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+\n+        // Join lineitem with a single row of part\n+        assertDynamicFiltering(\n+                \"SELECT l.comment FROM  lineitem l, part p WHERE p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                withBroadcastJoin(),\n+                39,\n+                ImmutableSet.of(39, 1));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringImplicitCoercion()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0NDMyNQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515444325", "bodyText": "removed the case", "author": "lzeiming", "createdAt": "2020-10-31T02:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4OTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAwMDk0MA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515000940", "bodyText": "Let's just have a single DF test in this. Other cases are already covered pretty well. However, it would be nice to have a test like: io.prestosql.plugin.hive.TestBackgroundHiveSplitLoader#testIncompleteDynamicFilterTimeout", "author": "sopel39", "createdAt": "2020-10-30T10:28:35Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestKuduIntegrationDynamicFilter", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0NDM0NA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515444344", "bodyText": "added testIncompleteDynamicFilterTimeout()", "author": "lzeiming", "createdAt": "2020-10-31T02:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAwMDk0MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1NTExNA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515655114", "bodyText": "I think in negative value case Duration.valueOf will throw exception anyway, we won't reach here", "author": "raunaqmorarka", "createdAt": "2020-11-01T18:29:13Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSessionProperties.java", "diffHunk": "@@ -14,31 +14,53 @@\n package io.prestosql.plugin.kudu;\n \n import com.google.common.collect.ImmutableList;\n+import io.airlift.units.Duration;\n+import io.prestosql.spi.PrestoException;\n import io.prestosql.spi.connector.ConnectorSession;\n import io.prestosql.spi.session.PropertyMetadata;\n \n import javax.inject.Inject;\n \n import java.util.List;\n \n+import static io.prestosql.spi.StandardErrorCode.INVALID_SESSION_PROPERTY;\n import static io.prestosql.spi.session.PropertyMetadata.booleanProperty;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static java.lang.String.format;\n \n public final class KuduSessionProperties\n {\n     private static final String KUDU_GROUPED_EXECUTION_ENABLED = \"grouped_execution\";\n+    private static final String DYNAMIC_FILTERING_WAIT_TIMEOUT = \"dynamic_filtering_wait_timeout\";\n \n     private final List<PropertyMetadata<?>> sessionProperties;\n \n     @Inject\n     public KuduSessionProperties(KuduClientConfig kuduConfig)\n     {\n-        sessionProperties = ImmutableList.<PropertyMetadata<?>>builder()\n-            .add(booleanProperty(\n-                KUDU_GROUPED_EXECUTION_ENABLED,\n-                \"Enable grouped execution.\",\n-                kuduConfig.isGroupedExecutionEnabled(),\n-                false))\n-            .build();\n+        sessionProperties = ImmutableList.of(\n+            booleanProperty(\n+                    KUDU_GROUPED_EXECUTION_ENABLED,\n+                    \"Enable grouped execution.\",\n+                    kuduConfig.isGroupedExecutionEnabled(),\n+                    false),\n+            new PropertyMetadata<>(\n+                    DYNAMIC_FILTERING_WAIT_TIMEOUT,\n+                    \"Duration to wait for completion of dynamic filters\",\n+                    VARCHAR,\n+                    Duration.class,\n+                    kuduConfig.getDynamicFilteringWaitTimeout(),\n+                    false,\n+                    value -> {\n+                        Duration duration = Duration.valueOf((String) value);\n+                        if (duration.getValue() < 0) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0OTQ3MQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515749471", "bodyText": "Updated", "author": "lzeiming", "createdAt": "2020-11-02T05:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1NTExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1NTM0NA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515655344", "bodyText": "I don't think this check can fail", "author": "raunaqmorarka", "createdAt": "2020-11-01T18:30:55Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -45,10 +52,25 @@ public ConnectorSplitSource getSplits(\n             ConnectorTableHandle table,\n             SplitSchedulingStrategy splitSchedulingStrategy,\n             DynamicFilter dynamicFilter)\n+    {\n+        long timeoutMillis = getDynamicFilteringWaitTimeout(session).toMillis();\n+        verify(timeoutMillis >= 0, \"wait timeout is negative\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0OTgzMQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515749831", "bodyText": "Updated", "author": "lzeiming", "createdAt": "2020-11-02T05:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1NTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1NTc2OQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515655769", "bodyText": "This test should be on top of KuduSplitManager, similar to TestBackgroundHiveSplitLoader#testIncompleteDynamicFilterTimeout.\nYou shouldn't have to expose completedOrTimeout to test this.", "author": "raunaqmorarka", "createdAt": "2020-11-01T18:34:51Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.plugin.kudu.KuduSplitManager.completedOrTimeout;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 10_000)\n+    public void testIncompleteDynamicFilterTimeout()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0OTg4Mg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515749882", "bodyText": "Updated", "author": "lzeiming", "createdAt": "2020-11-02T05:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY1NTc2OQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NDA1Mg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515884052", "bodyText": "static import NOT_BLOCKED", "author": "sopel39", "createdAt": "2020-11-02T10:42:11Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +79,56 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private static CompletableFuture<?> whenCompleted(DynamicFilter dynamicFilter)\n+    {\n+        if (dynamicFilter.isAwaitable()) {\n+            return dynamicFilter.isBlocked().thenCompose(o -> whenCompleted(dynamicFilter));\n+        }\n+        else {\n+            return DynamicFilter.NOT_BLOCKED;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTA4OQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395089", "bodyText": "updated", "author": "lzeiming", "createdAt": "2020-11-03T02:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NDA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NDcwNw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515884707", "bodyText": "requireNotNull(future, \"future is null\")", "author": "sopel39", "createdAt": "2020-11-02T10:43:28Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +79,56 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private static CompletableFuture<?> whenCompleted(DynamicFilter dynamicFilter)\n+    {\n+        if (dynamicFilter.isAwaitable()) {\n+            return dynamicFilter.isBlocked().thenCompose(o -> whenCompleted(dynamicFilter));\n+        }\n+        else {\n+            return DynamicFilter.NOT_BLOCKED;\n+        }\n+    }\n+\n+    private static class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<ConnectorSplitSource> future;\n+\n+        private KuduDynamicFilteringSplitSource(CompletableFuture<ConnectorSplitSource> future)\n+        {\n+            this.future = future;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTExNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395116", "bodyText": "updated", "author": "lzeiming", "createdAt": "2020-11-03T02:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NDcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NjgzOA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515886838", "bodyText": "this still doesn't help with race condition, e.g: other thread might be just after obtaining split source via getSplitSource(table, splitSchedulingStrategy, dynamicFilter) but before exiting .thenApply(result -> getSplitSource(table, splitSchedulingStrategy, dynamicFilter));. In that case cancellation would be successful, but split source is not closed.", "author": "sopel39", "createdAt": "2020-11-02T10:47:03Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +79,56 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private static CompletableFuture<?> whenCompleted(DynamicFilter dynamicFilter)\n+    {\n+        if (dynamicFilter.isAwaitable()) {\n+            return dynamicFilter.isBlocked().thenCompose(o -> whenCompleted(dynamicFilter));\n+        }\n+        else {\n+            return DynamicFilter.NOT_BLOCKED;\n+        }\n+    }\n+\n+    private static class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<ConnectorSplitSource> future;\n+\n+        private KuduDynamicFilteringSplitSource(CompletableFuture<ConnectorSplitSource> future)\n+        {\n+            this.future = future;\n+        }\n+\n+        @Override\n+        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+        {\n+            return future.thenCompose(splitSource -> splitSource.getNextBatch(partitionHandle, maxSize));\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            if (!future.cancel(true)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTE0MQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395141", "bodyText": "updated", "author": "lzeiming", "createdAt": "2020-11-03T02:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NjgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NzcxNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515887716", "bodyText": "remove this test", "author": "sopel39", "createdAt": "2020-11-02T10:48:42Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinLargeBuildSideDynamicFiltering()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTUwNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395506", "bodyText": "removed", "author": "lzeiming", "createdAt": "2020-11-03T02:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NzcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4Nzc2OA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515887768", "bodyText": "remove this test", "author": "sopel39", "createdAt": "2020-11-02T10:48:48Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinLargeBuildSideDynamicFiltering()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey and orders.custkey BETWEEN 300 AND 700\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedJoinDynamicFiltering()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTUxOQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395519", "bodyText": "removed", "author": "lzeiming", "createdAt": "2020-11-03T02:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4Nzc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4Nzk0OA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515887948", "bodyText": "remove this test", "author": "sopel39", "createdAt": "2020-11-02T10:49:07Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODIwMA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515888200", "bodyText": "remove this test", "author": "sopel39", "createdAt": "2020-11-02T10:49:34Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinLargeBuildSideDynamicFiltering()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey and orders.custkey BETWEEN 300 AND 700\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedJoinDynamicFiltering()\n+    {\n+        // Probe-side is not scanned at all\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        assertDynamicFiltering(\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                withBroadcastJoinNonReordering(),\n+                1,\n+                ImmutableSet.of(1));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringNone()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTUzMg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395532", "bodyText": "removed", "author": "lzeiming", "createdAt": "2020-11-03T02:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODI3MQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515888271", "bodyText": "remove this test", "author": "sopel39", "createdAt": "2020-11-02T10:49:42Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinLargeBuildSideDynamicFiltering()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey and orders.custkey BETWEEN 300 AND 700\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedJoinDynamicFiltering()\n+    {\n+        // Probe-side is not scanned at all\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        assertDynamicFiltering(\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                withBroadcastJoinNonReordering(),\n+                1,\n+                ImmutableSet.of(1));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testSemiJoinLargeBuildSideDynamicFiltering()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTU0OQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395549", "bodyText": "removed", "author": "lzeiming", "createdAt": "2020-11-03T02:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODM1Ng==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515888356", "bodyText": "remove this test", "author": "sopel39", "createdAt": "2020-11-02T10:49:52Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinLargeBuildSideDynamicFiltering()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey and orders.custkey BETWEEN 300 AND 700\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedJoinDynamicFiltering()\n+    {\n+        // Probe-side is not scanned at all\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        assertDynamicFiltering(\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                withBroadcastJoinNonReordering(),\n+                1,\n+                ImmutableSet.of(1));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testSemiJoinLargeBuildSideDynamicFiltering()\n+    {\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem WHERE lineitem.orderkey IN \" +\n+                \"(SELECT orders.orderkey FROM orders WHERE orders.custkey BETWEEN 300 AND 700)\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedSemiJoinDynamicFiltering()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTMyOQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395329", "bodyText": "removed", "author": "lzeiming", "createdAt": "2020-11-03T02:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODQ1MA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515888450", "bodyText": "remove this test", "author": "sopel39", "createdAt": "2020-11-02T10:49:59Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinLargeBuildSideDynamicFiltering()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey and orders.custkey BETWEEN 300 AND 700\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedJoinDynamicFiltering()\n+    {\n+        // Probe-side is not scanned at all\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        assertDynamicFiltering(\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                withBroadcastJoinNonReordering(),\n+                1,\n+                ImmutableSet.of(1));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testSemiJoinLargeBuildSideDynamicFiltering()\n+    {\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem WHERE lineitem.orderkey IN \" +\n+                \"(SELECT orders.orderkey FROM orders WHERE orders.custkey BETWEEN 300 AND 700)\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedSemiJoinDynamicFiltering()\n+    {\n+        // Probe-side is not scanned at all\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringSingleValue()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTU2Ng==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395566", "bodyText": "removed", "author": "lzeiming", "createdAt": "2020-11-03T02:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODUxMw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r515888513", "bodyText": "remove this test", "author": "sopel39", "createdAt": "2020-11-02T10:50:06Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.ENABLE_LARGE_DYNAMIC_FILTERS;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private static final int LINEITEM_COUNT = 60175;\n+\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinLargeBuildSideDynamicFiltering()\n+    {\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey and orders.custkey BETWEEN 300 AND 700\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedJoinDynamicFiltering()\n+    {\n+        // Probe-side is not scanned at all\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        assertDynamicFiltering(\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                withBroadcastJoinNonReordering(),\n+                1,\n+                ImmutableSet.of(1));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringNone()\n+    {\n+        // Probe-side is not scanned at all, due to dynamic filtering:\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withBroadcastJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testSemiJoinLargeBuildSideDynamicFiltering()\n+    {\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem WHERE lineitem.orderkey IN \" +\n+                \"(SELECT orders.orderkey FROM orders WHERE orders.custkey BETWEEN 300 AND 700)\";\n+        int expectedRowCount = 15793;\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertDynamicFiltering(\n+                sql,\n+                withBroadcastJoin(),\n+                expectedRowCount,\n+                ImmutableSet.of(LINEITEM_COUNT, 3977));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering\n+        assertDynamicFiltering(\n+                sql,\n+                withLargeDynamicFilters(),\n+                expectedRowCount,\n+                ImmutableSet.of(60139, 3977));\n+    }\n+\n+    @Test\n+    public void testPartitionedSemiJoinDynamicFiltering()\n+    {\n+        // Probe-side is not scanned at all\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.totalprice < 0)\",\n+                withPartitionedJoin(),\n+                0,\n+                ImmutableSet.of(0));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders WHERE orders.comment = 'nstructions sleep furiously among ')\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+    }\n+\n+    @Test\n+    public void testSemiJoinDynamicFilteringBlockProbeSide()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTU5Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r516395593", "bodyText": "removed", "author": "lzeiming", "createdAt": "2020-11-03T02:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4ODUxMw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzOTE5Mg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r517339192", "bodyText": "redunrent else", "author": "sopel39", "createdAt": "2020-11-04T13:24:25Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +81,60 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private static CompletableFuture<?> whenCompleted(DynamicFilter dynamicFilter)\n+    {\n+        if (dynamicFilter.isAwaitable()) {\n+            return dynamicFilter.isBlocked().thenCompose(ignored -> whenCompleted(dynamicFilter));\n+        }\n+        else {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0ODc1MA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r517348750", "bodyText": "Could it be that cancellation succeeded and splitSourceFuture created split source anyway (I think it still might be the case).\nWhat if we implement getNextBatch as:\n@GuardedBy(\"this\")\nprivate Optional<ConnectorSplitSource> delegateSplitSource = Optional.empty();\n\npublic CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n{\n  if (!dynamicFilterFuture.isDone()) {\n    return dynamicFilterFuture.thenApply(new ConnectorSplitSource.ConnectorSplitBatch(ImmutableList.of(), false));\n  }\n\n  return getDelegateSplitSource().getNextBatch(partitionHandle, maxSize)\n}\n\nprivate synchronized ConnectorSplitSource getDelegateSplitSource() {\n  if (delegateSplitSource.isPresent()) {\n   return delegateSplitSource.get();\n  }\n\n  delegateSplitSource = Optional.of(...)\n  return delegateSplitSource.get();\n}", "author": "sopel39", "createdAt": "2020-11-04T13:39:46Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +81,60 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private static CompletableFuture<?> whenCompleted(DynamicFilter dynamicFilter)\n+    {\n+        if (dynamicFilter.isAwaitable()) {\n+            return dynamicFilter.isBlocked().thenCompose(ignored -> whenCompleted(dynamicFilter));\n+        }\n+        else {\n+            return NOT_BLOCKED;\n+        }\n+    }\n+\n+    private static class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<?> dynamicFilterFuture;\n+        private final CompletableFuture<ConnectorSplitSource> splitSourceFuture;\n+\n+        private KuduDynamicFilteringSplitSource(\n+                CompletableFuture<?> dynamicFilterFuture,\n+                CompletableFuture<ConnectorSplitSource> splitSourceFuture)\n+        {\n+            this.dynamicFilterFuture = requireNonNull(dynamicFilterFuture, \"dynamicFilterFuture is null\");\n+            this.splitSourceFuture = requireNonNull(splitSourceFuture, \"splitSourceFuture is null\");\n+        }\n+\n+        @Override\n+        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+        {\n+            return splitSourceFuture.thenCompose(splitSource -> splitSource.getNextBatch(partitionHandle, maxSize));\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            if (!dynamicFilterFuture.cancel(true)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczNzg0NA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r517737844", "bodyText": "Could it be that cancellation succeeded and splitSourceFuture created split source anyway (I think it still might be the case).\n\nI do not think the case should exist.\nIf dynamicFilterFuture cancellation succeeded, then dynamicFilterFuture is not completed normally, then function getSplitSource() is not triggered.\nReasoning backward, if getSplitSource() is already triggered, we know dynamicFilterFuture is completed normally, dynamicFilterFuture cancellation should fail.", "author": "lzeiming", "createdAt": "2020-11-05T02:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0ODc1MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1NjgxMQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r519656811", "bodyText": "reverse the iff:\nif (!splitSourceFuture.isDone()) {\n  return false;\n}\n\nif (splitSourceFuture.isCompletedExceptionally()) {\n  return false;\n}\n...", "author": "sopel39", "createdAt": "2020-11-09T09:17:00Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +81,58 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private static CompletableFuture<?> whenCompleted(DynamicFilter dynamicFilter)\n+    {\n+        if (dynamicFilter.isAwaitable()) {\n+            return dynamicFilter.isBlocked().thenCompose(ignored -> whenCompleted(dynamicFilter));\n+        }\n+        return NOT_BLOCKED;\n+    }\n+\n+    private static class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<?> dynamicFilterFuture;\n+        private final CompletableFuture<ConnectorSplitSource> splitSourceFuture;\n+\n+        private KuduDynamicFilteringSplitSource(\n+                CompletableFuture<?> dynamicFilterFuture,\n+                CompletableFuture<ConnectorSplitSource> splitSourceFuture)\n+        {\n+            this.dynamicFilterFuture = requireNonNull(dynamicFilterFuture, \"dynamicFilterFuture is null\");\n+            this.splitSourceFuture = requireNonNull(splitSourceFuture, \"splitSourceFuture is null\");\n+        }\n+\n+        @Override\n+        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+        {\n+            return splitSourceFuture.thenCompose(splitSource -> splitSource.getNextBatch(partitionHandle, maxSize));\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            if (!dynamicFilterFuture.cancel(true)) {\n+                splitSourceFuture.thenAccept(ConnectorSplitSource::close);\n+            }\n+        }\n+\n+        @Override\n+        public boolean isFinished()\n+        {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1ODQyMg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r519658422", "bodyText": "I don't think it can complete exceptionally", "author": "sopel39", "createdAt": "2020-11-09T09:19:44Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduSplitManager.java", "diffHunk": "@@ -59,4 +81,58 @@ public ConnectorSplitSource getSplits(\n                 throw new IllegalArgumentException(\"Unknown splitSchedulingStrategy: \" + splitSchedulingStrategy);\n         }\n     }\n+\n+    private static CompletableFuture<?> whenCompleted(DynamicFilter dynamicFilter)\n+    {\n+        if (dynamicFilter.isAwaitable()) {\n+            return dynamicFilter.isBlocked().thenCompose(ignored -> whenCompleted(dynamicFilter));\n+        }\n+        return NOT_BLOCKED;\n+    }\n+\n+    private static class KuduDynamicFilteringSplitSource\n+            implements ConnectorSplitSource\n+    {\n+        private final CompletableFuture<?> dynamicFilterFuture;\n+        private final CompletableFuture<ConnectorSplitSource> splitSourceFuture;\n+\n+        private KuduDynamicFilteringSplitSource(\n+                CompletableFuture<?> dynamicFilterFuture,\n+                CompletableFuture<ConnectorSplitSource> splitSourceFuture)\n+        {\n+            this.dynamicFilterFuture = requireNonNull(dynamicFilterFuture, \"dynamicFilterFuture is null\");\n+            this.splitSourceFuture = requireNonNull(splitSourceFuture, \"splitSourceFuture is null\");\n+        }\n+\n+        @Override\n+        public CompletableFuture<ConnectorSplitBatch> getNextBatch(ConnectorPartitionHandle partitionHandle, int maxSize)\n+        {\n+            return splitSourceFuture.thenCompose(splitSource -> splitSource.getNextBatch(partitionHandle, maxSize));\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            if (!dynamicFilterFuture.cancel(true)) {\n+                splitSourceFuture.thenAccept(ConnectorSplitSource::close);\n+            }\n+        }\n+\n+        @Override\n+        public boolean isFinished()\n+        {\n+            if (splitSourceFuture.isDone()) {\n+                if (splitSourceFuture.isCompletedExceptionally()) {\n+                    return false;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI2NjY0NQ==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r520266645", "bodyText": "If isFinished() is called after close(), and dynamicFilterFuture cancellation in close() succeeded, splitSourceFuture is completed exceptionally.", "author": "lzeiming", "createdAt": "2020-11-10T03:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1ODQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg5NDM1NA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r522894354", "bodyText": "It should return true then here", "author": "sopel39", "createdAt": "2020-11-13T11:32:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1ODQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzMzNzA3Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r523337073", "bodyText": "In this case, splitSource is not created since getSplitSource() is not triggered. I think return false is more reasonable.\nisFinished() return false after close() should not be a problem. In FixedSplitSource,  isFinished() aslo can return false after close().", "author": "lzeiming", "createdAt": "2020-11-14T01:50:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1ODQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2MDE2NA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r519660164", "bodyText": "we changed that method to return list now: io.prestosql.plugin.memory.TestMemorySmoke#getOperatorRowsRead", "author": "sopel39", "createdAt": "2020-11-09T09:22:27Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter\n+            implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        assertDynamicFiltering(\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                withBroadcastJoinNonReordering(),\n+                1,\n+                ImmutableSet.of(1));\n+    }\n+\n+    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, Set<Integer> expectedOperatorRowsRead)\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, selectQuery);\n+\n+        assertEquals(result.getResult().getRowCount(), expectedRowCount);\n+        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), expectedOperatorRowsRead);\n+    }\n+\n+    private Session withBroadcastJoin()\n+    {\n+        return Session.builder(this.getQueryRunner().getDefaultSession())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, BROADCAST.name())\n+                .build();\n+    }\n+\n+    private Session withBroadcastJoinNonReordering()\n+    {\n+        return Session.builder(this.getQueryRunner().getDefaultSession())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, BROADCAST.name())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .build();\n+    }\n+\n+    private static Set<Integer> getOperatorRowsRead(DistributedQueryRunner runner, QueryId queryId)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2MDYwNg==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r519660606", "bodyText": "we changed that method to accept array of ints now: io.prestosql.plugin.memory.TestMemorySmoke#assertDynamicFiltering", "author": "sopel39", "createdAt": "2020-11-09T09:23:11Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter\n+            implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                ImmutableSet.of(6, 1));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        assertDynamicFiltering(\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                withBroadcastJoinNonReordering(),\n+                1,\n+                ImmutableSet.of(1));\n+    }\n+\n+    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, Set<Integer> expectedOperatorRowsRead)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk3OTg5Mw==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r521979893", "bodyText": "remote .this", "author": "sopel39", "createdAt": "2020-11-12T09:57:59Z", "path": "presto-kudu/src/test/java/io/prestosql/plugin/kudu/TestKuduIntegrationDynamicFilter.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kudu;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.execution.Lifespan;\n+import io.prestosql.execution.QueryStats;\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.metadata.Split;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.security.AllowAllAccessControl;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.split.SplitSource;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import io.prestosql.tpch.TpchTable;\n+import io.prestosql.transaction.TransactionId;\n+import io.prestosql.transaction.TransactionManager;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.kudu.KuduQueryRunnerFactory.createKuduQueryRunnerTpch;\n+import static io.prestosql.spi.connector.ConnectorSplitManager.SplitSchedulingStrategy.UNGROUPED_SCHEDULING;\n+import static io.prestosql.spi.connector.NotPartitionedPartitionHandle.NOT_PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.BROADCAST;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestKuduIntegrationDynamicFilter\n+        extends AbstractTestQueryFramework\n+{\n+    private TestingKuduServer kuduServer;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        kuduServer = new TestingKuduServer();\n+        return createKuduQueryRunnerTpch(\n+                kuduServer,\n+                Optional.of(\"\"),\n+                ImmutableMap.of(\"dynamic_filtering_wait_timeout\", \"1h\"),\n+                ImmutableMap.of(\n+                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n+                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\"),\n+                TpchTable.getTables());\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public final void destroy()\n+    {\n+        kuduServer.close();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        QueryRunner runner = getQueryRunner();\n+        TransactionManager transactionManager = runner.getTransactionManager();\n+        TransactionId transactionId = transactionManager.beginTransaction(false);\n+        Session session = Session.builder(runner.getDefaultSession())\n+                .setCatalogSessionProperty(\"kudu\", \"dynamic_filtering_wait_timeout\", \"1s\")\n+                .build()\n+                .beginTransactionId(transactionId, transactionManager, new AllowAllAccessControl());\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"kudu\", \"tpch\", \"orders\");\n+        Optional<TableHandle> tableHandle = runner.getMetadata().getTableHandle(session, tableName);\n+        assertTrue(tableHandle.isPresent());\n+        SplitSource splitSource = runner.getSplitManager()\n+                .getSplits(session, tableHandle.get(), UNGROUPED_SCHEDULING, new IncompleteDynamicFilter());\n+        List<Split> splits = new ArrayList<>();\n+        while (!splitSource.isFinished()) {\n+            splits.addAll(splitSource.getNextBatch(NOT_PARTITIONED, Lifespan.taskWide(), 1000).get().getSplits());\n+        }\n+        splitSource.close();\n+        assertFalse(splits.isEmpty());\n+    }\n+\n+    private static class IncompleteDynamicFilter\n+            implements DynamicFilter\n+    {\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return CompletableFuture.runAsync(() -> {\n+                try {\n+                    TimeUnit.HOURS.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean isComplete()\n+        {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isAwaitable()\n+        {\n+            return true;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();\n+        }\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringSingleValue()\n+    {\n+        // Join lineitem with a single row of orders\n+        assertDynamicFiltering(\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\",\n+                withBroadcastJoin(),\n+                6,\n+                6, 1);\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        assertDynamicFiltering(\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\",\n+                withBroadcastJoinNonReordering(),\n+                1,\n+                1, 1, 1);\n+    }\n+\n+    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, int... expectedOperatorRowsRead)\n+    {\n+        DistributedQueryRunner runner = getDistributedQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, selectQuery);\n+\n+        assertEquals(result.getResult().getRowCount(), expectedRowCount);\n+        assertEquals(getOperatorRowsRead(runner, result.getQueryId()).toArray(), expectedOperatorRowsRead);\n+    }\n+\n+    private Session withBroadcastJoin()\n+    {\n+        return Session.builder(this.getQueryRunner().getDefaultSession())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, BROADCAST.name())\n+                .build();\n+    }\n+\n+    private Session withBroadcastJoinNonReordering()\n+    {\n+        return Session.builder(this.getQueryRunner().getDefaultSession())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "8e740d2d15b7342b7e27409bd0cfc32ed850fb3f", "url": "https://github.com/trinodb/trino/commit/8e740d2d15b7342b7e27409bd0cfc32ed850fb3f", "message": "Wait for and build split with dynamic filter in Kudu", "committedDate": "2020-11-14T01:53:02Z", "type": "commit"}, {"oid": "8e740d2d15b7342b7e27409bd0cfc32ed850fb3f", "url": "https://github.com/trinodb/trino/commit/8e740d2d15b7342b7e27409bd0cfc32ed850fb3f", "message": "Wait for and build split with dynamic filter in Kudu", "committedDate": "2020-11-14T01:53:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDIyMTA4NA==", "url": "https://github.com/trinodb/trino/pull/5594#discussion_r524221084", "bodyText": "nit: test for kudu config is missing", "author": "sopel39", "createdAt": "2020-11-16T12:30:42Z", "path": "presto-kudu/src/main/java/io/prestosql/plugin/kudu/KuduClientConfig.java", "diffHunk": "@@ -26,6 +27,8 @@\n import java.util.List;\n import java.util.concurrent.TimeUnit;\n \n+import static java.util.concurrent.TimeUnit.MINUTES;", "originalCommit": "8e740d2d15b7342b7e27409bd0cfc32ed850fb3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}