{"pr_number": 6326, "pr_title": "Decorrelate subquery with inner UNNEST and global aggregation", "pr_createdAt": "2020-12-13T22:38:17Z", "pr_url": "https://github.com/trinodb/trino/pull/6326", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyMTk1NA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r546121954", "bodyText": "correlation(c1, c2)?", "author": "martint", "createdAt": "2020-12-18T22:32:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedUnnestToLeftUnnest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.PlanNodeIdAllocator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolAllocator;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AssignUniqueId;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.CorrelatedJoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanNodeId;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.UnnestNode;\n+import io.prestosql.sql.planner.plan.UnnestNode.Mapping;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.matching.Pattern.nonEmpty;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.prestosql.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.prestosql.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.prestosql.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.prestosql.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c1)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyMzI4Mw==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r546123283", "bodyText": "Is the fact that there are two nested aggregations relevant? Or is that just for illustration?", "author": "martint", "createdAt": "2020-12-18T22:36:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedUnnestToLeftUnnest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.PlanNodeIdAllocator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolAllocator;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AssignUniqueId;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.CorrelatedJoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanNodeId;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.UnnestNode;\n+import io.prestosql.sql.planner.plan.UnnestNode.Mapping;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.matching.Pattern.nonEmpty;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.prestosql.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.prestosql.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.prestosql.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.prestosql.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c1)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI4Njg4OQ==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r546286889", "bodyText": "It is just an illustration to show how a grouped aggregation and a global aggregation are rewritten.", "author": "kasiafi", "createdAt": "2020-12-19T21:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyMzI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEyNzQzOQ==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r546127439", "bodyText": "I think this is too constraining. We should be able to decorrelate any query that produces a scalar value, such as:\nSELECT (\n    SELECT k \n    FROM UNNEST(a) AS u(k) \n    LIMIT 1\n)\nFROM (VALUES\n    ARRAY[1,2,3],\n    ARRAY[4,5,6],\n    ARRAY[]) t(a)\n\nor even, simply:\nSELECT (\n    SELECT k \n    FROM UNNEST(a) AS u(k) \n)\nFROM ...\n\nwhich should fail if the nested subquery produces more than one row for each outer row.\nThe rewrite would likely have to involve some window function and a check to make sure that the count of rows with the same uniqueid is <= 1 (or else fail).", "author": "martint", "createdAt": "2020-12-18T22:51:14Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedUnnestToLeftUnnest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.PlanNodeIdAllocator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolAllocator;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AssignUniqueId;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.CorrelatedJoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanNodeId;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.UnnestNode;\n+import io.prestosql.sql.planner.plan.UnnestNode.Mapping;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.matching.Pattern.nonEmpty;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.prestosql.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.prestosql.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.prestosql.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.prestosql.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c1)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class TransformCorrelatedUnnestToLeftUnnest\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(TransformCorrelatedUnnestToLeftUnnest::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE3NzE2OA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r561177168", "bodyText": "I would call this isSupportedUnnest and add short commment what does it mean (even if it would add duplication agains class-level javadoc)", "author": "losipiuk", "createdAt": "2021-01-20T18:19:37Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/TransformCorrelatedUnnestToLeftUnnest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class TransformCorrelatedUnnestToLeftUnnest\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(TransformCorrelatedUnnestToLeftUnnest::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // if there are multiple global aggregations, the one that is closest to the source is the \"reducing\" aggregation, because it reduces multiple input rows to single output row\n+        AggregationNode reducingAggregation = (AggregationNode) globalAggregations.get(globalAggregations.size() - 1);\n+\n+        // find unnest in subquery\n+        Optional<PlanNode> subqueryUnnest = PlanNodeSearcher.searchFrom(reducingAggregation.getSource(), context.getLookup())\n+                .where(node -> isCorrelatedUnnest(node, correlatedJoinNode.getCorrelation(), context.getLookup()))\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGroupedAggregation(node))\n+                .findFirst();\n+\n+        if (subqueryUnnest.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        UnnestNode unnestNode = (UnnestNode) subqueryUnnest.get();\n+\n+        // assign unique id on input rows to restore semantics of aggregations after rewrite\n+        PlanNode input = new AssignUniqueId(\n+                context.getIdAllocator().getNextId(),\n+                correlatedJoinNode.getInput(),\n+                context.getSymbolAllocator().newSymbol(\"unique\", BIGINT));\n+\n+        // pre-project unnest symbols if they were pre-projected in subquery\n+        if (!ImmutableSet.copyOf(correlatedJoinNode.getCorrelation()).containsAll(unnestNode.getMappings().stream()\n+                .map(Mapping::getInput)\n+                .collect(toImmutableList()))) {\n+            ProjectNode unnestSource = (ProjectNode) context.getLookup().resolve(unnestNode.getSource());\n+            input = new ProjectNode(\n+                    unnestSource.getId(),\n+                    input,\n+                    Assignments.builder()\n+                            .putIdentities(input.getOutputSymbols())\n+                            .putAll(unnestSource.getAssignments())\n+                            .build());\n+        }\n+\n+        // rewrite correlated join to UnnestNode\n+        Symbol ordinalitySymbol = unnestNode.getOrdinalitySymbol().orElseGet(() -> context.getSymbolAllocator().newSymbol(\"ordinality\", BIGINT));\n+\n+        UnnestNode rewrittenUnnest = new UnnestNode(\n+                context.getIdAllocator().getNextId(),\n+                input,\n+                input.getOutputSymbols(),\n+                unnestNode.getMappings(),\n+                Optional.of(ordinalitySymbol),\n+                LEFT,\n+                Optional.empty());\n+\n+        // append mask symbol based on ordinality to distinguish between the unnested rows and synthetic null rows\n+        Symbol mask = context.getSymbolAllocator().newSymbol(\"mask\", BOOLEAN);\n+        ProjectNode sourceWithMask = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                rewrittenUnnest,\n+                Assignments.builder()\n+                        .putIdentities(rewrittenUnnest.getOutputSymbols())\n+                        .put(mask, new IsNotNullPredicate(ordinalitySymbol.toSymbolReference()))\n+                        .build());\n+\n+        // restore all projections, grouped aggregations and global aggregations from the subquery\n+        PlanNode result = rewriteNodeSequence(\n+                context.getLookup().resolve(correlatedJoinNode.getSubquery()),\n+                input.getOutputSymbols(),\n+                mask,\n+                sourceWithMask,\n+                reducingAggregation.getId(),\n+                unnestNode.getId(),\n+                context.getSymbolAllocator(),\n+                context.getIdAllocator(),\n+                context.getLookup());\n+\n+        // restrict outputs\n+        return Result.ofPlanNode(restrictOutputs(context.getIdAllocator(), result, ImmutableSet.copyOf(correlatedJoinNode.getOutputSymbols())).orElse(result));\n+    }\n+\n+    private static boolean isGlobalAggregation(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                ((AggregationNode) node).hasEmptyGroupingSet() &&\n+                ((AggregationNode) node).getGroupingSetCount() == 1 &&\n+                ((AggregationNode) node).getStep() == SINGLE;\n+    }\n+\n+    private static boolean isGroupedAggregation(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                !((AggregationNode) node).hasEmptyGroupingSet() &&\n+                ((AggregationNode) node).getGroupingSetCount() == 1 &&\n+                ((AggregationNode) node).getStep() == SINGLE;\n+    }\n+\n+    private static boolean isCorrelatedUnnest(PlanNode node, List<Symbol> correlation, Lookup lookup)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4OTI2MA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r561189260", "bodyText": "nit: extract (AggregationNode) node as a variable (I know it will make method a bit longer.", "author": "losipiuk", "createdAt": "2021-01-20T18:38:50Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/TransformCorrelatedUnnestToLeftUnnest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class TransformCorrelatedUnnestToLeftUnnest\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(TransformCorrelatedUnnestToLeftUnnest::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // if there are multiple global aggregations, the one that is closest to the source is the \"reducing\" aggregation, because it reduces multiple input rows to single output row\n+        AggregationNode reducingAggregation = (AggregationNode) globalAggregations.get(globalAggregations.size() - 1);\n+\n+        // find unnest in subquery\n+        Optional<PlanNode> subqueryUnnest = PlanNodeSearcher.searchFrom(reducingAggregation.getSource(), context.getLookup())\n+                .where(node -> isCorrelatedUnnest(node, correlatedJoinNode.getCorrelation(), context.getLookup()))\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGroupedAggregation(node))\n+                .findFirst();\n+\n+        if (subqueryUnnest.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        UnnestNode unnestNode = (UnnestNode) subqueryUnnest.get();\n+\n+        // assign unique id on input rows to restore semantics of aggregations after rewrite\n+        PlanNode input = new AssignUniqueId(\n+                context.getIdAllocator().getNextId(),\n+                correlatedJoinNode.getInput(),\n+                context.getSymbolAllocator().newSymbol(\"unique\", BIGINT));\n+\n+        // pre-project unnest symbols if they were pre-projected in subquery\n+        if (!ImmutableSet.copyOf(correlatedJoinNode.getCorrelation()).containsAll(unnestNode.getMappings().stream()\n+                .map(Mapping::getInput)\n+                .collect(toImmutableList()))) {\n+            ProjectNode unnestSource = (ProjectNode) context.getLookup().resolve(unnestNode.getSource());\n+            input = new ProjectNode(\n+                    unnestSource.getId(),\n+                    input,\n+                    Assignments.builder()\n+                            .putIdentities(input.getOutputSymbols())\n+                            .putAll(unnestSource.getAssignments())\n+                            .build());\n+        }\n+\n+        // rewrite correlated join to UnnestNode\n+        Symbol ordinalitySymbol = unnestNode.getOrdinalitySymbol().orElseGet(() -> context.getSymbolAllocator().newSymbol(\"ordinality\", BIGINT));\n+\n+        UnnestNode rewrittenUnnest = new UnnestNode(\n+                context.getIdAllocator().getNextId(),\n+                input,\n+                input.getOutputSymbols(),\n+                unnestNode.getMappings(),\n+                Optional.of(ordinalitySymbol),\n+                LEFT,\n+                Optional.empty());\n+\n+        // append mask symbol based on ordinality to distinguish between the unnested rows and synthetic null rows\n+        Symbol mask = context.getSymbolAllocator().newSymbol(\"mask\", BOOLEAN);\n+        ProjectNode sourceWithMask = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                rewrittenUnnest,\n+                Assignments.builder()\n+                        .putIdentities(rewrittenUnnest.getOutputSymbols())\n+                        .put(mask, new IsNotNullPredicate(ordinalitySymbol.toSymbolReference()))\n+                        .build());\n+\n+        // restore all projections, grouped aggregations and global aggregations from the subquery\n+        PlanNode result = rewriteNodeSequence(\n+                context.getLookup().resolve(correlatedJoinNode.getSubquery()),\n+                input.getOutputSymbols(),\n+                mask,\n+                sourceWithMask,\n+                reducingAggregation.getId(),\n+                unnestNode.getId(),\n+                context.getSymbolAllocator(),\n+                context.getIdAllocator(),\n+                context.getLookup());\n+\n+        // restrict outputs\n+        return Result.ofPlanNode(restrictOutputs(context.getIdAllocator(), result, ImmutableSet.copyOf(correlatedJoinNode.getOutputSymbols())).orElse(result));\n+    }\n+\n+    private static boolean isGlobalAggregation(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                ((AggregationNode) node).hasEmptyGroupingSet() &&", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4OTQzNA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r561189434", "bodyText": "Is it the same as hasNonEmptyGroupingSet()?", "author": "losipiuk", "createdAt": "2021-01-20T18:39:07Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/TransformCorrelatedUnnestToLeftUnnest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class TransformCorrelatedUnnestToLeftUnnest\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(TransformCorrelatedUnnestToLeftUnnest::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // if there are multiple global aggregations, the one that is closest to the source is the \"reducing\" aggregation, because it reduces multiple input rows to single output row\n+        AggregationNode reducingAggregation = (AggregationNode) globalAggregations.get(globalAggregations.size() - 1);\n+\n+        // find unnest in subquery\n+        Optional<PlanNode> subqueryUnnest = PlanNodeSearcher.searchFrom(reducingAggregation.getSource(), context.getLookup())\n+                .where(node -> isCorrelatedUnnest(node, correlatedJoinNode.getCorrelation(), context.getLookup()))\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGroupedAggregation(node))\n+                .findFirst();\n+\n+        if (subqueryUnnest.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        UnnestNode unnestNode = (UnnestNode) subqueryUnnest.get();\n+\n+        // assign unique id on input rows to restore semantics of aggregations after rewrite\n+        PlanNode input = new AssignUniqueId(\n+                context.getIdAllocator().getNextId(),\n+                correlatedJoinNode.getInput(),\n+                context.getSymbolAllocator().newSymbol(\"unique\", BIGINT));\n+\n+        // pre-project unnest symbols if they were pre-projected in subquery\n+        if (!ImmutableSet.copyOf(correlatedJoinNode.getCorrelation()).containsAll(unnestNode.getMappings().stream()\n+                .map(Mapping::getInput)\n+                .collect(toImmutableList()))) {\n+            ProjectNode unnestSource = (ProjectNode) context.getLookup().resolve(unnestNode.getSource());\n+            input = new ProjectNode(\n+                    unnestSource.getId(),\n+                    input,\n+                    Assignments.builder()\n+                            .putIdentities(input.getOutputSymbols())\n+                            .putAll(unnestSource.getAssignments())\n+                            .build());\n+        }\n+\n+        // rewrite correlated join to UnnestNode\n+        Symbol ordinalitySymbol = unnestNode.getOrdinalitySymbol().orElseGet(() -> context.getSymbolAllocator().newSymbol(\"ordinality\", BIGINT));\n+\n+        UnnestNode rewrittenUnnest = new UnnestNode(\n+                context.getIdAllocator().getNextId(),\n+                input,\n+                input.getOutputSymbols(),\n+                unnestNode.getMappings(),\n+                Optional.of(ordinalitySymbol),\n+                LEFT,\n+                Optional.empty());\n+\n+        // append mask symbol based on ordinality to distinguish between the unnested rows and synthetic null rows\n+        Symbol mask = context.getSymbolAllocator().newSymbol(\"mask\", BOOLEAN);\n+        ProjectNode sourceWithMask = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                rewrittenUnnest,\n+                Assignments.builder()\n+                        .putIdentities(rewrittenUnnest.getOutputSymbols())\n+                        .put(mask, new IsNotNullPredicate(ordinalitySymbol.toSymbolReference()))\n+                        .build());\n+\n+        // restore all projections, grouped aggregations and global aggregations from the subquery\n+        PlanNode result = rewriteNodeSequence(\n+                context.getLookup().resolve(correlatedJoinNode.getSubquery()),\n+                input.getOutputSymbols(),\n+                mask,\n+                sourceWithMask,\n+                reducingAggregation.getId(),\n+                unnestNode.getId(),\n+                context.getSymbolAllocator(),\n+                context.getIdAllocator(),\n+                context.getLookup());\n+\n+        // restrict outputs\n+        return Result.ofPlanNode(restrictOutputs(context.getIdAllocator(), result, ImmutableSet.copyOf(correlatedJoinNode.getOutputSymbols())).orElse(result));\n+    }\n+\n+    private static boolean isGlobalAggregation(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                ((AggregationNode) node).hasEmptyGroupingSet() &&\n+                ((AggregationNode) node).getGroupingSetCount() == 1 &&\n+                ((AggregationNode) node).getStep() == SINGLE;\n+    }\n+\n+    private static boolean isGroupedAggregation(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                !((AggregationNode) node).hasEmptyGroupingSet() &&", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5NTgzOA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r561195838", "bodyText": "nit: optionalUnnestNode", "author": "losipiuk", "createdAt": "2021-01-20T18:49:11Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/TransformCorrelatedUnnestToLeftUnnest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class TransformCorrelatedUnnestToLeftUnnest\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(TransformCorrelatedUnnestToLeftUnnest::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // if there are multiple global aggregations, the one that is closest to the source is the \"reducing\" aggregation, because it reduces multiple input rows to single output row\n+        AggregationNode reducingAggregation = (AggregationNode) globalAggregations.get(globalAggregations.size() - 1);\n+\n+        // find unnest in subquery\n+        Optional<PlanNode> subqueryUnnest = PlanNodeSearcher.searchFrom(reducingAggregation.getSource(), context.getLookup())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5NjI0OQ==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r561196249", "bodyText": "to input rows", "author": "losipiuk", "createdAt": "2021-01-20T18:49:49Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/TransformCorrelatedUnnestToLeftUnnest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class TransformCorrelatedUnnestToLeftUnnest\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(TransformCorrelatedUnnestToLeftUnnest::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // if there are multiple global aggregations, the one that is closest to the source is the \"reducing\" aggregation, because it reduces multiple input rows to single output row\n+        AggregationNode reducingAggregation = (AggregationNode) globalAggregations.get(globalAggregations.size() - 1);\n+\n+        // find unnest in subquery\n+        Optional<PlanNode> subqueryUnnest = PlanNodeSearcher.searchFrom(reducingAggregation.getSource(), context.getLookup())\n+                .where(node -> isCorrelatedUnnest(node, correlatedJoinNode.getCorrelation(), context.getLookup()))\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGroupedAggregation(node))\n+                .findFirst();\n+\n+        if (subqueryUnnest.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        UnnestNode unnestNode = (UnnestNode) subqueryUnnest.get();\n+\n+        // assign unique id on input rows to restore semantics of aggregations after rewrite", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMTEwNA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r561201104", "bodyText": "can we do that unconditionally and assume the unnecessary projection would be prunned afterwards?", "author": "losipiuk", "createdAt": "2021-01-20T18:57:34Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/TransformCorrelatedUnnestToLeftUnnest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class TransformCorrelatedUnnestToLeftUnnest\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(TransformCorrelatedUnnestToLeftUnnest::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // if there are multiple global aggregations, the one that is closest to the source is the \"reducing\" aggregation, because it reduces multiple input rows to single output row\n+        AggregationNode reducingAggregation = (AggregationNode) globalAggregations.get(globalAggregations.size() - 1);\n+\n+        // find unnest in subquery\n+        Optional<PlanNode> subqueryUnnest = PlanNodeSearcher.searchFrom(reducingAggregation.getSource(), context.getLookup())\n+                .where(node -> isCorrelatedUnnest(node, correlatedJoinNode.getCorrelation(), context.getLookup()))\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGroupedAggregation(node))\n+                .findFirst();\n+\n+        if (subqueryUnnest.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        UnnestNode unnestNode = (UnnestNode) subqueryUnnest.get();\n+\n+        // assign unique id on input rows to restore semantics of aggregations after rewrite\n+        PlanNode input = new AssignUniqueId(\n+                context.getIdAllocator().getNextId(),\n+                correlatedJoinNode.getInput(),\n+                context.getSymbolAllocator().newSymbol(\"unique\", BIGINT));\n+\n+        // pre-project unnest symbols if they were pre-projected in subquery\n+        if (!ImmutableSet.copyOf(correlatedJoinNode.getCorrelation()).containsAll(unnestNode.getMappings().stream()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzMxNTgzNQ==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r563315835", "bodyText": "Not quite. It is supposed to copy a projection that provides input for UnnestNode. So we cannot do it unconditionally, but need to check if there is a  projection below UnnestNode or not.\nHowever, the condition can be simplified to checking if there is a projection (currently it checks if the projection is necessary for the UnnestNode). It will make the code clearer, and if we plan an unnecessary projection, it should be pruned afterwards.", "author": "kasiafi", "createdAt": "2021-01-24T16:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTIwMTEwNA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzg5ODg2OA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r563898868", "bodyText": "There are no guarantees about the order of nodes returned by PlanNodeSearcher", "author": "martint", "createdAt": "2021-01-25T17:18:54Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/DecorrelateInnerUnnestWithGlobalAggregation.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class DecorrelateInnerUnnestWithGlobalAggregation\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(DecorrelateInnerUnnestWithGlobalAggregation::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // if there are multiple global aggregations, the one that is closest to the source is the \"reducing\" aggregation, because it reduces multiple input rows to single output row\n+        AggregationNode reducingAggregation = (AggregationNode) globalAggregations.get(globalAggregations.size() - 1);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQ2MjcyNw==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r567462727", "bodyText": "The order is deterministic. PlanNodeSearcher is not documented, but it seems an intuitive expectation to me that findAll() should return nodes in order.", "author": "kasiafi", "createdAt": "2021-01-31T18:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzg5ODg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDIzMjgzMQ==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r580232831", "bodyText": "@kasiafi I am fine with assuming ordering, but can you please add a comment (and preferably test) for PlanNodeSearcher.searchFrom to document semantics.\nCan be (or even preferably) in another PR.", "author": "losipiuk", "createdAt": "2021-02-22T13:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzg5ODg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjI2MTg3Ng==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r582261876", "bodyText": "@losipiuk I added a comment + test in #7024", "author": "kasiafi", "createdAt": "2021-02-24T20:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzg5ODg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkwMTc5NA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r563901794", "bodyText": "What if there are multiple UNNESTs?", "author": "martint", "createdAt": "2021-01-25T17:22:48Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/DecorrelateInnerUnnestWithGlobalAggregation.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class DecorrelateInnerUnnestWithGlobalAggregation\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(DecorrelateInnerUnnestWithGlobalAggregation::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // if there are multiple global aggregations, the one that is closest to the source is the \"reducing\" aggregation, because it reduces multiple input rows to single output row\n+        AggregationNode reducingAggregation = (AggregationNode) globalAggregations.get(globalAggregations.size() - 1);\n+\n+        // find unnest in subquery\n+        Optional<UnnestNode> subqueryUnnest = PlanNodeSearcher.searchFrom(reducingAggregation.getSource(), context.getLookup())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQ2Mjc0NA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r567462744", "bodyText": "The search condition is written such that a single UNNEST is supported. Probably it could be extended to support multi-level (nested) unnesting. That could be a follow-up if we find we really need it.\nI haven't thought about it in depth, but it seems that we'd have to capture ordinality symbol from the outermost (last) UNNEST and use it analogically to how ordinality of the only UNNEST is used in this rule.", "author": "kasiafi", "createdAt": "2021-01-31T18:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkwMTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk0MTQ3OQ==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r563941479", "bodyText": "Add tests with multiple unnest (e.g., FROM UNNEST(a), UNNEST(b), and tests with correlations at multiple levels (i.e., two or more levels of nesting)", "author": "martint", "createdAt": "2021-01-25T18:18:36Z", "path": "core/trino-main/src/test/java/io/trino/sql/query/TestSubqueries.java", "diffHunk": "@@ -597,4 +597,110 @@ public void testCorrelatedJoin()\n \n         assertions.assertQueryReturnsEmptyResult(\"SELECT * FROM (SELECT 1 where 0 = 1) t(a) LEFT JOIN LATERAL (SELECT 2 WHERE a = 1 ) t2(b) ON TRUE\");\n     }\n+\n+    @Test\n+    public void testCorrelatedUnnest()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzQ2Mjc2NA==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r567462764", "bodyText": "FROM UNNEST(a), UNNEST(b)\n\nIn the subquery? No, that's not supported. This rule supports single correlated UNNEST. The mechanism of this rule is that it identifies a correlated subquery based on UNNEST, and \"plants\" the subquery (with all necessary modifications) on top of CorrelatedJoin's input. If we tried it with two UNNESTs, we'd have to duplicate the CorrelatedJoin's input plan, decorrelate UNNESTs and join.\n\ntests with correlations at multiple levels (i.e., two or more levels of nesting)\n\nThere are tests like\n\"SELECT (SELECT max(count) FROM (SELECT count(v) AS count FROM UNNEST(id, val) u(i, v) GROUP BY i)) \"\nwhere correlation comes from a further outer scope.\nI'll try to add some example where the innermost subquery is resolved and it enables decorrelation on another level.", "author": "kasiafi", "createdAt": "2021-01-31T18:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk0MTQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjIxMjI3Nw==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r576212277", "bodyText": "I added a test with two levels of decorrelation.", "author": "kasiafi", "createdAt": "2021-02-15T14:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk0MTQ3OQ=="}], "type": "inlineReview"}, {"oid": "63a2cca42e466d438e09b47ae2b4d41f9400fe32", "url": "https://github.com/trinodb/trino/commit/63a2cca42e466d438e09b47ae2b4d41f9400fe32", "message": "Verify that grouping set count is positive", "committedDate": "2021-02-15T13:27:37Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDI0ODY4Nw==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r580248687", "bodyText": "If we have unique assigned for a, c1, c2 we do not have to put those in set of grouping columns. Just unique would be enough. Right?\nNot sure if this is any harm though?\nDo you know if for execution-wise one is better than the other?", "author": "losipiuk", "createdAt": "2021-02-22T13:28:38Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/DecorrelateInnerUnnestWithGlobalAggregation.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDMxMzk1OQ==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r580313959", "bodyText": "Oh - never mind. This comment does not make sense. If they were not part of grouping set we would have to wrap them into arbitrary aggregation. Keep it.", "author": "losipiuk", "createdAt": "2021-02-22T14:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDI0ODY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDI1NDY3NQ==", "url": "https://github.com/trinodb/trino/pull/6326#discussion_r580254675", "bodyText": "nit: extract ImmutableSet.copyOf(correlation) as variable", "author": "losipiuk", "createdAt": "2021-02-22T13:37:51Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/DecorrelateInnerUnnestWithGlobalAggregation.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Streams;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.sql.planner.PlanNodeIdAllocator;\n+import io.trino.sql.planner.Symbol;\n+import io.trino.sql.planner.SymbolAllocator;\n+import io.trino.sql.planner.SymbolsExtractor;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.optimizations.PlanNodeSearcher;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.AssignUniqueId;\n+import io.trino.sql.planner.plan.Assignments;\n+import io.trino.sql.planner.plan.CorrelatedJoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanNodeId;\n+import io.trino.sql.planner.plan.ProjectNode;\n+import io.trino.sql.planner.plan.UnnestNode;\n+import io.trino.sql.planner.plan.UnnestNode.Mapping;\n+import io.trino.sql.tree.Expression;\n+import io.trino.sql.tree.IsNotNullPredicate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.trino.matching.Pattern.nonEmpty;\n+import static io.trino.spi.type.BigintType.BIGINT;\n+import static io.trino.spi.type.BooleanType.BOOLEAN;\n+import static io.trino.sql.ExpressionUtils.and;\n+import static io.trino.sql.planner.iterative.rule.AggregationDecorrelation.rewriteWithMasks;\n+import static io.trino.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.trino.sql.planner.optimizations.QueryCardinalityUtil.isScalar;\n+import static io.trino.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.trino.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.trino.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.trino.sql.planner.plan.JoinNode.Type.LEFT;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.correlation;\n+import static io.trino.sql.planner.plan.Patterns.CorrelatedJoin.filter;\n+import static io.trino.sql.planner.plan.Patterns.correlatedJoin;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * This rule finds correlated UnnestNode in CorrelatedJoinNode's subquery and folds\n+ * them into UnnestNode representing LEFT JOIN UNNEST.\n+ * This rule transforms plans, where:\n+ * - UnnestNode in subquery is based only on correlation symbols\n+ * - UnnestNode in subquery is INNER without filter\n+ * - subquery contains global aggregation over the result of unnest\n+ * Additionally, other global aggregations, grouped aggregations and projections\n+ * in subquery are supported.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - CorrelatedJoin (LEFT or INNER) on true, correlation(c1, c2)\n+ *      - Input (a, c1, c2)\n+ *      - Aggregation\n+ *           global grouping\n+ *           agg <- agg1(x)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g)\n+ *                     y <- agg2(u)\n+ *                     - Unnest INNER\n+ *                          g <- unnest(c1)\n+ *                          u <- unnest(c2)\n+ *                          replicate: ()\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Projection (restrict outputs)\n+ *      - Aggregation\n+ *           group by (a, c1, c2, unique)\n+ *           agg <- agg1(x) mask(mask_symbol)\n+ *           - Projection\n+ *                x <- foo(y)\n+ *                - Aggregation\n+ *                     group by (g, a, c1, c2, unique, mask_symbol)\n+ *                     y <- agg2(u)\n+ *                     - Projection\n+ *                          mask_symbol <- ordinality IS NOT NULL\n+ *                          - Unnest LEFT with ordinality\n+ *                               g <- unnest(c1)\n+ *                               u <- unnest(c2)\n+ *                               replicate: (a, c1, c2, unique)\n+ *                               - AssignUniqueId unique\n+ *                                    - Input (a, c1, c2)\n+ * </pre>\n+ */\n+public class DecorrelateInnerUnnestWithGlobalAggregation\n+        implements Rule<CorrelatedJoinNode>\n+{\n+    private static final Pattern<CorrelatedJoinNode> PATTERN = correlatedJoin()\n+            .with(nonEmpty(correlation()))\n+            .with(filter().equalTo(TRUE_LITERAL))\n+            .matching(node -> node.getType() == CorrelatedJoinNode.Type.INNER || node.getType() == CorrelatedJoinNode.Type.LEFT);\n+\n+    @Override\n+    public Pattern<CorrelatedJoinNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(CorrelatedJoinNode correlatedJoinNode, Captures captures, Context context)\n+    {\n+        // find global aggregation in subquery\n+        List<PlanNode> globalAggregations = PlanNodeSearcher.searchFrom(correlatedJoinNode.getSubquery(), context.getLookup())\n+                .where(DecorrelateInnerUnnestWithGlobalAggregation::isGlobalAggregation)\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGlobalAggregation(node))\n+                .findAll();\n+\n+        if (globalAggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // if there are multiple global aggregations, the one that is closest to the source is the \"reducing\" aggregation, because it reduces multiple input rows to single output row\n+        AggregationNode reducingAggregation = (AggregationNode) globalAggregations.get(globalAggregations.size() - 1);\n+\n+        // find unnest in subquery\n+        Optional<UnnestNode> subqueryUnnest = PlanNodeSearcher.searchFrom(reducingAggregation.getSource(), context.getLookup())\n+                .where(node -> isSupportedUnnest(node, correlatedJoinNode.getCorrelation(), context.getLookup()))\n+                .recurseOnlyWhen(node -> node instanceof ProjectNode || isGroupedAggregation(node))\n+                .findFirst();\n+\n+        if (subqueryUnnest.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        UnnestNode unnestNode = subqueryUnnest.get();\n+\n+        // assign unique id to input rows to restore semantics of aggregations after rewrite\n+        PlanNode input = new AssignUniqueId(\n+                context.getIdAllocator().getNextId(),\n+                correlatedJoinNode.getInput(),\n+                context.getSymbolAllocator().newSymbol(\"unique\", BIGINT));\n+\n+        // pre-project unnest symbols if they were pre-projected in subquery\n+        // The correlated UnnestNode either unnests correlation symbols directly, or unnests symbols produced by a projection that uses only correlation symbols.\n+        // Here, any underlying projection that was a source of the correlated UnnestNode, is appended as a source of the rewritten UnnestNode.\n+        // If the projection is not necessary for UnnestNode (i.e. it does not produce any unnest symbols), it should be pruned afterwards.\n+        PlanNode unnestSource = context.getLookup().resolve(unnestNode.getSource());\n+        if (unnestSource instanceof ProjectNode) {\n+            ProjectNode sourceProjection = (ProjectNode) unnestSource;\n+            input = new ProjectNode(\n+                    sourceProjection.getId(),\n+                    input,\n+                    Assignments.builder()\n+                            .putIdentities(input.getOutputSymbols())\n+                            .putAll(sourceProjection.getAssignments())\n+                            .build());\n+        }\n+\n+        // rewrite correlated join to UnnestNode\n+        Symbol ordinalitySymbol = unnestNode.getOrdinalitySymbol().orElseGet(() -> context.getSymbolAllocator().newSymbol(\"ordinality\", BIGINT));\n+\n+        UnnestNode rewrittenUnnest = new UnnestNode(\n+                context.getIdAllocator().getNextId(),\n+                input,\n+                input.getOutputSymbols(),\n+                unnestNode.getMappings(),\n+                Optional.of(ordinalitySymbol),\n+                LEFT,\n+                Optional.empty());\n+\n+        // append mask symbol based on ordinality to distinguish between the unnested rows and synthetic null rows\n+        Symbol mask = context.getSymbolAllocator().newSymbol(\"mask\", BOOLEAN);\n+        ProjectNode sourceWithMask = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                rewrittenUnnest,\n+                Assignments.builder()\n+                        .putIdentities(rewrittenUnnest.getOutputSymbols())\n+                        .put(mask, new IsNotNullPredicate(ordinalitySymbol.toSymbolReference()))\n+                        .build());\n+\n+        // restore all projections, grouped aggregations and global aggregations from the subquery\n+        PlanNode result = rewriteNodeSequence(\n+                context.getLookup().resolve(correlatedJoinNode.getSubquery()),\n+                input.getOutputSymbols(),\n+                mask,\n+                sourceWithMask,\n+                reducingAggregation.getId(),\n+                unnestNode.getId(),\n+                context.getSymbolAllocator(),\n+                context.getIdAllocator(),\n+                context.getLookup());\n+\n+        // restrict outputs\n+        return Result.ofPlanNode(restrictOutputs(context.getIdAllocator(), result, ImmutableSet.copyOf(correlatedJoinNode.getOutputSymbols())).orElse(result));\n+    }\n+\n+    private static boolean isGlobalAggregation(PlanNode node)\n+    {\n+        if (!(node instanceof AggregationNode)) {\n+            return false;\n+        }\n+\n+        AggregationNode aggregationNode = (AggregationNode) node;\n+        return aggregationNode.hasEmptyGroupingSet() &&\n+                aggregationNode.getGroupingSetCount() == 1 &&\n+                aggregationNode.getStep() == SINGLE;\n+    }\n+\n+    private static boolean isGroupedAggregation(PlanNode node)\n+    {\n+        if (!(node instanceof AggregationNode)) {\n+            return false;\n+        }\n+\n+        AggregationNode aggregationNode = (AggregationNode) node;\n+        return aggregationNode.hasNonEmptyGroupingSet() &&\n+                aggregationNode.getGroupingSetCount() == 1 &&\n+                aggregationNode.getStep() == SINGLE;\n+    }\n+\n+    /**\n+     * This rule supports decorrelation of UnnestNode meeting certain conditions:\n+     * - the UnnestNode should be based on correlation symbols, that is: either unnest correlation symbols directly,\n+     * or unnest symbols produced by a projection that uses only correlation symbols.\n+     * - the UnnestNode should not have any replicate symbols,\n+     * - the UnnestNode should be of type INNER,\n+     * - the UnnestNode should not have a filter.\n+     */\n+    private static boolean isSupportedUnnest(PlanNode node, List<Symbol> correlation, Lookup lookup)\n+    {\n+        if (!(node instanceof UnnestNode)) {\n+            return false;\n+        }\n+\n+        UnnestNode unnestNode = (UnnestNode) node;\n+        List<Symbol> unnestSymbols = unnestNode.getMappings().stream()\n+                .map(Mapping::getInput)\n+                .collect(toImmutableList());\n+        PlanNode unnestSource = lookup.resolve(unnestNode.getSource());\n+        boolean basedOnCorrelation = ImmutableSet.copyOf(correlation).containsAll(unnestSymbols) ||", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "98a3ecfbf2a1595bc85aba69eab6d0b6e916e7f7", "url": "https://github.com/trinodb/trino/commit/98a3ecfbf2a1595bc85aba69eab6d0b6e916e7f7", "message": "Decorrelate subqueries with inner UNNEST and global aggregation", "committedDate": "2021-02-22T15:30:08Z", "type": "commit"}, {"oid": "98a3ecfbf2a1595bc85aba69eab6d0b6e916e7f7", "url": "https://github.com/trinodb/trino/commit/98a3ecfbf2a1595bc85aba69eab6d0b6e916e7f7", "message": "Decorrelate subqueries with inner UNNEST and global aggregation", "committedDate": "2021-02-22T15:30:08Z", "type": "forcePushed"}]}