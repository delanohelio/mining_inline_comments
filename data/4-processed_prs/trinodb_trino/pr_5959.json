{"pr_number": 5959, "pr_title": "Add rules for decorrelation of aggregations", "pr_createdAt": "2020-11-13T22:33:17Z", "pr_url": "https://github.com/trinodb/trino/pull/5959", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2MzM2Mw==", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r526363363", "bodyText": "The method name is not very clear. What does \"join sources\" refer to, and what is a \"helper\" symbol?", "author": "martint", "createdAt": "2020-11-18T19:29:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedAggregationToJoin.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.metadata.FunctionId;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator.DecorrelatedNode;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.Aggregation;\n+import io.prestosql.sql.planner.plan.AssignUniqueId;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.CorrelatedJoinNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.QualifiedName;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.sql.analyzer.TypeSignatureProvider.fromTypes;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class TransformCorrelatedAggregationToJoin\n+{\n+    private final Metadata metadata;\n+\n+    public TransformCorrelatedAggregationToJoin(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new TransformCorrelatedGlobalAggregationWithProjection(metadata),\n+                new TransformCorrelatedGlobalAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithoutProjection(metadata));\n+    }\n+\n+    public static boolean isDistinctOperator(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                ((AggregationNode) node).getAggregations().isEmpty() &&\n+                ((AggregationNode) node).getGroupingSetCount() == 1 &&\n+                ((AggregationNode) node).hasNonEmptyGroupingSet();\n+    }\n+\n+    public static Optional<JoinNode> joinSourcesWithHelperSymbols(CorrelatedJoinNode correlatedJoinNode, PlanNode rightSource, JoinNode.Type joinType, Optional<Symbol> nonNull, Context context, Metadata metadata)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2NjAyOA==", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r526366028", "bodyText": "Since this method takes \"rightSource\" (which, btw, would be more accurate to call \"nested plan\"), passing CorrelatedJoinNode is confusing and error prone. It allows, or appears to allow, passing a rightSource that's unrelated to the correlationJoinNode argument.\nInstead, pass the input, nested plan and correlations as separate arguments.", "author": "martint", "createdAt": "2020-11-18T19:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2MzM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2Nzc0MA==", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r526367740", "bodyText": "The fact that this is only relevant for LEFT join (even though this method can take different joinTypes), makes me think this method is doing to much and modeling a union of overlapping behaviors. I think it would be cleaner to either:\n\npartially inline this method in the callers\nhave dedicated variants for the different use cases it handles\n\nI'll try out a couple of options.", "author": "martint", "createdAt": "2020-11-18T19:36:55Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformCorrelatedAggregationToJoin.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.metadata.FunctionId;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator;\n+import io.prestosql.sql.planner.optimizations.PlanNodeDecorrelator.DecorrelatedNode;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.Aggregation;\n+import io.prestosql.sql.planner.plan.AssignUniqueId;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.CorrelatedJoinNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.QualifiedName;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.sql.analyzer.TypeSignatureProvider.fromTypes;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class TransformCorrelatedAggregationToJoin\n+{\n+    private final Metadata metadata;\n+\n+    public TransformCorrelatedAggregationToJoin(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new TransformCorrelatedGlobalAggregationWithProjection(metadata),\n+                new TransformCorrelatedGlobalAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithProjection(metadata),\n+                new TransformCorrelatedDistinctAggregationWithoutProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithProjection(metadata),\n+                new TransformCorrelatedGroupedAggregationWithoutProjection(metadata));\n+    }\n+\n+    public static boolean isDistinctOperator(PlanNode node)\n+    {\n+        return node instanceof AggregationNode &&\n+                ((AggregationNode) node).getAggregations().isEmpty() &&\n+                ((AggregationNode) node).getGroupingSetCount() == 1 &&\n+                ((AggregationNode) node).hasNonEmptyGroupingSet();\n+    }\n+\n+    public static Optional<JoinNode> joinSourcesWithHelperSymbols(CorrelatedJoinNode correlatedJoinNode, PlanNode rightSource, JoinNode.Type joinType, Optional<Symbol> nonNull, Context context, Metadata metadata)\n+    {\n+        // decorrelate source\n+        PlanNodeDecorrelator decorrelator = new PlanNodeDecorrelator(metadata, context.getSymbolAllocator(), context.getLookup());\n+        Optional<DecorrelatedNode> decorrelatedSource = decorrelator.decorrelateFilters(rightSource, correlatedJoinNode.getCorrelation());\n+        if (decorrelatedSource.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        PlanNode source = decorrelatedSource.get().getNode();\n+\n+        // append non-null symbol on source. It will be used to restore semantics of count(*) aggregations after LEFT join\n+        if (nonNull.isPresent()) {\n+            source = new ProjectNode(\n+                    context.getIdAllocator().getNextId(),\n+                    source,\n+                    Assignments.builder()\n+                            .putIdentities(source.getOutputSymbols())\n+                            .put(nonNull.get(), TRUE_LITERAL)\n+                            .build());\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQzNTgyOA==", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r526435828", "bodyText": "Indeed, at least for TransformCorrelatedDistinctAggregationWithoutProjection, it's a lot clearer what's going on if you inline this method and the calls to appendAggregations. They seem like unnecessary abstractions that don't add much value.", "author": "martint", "createdAt": "2020-11-18T21:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2Nzc0MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1ODE1Mw==", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r528958153", "bodyText": "Add some tests involving ORDER BY within aggregations and FILTER (WHERE ...)", "author": "martint", "createdAt": "2020-11-23T19:52:51Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestCorrelatedAggregation.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestCorrelatedAggregation", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1ODE4OQ==", "url": "https://github.com/trinodb/trino/pull/5959#discussion_r528958189", "bodyText": "Use lower-case for table names. T -> t", "author": "martint", "createdAt": "2020-11-23T19:52:54Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestCorrelatedAggregation.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.query;\n+\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class TestCorrelatedAggregation\n+{\n+    protected QueryAssertions assertions;\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        assertions = new QueryAssertions();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void teardown()\n+    {\n+        assertions.close();\n+        assertions = null;\n+    }\n+\n+    @Test\n+    public void testGlobalDistinctAggregation()\n+    {\n+        assertThat(assertions.query(\"SELECT * FROM \" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "b07d4698f1ac97695f4332085effcf61a26f5674", "url": "https://github.com/trinodb/trino/commit/b07d4698f1ac97695f4332085effcf61a26f5674", "message": "Verify that grouping keys are not correlated\n\nFor an Aggregation in correlated subquery, the Analyzer requires\nthat all grouping keys come from the local scope.\nAlso, PlanNodeDecorrelator does not attempt to decorrelate grouping\nkeys but uses those from the original node in the decorrelated node.\nThis change adds a check that the original grouping keys cannot\nbe decorrelated.", "committedDate": "2020-12-01T08:17:04Z", "type": "commit"}, {"oid": "5508789eec374f3ad483ee846c3e403cc1e1b2c0", "url": "https://github.com/trinodb/trino/commit/5508789eec374f3ad483ee846c3e403cc1e1b2c0", "message": "Add comment explaining decorrelation of AggregationNode", "committedDate": "2020-12-01T08:17:04Z", "type": "commit"}, {"oid": "c0a3b718227b6aa54f0b272bea565118529873d6", "url": "https://github.com/trinodb/trino/commit/c0a3b718227b6aa54f0b272bea565118529873d6", "message": "Support multiple filter to mask rewrites for aggregation\n\nThis change enables rewriting Aggregation's filter to mask\nin case when mask is already present.\nIt allows to add filter during optimization to an Aggregation\nthat had FILTER. It helps avoid dependencies between rules.\n\nAlso, after this change, unnecessary projection isn't added to the plan.\nBefore, every filter symbol was projected to a new mask symbol.\nNow, renaming projections are skipped and a ProjectNode is only added\nwhen there is a need to combine symbols: existing mask and filter.", "committedDate": "2020-12-01T08:17:04Z", "type": "commit"}, {"oid": "0f6443a4b11cae89fe8169c5712c88cad41da729", "url": "https://github.com/trinodb/trino/commit/0f6443a4b11cae89fe8169c5712c88cad41da729", "message": "Support matching filter in AggregationFunctionMatcher", "committedDate": "2020-12-01T08:17:05Z", "type": "commit"}, {"oid": "3408631fb21c5f8440c4eea5aee6d054132f6829", "url": "https://github.com/trinodb/trino/commit/3408631fb21c5f8440c4eea5aee6d054132f6829", "message": "Add rules for decorrelation of aggregations", "committedDate": "2020-12-01T08:17:05Z", "type": "commit"}, {"oid": "3408631fb21c5f8440c4eea5aee6d054132f6829", "url": "https://github.com/trinodb/trino/commit/3408631fb21c5f8440c4eea5aee6d054132f6829", "message": "Add rules for decorrelation of aggregations", "committedDate": "2020-12-01T08:17:05Z", "type": "forcePushed"}]}