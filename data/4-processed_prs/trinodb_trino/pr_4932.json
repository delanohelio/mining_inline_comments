{"pr_number": 4932, "pr_title": "Use predicates on non-partition columns in Iceberg", "pr_createdAt": "2020-08-22T01:35:38Z", "pr_url": "https://github.com/trinodb/trino/pull/4932", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5MzIwMA==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r492393200", "bodyText": "We can also handle the case when icebergTable.specs().values().stream().allMatch(spec -> spec.fields().containsAll(fields)) is false. Currently,\n        if (newDomain.equals(table.getPredicate().intersect(table.getEnforcedPredicate()))) {\n            return Optional.empty();\n        }\n\nEven in this case the pushed predicate can be used in table scans.", "author": "lxynov", "createdAt": "2020-09-21T23:01:33Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -613,7 +613,6 @@ public void rollback()\n     {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkzMjgxMA==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r499932810", "bodyText": "Good point. Thinking more on this, I think there might be a better approach to this. I've updated the PR with this new approach.", "author": "phd3", "createdAt": "2020-10-05T23:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5MzIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5NTQ3OA==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r492395478", "bodyText": "We should also make a change to the function call icebergTableHandle.getPredicate() in TableStatisticsMaker::makeTableStatistics?", "author": "lxynov", "createdAt": "2020-09-21T23:08:29Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergTableHandle.java", "diffHunk": "@@ -90,6 +97,12 @@ public TableType getTableType()\n         return predicate;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MjY0NQ==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r512962645", "bodyText": "This seems wrong to me. Shouldn't we return \"none\" to the engine?", "author": "electrum", "createdAt": "2020-10-27T19:19:19Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergMetadata.java", "diffHunk": "@@ -612,47 +612,45 @@ public void rollback()\n     public Optional<ConstraintApplicationResult<ConnectorTableHandle>> applyFilter(ConnectorSession session, ConnectorTableHandle handle, Constraint constraint)\n     {\n         IcebergTableHandle table = (IcebergTableHandle) handle;\n+        org.apache.iceberg.Table icebergTable = getIcebergTable(metastore, hdfsEnvironment, session, table.getSchemaTableName());\n \n-        // TODO: Remove TupleDomain#simplify once Iceberg supports IN expression\n-        TupleDomain<IcebergColumnHandle> newDomain = constraint.getSummary()\n-                .transform(IcebergColumnHandle.class::cast)\n-                .intersect(table.getPredicate());\n-\n-        if (newDomain.isNone()) {\n-            return Optional.empty();\n-        }\n+        // Extract identity partition column source ids common to ALL specs\n+        Set<Integer> partitionSourceIds = icebergTable.spec().fields().stream()\n+                .filter(field -> field.transform().isIdentity())\n+                .filter(field -> icebergTable.specs().values().stream().allMatch(spec -> spec.fields().contains(field)))\n+                .map(PartitionField::sourceId)\n+                .collect(toImmutableSet());\n \n-        if (newDomain.equals(table.getPredicate())) {\n-            return Optional.empty();\n-        }\n+        BiPredicate<IcebergColumnHandle, Domain> isIdentityPartition = (column, domain) -> partitionSourceIds.contains(column.getId());\n \n-        org.apache.iceberg.Table icebergTable = getIcebergTable(metastore, hdfsEnvironment, session, table.getSchemaTableName());\n+        TupleDomain<IcebergColumnHandle> newEnforcedConstraint = constraint.getSummary()\n+                .transform(IcebergColumnHandle.class::cast)\n+                .filter(isIdentityPartition)\n+                .intersect(table.getEnforcedPredicate());\n \n-        List<PartitionField> fields = icebergTable.spec().fields().stream()\n-                .filter(field -> field.transform().isIdentity())\n-                .collect(toImmutableList());\n+        TupleDomain<IcebergColumnHandle> newUnenforcedConstraint = constraint.getSummary()\n+                .transform(IcebergColumnHandle.class::cast)\n+                .filter(isIdentityPartition.negate())\n+                .intersect(table.getPredicate());\n \n-        // Ensure partition specs in all manifests contain the identity fields from the predicate\n-        if (!icebergTable.specs().values().stream().allMatch(spec -> spec.fields().containsAll(fields))) {\n+        if (newEnforcedConstraint.equals(table.getEnforcedPredicate())\n+                && newUnenforcedConstraint.equals(table.getPredicate())) {\n             return Optional.empty();\n         }\n \n-        Set<Integer> partitionSourceIds = icebergTable.spec().fields().stream()\n-                .filter(field -> field.transform().isIdentity())\n-                .map(PartitionField::sourceId)\n-                .collect(toImmutableSet());\n-\n-        BiPredicate<IcebergColumnHandle, Domain> contains = (column, domain) -> partitionSourceIds.contains(column.getId());\n-        TupleDomain<ColumnHandle> remainingTupleDomain = newDomain.filter(contains.negate()).transform(ColumnHandle.class::cast);\n-        TupleDomain<IcebergColumnHandle> enforcedTupleDomain = newDomain.filter(contains);\n+        if (newEnforcedConstraint.isNone()) {\n+            // If no tuple satisfies the constraint, no need to do additional filtering in the engine\n+            newUnenforcedConstraint = TupleDomain.all();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyODk4Nw==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r516028987", "bodyText": "removed the special condition.", "author": "phd3", "createdAt": "2020-11-02T14:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MjY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MzY0Nw==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r512963647", "bodyText": "Should this move inside toIcebergExpression()?", "author": "electrum", "createdAt": "2020-10-27T19:21:04Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergSplitManager.java", "diffHunk": "@@ -57,7 +57,12 @@ public ConnectorSplitSource getSplits(\n         HiveMetastore metastore = transactionManager.get(transaction).getMetastore();\n         Table icebergTable = getIcebergTable(metastore, hdfsEnvironment, session, table.getSchemaTableName());\n \n-        TableScan tableScan = getTableScan(table.getPredicate(), table.getSnapshotId(), icebergTable);\n+        TableScan tableScan = getTableScan(\n+                // TODO: Remove TupleDomain#simplify once Iceberg supports IN expression\n+                table.getEnforcedPredicate()\n+                        .intersect(table.getPredicate()).simplify(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM3NzQ2OA==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r526377468", "bodyText": "simplify needs to be used cautiously only when required because it can change the predicate.\nFor example, it cannot be used for an \"enforced\" constraint. we may end up returning incorrect results for filters on partition columns for SELECT queries, or deleting undesired partitions in case of metadata delete.", "author": "phd3", "createdAt": "2020-11-18T19:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MzY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2NDg4NA==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r512964884", "bodyText": "This can use orElseThrow()", "author": "electrum", "createdAt": "2020-10-27T19:22:28Z", "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/AbstractTestIcebergSmoke.java", "diffHunk": "@@ -1204,6 +1209,72 @@ public void testStatisticsConstraints()\n         dropTable(tableName);\n     }\n \n+    @Test\n+    public void testPredicatePushdown()\n+    {\n+        QualifiedObjectName tableName = new QualifiedObjectName(\"iceberg\", \"tpch\", \"test_predicate\");\n+        assertUpdate(format(\"CREATE TABLE %s (col1 BIGINT, col2 BIGINT, col3 BIGINT) WITH (partitioning = ARRAY['col2', 'col3'])\", tableName));\n+        assertUpdate(format(\"INSERT INTO %s VALUES (1, 10, 100)\", tableName), 1L);\n+        assertUpdate(format(\"INSERT INTO %s VALUES (2, 20, 200)\", tableName), 1L);\n+\n+        assertFilterPushdown(tableName,\n+                ImmutableMap.of(\"col1\", NullableValue.of(BIGINT, 1L)),\n+                ImmutableMap.of(),\n+                ImmutableMap.of(\"col1\", NullableValue.of(BIGINT, 1L)));\n+\n+        assertFilterPushdown(tableName,\n+                ImmutableMap.of(\"col2\", NullableValue.of(BIGINT, 10L)),\n+                ImmutableMap.of(\"col2\", NullableValue.of(BIGINT, 10L)),\n+                ImmutableMap.of());\n+\n+        assertFilterPushdown(tableName,\n+                ImmutableMap.of(\"col1\", NullableValue.of(BIGINT, 1L), \"col2\", NullableValue.of(BIGINT, 10L)),\n+                ImmutableMap.of(\"col2\", NullableValue.of(BIGINT, 10L)),\n+                ImmutableMap.of(\"col1\", NullableValue.of(BIGINT, 1L)));\n+\n+        dropTable(tableName.getObjectName());\n+    }\n+\n+    private void assertFilterPushdown(\n+            QualifiedObjectName tableName,\n+            Map<String, NullableValue> filter,\n+            Map<String, NullableValue> expectedEnforcedPredicate,\n+            Map<String, NullableValue> expectedPredicate)\n+    {\n+        Metadata metadata = getQueryRunner().getMetadata();\n+\n+        newTransaction().execute(getSession(), session -> {\n+            Optional<TableHandle> table = metadata.getTableHandle(session, tableName);\n+            checkArgument(table.isPresent(), \"Could not create table handle for table %s\", tableName);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwMzQ5Ng==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r529003496", "bodyText": "What are the semantics of IcebergTableHandle.getEnforcedPredicate? Is it guaranteed to be a tight bound?", "author": "martint", "createdAt": "2020-11-23T21:19:49Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergTableHandle.java", "diffHunk": "@@ -79,6 +86,12 @@ public TableType getTableType()\n         return predicate;\n     }\n \n+    @JsonProperty\n+    public TupleDomain<IcebergColumnHandle> getEnforcedPredicate()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAxMzY5Mg==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r529013692", "bodyText": "In particular how do predicate and enforcedPredicate differ from each other. From my reading of the above code, this is just about whether the predicate is over the partition columns vs non-partition columns.\nMaybe it'd make more sense to model it as two complementary sets of predicates (partitionColumnPredicate vs nonPartitionColumnPredicate). It would also make it easier to interpret and understand all the places where they are referenced.", "author": "martint", "createdAt": "2020-11-23T21:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwMzQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4OTAyNg==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r529089026", "bodyText": "@martint enforcedPredicate - predicates that can be enforced by the iceberg connector because they are over identity partition columns that are present in all partition specs. predicates on other columns are put in predicate. They're complementary currently.\nGiven the nuances mentioned above, didn't name them as \"partitionColumnPredicate\" as it's inaccurate.  should we rename predicate as unEnforcedPredicate instead? we can say unEnforcedPredicate are not guaranteed to be enforced, but still being used for split-generation and reader-level optimizations.", "author": "phd3", "createdAt": "2020-11-24T00:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwMzQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTUzNDIwMw==", "url": "https://github.com/trinodb/trino/pull/4932#discussion_r535534203", "bodyText": "Yes, that would be better.", "author": "martint", "createdAt": "2020-12-03T19:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAwMzQ5Ng=="}], "type": "inlineReview"}, {"oid": "6ca382468b2da8bbc500fed75a990e239c87bf6a", "url": "https://github.com/trinodb/trino/commit/6ca382468b2da8bbc500fed75a990e239c87bf6a", "message": "Add test asserting failures for large IN predicates in Iceberg", "committedDate": "2020-12-05T00:38:52Z", "type": "commit"}, {"oid": "7d97e7dcbf86ecbfcbcd096877653c5863df9daf", "url": "https://github.com/trinodb/trino/commit/7d97e7dcbf86ecbfcbcd096877653c5863df9daf", "message": "Use predicates on non-partition columns\n\nWith this change, predicates that cannot be enforced by iceberg\nconnector will still be used during split generation, reducing\nthe number of splits scheduled.\n\nThese predicates will also be used by ORC/Parquet readers for\noptimizing reads.", "committedDate": "2020-12-05T00:38:53Z", "type": "commit"}, {"oid": "66b8a1366a7ac2aa9ea864e371e93377ccb30d89", "url": "https://github.com/trinodb/trino/commit/66b8a1366a7ac2aa9ea864e371e93377ccb30d89", "message": "Fix Iceberg Expression conversion for timestamp with timezone", "committedDate": "2020-12-05T00:38:53Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "b4c6668dbac8e07ab7d7939e5f2e472eea4bcac3", "url": "https://github.com/trinodb/trino/commit/b4c6668dbac8e07ab7d7939e5f2e472eea4bcac3", "message": "Rename predicate to unenforcedPredicate\n\nThe new naming more accurately represents the\nexpected behavior of the variable, and the\ncomplementary relationship with enforcedPredicate.", "committedDate": "2020-12-05T01:20:38Z", "type": "commit"}, {"oid": "b4c6668dbac8e07ab7d7939e5f2e472eea4bcac3", "url": "https://github.com/trinodb/trino/commit/b4c6668dbac8e07ab7d7939e5f2e472eea4bcac3", "message": "Rename predicate to unenforcedPredicate\n\nThe new naming more accurately represents the\nexpected behavior of the variable, and the\ncomplementary relationship with enforcedPredicate.", "committedDate": "2020-12-05T01:20:38Z", "type": "forcePushed"}]}