{"pr_number": 5801, "pr_title": "Refactor ValuesNode", "pr_createdAt": "2020-11-03T19:12:21Z", "pr_url": "https://github.com/trinodb/trino/pull/5801", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUxNjYyNA==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r517516624", "bodyText": "The Optional is unfortunate. Once we split the AST from the IR, we can have an abstraction for tuple types that can have 0 fields -- we can then represent a VALUES that produces rows with no columns as a list of empty tuples.", "author": "martint", "createdAt": "2020-11-04T17:36:38Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/ValuesNode.java", "diffHunk": "@@ -18,33 +18,85 @@\n import com.google.common.collect.ImmutableList;\n import io.prestosql.sql.planner.Symbol;\n import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Row;\n \n import javax.annotation.concurrent.Immutable;\n \n import java.util.List;\n+import java.util.Optional;\n \n import static com.google.common.base.Preconditions.checkArgument;\n-import static io.prestosql.util.MoreLists.listOfListsCopy;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.util.Objects.requireNonNull;\n \n @Immutable\n public class ValuesNode\n         extends PlanNode\n {\n     private final List<Symbol> outputSymbols;\n-    private final List<List<Expression>> rows;\n+    private final int rowCount;\n+    // If ValuesNode produces output symbols, each row in ValuesNode is represented by a single expression in `rows` list.\n+    // It can be an expression of type Row or any other expression that evaluates to RowType.\n+    // In case when output symbols are present but ValuesNode does not have any rows, `rows` is an Optional with empty list.\n+    // If ValuesNode does not produce any output symbols, `rows` is Optional.empty().\n+    private final Optional<List<Expression>> rows;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3MTkwNw==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521671907", "bodyText": "As long as it is List<Expression>, I can see no better way than to wrap it in Optional.\nAt first, I tried to create Row with no fields. Even though it is legal to create, it fails to evaluate.", "author": "kasiafi", "createdAt": "2020-11-11T22:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUxNjYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwNzA3NA==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521707074", "bodyText": "Yes, I know. Not asking for any changes -- just commenting on what would be desirable in the longer term.", "author": "martint", "createdAt": "2020-11-11T23:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUxNjYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzOTAxNA==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521539014", "bodyText": "This shouldn't be necessary. The branch below should be able to handle evaluating a Row expression, just like any other expression.", "author": "martint", "createdAt": "2020-11-11T17:56:45Z", "path": "presto-main/src/main/java/io/prestosql/cost/ValuesStatsRule.java", "diffHunk": "@@ -61,28 +67,42 @@ public ValuesStatsRule(Metadata metadata)\n     public Optional<PlanNodeStatsEstimate> calculate(ValuesNode node, StatsProvider sourceStats, Lookup lookup, Session session, TypeProvider types)\n     {\n         PlanNodeStatsEstimate.Builder statsBuilder = PlanNodeStatsEstimate.builder();\n-        statsBuilder.setOutputRowCount(node.getRows().size());\n+        statsBuilder.setOutputRowCount(node.getRowCount());\n \n         for (int symbolId = 0; symbolId < node.getOutputSymbols().size(); ++symbolId) {\n             Symbol symbol = node.getOutputSymbols().get(symbolId);\n-            List<Object> symbolValues = getSymbolValues(node, symbolId, session, types.get(symbol));\n+            List<Object> symbolValues = getSymbolValues(\n+                    node,\n+                    symbolId,\n+                    session,\n+                    RowType.anonymous(node.getOutputSymbols().stream()\n+                            .map(types::get)\n+                            .collect(toImmutableList())));\n             statsBuilder.addSymbolStatistics(symbol, buildSymbolStatistics(symbolValues, session, types.get(symbol)));\n         }\n \n         return Optional.of(statsBuilder.build());\n     }\n \n-    private List<Object> getSymbolValues(ValuesNode valuesNode, int symbolId, Session session, Type symbolType)\n+    private List<Object> getSymbolValues(ValuesNode valuesNode, int symbolId, Session session, Type rowType)\n     {\n+        Type symbolType = rowType.getTypeParameters().get(symbolId);\n         if (UNKNOWN.equals(symbolType)) {\n             // special casing for UNKNOWN as evaluateConstantExpression does not handle that\n-            return IntStream.range(0, valuesNode.getRows().size())\n+            return IntStream.range(0, valuesNode.getRowCount())\n                     .mapToObj(rowId -> null)\n                     .collect(toList());\n         }\n-        return valuesNode.getRows().stream()\n-                .map(row -> row.get(symbolId))\n-                .map(expression -> evaluateConstantExpression(expression, symbolType, metadata, session, new AllowAllAccessControl(), ImmutableMap.of()))\n+        checkState(valuesNode.getRows().isPresent(), \"rows is empty\");\n+        return valuesNode.getRows().get().stream()\n+                .map(row -> {\n+                    if (row instanceof Row) {\n+                        Expression item = ((Row) row).getItems().get(symbolId);\n+                        return evaluateConstantExpression(item, symbolType, metadata, session, new AllowAllAccessControl(), ImmutableMap.of());\n+                    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0NzU1NQ==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521547555", "bodyText": "This is ok for now, but it should eventually be modeled as a whole-row cast and moved to an optimizer rule. Please add a TODO.", "author": "martint", "createdAt": "2020-11-11T18:11:40Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1858,67 +1859,70 @@ protected Scope visitValues(Values node, Optional<Scope> scope)\n         {\n             checkState(node.getRows().size() >= 1);\n \n-            List<List<Type>> rowTypes = node.getRows().stream()\n+            List<Type> rowTypes = node.getRows().stream()\n                     .map(row -> analyzeExpression(row, createScope(scope)).getType(row))\n                     .map(type -> {\n                         if (type instanceof RowType) {\n-                            return type.getTypeParameters();\n+                            return type;\n                         }\n-                        return ImmutableList.of(type);\n+                        return RowType.anonymousRow(type);\n                     })\n                     .collect(toImmutableList());\n \n-            // determine common super type of the rows\n-            List<Type> fieldTypes = new ArrayList<>(rowTypes.iterator().next());\n-            for (List<Type> rowType : rowTypes) {\n+            int fieldCount = rowTypes.get(0).getTypeParameters().size();\n+            Type commonSuperType = rowTypes.get(0);\n+            for (Type rowType : rowTypes) {\n                 // check field count consistency for rows\n-                if (rowType.size() != fieldTypes.size()) {\n+                if (rowType.getTypeParameters().size() != fieldCount) {\n+                    throw semanticException(TYPE_MISMATCH,\n+                            node,\n+                            \"Values rows have mismatched sizes: %s vs %s\",\n+                            fieldCount,\n+                            rowType.getTypeParameters().size());\n+                }\n+\n+                // determine common super type of the rows\n+                Optional<Type> partialSuperType = typeCoercion.getCommonSuperType(rowType, commonSuperType);\n+                if (partialSuperType.isEmpty()) {\n                     throw semanticException(TYPE_MISMATCH,\n                             node,\n                             \"Values rows have mismatched types: %s vs %s\",\n                             rowTypes.get(0),\n                             rowType);\n                 }\n-\n-                for (int i = 0; i < rowType.size(); i++) {\n-                    Type fieldType = rowType.get(i);\n-                    Type superType = fieldTypes.get(i);\n-\n-                    Optional<Type> commonSuperType = typeCoercion.getCommonSuperType(fieldType, superType);\n-                    if (commonSuperType.isEmpty()) {\n-                        throw semanticException(TYPE_MISMATCH,\n-                                node,\n-                                \"Values rows have mismatched types: %s vs %s\",\n-                                rowTypes.get(0),\n-                                rowType);\n-                    }\n-                    fieldTypes.set(i, commonSuperType.get());\n-                }\n+                commonSuperType = partialSuperType.get();\n             }\n \n-            // add coercions for the rows\n+            // add coercions\n             for (Expression row : node.getRows()) {\n+                Type actualType = analysis.getType(row);\n                 if (row instanceof Row) {\n-                    List<Expression> items = ((Row) row).getItems();\n-                    for (int i = 0; i < items.size(); i++) {\n-                        Type expectedType = fieldTypes.get(i);\n-                        Expression item = items.get(i);\n-                        Type actualType = analysis.getType(item);\n-                        if (!actualType.equals(expectedType)) {\n-                            analysis.addCoercion(item, expectedType, typeCoercion.isTypeOnlyCoercion(actualType, expectedType));\n+                    // coerce Row by fields to preserve Row structure and enable optimizations based on this structure, e.g. pruning, predicate extraction\n+                    for (int i = 0; i < actualType.getTypeParameters().size(); i++) {\n+                        Expression item = ((Row) row).getItems().get(i);\n+                        Type actualItemType = actualType.getTypeParameters().get(i);\n+                        Type expectedItemType = commonSuperType.getTypeParameters().get(i);\n+                        if (!actualItemType.equals(expectedItemType)) {\n+                            analysis.addCoercion(item, expectedItemType, typeCoercion.isTypeOnlyCoercion(actualItemType, expectedItemType));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0OTkwMg==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521549902", "bodyText": "This shouldn't be necessary. The analyzer should be able to analyze Row expressions (and their elements), as well.", "author": "martint", "createdAt": "2020-11-11T18:16:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/EffectivePredicateExtractor.java", "diffHunk": "@@ -336,69 +340,103 @@ public Expression visitValues(ValuesNode node, Void context)\n                 return TRUE_LITERAL;\n             }\n \n-            // get all types in one shot -- needed for the expression optimizer below\n-            List<Expression> allExpressions = node.getRows().stream()\n-                    .flatMap(List::stream)\n-                    .collect(Collectors.toList());\n-\n-            Map<NodeRef<Expression>, Type> expressionTypes = typeAnalyzer.getTypes(session, types, allExpressions);\n-\n-            ImmutableMap.Builder<Symbol, Domain> domains = ImmutableMap.builder();\n-\n-            for (int column = 0; column < node.getOutputSymbols().size(); column++) {\n-                Symbol symbol = node.getOutputSymbols().get(column);\n-                Type type = types.get(symbol);\n+            // for each row of Values, get all expressions that will be evaluated:\n+            // - if the row is of type Row, evaluate fields of the row\n+            // - otherwise evaluate the whole expression and then analyze fields of the resulting row\n+            checkState(node.getRows().isPresent(), \"rows is empty\");\n+            List<Expression> processedExpressions = node.getRows().get().stream()\n+                    .flatMap(row -> {\n+                        if (row instanceof Row) {\n+                            return ((Row) row).getItems().stream();\n+                        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ2NDg4MA==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r523464880", "bodyText": "I wanted to take advantage of analyzing Row items separately in case some of them are non-deterministic and other are deterministic. When analyzing them one by one, we still can build domains for the deterministic columns.", "author": "kasiafi", "createdAt": "2020-11-14T21:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0OTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1NDk5Mw==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521554993", "bodyText": "In theory, the result may be a Row expression with partially constant-folded items. In that case, we want to go through the same treatment as above.", "author": "martint", "createdAt": "2020-11-11T18:25:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/EffectivePredicateExtractor.java", "diffHunk": "@@ -336,69 +340,103 @@ public Expression visitValues(ValuesNode node, Void context)\n                 return TRUE_LITERAL;\n             }\n \n-            // get all types in one shot -- needed for the expression optimizer below\n-            List<Expression> allExpressions = node.getRows().stream()\n-                    .flatMap(List::stream)\n-                    .collect(Collectors.toList());\n-\n-            Map<NodeRef<Expression>, Type> expressionTypes = typeAnalyzer.getTypes(session, types, allExpressions);\n-\n-            ImmutableMap.Builder<Symbol, Domain> domains = ImmutableMap.builder();\n-\n-            for (int column = 0; column < node.getOutputSymbols().size(); column++) {\n-                Symbol symbol = node.getOutputSymbols().get(column);\n-                Type type = types.get(symbol);\n+            // for each row of Values, get all expressions that will be evaluated:\n+            // - if the row is of type Row, evaluate fields of the row\n+            // - otherwise evaluate the whole expression and then analyze fields of the resulting row\n+            checkState(node.getRows().isPresent(), \"rows is empty\");\n+            List<Expression> processedExpressions = node.getRows().get().stream()\n+                    .flatMap(row -> {\n+                        if (row instanceof Row) {\n+                            return ((Row) row).getItems().stream();\n+                        }\n+                        return Stream.of(row);\n+                    })\n+                    .collect(toImmutableList());\n \n-                ImmutableList.Builder<Object> builder = ImmutableList.builder();\n-                boolean hasNull = false;\n-                boolean hasNaN = false;\n-                boolean nonDeterministic = false;\n-                for (int row = 0; row < node.getRows().size(); row++) {\n-                    Expression value = node.getRows().get(row).get(column);\n+            Map<NodeRef<Expression>, Type> expressionTypes = typeAnalyzer.getTypes(session, types, processedExpressions);\n \n-                    if (!DeterminismEvaluator.isDeterministic(value, metadata)) {\n-                        nonDeterministic = true;\n-                        break;\n+            boolean[] hasNull = new boolean[node.getOutputSymbols().size()];\n+            boolean[] hasNaN = new boolean[node.getOutputSymbols().size()];\n+            boolean[] nonDeterministic = new boolean[node.getOutputSymbols().size()];\n+            ImmutableList.Builder<ImmutableList.Builder<Object>> builders = ImmutableList.builder();\n+            for (int i = 0; i < node.getOutputSymbols().size(); i++) {\n+                builders.add(ImmutableList.builder());\n+            }\n+            List<ImmutableList.Builder<Object>> valuesBuilders = builders.build();\n+\n+            for (Expression row : node.getRows().get()) {\n+                if (row instanceof Row) {\n+                    for (int i = 0; i < node.getOutputSymbols().size(); i++) {\n+                        Expression value = ((Row) row).getItems().get(i);\n+                        if (!DeterminismEvaluator.isDeterministic(value, metadata)) {\n+                            nonDeterministic[i] = true;\n+                        }\n+                        else {\n+                            ExpressionInterpreter interpreter = ExpressionInterpreter.expressionOptimizer(value, metadata, session, expressionTypes);\n+                            Object item = interpreter.optimize(NoOpSymbolResolver.INSTANCE);\n+                            if (item instanceof Expression) {\n+                                return TRUE_LITERAL;\n+                            }\n+                            if (item == null) {\n+                                hasNull[i] = true;\n+                            }\n+                            else {\n+                                Type type = types.get(node.getOutputSymbols().get(i));\n+                                if (isFloatingPointNaN(type, item)) {\n+                                    hasNaN[i] = true;\n+                                }\n+                                valuesBuilders.get(i).add(item);\n+                            }\n+                        }\n                     }\n-\n-                    ExpressionInterpreter interpreter = ExpressionInterpreter.expressionOptimizer(value, metadata, session, expressionTypes);\n+                }\n+                else {\n+                    ExpressionInterpreter interpreter = ExpressionInterpreter.expressionOptimizer(row, metadata, session, expressionTypes);\n                     Object evaluated = interpreter.optimize(NoOpSymbolResolver.INSTANCE);\n-\n                     if (evaluated instanceof Expression) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ2NTMyMA==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r523465320", "bodyText": "The same treatment as above means that we return TRUE_LITERAL from the method if we find any unresolved item. I just copied this behavior for non-Row expressions.\nThe predicate extractor could be further improved to only skip a single column in such case.", "author": "kasiafi", "createdAt": "2020-11-14T21:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1NDk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1NjUwMg==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521556502", "bodyText": "The rewriter should be able to handle the case of a Row expression natively, so this branch shouldn't be needed.", "author": "martint", "createdAt": "2020-11-11T18:28:18Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ExpressionRewriteRuleSet.java", "diffHunk": "@@ -285,18 +285,27 @@ public Result apply(JoinNode joinNode, Captures captures, Context context)\n         @Override\n         public Result apply(ValuesNode valuesNode, Captures captures, Context context)\n         {\n+            if (valuesNode.getRows().isEmpty()) {\n+                return Result.empty();\n+            }\n+\n             boolean anyRewritten = false;\n-            ImmutableList.Builder<List<Expression>> rows = ImmutableList.builder();\n-            for (List<Expression> row : valuesNode.getRows()) {\n-                ImmutableList.Builder<Expression> newRow = ImmutableList.builder();\n-                for (Expression expression : row) {\n-                    Expression rewritten = rewriter.rewrite(expression, context);\n-                    if (!expression.equals(rewritten)) {\n-                        anyRewritten = true;\n-                    }\n-                    newRow.add(rewritten);\n+            ImmutableList.Builder<Expression> rows = ImmutableList.builder();\n+            for (Expression row : valuesNode.getRows().get()) {\n+                Expression rewritten;\n+                if (row instanceof Row) {\n+                    // preserve the structure of row\n+                    rewritten = new Row(((Row) row).getItems().stream()\n+                            .map(item -> rewriter.rewrite(item, context))\n+                            .collect(toImmutableList()));\n+                }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQ2NTkwMg==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r523465902", "bodyText": "Yes... I found I needed to extract the case of Row expression because of SimplifyExpressions.\nIt uses the LiteralEncoder which turns a Row into something else. I had to process the Row by field and then put it back together so that it remained a Row at the top level.", "author": "kasiafi", "createdAt": "2020-11-14T21:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU1NjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMzA2MQ==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521613061", "bodyText": "Alternatively:\n        if (!valuesNode.getRows().get().stream().allMatch(Row.class::isInstance)) {", "author": "martint", "createdAt": "2020-11-11T20:15:58Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneValuesColumns.java", "diffHunk": "@@ -39,6 +41,17 @@ public PruneValuesColumns()\n     @Override\n     protected Optional<PlanNode> pushDownProjectOff(Context context, ValuesNode valuesNode, Set<Symbol> referencedOutputs)\n     {\n+        // no symbols to prune\n+        if (valuesNode.getOutputSymbols().isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        checkState(valuesNode.getRows().isPresent(), \"rows is empty\");\n+        // if any of ValuesNode's rows is specified by expression other than Row, the redundant piece cannot be extracted and pruned\n+        if (valuesNode.getRows().get().stream().anyMatch(row -> !(row instanceof Row))) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNDQ5NQ==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521614495", "bodyText": "Alternatively:\n        if (!node.getRows().get().stream().allMatch(Row.class::isInstance)) {", "author": "martint", "createdAt": "2020-11-11T20:18:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PruneUnreferencedOutputs.java", "diffHunk": "@@ -763,10 +764,20 @@ private PlanNode rewriteSetOperationChildren(SetOperationNode node, RewriteConte\n         @Override\n         public PlanNode visitValues(ValuesNode node, RewriteContext<Set<Symbol>> context)\n         {\n+            // nothing to prune: no output symbols and no expressions\n+            if (node.getRows().isEmpty()) {\n+                return node;\n+            }\n+\n+            // if any of ValuesNode's rows is specified by expression other than Row, the redundant piece cannot be extracted and pruned\n+            if (node.getRows().get().stream().anyMatch(row -> !(row instanceof Row))) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNTM4Ng==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521615386", "bodyText": "Format as:\nnew ValuesNode(node.getId(), newOutputs, newRows)", "author": "martint", "createdAt": "2020-11-11T20:20:25Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/UnaliasSymbolReferences.java", "diffHunk": "@@ -462,11 +463,34 @@ public PlanAndMappings visitValues(ValuesNode node, UnaliasContext context)\n             Map<Symbol, Symbol> mapping = new HashMap<>(context.getCorrelationMapping());\n             SymbolMapper mapper = symbolMapper(mapping);\n \n+            // nothing to map: no output symbols and no expressions\n+            if (node.getRows().isEmpty()) {\n+                return new PlanAndMappings(node, mapping);\n+            }\n+\n+            // if any of ValuesNode's rows is specified by expression other than Row, we cannot reason about individual fields\n+            if (node.getRows().get().stream().anyMatch(row -> !(row instanceof Row))) {\n+                List<Expression> newRows = node.getRows().get().stream()\n+                        .map(mapper::map)\n+                        .collect(toImmutableList());\n+                List<Symbol> newOutputs = node.getOutputSymbols().stream()\n+                        .map(mapper::map)\n+                        .distinct()\n+                        .collect(toImmutableList());\n+                checkState(newOutputs.size() == node.getOutputSymbols().size(), \"duplicate output symbol in Values\");\n+                return new PlanAndMappings(\n+                        new ValuesNode(\n+                                node.getId(),\n+                                newOutputs,\n+                                newRows),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNzc3Ng==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521617776", "bodyText": "Why is this needed? The expression printer should be able to print a Row expression directly.", "author": "martint", "createdAt": "2020-11-11T20:25:16Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -697,11 +698,25 @@ public Void visitTableScan(TableScanNode node, Void context)\n         public Void visitValues(ValuesNode node, Void context)\n         {\n             NodeRepresentation nodeOutput = addNode(node, \"Values\");\n-            for (List<Expression> row : node.getRows()) {\n-                nodeOutput.appendDetailsLine(row.stream()\n-                        .map(PlanPrinter::unresolveFunctions)\n-                        .map(Expression::toString)\n-                        .collect(joining(\", \", \"(\", \")\")));\n+            if (node.getRows().isEmpty()) {\n+                for (int i = 0; i < node.getRowCount(); i++) {\n+                    nodeOutput.appendDetailsLine(\"()\");\n+                }\n+                return null;\n+            }\n+            List<String> rows = node.getRows().get().stream()\n+                    .map(row -> {\n+                        if (row instanceof Row) {\n+                            return ((Row) row).getItems().stream()\n+                                    .map(PlanPrinter::unresolveFunctions)\n+                                    .map(Expression::toString)\n+                                    .collect(joining(\", \", \"(\", \")\"));\n+                        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY3MDUzMA==", "url": "https://github.com/trinodb/trino/pull/5801#discussion_r521670530", "bodyText": "I wanted to preserve the result for all \"regular\" rows.\nRow expression renders as \"ROW(...\"", "author": "kasiafi", "createdAt": "2020-11-11T22:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNzc3Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "0dd7c5c73ab82c72471312cb73aaf5c6ce52db32", "url": "https://github.com/trinodb/trino/commit/0dd7c5c73ab82c72471312cb73aaf5c6ce52db32", "message": "Fix literal type in a rule\n\nIn `PruneCountAggregationOverScalar` rule changes the type of\nused literal from LongLiteral to Bigint.", "committedDate": "2020-11-16T16:27:56Z", "type": "commit"}, {"oid": "f8a0833c2235e1d352b7d960b03f25bc68df8604", "url": "https://github.com/trinodb/trino/commit/f8a0833c2235e1d352b7d960b03f25bc68df8604", "message": "Use proper literal type", "committedDate": "2020-11-16T16:27:56Z", "type": "commit"}, {"oid": "27f4c1ab71ca9803bfd8d1c484f1570627014fab", "url": "https://github.com/trinodb/trino/commit/27f4c1ab71ca9803bfd8d1c484f1570627014fab", "message": "Use proper literal type", "committedDate": "2020-11-16T16:27:56Z", "type": "commit"}, {"oid": "838bcf014aef88a0e132b53b3eef6c14299613f6", "url": "https://github.com/trinodb/trino/commit/838bcf014aef88a0e132b53b3eef6c14299613f6", "message": "Refactor ValuesNode\n\nChange inner rows structure of ValuesNode from List<List<Expression>>\nto List<Expression>.\nFix the issue of Values rows specified by expressions other than Row\nbut evaluating to RowType.\nIn that case, Values node failed at Planning, as the expression\nwas considered a single field specification instead of\nrow specification.", "committedDate": "2020-11-16T16:27:56Z", "type": "commit"}, {"oid": "d3f3aea21b2ed215cdfe6403c4c9fb87f4deb5e4", "url": "https://github.com/trinodb/trino/commit/d3f3aea21b2ed215cdfe6403c4c9fb87f4deb5e4", "message": "Support pruning all columns from ValuesNode with non-Row expression", "committedDate": "2020-11-16T16:27:56Z", "type": "commit"}, {"oid": "a9e09de4e2604f7bfd2bc5a6e544c91ba10f653b", "url": "https://github.com/trinodb/trino/commit/a9e09de4e2604f7bfd2bc5a6e544c91ba10f653b", "message": "Recognize ValuesNode with no rows as a node with distinct output\n\nIn DistinctOutputQueryUtil, before this change, only ValuesNode\nwith single row was considered as having distinct output.", "committedDate": "2020-11-16T16:27:56Z", "type": "commit"}, {"oid": "beb2f7c0bdcd5749b3d3e985cd0c9e3fc7987574", "url": "https://github.com/trinodb/trino/commit/beb2f7c0bdcd5749b3d3e985cd0c9e3fc7987574", "message": "Handle the case of no ValuesNode outputs left in PruneUnreferencedOutputs", "committedDate": "2020-11-16T16:27:57Z", "type": "commit"}, {"oid": "beb2f7c0bdcd5749b3d3e985cd0c9e3fc7987574", "url": "https://github.com/trinodb/trino/commit/beb2f7c0bdcd5749b3d3e985cd0c9e3fc7987574", "message": "Handle the case of no ValuesNode outputs left in PruneUnreferencedOutputs", "committedDate": "2020-11-16T16:27:57Z", "type": "forcePushed"}]}