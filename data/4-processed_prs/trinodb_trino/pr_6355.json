{"pr_number": 6355, "pr_title": "Add functions to_geojson and from_geojson", "pr_createdAt": "2020-12-16T01:59:01Z", "pr_url": "https://github.com/trinodb/trino/pull/6355", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NjkzNw==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546256937", "bodyText": "What if we could use ImmutableSet.of(\"LineString\", \"Polygon\", \"Point\")", "author": "Praveen2112", "createdAt": "2020-12-19T16:33:37Z", "path": "presto-geospatial-toolkit/src/main/java/io/prestosql/geospatial/GeometryUtils.java", "diffHunk": "@@ -23,12 +23,27 @@\n import com.esri.core.geometry.ogc.OGCGeometry;\n import com.esri.core.geometry.ogc.OGCPoint;\n import com.esri.core.geometry.ogc.OGCPolygon;\n+import io.prestosql.spi.PrestoException;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.geojson.GeoJsonReader;\n+import org.locationtech.jts.io.geojson.GeoJsonWriter;\n \n import java.util.HashSet;\n+import java.util.Optional;\n import java.util.Set;\n \n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+\n public final class GeometryUtils\n {\n+    private static final Set<String> ATOMIC_GEOMETRY_TYPES = new HashSet<>();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NzM4OQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546257389", "bodyText": "Can we have lambda based expression like\nmap(Slices::utf8Slice).orElse(null)", "author": "Praveen2112", "createdAt": "2020-12-19T16:37:38Z", "path": "presto-geospatial/src/main/java/io/prestosql/plugin/geospatial/GeoFunctions.java", "diffHunk": "@@ -1396,6 +1400,29 @@ public static Block spatialPartitions(@SqlType(KdbTreeType.NAME) Object kdbTree,\n         return spatialPartitions((KdbTree) kdbTree, new Rectangle(envelope.getXMin(), envelope.getYMin(), envelope.getXMax(), envelope.getYMax()));\n     }\n \n+    @ScalarFunction(\"to_geojson\")\n+    @Description(\"Returns a geometry from a geo JSON string\")\n+    @SqlType(GEOMETRY_TYPE_NAME)\n+    public static Slice toGeoJson(@SqlType(VARCHAR) Slice input)\n+    {\n+        return serialize(jtsGeometryFromJson(input.toStringUtf8()));\n+    }\n+\n+    @SqlNullable\n+    @ScalarFunction(\"from_geojson\")\n+    @Description(\"Returns geo JSON string based on the input geometry\")\n+    @SqlType(VARCHAR)\n+    public static Slice fromGeoJson(@SqlType(GEOMETRY_TYPE_NAME) Slice input)\n+    {\n+        Optional<String> geoJson = jsonFromJtsGeometry(JtsGeometrySerde.deserialize(input));\n+        if (geoJson.isPresent()) {\n+            return utf8Slice(geoJson.get());\n+        }\n+        else {\n+            return null;\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyMzg0OA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546523848", "bodyText": "same comment about function name swap", "author": "phd3", "createdAt": "2020-12-21T06:02:37Z", "path": "presto-docs/src/main/sphinx/functions/geospatial.rst", "diffHunk": "@@ -407,6 +407,16 @@ Accessors\n \n     Returns the great-circle distance between two points on Earth's surface in kilometers.\n \n+.. function:: from_geojson(Geometry) -> varchar", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyODU1Nw==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546528557", "bodyText": "I think the names from_geojson and to_geojson should be switched.", "author": "phd3", "createdAt": "2020-12-21T06:20:31Z", "path": "presto-geospatial/src/main/java/io/prestosql/plugin/geospatial/GeoFunctions.java", "diffHunk": "@@ -1396,6 +1400,29 @@ public static Block spatialPartitions(@SqlType(KdbTreeType.NAME) Object kdbTree,\n         return spatialPartitions((KdbTree) kdbTree, new Rectangle(envelope.getXMin(), envelope.getYMin(), envelope.getXMax(), envelope.getYMax()));\n     }\n \n+    @ScalarFunction(\"to_geojson\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjUyOTcxNA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546529714", "bodyText": "since GeoJSON seems like a standard, we can use this standardized casing in all references in our comments/docs.", "author": "phd3", "createdAt": "2020-12-21T06:25:02Z", "path": "presto-geospatial/src/main/java/io/prestosql/plugin/geospatial/GeoFunctions.java", "diffHunk": "@@ -1396,6 +1400,29 @@ public static Block spatialPartitions(@SqlType(KdbTreeType.NAME) Object kdbTree,\n         return spatialPartitions((KdbTree) kdbTree, new Rectangle(envelope.getXMin(), envelope.getYMin(), envelope.getXMax(), envelope.getYMax()));\n     }\n \n+    @ScalarFunction(\"to_geojson\")\n+    @Description(\"Returns a geometry from a geo JSON string\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg5MzE3Mg==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546893172", "bodyText": "nit: split arguments on multiple lines for the assertions going too long", "author": "phd3", "createdAt": "2020-12-21T19:38:23Z", "path": "presto-geospatial/src/test/java/io/prestosql/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,68 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()\n+    {\n+        // empty atomic (non-multi) geometries should return null\n+        assertEmptyGeoToJson(\"POINT EMPTY\");\n+        assertEmptyGeoToJson(\"LINESTRING EMPTY\");\n+        assertEmptyGeoToJson(\"POLYGON EMPTY\");\n+\n+        // empty multi geometries should return empty\n+        assertGeoToAndFromJson(\"MULTIPOINT EMPTY\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING EMPTY\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON EMPTY\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION EMPTY\");\n+\n+        // valid nonempty geometries should return as is.\n+        assertGeoToAndFromJson(\"POINT (1 2)\");\n+        assertGeoToAndFromJson(\"MULTIPOINT ((1 2), (3 4))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 2, 3 4)\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING ((1 1, 5 1), (2 4, 4 4))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 3 0, 3 3, 0 3, 0 0), (1 1, 1 2, 2 2, 2 1, 1 1))\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON (((1 1, 3 1, 3 3, 1 3, 1 1)), ((2 4, 6 4, 6 6, 2 6, 2 4)))\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTczOA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546965738", "bodyText": "Could you please explain why we need to treat the types differently?  The rfc says the following, so it'd also be valid to return null for multi types right?\n\nGeoJSON processors MAY interpret Geometry objects with\nempty \"coordinates\" arrays as null objects.", "author": "phd3", "createdAt": "2020-12-21T22:42:31Z", "path": "presto-geospatial-toolkit/src/main/java/io/prestosql/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +175,24 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)\n+    {\n+        try {\n+            return new GeoJsonReader().read(json);\n+        }\n+        catch (ParseException | IllegalArgumentException e) {\n+            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Invalid GeoJSON: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public static Optional<String> jsonFromJtsGeometry(org.locationtech.jts.geom.Geometry geometry)\n+    {\n+        if (ATOMIC_GEOMETRY_TYPES.contains(geometry.getGeometryType()) && geometry.isEmpty()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NjU3Nw==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546966577", "bodyText": "use errorcode in the assertion", "author": "phd3", "createdAt": "2020-12-21T22:45:02Z", "path": "presto-geospatial/src/test/java/io/prestosql/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,68 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()\n+    {\n+        // empty atomic (non-multi) geometries should return null\n+        assertEmptyGeoToJson(\"POINT EMPTY\");\n+        assertEmptyGeoToJson(\"LINESTRING EMPTY\");\n+        assertEmptyGeoToJson(\"POLYGON EMPTY\");\n+\n+        // empty multi geometries should return empty\n+        assertGeoToAndFromJson(\"MULTIPOINT EMPTY\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING EMPTY\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON EMPTY\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION EMPTY\");\n+\n+        // valid nonempty geometries should return as is.\n+        assertGeoToAndFromJson(\"POINT (1 2)\");\n+        assertGeoToAndFromJson(\"MULTIPOINT ((1 2), (3 4))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 2, 3 4)\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING ((1 1, 5 1), (2 4, 4 4))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 3 0, 3 3, 0 3, 0 0), (1 1, 1 2, 2 2, 2 1, 1 1))\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON (((1 1, 3 1, 3 3, 1 3, 1 1)), ((2 4, 6 4, 6 6, 2 6, 2 4)))\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION (POINT (1 2), LINESTRING (0 0, 1 2, 3 4), POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0)))\");\n+\n+        // invalid geometries should return as is.\n+        assertGeoToAndFromJson(\"MULTIPOINT ((0 0), (0 1), (1 1), (0 1))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 0 1, 0 1, 1 1, 1 0, 0 0)\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 1, 1 0, 0 1)\");\n+\n+        // explicit JSON test cases should valid but return empty or null\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":[]}\", \"LINESTRING EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"coordinates\\\":[]}\", \"MULTIPOINT EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPolygon\\\",\\\"coordinates\\\":[]}\", \"MULTIPOLYGON EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiLineString\\\",\\\"coordinates\\\":[[[0.0,0.0],[1,10]],[[10,10],[20,30]],[[123,123],[456,789]]]}\", \"MULTILINESTRING ((0 0, 1 10), (10 10, 20 30), (123 123, 456 789))\");\n+\n+        // Valid JSON with invalid Geometry definition\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[]}\", \"Invalid GeoJSON: Could not parse Polygon from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"invalidField\\\":[]}\", \"Invalid GeoJSON: Could not parse MultiPoint from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"coordinates\\\":[[[0.0,0.0],[1,10]],[[10,10],[20,30]],[[123,123],[456,789]]]}\", \"Invalid GeoJSON: Could not parse Geometry from Json string.  No 'type' property found.\");\n+\n+        // Invalid JSON\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"crashMe\\\"}\", \"Invalid GeoJSON: Unexpected token RIGHT BRACE(}) at position 30.\");\n+    }\n+\n+    private void assertEmptyGeoToJson(String wkt)\n+    {\n+        assertFunction(format(\"from_geojson(ST_GeometryFromText('%s'))\", wkt), VARCHAR, null);\n+    }\n+\n+    private void assertGeoToAndFromJson(String wkt)\n+    {\n+        assertFunction(format(\"ST_AsText(to_geojson(from_geojson(ST_GeometryFromText('%s'))))\", wkt), VARCHAR, wkt);\n+    }\n+\n+    private void assertValidGeometryJson(String json, String wkt)\n+    {\n+        assertFunction(\"ST_AsText(to_geojson('\" + json + \"'))\", VARCHAR, wkt);\n+    }\n+\n+    private void assertInvalidGeometryJson(String json, String message)\n+    {\n+        assertInvalidFunction(\"to_geojson('\" + json + \"')\", message);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk3MDEzNQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546970135", "bodyText": "If we end up going ahead with using JTS's structures during conversion, I'd rename ATOMIC_GEOMETRY_TYPES to something that clearly indicates that this is for the JTS Geometry objects.", "author": "phd3", "createdAt": "2020-12-21T22:54:04Z", "path": "presto-geospatial-toolkit/src/main/java/io/prestosql/geospatial/GeometryUtils.java", "diffHunk": "@@ -23,12 +23,27 @@\n import com.esri.core.geometry.ogc.OGCGeometry;\n import com.esri.core.geometry.ogc.OGCPoint;\n import com.esri.core.geometry.ogc.OGCPolygon;\n+import io.prestosql.spi.PrestoException;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.geojson.GeoJsonReader;\n+import org.locationtech.jts.io.geojson.GeoJsonWriter;\n \n import java.util.HashSet;\n+import java.util.Optional;\n import java.util.Set;\n \n+import static io.prestosql.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+\n public final class GeometryUtils\n {\n+    private static final Set<String> ATOMIC_GEOMETRY_TYPES = new HashSet<>();\n+\n+    static {\n+        ATOMIC_GEOMETRY_TYPES.add(\"LineString\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk3NDU3NA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546974574", "bodyText": "is there a reason for converting from esri-geometry-api' OgcGeometry -> locationtech's Geometry --> GeoJSON?\nSince types in presto seem to serialize the esri-geometry-api form, is it possible to use any SerDe related methods provided by esri-geometry-api directly?", "author": "phd3", "createdAt": "2020-12-21T23:04:01Z", "path": "presto-geospatial-toolkit/src/main/java/io/prestosql/geospatial/GeometryUtils.java", "diffHunk": "@@ -23,12 +23,27 @@\n import com.esri.core.geometry.ogc.OGCGeometry;\n import com.esri.core.geometry.ogc.OGCPoint;\n import com.esri.core.geometry.ogc.OGCPolygon;\n+import io.prestosql.spi.PrestoException;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.geojson.GeoJsonReader;\n+import org.locationtech.jts.io.geojson.GeoJsonWriter;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcwMDI5Ng==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r558700296", "bodyText": "Not sure I understand the question. The entire purpose of these new built-ins is to convert from esri-geometry WKT to/from GeoJSON. There's no functionality in esri-geometry-api that provides this.", "author": "JamesRTaylor", "createdAt": "2021-01-16T00:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk3NDU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MDU5OA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546980598", "bodyText": "should valid --> should be valid", "author": "phd3", "createdAt": "2020-12-21T23:20:16Z", "path": "presto-geospatial/src/test/java/io/prestosql/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,68 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()\n+    {\n+        // empty atomic (non-multi) geometries should return null\n+        assertEmptyGeoToJson(\"POINT EMPTY\");\n+        assertEmptyGeoToJson(\"LINESTRING EMPTY\");\n+        assertEmptyGeoToJson(\"POLYGON EMPTY\");\n+\n+        // empty multi geometries should return empty\n+        assertGeoToAndFromJson(\"MULTIPOINT EMPTY\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING EMPTY\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON EMPTY\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION EMPTY\");\n+\n+        // valid nonempty geometries should return as is.\n+        assertGeoToAndFromJson(\"POINT (1 2)\");\n+        assertGeoToAndFromJson(\"MULTIPOINT ((1 2), (3 4))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 2, 3 4)\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING ((1 1, 5 1), (2 4, 4 4))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 3 0, 3 3, 0 3, 0 0), (1 1, 1 2, 2 2, 2 1, 1 1))\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON (((1 1, 3 1, 3 3, 1 3, 1 1)), ((2 4, 6 4, 6 6, 2 6, 2 4)))\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION (POINT (1 2), LINESTRING (0 0, 1 2, 3 4), POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0)))\");\n+\n+        // invalid geometries should return as is.\n+        assertGeoToAndFromJson(\"MULTIPOINT ((0 0), (0 1), (1 1), (0 1))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 0 1, 0 1, 1 1, 1 0, 0 0)\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 1, 1 0, 0 1)\");\n+\n+        // explicit JSON test cases should valid but return empty or null", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NjY5NQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546986695", "bodyText": "can we add some tests for Envelope type too?", "author": "phd3", "createdAt": "2020-12-21T23:41:16Z", "path": "presto-geospatial/src/test/java/io/prestosql/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,68 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODY4MjQzNg==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r558682436", "bodyText": "There's no ENVELOPE keyword that you can use in WKT (like you can with POINT, POLYGON, etc.). You can calculate the envelope from a Geometry with functions like ST_ENVELOPE.", "author": "JamesRTaylor", "createdAt": "2021-01-15T23:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NjY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NzcxOA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546987718", "bodyText": "Looks like a GeoJSON object can be a Feature Object, FeatureCollection object or a Geometry object. How does GeoJsonReader/Writer behave in the first two cases?\nIf it fails the conversion, it would be good to add tests documenting that. May be we can rename the method to to_geojson_geometry and from_geogson_geometry to make the behavior more obvious.\nOn the other hand, if it silently tries to extract the geometry values, then I think we may want to explicitly fail or call this an \"extraction\" rather than conversion.", "author": "phd3", "createdAt": "2020-12-21T23:45:14Z", "path": "presto-geospatial-toolkit/src/main/java/io/prestosql/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +175,24 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk5MDI5NQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546990295", "bodyText": "can we document more edge cases here? i.e. deserializing single types with empty and non-empty coordinates,\n, deserializing with additional fields, envelopes, deserializing with null values for coordinates field", "author": "phd3", "createdAt": "2020-12-21T23:54:27Z", "path": "presto-geospatial/src/test/java/io/prestosql/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,68 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()\n+    {\n+        // empty atomic (non-multi) geometries should return null\n+        assertEmptyGeoToJson(\"POINT EMPTY\");\n+        assertEmptyGeoToJson(\"LINESTRING EMPTY\");\n+        assertEmptyGeoToJson(\"POLYGON EMPTY\");\n+\n+        // empty multi geometries should return empty\n+        assertGeoToAndFromJson(\"MULTIPOINT EMPTY\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING EMPTY\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON EMPTY\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION EMPTY\");\n+\n+        // valid nonempty geometries should return as is.\n+        assertGeoToAndFromJson(\"POINT (1 2)\");\n+        assertGeoToAndFromJson(\"MULTIPOINT ((1 2), (3 4))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 2, 3 4)\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING ((1 1, 5 1), (2 4, 4 4))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 3 0, 3 3, 0 3, 0 0), (1 1, 1 2, 2 2, 2 1, 1 1))\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON (((1 1, 3 1, 3 3, 1 3, 1 1)), ((2 4, 6 4, 6 6, 2 6, 2 4)))\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION (POINT (1 2), LINESTRING (0 0, 1 2, 3 4), POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0)))\");\n+\n+        // invalid geometries should return as is.\n+        assertGeoToAndFromJson(\"MULTIPOINT ((0 0), (0 1), (1 1), (0 1))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 0 1, 0 1, 1 1, 1 0, 0 0)\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 1, 1 0, 0 1)\");\n+\n+        // explicit JSON test cases should valid but return empty or null\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":[]}\", \"LINESTRING EMPTY\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk5Nzc0Mw==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546997743", "bodyText": "There can be additional elements in the a Geometry GeoJSON. e.g.\n{ \"type\": \"Point\",\"coordinates\": [100.0, 0.0], \"mykey\":\"myvalue\"}\n\nI think we can add a test for this, and add in our documentation should that such  extra information is dropped during deserialization.", "author": "phd3", "createdAt": "2020-12-22T00:20:20Z", "path": "presto-geospatial-toolkit/src/main/java/io/prestosql/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +175,24 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)\n+    {\n+        try {\n+            return new GeoJsonReader().read(json);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk5OTU4OA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r546999588", "bodyText": "I don't think the reason for failure here is not that the field is invalid, but rather the missing coordinates.  so may be rename \"invalidField\" ?", "author": "phd3", "createdAt": "2020-12-22T00:27:32Z", "path": "presto-geospatial/src/test/java/io/prestosql/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,68 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()\n+    {\n+        // empty atomic (non-multi) geometries should return null\n+        assertEmptyGeoToJson(\"POINT EMPTY\");\n+        assertEmptyGeoToJson(\"LINESTRING EMPTY\");\n+        assertEmptyGeoToJson(\"POLYGON EMPTY\");\n+\n+        // empty multi geometries should return empty\n+        assertGeoToAndFromJson(\"MULTIPOINT EMPTY\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING EMPTY\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON EMPTY\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION EMPTY\");\n+\n+        // valid nonempty geometries should return as is.\n+        assertGeoToAndFromJson(\"POINT (1 2)\");\n+        assertGeoToAndFromJson(\"MULTIPOINT ((1 2), (3 4))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 2, 3 4)\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING ((1 1, 5 1), (2 4, 4 4))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))\");\n+        assertGeoToAndFromJson(\"POLYGON ((0 0, 3 0, 3 3, 0 3, 0 0), (1 1, 1 2, 2 2, 2 1, 1 1))\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON (((1 1, 3 1, 3 3, 1 3, 1 1)), ((2 4, 6 4, 6 6, 2 6, 2 4)))\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION (POINT (1 2), LINESTRING (0 0, 1 2, 3 4), POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0)))\");\n+\n+        // invalid geometries should return as is.\n+        assertGeoToAndFromJson(\"MULTIPOINT ((0 0), (0 1), (1 1), (0 1))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 0 1, 0 1, 1 1, 1 0, 0 0)\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 1, 1 0, 0 1)\");\n+\n+        // explicit JSON test cases should valid but return empty or null\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":[]}\", \"LINESTRING EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"coordinates\\\":[]}\", \"MULTIPOINT EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPolygon\\\",\\\"coordinates\\\":[]}\", \"MULTIPOLYGON EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiLineString\\\",\\\"coordinates\\\":[[[0.0,0.0],[1,10]],[[10,10],[20,30]],[[123,123],[456,789]]]}\", \"MULTILINESTRING ((0 0, 1 10), (10 10, 20 30), (123 123, 456 789))\");\n+\n+        // Valid JSON with invalid Geometry definition\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[]}\", \"Invalid GeoJSON: Could not parse Polygon from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"invalidField\\\":[]}\", \"Invalid GeoJSON: Could not parse MultiPoint from GeoJson string.\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA4MDM1Mg==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r547080352", "bodyText": "Or add a new test with all three fields (two valid + one invalid) and rename the current one.", "author": "hashhar", "createdAt": "2020-12-22T05:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk5OTU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwNTcwNw==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r547005707", "bodyText": "The rfc mentions the following:\n\nThe coordinate reference system for all GeoJSON coordinates is a geographic coordinate reference system, using the World Geodetic System 1984 (WGS 84) [WGS84] datum, with longitude and latitude units of decimal degrees.\n\n@martint is presto's SphericalGeographyType better suited here instead of GeometryType?\nbtw, the rfc also mentions the following, but we can't rely on external usecases following the same I think.\n\nwhere all involved parties have a prior arrangement, alternative coordinate reference systems can be used without risk of data being misinterpreted.", "author": "phd3", "createdAt": "2020-12-22T00:50:35Z", "path": "presto-geospatial/src/main/java/io/prestosql/plugin/geospatial/GeoFunctions.java", "diffHunk": "@@ -1396,6 +1400,29 @@ public static Block spatialPartitions(@SqlType(KdbTreeType.NAME) Object kdbTree,\n         return spatialPartitions((KdbTree) kdbTree, new Rectangle(envelope.getXMin(), envelope.getYMin(), envelope.getXMax(), envelope.getYMax()));\n     }\n \n+    @ScalarFunction(\"to_geojson\")\n+    @Description(\"Returns a geometry from a geo JSON string\")\n+    @SqlType(GEOMETRY_TYPE_NAME)\n+    public static Slice toGeoJson(@SqlType(VARCHAR) Slice input)\n+    {\n+        return serialize(jtsGeometryFromJson(input.toStringUtf8()));\n+    }\n+\n+    @SqlNullable\n+    @ScalarFunction(\"from_geojson\")\n+    @Description(\"Returns geo JSON string based on the input geometry\")\n+    @SqlType(VARCHAR)\n+    public static Slice fromGeoJson(@SqlType(GEOMETRY_TYPE_NAME) Slice input)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk2MzA1NA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r562963054", "bodyText": "Yes, that seems more appropriate", "author": "martint", "createdAt": "2021-01-22T23:04:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwNTcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM0NzA2Mg==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571347062", "bodyText": "I updated the built-in functions to use SphericalGeographyType instead.", "author": "JamesRTaylor", "createdAt": "2021-02-06T03:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAwNTcwNw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzkwMzQ5Ng==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r557903496", "bodyText": "nit: Returns the GeoJSON encoding of the input geometry.\nPlease also add things that are not supported: e.g. dropping of additional key-values, feature/featureCollection etc.", "author": "phd3", "createdAt": "2021-01-15T06:38:16Z", "path": "docs/src/main/sphinx/functions/geospatial.rst", "diffHunk": "@@ -407,6 +407,16 @@ Accessors\n \n     Returns the great-circle distance between two points on Earth's surface in kilometers.\n \n+.. function:: to_geojson_geometry(Geometry) -> varchar\n+\n+    Returns the GeoJSON encoded defined by the input geometry.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDcxMjM2Mw==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r560712363", "bodyText": "Jts's GeoJsonWriter#write method, for a non-multi typed empty objects returns a malformed JSON {\"type\":\"Point\",\"coordinates\":,\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:0\"}}} which seems like a bug: locationtech/jts#411 So we may need to take it into account if we don't want to serialize as null.", "author": "phd3", "createdAt": "2021-01-20T06:42:38Z", "path": "lib/trino-geospatial-toolkit/src/main/java/io/trino/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +170,26 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)\n+    {\n+        try {\n+            return new GeoJsonReader().read(json);\n+        }\n+        catch (ParseException | IllegalArgumentException e) {\n+            throw new TrinoException(INVALID_FUNCTION_ARGUMENT, \"Invalid GeoJSON: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public static Optional<String> jsonFromJtsGeometry(org.locationtech.jts.geom.Geometry geometry)\n+    {\n+        // Empty atomic (non-multi) geometries return null since\n+        // there's no way to represent an empty atomic value in GeoJSON\n+        if (ATOMIC_GEOMETRY_TYPES.contains(geometry.getGeometryType()) && geometry.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        else { // Empty multi geometries are represented as empty coordinate arrays in GeoJSON\n+            return Optional.of(new GeoJsonWriter().write(geometry));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM0NzMzMQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571347331", "bodyText": "Had an offline conversation with @martint who suggested just throwing in the case of an empty atomic geometry since the handling is error prone and inconsistent in the library on which we're relying. I'll follow up with them to see if they're open to cleaning this up in which case we can remove this restriction once the library fixes it.", "author": "JamesRTaylor", "createdAt": "2021-02-06T03:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDcxMjM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY5MTAxOQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571691019", "bodyText": "Returns a spherical geography ... now?", "author": "phd3", "createdAt": "2021-02-07T20:49:02Z", "path": "plugin/trino-geospatial/src/main/java/io/trino/plugin/geospatial/GeoFunctions.java", "diffHunk": "@@ -1396,6 +1400,23 @@ public static Block spatialPartitions(@SqlType(KdbTreeType.NAME) Object kdbTree,\n         return spatialPartitions((KdbTree) kdbTree, new Rectangle(envelope.getXMin(), envelope.getYMin(), envelope.getXMax(), envelope.getYMax()));\n     }\n \n+    @ScalarFunction(\"from_geojson_geometry\")\n+    @Description(\"Returns a geometry from a GeoJSON string\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY5MTYxNA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571691614", "bodyText": "ATTRIB --> ATTRIBUTE", "author": "phd3", "createdAt": "2021-02-07T20:54:09Z", "path": "lib/trino-geospatial-toolkit/src/main/java/io/trino/geospatial/GeometryUtils.java", "diffHunk": "@@ -23,12 +23,29 @@\n import com.esri.core.geometry.ogc.OGCGeometry;\n import com.esri.core.geometry.ogc.OGCPoint;\n import com.esri.core.geometry.ogc.OGCPolygon;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableSet;\n+import io.trino.spi.TrinoException;\n+import org.locationtech.jts.io.ParseException;\n+import org.locationtech.jts.io.geojson.GeoJsonReader;\n+import org.locationtech.jts.io.geojson.GeoJsonWriter;\n \n import java.util.HashSet;\n+import java.util.Optional;\n import java.util.Set;\n \n+import static io.trino.spi.StandardErrorCode.INVALID_FUNCTION_ARGUMENT;\n+import static java.lang.String.format;\n+\n public final class GeometryUtils\n {\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private static final String TYPE_ATTRIB = \"type\";\n+    private static final String COORDINATES_ATTRIB = \"coordinates\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY5MzM1MQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571693351", "bodyText": "... based on input spherical geography now?", "author": "phd3", "createdAt": "2021-02-07T20:57:22Z", "path": "plugin/trino-geospatial/src/main/java/io/trino/plugin/geospatial/GeoFunctions.java", "diffHunk": "@@ -1396,6 +1400,23 @@ public static Block spatialPartitions(@SqlType(KdbTreeType.NAME) Object kdbTree,\n         return spatialPartitions((KdbTree) kdbTree, new Rectangle(envelope.getXMin(), envelope.getYMin(), envelope.getXMax(), envelope.getYMax()));\n     }\n \n+    @ScalarFunction(\"from_geojson_geometry\")\n+    @Description(\"Returns a geometry from a GeoJSON string\")\n+    @SqlType(SPHERICAL_GEOGRAPHY_TYPE_NAME)\n+    public static Slice fromGeoJsonGeometry(@SqlType(VARCHAR) Slice input)\n+    {\n+        return serialize(jtsGeometryFromJson(input.toStringUtf8()));\n+    }\n+\n+    @SqlNullable\n+    @ScalarFunction(\"to_geojson_geometry\")\n+    @Description(\"Returns GeoJSON string based on the input geometry\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwMTg5Mg==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571701892", "bodyText": "I'd Throws a TrinoException ... and remove @param and @throws below.", "author": "phd3", "createdAt": "2021-02-07T21:20:49Z", "path": "lib/trino-geospatial-toolkit/src/main/java/io/trino/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +177,56 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)\n+    {\n+        verifyNonEmptyCoordinatesForAtomicTypes(json);\n+        try {\n+            return new GeoJsonReader().read(json);\n+        }\n+        catch (ParseException | IllegalArgumentException e) {\n+            throw new TrinoException(INVALID_FUNCTION_ARGUMENT, \"Invalid GeoJSON: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Throws if json has empty coordinates for atomic type (Point, LineString, and Polygon).", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwMjMxMg==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571702312", "bodyText": "Thanks for adding these examples!  \u2764\ufe0f", "author": "phd3", "createdAt": "2021-02-07T21:25:03Z", "path": "lib/trino-geospatial-toolkit/src/main/java/io/trino/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +177,56 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)\n+    {\n+        verifyNonEmptyCoordinatesForAtomicTypes(json);\n+        try {\n+            return new GeoJsonReader().read(json);\n+        }\n+        catch (ParseException | IllegalArgumentException e) {\n+            throw new TrinoException(INVALID_FUNCTION_ARGUMENT, \"Invalid GeoJSON: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Throws if json has empty coordinates for atomic type (Point, LineString, and Polygon).\n+     * This is due to the inconsistent behavior in the locationtech library not returning\n+     * an EMPTY type, but instead doing the following:\n+     * {type:Point, coordinates:[]} -> POINT (0 0)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwMzM2NQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571703365", "bodyText": "I think we can remove Optional here", "author": "phd3", "createdAt": "2021-02-07T21:33:51Z", "path": "lib/trino-geospatial-toolkit/src/main/java/io/trino/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +177,56 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)\n+    {\n+        verifyNonEmptyCoordinatesForAtomicTypes(json);\n+        try {\n+            return new GeoJsonReader().read(json);\n+        }\n+        catch (ParseException | IllegalArgumentException e) {\n+            throw new TrinoException(INVALID_FUNCTION_ARGUMENT, \"Invalid GeoJSON: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Throws if json has empty coordinates for atomic type (Point, LineString, and Polygon).\n+     * This is due to the inconsistent behavior in the locationtech library not returning\n+     * an EMPTY type, but instead doing the following:\n+     * {type:Point, coordinates:[]} -> POINT (0 0)\n+     * {type:LineString, coordinates[]} -> LINESTRING EMPTY\n+     * {type:Polygon, coordinates[]} -> Exception during parsing\n+     *\n+     * @param json\n+     * @throws TrinoException\n+     */\n+    private static void verifyNonEmptyCoordinatesForAtomicTypes(String json)\n+    {\n+        try {\n+            JsonNode jsonNode = OBJECT_MAPPER.readTree(json);\n+            JsonNode typeNode = jsonNode.get(TYPE_ATTRIB);\n+            if (typeNode != null) {\n+                String type = typeNode.textValue();\n+                if (ATOMIC_GEOMETRY_TYPES.contains(type)) {\n+                    JsonNode coordinatesNode = jsonNode.get(COORDINATES_ATTRIB);\n+                    if (coordinatesNode != null && coordinatesNode.isArray() && coordinatesNode.isEmpty()) {\n+                        throw new TrinoException(INVALID_FUNCTION_ARGUMENT, format(\"Invalid GeoJSON: Empty %s not allowed.\", type));\n+                    }\n+                }\n+            }\n+        }\n+        catch (JsonProcessingException e) {\n+        }\n+    }\n+\n+    public static Optional<String> jsonFromJtsGeometry(org.locationtech.jts.geom.Geometry geometry)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwNDI4OA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571704288", "bodyText": "we could put this check once the reader has failed - so that we avoid double parsing for all the valid cases. But since the json seems to be small, this is probably fine for now.", "author": "phd3", "createdAt": "2021-02-07T21:41:52Z", "path": "lib/trino-geospatial-toolkit/src/main/java/io/trino/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +177,56 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)\n+    {\n+        verifyNonEmptyCoordinatesForAtomicTypes(json);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwNTI0Mg==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571705242", "bodyText": "nit: duplicate test", "author": "phd3", "createdAt": "2021-02-07T21:49:31Z", "path": "plugin/trino-geospatial/src/test/java/io/trino/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,120 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()\n+    {\n+        // empty atomic (non-multi) geometries yield invalid json so instead are treated as exception cases\n+        assertInvalidToGeometryJson(\"POINT EMPTY\", \"Invalid GeoJSON: Empty Point not allowed.\");\n+        assertInvalidToGeometryJson(\"LINESTRING EMPTY\", \"Invalid GeoJSON: Empty LineString not allowed.\");\n+        assertInvalidToGeometryJson(\"POLYGON EMPTY\", \"Invalid GeoJSON: Empty Polygon not allowed.\");\n+\n+        // empty coordinate arrays yield inconsistent results so instead are treated as exception cases\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty Point not allowed.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty LineString not allowed.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty Polygon not allowed.\");\n+\n+        // empty multi geometries should return empty\n+        // empty multi-type values are represented by an empty JSON array in GeoJSON\n+        assertGeoToAndFromJson(\"MULTIPOINT EMPTY\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING EMPTY\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON EMPTY\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION EMPTY\");\n+\n+        // valid nonempty geometries should return as is.\n+        assertGeoToAndFromJson(\"POINT (1 2)\");\n+        assertGeoToAndFromJson(\"MULTIPOINT ((1 2), (3 4))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 2, 3 4)\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING (\" +\n+                \"(1 1, 5 1), \" +\n+                \"(2 4, 4 4))\");\n+        assertGeoToAndFromJson(\"POLYGON (\" +\n+                \"(0 0, 1 0, 1 1, 0 1, 0 0))\");\n+        assertGeoToAndFromJson(\"POLYGON (\" +\n+                \"(0 0, 3 0, 3 3, 0 3, 0 0), \" +\n+                \"(1 1, 1 2, 2 2, 2 1, 1 1))\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON (\" +\n+                \"((1 1, 3 1, 3 3, 1 3, 1 1)), \" +\n+                \"((2 4, 6 4, 6 6, 2 6, 2 4)))\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION (\" +\n+                \"POINT (1 2), \" +\n+                \"LINESTRING (0 0, 1 2, 3 4), \" +\n+                \"POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0)))\");\n+\n+        // invalid geometries should return as is.\n+        assertGeoToAndFromJson(\"MULTIPOINT ((0 0), (0 1), (1 1), (0 1))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 0 1, 0 1, 1 1, 1 0, 0 0)\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 1, 1 0, 0 1)\");\n+\n+        // extra properties are stripped from JSON\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\" +\n+                \"\\\"coordinates\\\":[0,0], \\\"mykey\\\":\\\"myvalue\\\"}\", \"POINT (0 0)\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwNTUzOQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571705539", "bodyText": "nit: unused", "author": "phd3", "createdAt": "2021-02-07T21:51:45Z", "path": "plugin/trino-geospatial/src/test/java/io/trino/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,120 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()\n+    {\n+        // empty atomic (non-multi) geometries yield invalid json so instead are treated as exception cases\n+        assertInvalidToGeometryJson(\"POINT EMPTY\", \"Invalid GeoJSON: Empty Point not allowed.\");\n+        assertInvalidToGeometryJson(\"LINESTRING EMPTY\", \"Invalid GeoJSON: Empty LineString not allowed.\");\n+        assertInvalidToGeometryJson(\"POLYGON EMPTY\", \"Invalid GeoJSON: Empty Polygon not allowed.\");\n+\n+        // empty coordinate arrays yield inconsistent results so instead are treated as exception cases\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty Point not allowed.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty LineString not allowed.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty Polygon not allowed.\");\n+\n+        // empty multi geometries should return empty\n+        // empty multi-type values are represented by an empty JSON array in GeoJSON\n+        assertGeoToAndFromJson(\"MULTIPOINT EMPTY\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING EMPTY\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON EMPTY\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION EMPTY\");\n+\n+        // valid nonempty geometries should return as is.\n+        assertGeoToAndFromJson(\"POINT (1 2)\");\n+        assertGeoToAndFromJson(\"MULTIPOINT ((1 2), (3 4))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 2, 3 4)\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING (\" +\n+                \"(1 1, 5 1), \" +\n+                \"(2 4, 4 4))\");\n+        assertGeoToAndFromJson(\"POLYGON (\" +\n+                \"(0 0, 1 0, 1 1, 0 1, 0 0))\");\n+        assertGeoToAndFromJson(\"POLYGON (\" +\n+                \"(0 0, 3 0, 3 3, 0 3, 0 0), \" +\n+                \"(1 1, 1 2, 2 2, 2 1, 1 1))\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON (\" +\n+                \"((1 1, 3 1, 3 3, 1 3, 1 1)), \" +\n+                \"((2 4, 6 4, 6 6, 2 6, 2 4)))\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION (\" +\n+                \"POINT (1 2), \" +\n+                \"LINESTRING (0 0, 1 2, 3 4), \" +\n+                \"POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0)))\");\n+\n+        // invalid geometries should return as is.\n+        assertGeoToAndFromJson(\"MULTIPOINT ((0 0), (0 1), (1 1), (0 1))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 0 1, 0 1, 1 1, 1 0, 0 0)\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 1, 1 0, 0 1)\");\n+\n+        // extra properties are stripped from JSON\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\" +\n+                \"\\\"coordinates\\\":[0,0], \\\"mykey\\\":\\\"myvalue\\\"}\", \"POINT (0 0)\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\" +\n+                \"\\\"coordinates\\\":[0,0], \\\"mykey\\\":\\\"myvalue\\\"}\", \"POINT (0 0)\");\n+\n+        // explicit JSON test cases should valid but return empty\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\" +\n+                \"\\\"coordinates\\\":[]}\", \"MULTIPOINT EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPolygon\\\",\" +\n+                \"\\\"coordinates\\\":[]}\", \"MULTIPOLYGON EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiLineString\\\",\" +\n+                \"\\\"coordinates\\\":[[[0.0,0.0],[1,10]],[[10,10],[20,30]],[[123,123],[456,789]]]}\",\n+                \"MULTILINESTRING ((0 0, 1 10), (10 10, 20 30), (123 123, 456 789))\");\n+\n+        // Valid JSON with invalid Geometry definition\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Point\\\"}\",\n+                \"Invalid GeoJSON: Could not parse Point from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":null}\",\n+                \"Invalid GeoJSON: Could not parse LineString from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{ \\\"data\\\": {\\\"type\\\":\\\"Point\\\",\\\"coordinates\\\":[0,0]}}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from Json string.  No 'type' property found.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"invalidField\\\":[[10,10],[20,30]]}\",\n+                \"Invalid GeoJSON: Could not parse MultiPoint from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Feature\\\",\\\"geometry\\\":[],\\\"property\\\":\\\"foo\\\"}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from GeoJson string.  Unsupported 'type':Feature\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"FeatureCollection\\\",\\\"features\\\":[]}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from GeoJson string.  Unsupported 'type':FeatureCollection\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"missingCoordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Could not parse MultiPoint from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"coordinates\\\":[[[0.0,0.0],[1,10]],[[10,10],[20,30]],[[123,123],[456,789]]]}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from Json string.  No 'type' property found.\");\n+\n+        // Invalid JSON\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"crashMe\\\"}\",\n+                \"Invalid GeoJSON: Unexpected token RIGHT BRACE(}) at position 30.\");\n+    }\n+\n+    private void assertEmptyGeoToJson(String wkt)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwNTc2Ng==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571705766", "bodyText": "nit: unused", "author": "phd3", "createdAt": "2021-02-07T21:53:43Z", "path": "plugin/trino-geospatial/src/test/java/io/trino/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,120 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()\n+    {\n+        // empty atomic (non-multi) geometries yield invalid json so instead are treated as exception cases\n+        assertInvalidToGeometryJson(\"POINT EMPTY\", \"Invalid GeoJSON: Empty Point not allowed.\");\n+        assertInvalidToGeometryJson(\"LINESTRING EMPTY\", \"Invalid GeoJSON: Empty LineString not allowed.\");\n+        assertInvalidToGeometryJson(\"POLYGON EMPTY\", \"Invalid GeoJSON: Empty Polygon not allowed.\");\n+\n+        // empty coordinate arrays yield inconsistent results so instead are treated as exception cases\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty Point not allowed.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty LineString not allowed.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty Polygon not allowed.\");\n+\n+        // empty multi geometries should return empty\n+        // empty multi-type values are represented by an empty JSON array in GeoJSON\n+        assertGeoToAndFromJson(\"MULTIPOINT EMPTY\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING EMPTY\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON EMPTY\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION EMPTY\");\n+\n+        // valid nonempty geometries should return as is.\n+        assertGeoToAndFromJson(\"POINT (1 2)\");\n+        assertGeoToAndFromJson(\"MULTIPOINT ((1 2), (3 4))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 2, 3 4)\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING (\" +\n+                \"(1 1, 5 1), \" +\n+                \"(2 4, 4 4))\");\n+        assertGeoToAndFromJson(\"POLYGON (\" +\n+                \"(0 0, 1 0, 1 1, 0 1, 0 0))\");\n+        assertGeoToAndFromJson(\"POLYGON (\" +\n+                \"(0 0, 3 0, 3 3, 0 3, 0 0), \" +\n+                \"(1 1, 1 2, 2 2, 2 1, 1 1))\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON (\" +\n+                \"((1 1, 3 1, 3 3, 1 3, 1 1)), \" +\n+                \"((2 4, 6 4, 6 6, 2 6, 2 4)))\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION (\" +\n+                \"POINT (1 2), \" +\n+                \"LINESTRING (0 0, 1 2, 3 4), \" +\n+                \"POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0)))\");\n+\n+        // invalid geometries should return as is.\n+        assertGeoToAndFromJson(\"MULTIPOINT ((0 0), (0 1), (1 1), (0 1))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 0 1, 0 1, 1 1, 1 0, 0 0)\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 1, 1 0, 0 1)\");\n+\n+        // extra properties are stripped from JSON\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\" +\n+                \"\\\"coordinates\\\":[0,0], \\\"mykey\\\":\\\"myvalue\\\"}\", \"POINT (0 0)\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\" +\n+                \"\\\"coordinates\\\":[0,0], \\\"mykey\\\":\\\"myvalue\\\"}\", \"POINT (0 0)\");\n+\n+        // explicit JSON test cases should valid but return empty\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\" +\n+                \"\\\"coordinates\\\":[]}\", \"MULTIPOINT EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPolygon\\\",\" +\n+                \"\\\"coordinates\\\":[]}\", \"MULTIPOLYGON EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiLineString\\\",\" +\n+                \"\\\"coordinates\\\":[[[0.0,0.0],[1,10]],[[10,10],[20,30]],[[123,123],[456,789]]]}\",\n+                \"MULTILINESTRING ((0 0, 1 10), (10 10, 20 30), (123 123, 456 789))\");\n+\n+        // Valid JSON with invalid Geometry definition\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Point\\\"}\",\n+                \"Invalid GeoJSON: Could not parse Point from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":null}\",\n+                \"Invalid GeoJSON: Could not parse LineString from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{ \\\"data\\\": {\\\"type\\\":\\\"Point\\\",\\\"coordinates\\\":[0,0]}}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from Json string.  No 'type' property found.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"invalidField\\\":[[10,10],[20,30]]}\",\n+                \"Invalid GeoJSON: Could not parse MultiPoint from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Feature\\\",\\\"geometry\\\":[],\\\"property\\\":\\\"foo\\\"}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from GeoJson string.  Unsupported 'type':Feature\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"FeatureCollection\\\",\\\"features\\\":[]}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from GeoJson string.  Unsupported 'type':FeatureCollection\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"missingCoordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Could not parse MultiPoint from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"coordinates\\\":[[[0.0,0.0],[1,10]],[[10,10],[20,30]],[[123,123],[456,789]]]}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from Json string.  No 'type' property found.\");\n+\n+        // Invalid JSON\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"crashMe\\\"}\",\n+                \"Invalid GeoJSON: Unexpected token RIGHT BRACE(}) at position 30.\");\n+    }\n+\n+    private void assertEmptyGeoToJson(String wkt)\n+    {\n+        assertFunction(format(\"to_geojson_geometry(to_spherical_geography(ST_GeometryFromText('%s')))\", wkt), VARCHAR, null);\n+    }\n+\n+    private void assertGeoToAndFromJson(String wkt)\n+    {\n+        assertFunction(format(\"ST_AsText(to_geometry(from_geojson_geometry(to_geojson_geometry(to_spherical_geography(ST_GeometryFromText('%s'))))))\", wkt), VARCHAR, wkt);\n+    }\n+\n+    private void assertValidGeometryJson(String json, String wkt)\n+    {\n+        assertFunction(\"ST_AsText(to_geometry(from_geojson_geometry('\" + json + \"')))\", VARCHAR, wkt);\n+    }\n+\n+    private void assertValidGeometry(String wkt, String json)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwNjA3NQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571706075", "bodyText": "nit: assertInvalidGeoJson and assertValidGeoJson?", "author": "phd3", "createdAt": "2021-02-07T21:56:16Z", "path": "plugin/trino-geospatial/src/test/java/io/trino/plugin/geospatial/TestGeoFunctions.java", "diffHunk": "@@ -1407,4 +1407,120 @@ private void assertGeometryFromHadoopShape(String hadoopHex, String expectedWkt)\n     {\n         assertFunction(format(\"ST_AsText(geometry_from_hadoop_shape(from_hex('%s')))\", hadoopHex), VARCHAR, expectedWkt);\n     }\n+\n+    @Test\n+    public void testGeometryJsonConversion()\n+    {\n+        // empty atomic (non-multi) geometries yield invalid json so instead are treated as exception cases\n+        assertInvalidToGeometryJson(\"POINT EMPTY\", \"Invalid GeoJSON: Empty Point not allowed.\");\n+        assertInvalidToGeometryJson(\"LINESTRING EMPTY\", \"Invalid GeoJSON: Empty LineString not allowed.\");\n+        assertInvalidToGeometryJson(\"POLYGON EMPTY\", \"Invalid GeoJSON: Empty Polygon not allowed.\");\n+\n+        // empty coordinate arrays yield inconsistent results so instead are treated as exception cases\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty Point not allowed.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty LineString not allowed.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Polygon\\\",\\\"coordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Empty Polygon not allowed.\");\n+\n+        // empty multi geometries should return empty\n+        // empty multi-type values are represented by an empty JSON array in GeoJSON\n+        assertGeoToAndFromJson(\"MULTIPOINT EMPTY\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING EMPTY\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON EMPTY\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION EMPTY\");\n+\n+        // valid nonempty geometries should return as is.\n+        assertGeoToAndFromJson(\"POINT (1 2)\");\n+        assertGeoToAndFromJson(\"MULTIPOINT ((1 2), (3 4))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 2, 3 4)\");\n+        assertGeoToAndFromJson(\"MULTILINESTRING (\" +\n+                \"(1 1, 5 1), \" +\n+                \"(2 4, 4 4))\");\n+        assertGeoToAndFromJson(\"POLYGON (\" +\n+                \"(0 0, 1 0, 1 1, 0 1, 0 0))\");\n+        assertGeoToAndFromJson(\"POLYGON (\" +\n+                \"(0 0, 3 0, 3 3, 0 3, 0 0), \" +\n+                \"(1 1, 1 2, 2 2, 2 1, 1 1))\");\n+        assertGeoToAndFromJson(\"MULTIPOLYGON (\" +\n+                \"((1 1, 3 1, 3 3, 1 3, 1 1)), \" +\n+                \"((2 4, 6 4, 6 6, 2 6, 2 4)))\");\n+        assertGeoToAndFromJson(\"GEOMETRYCOLLECTION (\" +\n+                \"POINT (1 2), \" +\n+                \"LINESTRING (0 0, 1 2, 3 4), \" +\n+                \"POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0)))\");\n+\n+        // invalid geometries should return as is.\n+        assertGeoToAndFromJson(\"MULTIPOINT ((0 0), (0 1), (1 1), (0 1))\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 0 1, 0 1, 1 1, 1 0, 0 0)\");\n+        assertGeoToAndFromJson(\"LINESTRING (0 0, 1 1, 1 0, 0 1)\");\n+\n+        // extra properties are stripped from JSON\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\" +\n+                \"\\\"coordinates\\\":[0,0], \\\"mykey\\\":\\\"myvalue\\\"}\", \"POINT (0 0)\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"Point\\\",\" +\n+                \"\\\"coordinates\\\":[0,0], \\\"mykey\\\":\\\"myvalue\\\"}\", \"POINT (0 0)\");\n+\n+        // explicit JSON test cases should valid but return empty\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\" +\n+                \"\\\"coordinates\\\":[]}\", \"MULTIPOINT EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiPolygon\\\",\" +\n+                \"\\\"coordinates\\\":[]}\", \"MULTIPOLYGON EMPTY\");\n+        assertValidGeometryJson(\"{\\\"type\\\":\\\"MultiLineString\\\",\" +\n+                \"\\\"coordinates\\\":[[[0.0,0.0],[1,10]],[[10,10],[20,30]],[[123,123],[456,789]]]}\",\n+                \"MULTILINESTRING ((0 0, 1 10), (10 10, 20 30), (123 123, 456 789))\");\n+\n+        // Valid JSON with invalid Geometry definition\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Point\\\"}\",\n+                \"Invalid GeoJSON: Could not parse Point from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"LineString\\\",\\\"coordinates\\\":null}\",\n+                \"Invalid GeoJSON: Could not parse LineString from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{ \\\"data\\\": {\\\"type\\\":\\\"Point\\\",\\\"coordinates\\\":[0,0]}}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from Json string.  No 'type' property found.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"invalidField\\\":[[10,10],[20,30]]}\",\n+                \"Invalid GeoJSON: Could not parse MultiPoint from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"Feature\\\",\\\"geometry\\\":[],\\\"property\\\":\\\"foo\\\"}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from GeoJson string.  Unsupported 'type':Feature\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"FeatureCollection\\\",\\\"features\\\":[]}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from GeoJson string.  Unsupported 'type':FeatureCollection\");\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"missingCoordinates\\\":[]}\",\n+                \"Invalid GeoJSON: Could not parse MultiPoint from GeoJson string.\");\n+        assertInvalidGeometryJson(\"{\\\"coordinates\\\":[[[0.0,0.0],[1,10]],[[10,10],[20,30]],[[123,123],[456,789]]]}\",\n+                \"Invalid GeoJSON: Could not parse Geometry from Json string.  No 'type' property found.\");\n+\n+        // Invalid JSON\n+        assertInvalidGeometryJson(\"{\\\"type\\\":\\\"MultiPoint\\\",\\\"crashMe\\\"}\",\n+                \"Invalid GeoJSON: Unexpected token RIGHT BRACE(}) at position 30.\");\n+    }\n+\n+    private void assertEmptyGeoToJson(String wkt)\n+    {\n+        assertFunction(format(\"to_geojson_geometry(to_spherical_geography(ST_GeometryFromText('%s')))\", wkt), VARCHAR, null);\n+    }\n+\n+    private void assertGeoToAndFromJson(String wkt)\n+    {\n+        assertFunction(format(\"ST_AsText(to_geometry(from_geojson_geometry(to_geojson_geometry(to_spherical_geography(ST_GeometryFromText('%s'))))))\", wkt), VARCHAR, wkt);\n+    }\n+\n+    private void assertValidGeometryJson(String json, String wkt)\n+    {\n+        assertFunction(\"ST_AsText(to_geometry(from_geojson_geometry('\" + json + \"')))\", VARCHAR, wkt);\n+    }\n+\n+    private void assertValidGeometry(String wkt, String json)\n+    {\n+        assertFunction(format(\"to_geojson_geometry(to_spherical_geography(ST_GeometryFromText('%s')))\", wkt), VARCHAR, json);\n+    }\n+\n+    private void assertInvalidGeometryJson(String json, String message)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwNzYwNQ==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571707605", "bodyText": "nit: add comment for ignoring the exception", "author": "phd3", "createdAt": "2021-02-07T22:07:53Z", "path": "lib/trino-geospatial-toolkit/src/main/java/io/trino/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +177,56 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)\n+    {\n+        verifyNonEmptyCoordinatesForAtomicTypes(json);\n+        try {\n+            return new GeoJsonReader().read(json);\n+        }\n+        catch (ParseException | IllegalArgumentException e) {\n+            throw new TrinoException(INVALID_FUNCTION_ARGUMENT, \"Invalid GeoJSON: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Throws if json has empty coordinates for atomic type (Point, LineString, and Polygon).\n+     * This is due to the inconsistent behavior in the locationtech library not returning\n+     * an EMPTY type, but instead doing the following:\n+     * {type:Point, coordinates:[]} -> POINT (0 0)\n+     * {type:LineString, coordinates[]} -> LINESTRING EMPTY\n+     * {type:Polygon, coordinates[]} -> Exception during parsing\n+     *\n+     * @param json\n+     * @throws TrinoException\n+     */\n+    private static void verifyNonEmptyCoordinatesForAtomicTypes(String json)\n+    {\n+        try {\n+            JsonNode jsonNode = OBJECT_MAPPER.readTree(json);\n+            JsonNode typeNode = jsonNode.get(TYPE_ATTRIB);\n+            if (typeNode != null) {\n+                String type = typeNode.textValue();\n+                if (ATOMIC_GEOMETRY_TYPES.contains(type)) {\n+                    JsonNode coordinatesNode = jsonNode.get(COORDINATES_ATTRIB);\n+                    if (coordinatesNode != null && coordinatesNode.isArray() && coordinatesNode.isEmpty()) {\n+                        throw new TrinoException(INVALID_FUNCTION_ARGUMENT, format(\"Invalid GeoJSON: Empty %s not allowed.\", type));\n+                    }\n+                }\n+            }\n+        }\n+        catch (JsonProcessingException e) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTcwODAwOA==", "url": "https://github.com/trinodb/trino/pull/6355#discussion_r571708008", "bodyText": "nit: since GeoJSON is the output here, may be change Invalid GeoJSON to Unsupported input in error message?", "author": "phd3", "createdAt": "2021-02-07T22:10:56Z", "path": "lib/trino-geospatial-toolkit/src/main/java/io/trino/geospatial/GeometryUtils.java", "diffHunk": "@@ -160,4 +177,56 @@ public static boolean isPointOrRectangle(OGCGeometry ogcGeometry, Envelope envel\n \n         return true;\n     }\n+\n+    public static org.locationtech.jts.geom.Geometry jtsGeometryFromJson(String json)\n+    {\n+        verifyNonEmptyCoordinatesForAtomicTypes(json);\n+        try {\n+            return new GeoJsonReader().read(json);\n+        }\n+        catch (ParseException | IllegalArgumentException e) {\n+            throw new TrinoException(INVALID_FUNCTION_ARGUMENT, \"Invalid GeoJSON: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Throws if json has empty coordinates for atomic type (Point, LineString, and Polygon).\n+     * This is due to the inconsistent behavior in the locationtech library not returning\n+     * an EMPTY type, but instead doing the following:\n+     * {type:Point, coordinates:[]} -> POINT (0 0)\n+     * {type:LineString, coordinates[]} -> LINESTRING EMPTY\n+     * {type:Polygon, coordinates[]} -> Exception during parsing\n+     *\n+     * @param json\n+     * @throws TrinoException\n+     */\n+    private static void verifyNonEmptyCoordinatesForAtomicTypes(String json)\n+    {\n+        try {\n+            JsonNode jsonNode = OBJECT_MAPPER.readTree(json);\n+            JsonNode typeNode = jsonNode.get(TYPE_ATTRIB);\n+            if (typeNode != null) {\n+                String type = typeNode.textValue();\n+                if (ATOMIC_GEOMETRY_TYPES.contains(type)) {\n+                    JsonNode coordinatesNode = jsonNode.get(COORDINATES_ATTRIB);\n+                    if (coordinatesNode != null && coordinatesNode.isArray() && coordinatesNode.isEmpty()) {\n+                        throw new TrinoException(INVALID_FUNCTION_ARGUMENT, format(\"Invalid GeoJSON: Empty %s not allowed.\", type));\n+                    }\n+                }\n+            }\n+        }\n+        catch (JsonProcessingException e) {\n+        }\n+    }\n+\n+    public static Optional<String> jsonFromJtsGeometry(org.locationtech.jts.geom.Geometry geometry)\n+    {\n+        // Throw if empty atomic type instead of returning invalid JSON in the form:\n+        // {type:Point, coordinates:, ...}\n+        if (ATOMIC_GEOMETRY_TYPES.contains(geometry.getGeometryType()) && geometry.isEmpty()) {\n+            throw new TrinoException(INVALID_FUNCTION_ARGUMENT, format(\"Invalid GeoJSON: Empty %s not allowed.\", geometry.getGeometryType()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "0309b05d8306fcf9bfbb885a71587cd510e68292", "url": "https://github.com/trinodb/trino/commit/0309b05d8306fcf9bfbb885a71587cd510e68292", "message": "Add functions to_geojson_geometry and from_geojson_geometry\n\nCo-authored-by: Rong Rong <rongr@fb.com>", "committedDate": "2021-02-09T20:45:13Z", "type": "commit"}, {"oid": "0309b05d8306fcf9bfbb885a71587cd510e68292", "url": "https://github.com/trinodb/trino/commit/0309b05d8306fcf9bfbb885a71587cd510e68292", "message": "Add functions to_geojson_geometry and from_geojson_geometry\n\nCo-authored-by: Rong Rong <rongr@fb.com>", "committedDate": "2021-02-09T20:45:13Z", "type": "forcePushed"}]}