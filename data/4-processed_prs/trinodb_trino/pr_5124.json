{"pr_number": 5124, "pr_title": "Add support for precision for TIMESTAMP in Postgresql type mapping", "pr_createdAt": "2020-09-09T20:44:19Z", "pr_url": "https://github.com/trinodb/trino/pull/5124", "timeline": [{"oid": "5a6a07ebf85a05a62c17fd8164f3b763f77cfac6", "url": "https://github.com/trinodb/trino/commit/5a6a07ebf85a05a62c17fd8164f3b763f77cfac6", "message": "Remove redundant cast", "committedDate": "2020-09-09T20:41:24Z", "type": "commit"}, {"oid": "65fd8511eebe81d937b926ff6919ef10f93d6a23", "url": "https://github.com/trinodb/trino/commit/65fd8511eebe81d937b926ff6919ef10f93d6a23", "message": "Do not use raw parametrized type", "committedDate": "2020-09-09T20:41:24Z", "type": "commit"}, {"oid": "12c690670d8d0274a58a34b0878a0fb3ab228b4d", "url": "https://github.com/trinodb/trino/commit/12c690670d8d0274a58a34b0878a0fb3ab228b4d", "message": "Remove not needed annotations", "committedDate": "2020-09-09T20:41:24Z", "type": "commit"}, {"oid": "631f5aad0c932829f1c8a43a04e38068ebe8544c", "url": "https://github.com/trinodb/trino/commit/631f5aad0c932829f1c8a43a04e38068ebe8544c", "message": "Rename method paremeter to express its meaning", "committedDate": "2020-09-09T20:42:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0MzI5OQ==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486143299", "bodyText": "I would rather drop this commit.\nThe added burden of an overload is not justified for arguably small benefit this brings.", "author": "findepi", "createdAt": "2020-09-10T08:02:25Z", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/PostgreSqlQueryRunner.java", "diffHunk": "@@ -49,11 +49,23 @@ public static DistributedQueryRunner createPostgreSqlQueryRunner(\n             Map<String, String> connectorProperties,\n             Iterable<TpchTable<?>> tables)\n             throws Exception\n+    {\n+        return createPostgreSqlQueryRunner(server, extraProperties, connectorProperties, tables, 3);\n+    }\n+\n+    public static DistributedQueryRunner createPostgreSqlQueryRunner(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0Mzk1OA==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486143958", "bodyText": "The cmt title is\n\nRename misleading testTimestampWithTimeZoneDataProvider\n\nit's removal not \"rename\"\n\"misleading\" is misleading. It was very nicely called \"DataProvider\", i do not find anything misleading in that and next time would call it the same.", "author": "findepi", "createdAt": "2020-09-10T08:03:31Z", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1199,15 +1200,6 @@ public void testArrayTimestampWithTimeZone(boolean insertWithPresto)\n         tests.execute(getQueryRunner(), sessionWithArrayAsArray(), dataSetup);\n     }\n \n-    @DataProvider\n-    public Object[][] testTimestampWithTimeZoneDataProvider()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MDAxMA==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486190010", "bodyText": "Changed to \"Use generic trueFalse data provider for timestamp tests\"", "author": "losipiuk", "createdAt": "2020-09-10T09:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0Mzk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0ODE5MQ==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486148191", "bodyText": "if timestampType.precision < 6, you need to round/truncate here\n@martint what is the correct way to do this?\nthere are some utility methods in io.prestosql.spi.type.Timestamps, but I do not see something that's immediately applicable.", "author": "findepi", "createdAt": "2020-09-10T08:09:59Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0ODc1MA==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486148750", "bodyText": "You do not really need to validate this here. If someone provided epochMicros, it;'s all you need.", "author": "findepi", "createdAt": "2020-09-10T08:10:54Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);\n     }\n \n-    public static LocalDateTime fromPrestoTimestamp(long value)\n+    public static LocalDateTime fromPrestoTimestamp(TimestampType timestampType, long epochMicros)\n     {\n-        return Instant.ofEpochMilli(floorDiv(value, MICROSECONDS_PER_MILLISECOND)).atZone(UTC).toLocalDateTime();\n+        int precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION && precision >= 0, \"Precision is out of range: %s\", precision);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MDE5MQ==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486150191", "bodyText": "we could unify & reuse with io.prestosql.spi.type.Timestamps#formatTimestamp(int precision, long epochMicros, int picosOfMicro)", "author": "findepi", "createdAt": "2020-09-10T08:13:14Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/StandardColumnMappings.java", "diffHunk": "@@ -382,24 +397,34 @@ public static LongReadFunction timestampReadFunction()\n      * {@link #timestampWriteFunction} instead.\n      */\n     @Deprecated\n-    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp()\n+    public static LongWriteFunction timestampWriteFunctionUsingSqlTimestamp(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(value)));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setTimestamp(index, Timestamp.valueOf(fromPrestoTimestamp(timestampType, value)));\n     }\n \n-    public static LongWriteFunction timestampWriteFunction()\n+    public static LongWriteFunction timestampWriteFunction(TimestampType timestampType)\n     {\n-        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(value));\n+        checkArgument(timestampType.getPrecision() <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", timestampType.getPrecision());\n+        return (statement, index, value) -> statement.setObject(index, fromPrestoTimestamp(timestampType, value));\n     }\n \n-    public static long toPrestoTimestamp(LocalDateTime localDateTime)\n+    public static long toPrestoTimestamp(TimestampType timestampType, LocalDateTime localDateTime)\n     {\n-        return localDateTime.atZone(UTC).toInstant().toEpochMilli() * MICROSECONDS_PER_MILLISECOND;\n+        long precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION, \"Precision is out of range: %s\", precision);\n+        Instant instant = localDateTime.atZone(UTC).toInstant();\n+        return instant.getEpochSecond() * MICROSECONDS_PER_SECOND + roundDiv(instant.getNano(), NANOSECONDS_PER_MICROSECOND);\n     }\n \n-    public static LocalDateTime fromPrestoTimestamp(long value)\n+    public static LocalDateTime fromPrestoTimestamp(TimestampType timestampType, long epochMicros)\n     {\n-        return Instant.ofEpochMilli(floorDiv(value, MICROSECONDS_PER_MILLISECOND)).atZone(UTC).toLocalDateTime();\n+        int precision = timestampType.getPrecision();\n+        checkArgument(precision <= MAX_SHORT_PRECISION && precision >= 0, \"Precision is out of range: %s\", precision);\n+        long epochSecond = floorDiv(epochMicros, MICROSECONDS_PER_SECOND);\n+        int nanoFraction = floorMod(epochMicros, MICROSECONDS_PER_SECOND) * NANOSECONDS_PER_MICROSECOND;\n+        Instant instant = Instant.ofEpochSecond(epochSecond, nanoFraction);\n+        return LocalDateTime.ofInstant(instant, UTC);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMDA0Mg==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486200042", "bodyText": "We could but I am not sure if we could extend spi with random methods. We should keep it fairly stable. Also the spi methods cares about picosOfMicro which we do not care about here. With picosOfMicro you cannot create a method which just returns LocalDateTime, which we need here. And have a specific method version which does not take picosOfSeconds and returns LocalDateTime seems to specific to me, to be put in spi.", "author": "losipiuk", "createdAt": "2020-09-10T09:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MDE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MDU0NA==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486150544", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp(TIMESTAMP));\n          \n          \n            \n                        return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp(TIMESTAMP_MILLIS));", "author": "findepi", "createdAt": "2020-09-10T08:13:48Z", "path": "presto-mysql/src/main/java/io/prestosql/plugin/mysql/MySqlClient.java", "diffHunk": "@@ -262,7 +262,7 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n         }\n         if (TIMESTAMP_MILLIS.equals(type)) {\n             // TODO use `timestampWriteFunction`\n-            return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp());\n+            return WriteMapping.longMapping(\"datetime\", timestampWriteFunctionUsingSqlTimestamp(TIMESTAMP));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MzI1Mg==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486153252", "bodyText": "\"TIMESTAMP WITH TIME ZONE\"\nalso, is 3 and 6 actually different cases?\ni think in timestamp case, we go with the same code path\n(ok to leave the test coverage, but if true, change the commnt)", "author": "findepi", "createdAt": "2020-09-10T08:18:15Z", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1005,24 +1005,38 @@ public void testTime(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        // using two non-JVM zones so that we don't need to worry what Postgres system zone is\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(timestampDataType(), beforeEpoch)\n-                .addRoundTrip(timestampDataType(), afterEpoch)\n-                .addRoundTrip(timestampDataType(), timeDoubledInJvmZone)\n-                .addRoundTrip(timestampDataType(), timeDoubledInVilnius)\n-                .addRoundTrip(timestampDataType(), epoch) // epoch also is a gap in JVM zone\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone1)\n-                .addRoundTrip(timestampDataType(), timeGapInJvmZone2)\n-                .addRoundTrip(timestampDataType(), timeGapInVilnius)\n-                .addRoundTrip(timestampDataType(), timeGapInKathmandu);\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwODE2Ng==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486208166", "bodyText": "Oh - you noticed it too - yeah - it same case. I dropped the coverage.", "author": "losipiuk", "createdAt": "2020-09-10T09:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MzI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NDYwNw==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486154607", "bodyText": "this belong to Simplify flow in timestamp with timezone mapping tests commit?", "author": "findepi", "createdAt": "2020-09-10T08:20:28Z", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1032,32 +1046,50 @@ public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testArrayTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        DataType<List<LocalDateTime>> dataType;\n-        DataSetup dataSetup;\n-        if (insertWithPresto) {\n-            dataType = arrayDataType(timestampDataType());\n-            dataSetup = prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\");\n-        }\n-        else {\n-            dataType = arrayDataType(timestampDataType(), \"timestamp[]\");\n-            dataSetup = postgresCreateAndInsert(\"tpch.test_array_timestamp\");\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {\n+            // test all standard cases with precision 3 and 6 to make sure the long and short TIMESTAMP WITH TIME ZONE\n+            // is gap friendly.\n+            DataType<List<LocalDateTime>> dataType = arrayOfTimestampDataType(precision, insertWithPresto);\n+            tests.addRoundTrip(dataType, asList(beforeEpoch));\n+            tests.addRoundTrip(dataType, asList(afterEpoch));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInJvmZone));\n+            tests.addRoundTrip(dataType, asList(timeDoubledInVilnius));\n+            tests.addRoundTrip(dataType, asList(epoch));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone1));\n+            tests.addRoundTrip(dataType, asList(timeGapInJvmZone2));\n+            tests.addRoundTrip(dataType, asList(timeGapInVilnius));\n+            tests.addRoundTrip(dataType, asList(timeGapInKathmandu));\n         }\n-        DataTypeTest tests = DataTypeTest.create(true)\n-                .addRoundTrip(dataType, asList(beforeEpoch))\n-                .addRoundTrip(dataType, asList(afterEpoch))\n-                .addRoundTrip(dataType, asList(timeDoubledInJvmZone))\n-                .addRoundTrip(dataType, asList(timeDoubledInVilnius))\n-                .addRoundTrip(dataType, asList(epoch))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone1))\n-                .addRoundTrip(dataType, asList(timeGapInJvmZone2))\n-                .addRoundTrip(dataType, asList(timeGapInVilnius))\n-                .addRoundTrip(dataType, asList(timeGapInKathmandu));\n+\n+        // test arbitrary time for all supported precisions\n+        tests.addRoundTrip(arrayOfTimestampDataType(1, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 100_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(2, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 120_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(3, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_000_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(4, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_400_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(5, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_450_000)));\n+        tests.addRoundTrip(arrayOfTimestampDataType(6, insertWithPresto), asList(LocalDateTime.of(1970, 1, 1, 1, 1, 1, 123_456_000)));\n \n         Session session = Session.builder(sessionWithArrayAsArray())\n                 .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(sessionZone.getId()))\n                 .build();\n \n-        tests.execute(getQueryRunner(), session, dataSetup);\n+        if (insertWithPresto) {\n+            tests.execute(getQueryRunner(), session, prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\"));\n+        }\n+        else {\n+            tests.execute(getQueryRunner(), session, postgresCreateAndInsert(\"tpch.test_array_timestamp\"));\n+        }\n+    }\n+\n+    private DataType<List<LocalDateTime>> arrayOfTimestampDataType(int precision, boolean insertWithPresto)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMjkwMw==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486202903", "bodyText": "no. This is specific to TIMESTAMP not TIMESTAMP w/TZ. So it belongs to last commit.", "author": "losipiuk", "createdAt": "2020-09-10T09:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NDYwNw=="}], "type": "inlineReview"}, {"oid": "7b58796e1fcc17adaaa722e8bf9a9a10cfdf7cc3", "url": "https://github.com/trinodb/trino/commit/7b58796e1fcc17adaaa722e8bf9a9a10cfdf7cc3", "message": "Use generic trueFalse data provider for timestamp tests", "committedDate": "2020-09-10T09:16:02Z", "type": "commit"}, {"oid": "570a5699e1046cd7772ca46611688307ce50adff", "url": "https://github.com/trinodb/trino/commit/570a5699e1046cd7772ca46611688307ce50adff", "message": "Simplify flow in timestamp with timezone mapping tests", "committedDate": "2020-09-10T09:16:27Z", "type": "commit"}, {"oid": "91875da84e897aacb2c9aac09b0fe885745606b8", "url": "https://github.com/trinodb/trino/commit/91875da84e897aacb2c9aac09b0fe885745606b8", "message": "Inline addArrayTimestampTestIfSupported", "committedDate": "2020-09-10T09:16:27Z", "type": "commit"}, {"oid": "e7fdfe30707ab52826fdb1b177dde2d989497d5e", "url": "https://github.com/trinodb/trino/commit/e7fdfe30707ab52826fdb1b177dde2d989497d5e", "message": "Add support for precision for TIMESTAMP in PostgreSQL type mapping\n\nAdd support for mapping TIMESTAMP from Presto to\nPostgreSQL (and vice versa) for precisions 1 to 6. It covers all\nprecisions currently supported by PostgreSQL.", "committedDate": "2020-09-10T09:42:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjIwMzI1MA==", "url": "https://github.com/trinodb/trino/pull/5124#discussion_r486203250", "bodyText": "I will drop this for. As representation is same for 3 and 6 for TIMESTAMP", "author": "losipiuk", "createdAt": "2020-09-10T09:38:19Z", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1032,32 +1046,50 @@ public void testTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     @Test(dataProvider = \"testTimestampDataProvider\")\n     public void testArrayTimestamp(boolean insertWithPresto, ZoneId sessionZone)\n     {\n-        DataType<List<LocalDateTime>> dataType;\n-        DataSetup dataSetup;\n-        if (insertWithPresto) {\n-            dataType = arrayDataType(timestampDataType());\n-            dataSetup = prestoCreateAsSelect(sessionWithArrayAsArray(), \"test_array_timestamp\");\n-        }\n-        else {\n-            dataType = arrayDataType(timestampDataType(), \"timestamp[]\");\n-            dataSetup = postgresCreateAndInsert(\"tpch.test_array_timestamp\");\n+        DataTypeTest tests = DataTypeTest.create(true);\n+        for (int precision : List.of(3, 6)) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e7fdfe30707ab52826fdb1b177dde2d989497d5e", "url": "https://github.com/trinodb/trino/commit/e7fdfe30707ab52826fdb1b177dde2d989497d5e", "message": "Add support for precision for TIMESTAMP in PostgreSQL type mapping\n\nAdd support for mapping TIMESTAMP from Presto to\nPostgreSQL (and vice versa) for precisions 1 to 6. It covers all\nprecisions currently supported by PostgreSQL.", "committedDate": "2020-09-10T09:42:49Z", "type": "forcePushed"}]}