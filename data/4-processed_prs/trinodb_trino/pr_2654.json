{"pr_number": 2654, "pr_title": "Add column-pruning rules for ApplyNode", "pr_createdAt": "2020-01-28T17:57:12Z", "pr_url": "https://github.com/trinodb/trino/pull/2654", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE0NjkwNA==", "url": "https://github.com/trinodb/trino/pull/2654#discussion_r372146904", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ImmutableList<Symbol> newCorrelation = applyNode.getCorrelation().stream()\n          \n          \n            \n                    List<Symbol> newCorrelation = applyNode.getCorrelation().stream()", "author": "Praveen2112", "createdAt": "2020-01-29T01:23:04Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneApplyColumns.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.plan.ApplyNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.intersection;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractUnique;\n+import static io.prestosql.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.prestosql.sql.planner.plan.Patterns.applyNode;\n+\n+/**\n+ * This rule restricts the outputs of ApplyNode's input and subquery\n+ * based on which ApplyNode's output symbols are referenced.\n+ * <p>\n+ * A symbol from input source can be pruned, when\n+ * - it is not a referenced output symbol\n+ * - it is not a correlation symbol\n+ * - it is not referenced in subqueryAssignments\n+ * <p>\n+ * A symbol from subquery source can be pruned, when\n+ * it is not referenced in subqueryAssignments.\n+ * <p>\n+ * A subquery assignment can be removed, when\n+ * its key is not a referenced output symbol.\n+ * <p>\n+ * A symbol can be removed from the correlation list, when\n+ * it is no longer present in the subquery.\n+ * <p>\n+ * Note: this rule does not remove any symbols from the subquery.\n+ * However, the correlated symbol might have been removed from\n+ * the subquery by another rule. This rule checks it so that it can\n+ * update the correlation list and take the advantage of\n+ * pruning the symbol if it is not referenced.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - Project (i1, r1)\n+ *      - Apply\n+ *          correlation: [corr]\n+ *          assignments:\n+ *              r1 -> a in s1,\n+ *              r2 -> b in s2,\n+ *          - Input (a, b, corr)\n+ *          - Subquery (s1, s2)\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Project (i1, r1)\n+ *      - Apply\n+ *          correlation: []\n+ *          assignments:\n+ *              r1 -> a in s1,\n+ *          - Project (a)\n+ *              - Input (a, b, corr)\n+ *          - Project (s1)\n+ *              - Subquery (s1, s2)\n+ * </pre>\n+ */\n+public class PruneApplyColumns\n+        extends ProjectOffPushDownRule<ApplyNode>\n+{\n+    public PruneApplyColumns()\n+    {\n+        super(applyNode());\n+    }\n+\n+    @Override\n+    protected Optional<PlanNode> pushDownProjectOff(\n+            Context context,\n+            ApplyNode applyNode,\n+            Set<Symbol> referencedOutputs)\n+    {\n+        // remove unused apply node\n+        if (intersection(applyNode.getSubqueryAssignments().getSymbols(), referencedOutputs).isEmpty()) {\n+            return Optional.of(applyNode.getInput());\n+        }\n+\n+        // extract referenced assignments\n+        ImmutableSet.Builder<Symbol> requiredSubquerySymbols = ImmutableSet.builder();\n+        Assignments.Builder newSubqueryAssignments = Assignments.builder();\n+        for (Map.Entry<Symbol, Expression> entry : applyNode.getSubqueryAssignments().entrySet()) {\n+            if (referencedOutputs.contains(entry.getKey())) {\n+                requiredSubquerySymbols.addAll(extractUnique(entry.getValue()));\n+                newSubqueryAssignments.put(entry);\n+            }\n+        }\n+\n+        // prune subquery symbols\n+        Optional<PlanNode> newSubquery = restrictOutputs(context.getIdAllocator(), applyNode.getSubquery(), requiredSubquerySymbols.build());\n+\n+        // extract actual correlation symbols\n+        ImmutableList<Symbol> newCorrelation = applyNode.getCorrelation().stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE0NzMzOA==", "url": "https://github.com/trinodb/trino/pull/2654#discussion_r372147338", "bodyText": "Can we extract the Unique symbols once and check it ?", "author": "Praveen2112", "createdAt": "2020-01-29T01:24:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneApplyColumns.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.plan.ApplyNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.intersection;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractUnique;\n+import static io.prestosql.sql.planner.iterative.rule.Util.restrictOutputs;\n+import static io.prestosql.sql.planner.plan.Patterns.applyNode;\n+\n+/**\n+ * This rule restricts the outputs of ApplyNode's input and subquery\n+ * based on which ApplyNode's output symbols are referenced.\n+ * <p>\n+ * A symbol from input source can be pruned, when\n+ * - it is not a referenced output symbol\n+ * - it is not a correlation symbol\n+ * - it is not referenced in subqueryAssignments\n+ * <p>\n+ * A symbol from subquery source can be pruned, when\n+ * it is not referenced in subqueryAssignments.\n+ * <p>\n+ * A subquery assignment can be removed, when\n+ * its key is not a referenced output symbol.\n+ * <p>\n+ * A symbol can be removed from the correlation list, when\n+ * it is no longer present in the subquery.\n+ * <p>\n+ * Note: this rule does not remove any symbols from the subquery.\n+ * However, the correlated symbol might have been removed from\n+ * the subquery by another rule. This rule checks it so that it can\n+ * update the correlation list and take the advantage of\n+ * pruning the symbol if it is not referenced.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - Project (i1, r1)\n+ *      - Apply\n+ *          correlation: [corr]\n+ *          assignments:\n+ *              r1 -> a in s1,\n+ *              r2 -> b in s2,\n+ *          - Input (a, b, corr)\n+ *          - Subquery (s1, s2)\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Project (i1, r1)\n+ *      - Apply\n+ *          correlation: []\n+ *          assignments:\n+ *              r1 -> a in s1,\n+ *          - Project (a)\n+ *              - Input (a, b, corr)\n+ *          - Project (s1)\n+ *              - Subquery (s1, s2)\n+ * </pre>\n+ */\n+public class PruneApplyColumns\n+        extends ProjectOffPushDownRule<ApplyNode>\n+{\n+    public PruneApplyColumns()\n+    {\n+        super(applyNode());\n+    }\n+\n+    @Override\n+    protected Optional<PlanNode> pushDownProjectOff(\n+            Context context,\n+            ApplyNode applyNode,\n+            Set<Symbol> referencedOutputs)\n+    {\n+        // remove unused apply node\n+        if (intersection(applyNode.getSubqueryAssignments().getSymbols(), referencedOutputs).isEmpty()) {\n+            return Optional.of(applyNode.getInput());\n+        }\n+\n+        // extract referenced assignments\n+        ImmutableSet.Builder<Symbol> requiredSubquerySymbols = ImmutableSet.builder();\n+        Assignments.Builder newSubqueryAssignments = Assignments.builder();\n+        for (Map.Entry<Symbol, Expression> entry : applyNode.getSubqueryAssignments().entrySet()) {\n+            if (referencedOutputs.contains(entry.getKey())) {\n+                requiredSubquerySymbols.addAll(extractUnique(entry.getValue()));\n+                newSubqueryAssignments.put(entry);\n+            }\n+        }\n+\n+        // prune subquery symbols\n+        Optional<PlanNode> newSubquery = restrictOutputs(context.getIdAllocator(), applyNode.getSubquery(), requiredSubquerySymbols.build());\n+\n+        // extract actual correlation symbols\n+        ImmutableList<Symbol> newCorrelation = applyNode.getCorrelation().stream()\n+                .filter(symbol -> extractUnique(newSubquery.orElse(applyNode.getSubquery()), context.getLookup()).contains(symbol))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "f3b984e6776d1a44dd19f81010978cee16cbd604", "url": "https://github.com/trinodb/trino/commit/f3b984e6776d1a44dd19f81010978cee16cbd604", "message": "Pass Context to Project-off rules", "committedDate": "2020-02-15T12:47:43Z", "type": "commit"}, {"oid": "7b1b53119396db71115a3c13d9cc75f5590e43d4", "url": "https://github.com/trinodb/trino/commit/7b1b53119396db71115a3c13d9cc75f5590e43d4", "message": "Add Project-off rule for ApplyNode", "committedDate": "2020-02-15T12:47:43Z", "type": "commit"}, {"oid": "e72334ccd7ec41f163d41785f1eb1e27167a1481", "url": "https://github.com/trinodb/trino/commit/e72334ccd7ec41f163d41785f1eb1e27167a1481", "message": "Add rule for pruning ApplyNode's subquery columns\n\nAdds a new Optimiser rule PruneApplySourceColumns.\nThis rule, and a project-off rule PruneApplyColumns,\ntogrther provide the same column-pruning capability as\nPruneUnreferencedOutputs#visitApply().", "committedDate": "2020-02-15T12:47:43Z", "type": "commit"}, {"oid": "e72334ccd7ec41f163d41785f1eb1e27167a1481", "url": "https://github.com/trinodb/trino/commit/e72334ccd7ec41f163d41785f1eb1e27167a1481", "message": "Add rule for pruning ApplyNode's subquery columns\n\nAdds a new Optimiser rule PruneApplySourceColumns.\nThis rule, and a project-off rule PruneApplyColumns,\ntogrther provide the same column-pruning capability as\nPruneUnreferencedOutputs#visitApply().", "committedDate": "2020-02-15T12:47:43Z", "type": "forcePushed"}]}