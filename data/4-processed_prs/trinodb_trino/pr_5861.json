{"pr_number": 5861, "pr_title": "Support SQL UPDATE in the Presto Engine and Hive ACID Tables", "pr_createdAt": "2020-11-06T15:20:24Z", "pr_url": "https://github.com/trinodb/trino/pull/5861", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1ODE2MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518858160", "bodyText": "isUpdateQuery and updateKind should be folded into a single argument. Otherwise, this allows for non-sensical combinations such as isUpdateQuery == false and updateKind == UPDATE.", "author": "martint", "createdAt": "2020-11-06T16:20:57Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -326,12 +331,14 @@ public Scope analyzeForUpdate(Table table, Optional<Scope> outerQueryScope)\n         private final Optional<Scope> outerQueryScope;\n         private final WarningCollector warningCollector;\n         private final boolean isUpdateQuery;\n+        private final UpdateKind updateKind;\n \n-        private Visitor(Optional<Scope> outerQueryScope, WarningCollector warningCollector, boolean isUpdateQuery)\n+        private Visitor(Optional<Scope> outerQueryScope, WarningCollector warningCollector, boolean isUpdateQuery, UpdateKind updateKind)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTQ3NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075474", "bodyText": "Good point - - as you suggest below, conveying both intentions in an Optional<UpdateKind> is the right thing, and removes the cursed NO_UPDATE enum value.  Done!", "author": "djsstarburst", "createdAt": "2020-11-07T01:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1ODE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1ODkyMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518858923", "bodyText": "Why is this in the SPI? It's only used as an internal detail of the analyzer.", "author": "martint", "createdAt": "2020-11-06T16:22:10Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/UpdateKind.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+public enum UpdateKind", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTQ5NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075494", "bodyText": "It's a leftover from an earlier era of the UPDATE API.  It used to be an argument to ConnectorMetadata.getUpdateRowIdColumnHandle() before we broke that into two different methods, one for DELETE and one for UPDATE.  It's a great point that it doesn't belong in the SPI.  Demoted to be a private enum in StatementAnalyzer.", "author": "djsstarburst", "createdAt": "2020-11-07T01:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg1ODkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MDkxNg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518860916", "bodyText": "Instead of representing \"no update\" a type of update, make callers use an Optional<UpdateKind>. This will also make callsites where an UpdateKind is needed more obvious and coherent. For instance, in:\npublic Scope analyzeForUpdate(Table table, Optional<Scope> outerQueryScope, UpdateKind updateKind)\n\nIt would be wrong or strange to call that method with UpdateKind.NO_UPDATE (and the method would need to check internally for this case).", "author": "martint", "createdAt": "2020-11-06T16:25:24Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/UpdateKind.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+public enum UpdateKind\n+{\n+    NO_UPDATE,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTUxMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075513", "bodyText": "Converted to Optional, a much cleaner solution, making the NO_UPDATE enum value vanish.", "author": "djsstarburst", "createdAt": "2020-11-07T01:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2MDkxNg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NDI2NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518974264", "bodyText": "Add a condition to make sure this is UpdateKind.DELETE. Otherwise, this can break in the future if a new value is added to that enum. I might structure it as:\nswitch (updateKind) {\n    case UPDATE: {\n        ...\n        break;\n    }\n    case DELETE: {\n        ...\n        break;\n    }\n    default:\n        throw new UnsupportedOperationException(\"Update kind not supported:\" + updateKind);\n}", "author": "martint", "createdAt": "2020-11-06T20:00:55Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1243,11 +1250,24 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n \n             if (isUpdateQuery) {\n                 // Add the row id field\n-                ColumnHandle column = metadata.getUpdateRowIdColumnHandle(session, tableHandle.get());\n-                Type type = metadata.getColumnMetadata(session, tableHandle.get(), column).getType();\n+                ColumnHandle rowIdColumn;\n+                if (updateKind == UpdateKind.UPDATE) {\n+                    Optional<List<ColumnMetadata>> updatedColumnMetadata = analysis.getUpdatedColumns();\n+                    checkArgument(updatedColumnMetadata.isPresent(), \"updatedColumnMetadata isn't present\");\n+                    Set<String> updatedColumnNames = updatedColumnMetadata.get().stream().map(ColumnMetadata::getName).collect(toImmutableSet());\n+                    List<ColumnHandle> updatedColumns = columnHandles.entrySet().stream()\n+                            .filter(entry -> updatedColumnNames.contains(entry.getKey()))\n+                            .map(Map.Entry::getValue)\n+                            .collect(toImmutableList());\n+                    rowIdColumn = metadata.getUpdateRowIdColumnHandle(session, tableHandle.get(), columnHandles, updatedColumns);\n+                }\n+                else {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTUyNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075527", "bodyText": "Converted to a switch statement.", "author": "djsstarburst", "createdAt": "2020-11-07T01:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NDI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NjQ1OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518976458", "bodyText": "Format as:\nSet<String> updatedTargetNames = update.getTargets().stream()\n        .map(Identifier::getValue)\n        .collect(toImmutableSet());", "author": "martint", "createdAt": "2020-11-06T20:05:53Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1765,6 +1785,93 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, update.getTargets().stream().map(Identifier::getValue).collect(toUnmodifiableSet()));\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");\n+            }\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+            // Strip out the \"hidden\" columns\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns().stream()\n+                    .filter(column -> !column.isHidden())\n+                    .collect(toImmutableList());\n+            for (ColumnMetadata tableColumn : allColumns) {\n+                if (!accessControl.getColumnMasks(session.toSecurityContext(), tableName, tableColumn.getName(), tableColumn.getType()).isEmpty()) {\n+                    throw semanticException(NOT_SUPPORTED, update, \"Update table with column mask\");\n+                }\n+            }\n+\n+            Set<String> updatedTargetNames = update.getTargets().stream().map(Identifier::getValue).collect(toImmutableSet());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTUzOQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075539", "bodyText": "Converted.", "author": "djsstarburst", "createdAt": "2020-11-07T01:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NjQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NzM5MQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518977391", "bodyText": "Format as:\nList<ColumnMetadata> updatedColumns = allColumns.stream()\n        .filter(column -> updatedTargetNames.contains(column.getName()))\n        .collect(toImmutableList());", "author": "martint", "createdAt": "2020-11-06T20:07:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1765,6 +1785,93 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, update.getTargets().stream().map(Identifier::getValue).collect(toUnmodifiableSet()));\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");\n+            }\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+            // Strip out the \"hidden\" columns\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns().stream()\n+                    .filter(column -> !column.isHidden())\n+                    .collect(toImmutableList());\n+            for (ColumnMetadata tableColumn : allColumns) {\n+                if (!accessControl.getColumnMasks(session.toSecurityContext(), tableName, tableColumn.getName(), tableColumn.getType()).isEmpty()) {\n+                    throw semanticException(NOT_SUPPORTED, update, \"Update table with column mask\");\n+                }\n+            }\n+\n+            Set<String> updatedTargetNames = update.getTargets().stream().map(Identifier::getValue).collect(toImmutableSet());\n+            List<ColumnMetadata> updatedColumns = allColumns.stream().filter(column -> updatedTargetNames.contains(column.getName())).collect(toImmutableList());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTU0Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075543", "bodyText": "Converted.", "author": "djsstarburst", "createdAt": "2020-11-07T01:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NzM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3ODMxMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518978312", "bodyText": "Unrelated changes", "author": "martint", "createdAt": "2020-11-06T20:08:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -250,13 +252,16 @@ private RelationPlan planStatementWithoutOutput(Analysis analysis, Statement sta\n             checkState(analysis.getInsert().isPresent(), \"Insert handle is missing\");\n             return createInsertPlan(analysis, (Insert) statement);\n         }\n-        else if (statement instanceof RefreshMaterializedView) {\n+        if (statement instanceof RefreshMaterializedView) {\n             checkState(analysis.getRefreshMaterializedView().isPresent(), \"RefreshMaterializedViewAnalysis handle is missing\");\n             return createRefreshMaterializedViewPlan(analysis);\n         }\n-        else if (statement instanceof Delete) {\n+        if (statement instanceof Delete) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTU1Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075553", "bodyText": "Reverted.", "author": "djsstarburst", "createdAt": "2020-11-07T01:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3ODMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3ODgwMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518978801", "bodyText": "Why?\nAlso, this change seems unrelated.", "author": "martint", "createdAt": "2020-11-06T20:09:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanBuilder.java", "diffHunk": "@@ -115,7 +115,7 @@ public PlanBuilder appendProjections(Iterable<Expression> expressions, SymbolAll\n         // add an identity projection for underlying plan\n         projections.putIdentities(root.getOutputSymbols());\n \n-        Map<ScopeAware<Expression>, Symbol> mappings = new HashMap<>();\n+        Map<ScopeAware<Expression>, Symbol> mappings = new LinkedHashMap<>();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTU3MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075570", "bodyText": "It was needed at one point in the evolution of the implementation, but isn't any more.  Reverted.", "author": "djsstarburst", "createdAt": "2020-11-07T01:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3ODgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4MjgyNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518982827", "bodyText": "I would model them in a single list of \"assignments\". Then, you don't have to worry about whether the incoming lists have different numbers of elements.", "author": "martint", "createdAt": "2020-11-06T20:13:56Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/Update.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.tree;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class Update\n+        extends Statement\n+{\n+    private final Table table;\n+    private final List<Identifier> targets;\n+    private final List<Expression> values;\n+    private final Optional<Expression> where;\n+\n+    public Update(Table table, List<Identifier> targets, List<Expression> values, Optional<Expression> where)\n+    {\n+        this(Optional.empty(), table, targets, values, where);\n+    }\n+\n+    public Update(NodeLocation location, Table table, List<Identifier> targets, List<Expression> values, Optional<Expression> where)\n+    {\n+        this(Optional.of(location), table, targets, values, where);\n+    }\n+\n+    private Update(Optional<NodeLocation> location, Table table, List<Identifier> targets, List<Expression> values, Optional<Expression> where)\n+    {\n+        super(location);\n+        this.table = requireNonNull(table, \"table is null\");\n+        this.targets = requireNonNull(targets, \"targets is null\");\n+        this.values = requireNonNull(values, \"values is null\");\n+        checkArgument(targets.size() == values.size(), \"targets (%s) and values (%s) have differents sizes\", targets.size(), values.size());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTU4Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075583", "bodyText": "Indeed, this is much nicer!  Changed.", "author": "djsstarburst", "createdAt": "2020-11-07T01:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4MjgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NDQ5Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518984492", "bodyText": "See my comment in the Update class about modeling these as \"assignments\". Take a look at how we do it for io.prestosql.sql.tree.Property", "author": "martint", "createdAt": "2020-11-06T20:17:51Z", "path": "presto-parser/src/main/antlr4/io/prestosql/sql/parser/SqlBase.g4", "diffHunk": "@@ -140,6 +140,10 @@ statement\n     | DESCRIBE INPUT identifier                                        #describeInput\n     | DESCRIBE OUTPUT identifier                                       #describeOutput\n     | SET PATH pathSpecification                                       #setPath\n+    | UPDATE qualifiedName\n+        SET targets+=identifier '=' values+=updateSource\n+            (',' targets+=identifier '=' values+=updateSource)*\n+        (WHERE where=booleanExpression)?                               #update", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTU5Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075597", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-07T01:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NDQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4OTIzOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r518989238", "bodyText": "DEFAULT will be interpreted as an identifier (and as a column named \"default\"), but it should be treated a special entity that has distinct semantics. We'll need to introduce a Default expression for this.\nSince we're not handling this at all in the code, I would get rid of it for now and do it as a future enhancement.", "author": "martint", "createdAt": "2020-11-06T20:29:29Z", "path": "presto-parser/src/main/antlr4/io/prestosql/sql/parser/SqlBase.g4", "diffHunk": "@@ -460,6 +464,9 @@ frameBound\n     | expression boundType=(PRECEDING | FOLLOWING)  #boundedFrame\n     ;\n \n+updateSource\n+    : (expression | DEFAULT)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTYxOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r519075618", "bodyText": "Removed.", "author": "djsstarburst", "createdAt": "2020-11-07T01:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4OTIzOA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ0ODA5OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526448098", "bodyText": "Let's move this after example-http since it is related to connectors", "author": "electrum", "createdAt": "2020-11-18T21:54:49Z", "path": "presto-docs/src/main/sphinx/develop.rst", "diffHunk": "@@ -17,3 +17,4 @@ This guide is intended for Presto contributors and plugin developers.\n     develop/certificate-authenticator\n     develop/group-provider\n     develop/event-listener\n+    develop/delete-and-update", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4Nzg4NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526587885", "bodyText": "Moved.", "author": "djsstarburst", "createdAt": "2020-11-19T04:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ0ODA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3MDE2NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526470164", "bodyText": "This change to the Hive docs is in the wrong commit", "author": "electrum", "createdAt": "2020-11-18T22:37:49Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -88,7 +88,9 @@ Transactional and ACID Tables\n \n When connecting to a Hive metastore version 3.x, the Hive connector supports\n reading from and writing to insert-only and ACID tables, with full support for\n-partitioning and bucketing. Row-level deletes are supported for ACID tables.\n+partitioning and bucketing. Row-level DELETE is supported for ACID tables,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3MDk3MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526470970", "bodyText": "How about changing the sentence to\n\nACID tables support UPDATE and row-level DELETE. Updating the values of partition keys or bucket columns is not supported.", "author": "electrum", "createdAt": "2020-11-18T22:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3MDE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4NzkxOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526587918", "bodyText": "Removed from this commit.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3MDE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3ODM2NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526478364", "bodyText": "Remove the default methods and move this to AbstractMockMetadata, since this is an internal interface.", "author": "electrum", "createdAt": "2020-11-18T22:55:54Z", "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -317,6 +322,22 @@\n      */\n     void finishDelete(Session session, TableHandle tableHandle, Collection<Slice> fragments);\n \n+    /**\n+     * Begin update query\n+     */\n+    default TableHandle beginUpdate(Session session, TableHandle tableHandle, List<ColumnHandle> updatedColumns, List<Integer> updateExpressionChannelNumbers)\n+    {\n+        throw new UnsupportedOperationException();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4NzkzOQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526587939", "bodyText": "Done.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3ODM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTQ1MQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526479451", "bodyText": "This doesn't need to be qualified", "author": "electrum", "createdAt": "2020-11-18T22:58:22Z", "path": "presto-main/src/main/java/io/prestosql/operator/UpdateOperator.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PageBuilder;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.UpdatablePageSource;\n+import io.prestosql.sql.planner.plan.PlanNodeId;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.airlift.concurrent.MoreFutures.toListenableFuture;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static java.util.Objects.requireNonNull;\n+\n+public class UpdateOperator\n+        implements Operator\n+{\n+    public static class UpdateOperatorFactory\n+            implements OperatorFactory\n+    {\n+        private final int operatorId;\n+        private final PlanNodeId planNodeId;\n+        private final int rowIdChannel;\n+        private boolean closed;\n+\n+        public UpdateOperatorFactory(int operatorId, PlanNodeId planNodeId, int rowIdChannel)\n+        {\n+            this.operatorId = operatorId;\n+            this.planNodeId = requireNonNull(planNodeId, \"planNodeId is null\");\n+            this.rowIdChannel = rowIdChannel;\n+        }\n+\n+        @Override\n+        public Operator createOperator(DriverContext driverContext)\n+        {\n+            checkState(!closed, \"Factory is already closed\");\n+            OperatorContext context = driverContext.addOperatorContext(operatorId, planNodeId, UpdateOperator.class.getSimpleName());\n+            return new UpdateOperator(context, rowIdChannel);\n+        }\n+\n+        @Override\n+        public void noMoreOperators()\n+        {\n+            closed = true;\n+        }\n+\n+        @Override\n+        public OperatorFactory duplicate()\n+        {\n+            return new UpdateOperator.UpdateOperatorFactory(operatorId, planNodeId, rowIdChannel);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4Nzk0Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526587943", "bodyText": "Unqualified.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTcwNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526479705", "bodyText": "No need to qualify State. This can be\nif (state == State.RUNNING) {", "author": "electrum", "createdAt": "2020-11-18T22:59:03Z", "path": "presto-main/src/main/java/io/prestosql/operator/UpdateOperator.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PageBuilder;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.UpdatablePageSource;\n+import io.prestosql.sql.planner.plan.PlanNodeId;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.airlift.concurrent.MoreFutures.toListenableFuture;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static java.util.Objects.requireNonNull;\n+\n+public class UpdateOperator\n+        implements Operator\n+{\n+    public static class UpdateOperatorFactory\n+            implements OperatorFactory\n+    {\n+        private final int operatorId;\n+        private final PlanNodeId planNodeId;\n+        private final int rowIdChannel;\n+        private boolean closed;\n+\n+        public UpdateOperatorFactory(int operatorId, PlanNodeId planNodeId, int rowIdChannel)\n+        {\n+            this.operatorId = operatorId;\n+            this.planNodeId = requireNonNull(planNodeId, \"planNodeId is null\");\n+            this.rowIdChannel = rowIdChannel;\n+        }\n+\n+        @Override\n+        public Operator createOperator(DriverContext driverContext)\n+        {\n+            checkState(!closed, \"Factory is already closed\");\n+            OperatorContext context = driverContext.addOperatorContext(operatorId, planNodeId, UpdateOperator.class.getSimpleName());\n+            return new UpdateOperator(context, rowIdChannel);\n+        }\n+\n+        @Override\n+        public void noMoreOperators()\n+        {\n+            closed = true;\n+        }\n+\n+        @Override\n+        public OperatorFactory duplicate()\n+        {\n+            return new UpdateOperator.UpdateOperatorFactory(operatorId, planNodeId, rowIdChannel);\n+        }\n+    }\n+\n+    private enum State\n+    {\n+        RUNNING, FINISHING, FINISHED\n+    }\n+\n+    private final OperatorContext operatorContext;\n+    private final int rowIdChannel;\n+\n+    private UpdateOperator.State state = UpdateOperator.State.RUNNING;\n+    private long rowCount;\n+    private boolean closed;\n+    private ListenableFuture<Collection<Slice>> finishFuture;\n+    private Supplier<Optional<UpdatablePageSource>> pageSource = Optional::empty;\n+\n+    public UpdateOperator(OperatorContext operatorContext, int rowIdChannel)\n+    {\n+        this.operatorContext = requireNonNull(operatorContext, \"operatorContext is null\");\n+        this.rowIdChannel = rowIdChannel;\n+    }\n+\n+    @Override\n+    public OperatorContext getOperatorContext()\n+    {\n+        return operatorContext;\n+    }\n+\n+    @Override\n+    public void finish()\n+    {\n+        if (state == UpdateOperator.State.RUNNING) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4Nzk3Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526587973", "bodyText": "All UpdateOperator. qualifications removed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MDIyMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526480221", "bodyText": "This is not used", "author": "electrum", "createdAt": "2020-11-18T23:00:19Z", "path": "presto-main/src/main/java/io/prestosql/operator/UpdateOperator.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PageBuilder;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.UpdatablePageSource;\n+import io.prestosql.sql.planner.plan.PlanNodeId;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.airlift.concurrent.MoreFutures.toListenableFuture;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static java.util.Objects.requireNonNull;\n+\n+public class UpdateOperator\n+        implements Operator\n+{\n+    public static class UpdateOperatorFactory\n+            implements OperatorFactory\n+    {\n+        private final int operatorId;\n+        private final PlanNodeId planNodeId;\n+        private final int rowIdChannel;\n+        private boolean closed;\n+\n+        public UpdateOperatorFactory(int operatorId, PlanNodeId planNodeId, int rowIdChannel)\n+        {\n+            this.operatorId = operatorId;\n+            this.planNodeId = requireNonNull(planNodeId, \"planNodeId is null\");\n+            this.rowIdChannel = rowIdChannel;\n+        }\n+\n+        @Override\n+        public Operator createOperator(DriverContext driverContext)\n+        {\n+            checkState(!closed, \"Factory is already closed\");\n+            OperatorContext context = driverContext.addOperatorContext(operatorId, planNodeId, UpdateOperator.class.getSimpleName());\n+            return new UpdateOperator(context, rowIdChannel);\n+        }\n+\n+        @Override\n+        public void noMoreOperators()\n+        {\n+            closed = true;\n+        }\n+\n+        @Override\n+        public OperatorFactory duplicate()\n+        {\n+            return new UpdateOperator.UpdateOperatorFactory(operatorId, planNodeId, rowIdChannel);\n+        }\n+    }\n+\n+    private enum State\n+    {\n+        RUNNING, FINISHING, FINISHED\n+    }\n+\n+    private final OperatorContext operatorContext;\n+    private final int rowIdChannel;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4Nzk4OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526587989", "bodyText": "Removed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MDIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MjA1OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526482059", "bodyText": "List<ColumnMetadata>> updatedColumnMetadata = analysis.getUpdatedColumns()\n        .orElseThrow(() -> new VerifyException(\"updated columns not set\"));", "author": "electrum", "createdAt": "2020-11-18T23:04:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1241,13 +1251,31 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n                 analysis.setColumn(field, columnHandle);\n             }\n \n-            if (isUpdateQuery) {\n+            if (updateKind.isPresent()) {\n                 // Add the row id field\n-                ColumnHandle column = metadata.getUpdateRowIdColumnHandle(session, tableHandle.get());\n-                Type type = metadata.getColumnMetadata(session, tableHandle.get(), column).getType();\n+                ColumnHandle rowIdColumn;\n+                switch (updateKind.get()) {\n+                    case DELETE:\n+                        rowIdColumn = metadata.getDeleteRowIdColumnHandle(session, tableHandle.get());\n+                        break;\n+                    case UPDATE:\n+                        Optional<List<ColumnMetadata>> updatedColumnMetadata = analysis.getUpdatedColumns();\n+                        checkArgument(updatedColumnMetadata.isPresent(), \"updatedColumnMetadata isn't present\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4Nzk5Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526587996", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MjA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MjM5Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526482396", "bodyText": "Use VerifyException since this would be a bug", "author": "electrum", "createdAt": "2020-11-18T23:05:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1241,13 +1251,31 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n                 analysis.setColumn(field, columnHandle);\n             }\n \n-            if (isUpdateQuery) {\n+            if (updateKind.isPresent()) {\n                 // Add the row id field\n-                ColumnHandle column = metadata.getUpdateRowIdColumnHandle(session, tableHandle.get());\n-                Type type = metadata.getColumnMetadata(session, tableHandle.get(), column).getType();\n+                ColumnHandle rowIdColumn;\n+                switch (updateKind.get()) {\n+                    case DELETE:\n+                        rowIdColumn = metadata.getDeleteRowIdColumnHandle(session, tableHandle.get());\n+                        break;\n+                    case UPDATE:\n+                        Optional<List<ColumnMetadata>> updatedColumnMetadata = analysis.getUpdatedColumns();\n+                        checkArgument(updatedColumnMetadata.isPresent(), \"updatedColumnMetadata isn't present\");\n+                        Set<String> updatedColumnNames = updatedColumnMetadata.get().stream().map(ColumnMetadata::getName).collect(toImmutableSet());\n+                        List<ColumnHandle> updatedColumns = columnHandles.entrySet().stream()\n+                                .filter(entry -> updatedColumnNames.contains(entry.getKey()))\n+                                .map(Map.Entry::getValue)\n+                                .collect(toImmutableList());\n+                        rowIdColumn = metadata.getUpdateRowIdColumnHandle(session, tableHandle.get(), updatedColumns);\n+                        break;\n+                    default:\n+                        throw new IllegalArgumentException(\"Unknown UpdateKind \" + updateKind.get());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODAxMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588010", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MzMwNA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526483304", "bodyText": "We don't do this for delete. I'm not sure why we do it for insert. I don't think we should exclude hidden columns here unless there is a good reason. cc @martint", "author": "electrum", "createdAt": "2020-11-18T23:08:17Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1765,6 +1793,101 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            Set<String> assignmentTargets = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, assignmentTargets);\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");\n+            }\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+            // Strip out the \"hidden\" columns", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2MTk5Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526561992", "bodyText": "Here is the definition of HiveColumnHandle.isHidden():\n    public boolean isHidden()\n    {\n        return columnType == SYNTHESIZED;\n    }\n\nHere is the complete list of SYNTHESIZED columns:\n    public static HiveColumnHandle getDeleteRowIdColumnHandle();\n    public static HiveColumnHandle updateRowIdColumnHandle(List<HiveColumnHandle> columnHandles, List<ColumnHandle> updatedColumns);\n    public static HiveColumnHandle pathColumnHandle();\n    public static HiveColumnHandle bucketColumnHandle();\n    public static HiveColumnHandle fileSizeColumnHandle();\n    public static HiveColumnHandle fileModifiedTimeColumnHandle();\n    public static HiveColumnHandle partitionColumnHandle();\n\nAFAICT none of these can be UPDATE SET targets.", "author": "djsstarburst", "createdAt": "2020-11-19T03:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MzMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NjQ2MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526486460", "bodyText": "I don't think we should filter here. We should be able to update a hidden column, just like we can select one.", "author": "electrum", "createdAt": "2020-11-18T23:16:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1765,6 +1793,101 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            Set<String> assignmentTargets = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, assignmentTargets);\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");\n+            }\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+            // Strip out the \"hidden\" columns\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns().stream()\n+                    .filter(column -> !column.isHidden())\n+                    .collect(toImmutableList());\n+            for (ColumnMetadata tableColumn : allColumns) {\n+                if (!accessControl.getColumnMasks(session.toSecurityContext(), tableName, tableColumn.getName(), tableColumn.getType()).isEmpty()) {\n+                    throw semanticException(NOT_SUPPORTED, update, \"Update table with column mask\");\n+                }\n+            }\n+\n+            Set<String> updatedTargetNames = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            List<ColumnMetadata> updatedColumns = allColumns.stream()\n+                    .filter(column -> updatedTargetNames.contains(column.getName()))\n+                    .collect(toImmutableList());\n+            analysis.setUpdateType(\"UPDATE\", tableName);\n+            analysis.setUpdatedColumns(updatedColumns);\n+\n+            // Analyzer checks for select permissions but UPDATE has a separate permission, so disable access checks\n+            StatementAnalyzer analyzer = new StatementAnalyzer(\n+                    analysis,\n+                    metadata,\n+                    sqlParser,\n+                    new AllowAllAccessControl(),\n+                    session,\n+                    warningCollector,\n+                    CorrelationSupport.ALLOWED);\n+\n+            Scope tableScope = analyzer.analyzeForUpdate(table, scope, UpdateKind.UPDATE);\n+            update.getWhere().ifPresent(where -> analyzeWhere(update, tableScope, where));\n+\n+            Map<String, ColumnMetadata> columns = allColumns.stream()\n+                    .filter(column -> !column.isHidden())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODA2OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588069", "bodyText": "Since allColumns is filtered above, it's certainly doesn't need to be filtered again here.  Filtering removed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NjQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NzUwMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526487503", "bodyText": "Rather than doing a null check here, we should verify that the target column name exists up above, with a proper semantic error, before we do security checks or anything else using it.", "author": "electrum", "createdAt": "2020-11-18T23:19:13Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1765,6 +1793,101 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            Set<String> assignmentTargets = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, assignmentTargets);\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");\n+            }\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+            // Strip out the \"hidden\" columns\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns().stream()\n+                    .filter(column -> !column.isHidden())\n+                    .collect(toImmutableList());\n+            for (ColumnMetadata tableColumn : allColumns) {\n+                if (!accessControl.getColumnMasks(session.toSecurityContext(), tableName, tableColumn.getName(), tableColumn.getType()).isEmpty()) {\n+                    throw semanticException(NOT_SUPPORTED, update, \"Update table with column mask\");\n+                }\n+            }\n+\n+            Set<String> updatedTargetNames = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            List<ColumnMetadata> updatedColumns = allColumns.stream()\n+                    .filter(column -> updatedTargetNames.contains(column.getName()))\n+                    .collect(toImmutableList());\n+            analysis.setUpdateType(\"UPDATE\", tableName);\n+            analysis.setUpdatedColumns(updatedColumns);\n+\n+            // Analyzer checks for select permissions but UPDATE has a separate permission, so disable access checks\n+            StatementAnalyzer analyzer = new StatementAnalyzer(\n+                    analysis,\n+                    metadata,\n+                    sqlParser,\n+                    new AllowAllAccessControl(),\n+                    session,\n+                    warningCollector,\n+                    CorrelationSupport.ALLOWED);\n+\n+            Scope tableScope = analyzer.analyzeForUpdate(table, scope, UpdateKind.UPDATE);\n+            update.getWhere().ifPresent(where -> analyzeWhere(update, tableScope, where));\n+\n+            Map<String, ColumnMetadata> columns = allColumns.stream()\n+                    .filter(column -> !column.isHidden())\n+                    .collect(toImmutableMap(ColumnMetadata::getName, Function.identity()));\n+\n+            ImmutableList.Builder<ExpressionAnalysis> analysesBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<Type> expressionTypesBuilder = ImmutableList.builder();\n+            for (UpdateAssignment assignment : update.getAssignments()) {\n+                Expression expression = assignment.getValue();\n+                ExpressionAnalysis analysis = analyzeExpression(expression, tableScope);\n+                analysesBuilder.add(analysis);\n+                expressionTypesBuilder.add(analysis.getType(expression));\n+            }\n+            List<ExpressionAnalysis> analyses = analysesBuilder.build();\n+            List<Type> expressionTypes = expressionTypesBuilder.build();\n+\n+            List<Type> tableTypes = update.getAssignments().stream()\n+                    .map(assignment -> requireNonNull(columns.get(assignment.getName().getValue())))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODEwNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588107", "bodyText": "Done.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NzUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk5MjEzNg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528992136", "bodyText": "Is this resolved? I still see the null check.", "author": "martint", "createdAt": "2020-11-23T20:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NzUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4ODQxNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526488415", "bodyText": "Remove \"else\" here as well", "author": "electrum", "createdAt": "2020-11-18T23:21:45Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -250,13 +252,16 @@ private RelationPlan planStatementWithoutOutput(Analysis analysis, Statement sta\n             checkState(analysis.getInsert().isPresent(), \"Insert handle is missing\");\n             return createInsertPlan(analysis, (Insert) statement);\n         }\n-        else if (statement instanceof RefreshMaterializedView) {\n+        if (statement instanceof RefreshMaterializedView) {\n             checkState(analysis.getRefreshMaterializedView().isPresent(), \"RefreshMaterializedViewAnalysis handle is missing\");\n             return createRefreshMaterializedViewPlan(analysis);\n         }\n         else if (statement instanceof Delete) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODExNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588117", "bodyText": "Removed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4ODQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4OTEyMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526489123", "bodyText": "Good change, but unrelated", "author": "electrum", "createdAt": "2020-11-18T23:23:48Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -396,8 +402,7 @@ public RelationPlan plan(QuerySpecification node)\n \n             // The new scope is the composite of the fields from the FROM and SELECT clause (local nested scopes). Fields from the bottom of\n             // the scope stack need to be placed first to match the expected layout for nested scopes.\n-            List<Symbol> newFields = new ArrayList<>();\n-            newFields.addAll(builder.getTranslations().getFieldSymbols());\n+            List<Symbol> newFields = new ArrayList<>(builder.getTranslations().getFieldSymbols());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODE0Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588143", "bodyText": "Reverted.", "author": "djsstarburst", "createdAt": "2020-11-19T04:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4OTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5MDgzNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526490837", "bodyText": "Calling this ordered might be better since it's not really sorted", "author": "electrum", "createdAt": "2020-11-18T23:28:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,106 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<UpdateAssignment> sortedAssignmentsBuilder = ImmutableList.builder();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODE2NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588164", "bodyText": "Yes, ordered is better.  Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5MDgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NDkzMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526494931", "bodyText": "sortedAssignments is only used here, so we could inline this into the creation loop", "author": "electrum", "createdAt": "2020-11-18T23:39:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,106 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<UpdateAssignment> sortedAssignmentsBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            sortedAssignmentsBuilder.add(node.getAssignments().get(index));\n+        }\n+        List<UpdateAssignment> sortedAssignments = sortedAssignmentsBuilder.build();\n+        List<Expression> sortedExpressions = sortedAssignments.stream()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODE4NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588184", "bodyText": "Done; nice cleanup!", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NDkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5ODI0Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526498246", "bodyText": "toImmutableList", "author": "electrum", "createdAt": "2020-11-18T23:48:13Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,106 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<UpdateAssignment> sortedAssignmentsBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            sortedAssignmentsBuilder.add(node.getAssignments().get(index));\n+        }\n+        List<UpdateAssignment> sortedAssignments = sortedAssignmentsBuilder.build();\n+        List<Expression> sortedExpressions = sortedAssignments.stream()\n+                .map(UpdateAssignment::getValue)\n+                .collect(toImmutableList());\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(sortedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, sortedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();\n+\n+        List<Symbol> expressionSymbols = sortedExpressions.stream()\n+                .map(expression -> requireNonNull(planAndMappings.get(expression), \"planAndMappings.get(expression) is null\"))\n+                .collect(Collectors.toList());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODIwOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588208", "bodyText": "This loop was removed in the previous cleanup.", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5ODI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTc0Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526499743", "bodyText": "Split this out into\nupdateExpressionChannelNumbers[index] = symbolCounter;\nsymbolCounter++;\nWe avoid using increment as an expression", "author": "electrum", "createdAt": "2020-11-18T23:52:17Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,106 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<UpdateAssignment> sortedAssignmentsBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            sortedAssignmentsBuilder.add(node.getAssignments().get(index));\n+        }\n+        List<UpdateAssignment> sortedAssignments = sortedAssignmentsBuilder.build();\n+        List<Expression> sortedExpressions = sortedAssignments.stream()\n+                .map(UpdateAssignment::getValue)\n+                .collect(toImmutableList());\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(sortedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, sortedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();\n+\n+        List<Symbol> expressionSymbols = sortedExpressions.stream()\n+                .map(expression -> requireNonNull(planAndMappings.get(expression), \"planAndMappings.get(expression) is null\"))\n+                .collect(Collectors.toList());\n+\n+        Set<String> dependencyColumnNames = analysis.getColumnReferences().stream()\n+                .map(NodeRef::getNode)\n+                .filter(someNode -> someNode instanceof Identifier)\n+                .map(someNode -> ((Identifier) someNode).getValue())\n+                .collect(toImmutableSet());\n+        List<ColumnHandle> dependencyColumns = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> dependencyColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        Symbol rowId = builder.translate(analysis.getRowIdField(table));\n+\n+        expressionSymbols.add(rowId);\n+        List<Integer> updateExpressionChannelNumbers = createUpdateExpressionChannelNumbers(projectNode.getAssignments(), expressionSymbols);\n+\n+        List<ColumnHandle> targets = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> targetColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        List<Symbol> projectedSymbols = new ArrayList<>();\n+        projectedSymbols.add(rowId);\n+        projectedSymbols.addAll(planAndMappings.mappings.values());\n+\n+        List<Symbol> outputs = ImmutableList.of(\n+                symbolAllocator.newSymbol(\"partialrows\", BIGINT),\n+                symbolAllocator.newSymbol(\"fragment\", VARBINARY));\n+\n+        // create update node\n+        return new UpdateNode(\n+                idAllocator.getNextId(),\n+                builder.getRoot(),\n+                new UpdateTarget(handle, metadata.getTableMetadata(session, handle).getTable(), targets, dependencyColumns, updateExpressionChannelNumbers),\n+                rowId,\n+                projectedSymbols,\n+                updateExpressionChannelNumbers,\n+                outputs);\n+    }\n+\n+    private List<Integer> createUpdateExpressionChannelNumbers(Assignments assignments, List<Symbol> expressionSymbols)\n+    {\n+        Integer[] updateExpressionChannelNumbers = new Integer[expressionSymbols.size()];\n+        int symbolCounter = 0;\n+        // This depends on the assignment symbols being ordered as the blocks of the\n+        // resulting page are ordered.\n+        for (Symbol symbol : assignments.getSymbols()) {\n+            int index = expressionSymbols.indexOf(symbol);\n+            if (index < 0) {\n+                continue;\n+            }\n+            updateExpressionChannelNumbers[index] = symbolCounter++;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODIzNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588235", "bodyText": "Ok, I'll remember that.  Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTk4Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526499982", "bodyText": "You can use int[] here along with Guava's Ints.asList()", "author": "electrum", "createdAt": "2020-11-18T23:52:57Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,106 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<UpdateAssignment> sortedAssignmentsBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            sortedAssignmentsBuilder.add(node.getAssignments().get(index));\n+        }\n+        List<UpdateAssignment> sortedAssignments = sortedAssignmentsBuilder.build();\n+        List<Expression> sortedExpressions = sortedAssignments.stream()\n+                .map(UpdateAssignment::getValue)\n+                .collect(toImmutableList());\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(sortedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, sortedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();\n+\n+        List<Symbol> expressionSymbols = sortedExpressions.stream()\n+                .map(expression -> requireNonNull(planAndMappings.get(expression), \"planAndMappings.get(expression) is null\"))\n+                .collect(Collectors.toList());\n+\n+        Set<String> dependencyColumnNames = analysis.getColumnReferences().stream()\n+                .map(NodeRef::getNode)\n+                .filter(someNode -> someNode instanceof Identifier)\n+                .map(someNode -> ((Identifier) someNode).getValue())\n+                .collect(toImmutableSet());\n+        List<ColumnHandle> dependencyColumns = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> dependencyColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        Symbol rowId = builder.translate(analysis.getRowIdField(table));\n+\n+        expressionSymbols.add(rowId);\n+        List<Integer> updateExpressionChannelNumbers = createUpdateExpressionChannelNumbers(projectNode.getAssignments(), expressionSymbols);\n+\n+        List<ColumnHandle> targets = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> targetColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        List<Symbol> projectedSymbols = new ArrayList<>();\n+        projectedSymbols.add(rowId);\n+        projectedSymbols.addAll(planAndMappings.mappings.values());\n+\n+        List<Symbol> outputs = ImmutableList.of(\n+                symbolAllocator.newSymbol(\"partialrows\", BIGINT),\n+                symbolAllocator.newSymbol(\"fragment\", VARBINARY));\n+\n+        // create update node\n+        return new UpdateNode(\n+                idAllocator.getNextId(),\n+                builder.getRoot(),\n+                new UpdateTarget(handle, metadata.getTableMetadata(session, handle).getTable(), targets, dependencyColumns, updateExpressionChannelNumbers),\n+                rowId,\n+                projectedSymbols,\n+                updateExpressionChannelNumbers,\n+                outputs);\n+    }\n+\n+    private List<Integer> createUpdateExpressionChannelNumbers(Assignments assignments, List<Symbol> expressionSymbols)\n+    {\n+        Integer[] updateExpressionChannelNumbers = new Integer[expressionSymbols.size()];", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODI4OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588288", "bodyText": "Let's chat about this - - I don't see how Ints.asList() is applicable to this case.", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMTYyNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526501627", "bodyText": "Can this method be static?", "author": "electrum", "createdAt": "2020-11-18T23:57:13Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,106 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<UpdateAssignment> sortedAssignmentsBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            sortedAssignmentsBuilder.add(node.getAssignments().get(index));\n+        }\n+        List<UpdateAssignment> sortedAssignments = sortedAssignmentsBuilder.build();\n+        List<Expression> sortedExpressions = sortedAssignments.stream()\n+                .map(UpdateAssignment::getValue)\n+                .collect(toImmutableList());\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(sortedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, sortedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();\n+\n+        List<Symbol> expressionSymbols = sortedExpressions.stream()\n+                .map(expression -> requireNonNull(planAndMappings.get(expression), \"planAndMappings.get(expression) is null\"))\n+                .collect(Collectors.toList());\n+\n+        Set<String> dependencyColumnNames = analysis.getColumnReferences().stream()\n+                .map(NodeRef::getNode)\n+                .filter(someNode -> someNode instanceof Identifier)\n+                .map(someNode -> ((Identifier) someNode).getValue())\n+                .collect(toImmutableSet());\n+        List<ColumnHandle> dependencyColumns = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> dependencyColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        Symbol rowId = builder.translate(analysis.getRowIdField(table));\n+\n+        expressionSymbols.add(rowId);\n+        List<Integer> updateExpressionChannelNumbers = createUpdateExpressionChannelNumbers(projectNode.getAssignments(), expressionSymbols);\n+\n+        List<ColumnHandle> targets = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> targetColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        List<Symbol> projectedSymbols = new ArrayList<>();\n+        projectedSymbols.add(rowId);\n+        projectedSymbols.addAll(planAndMappings.mappings.values());\n+\n+        List<Symbol> outputs = ImmutableList.of(\n+                symbolAllocator.newSymbol(\"partialrows\", BIGINT),\n+                symbolAllocator.newSymbol(\"fragment\", VARBINARY));\n+\n+        // create update node\n+        return new UpdateNode(\n+                idAllocator.getNextId(),\n+                builder.getRoot(),\n+                new UpdateTarget(handle, metadata.getTableMetadata(session, handle).getTable(), targets, dependencyColumns, updateExpressionChannelNumbers),\n+                rowId,\n+                projectedSymbols,\n+                updateExpressionChannelNumbers,\n+                outputs);\n+    }\n+\n+    private List<Integer> createUpdateExpressionChannelNumbers(Assignments assignments, List<Symbol> expressionSymbols)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODMwNg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588306", "bodyText": "Indeed it can.  Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMTYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNTU4Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526515586", "bodyText": "Can shorten to \"Invalid descendant ...\" since the method name will be in the stack trace", "author": "electrum", "createdAt": "2020-11-19T00:38:28Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/BeginTableWrite.java", "diffHunk": "@@ -195,7 +225,39 @@ private WriterTarget createWriterTarget(WriterTarget target)\n             throw new IllegalArgumentException(\"Unhandled target type: \" + target.getClass().getSimpleName());\n         }\n \n-        private PlanNode rewriteDeleteTableScan(PlanNode node, TableHandle handle)\n+        private TableHandle getTableHandleFromSource(PlanNode node)\n+        {\n+            if (node instanceof TableScanNode) {\n+                return ((TableScanNode) node).getTable();\n+            }\n+            if (node instanceof DeleteNode) {\n+                return getTableHandleFromSource(((DeleteNode) node).getSource());\n+            }\n+            if (node instanceof UpdateNode) {\n+                return getTableHandleFromSource(((UpdateNode) node).getSource());\n+            }\n+            if (node instanceof ExchangeNode) {\n+                return getTableHandleFromSource(node.getSources().get(0));\n+            }\n+            if (node instanceof FilterNode) {\n+                return getTableHandleFromSource(((FilterNode) node).getSource());\n+            }\n+            if (node instanceof ProjectNode) {\n+                return getTableHandleFromSource(((ProjectNode) node).getSource());\n+            }\n+            if (node instanceof SemiJoinNode) {\n+                return getTableHandleFromSource(((SemiJoinNode) node).getSource());\n+            }\n+            if (node instanceof JoinNode) {\n+                JoinNode joinNode = (JoinNode) node;\n+                if (joinNode.getType() == JoinNode.Type.INNER && isAtMostScalar(joinNode.getRight())) {\n+                    return getTableHandleFromSource(joinNode.getLeft());\n+                }\n+            }\n+            throw new IllegalArgumentException(\"In getTableHandleFromSource, invalid descendant for DeleteNode or UpdateNode: \" + node.getClass().getName());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODMzMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588330", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNTU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNzMyNg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526517326", "bodyText": "Use getOnlyElement() from Iterables so we fail if there are multiple sources", "author": "electrum", "createdAt": "2020-11-19T00:43:33Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/BeginTableWrite.java", "diffHunk": "@@ -195,7 +225,39 @@ private WriterTarget createWriterTarget(WriterTarget target)\n             throw new IllegalArgumentException(\"Unhandled target type: \" + target.getClass().getSimpleName());\n         }\n \n-        private PlanNode rewriteDeleteTableScan(PlanNode node, TableHandle handle)\n+        private TableHandle getTableHandleFromSource(PlanNode node)\n+        {\n+            if (node instanceof TableScanNode) {\n+                return ((TableScanNode) node).getTable();\n+            }\n+            if (node instanceof DeleteNode) {\n+                return getTableHandleFromSource(((DeleteNode) node).getSource());\n+            }\n+            if (node instanceof UpdateNode) {\n+                return getTableHandleFromSource(((UpdateNode) node).getSource());\n+            }\n+            if (node instanceof ExchangeNode) {\n+                return getTableHandleFromSource(node.getSources().get(0));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODM1MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588350", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxNzMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxODU3OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526518579", "bodyText": "Make defensive copies of all lists", "author": "electrum", "createdAt": "2020-11-19T00:47:07Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/UpdateNode.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.plan;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.plan.TableWriterNode.UpdateTarget;\n+\n+import javax.annotation.concurrent.Immutable;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+@Immutable\n+public class UpdateNode\n+        extends PlanNode\n+{\n+    private final PlanNode source;\n+    private final UpdateTarget target;\n+    private final Symbol rowId;\n+    private final List<Symbol> projectedSymbols;\n+    private final List<Integer> updateExpressionChannelNumbers;\n+    private final List<Symbol> outputs;\n+\n+    @JsonCreator\n+    public UpdateNode(\n+            @JsonProperty(\"id\") PlanNodeId id,\n+            @JsonProperty(\"source\") PlanNode source,\n+            @JsonProperty(\"target\") UpdateTarget target,\n+            @JsonProperty(\"rowId\") Symbol rowId,\n+            @JsonProperty(\"projectedSymbols\") List<Symbol> projectedSymbols,\n+            @JsonProperty(\"updateExpressionChannelNumbers\") List<Integer> updateExpressionChannelNumbers,\n+            @JsonProperty(\"outputs\") List<Symbol> outputs)\n+    {\n+        super(id);\n+\n+        this.source = requireNonNull(source, \"source is null\");\n+        this.target = requireNonNull(target, \"target is null\");\n+        this.rowId = requireNonNull(rowId, \"rowId is null\");\n+        this.projectedSymbols = requireNonNull(projectedSymbols, \"projectedSymbols is null\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODM2Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588363", "bodyText": "Copied.", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxODU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxOTAyOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526519028", "bodyText": "Should we validate that the row ID is present, like visitDelete does? Also, should the projectedSymbols be validated? (see other methods for examples of checks)", "author": "electrum", "createdAt": "2020-11-19T00:48:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/ValidateDependenciesChecker.java", "diffHunk": "@@ -573,6 +574,15 @@ public Void visitDelete(DeleteNode node, Set<Symbol> boundSymbols)\n             return null;\n         }\n \n+        @Override\n+        public Void visitUpdate(UpdateNode node, Set<Symbol> boundSymbols)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODQxMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588413", "bodyText": "I added validation of row ID.  Validation of projectedSymbols will take a bit more thought.", "author": "djsstarburst", "createdAt": "2020-11-19T04:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxOTAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxOTkzOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526519938", "bodyText": "Put this after INSERT", "author": "electrum", "createdAt": "2020-11-19T00:51:14Z", "path": "presto-spi/src/main/java/io/prestosql/spi/resourcegroups/QueryType.java", "diffHunk": "@@ -21,5 +21,6 @@\n     EXPLAIN,\n     ANALYZE,\n     INSERT,\n-    SELECT\n+    SELECT,\n+    UPDATE", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODQ0Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588443", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxOTkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMDExNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526520117", "bodyText": "Make deleteRows default as well, allowing a connector to implement update but not delete", "author": "electrum", "createdAt": "2020-11-19T00:51:50Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/UpdatablePageSource.java", "diffHunk": "@@ -24,6 +25,11 @@\n {\n     void deleteRows(Block rowIds);\n \n+    default void updateRows(Page page)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODQ1Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588457", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMDExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMDI4NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526520285", "bodyText": "This should probably throw, like deleteRows", "author": "electrum", "createdAt": "2020-11-19T00:52:20Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/EmptyPageSource.java", "diffHunk": "@@ -32,6 +32,9 @@ public void deleteRows(Block rowIds)\n         throw new UnsupportedOperationException(\"deleteRows called on EmptyPageSource\");\n     }\n \n+    @Override\n+    public void updateRows(Page page) {}", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODQ3Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588473", "bodyText": "Throwing.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMDI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMDQ2OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526520468", "bodyText": "Move these methods above, to be after finishDelete", "author": "electrum", "createdAt": "2020-11-19T00:52:52Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -1045,4 +1055,38 @@ default MaterializedViewFreshness getMaterializedViewFreshness(ConnectorSession\n     {\n         return new MaterializedViewFreshness(false);\n     }\n+\n+    /**", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODQ5MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588490", "bodyText": "Moved.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMDQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMDc4Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526520783", "bodyText": "This can be shortened to\n@param updateExpressionChannelNumbers provides the ...", "author": "electrum", "createdAt": "2020-11-19T00:53:52Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -1045,4 +1055,38 @@ default MaterializedViewFreshness getMaterializedViewFreshness(ConnectorSession\n     {\n         return new MaterializedViewFreshness(false);\n     }\n+\n+    /**\n+     * Do whatever is necessary to start an UPDATE query, returning the {@link ConnectorTableHandle}\n+     * instance that will be passed to split generation, and to the {@link #finishUpdate} method.\n+     * @param session The session in which to start the update operation.\n+     * @param tableHandle A ConnectorTableHandle for the table to be updated.\n+     * @param updatedColumns A list of the ColumnHandles of columns that will be updated by this UPDATE\n+     * operation, in table column order.\n+     * @param updateExpressionChannelNumbers updateExpressionChannelNumbers provides the channel", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODQ5OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588499", "bodyText": "Shortened.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMDc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMTMwOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526521308", "bodyText": "Change the last sentence to\n\nThe last element of the list is the channel number of the rowId column.\n\nRepeating the parameter name is redundant, and row ID might not be a row block (it can be any type).", "author": "electrum", "createdAt": "2020-11-19T00:55:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -1045,4 +1055,38 @@ default MaterializedViewFreshness getMaterializedViewFreshness(ConnectorSession\n     {\n         return new MaterializedViewFreshness(false);\n     }\n+\n+    /**\n+     * Do whatever is necessary to start an UPDATE query, returning the {@link ConnectorTableHandle}\n+     * instance that will be passed to split generation, and to the {@link #finishUpdate} method.\n+     * @param session The session in which to start the update operation.\n+     * @param tableHandle A ConnectorTableHandle for the table to be updated.\n+     * @param updatedColumns A list of the ColumnHandles of columns that will be updated by this UPDATE\n+     * operation, in table column order.\n+     * @param updateExpressionChannelNumbers updateExpressionChannelNumbers provides the channel\n+     * numbers in the final projected page produced by the Presto engine and passed to\n+     * {@link UpdatablePageSource#updateRows}.  There is a channel number for column handle in {#link #updatedColumns},\n+     * in the same order as the updatedColumns list.  The last element of the updateExpressionChannelNumbers\n+     * list is the channel number of the RowBlock containing the rowId column.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODUxNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588515", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMTYzMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526521633", "bodyText": "Shorten to\n@return a ConnectorTableHandle that ...\n\nThe \"Returns\" part is redundant for @return", "author": "electrum", "createdAt": "2020-11-19T00:56:09Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -1045,4 +1055,38 @@ default MaterializedViewFreshness getMaterializedViewFreshness(ConnectorSession\n     {\n         return new MaterializedViewFreshness(false);\n     }\n+\n+    /**\n+     * Do whatever is necessary to start an UPDATE query, returning the {@link ConnectorTableHandle}\n+     * instance that will be passed to split generation, and to the {@link #finishUpdate} method.\n+     * @param session The session in which to start the update operation.\n+     * @param tableHandle A ConnectorTableHandle for the table to be updated.\n+     * @param updatedColumns A list of the ColumnHandles of columns that will be updated by this UPDATE\n+     * operation, in table column order.\n+     * @param updateExpressionChannelNumbers updateExpressionChannelNumbers provides the channel\n+     * numbers in the final projected page produced by the Presto engine and passed to\n+     * {@link UpdatablePageSource#updateRows}.  There is a channel number for column handle in {#link #updatedColumns},\n+     * in the same order as the updatedColumns list.  The last element of the updateExpressionChannelNumbers\n+     * list is the channel number of the RowBlock containing the rowId column.\n+     * @return Returns a ConnectorTableHandle that will be passed to split generation, and to the", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODU2OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588569", "bodyText": "Shortened.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMTYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMjM4Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526522382", "bodyText": "You could use join() from String. But instead, just pass updatedColumnNames directly to format(), since that will format nicely with [] around it for readability.", "author": "electrum", "createdAt": "2020-11-19T00:58:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/security/AccessDeniedException.java", "diffHunk": "@@ -303,6 +304,17 @@ public static void denyDeleteTable(String tableName, String extraInfo)\n         throw new AccessDeniedException(format(\"Cannot delete from table %s%s\", tableName, formatExtraInfo(extraInfo)));\n     }\n \n+    public static void denyUpdateTableColumns(String tableName, Set<String> updatedColumnNames)\n+    {\n+        denyUpdateTableColumns(tableName, updatedColumnNames, null);\n+    }\n+\n+    public static void denyUpdateTableColumns(String tableName, Set<String> updatedColumnNames, String extraInfo)\n+    {\n+        String columnsString = updatedColumnNames.stream().collect(joining(\", \"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODU5NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588595", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMjM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMjc4OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526522789", "bodyText": "These are all Hive specific errors, so not appropriate for the engine. But I think it's fine to just use NOT_SUPPORTED", "author": "electrum", "createdAt": "2020-11-19T00:59:28Z", "path": "presto-spi/src/main/java/io/prestosql/spi/StandardErrorCode.java", "diffHunk": "@@ -112,6 +112,9 @@\n     NESTED_RECURSIVE(89, USER_ERROR),\n     INVALID_LIMIT_CLAUSE(90, USER_ERROR),\n     INVALID_ORDER_BY(91, USER_ERROR),\n+    UPDATE_OF_PARTITION_COLUMNS(92, USER_ERROR),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODYxNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588617", "bodyText": "Removed, and uses changed to NOT_SUPPORTED.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMjc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMzg3Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526523877", "bodyText": "It might be nicer to format like\nreturn format(\"%s = %s\", name, value);", "author": "electrum", "createdAt": "2020-11-19T01:02:42Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/UpdateAssignment.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.tree;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+public class UpdateAssignment\n+        extends Node\n+{\n+    private final Identifier name;\n+    private final Expression value;\n+\n+    public UpdateAssignment(Identifier name, Expression value)\n+    {\n+        this(Optional.empty(), name, value);\n+    }\n+\n+    public UpdateAssignment(NodeLocation location, Identifier name, Expression value)\n+    {\n+        this(Optional.of(location), name, value);\n+    }\n+\n+    private UpdateAssignment(Optional<NodeLocation> location, Identifier name, Expression value)\n+    {\n+        super(location);\n+        this.name = requireNonNull(name, \"name is null\");\n+        this.value = requireNonNull(value, \"value is null\");\n+    }\n+\n+    public Identifier getName()\n+    {\n+        return name;\n+    }\n+\n+    public Expression getValue()\n+    {\n+        return value;\n+    }\n+\n+    @Override\n+    public <R, C> R accept(AstVisitor<R, C> visitor, C context)\n+    {\n+        return visitor.visitUpdateAssignment(this, context);\n+    }\n+\n+    @Override\n+    public List<? extends Node> getChildren()\n+    {\n+        return ImmutableList.of(name, value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj)\n+    {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        UpdateAssignment other = (UpdateAssignment) obj;\n+        return Objects.equals(name, other.name) &&\n+                Objects.equals(value, other.value);\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return Objects.hash(name, value);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODYzMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588631", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMzg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNDE0Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526524143", "bodyText": "Make this\n.add(\"where\", where.orElse(null))\n.omitNullValues()\n.toString()", "author": "electrum", "createdAt": "2020-11-19T01:03:36Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/Update.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.tree;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+public class Update\n+        extends Statement\n+{\n+    private final Table table;\n+    private final List<UpdateAssignment> assignments;\n+    private final Optional<Expression> where;\n+\n+    public Update(Table table, List<UpdateAssignment> assignments, Optional<Expression> where)\n+    {\n+        this(Optional.empty(), table, assignments, where);\n+    }\n+\n+    public Update(NodeLocation location, Table table, List<UpdateAssignment> assignments, Optional<Expression> where)\n+    {\n+        this(Optional.of(location), table, assignments, where);\n+    }\n+\n+    private Update(Optional<NodeLocation> location, Table table, List<UpdateAssignment> assignments, Optional<Expression> where)\n+    {\n+        super(location);\n+        this.table = requireNonNull(table, \"table is null\");\n+        this.assignments = requireNonNull(assignments, \"targets is null\");\n+        this.where = requireNonNull(where, \"where is null\");\n+    }\n+\n+    public Table getTable()\n+    {\n+        return table;\n+    }\n+\n+    public List<UpdateAssignment> getAssignments()\n+    {\n+        return assignments;\n+    }\n+\n+    public Optional<Expression> getWhere()\n+    {\n+        return where;\n+    }\n+\n+    @Override\n+    public List<? extends Node> getChildren()\n+    {\n+        ImmutableList.Builder<Node> nodes = ImmutableList.builder();\n+        nodes.addAll(assignments);\n+        where.ifPresent(nodes::add);\n+        return nodes.build();\n+    }\n+\n+    @Override\n+    public <R, C> R accept(AstVisitor<R, C> visitor, C context)\n+    {\n+        return visitor.visitUpdate(this, context);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        Update update = (Update) o;\n+        return table.equals(update.table) &&\n+                assignments.equals(update.assignments) &&\n+                where.equals(update.where);\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return Objects.hash(table, assignments, where);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)\n+                .add(\"table\", table)\n+                .add(\"assignments\", assignments)\n+                .add(\"where\", where)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODY1Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588656", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNDE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNTUyNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526525527", "bodyText": "We should only output a blank line if there is a WHERE\nif (node.getWhere().isPresent()) {\n    builder.append(\"\\nWHERE \").append(...);\n}", "author": "electrum", "createdAt": "2020-11-19T01:07:51Z", "path": "presto-parser/src/main/java/io/prestosql/sql/SqlFormatter.java", "diffHunk": "@@ -1219,6 +1220,28 @@ protected Void visitInsert(Insert node, Integer indent)\n             return null;\n         }\n \n+        @Override\n+        protected Void visitUpdate(Update node, Integer indent)\n+        {\n+            builder.append(\"UPDATE \")\n+                    .append(node.getTable().getName());\n+\n+            builder.append(\"\\n\")\n+                    .append(indentString(indent + 1))\n+                    .append(\"SET \");\n+            builder.append(node.getAssignments().stream()\n+                    .map(assignment -> format(\"%s = %s\", assignment.getName().getValue(), formatExpression(assignment.getValue())))\n+                    .collect(joining(\", \")));\n+            builder.append(\"\\n\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODY2OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588669", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNTUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNTU3OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526525579", "bodyText": "We shouldn't add a trailing newline", "author": "electrum", "createdAt": "2020-11-19T01:07:59Z", "path": "presto-parser/src/main/java/io/prestosql/sql/SqlFormatter.java", "diffHunk": "@@ -1219,6 +1220,28 @@ protected Void visitInsert(Insert node, Integer indent)\n             return null;\n         }\n \n+        @Override\n+        protected Void visitUpdate(Update node, Integer indent)\n+        {\n+            builder.append(\"UPDATE \")\n+                    .append(node.getTable().getName());\n+\n+            builder.append(\"\\n\")\n+                    .append(indentString(indent + 1))\n+                    .append(\"SET \");\n+            builder.append(node.getAssignments().stream()\n+                    .map(assignment -> format(\"%s = %s\", assignment.getName().getValue(), formatExpression(assignment.getValue())))\n+                    .collect(joining(\", \")));\n+            builder.append(\"\\n\")\n+                    .append(indentString(indent));\n+            if (node.getWhere().isPresent()) {\n+                builder.append(\"WHERE \").append(formatExpression(node.getWhere().get()));\n+            }\n+            builder.append(\"\\n\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODY4OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588688", "bodyText": "Removed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNTY5Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526525696", "bodyText": "Add another one without a WHERE", "author": "electrum", "createdAt": "2020-11-19T01:08:18Z", "path": "presto-parser/src/test/java/io/prestosql/sql/parser/TestSqlParser.java", "diffHunk": "@@ -2710,6 +2712,23 @@ public void testNullTreatment()\n                         ImmutableList.of(new Identifier(\"x\"), new LongLiteral(\"1\"))));\n     }\n \n+    @Test\n+    public void testUpdate()\n+    {\n+        assertStatement(\"\" +", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODY5OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588699", "bodyText": "Added.", "author": "djsstarburst", "createdAt": "2020-11-19T04:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNTY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNjEzMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526526131", "bodyText": "Let's put each one on a separate line, so it looks like\nUPDATE foo SET\n    abc = 123,\n    xyz = 456\nWHERE something", "author": "electrum", "createdAt": "2020-11-19T01:09:43Z", "path": "presto-parser/src/main/java/io/prestosql/sql/SqlFormatter.java", "diffHunk": "@@ -1219,6 +1220,28 @@ protected Void visitInsert(Insert node, Integer indent)\n             return null;\n         }\n \n+        @Override\n+        protected Void visitUpdate(Update node, Integer indent)\n+        {\n+            builder.append(\"UPDATE \")\n+                    .append(node.getTable().getName());\n+\n+            builder.append(\"\\n\")\n+                    .append(indentString(indent + 1))\n+                    .append(\"SET \");\n+            builder.append(node.getAssignments().stream()\n+                    .map(assignment -> format(\"%s = %s\", assignment.getName().getValue(), formatExpression(assignment.getValue())))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODcxMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588712", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNjMwMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526526303", "bodyText": "This seems to be unused", "author": "electrum", "createdAt": "2020-11-19T01:10:14Z", "path": "presto-parser/src/main/antlr4/io/prestosql/sql/parser/SqlBase.g4", "diffHunk": "@@ -598,6 +605,7 @@ DATA: 'DATA';\n DATE: 'DATE';\n DAY: 'DAY';\n DEALLOCATE: 'DEALLOCATE';\n+DEFAULT: 'DEFAULT';", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODcxOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588718", "bodyText": "Removed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNjMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNjcxOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526526718", "bodyText": "I'd format this so the assignment list is together\n| UPDATE qualifiedName\n    SET updateAssignment (',' updateAssignment)*\n    (WHERE where=booleanExpression)?                               #update", "author": "electrum", "createdAt": "2020-11-19T01:11:32Z", "path": "presto-parser/src/main/antlr4/io/prestosql/sql/parser/SqlBase.g4", "diffHunk": "@@ -140,6 +140,10 @@ statement\n     | DESCRIBE INPUT identifier                                        #describeInput\n     | DESCRIBE OUTPUT identifier                                       #describeOutput\n     | SET PATH pathSpecification                                       #setPath\n+    | UPDATE qualifiedName", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4ODczMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526588730", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-19T04:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNjcxOA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTUyMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526725521", "bodyText": "Should we overload the rowId columnHandle abstraction with the \"any other fields of the row that the connector will need to complete the UPDATE operation\" or have a separate abstraction for the same which could be optional? Ideally the RowIdColumnHandle should only identify the updated rowIds", "author": "abhishekkhanna1", "createdAt": "2020-11-19T09:47:27Z", "path": "presto-docs/src/main/sphinx/develop/delete-and-update.rst", "diffHunk": "@@ -0,0 +1,203 @@\n+====================================\n+Supporting ``DELETE`` and ``UPDATE``\n+====================================\n+\n+The Presto engine provides APIs to support row-level SQL ``DELETE`` and ``UPDATE``.\n+To implement ``DELETE`` or ``UPDATE``, a connector must layer an ``UpdatablePageSource``\n+on top of the connector's usual ``ConnectorPageSource``, and define ``ConnectorMetadata``\n+methods to get a \"rowId\" column handle; to start the operation; and to finish the operation.\n+\n+``DELETE`` and ``UPDATE`` Data Flow\n+===================================\n+\n+``DELETE`` and ``UPDATE`` have a similar flow:\n+\n+* For each split, the connector will create an ``UpdatablePageSource`` instance, layered over the\n+  connector's ``ConnectorPageSource``, to read pages on behalf of the Presto engine, and to\n+  write deletions and/or updates to the underlying data store.\n+* The connector's ``UpdatablePageSource.getNextPage()`` implementation fetches the next page\n+  from the underlying ``ConnectorPageSource``, optionally reformats the page, and returns it\n+  to the Presto engine.\n+* The Presto engine performs filtering and projection on the page read, producing a page of filtered,\n+  projected results.\n+* The Presto engine passes that filtered, projected page of results to the connector's\n+  ``UpdatablePageSource`` ``deleteRows()`` or ``updateRows()`` method.  Those methods persist\n+  the deletions or updates in the underlying data store.\n+* When all the pages for a specific split have been processed, the Presto engine calls\n+  ``UpdatablePageSource.finish()``, which returns a ``Collection<Slice>`` of \"fragments\"\n+  representing connector-specific information about the rows processed by the calls to\n+  ``deleteRows`` or ``updateRows``.\n+* When all pages for all splits have been processed, the Presto engine calls ``ConnectorMetadata.finishDelete()`` or\n+  ``finishUpdate``, passing a collection containing all the \"fragments\" from all the splits.  The connector\n+  does what is required to finalize the operation, for example, committing the transaction.\n+\n+The rowId Column Abstraction\n+============================\n+\n+The Presto engine and connectors use a \"rowId\" column handle abstraction to agree on the identities of rows\n+to be updated or deleted.  The rowId column handle is opaque to the Presto engine.  Depending on the connector,\n+the rowId column handle abstraction could represent several physical columns.  For the JDBC connector, the rowId\n+column handle points might be the primary key for the table.  For deletion in Hive ACID tables, the rowId consists\n+of the three ACID columns that uniquely identify rows.\n+\n+The rowId Column for ``DELETE``\n+-------------------------------\n+\n+The Presto engine identifies the rows to be deleted using a connector-specific\n+rowId column handle, returned by the connector's ``ConnectorMetadata.getDeleteRowIdColumnHandle()``\n+method, whose full signature is::\n+\n+    ColumnHandle getDeleteRowIdColumnHandle(\n+        ConnectorSession session,\n+        ConnectorTableHandle tableHandle)\n+\n+The rowId Column for ``UPDATE``\n+-------------------------------\n+\n+The Presto engine identifies rows to be updated using a connector-specific rowId column handle,\n+returned by the connector's ``ConnectorMetadata.getUpdateRowIdColumnHandle()``\n+method.  In addition to the columns that identify the row, for ``UPDATE`` the rowId column will contain\n+any columns that the connector requires in order to perform the ``UPDATE`` operation.  In Hive ACID, for example,\n+the rowId column contains the values of all columns *not* updated by the ``UPDATE`` operation, since Hive ACID\n+implements ``UPDATE`` as a ``DELETE`` paired with an INSERT.\n+\n+UpdatablePageSource API\n+=======================\n+\n+As mentioned above, to support ``DELETE`` or ``UPDATE``, the connector must define a subclass of\n+``UpdatablePageSource``, layered over the connector's usual ``ConnectorPageSource``.  The interesting methods are:\n+\n+* ``Page getNextPage()``.  When the Presto engine calls ``getNextPage()``, the ``UpdatablePageSource`` calls\n+  its underlying ``ConnectorPageSource.getNextPage()`` method to get a page.  Some connectors will reformat\n+  the page before returning it to the Presto engine.\n+\n+* ``void deleteRows(Block rowIds)``.  The Presto engine calls the ``deleteRows()`` method of the same ``UpdatablePageSource``\n+  instance that supplied the original page,  passing a block of \"rowIds\", created by the Presto engine based on the column\n+  handle returned by ``ConnectorMetadata.getDeleteRowIdColumnHandle()``\n+\n+* ``void updateRows(Page page)``.  The Presto engine calls the ``updateRows()`` method of the same ``UpdatablePageSource``\n+  instance that supplied the original page, passing a page of projected columns, one for each updated column and one for\n+  the rowId column.  The order of projected columns is defined by the Presto engine, and that order is reflected in the\n+  ``updateExpressionChannelNumbers`` argument to ``ConnectorMetadata.beginUpdate()``.  The job of ``updateRows()`` is to:\n+\n+  * Extract the updated column blocks and the rowId block from the projected page.\n+  * Assemble them in whatever order is required by the connector for storage.\n+  * Store the update result in the underlying file store.\n+\n+  In the case of Hive ACID, ``updateRows()`` stores a file of records that delete the\n+  previous contents of the updated rows, and a separate file that inserts completely\n+  new rows containing the updated and non-updated column values.\n+\n+* ``CompletableFuture<Collection<Slice>> finish()``.  The Presto engine calls ``finish()`` when all the pages\n+  of a split have been processed.  The connector returns a future containing a collection of ``Slice``, representing\n+  connector-specific information about the rows processed.  Usually this will include the row count, and might\n+  include information like the files or partitions created or changed.\n+\n+``ConnectorMetadata`` ``DELETE`` API\n+====================================\n+\n+A connector implementing ``DELETE`` must specify three ``ConnectorMetadata`` methods.\n+\n+* ``getDeleteRowIdColumnHandle()``::\n+\n+   ColumnHandle getDeleteRowIdColumnHandle(\n+        ConnectorSession session,\n+        ConnectorTableHandle tableHandle)\n+\n+  The ColumnHandle returned by this method provides the \"rowId\" used by the connector to identify rows to be deleted, as\n+  well as any other fields of the row that the connector will need to complete the ``DELETE`` operation.\n+  For a JDBC connector, that rowId is usually the primary key for the table and no other fields are required.\n+  For other connectors, the information needed to identify a row usually consists of multiple physical columns.\n+  With the Hive connector and a Hive ACID table, for example, the ``DELETE`` rowId consists of the three ORC ACID columns\n+  that identify the row.\n+\n+* ``beginDelete()``::\n+\n+    ConnectorTableHandle beginDelete(\n+         ConnectorSession session,\n+         ConnectorTableHandle tableHandle,\n+         Map<String, ColumnHandle> columnHandles)\n+\n+  As the last step in creating the ``DELETE`` execution plan, the connector's ``beginDelete()`` method is called.\n+  In addition to the ``session`` and ``tableHandle``, a map of all column hanedles is supplied.\n+\n+  ``beginDelete()`` performs any orchestration needed in the connector to start processing the ``DELETE``.\n+  This orchestration varies from connector to connector.  In the Hive ACID connector, for example, ``beginDelete()``\n+  checks that the table is transactional and starts a Hive Metastore transaction.\n+\n+  ``beginDelete()`` returns a ``ConnectorTableHandle`` with any added information the connector needs when the handle\n+  is passed back to ``finishDelete()`` and the split generation machinery.  For most connectors, the returned table\n+  handle contains a flag identifying the table handle as a table handle for a ``DELETE`` operation.\n+\n+* ``finishDelete()``::\n+\n+      void finishDelete(\n+          ConnectorSession session,\n+          ConnectorTableHandle tableHandle,\n+          Collection<Slice> fragments)\n+\n+  During ``DELETE`` processing, the Presto engine accumulates the ``Slice`` collections returned by ``UpdatablePageSource.finish()``.\n+  After all splits have been processed, the engine calls ``finishDelete()``, passing the table handle and that\n+  collection of ``Slice`` fragments.  In response, the connector takes appropriate actions to complete the ``Delete`` operation.\n+  Those actions might include committing the transaction, assuming the connector supports a transaction paradigm.\n+\n+``ConnectorMetadata`` ``UPDATE`` API\n+====================================\n+\n+A connector implementing ``UPDATE`` must specify three ``ConnectorMetadata`` methods.\n+\n+* ``getUpdateRowIdColumnHandle``::\n+\n+   ColumnHandle getUpdateRowIdColumnHandle(\n+        ConnectorSession session,\n+        ConnectorTableHandle tableHandle,\n+        List<ColumnHandle> updatedColumns)\n+\n+  The ``updatedColumns`` list contains column handles for all columns updated by the ``UPDATE`` operation in table column order.\n+\n+  The ColumnHandle returned by this method provides the \"rowId\" used by the connector to identify rows to be updated, as\n+  well as any other fields of the row that the connector will need to complete the ``UPDATE`` operation.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkzMDI4Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526930287", "bodyText": "The challenge is that some connectors won't have any other values.  For example, the JDBC connector may not need any other column values besides the SET  expressions, while the Hive connector needs the values of all columns that are not the targets of SET expressions.", "author": "djsstarburst", "createdAt": "2020-11-19T14:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0MzQ1NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r527043454", "bodyText": "You can think of the \"row ID\" field as being anything that the connector needs to pass between the table scan and the update/delete. I would agree that name \"row ID\" is a bit misleading with that definition, but from an API and implementation perspective, having a single column is simpler. (since with a row type, you can have any number of nested columns)", "author": "electrum", "createdAt": "2020-11-19T16:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzODA5Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r527238093", "bodyText": "makes sense from an implementation perspective, but probably we can rename it accordingly", "author": "abhishekkhanna1", "createdAt": "2020-11-19T22:14:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTYwOQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526725609", "bodyText": "Might not be relevant, just thinking out loud. What would be the behavior if there is a concurrent Alter table which drops or renames the columns before the beginUpdate is invoked?", "author": "abhishekkhanna1", "createdAt": "2020-11-19T09:47:35Z", "path": "presto-docs/src/main/sphinx/develop/delete-and-update.rst", "diffHunk": "@@ -0,0 +1,203 @@\n+====================================\n+Supporting ``DELETE`` and ``UPDATE``\n+====================================\n+\n+The Presto engine provides APIs to support row-level SQL ``DELETE`` and ``UPDATE``.\n+To implement ``DELETE`` or ``UPDATE``, a connector must layer an ``UpdatablePageSource``\n+on top of the connector's usual ``ConnectorPageSource``, and define ``ConnectorMetadata``\n+methods to get a \"rowId\" column handle; to start the operation; and to finish the operation.\n+\n+``DELETE`` and ``UPDATE`` Data Flow\n+===================================\n+\n+``DELETE`` and ``UPDATE`` have a similar flow:\n+\n+* For each split, the connector will create an ``UpdatablePageSource`` instance, layered over the\n+  connector's ``ConnectorPageSource``, to read pages on behalf of the Presto engine, and to\n+  write deletions and/or updates to the underlying data store.\n+* The connector's ``UpdatablePageSource.getNextPage()`` implementation fetches the next page\n+  from the underlying ``ConnectorPageSource``, optionally reformats the page, and returns it\n+  to the Presto engine.\n+* The Presto engine performs filtering and projection on the page read, producing a page of filtered,\n+  projected results.\n+* The Presto engine passes that filtered, projected page of results to the connector's\n+  ``UpdatablePageSource`` ``deleteRows()`` or ``updateRows()`` method.  Those methods persist\n+  the deletions or updates in the underlying data store.\n+* When all the pages for a specific split have been processed, the Presto engine calls\n+  ``UpdatablePageSource.finish()``, which returns a ``Collection<Slice>`` of \"fragments\"\n+  representing connector-specific information about the rows processed by the calls to\n+  ``deleteRows`` or ``updateRows``.\n+* When all pages for all splits have been processed, the Presto engine calls ``ConnectorMetadata.finishDelete()`` or\n+  ``finishUpdate``, passing a collection containing all the \"fragments\" from all the splits.  The connector\n+  does what is required to finalize the operation, for example, committing the transaction.\n+\n+The rowId Column Abstraction\n+============================\n+\n+The Presto engine and connectors use a \"rowId\" column handle abstraction to agree on the identities of rows\n+to be updated or deleted.  The rowId column handle is opaque to the Presto engine.  Depending on the connector,\n+the rowId column handle abstraction could represent several physical columns.  For the JDBC connector, the rowId\n+column handle points might be the primary key for the table.  For deletion in Hive ACID tables, the rowId consists\n+of the three ACID columns that uniquely identify rows.\n+\n+The rowId Column for ``DELETE``\n+-------------------------------\n+\n+The Presto engine identifies the rows to be deleted using a connector-specific\n+rowId column handle, returned by the connector's ``ConnectorMetadata.getDeleteRowIdColumnHandle()``\n+method, whose full signature is::\n+\n+    ColumnHandle getDeleteRowIdColumnHandle(\n+        ConnectorSession session,\n+        ConnectorTableHandle tableHandle)\n+\n+The rowId Column for ``UPDATE``\n+-------------------------------\n+\n+The Presto engine identifies rows to be updated using a connector-specific rowId column handle,\n+returned by the connector's ``ConnectorMetadata.getUpdateRowIdColumnHandle()``\n+method.  In addition to the columns that identify the row, for ``UPDATE`` the rowId column will contain\n+any columns that the connector requires in order to perform the ``UPDATE`` operation.  In Hive ACID, for example,\n+the rowId column contains the values of all columns *not* updated by the ``UPDATE`` operation, since Hive ACID\n+implements ``UPDATE`` as a ``DELETE`` paired with an INSERT.\n+\n+UpdatablePageSource API\n+=======================\n+\n+As mentioned above, to support ``DELETE`` or ``UPDATE``, the connector must define a subclass of\n+``UpdatablePageSource``, layered over the connector's usual ``ConnectorPageSource``.  The interesting methods are:\n+\n+* ``Page getNextPage()``.  When the Presto engine calls ``getNextPage()``, the ``UpdatablePageSource`` calls\n+  its underlying ``ConnectorPageSource.getNextPage()`` method to get a page.  Some connectors will reformat\n+  the page before returning it to the Presto engine.\n+\n+* ``void deleteRows(Block rowIds)``.  The Presto engine calls the ``deleteRows()`` method of the same ``UpdatablePageSource``\n+  instance that supplied the original page,  passing a block of \"rowIds\", created by the Presto engine based on the column\n+  handle returned by ``ConnectorMetadata.getDeleteRowIdColumnHandle()``\n+\n+* ``void updateRows(Page page)``.  The Presto engine calls the ``updateRows()`` method of the same ``UpdatablePageSource``\n+  instance that supplied the original page, passing a page of projected columns, one for each updated column and one for\n+  the rowId column.  The order of projected columns is defined by the Presto engine, and that order is reflected in the\n+  ``updateExpressionChannelNumbers`` argument to ``ConnectorMetadata.beginUpdate()``.  The job of ``updateRows()`` is to:\n+\n+  * Extract the updated column blocks and the rowId block from the projected page.\n+  * Assemble them in whatever order is required by the connector for storage.\n+  * Store the update result in the underlying file store.\n+\n+  In the case of Hive ACID, ``updateRows()`` stores a file of records that delete the\n+  previous contents of the updated rows, and a separate file that inserts completely\n+  new rows containing the updated and non-updated column values.\n+\n+* ``CompletableFuture<Collection<Slice>> finish()``.  The Presto engine calls ``finish()`` when all the pages\n+  of a split have been processed.  The connector returns a future containing a collection of ``Slice``, representing\n+  connector-specific information about the rows processed.  Usually this will include the row count, and might\n+  include information like the files or partitions created or changed.\n+\n+``ConnectorMetadata`` ``DELETE`` API\n+====================================\n+\n+A connector implementing ``DELETE`` must specify three ``ConnectorMetadata`` methods.\n+\n+* ``getDeleteRowIdColumnHandle()``::\n+\n+   ColumnHandle getDeleteRowIdColumnHandle(\n+        ConnectorSession session,\n+        ConnectorTableHandle tableHandle)\n+\n+  The ColumnHandle returned by this method provides the \"rowId\" used by the connector to identify rows to be deleted, as\n+  well as any other fields of the row that the connector will need to complete the ``DELETE`` operation.\n+  For a JDBC connector, that rowId is usually the primary key for the table and no other fields are required.\n+  For other connectors, the information needed to identify a row usually consists of multiple physical columns.\n+  With the Hive connector and a Hive ACID table, for example, the ``DELETE`` rowId consists of the three ORC ACID columns\n+  that identify the row.\n+\n+* ``beginDelete()``::\n+\n+    ConnectorTableHandle beginDelete(\n+         ConnectorSession session,\n+         ConnectorTableHandle tableHandle,\n+         Map<String, ColumnHandle> columnHandles)\n+\n+  As the last step in creating the ``DELETE`` execution plan, the connector's ``beginDelete()`` method is called.\n+  In addition to the ``session`` and ``tableHandle``, a map of all column hanedles is supplied.\n+\n+  ``beginDelete()`` performs any orchestration needed in the connector to start processing the ``DELETE``.\n+  This orchestration varies from connector to connector.  In the Hive ACID connector, for example, ``beginDelete()``\n+  checks that the table is transactional and starts a Hive Metastore transaction.\n+\n+  ``beginDelete()`` returns a ``ConnectorTableHandle`` with any added information the connector needs when the handle\n+  is passed back to ``finishDelete()`` and the split generation machinery.  For most connectors, the returned table\n+  handle contains a flag identifying the table handle as a table handle for a ``DELETE`` operation.\n+\n+* ``finishDelete()``::\n+\n+      void finishDelete(\n+          ConnectorSession session,\n+          ConnectorTableHandle tableHandle,\n+          Collection<Slice> fragments)\n+\n+  During ``DELETE`` processing, the Presto engine accumulates the ``Slice`` collections returned by ``UpdatablePageSource.finish()``.\n+  After all splits have been processed, the engine calls ``finishDelete()``, passing the table handle and that\n+  collection of ``Slice`` fragments.  In response, the connector takes appropriate actions to complete the ``Delete`` operation.\n+  Those actions might include committing the transaction, assuming the connector supports a transaction paradigm.\n+\n+``ConnectorMetadata`` ``UPDATE`` API\n+====================================\n+\n+A connector implementing ``UPDATE`` must specify three ``ConnectorMetadata`` methods.\n+\n+* ``getUpdateRowIdColumnHandle``::\n+\n+   ColumnHandle getUpdateRowIdColumnHandle(\n+        ConnectorSession session,\n+        ConnectorTableHandle tableHandle,\n+        List<ColumnHandle> updatedColumns)\n+\n+  The ``updatedColumns`` list contains column handles for all columns updated by the ``UPDATE`` operation in table column order.\n+\n+  The ColumnHandle returned by this method provides the \"rowId\" used by the connector to identify rows to be updated, as\n+  well as any other fields of the row that the connector will need to complete the ``UPDATE`` operation.\n+  For a JDBC connector, that rowId is usually the primary key for the table and no other fields are required.\n+  For other connectors, the information needed to identify a row usually consists of multiple physical columns.\n+  Moreover, some connectors may need the values of columns that are not updated to complete the ``UPDATE`` operation.\n+  With the Hive connector and a Hive ACID table, for example, the ``UPDATE`` rowId consists of the three ORC ACID columns\n+  that identify the row, plus the values of all the data columns not updated.\n+\n+* ``beginUpdate``::\n+\n+    ConnectorTableHandle beginUpdate(\n+         ConnectorSession session,\n+         ConnectorTableHandle tableHandle,\n+         Map<String, ColumnHandle> columnHandles,\n+         List<ColumnHandle> updatedColumns,\n+         List<Integer> updateExpressionChannelNumbers)\n+\n+  As the last step in creating the ``UPDATE`` execution plan, the connector's ``beginUpdate()`` method is called,\n+  passing arguments that define the ``UPDATE`` to the connector.  In addition to the ``session``\n+  and ``tableHandle``, the arguments include the list of the updated columns and a list of channel numbers of\n+  updated columns in the projected page created by the Presto engine and passed into ``UpdatablePageSource.updateRows()``.\n+  All column lists are in table column order, as are the ``updateExpressionChannelNumbers``.  The size of\n+  ``updateExpressionChannelNumbers`` is one greater than the number of updated columns - - the last element of the\n+  list is the channel number of the block of rowIds for the page, constructed from the rowId column handle.\n+\n+  ``beginUpdate()`` performs any orchestration needed in the connector to start processing the ``UPDATE``.\n+  This orchestration varies from connector to connector.  In the Hive ACID connector, for example, ``beginUpdate()``\n+  starts the Hive Metastore transaction; checks that the updated table is transactional and that neither", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkzMDIyMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526930220", "bodyText": "It's a good question, and an area that is poorly tested.  If you could think of a way to test commit and rollback it would be a big contribution.  Here is the way I think it works:\nIf the ALTER TABLE transaction committed before beginUpdate() was called, the UPDATE operation would fail because the StatementAnalyzer would fail to find a referenced column.  If the ALTER TABLE transaction was started but not committed by the time beginUpdate() was called, I think the call to metastore.declareIntentionToWrite() will cause a rollback of the beginUpdate() transaction when the ALTER TABLE transaction commits.  But I'm guessing, and don't have tests to prove that it works that way :(", "author": "djsstarburst", "createdAt": "2020-11-19T14:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0NDg3MQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r527044871", "bodyText": "Assuming the metastore was a proper transactional system that implemented optimistic concurrency, the commit of the UPDATE operation would fail due to the conflict. That's how it will work for Iceberg, which properly supports transaction semantics.", "author": "electrum", "createdAt": "2020-11-19T16:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzODIwMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r527238200", "bodyText": "Makes sense that as long as we have OCC backed metastore, one of the conflicting transaction would be rejected. But, I was thinking can there be an Alter table request which makes the conflict not detectable because we rely on the names/order of the columns? e.g the scenarios listed here https://iceberg.apache.org/evolution/#correctness\n    Formats that track columns by name can inadvertently un-delete a column if a name is reused, which violates #1.\n    Formats that track columns by position cannot delete columns without changing the names that are used for each column, which violates #2.", "author": "abhishekkhanna1", "createdAt": "2020-11-19T22:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTY3OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526725679", "bodyText": "As the WriterKind is being used across plugins/connectors, should we move it out of the hive plugin module?", "author": "abhishekkhanna1", "createdAt": "2020-11-19T09:47:41Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergOrcFileWriter.java", "diffHunk": "@@ -31,6 +31,7 @@\n import io.prestosql.orc.metadata.statistics.DoubleStatistics;\n import io.prestosql.orc.metadata.statistics.IntegerStatistics;\n import io.prestosql.orc.metadata.statistics.StringStatistics;\n+import io.prestosql.plugin.hive.WriterKind;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk0MTkzNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526941937", "bodyText": "WriterKind is specific to presto-hive's OrcFileWriter, which is used by both presto-hive and presto-iceberg.  Module presto-iceberg depends on presto-hive.  I don't think it makes sense to move WriterKind into presto-spi, because not all connectors will need the distinction between delete writers and insert writers.  We need to for OrcFileWriter because the files written for DELETE and INSERT have different formats in ORC ACID.", "author": "djsstarburst", "createdAt": "2020-11-19T14:45:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzODI4Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r527238282", "bodyText": "Sure, we can have it here. With other connectors if we find a similar need, we can move it later", "author": "abhishekkhanna1", "createdAt": "2020-11-19T22:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTc2OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526725768", "bodyText": "Apart from the addInput method, this class seems to be duplicating most of the stuff from DeleteOperator class. Should we have an abstract parent?", "author": "abhishekkhanna1", "createdAt": "2020-11-19T09:47:51Z", "path": "presto-main/src/main/java/io/prestosql/operator/UpdateOperator.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator;\n+\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.PageBuilder;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.connector.UpdatablePageSource;\n+import io.prestosql.sql.planner.plan.PlanNodeId;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.airlift.concurrent.MoreFutures.toListenableFuture;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.VarbinaryType.VARBINARY;\n+import static java.util.Objects.requireNonNull;\n+\n+public class UpdateOperator", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkzNTU2OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526935569", "bodyText": "It's a good point.  In general, as you've probably observed, class inheritance is used sparingly in Presto, but this seems a good candidate.\nI'll chat @electrum about it.", "author": "djsstarburst", "createdAt": "2020-11-19T14:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTc2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxODg3MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528218870", "bodyText": "As you observed, nearly all of the code duplicated in DeleteOperator and UpdateOperator can be shared.  I introduced new base class AbstractRowChangingOperator, and changed DeleteOperator and UpdateOperator to inherit from it.\nA very nice cleanup!", "author": "djsstarburst", "createdAt": "2020-11-21T17:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNjA2NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526726064", "bodyText": "nit: s/rowIdColumn/rowIdColumnHandle/g to differentiate from just the rowId column", "author": "abhishekkhanna1", "createdAt": "2020-11-19T09:48:15Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1248,13 +1259,31 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n                 analysis.setColumn(field, columnHandle);\n             }\n \n-            if (isUpdateQuery) {\n+            if (updateKind.isPresent()) {\n                 // Add the row id field\n-                ColumnHandle column = metadata.getUpdateRowIdColumnHandle(session, tableHandle.get());\n-                Type type = metadata.getColumnMetadata(session, tableHandle.get(), column).getType();\n+                ColumnHandle rowIdColumn;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk0MjEwMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r526942101", "bodyText": "Good point; changed.", "author": "djsstarburst", "createdAt": "2020-11-19T14:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyNjA2NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0MDAxOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r527040018", "bodyText": "We can use the existing COLUMN_NOT_FOUND", "author": "electrum", "createdAt": "2020-11-19T16:49:59Z", "path": "presto-spi/src/main/java/io/prestosql/spi/StandardErrorCode.java", "diffHunk": "@@ -112,6 +112,7 @@\n     NESTED_RECURSIVE(89, USER_ERROR),\n     INVALID_LIMIT_CLAUSE(90, USER_ERROR),\n     INVALID_ORDER_BY(91, USER_ERROR),\n+    UPDATE_COLUMN_DOESNT_EXIST(92, USER_ERROR),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxODg3OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528218879", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-21T17:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA0MDAxOA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwNjExOQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r527006119", "bodyText": "UnsupportedOperationException would be more appropriate here. updateKind is an argument to this class -- here we're just signaling that this class doesn't know how to handle it.", "author": "martint", "createdAt": "2020-11-19T16:05:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1248,13 +1259,31 @@ protected Scope visitTable(Table table, Optional<Scope> scope)\n                 analysis.setColumn(field, columnHandle);\n             }\n \n-            if (isUpdateQuery) {\n+            if (updateKind.isPresent()) {\n                 // Add the row id field\n-                ColumnHandle column = metadata.getUpdateRowIdColumnHandle(session, tableHandle.get());\n-                Type type = metadata.getColumnMetadata(session, tableHandle.get(), column).getType();\n+                ColumnHandle rowIdColumnHandle;\n+                switch (updateKind.get()) {\n+                    case DELETE:\n+                        rowIdColumnHandle = metadata.getDeleteRowIdColumnHandle(session, tableHandle.get());\n+                        break;\n+                    case UPDATE:\n+                        List<ColumnMetadata> updatedColumnMetadata = analysis.getUpdatedColumns()\n+                                .orElseThrow(() -> new VerifyException(\"updated columns not set\"));\n+                        Set<String> updatedColumnNames = updatedColumnMetadata.stream().map(ColumnMetadata::getName).collect(toImmutableSet());\n+                        List<ColumnHandle> updatedColumns = columnHandles.entrySet().stream()\n+                                .filter(entry -> updatedColumnNames.contains(entry.getKey()))\n+                                .map(Map.Entry::getValue)\n+                                .collect(toImmutableList());\n+                        rowIdColumnHandle = metadata.getUpdateRowIdColumnHandle(session, tableHandle.get(), updatedColumns);\n+                        break;\n+                    default:\n+                        throw new VerifyException(\"Unknown UpdateKind \" + updateKind.get());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMDYzMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529100632", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-24T01:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwNjExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NTM2Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528975366", "bodyText": "DEFAULT is no longer used, so it should be removed from here.", "author": "martint", "createdAt": "2020-11-23T20:26:12Z", "path": "presto-parser/src/main/antlr4/io/prestosql/sql/parser/SqlBase.g4", "diffHunk": "@@ -536,7 +542,7 @@ nonReserved\n     : ADD | ADMIN | ALL | ANALYZE | ANY | ARRAY | ASC | AT | AUTHORIZATION\n     | BERNOULLI\n     | CALL | CASCADE | CATALOGS | COLUMN | COLUMNS | COMMENT | COMMIT | COMMITTED | CURRENT\n-    | DATA | DATE | DAY | DEFINER | DESC | DISTRIBUTED | DOUBLE\n+    | DATA | DATE | DAY | DEFAULT | DEFINER | DESC | DISTRIBUTED | DOUBLE", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMDcxMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529100713", "bodyText": "I'd previously removed the definition, but not this reference.  Removed.", "author": "djsstarburst", "createdAt": "2020-11-24T01:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NTM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NTU3OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528975578", "bodyText": "This belongs in the other commit.", "author": "martint", "createdAt": "2020-11-23T20:26:39Z", "path": "presto-iceberg/src/main/java/io/prestosql/plugin/iceberg/IcebergOrcFileWriter.java", "diffHunk": "@@ -78,7 +79,7 @@ public IcebergOrcFileWriter(\n             OrcWriteValidation.OrcWriteValidationMode validationMode,\n             OrcWriterStats stats)\n     {\n-        super(orcDataSink, NO_ACID_TRANSACTION, false, OptionalInt.empty(), rollbackAction, columnNames, fileColumnTypes, fileColumnOrcTypes, compression, options, writeLegacyVersion, fileInputColumnIndexes, metadata, validationInputFactory, validationMode, stats);\n+        super(orcDataSink, WriterKind.INSERT, NO_ACID_TRANSACTION, false, OptionalInt.empty(), rollbackAction, columnNames, fileColumnTypes, fileColumnOrcTypes, compression, options, writeLegacyVersion, fileInputColumnIndexes, metadata, validationInputFactory, validationMode, stats);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMDc0OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529100749", "bodyText": "Good point; moved.", "author": "djsstarburst", "createdAt": "2020-11-24T01:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NTU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NzMwOQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528977309", "bodyText": "What's an \"update expression channel number\"? Note that channels are a physical concept and not appropriate during query planning.", "author": "martint", "createdAt": "2020-11-23T20:30:08Z", "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -319,6 +324,16 @@\n      */\n     void finishDelete(Session session, TableHandle tableHandle, Collection<Slice> fragments);\n \n+    /**\n+     * Begin update query\n+     */\n+    TableHandle beginUpdate(Session session, TableHandle tableHandle, List<ColumnHandle> updatedColumns, List<Integer> updateExpressionChannelNumbers);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMDc5MQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529100791", "bodyText": "The updateExpressionChannelNumbers give the channel numbers of the projected update SET expressions in the Page supplied to UpdatablePageSource.updateRows().\nI've done this kind of thing differently for SQL Merge - - I packaged up the merge SET expressions in a RowType, so I can guarantee the order.\nThis will take some thought - - I'll commit changes for your other comments and come back to this.", "author": "djsstarburst", "createdAt": "2020-11-24T01:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NzMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxMDA5MQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529710091", "bodyText": "As commented below, I got rid of updateExpressionChannelNumbers.  Now it only shows up as an argument to UpdatablePageSource.updateRows().", "author": "djsstarburst", "createdAt": "2020-11-24T16:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk3NzMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4MzA2Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528983067", "bodyText": "The exception should link to the AST node corresponding to the column name (i.e., assignment.getName()) so that the location of the error is more precise and clients can render a better error.", "author": "martint", "createdAt": "2020-11-23T20:41:38Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1764,6 +1792,106 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns();\n+            Map<String, ColumnMetadata> columns = allColumns.stream()\n+                    .collect(toImmutableMap(ColumnMetadata::getName, Function.identity()));\n+\n+            for (UpdateAssignment assignment : update.getAssignments()) {\n+                String columnName = assignment.getName().getValue();\n+                if (!columns.containsKey(columnName)) {\n+                    throw semanticException(COLUMN_NOT_FOUND, update, \"The UPDATE SET target column %s doesn't exist\", columnName);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMDgzMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529100831", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-24T01:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4MzA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4NDIyMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528984220", "bodyText": "\"Updating a table with a row filter is not supported\"", "author": "martint", "createdAt": "2020-11-23T20:43:57Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1764,6 +1792,106 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns();\n+            Map<String, ColumnMetadata> columns = allColumns.stream()\n+                    .collect(toImmutableMap(ColumnMetadata::getName, Function.identity()));\n+\n+            for (UpdateAssignment assignment : update.getAssignments()) {\n+                String columnName = assignment.getName().getValue();\n+                if (!columns.containsKey(columnName)) {\n+                    throw semanticException(COLUMN_NOT_FOUND, update, \"The UPDATE SET target column %s doesn't exist\", columnName);\n+                }\n+            }\n+\n+            Set<String> assignmentTargets = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, assignmentTargets);\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMDg2Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529100867", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-24T01:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4NDIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4NDM1Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528984353", "bodyText": "\"Updating a table with column masks is not supported\"", "author": "martint", "createdAt": "2020-11-23T20:44:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1764,6 +1792,106 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns();\n+            Map<String, ColumnMetadata> columns = allColumns.stream()\n+                    .collect(toImmutableMap(ColumnMetadata::getName, Function.identity()));\n+\n+            for (UpdateAssignment assignment : update.getAssignments()) {\n+                String columnName = assignment.getName().getValue();\n+                if (!columns.containsKey(columnName)) {\n+                    throw semanticException(COLUMN_NOT_FOUND, update, \"The UPDATE SET target column %s doesn't exist\", columnName);\n+                }\n+            }\n+\n+            Set<String> assignmentTargets = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, assignmentTargets);\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");\n+            }\n+\n+            for (ColumnMetadata tableColumn : allColumns) {\n+                if (!accessControl.getColumnMasks(session.toSecurityContext(), tableName, tableColumn.getName(), tableColumn.getType()).isEmpty()) {\n+                    throw semanticException(NOT_SUPPORTED, update, \"Update table with column mask\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMDg4Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529100886", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-24T01:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4NDM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4NTk4NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528985985", "bodyText": "Technically, this should be allowed if the columns with masks are not in the assignments list, but it would only work for connectors that don't require seeing the original value for other columns to perform the update.", "author": "martint", "createdAt": "2020-11-23T20:47:08Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1764,6 +1792,106 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns();\n+            Map<String, ColumnMetadata> columns = allColumns.stream()\n+                    .collect(toImmutableMap(ColumnMetadata::getName, Function.identity()));\n+\n+            for (UpdateAssignment assignment : update.getAssignments()) {\n+                String columnName = assignment.getName().getValue();\n+                if (!columns.containsKey(columnName)) {\n+                    throw semanticException(COLUMN_NOT_FOUND, update, \"The UPDATE SET target column %s doesn't exist\", columnName);\n+                }\n+            }\n+\n+            Set<String> assignmentTargets = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, assignmentTargets);\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");\n+            }\n+\n+            for (ColumnMetadata tableColumn : allColumns) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMTAzOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529101038", "bodyText": "Should I limit the check to updated columns?", "author": "djsstarburst", "createdAt": "2020-11-24T01:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4NTk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTgzODgwNA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529838804", "bodyText": "I would leave it for now, but add a TODO. It will require more thinking about how to deal with connectors that need to see the pre-image of rows to perform the update without flowing that data through the masking logic.", "author": "martint", "createdAt": "2020-11-24T19:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4NTk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4ODE1Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528988153", "bodyText": "This is the same as assignmentTargets above.", "author": "martint", "createdAt": "2020-11-23T20:51:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1764,6 +1792,106 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns();\n+            Map<String, ColumnMetadata> columns = allColumns.stream()\n+                    .collect(toImmutableMap(ColumnMetadata::getName, Function.identity()));\n+\n+            for (UpdateAssignment assignment : update.getAssignments()) {\n+                String columnName = assignment.getName().getValue();\n+                if (!columns.containsKey(columnName)) {\n+                    throw semanticException(COLUMN_NOT_FOUND, update, \"The UPDATE SET target column %s doesn't exist\", columnName);\n+                }\n+            }\n+\n+            Set<String> assignmentTargets = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, assignmentTargets);\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");\n+            }\n+\n+            for (ColumnMetadata tableColumn : allColumns) {\n+                if (!accessControl.getColumnMasks(session.toSecurityContext(), tableName, tableColumn.getName(), tableColumn.getType()).isEmpty()) {\n+                    throw semanticException(NOT_SUPPORTED, update, \"Update table with column mask\");\n+                }\n+            }\n+\n+            Set<String> updatedTargetNames = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMTEwMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529101103", "bodyText": "Doh, removed.", "author": "djsstarburst", "createdAt": "2020-11-24T01:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk4ODE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk5NzgzMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r528997830", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .map(column -> column.getType())\n          \n          \n            \n                                .map(ColumnMetadata::getType)", "author": "martint", "createdAt": "2020-11-23T21:11:31Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1764,6 +1792,106 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns();\n+            Map<String, ColumnMetadata> columns = allColumns.stream()\n+                    .collect(toImmutableMap(ColumnMetadata::getName, Function.identity()));\n+\n+            for (UpdateAssignment assignment : update.getAssignments()) {\n+                String columnName = assignment.getName().getValue();\n+                if (!columns.containsKey(columnName)) {\n+                    throw semanticException(COLUMN_NOT_FOUND, update, \"The UPDATE SET target column %s doesn't exist\", columnName);\n+                }\n+            }\n+\n+            Set<String> assignmentTargets = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, assignmentTargets);\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Update table with row filter\");\n+            }\n+\n+            for (ColumnMetadata tableColumn : allColumns) {\n+                if (!accessControl.getColumnMasks(session.toSecurityContext(), tableName, tableColumn.getName(), tableColumn.getType()).isEmpty()) {\n+                    throw semanticException(NOT_SUPPORTED, update, \"Update table with column mask\");\n+                }\n+            }\n+\n+            Set<String> updatedTargetNames = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            List<ColumnMetadata> updatedColumns = allColumns.stream()\n+                    .filter(column -> updatedTargetNames.contains(column.getName()))\n+                    .collect(toImmutableList());\n+            analysis.setUpdateType(\"UPDATE\", tableName);\n+            analysis.setUpdatedColumns(updatedColumns);\n+\n+            // Analyzer checks for select permissions but UPDATE has a separate permission, so disable access checks\n+            StatementAnalyzer analyzer = new StatementAnalyzer(\n+                    analysis,\n+                    metadata,\n+                    sqlParser,\n+                    groupProvider,\n+                    new AllowAllAccessControl(),\n+                    session,\n+                    warningCollector,\n+                    CorrelationSupport.ALLOWED);\n+\n+            Scope tableScope = analyzer.analyzeForUpdate(table, scope, UpdateKind.UPDATE);\n+            update.getWhere().ifPresent(where -> analyzeWhere(update, tableScope, where));\n+\n+            ImmutableList.Builder<ExpressionAnalysis> analysesBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<Type> expressionTypesBuilder = ImmutableList.builder();\n+            for (UpdateAssignment assignment : update.getAssignments()) {\n+                Expression expression = assignment.getValue();\n+                ExpressionAnalysis analysis = analyzeExpression(expression, tableScope);\n+                analysesBuilder.add(analysis);\n+                expressionTypesBuilder.add(analysis.getType(expression));\n+            }\n+            List<ExpressionAnalysis> analyses = analysesBuilder.build();\n+            List<Type> expressionTypes = expressionTypesBuilder.build();\n+\n+            List<Type> tableTypes = update.getAssignments().stream()\n+                    .map(assignment -> requireNonNull(columns.get(assignment.getName().getValue())))\n+                    .map(column -> column.getType())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMTEzMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529101130", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-24T01:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk5NzgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMTM1Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529021352", "bodyText": "This should be determined and recorded during analysis. In particular:\n\nIt needs to respect identifier matching rules (with respect to quoting) -- that type of logic should not happen in the planner.\nanalysis.getColumnReferences will contain column references across the whole query, including references in nested subqueries, so it would be wrong to include those.", "author": "martint", "createdAt": "2020-11-23T21:55:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,104 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<Expression> orderedExpressionBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            orderedExpressionBuilder.add(node.getAssignments().get(index).getValue());\n+        }\n+        List<Expression> orderedExpressions = orderedExpressionBuilder.build();\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(orderedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, orderedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();\n+\n+        List<Symbol> expressionSymbols = orderedExpressions.stream()\n+                .map(expression -> requireNonNull(planAndMappings.get(expression), \"planAndMappings.get(expression) is null\"))\n+                .collect(Collectors.toList());\n+\n+        Set<String> dependencyColumnNames = analysis.getColumnReferences().stream()\n+                .map(NodeRef::getNode)\n+                .filter(someNode -> someNode instanceof Identifier)\n+                .map(someNode -> ((Identifier) someNode).getValue())\n+                .collect(toImmutableSet());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMTE5OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529101199", "bodyText": "This will take some thought.  I'll act on the other comments, and come back to this one.", "author": "djsstarburst", "createdAt": "2020-11-24T01:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMTM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwOTExMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529709112", "bodyText": "Actually, it didn't take much thought - - I can arrange that dependencyColumns is no longer required.  I removed it from here and from UpdateNode.", "author": "djsstarburst", "createdAt": "2020-11-24T16:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMTM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MDIzNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529050235", "bodyText": "This is not a good assumption to make. There's no guarantee that the top-level node produced by coerce is a projection node.\nHowever, it doesn't look like this needs to know it's a ProjectNode. It's using the key from the project node's assignments, which you can obtain from the node's getOutputSymbols.", "author": "martint", "createdAt": "2020-11-23T22:58:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,104 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<Expression> orderedExpressionBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            orderedExpressionBuilder.add(node.getAssignments().get(index).getValue());\n+        }\n+        List<Expression> orderedExpressions = orderedExpressionBuilder.build();\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(orderedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, orderedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMTI1Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529101256", "bodyText": "Good point; changed.", "author": "djsstarburst", "createdAt": "2020-11-24T01:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MDIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MTk5Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529051993", "bodyText": "remove requireNonNull (if anything, it should be a verify(), but I think it's overkill) and use Collectors.toImmutableList() below.", "author": "martint", "createdAt": "2020-11-23T23:02:03Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,104 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<Expression> orderedExpressionBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            orderedExpressionBuilder.add(node.getAssignments().get(index).getValue());\n+        }\n+        List<Expression> orderedExpressions = orderedExpressionBuilder.build();\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(orderedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, orderedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();\n+\n+        List<Symbol> expressionSymbols = orderedExpressions.stream()\n+                .map(expression -> requireNonNull(planAndMappings.get(expression), \"planAndMappings.get(expression) is null\"))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMTMzMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529101331", "bodyText": "requireNonNull removed, but the list needs to be mutable in order to add the rowId symbol at the end.  But maybe this needs to get re-thought along with the channel numbers.", "author": "djsstarburst", "createdAt": "2020-11-24T01:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA1MTk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NDIyNA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529064224", "bodyText": "These should be Symbols. It's the job of the LocalExecutionPlanner to turn then into physical channels numbers.", "author": "martint", "createdAt": "2020-11-23T23:32:14Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,104 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<Expression> orderedExpressionBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            orderedExpressionBuilder.add(node.getAssignments().get(index).getValue());\n+        }\n+        List<Expression> orderedExpressions = orderedExpressionBuilder.build();\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(orderedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, orderedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();\n+\n+        List<Symbol> expressionSymbols = orderedExpressions.stream()\n+                .map(expression -> requireNonNull(planAndMappings.get(expression), \"planAndMappings.get(expression) is null\"))\n+                .collect(Collectors.toList());\n+\n+        Set<String> dependencyColumnNames = analysis.getColumnReferences().stream()\n+                .map(NodeRef::getNode)\n+                .filter(someNode -> someNode instanceof Identifier)\n+                .map(someNode -> ((Identifier) someNode).getValue())\n+                .collect(toImmutableSet());\n+        List<ColumnHandle> dependencyColumns = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> dependencyColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        Symbol rowId = builder.translate(analysis.getRowIdField(table));\n+\n+        expressionSymbols.add(rowId);\n+        List<Integer> updateExpressionChannelNumbers = createUpdateExpressionChannelNumbers(projectNode.getAssignments(), expressionSymbols);\n+\n+        List<ColumnHandle> targets = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> targetColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        List<Symbol> projectedSymbols = new ArrayList<>();\n+        projectedSymbols.add(rowId);\n+        projectedSymbols.addAll(planAndMappings.mappings.values());\n+\n+        List<Symbol> outputs = ImmutableList.of(\n+                symbolAllocator.newSymbol(\"partialrows\", BIGINT),\n+                symbolAllocator.newSymbol(\"fragment\", VARBINARY));\n+\n+        // create update node\n+        return new UpdateNode(\n+                idAllocator.getNextId(),\n+                builder.getRoot(),\n+                new UpdateTarget(handle, metadata.getTableMetadata(session, handle).getTable(), targets, dependencyColumns, updateExpressionChannelNumbers),\n+                rowId,\n+                projectedSymbols,\n+                updateExpressionChannelNumbers,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMTM1Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529101357", "bodyText": "This will take a bit of thought.  I'll commit the other suggested changes, and then tackle this one.", "author": "djsstarburst", "createdAt": "2020-11-24T01:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NDIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwOTIwNg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529709206", "bodyText": "I eliminated use of updateExpressionChannelNumbers in StatementAnalyzer and QueryPlanner.  It's now created in LocalExecutionPlanner.visitUpdate(), saved in the UpdateOperatorFactory, and passed by UpdateOperator.addInput() to UpdatablePageSource.updateRows().  I believe this makes sense and is consistent with your review comments.", "author": "djsstarburst", "createdAt": "2020-11-24T16:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NDIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NjI0NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529066245", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Symbol> projectedSymbols = new ArrayList<>();\n          \n          \n            \n                    projectedSymbols.add(rowId);\n          \n          \n            \n                    projectedSymbols.addAll(planAndMappings.mappings.values());\n          \n          \n            \n                    List<Symbol> projectedSymbols = ImmutableList.<Symbol>builder()\n          \n          \n            \n                            .add(rowId)\n          \n          \n            \n                            .addAll(planAndMappings.mappings.values())\n          \n          \n            \n                            .build();", "author": "martint", "createdAt": "2020-11-23T23:37:45Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,104 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<Expression> orderedExpressionBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            orderedExpressionBuilder.add(node.getAssignments().get(index).getValue());\n+        }\n+        List<Expression> orderedExpressions = orderedExpressionBuilder.build();\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(orderedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, orderedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();\n+\n+        List<Symbol> expressionSymbols = orderedExpressions.stream()\n+                .map(expression -> requireNonNull(planAndMappings.get(expression), \"planAndMappings.get(expression) is null\"))\n+                .collect(Collectors.toList());\n+\n+        Set<String> dependencyColumnNames = analysis.getColumnReferences().stream()\n+                .map(NodeRef::getNode)\n+                .filter(someNode -> someNode instanceof Identifier)\n+                .map(someNode -> ((Identifier) someNode).getValue())\n+                .collect(toImmutableSet());\n+        List<ColumnHandle> dependencyColumns = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> dependencyColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        Symbol rowId = builder.translate(analysis.getRowIdField(table));\n+\n+        expressionSymbols.add(rowId);\n+        List<Integer> updateExpressionChannelNumbers = createUpdateExpressionChannelNumbers(projectNode.getAssignments(), expressionSymbols);\n+\n+        List<ColumnHandle> targets = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> targetColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        List<Symbol> projectedSymbols = new ArrayList<>();\n+        projectedSymbols.add(rowId);\n+        projectedSymbols.addAll(planAndMappings.mappings.values());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMTM3NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529101375", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-24T01:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NjI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NzI3Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529067276", "bodyText": "What's projectedSymbols", "author": "martint", "createdAt": "2020-11-23T23:40:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +475,104 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<Expression> orderedExpressionBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            orderedExpressionBuilder.add(node.getAssignments().get(index).getValue());\n+        }\n+        List<Expression> orderedExpressions = orderedExpressionBuilder.build();\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(orderedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, orderedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+        ProjectNode projectNode = (ProjectNode) builder.getRoot();\n+\n+        List<Symbol> expressionSymbols = orderedExpressions.stream()\n+                .map(expression -> requireNonNull(planAndMappings.get(expression), \"planAndMappings.get(expression) is null\"))\n+                .collect(Collectors.toList());\n+\n+        Set<String> dependencyColumnNames = analysis.getColumnReferences().stream()\n+                .map(NodeRef::getNode)\n+                .filter(someNode -> someNode instanceof Identifier)\n+                .map(someNode -> ((Identifier) someNode).getValue())\n+                .collect(toImmutableSet());\n+        List<ColumnHandle> dependencyColumns = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> dependencyColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        Symbol rowId = builder.translate(analysis.getRowIdField(table));\n+\n+        expressionSymbols.add(rowId);\n+        List<Integer> updateExpressionChannelNumbers = createUpdateExpressionChannelNumbers(projectNode.getAssignments(), expressionSymbols);\n+\n+        List<ColumnHandle> targets = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> targetColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        List<Symbol> projectedSymbols = new ArrayList<>();\n+        projectedSymbols.add(rowId);\n+        projectedSymbols.addAll(planAndMappings.mappings.values());\n+\n+        List<Symbol> outputs = ImmutableList.of(\n+                symbolAllocator.newSymbol(\"partialrows\", BIGINT),\n+                symbolAllocator.newSymbol(\"fragment\", VARBINARY));\n+\n+        // create update node\n+        return new UpdateNode(\n+                idAllocator.getNextId(),\n+                builder.getRoot(),\n+                new UpdateTarget(handle, metadata.getTableMetadata(session, handle).getTable(), targets, dependencyColumns, updateExpressionChannelNumbers),\n+                rowId,\n+                projectedSymbols,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTEwMTM5Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529101393", "bodyText": "projectedSymbols are the symbols for the UPDATE SET expressions, plus the rowId symbol.  They get used in PruneUpdateSourceColumns:\n    @Override\n    public Result apply(UpdateNode updateNode, Captures captures, Context context)\n    {\n        return restrictChildOutputs(context.getIdAllocator(), updateNode, ImmutableSet.copyOf(updateNode.getProjectedSymbols()))\n                .map(Result::ofPlanNode)\n                .orElse(Result.empty());\n    }", "author": "djsstarburst", "createdAt": "2020-11-24T01:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NzI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwOTI2Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529709267", "bodyText": "I renamed projectedSymbols to be expressionSymbols.", "author": "djsstarburst", "createdAt": "2020-11-24T16:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2NzI3Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MDMxMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529840311", "bodyText": "Since this needs to modify the list, the list shouldn't be built using Collectors.toList() above. There's no guarantee that such as list is mutable. From the javadocs:\n\nThere are no guarantees on the type, mutability, serializability, or thread-safety of the List returned;", "author": "martint", "createdAt": "2020-11-24T19:54:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +474,69 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<Expression> orderedExpressionBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            orderedExpressionBuilder.add(node.getAssignments().get(index).getValue());\n+        }\n+        List<Expression> orderedExpressions = orderedExpressionBuilder.build();\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(orderedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, orderedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+\n+        List<Symbol> expressionSymbols = orderedExpressions.stream()\n+                .map(planAndMappings::get)\n+                .collect(Collectors.toList());\n+\n+        Symbol rowId = builder.translate(analysis.getRowIdField(table));\n+\n+        expressionSymbols.add(rowId);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjgzMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662830", "bodyText": "Ah, I didn't realize that!  Changed to an ImmutableList.Builder.", "author": "djsstarburst", "createdAt": "2020-11-25T21:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MDMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MzEyMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529843122", "bodyText": "Do expressionSymbols need to be aligned with the columns listed in targets? If so, the fact that they are so disconnected is a little obscure and error prone.", "author": "martint", "createdAt": "2020-11-24T19:59:45Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +474,69 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create an UpdateAssignments list in table column order\n+        ImmutableList.Builder<Expression> orderedExpressionBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index < 0) {\n+                continue;\n+            }\n+            orderedExpressionBuilder.add(node.getAssignments().get(index).getValue());\n+        }\n+        List<Expression> orderedExpressions = orderedExpressionBuilder.build();\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(orderedExpressions, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, orderedExpressions, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+\n+        List<Symbol> expressionSymbols = orderedExpressions.stream()\n+                .map(planAndMappings::get)\n+                .collect(Collectors.toList());\n+\n+        Symbol rowId = builder.translate(analysis.getRowIdField(table));\n+\n+        expressionSymbols.add(rowId);\n+\n+        List<ColumnHandle> targets = dataColumnHandles.entrySet().stream()\n+                .filter(entry -> targetColumnNames.contains(entry.getKey()))\n+                .map(Map.Entry::getValue)\n+                .collect(toImmutableList());\n+\n+        List<Symbol> outputs = ImmutableList.of(\n+                symbolAllocator.newSymbol(\"partialrows\", BIGINT),\n+                symbolAllocator.newSymbol(\"fragment\", VARBINARY));\n+\n+        // create update node\n+        return new UpdateNode(\n+                idAllocator.getNextId(),\n+                builder.getRoot(),\n+                new UpdateTarget(handle, metadata.getTableMetadata(session, handle).getTable(), targets),\n+                rowId,\n+                expressionSymbols,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkyOTM4Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529929387", "bodyText": "Also, I would rename expressionSymbols to updatedColumns, updateInputs or something like that. expressionSymbols is too vague.", "author": "martint", "createdAt": "2020-11-24T22:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MzEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2Mjc4Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662787", "bodyText": "expressionSymbols must have the same order as targets.  I gave some thought to keeping both in a Map.    What I didn't like about that is that UpdateNode only cares about the Symbols, and UpdateTarget only cares about column handles.\nI changed the expressionSymbols to updatedColumnValueSymbols, and made the analogous changes to the expression list builder variable.  I also added a comment explaining the \"column value\" means the values of UPDATE column SET expressions.", "author": "djsstarburst", "createdAt": "2020-11-25T21:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MzEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2NDM3MQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530664371", "bodyText": "Ok. Although, I would remove the \"symbols\" part of the name. That's self-explanatory from the type of the variable.", "author": "martint", "createdAt": "2020-11-25T22:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MzEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2OTMyNg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530769326", "bodyText": "updatedColumnValueSymbols and friends have been re-Baptized as updatedColumnValues.", "author": "djsstarburst", "createdAt": "2020-11-26T04:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg0MzEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0ODczMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529948731", "bodyText": "Unrelated change?", "author": "martint", "createdAt": "2020-11-24T22:34:55Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/TranslationMap.java", "diffHunk": "@@ -116,7 +116,7 @@ public TranslationMap withNewMappings(Map<ScopeAware<Expression>, Symbol> mappin\n \n     public TranslationMap withAdditionalMappings(Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        Map<ScopeAware<Expression>, Symbol> newMappings = new HashMap<>();\n+        Map<ScopeAware<Expression>, Symbol> newMappings = new LinkedHashMap<>();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjczNA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662734", "bodyText": "This change and the following two changes were part of a vain attempt to ensure a specific order of Assignments.  I gave that up a couple of iterations ago, but failed to remove these changes.  The present version does it the right way - - by looking up outputs by Symbol.\nReverted.", "author": "djsstarburst", "createdAt": "2020-11-25T21:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0ODczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY5MDMyNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r538690325", "bodyText": "Did you forget to revert this?", "author": "martint", "createdAt": "2020-12-08T18:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0ODczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0OTM0Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529949343", "bodyText": "Unrelated change", "author": "martint", "createdAt": "2020-11-24T22:35:25Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/InlineProjections.java", "diffHunk": "@@ -83,7 +85,7 @@ public Result apply(ProjectNode parent, Captures captures, Context context)\n         Assignments assignments = child.getAssignments().filter(targets::contains);\n         Map<Symbol, Expression> parentAssignments = parent.getAssignments()\n                 .entrySet().stream()\n-                .collect(Collectors.toMap(\n+                .collect(toImmutableMap(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjY4NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662685", "bodyText": "Reverted.", "author": "djsstarburst", "createdAt": "2020-11-25T21:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0OTM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0OTQzMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529949430", "bodyText": "Unrelated change", "author": "martint", "createdAt": "2020-11-24T22:35:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/InlineProjections.java", "diffHunk": "@@ -94,7 +96,7 @@ public Result apply(ProjectNode parent, Captures captures, Context context)\n                 .filter(entry -> targets.contains(entry.getKey()))\n                 .map(Map.Entry::getValue)\n                 .flatMap(entry -> SymbolsExtractor.extractAll(entry).stream())\n-                .collect(toSet());\n+                .collect(toImmutableSet());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjY1Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662652", "bodyText": "Reverted.", "author": "djsstarburst", "createdAt": "2020-11-25T21:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk0OTQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk1NjE1Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529956157", "bodyText": "Why did this change?", "author": "martint", "createdAt": "2020-11-24T22:41:40Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/BeginTableWrite.java", "diffHunk": "@@ -185,7 +203,16 @@ private WriterTarget createWriterTarget(WriterTarget target)\n             }\n             if (target instanceof DeleteTarget) {\n                 DeleteTarget delete = (DeleteTarget) target;\n-                return new DeleteTarget(metadata.beginDelete(session, delete.getHandle()), delete.getSchemaTableName());\n+                TableHandle deleteHandle = getTableHandleFromSource(root);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjYxMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662610", "bodyText": "It should not have changed.  Reverted.", "author": "djsstarburst", "createdAt": "2020-11-25T21:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk1NjE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2MjIyMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529962222", "bodyText": "UpdateTarget contains the reference to the table handle, so it shouldn't be necessary to walk the tree to find it. This code also has the disadvantage of having to be kept in sync with rewriteModifyTableScan below.", "author": "martint", "createdAt": "2020-11-24T22:47:25Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/BeginTableWrite.java", "diffHunk": "@@ -198,7 +225,39 @@ private WriterTarget createWriterTarget(WriterTarget target)\n             throw new IllegalArgumentException(\"Unhandled target type: \" + target.getClass().getSimpleName());\n         }\n \n-        private PlanNode rewriteDeleteTableScan(PlanNode node, TableHandle handle)\n+        private TableHandle getTableHandleFromSource(PlanNode node)\n+        {\n+            if (node instanceof TableScanNode) {\n+                return ((TableScanNode) node).getTable();\n+            }\n+            if (node instanceof DeleteNode) {\n+                return getTableHandleFromSource(((DeleteNode) node).getSource());\n+            }\n+            if (node instanceof UpdateNode) {\n+                return getTableHandleFromSource(((UpdateNode) node).getSource());\n+            }\n+            if (node instanceof ExchangeNode) {\n+                return getTableHandleFromSource(getOnlyElement(node.getSources()));\n+            }\n+            if (node instanceof FilterNode) {\n+                return getTableHandleFromSource(((FilterNode) node).getSource());\n+            }\n+            if (node instanceof ProjectNode) {\n+                return getTableHandleFromSource(((ProjectNode) node).getSource());\n+            }\n+            if (node instanceof SemiJoinNode) {\n+                return getTableHandleFromSource(((SemiJoinNode) node).getSource());\n+            }\n+            if (node instanceof JoinNode) {\n+                JoinNode joinNode = (JoinNode) node;\n+                if (joinNode.getType() == JoinNode.Type.INNER && isAtMostScalar(joinNode.getRight())) {\n+                    return getTableHandleFromSource(joinNode.getLeft());\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Invalid descendant for DeleteNode or UpdateNode: \" + node.getClass().getName());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjUxOQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662519", "bodyText": "Yes, I mentioned yesterday morning to David that the TableHandle was a field of UpdateNode, we don't need this junk.\nI'm really happy to get rid of it!", "author": "djsstarburst", "createdAt": "2020-11-25T21:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2MjIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2MzcyNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529963727", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ActualProperties properties = Iterables.getOnlyElement(inputProperties).translate(symbol -> Optional.empty());\n          \n          \n            \n                        return ActualProperties.builderFrom(properties)\n          \n          \n            \n                                .build();\n          \n          \n            \n                        return Iterables.getOnlyElement(inputProperties).translate(symbol -> Optional.empty());", "author": "martint", "createdAt": "2020-11-24T22:48:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PropertyDerivations.java", "diffHunk": "@@ -418,6 +419,14 @@ public ActualProperties visitDelete(DeleteNode node, List<ActualProperties> inpu\n             return Iterables.getOnlyElement(inputProperties).translate(symbol -> Optional.empty());\n         }\n \n+        @Override\n+        public ActualProperties visitUpdate(UpdateNode node, List<ActualProperties> inputProperties)\n+        {\n+            ActualProperties properties = Iterables.getOnlyElement(inputProperties).translate(symbol -> Optional.empty());\n+            return ActualProperties.builderFrom(properties)\n+                    .build();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjQ0OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662449", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-25T21:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2MzcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2ODM3MQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529968371", "bodyText": "This needs to include all the symbols required by the UpdateNode (i.e., expressionSymbols). Also, technically, node.getOutputSymbols() should be pruned based on the symbols indicated in the context argument.", "author": "martint", "createdAt": "2020-11-24T22:53:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PruneUnreferencedOutputs.java", "diffHunk": "@@ -715,6 +716,13 @@ public PlanNode visitDelete(DeleteNode node, RewriteContext<Set<Symbol>> context\n             return new DeleteNode(node.getId(), source, node.getTarget(), node.getRowId(), node.getOutputSymbols());\n         }\n \n+        @Override\n+        public PlanNode visitUpdate(UpdateNode node, RewriteContext<Set<Symbol>> context)\n+        {\n+            PlanNode source = context.rewrite(node.getSource(), ImmutableSet.of(node.getRowId()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjQxMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662412", "bodyText": "I changed the rewrite using the expressionSymbols.  I'm uncertain how to follow the guidance on node.getOutputSymbols().  When I stop in the debugger, I always see zero symbols in the context argument.", "author": "djsstarburst", "createdAt": "2020-11-25T21:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2ODM3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2NTA5Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530665093", "bodyText": "Hmm.. that could be a bug elsewhere. That would mean that whichever operation is downstream from the Update node doesn't care about any of its outputs.", "author": "martint", "createdAt": "2020-11-25T22:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2ODM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MDgxMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529970811", "bodyText": "We should include the columns being updated and the input corresponding to each of them.", "author": "martint", "createdAt": "2020-11-24T22:55:44Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -1110,6 +1111,14 @@ public Void visitDelete(DeleteNode node, Void context)\n             return processChildren(node, context);\n         }\n \n+        @Override\n+        public Void visitUpdate(UpdateNode node, Void context)\n+        {\n+            addNode(node, \"Update\", format(\"[%s]\", node.getTarget()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjMxNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662315", "bodyText": "As of now, the node itself doesn't know what columns are being updated.  It does carry the symbols for the update expressions, and I've added those to the formatted output.", "author": "djsstarburst", "createdAt": "2020-11-25T21:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MDgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2NTIzNA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530665234", "bodyText": "They are recorded in UpdateTarget, no?", "author": "martint", "createdAt": "2020-11-25T22:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MDgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc2OTI3MQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530769271", "bodyText": "They weren't - - in only had a list of opaque ColumnHandles.  I changed that list into an ImmutableMap<String, ColumnHandle>, so order would be preserved, and changed the PlanPrinter to show the column names as well as the updateColumnValue symbols.", "author": "djsstarburst", "createdAt": "2020-11-26T04:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MDgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc3MjY3NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530772674", "bodyText": "Oh, I didn\u2019t mean to add the names, but to render the column handles, just like we do when printing the tablescan", "author": "martint", "createdAt": "2020-11-26T04:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MDgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA3NzAzMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r531077033", "bodyText": "I'm not sure what you are intending.  Given this UPDATE statement:\nUPDATE ... SET col5 = col4, col1 = col3, col3 = col2, col4 = col5, col2 = col1 WHERE col1 = 21\nThis is what PlanPrinter generates with the latest changes:\nUpdate[hive:default:test_update_all_columns_set_true_none_61egligttsrv: col1 = col3_0, col2 = col1_1, col3 = col2_2, col4 = col5_3, col5 = col4_4]\n...\nIf you'd like it to be different, let me know.  I'm happy to make a change but I don't know what change you would like.", "author": "djsstarburst", "createdAt": "2020-11-26T14:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MDgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc1Njc2Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r532756767", "bodyText": "I was thinking something like the inverse of that TableScan shows:\n     TableScan[tpch:orders:sf0.01, grouped = false]\n         Layout: [orderkey:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment:varchar(79)]\n         Estimates: {rows: 15000 (1.52MB), cpu: 1.52M, memory: 0B, network: 0B}\n         clerk := tpch:clerk\n         orderkey := tpch:orderkey\n         orderstatus := tpch:orderstatus\n         custkey := tpch:custkey\n         totalprice := tpch:totalprice\n         comment := tpch:comment\n         orderdate := tpch:orderdate\n         orderpriority := tpch:orderpriority\n         shippriority := tpch:shippriority\n\ne.g.,\nUpdate[tpch:orders]\n    tpch.orderstatus := col0\n    tpch.comment := col1\n    ...", "author": "martint", "createdAt": "2020-11-30T17:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MDgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA5ODI4OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537098288", "bodyText": "Thanks for spelling it out, @martint!  I've done it.  Here is the result of EXPLAIN UPDATE foo SET col2 = 'DEUX', col3 = col3 + 20 + col1 + col5 WHERE col1 = 13:\nFragment 1 [SOURCE]\n    Output layout: [partialrows, fragment]\n    Output partitioning: SINGLE []\n    Stage Execution Strategy: UNGROUPED_EXECUTION\n    Update[hive:default:foo]\n    \u2502   Layout: [partialrows:bigint, fragment:varbinary]\n    \u2502   col2 := expr_1\n    \u2502   col3 := expr_0\n   \u2514\u2500 ScanFilterProject[table = hive:default:foo, grouped = false, filterPredicate = (\"col1\" = TINYINT '13')]\n           Layout: [field:row(originalTransaction bigint, rowId bigint, bucket integer, row row(col1 tinyint, col4 boolean, col5 integer)), expr_0:bigint, expr_1:varchar]\n           Estimates: {rows: 2 (238B), cpu: 142, memory: 0B, network: 0B}/{rows: ? (?), cpu: 284, memory: 0B, network: 0B}/{rows: ? (?), cpu: ?, memory: 0B, network: 0B}\n           expr_0 := (((\"col3\" + BIGINT '20') + CAST(\"col1\" AS bigint)) + CAST(\"col5\" AS bigint))\n           expr_1 := CAST('DEUX' AS varchar)\n           field := $row_id:struct<originalTransaction:bigint,rowId:bigint,bucket:int,row:struct<col1:tinyint,col4:boolean,col5:int>>:SYNTHESIZED\n           col5 := col5:int:REGULAR\n           col3 := col3:bigint:REGULAR\n           col1 := col1:tinyint:REGULAR", "author": "djsstarburst", "createdAt": "2020-12-06T18:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MDgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3NDQ1MQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r529974451", "bodyText": "Add validation for expressionSymbols. This should be as simple as:\ncheckArgument(source.getOutputSymbols().containsAll(node.getExpressionSymbols()));", "author": "martint", "createdAt": "2020-11-24T22:59:20Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/ValidateDependenciesChecker.java", "diffHunk": "@@ -573,6 +574,17 @@ public Void visitDelete(DeleteNode node, Set<Symbol> boundSymbols)\n             return null;\n         }\n \n+        @Override\n+        public Void visitUpdate(UpdateNode node, Set<Symbol> boundSymbols)\n+        {\n+            PlanNode source = node.getSource();\n+            source.accept(this, boundSymbols); // visit child\n+\n+            checkArgument(source.getOutputSymbols().contains(node.getRowId()), \"Invalid node. Row ID symbol (%s) is not in source plan output (%s)\", node.getRowId(), node.getSource().getOutputSymbols());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjEyOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r530662128", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-11-25T21:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3NDQ1MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NDIzMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536394232", "bodyText": "These intersection calls can be inlined", "author": "electrum", "createdAt": "2020-12-04T21:38:03Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveMetadata.java", "diffHunk": "@@ -1557,6 +1558,95 @@ private static void writeEmptyFile(ConnectorSession session, Path target, JobCon\n         }\n     }\n \n+    @Override\n+    public ConnectorTableHandle beginUpdate(ConnectorSession session, ConnectorTableHandle tableHandle, List<ColumnHandle> updatedColumns)\n+    {\n+        HiveIdentity identity = new HiveIdentity(session);\n+        HiveTableHandle hiveTableHandle = (HiveTableHandle) tableHandle;\n+        SchemaTableName tableName = hiveTableHandle.getSchemaTableName();\n+        Table table = metastore.getTable(identity, tableName.getSchemaName(), tableName.getTableName())\n+                .orElseThrow(() -> new TableNotFoundException(tableName));\n+\n+        if (!isTransactionalTable(table.getParameters())) {\n+            throw new PrestoException(NOT_SUPPORTED, \"Hive update is only supported for transactional tables\");\n+        }\n+\n+        // Verify that none of the updated columns are partition columns or bucket columns\n+\n+        Set<String> updatedColumnNames = updatedColumns.stream().map(handle -> ((HiveColumnHandle) handle).getName()).collect(toImmutableSet());\n+        Set<String> partitionColumnNames = table.getPartitionColumns().stream().map(Column::getName).collect(toImmutableSet());\n+        Set<String> intersection = intersection(updatedColumnNames, partitionColumnNames);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTU4Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129582", "bodyText": "Inlined.", "author": "djsstarburst", "createdAt": "2020-12-06T21:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NDIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NDMyNg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536394326", "bodyText": "This could use Optional.ifPresent()", "author": "electrum", "createdAt": "2020-12-04T21:38:17Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveMetadata.java", "diffHunk": "@@ -1557,6 +1558,95 @@ private static void writeEmptyFile(ConnectorSession session, Path target, JobCon\n         }\n     }\n \n+    @Override\n+    public ConnectorTableHandle beginUpdate(ConnectorSession session, ConnectorTableHandle tableHandle, List<ColumnHandle> updatedColumns)\n+    {\n+        HiveIdentity identity = new HiveIdentity(session);\n+        HiveTableHandle hiveTableHandle = (HiveTableHandle) tableHandle;\n+        SchemaTableName tableName = hiveTableHandle.getSchemaTableName();\n+        Table table = metastore.getTable(identity, tableName.getSchemaName(), tableName.getTableName())\n+                .orElseThrow(() -> new TableNotFoundException(tableName));\n+\n+        if (!isTransactionalTable(table.getParameters())) {\n+            throw new PrestoException(NOT_SUPPORTED, \"Hive update is only supported for transactional tables\");\n+        }\n+\n+        // Verify that none of the updated columns are partition columns or bucket columns\n+\n+        Set<String> updatedColumnNames = updatedColumns.stream().map(handle -> ((HiveColumnHandle) handle).getName()).collect(toImmutableSet());\n+        Set<String> partitionColumnNames = table.getPartitionColumns().stream().map(Column::getName).collect(toImmutableSet());\n+        Set<String> intersection = intersection(updatedColumnNames, partitionColumnNames);\n+        if (!intersection.isEmpty()) {\n+            throw new PrestoException(NOT_SUPPORTED, \"Updating Hive table partition columns is not supported\");\n+        }\n+\n+        if (hiveTableHandle.getBucketHandle().isPresent()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTYyNg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129626", "bodyText": "Yes, that's nicer.  Changed.", "author": "djsstarburst", "createdAt": "2020-12-06T21:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NDMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NDYzNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536394637", "bodyText": "Remove table name since we don't have it for other error messages (and it's not needed, since there is only one table updated for a query)", "author": "electrum", "createdAt": "2020-12-04T21:39:00Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveMetadata.java", "diffHunk": "@@ -1557,6 +1558,95 @@ private static void writeEmptyFile(ConnectorSession session, Path target, JobCon\n         }\n     }\n \n+    @Override\n+    public ConnectorTableHandle beginUpdate(ConnectorSession session, ConnectorTableHandle tableHandle, List<ColumnHandle> updatedColumns)\n+    {\n+        HiveIdentity identity = new HiveIdentity(session);\n+        HiveTableHandle hiveTableHandle = (HiveTableHandle) tableHandle;\n+        SchemaTableName tableName = hiveTableHandle.getSchemaTableName();\n+        Table table = metastore.getTable(identity, tableName.getSchemaName(), tableName.getTableName())\n+                .orElseThrow(() -> new TableNotFoundException(tableName));\n+\n+        if (!isTransactionalTable(table.getParameters())) {\n+            throw new PrestoException(NOT_SUPPORTED, \"Hive update is only supported for transactional tables\");\n+        }\n+\n+        // Verify that none of the updated columns are partition columns or bucket columns\n+\n+        Set<String> updatedColumnNames = updatedColumns.stream().map(handle -> ((HiveColumnHandle) handle).getName()).collect(toImmutableSet());\n+        Set<String> partitionColumnNames = table.getPartitionColumns().stream().map(Column::getName).collect(toImmutableSet());\n+        Set<String> intersection = intersection(updatedColumnNames, partitionColumnNames);\n+        if (!intersection.isEmpty()) {\n+            throw new PrestoException(NOT_SUPPORTED, \"Updating Hive table partition columns is not supported\");\n+        }\n+\n+        if (hiveTableHandle.getBucketHandle().isPresent()) {\n+            Set<String> bucketColumnNames = hiveTableHandle.getBucketHandle().get().getColumns().stream().map(HiveColumnHandle::getName).collect(toImmutableSet());\n+            intersection = intersection(updatedColumnNames, bucketColumnNames);\n+            if (!intersection.isEmpty()) {\n+                throw new PrestoException(NOT_SUPPORTED, \"Updating Hive table bucket columns is not supported\");\n+            }\n+        }\n+\n+        checkTableIsWritable(table, writesToNonManagedTablesEnabled);\n+\n+        for (Column column : table.getDataColumns()) {\n+            if (!isWritableType(column.getType())) {\n+                throw new PrestoException(NOT_SUPPORTED, format(\"Updating a Hive table %s with column type %s not supported\", tableName, column.getType()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTYzNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129635", "bodyText": "Removed.", "author": "djsstarburst", "createdAt": "2020-12-06T21:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NDYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NjQ5Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536396496", "bodyText": "Let's remove this static import since it's not clear what \"codec\" refers to", "author": "electrum", "createdAt": "2020-12-04T21:42:52Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveMetadata.java", "diffHunk": "@@ -1557,6 +1558,95 @@ private static void writeEmptyFile(ConnectorSession session, Path target, JobCon\n         }\n     }\n \n+    @Override\n+    public ConnectorTableHandle beginUpdate(ConnectorSession session, ConnectorTableHandle tableHandle, List<ColumnHandle> updatedColumns)\n+    {\n+        HiveIdentity identity = new HiveIdentity(session);\n+        HiveTableHandle hiveTableHandle = (HiveTableHandle) tableHandle;\n+        SchemaTableName tableName = hiveTableHandle.getSchemaTableName();\n+        Table table = metastore.getTable(identity, tableName.getSchemaName(), tableName.getTableName())\n+                .orElseThrow(() -> new TableNotFoundException(tableName));\n+\n+        if (!isTransactionalTable(table.getParameters())) {\n+            throw new PrestoException(NOT_SUPPORTED, \"Hive update is only supported for transactional tables\");\n+        }\n+\n+        // Verify that none of the updated columns are partition columns or bucket columns\n+\n+        Set<String> updatedColumnNames = updatedColumns.stream().map(handle -> ((HiveColumnHandle) handle).getName()).collect(toImmutableSet());\n+        Set<String> partitionColumnNames = table.getPartitionColumns().stream().map(Column::getName).collect(toImmutableSet());\n+        Set<String> intersection = intersection(updatedColumnNames, partitionColumnNames);\n+        if (!intersection.isEmpty()) {\n+            throw new PrestoException(NOT_SUPPORTED, \"Updating Hive table partition columns is not supported\");\n+        }\n+\n+        if (hiveTableHandle.getBucketHandle().isPresent()) {\n+            Set<String> bucketColumnNames = hiveTableHandle.getBucketHandle().get().getColumns().stream().map(HiveColumnHandle::getName).collect(toImmutableSet());\n+            intersection = intersection(updatedColumnNames, bucketColumnNames);\n+            if (!intersection.isEmpty()) {\n+                throw new PrestoException(NOT_SUPPORTED, \"Updating Hive table bucket columns is not supported\");\n+            }\n+        }\n+\n+        checkTableIsWritable(table, writesToNonManagedTablesEnabled);\n+\n+        for (Column column : table.getDataColumns()) {\n+            if (!isWritableType(column.getType())) {\n+                throw new PrestoException(NOT_SUPPORTED, format(\"Updating a Hive table %s with column type %s not supported\", tableName, column.getType()));\n+            }\n+        }\n+\n+        List<HiveColumnHandle> allDataColumns = getRegularColumnHandles(table, typeManager, getTimestampPrecision(session)).stream()\n+                .filter(columnHandle -> !columnHandle.isHidden())\n+                .collect(toList());\n+        List<HiveColumnHandle> hiveUpdatedColumns = updatedColumns.stream().map(HiveColumnHandle.class::cast).collect(toImmutableList());\n+\n+        if (table.getParameters().containsKey(SKIP_HEADER_COUNT_KEY)) {\n+            throw new PrestoException(NOT_SUPPORTED, format(\"Updating a Hive table with %s property not supported\", SKIP_HEADER_COUNT_KEY));\n+        }\n+        if (table.getParameters().containsKey(SKIP_FOOTER_COUNT_KEY)) {\n+            throw new PrestoException(NOT_SUPPORTED, format(\"Updating a Hive table with %s property not supported\", SKIP_FOOTER_COUNT_KEY));\n+        }\n+        LocationHandle locationHandle = locationService.forExistingTable(metastore, session, table);\n+\n+        AcidTransaction transaction = metastore.beginUpdate(session, table);\n+        HiveTableHandle updateHandle = hiveTableHandle.withUpdateProcessor(\n+                transaction,\n+                new HiveUpdateProcessor(allDataColumns, hiveUpdatedColumns));\n+\n+        WriteInfo writeInfo = locationService.getQueryWriteInfo(locationHandle);\n+        metastore.declareIntentionToWrite(session, writeInfo.getWriteMode(), writeInfo.getWritePath(), tableName);\n+        return updateHandle;\n+    }\n+\n+    @Override\n+    public void finishUpdate(ConnectorSession session, ConnectorTableHandle tableHandle, Collection<Slice> fragments)\n+    {\n+        HiveTableHandle handle = (HiveTableHandle) tableHandle;\n+        checkArgument(handle.isAcidUpdate(), \"handle should be a update handle, but is %s\", handle);\n+\n+        requireNonNull(fragments, \"fragments is null\");\n+\n+        SchemaTableName tableName = handle.getSchemaTableName();\n+        HiveIdentity identity = new HiveIdentity(session);\n+        Table table = metastore.getTable(identity, tableName.getSchemaName(), tableName.getTableName())\n+                .orElseThrow(() -> new TableNotFoundException(tableName));\n+\n+        List<PartitionAndStatementId> partitionAndStatementIds = fragments.stream()\n+                .map(Slice::getBytes)\n+                .map(CODEC::fromJson)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTY1NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129655", "bodyText": "Removed.", "author": "djsstarburst", "createdAt": "2020-12-06T21:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NjQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5Njk4MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536396980", "bodyText": "Static import getDeleteRowIdColumnHandle since the name stands by itself", "author": "electrum", "createdAt": "2020-12-04T21:43:58Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveMetadata.java", "diffHunk": "@@ -2021,7 +2111,14 @@ private void ensureTableSupportsDelete(Table table)\n     @Override\n     public ColumnHandle getDeleteRowIdColumnHandle(ConnectorSession session, ConnectorTableHandle tableHandle)\n     {\n-        return updateRowIdColumnHandle();\n+        return HiveColumnHandle.getDeleteRowIdColumnHandle();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTY2Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129666", "bodyText": "Actually, the explicit HiveColumnHandle. seems to be required - - if I add the import and remove the HiveColumnHandle., I see an error.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5Njk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NzYxMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536397611", "bodyText": "hiveColumns = hiveTable.getUpdateProcessor()\n        .orElseThrow(() -> new IllegalArgumentException(\"update processor not present\"))\n        .mergeWithNonUpdatedColumns(hiveColumns);", "author": "electrum", "createdAt": "2020-12-04T21:45:18Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HivePageSourceProvider.java", "diffHunk": "@@ -138,6 +138,16 @@ public ConnectorPageSource createPageSource(\n         List<HiveColumnHandle> hiveColumns = columns.stream()\n                 .map(HiveColumnHandle.class::cast)\n                 .collect(toList());\n+\n+        List<HiveColumnHandle> dependencyColumns = hiveColumns.stream()\n+                .filter(HiveColumnHandle::isBaseColumn)\n+                .collect(toImmutableList());\n+\n+        if (hiveTable.isAcidUpdate()) {\n+            checkArgument(hiveTable.getUpdateProcessor().isPresent(), \"hiveTable.getUpdateProcessor() isn't present\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTY5OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129699", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM5NzYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwODQ5MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536408490", "bodyText": "Why move this line?", "author": "electrum", "createdAt": "2020-12-04T21:59:47Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -112,22 +127,27 @@ public HiveUpdatablePageSource(\n         this.configuration = requireNonNull(configuration, \"configuration is null\");\n         this.session = requireNonNull(session, \"session is null\");\n         this.hiveRowTypeNullsBlock = nativeValueToBlock(hiveRowType.getType(typeManager), null);\n-        checkArgument(hiveTableHandle.isInAcidTransaction(), \"Not in a transaction; hiveTableHandle: %s\", hiveTableHandle);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTcwNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129707", "bodyText": "No big reason; restored.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwODQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwOTg3NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536409874", "bodyText": "Make this final and Optional", "author": "electrum", "createdAt": "2020-12-04T22:03:01Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -78,15 +86,20 @@\n     private final OrcFileWriterFactory orcFileWriterFactory;\n     private final Configuration configuration;\n     private final ConnectorSession session;\n+    private final List<HiveColumnHandle> dependencyColumns;\n     private final Block hiveRowTypeNullsBlock;\n     private final long writeId;\n+    private final AcidOperation updateKind;\n     private final Properties hiveAcidSchema;\n     private final Path deleteDeltaDirectory;\n     private final String bucketFilename;\n+    private Path deltaDirectory;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTczMA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129730", "bodyText": "Done.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwOTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMDEyOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536410128", "bodyText": "Why remove?", "author": "electrum", "createdAt": "2020-12-04T22:03:34Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -136,7 +156,6 @@ public void deleteRows(Block rowIds)\n     {\n         int positionCount = rowIds.getPositionCount();\n         List<Block> blocks = rowIds.getChildren();\n-        checkArgument(blocks.size() == 3, \"The rowId block should have 3 children, but has \" + blocks.size());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTc0Mw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129743", "bodyText": "deleteRows() gets called for UPDATE as well as DELETE, and in the UPDATE case, the RowBlock has 4 children, where the 4th child has the updated column values that don't matter for creation of the ORC DELETE records that result from UPDATE.\nI created method deleteRowsInternal(Block rowIds); restored the check in deleteRows() before calling the internal method; and added a check for size == 4 in the updateRows() code before calling the internal method.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMDEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMTMwOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536411308", "bodyText": "We can simplify to\ndeleteFileWriter.orElseThrow().appendRows(deletePage);\nSince we know it is created by the above method call", "author": "electrum", "createdAt": "2020-12-04T22:06:20Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -152,18 +171,59 @@ public void deleteRows(Block rowIds)\n             maxWriteId = Math.max(maxWriteId, block.getLong(index, 0));\n         }\n \n-        lazyInitializeFileWriter();\n-        checkArgument(writer.isPresent(), \"writer not present\");\n-        writer.get().appendRows(deletePage);\n+        lazyInitializeDeleteFileWriter();\n+        checkArgument(deleteFileWriter.isPresent(), \"deleteFileWriter not present\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTc3Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129776", "bodyText": "Simplified.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMTk3NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536411975", "bodyText": "I think the new Block[] is redundant. It can be just\nBlock[] foo = { ... };", "author": "electrum", "createdAt": "2020-12-04T22:07:45Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -152,18 +171,59 @@ public void deleteRows(Block rowIds)\n             maxWriteId = Math.max(maxWriteId, block.getLong(index, 0));\n         }\n \n-        lazyInitializeFileWriter();\n-        checkArgument(writer.isPresent(), \"writer not present\");\n-        writer.get().appendRows(deletePage);\n+        lazyInitializeDeleteFileWriter();\n+        checkArgument(deleteFileWriter.isPresent(), \"deleteFileWriter not present\");\n+        deleteFileWriter.get().appendRows(deletePage);\n         rowCount += positionCount;\n     }\n \n-    private void lazyInitializeFileWriter()\n+    @Override\n+    public void updateRows(Page page, List<Integer> updateExpressionChannelNumbers)\n+    {\n+        int positionCount = page.getPositionCount();\n+        if (positionCount == 0) {\n+            return;\n+        }\n+\n+        HiveUpdateProcessor updateProcessor = hiveTable.getUpdateProcessor().orElseThrow(() -> new IllegalArgumentException(\"updateProcessor isn't present\"));\n+        RowBlock acidRowBlock = updateProcessor.getAcidRowBlock(page, updateExpressionChannelNumbers);\n+        deleteRows(acidRowBlock);\n+\n+        Block mergedColumnsBlock = updateProcessor.createMergedColumnsBlock(page, updateExpressionChannelNumbers);\n+\n+        List<Block> blocks = acidRowBlock.getChildren();\n+\n+        Block currentTransactionBlock = RunLengthEncodedBlock.create(BIGINT, writeId, positionCount);\n+        Block[] blockArray = new Block[] {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTc4Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129782", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMTk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMjIzNA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536412234", "bodyText": "Nit: isn't -> not", "author": "electrum", "createdAt": "2020-12-04T22:08:25Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -152,18 +171,59 @@ public void deleteRows(Block rowIds)\n             maxWriteId = Math.max(maxWriteId, block.getLong(index, 0));\n         }\n \n-        lazyInitializeFileWriter();\n-        checkArgument(writer.isPresent(), \"writer not present\");\n-        writer.get().appendRows(deletePage);\n+        lazyInitializeDeleteFileWriter();\n+        checkArgument(deleteFileWriter.isPresent(), \"deleteFileWriter not present\");\n+        deleteFileWriter.get().appendRows(deletePage);\n         rowCount += positionCount;\n     }\n \n-    private void lazyInitializeFileWriter()\n+    @Override\n+    public void updateRows(Page page, List<Integer> updateExpressionChannelNumbers)\n+    {\n+        int positionCount = page.getPositionCount();\n+        if (positionCount == 0) {\n+            return;\n+        }\n+\n+        HiveUpdateProcessor updateProcessor = hiveTable.getUpdateProcessor().orElseThrow(() -> new IllegalArgumentException(\"updateProcessor isn't present\"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTgwNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129805", "bodyText": "I've been using \"isn't present\" in a lot of places.  I've changed the three in this file, and will look for others.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMjIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMjUxNg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536412516", "bodyText": "Add trailing comma for consistency", "author": "electrum", "createdAt": "2020-12-04T22:09:06Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -152,18 +171,59 @@ public void deleteRows(Block rowIds)\n             maxWriteId = Math.max(maxWriteId, block.getLong(index, 0));\n         }\n \n-        lazyInitializeFileWriter();\n-        checkArgument(writer.isPresent(), \"writer not present\");\n-        writer.get().appendRows(deletePage);\n+        lazyInitializeDeleteFileWriter();\n+        checkArgument(deleteFileWriter.isPresent(), \"deleteFileWriter not present\");\n+        deleteFileWriter.get().appendRows(deletePage);\n         rowCount += positionCount;\n     }\n \n-    private void lazyInitializeFileWriter()\n+    @Override\n+    public void updateRows(Page page, List<Integer> updateExpressionChannelNumbers)\n+    {\n+        int positionCount = page.getPositionCount();\n+        if (positionCount == 0) {\n+            return;\n+        }\n+\n+        HiveUpdateProcessor updateProcessor = hiveTable.getUpdateProcessor().orElseThrow(() -> new IllegalArgumentException(\"updateProcessor isn't present\"));\n+        RowBlock acidRowBlock = updateProcessor.getAcidRowBlock(page, updateExpressionChannelNumbers);\n+        deleteRows(acidRowBlock);\n+\n+        Block mergedColumnsBlock = updateProcessor.createMergedColumnsBlock(page, updateExpressionChannelNumbers);\n+\n+        List<Block> blocks = acidRowBlock.getChildren();\n+\n+        Block currentTransactionBlock = RunLengthEncodedBlock.create(BIGINT, writeId, positionCount);\n+        Block[] blockArray = new Block[] {\n+                new RunLengthEncodedBlock(INSERT_OPERATION_BLOCK, positionCount),\n+                currentTransactionBlock,\n+                blocks.get(BUCKET_CHANNEL),\n+                createRowIdBlock(positionCount),\n+                currentTransactionBlock,\n+                mergedColumnsBlock", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTgzMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129832", "bodyText": "Added here, and earlier in the file where a Block array is created.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMjUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMzA2Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536413066", "bodyText": "Same, we know this was created, so do\ninsertFileWriter.orElseThrow()..appendRows(insertPage);", "author": "electrum", "createdAt": "2020-12-04T22:10:14Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -152,18 +171,59 @@ public void deleteRows(Block rowIds)\n             maxWriteId = Math.max(maxWriteId, block.getLong(index, 0));\n         }\n \n-        lazyInitializeFileWriter();\n-        checkArgument(writer.isPresent(), \"writer not present\");\n-        writer.get().appendRows(deletePage);\n+        lazyInitializeDeleteFileWriter();\n+        checkArgument(deleteFileWriter.isPresent(), \"deleteFileWriter not present\");\n+        deleteFileWriter.get().appendRows(deletePage);\n         rowCount += positionCount;\n     }\n \n-    private void lazyInitializeFileWriter()\n+    @Override\n+    public void updateRows(Page page, List<Integer> updateExpressionChannelNumbers)\n+    {\n+        int positionCount = page.getPositionCount();\n+        if (positionCount == 0) {\n+            return;\n+        }\n+\n+        HiveUpdateProcessor updateProcessor = hiveTable.getUpdateProcessor().orElseThrow(() -> new IllegalArgumentException(\"updateProcessor isn't present\"));\n+        RowBlock acidRowBlock = updateProcessor.getAcidRowBlock(page, updateExpressionChannelNumbers);\n+        deleteRows(acidRowBlock);\n+\n+        Block mergedColumnsBlock = updateProcessor.createMergedColumnsBlock(page, updateExpressionChannelNumbers);\n+\n+        List<Block> blocks = acidRowBlock.getChildren();\n+\n+        Block currentTransactionBlock = RunLengthEncodedBlock.create(BIGINT, writeId, positionCount);\n+        Block[] blockArray = new Block[] {\n+                new RunLengthEncodedBlock(INSERT_OPERATION_BLOCK, positionCount),\n+                currentTransactionBlock,\n+                blocks.get(BUCKET_CHANNEL),\n+                createRowIdBlock(positionCount),\n+                currentTransactionBlock,\n+                mergedColumnsBlock\n+        };\n+\n+        Page insertPage = new Page(blockArray);\n+        lazyInitializeInsertFileWriter();\n+        checkArgument(insertFileWriter.isPresent(), \"insertFileWriter not present\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTg1Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129852", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMzA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMzc4NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536413784", "bodyText": "This is a bit long, I'd wrap the arguments to PartitionAndStatementId", "author": "electrum", "createdAt": "2020-12-04T22:11:46Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -172,21 +232,58 @@ private void lazyInitializeFileWriter()\n                     session,\n                     bucketNumber,\n                     hiveTable.getTransaction(),\n-                    true);\n+                    true,\n+                    WriterKind.DELETE);\n+        }\n+    }\n+\n+    private void lazyInitializeInsertFileWriter()\n+    {\n+        if (insertFileWriter.isEmpty()) {\n+            Properties schemaCopy = new Properties();\n+            schemaCopy.putAll(hiveAcidSchema);\n+            insertFileWriter = orcFileWriterFactory.createFileWriter(\n+                    new Path(format(\"%s/%s\", deltaDirectory, bucketFilename)),\n+                    ACID_COLUMN_NAMES,\n+                    fromHiveStorageFormat(ORC),\n+                    schemaCopy,\n+                    toJobConf(configuration),\n+                    session,\n+                    bucketNumber,\n+                    hiveTable.getTransaction(),\n+                    true,\n+                    WriterKind.INSERT);\n         }\n     }\n \n     @Override\n     public CompletableFuture<Collection<Slice>> finish()\n     {\n-        if (writer.isPresent()) {\n-            OrcFileWriter orcFileWriter = (OrcFileWriter) writer.get();\n-            orcFileWriter.setMaxWriteId(maxWriteId);\n-            orcFileWriter.commit();\n-            Slice fragment = Slices.wrappedBuffer(CODEC.toJsonBytes(new PartitionAndStatementId(partitionName, statementId, rowCount, deleteDeltaDirectory.toString())));\n-            return completedFuture(ImmutableList.of(fragment));\n-        }\n-        return completedFuture(ImmutableList.of());\n+        if (deleteFileWriter.isEmpty()) {\n+            return completedFuture(ImmutableList.of());\n+        }\n+        OrcFileWriter deleteWriter = (OrcFileWriter) deleteFileWriter.get();\n+        deleteWriter.setMaxWriteId(maxWriteId);\n+        deleteWriter.commit();\n+\n+        Optional<String> deltaDirectoryString;\n+        switch (updateKind) {\n+            case DELETE:\n+                deltaDirectoryString = Optional.empty();\n+                break;\n+\n+            case UPDATE:\n+                OrcFileWriter insertWriter = (OrcFileWriter) insertFileWriter.get();\n+                insertWriter.setMaxWriteId(maxWriteId);\n+                insertWriter.commit();\n+                deltaDirectoryString = Optional.of(deltaDirectory.toString());\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unknown UpdateKind \" + updateKind);\n+        }\n+        Slice fragment = Slices.wrappedBuffer(CODEC.toJsonBytes(new PartitionAndStatementId(partitionName, statementId, rowCount, deleteDeltaDirectory.toString(), deltaDirectoryString)));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTg3NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129874", "bodyText": "Wrapped.", "author": "djsstarburst", "createdAt": "2020-12-06T21:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxMzc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNDUzMQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536414531", "bodyText": "Extra the ++ to a separate statement", "author": "electrum", "createdAt": "2020-12-04T22:13:27Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdateProcessor.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.plugin.hive.orc.OrcDeletedRows;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.RowBlock;\n+import io.prestosql.spi.type.RowType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.ColumnType.SYNTHESIZED;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_INDEX;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_NAME;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.createBaseColumn;\n+import static io.prestosql.plugin.hive.HiveType.toHiveType;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.BUCKET_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ORIGINAL_TRANSACTION_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_ID_CHANNEL;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_COLUMN_ROW_STRUCT;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_READ_FIELDS;\n+import static io.prestosql.spi.block.RowBlock.fromFieldBlocks;\n+import static io.prestosql.spi.type.RowType.Field;\n+import static io.prestosql.spi.type.RowType.field;\n+import static io.prestosql.spi.type.RowType.from;\n+import static java.util.Objects.requireNonNull;\n+\n+public class HiveUpdateProcessor\n+{\n+    private final List<HiveColumnHandle> allDataColumns;\n+    private final List<HiveColumnHandle> updatedColumns;\n+    private final List<HiveColumnHandle> nonUpdatedColumns;\n+\n+    @JsonCreator\n+    public HiveUpdateProcessor(\n+            @JsonProperty(\"allColumns\") List<HiveColumnHandle> allDataColumns,\n+            @JsonProperty(\"updatedColumns\") List<HiveColumnHandle> updatedColumns)\n+    {\n+        this.allDataColumns = requireNonNull(allDataColumns, \"allColumns is null\");\n+        this.updatedColumns = requireNonNull(updatedColumns, \"updatedColumns is null\");\n+        checkArgument(allDataColumns.containsAll(updatedColumns), \"allColumns does not contain all updatedColumns\");\n+        this.nonUpdatedColumns = allDataColumns.stream()\n+                .filter(column -> !updatedColumns.contains(column))\n+                .collect(toImmutableList());\n+    }\n+\n+    private Map<HiveColumnHandle, Integer> makeNonUpdatedChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableMap.Builder<HiveColumnHandle, Integer> nonUpdatedNumbersBuilder = ImmutableMap.builder();\n+        int nonUpdatedIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle)) {\n+                nonUpdatedNumbersBuilder.put(handle, nonUpdatedIndex++);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTk1Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129956", "bodyText": "Separated here and in all other uses of ++ in the file.", "author": "djsstarburst", "createdAt": "2020-12-06T21:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNDUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNDkzMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536414932", "bodyText": "Move private methods to end of class", "author": "electrum", "createdAt": "2020-12-04T22:14:17Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdateProcessor.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.plugin.hive.orc.OrcDeletedRows;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.RowBlock;\n+import io.prestosql.spi.type.RowType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.ColumnType.SYNTHESIZED;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_INDEX;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_NAME;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.createBaseColumn;\n+import static io.prestosql.plugin.hive.HiveType.toHiveType;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.BUCKET_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ORIGINAL_TRANSACTION_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_ID_CHANNEL;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_COLUMN_ROW_STRUCT;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_READ_FIELDS;\n+import static io.prestosql.spi.block.RowBlock.fromFieldBlocks;\n+import static io.prestosql.spi.type.RowType.Field;\n+import static io.prestosql.spi.type.RowType.field;\n+import static io.prestosql.spi.type.RowType.from;\n+import static java.util.Objects.requireNonNull;\n+\n+public class HiveUpdateProcessor\n+{\n+    private final List<HiveColumnHandle> allDataColumns;\n+    private final List<HiveColumnHandle> updatedColumns;\n+    private final List<HiveColumnHandle> nonUpdatedColumns;\n+\n+    @JsonCreator\n+    public HiveUpdateProcessor(\n+            @JsonProperty(\"allColumns\") List<HiveColumnHandle> allDataColumns,\n+            @JsonProperty(\"updatedColumns\") List<HiveColumnHandle> updatedColumns)\n+    {\n+        this.allDataColumns = requireNonNull(allDataColumns, \"allColumns is null\");\n+        this.updatedColumns = requireNonNull(updatedColumns, \"updatedColumns is null\");\n+        checkArgument(allDataColumns.containsAll(updatedColumns), \"allColumns does not contain all updatedColumns\");\n+        this.nonUpdatedColumns = allDataColumns.stream()\n+                .filter(column -> !updatedColumns.contains(column))\n+                .collect(toImmutableList());\n+    }\n+\n+    private Map<HiveColumnHandle, Integer> makeNonUpdatedChannelNumbers(List<HiveColumnHandle> dependencyColumns)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTk3OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129978", "bodyText": "Moved.", "author": "djsstarburst", "createdAt": "2020-12-06T21:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNDkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNjM3Nw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536416377", "bodyText": "Static import MaskDeletedRowsFunction", "author": "electrum", "createdAt": "2020-12-04T22:17:29Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdateProcessor.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.plugin.hive.orc.OrcDeletedRows;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.RowBlock;\n+import io.prestosql.spi.type.RowType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.ColumnType.SYNTHESIZED;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_INDEX;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_NAME;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.createBaseColumn;\n+import static io.prestosql.plugin.hive.HiveType.toHiveType;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.BUCKET_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ORIGINAL_TRANSACTION_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_ID_CHANNEL;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_COLUMN_ROW_STRUCT;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_READ_FIELDS;\n+import static io.prestosql.spi.block.RowBlock.fromFieldBlocks;\n+import static io.prestosql.spi.type.RowType.Field;\n+import static io.prestosql.spi.type.RowType.field;\n+import static io.prestosql.spi.type.RowType.from;\n+import static java.util.Objects.requireNonNull;\n+\n+public class HiveUpdateProcessor\n+{\n+    private final List<HiveColumnHandle> allDataColumns;\n+    private final List<HiveColumnHandle> updatedColumns;\n+    private final List<HiveColumnHandle> nonUpdatedColumns;\n+\n+    @JsonCreator\n+    public HiveUpdateProcessor(\n+            @JsonProperty(\"allColumns\") List<HiveColumnHandle> allDataColumns,\n+            @JsonProperty(\"updatedColumns\") List<HiveColumnHandle> updatedColumns)\n+    {\n+        this.allDataColumns = requireNonNull(allDataColumns, \"allColumns is null\");\n+        this.updatedColumns = requireNonNull(updatedColumns, \"updatedColumns is null\");\n+        checkArgument(allDataColumns.containsAll(updatedColumns), \"allColumns does not contain all updatedColumns\");\n+        this.nonUpdatedColumns = allDataColumns.stream()\n+                .filter(column -> !updatedColumns.contains(column))\n+                .collect(toImmutableList());\n+    }\n+\n+    private Map<HiveColumnHandle, Integer> makeNonUpdatedChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableMap.Builder<HiveColumnHandle, Integer> nonUpdatedNumbersBuilder = ImmutableMap.builder();\n+        int nonUpdatedIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle)) {\n+                nonUpdatedNumbersBuilder.put(handle, nonUpdatedIndex++);\n+            }\n+            else if (dependencyColumns.contains(handle)) {\n+                nonUpdatedIndex++;\n+            }\n+        }\n+        return nonUpdatedNumbersBuilder.build();\n+    }\n+\n+    private List<Integer> makeDependencyChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableList.Builder<Integer> dependencyIndexBuilder = ImmutableList.builder();\n+        int dependencyIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (dependencyColumns.contains(handle)) {\n+                dependencyIndexBuilder.add(dependencyIndex++);\n+            }\n+            else if (nonUpdatedColumns.contains(handle)) {\n+                dependencyIndex++;\n+            }\n+        }\n+        return dependencyIndexBuilder.build();\n+    }\n+\n+    @JsonProperty\n+    public List<HiveColumnHandle> getAllDataColumns()\n+    {\n+        return allDataColumns;\n+    }\n+\n+    @JsonProperty\n+    public List<HiveColumnHandle> getUpdatedColumns()\n+    {\n+        return updatedColumns;\n+    }\n+\n+    @JsonIgnore\n+    public List<HiveColumnHandle> getNonUpdatedColumns()\n+    {\n+        return nonUpdatedColumns;\n+    }\n+\n+    /**\n+     * Merge the non-updated columns with the update dependencies, in allDataColumns order,\n+     * and finally add the rowId column as the last dependency.\n+     */\n+    public List<HiveColumnHandle> mergeWithNonUpdatedColumns(List<HiveColumnHandle> updateDependencies)\n+    {\n+        ImmutableList.Builder<HiveColumnHandle> builder = ImmutableList.builder();\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle) || updateDependencies.contains(handle)) {\n+                builder.add(handle);\n+            }\n+        }\n+        // The last updateDependency is the rowId column\n+        builder.add(updateDependencies.get(updateDependencies.size() - 1));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Create a RowBlock containing four children: the three ACID columns - - originalTransaction,\n+     * rowId, bucket - - and a RowBlock containing all the data columns not changed\n+     * by the UPDATE statement.\n+     */\n+    public Block createUpdateRowBlock(Page page, List<HiveColumnHandle> updateDependencies, OrcDeletedRows.MaskDeletedRowsFunction maskDeletedRowsFunction)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyOTk4Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537129982", "bodyText": "Imported.", "author": "djsstarburst", "createdAt": "2020-12-06T21:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxNjM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxODYyMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536418622", "bodyText": "Maybe simplify to\nBlock[] blocks = acidBlocks + new Block[nonUpdatedColumns.isEmpty() ? 0 : 1];", "author": "electrum", "createdAt": "2020-12-04T22:22:30Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdateProcessor.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.plugin.hive.orc.OrcDeletedRows;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.RowBlock;\n+import io.prestosql.spi.type.RowType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.ColumnType.SYNTHESIZED;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_INDEX;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_NAME;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.createBaseColumn;\n+import static io.prestosql.plugin.hive.HiveType.toHiveType;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.BUCKET_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ORIGINAL_TRANSACTION_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_ID_CHANNEL;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_COLUMN_ROW_STRUCT;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_READ_FIELDS;\n+import static io.prestosql.spi.block.RowBlock.fromFieldBlocks;\n+import static io.prestosql.spi.type.RowType.Field;\n+import static io.prestosql.spi.type.RowType.field;\n+import static io.prestosql.spi.type.RowType.from;\n+import static java.util.Objects.requireNonNull;\n+\n+public class HiveUpdateProcessor\n+{\n+    private final List<HiveColumnHandle> allDataColumns;\n+    private final List<HiveColumnHandle> updatedColumns;\n+    private final List<HiveColumnHandle> nonUpdatedColumns;\n+\n+    @JsonCreator\n+    public HiveUpdateProcessor(\n+            @JsonProperty(\"allColumns\") List<HiveColumnHandle> allDataColumns,\n+            @JsonProperty(\"updatedColumns\") List<HiveColumnHandle> updatedColumns)\n+    {\n+        this.allDataColumns = requireNonNull(allDataColumns, \"allColumns is null\");\n+        this.updatedColumns = requireNonNull(updatedColumns, \"updatedColumns is null\");\n+        checkArgument(allDataColumns.containsAll(updatedColumns), \"allColumns does not contain all updatedColumns\");\n+        this.nonUpdatedColumns = allDataColumns.stream()\n+                .filter(column -> !updatedColumns.contains(column))\n+                .collect(toImmutableList());\n+    }\n+\n+    private Map<HiveColumnHandle, Integer> makeNonUpdatedChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableMap.Builder<HiveColumnHandle, Integer> nonUpdatedNumbersBuilder = ImmutableMap.builder();\n+        int nonUpdatedIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle)) {\n+                nonUpdatedNumbersBuilder.put(handle, nonUpdatedIndex++);\n+            }\n+            else if (dependencyColumns.contains(handle)) {\n+                nonUpdatedIndex++;\n+            }\n+        }\n+        return nonUpdatedNumbersBuilder.build();\n+    }\n+\n+    private List<Integer> makeDependencyChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableList.Builder<Integer> dependencyIndexBuilder = ImmutableList.builder();\n+        int dependencyIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (dependencyColumns.contains(handle)) {\n+                dependencyIndexBuilder.add(dependencyIndex++);\n+            }\n+            else if (nonUpdatedColumns.contains(handle)) {\n+                dependencyIndex++;\n+            }\n+        }\n+        return dependencyIndexBuilder.build();\n+    }\n+\n+    @JsonProperty\n+    public List<HiveColumnHandle> getAllDataColumns()\n+    {\n+        return allDataColumns;\n+    }\n+\n+    @JsonProperty\n+    public List<HiveColumnHandle> getUpdatedColumns()\n+    {\n+        return updatedColumns;\n+    }\n+\n+    @JsonIgnore\n+    public List<HiveColumnHandle> getNonUpdatedColumns()\n+    {\n+        return nonUpdatedColumns;\n+    }\n+\n+    /**\n+     * Merge the non-updated columns with the update dependencies, in allDataColumns order,\n+     * and finally add the rowId column as the last dependency.\n+     */\n+    public List<HiveColumnHandle> mergeWithNonUpdatedColumns(List<HiveColumnHandle> updateDependencies)\n+    {\n+        ImmutableList.Builder<HiveColumnHandle> builder = ImmutableList.builder();\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle) || updateDependencies.contains(handle)) {\n+                builder.add(handle);\n+            }\n+        }\n+        // The last updateDependency is the rowId column\n+        builder.add(updateDependencies.get(updateDependencies.size() - 1));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Create a RowBlock containing four children: the three ACID columns - - originalTransaction,\n+     * rowId, bucket - - and a RowBlock containing all the data columns not changed\n+     * by the UPDATE statement.\n+     */\n+    public Block createUpdateRowBlock(Page page, List<HiveColumnHandle> updateDependencies, OrcDeletedRows.MaskDeletedRowsFunction maskDeletedRowsFunction)\n+    {\n+        requireNonNull(page, \"page is null\");\n+        requireNonNull(updateDependencies, \"updateDependencies is null\");\n+        Map<HiveColumnHandle, Integer> nonUpdatedChannelNumbers = makeNonUpdatedChannelNumbers(updateDependencies);\n+        int acidBlocks = 3;\n+        checkArgument(page.getChannelCount() >= acidBlocks + nonUpdatedColumns.size(), \"page doesn't have enough columns\");\n+\n+        Block[] blocks = new Block[nonUpdatedColumns.isEmpty() ? acidBlocks : acidBlocks + 1];", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMDAxOA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537130018", "bodyText": "I think you mean:\nBlock[] blocks = new Block[acidBlocks + (nonUpdatedColumns.isEmpty() ? 0 : 1)];\nand indeed that's nicer.", "author": "djsstarburst", "createdAt": "2020-12-06T21:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQxODYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MTE1OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536881158", "bodyText": "We could compute this channel list up front, rather than for every page", "author": "electrum", "createdAt": "2020-12-05T19:49:04Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdateProcessor.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.plugin.hive.orc.OrcDeletedRows;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.RowBlock;\n+import io.prestosql.spi.type.RowType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.ColumnType.SYNTHESIZED;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_INDEX;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_NAME;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.createBaseColumn;\n+import static io.prestosql.plugin.hive.HiveType.toHiveType;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.BUCKET_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ORIGINAL_TRANSACTION_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_ID_CHANNEL;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_COLUMN_ROW_STRUCT;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_READ_FIELDS;\n+import static io.prestosql.spi.block.RowBlock.fromFieldBlocks;\n+import static io.prestosql.spi.type.RowType.Field;\n+import static io.prestosql.spi.type.RowType.field;\n+import static io.prestosql.spi.type.RowType.from;\n+import static java.util.Objects.requireNonNull;\n+\n+public class HiveUpdateProcessor\n+{\n+    private final List<HiveColumnHandle> allDataColumns;\n+    private final List<HiveColumnHandle> updatedColumns;\n+    private final List<HiveColumnHandle> nonUpdatedColumns;\n+\n+    @JsonCreator\n+    public HiveUpdateProcessor(\n+            @JsonProperty(\"allColumns\") List<HiveColumnHandle> allDataColumns,\n+            @JsonProperty(\"updatedColumns\") List<HiveColumnHandle> updatedColumns)\n+    {\n+        this.allDataColumns = requireNonNull(allDataColumns, \"allColumns is null\");\n+        this.updatedColumns = requireNonNull(updatedColumns, \"updatedColumns is null\");\n+        checkArgument(allDataColumns.containsAll(updatedColumns), \"allColumns does not contain all updatedColumns\");\n+        this.nonUpdatedColumns = allDataColumns.stream()\n+                .filter(column -> !updatedColumns.contains(column))\n+                .collect(toImmutableList());\n+    }\n+\n+    private Map<HiveColumnHandle, Integer> makeNonUpdatedChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableMap.Builder<HiveColumnHandle, Integer> nonUpdatedNumbersBuilder = ImmutableMap.builder();\n+        int nonUpdatedIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle)) {\n+                nonUpdatedNumbersBuilder.put(handle, nonUpdatedIndex++);\n+            }\n+            else if (dependencyColumns.contains(handle)) {\n+                nonUpdatedIndex++;\n+            }\n+        }\n+        return nonUpdatedNumbersBuilder.build();\n+    }\n+\n+    private List<Integer> makeDependencyChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableList.Builder<Integer> dependencyIndexBuilder = ImmutableList.builder();\n+        int dependencyIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (dependencyColumns.contains(handle)) {\n+                dependencyIndexBuilder.add(dependencyIndex++);\n+            }\n+            else if (nonUpdatedColumns.contains(handle)) {\n+                dependencyIndex++;\n+            }\n+        }\n+        return dependencyIndexBuilder.build();\n+    }\n+\n+    @JsonProperty\n+    public List<HiveColumnHandle> getAllDataColumns()\n+    {\n+        return allDataColumns;\n+    }\n+\n+    @JsonProperty\n+    public List<HiveColumnHandle> getUpdatedColumns()\n+    {\n+        return updatedColumns;\n+    }\n+\n+    @JsonIgnore\n+    public List<HiveColumnHandle> getNonUpdatedColumns()\n+    {\n+        return nonUpdatedColumns;\n+    }\n+\n+    /**\n+     * Merge the non-updated columns with the update dependencies, in allDataColumns order,\n+     * and finally add the rowId column as the last dependency.\n+     */\n+    public List<HiveColumnHandle> mergeWithNonUpdatedColumns(List<HiveColumnHandle> updateDependencies)\n+    {\n+        ImmutableList.Builder<HiveColumnHandle> builder = ImmutableList.builder();\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle) || updateDependencies.contains(handle)) {\n+                builder.add(handle);\n+            }\n+        }\n+        // The last updateDependency is the rowId column\n+        builder.add(updateDependencies.get(updateDependencies.size() - 1));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Create a RowBlock containing four children: the three ACID columns - - originalTransaction,\n+     * rowId, bucket - - and a RowBlock containing all the data columns not changed\n+     * by the UPDATE statement.\n+     */\n+    public Block createUpdateRowBlock(Page page, List<HiveColumnHandle> updateDependencies, OrcDeletedRows.MaskDeletedRowsFunction maskDeletedRowsFunction)\n+    {\n+        requireNonNull(page, \"page is null\");\n+        requireNonNull(updateDependencies, \"updateDependencies is null\");\n+        Map<HiveColumnHandle, Integer> nonUpdatedChannelNumbers = makeNonUpdatedChannelNumbers(updateDependencies);\n+        int acidBlocks = 3;\n+        checkArgument(page.getChannelCount() >= acidBlocks + nonUpdatedColumns.size(), \"page doesn't have enough columns\");\n+\n+        Block[] blocks = new Block[nonUpdatedColumns.isEmpty() ? acidBlocks : acidBlocks + 1];\n+        blocks[ORIGINAL_TRANSACTION_CHANNEL] = page.getBlock(ORIGINAL_TRANSACTION_CHANNEL);\n+        blocks[ROW_ID_CHANNEL] = page.getBlock(ROW_ID_CHANNEL);\n+        blocks[BUCKET_CHANNEL] = page.getBlock(BUCKET_CHANNEL);\n+\n+        if (!nonUpdatedColumns.isEmpty()) {\n+            Block[] nonUpdatedColumnBlocks = new Block[getNonUpdatedColumns().size()];\n+            int offset = 0;\n+            for (HiveColumnHandle handle : getNonUpdatedColumns()) {\n+                Integer sourceChannel = nonUpdatedChannelNumbers.get(handle);\n+                requireNonNull(sourceChannel, \"sourceChannel is null\");\n+                nonUpdatedColumnBlocks[offset] = page.getBlock(acidBlocks + sourceChannel);\n+                offset++;\n+            }\n+            blocks[ROW_CHANNEL] = RowBlock.fromFieldBlocks(page.getPositionCount(), Optional.empty(), nonUpdatedColumnBlocks);\n+        }\n+        return maskDeletedRowsFunction.apply(fromFieldBlocks(\n+                page.getPositionCount(),\n+                Optional.empty(),\n+                blocks));\n+    }\n+\n+    /**\n+     * Project expects the page to begin with the update dependencies, followed by\n+     * the \"rowId\" column.  Remove columns from the page if they are not\n+     * update dependencies.\n+     */\n+    public Page removeNonDependencyColumns(Page page, List<HiveColumnHandle> dependencyColumns)\n+    {\n+        List<Integer> dependencyChannels = makeDependencyChannelNumbers(dependencyColumns);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMDAzNA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537130034", "bodyText": "Done.", "author": "djsstarburst", "createdAt": "2020-12-06T21:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MTE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MTM0Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536881346", "bodyText": "Same comments as above", "author": "electrum", "createdAt": "2020-12-05T19:50:11Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdateProcessor.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.plugin.hive.orc.OrcDeletedRows;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.RowBlock;\n+import io.prestosql.spi.type.RowType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.ColumnType.SYNTHESIZED;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_INDEX;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_NAME;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.createBaseColumn;\n+import static io.prestosql.plugin.hive.HiveType.toHiveType;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.BUCKET_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ORIGINAL_TRANSACTION_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_ID_CHANNEL;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_COLUMN_ROW_STRUCT;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_READ_FIELDS;\n+import static io.prestosql.spi.block.RowBlock.fromFieldBlocks;\n+import static io.prestosql.spi.type.RowType.Field;\n+import static io.prestosql.spi.type.RowType.field;\n+import static io.prestosql.spi.type.RowType.from;\n+import static java.util.Objects.requireNonNull;\n+\n+public class HiveUpdateProcessor\n+{\n+    private final List<HiveColumnHandle> allDataColumns;\n+    private final List<HiveColumnHandle> updatedColumns;\n+    private final List<HiveColumnHandle> nonUpdatedColumns;\n+\n+    @JsonCreator\n+    public HiveUpdateProcessor(\n+            @JsonProperty(\"allColumns\") List<HiveColumnHandle> allDataColumns,\n+            @JsonProperty(\"updatedColumns\") List<HiveColumnHandle> updatedColumns)\n+    {\n+        this.allDataColumns = requireNonNull(allDataColumns, \"allColumns is null\");\n+        this.updatedColumns = requireNonNull(updatedColumns, \"updatedColumns is null\");\n+        checkArgument(allDataColumns.containsAll(updatedColumns), \"allColumns does not contain all updatedColumns\");\n+        this.nonUpdatedColumns = allDataColumns.stream()\n+                .filter(column -> !updatedColumns.contains(column))\n+                .collect(toImmutableList());\n+    }\n+\n+    private Map<HiveColumnHandle, Integer> makeNonUpdatedChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableMap.Builder<HiveColumnHandle, Integer> nonUpdatedNumbersBuilder = ImmutableMap.builder();\n+        int nonUpdatedIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle)) {\n+                nonUpdatedNumbersBuilder.put(handle, nonUpdatedIndex++);\n+            }\n+            else if (dependencyColumns.contains(handle)) {\n+                nonUpdatedIndex++;\n+            }\n+        }\n+        return nonUpdatedNumbersBuilder.build();\n+    }\n+\n+    private List<Integer> makeDependencyChannelNumbers(List<HiveColumnHandle> dependencyColumns)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMDA0OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537130049", "bodyText": "Done.", "author": "djsstarburst", "createdAt": "2020-12-06T21:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MTM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MTU5NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536881595", "bodyText": "Using contains on a list is O(n), and I don't like relying on the equality semantics of HiveColumnHandle here. It's probably better to put the column names into a set.", "author": "electrum", "createdAt": "2020-12-05T19:51:45Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdateProcessor.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.plugin.hive.orc.OrcDeletedRows;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.RowBlock;\n+import io.prestosql.spi.type.RowType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.ColumnType.SYNTHESIZED;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_INDEX;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_NAME;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.createBaseColumn;\n+import static io.prestosql.plugin.hive.HiveType.toHiveType;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.BUCKET_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ORIGINAL_TRANSACTION_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_ID_CHANNEL;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_COLUMN_ROW_STRUCT;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_READ_FIELDS;\n+import static io.prestosql.spi.block.RowBlock.fromFieldBlocks;\n+import static io.prestosql.spi.type.RowType.Field;\n+import static io.prestosql.spi.type.RowType.field;\n+import static io.prestosql.spi.type.RowType.from;\n+import static java.util.Objects.requireNonNull;\n+\n+public class HiveUpdateProcessor\n+{\n+    private final List<HiveColumnHandle> allDataColumns;\n+    private final List<HiveColumnHandle> updatedColumns;\n+    private final List<HiveColumnHandle> nonUpdatedColumns;\n+\n+    @JsonCreator\n+    public HiveUpdateProcessor(\n+            @JsonProperty(\"allColumns\") List<HiveColumnHandle> allDataColumns,\n+            @JsonProperty(\"updatedColumns\") List<HiveColumnHandle> updatedColumns)\n+    {\n+        this.allDataColumns = requireNonNull(allDataColumns, \"allColumns is null\");\n+        this.updatedColumns = requireNonNull(updatedColumns, \"updatedColumns is null\");\n+        checkArgument(allDataColumns.containsAll(updatedColumns), \"allColumns does not contain all updatedColumns\");\n+        this.nonUpdatedColumns = allDataColumns.stream()\n+                .filter(column -> !updatedColumns.contains(column))\n+                .collect(toImmutableList());\n+    }\n+\n+    private Map<HiveColumnHandle, Integer> makeNonUpdatedChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableMap.Builder<HiveColumnHandle, Integer> nonUpdatedNumbersBuilder = ImmutableMap.builder();\n+        int nonUpdatedIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMDA1OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537130059", "bodyText": "I changed everything that does .contains() or .containsAll() to be a Set, and precomputed the required Sets and Map.", "author": "djsstarburst", "createdAt": "2020-12-06T21:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MTU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MTkzNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536881935", "bodyText": "Rather than doing map lookups by column handle for every page, we could compute the list of the source channels up front.", "author": "electrum", "createdAt": "2020-12-05T19:54:01Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdateProcessor.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.plugin.hive.orc.OrcDeletedRows;\n+import io.prestosql.spi.Page;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.RowBlock;\n+import io.prestosql.spi.type.RowType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.ColumnType.SYNTHESIZED;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_INDEX;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.UPDATE_ROW_ID_COLUMN_NAME;\n+import static io.prestosql.plugin.hive.HiveColumnHandle.createBaseColumn;\n+import static io.prestosql.plugin.hive.HiveType.toHiveType;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.BUCKET_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ORIGINAL_TRANSACTION_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_CHANNEL;\n+import static io.prestosql.plugin.hive.HiveUpdatablePageSource.ROW_ID_CHANNEL;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_COLUMN_ROW_STRUCT;\n+import static io.prestosql.plugin.hive.acid.AcidSchema.ACID_READ_FIELDS;\n+import static io.prestosql.spi.block.RowBlock.fromFieldBlocks;\n+import static io.prestosql.spi.type.RowType.Field;\n+import static io.prestosql.spi.type.RowType.field;\n+import static io.prestosql.spi.type.RowType.from;\n+import static java.util.Objects.requireNonNull;\n+\n+public class HiveUpdateProcessor\n+{\n+    private final List<HiveColumnHandle> allDataColumns;\n+    private final List<HiveColumnHandle> updatedColumns;\n+    private final List<HiveColumnHandle> nonUpdatedColumns;\n+\n+    @JsonCreator\n+    public HiveUpdateProcessor(\n+            @JsonProperty(\"allColumns\") List<HiveColumnHandle> allDataColumns,\n+            @JsonProperty(\"updatedColumns\") List<HiveColumnHandle> updatedColumns)\n+    {\n+        this.allDataColumns = requireNonNull(allDataColumns, \"allColumns is null\");\n+        this.updatedColumns = requireNonNull(updatedColumns, \"updatedColumns is null\");\n+        checkArgument(allDataColumns.containsAll(updatedColumns), \"allColumns does not contain all updatedColumns\");\n+        this.nonUpdatedColumns = allDataColumns.stream()\n+                .filter(column -> !updatedColumns.contains(column))\n+                .collect(toImmutableList());\n+    }\n+\n+    private Map<HiveColumnHandle, Integer> makeNonUpdatedChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableMap.Builder<HiveColumnHandle, Integer> nonUpdatedNumbersBuilder = ImmutableMap.builder();\n+        int nonUpdatedIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle)) {\n+                nonUpdatedNumbersBuilder.put(handle, nonUpdatedIndex++);\n+            }\n+            else if (dependencyColumns.contains(handle)) {\n+                nonUpdatedIndex++;\n+            }\n+        }\n+        return nonUpdatedNumbersBuilder.build();\n+    }\n+\n+    private List<Integer> makeDependencyChannelNumbers(List<HiveColumnHandle> dependencyColumns)\n+    {\n+        ImmutableList.Builder<Integer> dependencyIndexBuilder = ImmutableList.builder();\n+        int dependencyIndex = 0;\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (dependencyColumns.contains(handle)) {\n+                dependencyIndexBuilder.add(dependencyIndex++);\n+            }\n+            else if (nonUpdatedColumns.contains(handle)) {\n+                dependencyIndex++;\n+            }\n+        }\n+        return dependencyIndexBuilder.build();\n+    }\n+\n+    @JsonProperty\n+    public List<HiveColumnHandle> getAllDataColumns()\n+    {\n+        return allDataColumns;\n+    }\n+\n+    @JsonProperty\n+    public List<HiveColumnHandle> getUpdatedColumns()\n+    {\n+        return updatedColumns;\n+    }\n+\n+    @JsonIgnore\n+    public List<HiveColumnHandle> getNonUpdatedColumns()\n+    {\n+        return nonUpdatedColumns;\n+    }\n+\n+    /**\n+     * Merge the non-updated columns with the update dependencies, in allDataColumns order,\n+     * and finally add the rowId column as the last dependency.\n+     */\n+    public List<HiveColumnHandle> mergeWithNonUpdatedColumns(List<HiveColumnHandle> updateDependencies)\n+    {\n+        ImmutableList.Builder<HiveColumnHandle> builder = ImmutableList.builder();\n+        for (HiveColumnHandle handle : allDataColumns) {\n+            if (nonUpdatedColumns.contains(handle) || updateDependencies.contains(handle)) {\n+                builder.add(handle);\n+            }\n+        }\n+        // The last updateDependency is the rowId column\n+        builder.add(updateDependencies.get(updateDependencies.size() - 1));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Create a RowBlock containing four children: the three ACID columns - - originalTransaction,\n+     * rowId, bucket - - and a RowBlock containing all the data columns not changed\n+     * by the UPDATE statement.\n+     */\n+    public Block createUpdateRowBlock(Page page, List<HiveColumnHandle> updateDependencies, OrcDeletedRows.MaskDeletedRowsFunction maskDeletedRowsFunction)\n+    {\n+        requireNonNull(page, \"page is null\");\n+        requireNonNull(updateDependencies, \"updateDependencies is null\");\n+        Map<HiveColumnHandle, Integer> nonUpdatedChannelNumbers = makeNonUpdatedChannelNumbers(updateDependencies);\n+        int acidBlocks = 3;\n+        checkArgument(page.getChannelCount() >= acidBlocks + nonUpdatedColumns.size(), \"page doesn't have enough columns\");\n+\n+        Block[] blocks = new Block[nonUpdatedColumns.isEmpty() ? acidBlocks : acidBlocks + 1];\n+        blocks[ORIGINAL_TRANSACTION_CHANNEL] = page.getBlock(ORIGINAL_TRANSACTION_CHANNEL);\n+        blocks[ROW_ID_CHANNEL] = page.getBlock(ROW_ID_CHANNEL);\n+        blocks[BUCKET_CHANNEL] = page.getBlock(BUCKET_CHANNEL);\n+\n+        if (!nonUpdatedColumns.isEmpty()) {\n+            Block[] nonUpdatedColumnBlocks = new Block[getNonUpdatedColumns().size()];\n+            int offset = 0;\n+            for (HiveColumnHandle handle : getNonUpdatedColumns()) {\n+                Integer sourceChannel = nonUpdatedChannelNumbers.get(handle);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMDA3MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537130070", "bodyText": "Done, and much nicer.", "author": "djsstarburst", "createdAt": "2020-12-06T21:42:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MjMxNQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536882315", "bodyText": "return deltaDirectory\n        .map(directory -> ImmutableList.of(deleteDeltaDirectory, directory))\n        .orElseGet(() -> ImmutableList.of(deleteDeltaDirectory));", "author": "electrum", "createdAt": "2020-12-05T19:56:23Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/PartitionAndStatementId.java", "diffHunk": "@@ -67,6 +74,23 @@ public String getDeleteDeltaDirectory()\n         return deleteDeltaDirectory;\n     }\n \n+    @JsonProperty\n+    public Optional<String> getDeltaDirectory()\n+    {\n+        return deltaDirectory;\n+    }\n+\n+    @JsonIgnore\n+    public List<String> getAllDirectories()\n+    {\n+        if (deltaDirectory.isPresent()) {\n+            return ImmutableList.of(deleteDeltaDirectory, deltaDirectory.get());\n+        }\n+        else {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMDA3NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537130075", "bodyText": "Nice!   Changed.", "author": "djsstarburst", "createdAt": "2020-12-06T21:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MjMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MzczOQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536883739", "bodyText": "Can this be\n.flatMap(ps -> ps.getAllDirectories().stream())\n.forEach(directory -> ...)", "author": "electrum", "createdAt": "2020-12-05T20:05:29Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/SemiTransactionalHiveMetastore.java", "diffHunk": "@@ -1625,6 +1693,33 @@ private void prepareDeleteRowsFromExistingTable(HdfsContext context, TableAndMor\n             updateTableWriteId(identity, databaseName, tableName, transactionId, writeId, OptionalLong.of(-totalRowsDeleted));\n         }\n \n+        private void prepareUpdateExistingTable(HdfsContext context, TableAndMore tableAndMore)\n+        {\n+            TableAndAcidDirectories updateState = (TableAndAcidDirectories) tableAndMore;\n+            List<PartitionAndStatementId> partitionAndStatementIds = updateState.getPartitionAndStatementIds();\n+            checkArgument(!partitionAndStatementIds.isEmpty(), \"partitionAndStatementIds is empty\");\n+\n+            Table table = updateState.getTable();\n+            checkArgument(currentHiveTransaction.isPresent(), \"currentHiveTransaction isn't present\");\n+            AcidTransaction transaction = currentHiveTransaction.get().getTransaction();\n+            checkArgument(transaction.isUpdate(), \"transaction should be update, but is %s\", transaction);\n+\n+            updateState.getPartitionAndStatementIds().stream()\n+                    .map(ps -> ps.getAllDirectories())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMDA4NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537130084", "bodyText": "Changed.", "author": "djsstarburst", "createdAt": "2020-12-06T21:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MzgzNA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536883834", "bodyText": "Add trailing comma", "author": "electrum", "createdAt": "2020-12-05T20:06:05Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/SemiTransactionalHiveMetastore.java", "diffHunk": "@@ -2462,7 +2557,8 @@ private void checkHoldsLock()\n         ADD,\n         ALTER,\n         INSERT_EXISTING,\n-        DELETE_ROWS\n+        DELETE_ROWS,\n+        UPDATE", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMDA5MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537130090", "bodyText": "Added.", "author": "djsstarburst", "createdAt": "2020-12-06T21:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg4MzgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MjM3NA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r536892374", "bodyText": "Use method reference", "author": "electrum", "createdAt": "2020-12-05T21:04:02Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/orc/OrcPageSourceFactory.java", "diffHunk": "@@ -399,6 +404,13 @@ else if (column.getBaseHiveColumnIndex() < fileColumns.size()) {\n                     columnAdaptations.add(ColumnAdaptation.rowIdColumn());\n                 }\n             }\n+            else if (transaction.isUpdate()) {\n+                checkArgument(updateProcessor.isPresent(), \"updateProcessor isn't present\");\n+                List<HiveColumnHandle> dependencyColumns = projections.stream()\n+                        .filter(projection -> projection.isBaseColumn())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEzMDEwNw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537130107", "bodyText": "Replaced.", "author": "djsstarburst", "createdAt": "2020-12-06T21:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5MjM3NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYxOTE5OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537619198", "bodyText": "Given #5861 (comment), add some validation to ensure the list of columns in target is the same size as the updatedColumnValueSymbols", "author": "martint", "createdAt": "2020-12-07T15:57:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/UpdateNode.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.plan;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.plan.TableWriterNode.UpdateTarget;\n+\n+import javax.annotation.concurrent.Immutable;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+@Immutable\n+public class UpdateNode\n+        extends PlanNode\n+{\n+    private final PlanNode source;\n+    private final UpdateTarget target;\n+    private final Symbol rowId;\n+    private final List<Symbol> updatedColumnValueSymbols;\n+    private final List<Symbol> outputs;\n+\n+    @JsonCreator\n+    public UpdateNode(\n+            @JsonProperty(\"id\") PlanNodeId id,\n+            @JsonProperty(\"source\") PlanNode source,\n+            @JsonProperty(\"target\") UpdateTarget target,\n+            @JsonProperty(\"rowId\") Symbol rowId,\n+            @JsonProperty(\"updatedColumnValueSymbols\") List<Symbol> updatedColumnValueSymbols,\n+            @JsonProperty(\"outputs\") List<Symbol> outputs)\n+    {\n+        super(id);\n+\n+        this.source = requireNonNull(source, \"source is null\");\n+        this.target = requireNonNull(target, \"target is null\");\n+        this.rowId = requireNonNull(rowId, \"rowId is null\");\n+        this.updatedColumnValueSymbols = ImmutableList.copyOf(requireNonNull(updatedColumnValueSymbols, \"updatedColumnValueSymbols is null\"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxMjE4NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r538012185", "bodyText": "I added a check to ensure they have the same sizes.  I also renamed the list of symbols and the corresponding list of channels to be the more accurate columnValueAndRowIdSymbols / columnValueAndRowIdChannels.", "author": "djsstarburst", "createdAt": "2020-12-08T03:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYxOTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYyNDU3MA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r537624570", "bodyText": "In #5861 (comment), you mentioned that the list of columns in UpdateTarget needs to have the same order as updatedColumnValues. However, now this is a Map, so the order is not guaranteed.", "author": "martint", "createdAt": "2020-12-07T16:03:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -470,6 +474,65 @@ public DeleteNode plan(Delete node)\n         return new DeleteNode(idAllocator.getNextId(), builder.getRoot(), new DeleteTarget(handle, metadata.getTableMetadata(session, handle).getTable()), rowId, outputs);\n     }\n \n+    public UpdateNode plan(Update node)\n+    {\n+        Table table = node.getTable();\n+        TableHandle handle = analysis.getTableHandle(table);\n+\n+        Map<String, ColumnHandle> dataColumnHandles = metadata.getColumnHandles(session, handle);\n+        List<String> targetColumnNames = node.getAssignments().stream()\n+                .map(assignment -> assignment.getName().getValue())\n+                .collect(toImmutableList());\n+\n+        // Create a list of column SET expressions, in table column order\n+        ImmutableList.Builder<Expression> orderedColumnValuesBuilder = ImmutableList.builder();\n+        for (String columnName : dataColumnHandles.keySet()) {\n+            int index = targetColumnNames.indexOf(columnName);\n+            if (index >= 0) {\n+                orderedColumnValuesBuilder.add(node.getAssignments().get(index).getValue());\n+            }\n+        }\n+        List<Expression> orderedColumnValues = orderedColumnValuesBuilder.build();\n+\n+        // create table scan\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session, recursiveSubqueries)\n+                .process(table, null);\n+\n+        PlanBuilder builder = newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n+\n+        if (node.getWhere().isPresent()) {\n+            builder = filter(builder, node.getWhere().get(), node);\n+        }\n+\n+        builder = builder.appendProjections(orderedColumnValues, symbolAllocator, idAllocator);\n+\n+        PlanAndMappings planAndMappings = coerce(builder, orderedColumnValues, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        builder = planAndMappings.getSubPlan();\n+\n+        ImmutableList.Builder<Symbol> updatedColumnValuesBuilder = ImmutableList.builder();\n+        orderedColumnValues.forEach(columnValue -> updatedColumnValuesBuilder.add(planAndMappings.get(columnValue)));\n+        Symbol rowId = builder.translate(analysis.getRowIdField(table));\n+        updatedColumnValuesBuilder.add(rowId);\n+        List<Symbol> updatedColumnValues = updatedColumnValuesBuilder.build();\n+\n+        Map<String, ColumnHandle> updatedColumns = dataColumnHandles.entrySet().stream()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxMjE2NQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r538012165", "bodyText": "I'm glad you pushed on this @martint!  I rewrote this code to use Lists exclusively, avoiding the Map order hazard.  I also did some renaming to make the usage more obvious.", "author": "djsstarburst", "createdAt": "2020-12-08T03:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYyNDU3MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMDIzOQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r538700239", "bodyText": "Verify that updateColumns and updatedColumnHandles have the same length.", "author": "martint", "createdAt": "2020-12-08T18:31:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/TableWriterNode.java", "diffHunk": "@@ -451,4 +452,56 @@ public String toString()\n             return handle.toString();\n         }\n     }\n+\n+    public static class UpdateTarget\n+            extends WriterTarget\n+    {\n+        private final TableHandle handle;\n+        private final SchemaTableName schemaTableName;\n+        private final List<String> updatedColumns;\n+        private final List<ColumnHandle> updatedColumnHandles;\n+\n+        @JsonCreator\n+        public UpdateTarget(\n+                @JsonProperty(\"handle\") TableHandle handle,\n+                @JsonProperty(\"schemaTableName\") SchemaTableName schemaTableName,\n+                @JsonProperty(\"updatedColumns\") List<String> updatedColumns,\n+                @JsonProperty(\"updatedColumnHandles\") List<ColumnHandle> updatedColumnHandles)\n+        {\n+            this.handle = requireNonNull(handle, \"handle is null\");\n+            this.schemaTableName = requireNonNull(schemaTableName, \"schemaTableName is null\");\n+            this.updatedColumns = requireNonNull(updatedColumns, \"updatedColumns is null\");\n+            this.updatedColumnHandles = requireNonNull(updatedColumnHandles, \"updatedColumnHandles is null\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxOTg4OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r538719888", "bodyText": "Added.", "author": "djsstarburst", "createdAt": "2020-12-08T18:53:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMDIzOQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4OTc4Mg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r540489782", "bodyText": "The base file and delta files can coexist as well before the subsequent compaction. Is that handled?", "author": "abhishekkhanna1", "createdAt": "2020-12-10T20:54:48Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -114,36 +131,58 @@ public HiveUpdatablePageSource(\n         this.hiveRowTypeNullsBlock = nativeValueToBlock(hiveRowType.getType(typeManager), null);\n         checkArgument(hiveTableHandle.isInAcidTransaction(), \"Not in a transaction; hiveTableHandle: %s\", hiveTableHandle);\n         this.writeId = hiveTableHandle.getWriteId();\n+        this.updateKind = requireNonNull(updateKind, \"updateKind is null\");\n         this.hiveAcidSchema = createAcidSchema(hiveRowType);\n         requireNonNull(bucketPath, \"bucketPath is null\");\n+        Matcher matcher;\n         if (originalFile) {\n-            Matcher matcher = ORIGINAL_FILE_PATH_MATCHER.matcher(bucketPath.toString());\n+            matcher = ORIGINAL_FILE_PATH_MATCHER.matcher(bucketPath.toString());\n             checkArgument(matcher.matches(), \"Original file bucketPath doesn't have the required format: %s\", bucketPath);\n             this.bucketFilename = format(\"bucket_%05d\", bucketNumber.isEmpty() ? 0 : bucketNumber.getAsInt());\n-            this.deleteDeltaDirectory = new Path(format(\"%s/%s\", matcher.group(\"rootDir\"), deleteDeltaSubdir(writeId, writeId, statementId)));\n         }\n         else {\n-            Matcher matcher = BUCKET_PATH_MATCHER.matcher(bucketPath.toString());\n-            checkArgument(matcher.matches(), \"bucketPath doesn't have the required format: %s\", bucketPath);\n-            // delete_delta bucket files should not have attemptId suffix\n-            this.bucketFilename = matcher.group(\"filenameBase\");\n-            this.deleteDeltaDirectory = new Path(format(\"%s/%s\", matcher.group(\"rootDir\"), deleteDeltaSubdir(writeId, writeId, statementId)));\n+            matcher = BASE_PATH_MATCHER.matcher(bucketPath.toString());\n+            if (matcher.matches()) {\n+                this.bucketFilename = matcher.group(\"filenameBase\");\n+            }\n+            else {\n+                matcher = BUCKET_PATH_MATCHER.matcher(bucketPath.toString());\n+                checkArgument(matcher.matches(), \"bucketPath doesn't have the required format: %s\", bucketPath);\n+                this.bucketFilename = matcher.group(\"filenameBase\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyMDEwMg==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r543820102", "bodyText": "It's a good point.  I just updated product test TestHiveTransactionalTable.testAcidUpdateMajorCompaction to add a series of operations that create more delta files in addition to the compacted base image, showing that they can coexist.", "author": "djsstarburst", "createdAt": "2020-12-16T01:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4OTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4OTk4OQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r540489989", "bodyText": "nit: s/compaction/major compaction/g\nMinor compaction does not create the base directory", "author": "abhishekkhanna1", "createdAt": "2020-12-10T20:55:09Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveUpdatablePageSource.java", "diffHunk": "@@ -62,13 +67,18 @@\n     public static final int ORIGINAL_TRANSACTION_CHANNEL = 0;\n     public static final int ROW_ID_CHANNEL = 1;\n     public static final int BUCKET_CHANNEL = 2;\n+    // Used for UPDATE operations\n+    public static final int ROW_CHANNEL = 3;\n     public static final int ACID_ROW_STRUCT_COLUMN_ID = 6;\n     public static final Block DELETE_OPERATION_BLOCK = nativeValueToBlock(INTEGER, Long.valueOf(DELETE.getOperationNumber()));\n+    public static final Block INSERT_OPERATION_BLOCK = nativeValueToBlock(INTEGER, Long.valueOf(INSERT.getOperationNumber()));\n \n     // The bucketPath looks like .../delta_nnnnnnn_mmmmmmm_ssss/bucket_bbbbb(_aaaa)?\n     public static final Pattern BUCKET_PATH_MATCHER = Pattern.compile(\"(?s)(?<rootDir>.*)/(?<dirStart>delta_[\\\\d]+_[\\\\d]+)_(?<statementId>[\\\\d]+)/(?<filenameBase>bucket_(?<bucketNumber>[\\\\d]+))(?<attemptId>_[\\\\d]+)?$\");\n     // The orignal file path looks like .../nnnnnnn_m(_copy_ccc)?\n     public static final Pattern ORIGINAL_FILE_PATH_MATCHER = Pattern.compile(\"(?s)(?<rootDir>.*)/(?<filename>(?<bucketNumber>[\\\\d]+)_(?<rest>.*)?)$\");\n+    // After compaction, the bucketPath looks like .../base_nnnnnnn/bucket_bbbbb(_aaaa)?", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyMDEyMw==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r543820123", "bodyText": "Replaced.", "author": "djsstarburst", "createdAt": "2020-12-16T01:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4OTk4OQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MTAxOQ==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r543751019", "bodyText": "Optional third argument targetTable expected", "author": "abhishekkhanna1", "createdAt": "2020-12-15T23:03:20Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1785,6 +1813,105 @@ else if (node.getType() == FULL) {\n             return output;\n         }\n \n+        @Override\n+        protected Scope visitUpdate(Update update, Optional<Scope> scope)\n+        {\n+            Table table = update.getTable();\n+            QualifiedObjectName tableName = createQualifiedObjectName(session, table, table.getName());\n+            if (metadata.getView(session, tableName).isPresent()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating through views is not supported\");\n+            }\n+\n+            TableHandle handle = metadata.getTableHandle(session, tableName)\n+                    .orElseThrow(() -> semanticException(TABLE_NOT_FOUND, table, \"Table '%s' does not exist\", tableName));\n+\n+            TableMetadata tableMetadata = metadata.getTableMetadata(session, handle);\n+\n+            List<ColumnMetadata> allColumns = tableMetadata.getColumns();\n+            Map<String, ColumnMetadata> columns = allColumns.stream()\n+                    .collect(toImmutableMap(ColumnMetadata::getName, Function.identity()));\n+\n+            for (UpdateAssignment assignment : update.getAssignments()) {\n+                String columnName = assignment.getName().getValue();\n+                if (!columns.containsKey(columnName)) {\n+                    throw semanticException(COLUMN_NOT_FOUND, assignment.getName(), \"The UPDATE SET target column %s doesn't exist\", columnName);\n+                }\n+            }\n+\n+            Set<String> assignmentTargets = update.getAssignments().stream()\n+                    .map(assignment -> assignment.getName().getValue())\n+                    .collect(toImmutableSet());\n+            accessControl.checkCanUpdateTableColumns(session.toSecurityContext(), tableName, assignmentTargets);\n+\n+            if (!accessControl.getRowFilters(session.toSecurityContext(), tableName).isEmpty()) {\n+                throw semanticException(NOT_SUPPORTED, update, \"Updating a table with a row filter is not supported\");\n+            }\n+\n+            // TODO: how to deal with connectors that need to see the pre-image of rows to perform the update without\n+            //       flowing that data through the masking logic\n+            for (ColumnMetadata tableColumn : allColumns) {\n+                if (!accessControl.getColumnMasks(session.toSecurityContext(), tableName, tableColumn.getName(), tableColumn.getType()).isEmpty()) {\n+                    throw semanticException(NOT_SUPPORTED, update, \"Updating a table with column masks is not supported\");\n+                }\n+            }\n+\n+            List<ColumnMetadata> updatedColumns = allColumns.stream()\n+                    .filter(column -> assignmentTargets.contains(column.getName()))\n+                    .collect(toImmutableList());\n+            analysis.setUpdateType(\"UPDATE\", tableName);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyMDI4OA==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r543820288", "bodyText": "Added.", "author": "djsstarburst", "createdAt": "2020-12-16T01:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MTAxOQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "af17e514745d1480e22a8fee14ded1cd267a72b9", "url": "https://github.com/trinodb/trino/commit/af17e514745d1480e22a8fee14ded1cd267a72b9", "message": "Support SQL UPDATE in the Presto Engine\n\nThis commit adds parsing, analysis and query planning for SQL\nUPDATE statements.  A second commit on top of this commit adds Hive ACID\nsupport for UPDATE, and product tests that show UPDATE works\nas expected.\n\nThis commit includes a new developer documentation page for connector\ndevelopers, delete-and-update.rst, that explains in detail how DELETE\nand UPDATE work.  This document refers to the Hive ACID implementation of\nUPDATE, coming in the second commit.\n\nOne note for the reader: before this commit, method ConnectorMetadata method\ngetUpdateRowIdColumnHandle() was used to get the rowId column handle for DELETE operations.\nThis was renamed to getDeleteRowIdColumnHandle(), to make way for the new\ngetUpdateRowIdColumnHandle(), used to get the rowId column handle for UPDATE operations.", "committedDate": "2021-02-03T16:58:25Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "7d8e8acbae62b0e1ce361c7184456e945c284c55", "url": "https://github.com/trinodb/trino/commit/7d8e8acbae62b0e1ce361c7184456e945c284c55", "message": "Implement SQL UPDATE for Hive ACID Tables\n\nThis commit implements SQL UPDATE for Hive ACID Tables, and adds\nproduct tests that demonstrate that it works as expected.  Those tests\ncheck:\no Expected failures cases - - e.g., non-transactional table; updating\n  partition or bucket columns.\no Some or all columns of the table updated.\no A spanning set of cases of overlap between dependency columns and\n  updated columns.\no A spanning set of cases of overlap between dependency columns and\n  non-updated columns.\no Permuted order of columns updated compared to table declaration order.\no Unpartitioned, partitioned and bucketed table updates.\no Some or all columns updated to either litereal or computed NULLs.", "committedDate": "2021-02-03T18:46:00Z", "type": "commit"}, {"oid": "7d8e8acbae62b0e1ce361c7184456e945c284c55", "url": "https://github.com/trinodb/trino/commit/7d8e8acbae62b0e1ce361c7184456e945c284c55", "message": "Implement SQL UPDATE for Hive ACID Tables\n\nThis commit implements SQL UPDATE for Hive ACID Tables, and adds\nproduct tests that demonstrate that it works as expected.  Those tests\ncheck:\no Expected failures cases - - e.g., non-transactional table; updating\n  partition or bucket columns.\no Some or all columns of the table updated.\no A spanning set of cases of overlap between dependency columns and\n  updated columns.\no A spanning set of cases of overlap between dependency columns and\n  non-updated columns.\no Permuted order of columns updated compared to table declaration order.\no Unpartitioned, partitioned and bucketed table updates.\no Some or all columns updated to either litereal or computed NULLs.", "committedDate": "2021-02-03T18:46:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU3ODU4Ng==", "url": "https://github.com/trinodb/trino/pull/5861#discussion_r599578586", "bodyText": "Add some info how this list should be decomposed, perhaps as a javadoc", "author": "findepi", "createdAt": "2021-03-23T13:42:28Z", "path": "core/trino-spi/src/main/java/io/trino/spi/connector/UpdatablePageSource.java", "diffHunk": "@@ -14,15 +14,25 @@\n package io.trino.spi.connector;\n \n import io.airlift.slice.Slice;\n+import io.trino.spi.Page;\n import io.trino.spi.block.Block;\n \n import java.util.Collection;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n public interface UpdatablePageSource\n         extends ConnectorPageSource\n {\n-    void deleteRows(Block rowIds);\n+    default void deleteRows(Block rowIds)\n+    {\n+        throw new UnsupportedOperationException(\"This connector does not support row-level delete\");\n+    }\n+\n+    default void updateRows(Page page, List<Integer> columnValueAndRowIdChannels)", "originalCommit": "7d8e8acbae62b0e1ce361c7184456e945c284c55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}