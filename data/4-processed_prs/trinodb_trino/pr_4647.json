{"pr_number": 4647, "pr_title": "Simplify comparable and orderable type operators", "pr_createdAt": "2020-07-31T00:25:43Z", "pr_url": "https://github.com/trinodb/trino/pull/4647", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzOTUyMA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r478639520", "bodyText": "How are the changes in this file related to the commit title?", "author": "martint", "createdAt": "2020-08-27T19:15:36Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/JsonToArrayCast.java", "diffHunk": "@@ -32,7 +32,6 @@\n \n import java.lang.invoke.MethodHandle;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTcwMzg0MQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r479703841", "bodyText": "When you remove the hash table the code folds up to a  simpler shared interface on the callers.", "author": "dain", "createdAt": "2020-08-30T00:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzOTUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0MDkzNA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r478640934", "bodyText": "Same here. The changes in this file seem unrelated to the commit message.", "author": "martint", "createdAt": "2020-08-27T19:18:11Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/JsonToRowCast.java", "diffHunk": "@@ -25,22 +25,15 @@\n import io.prestosql.spi.PrestoException;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxMDAzNg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487210036", "bodyText": "Wouldn't it be clearer to separate the default choice into a dedicated argument?\npublic ChoicesScalarFunctionImplementation(FunctionBinding functionBinding, ScalarImplementationChoice defaultChoice, List<ScalarImplementationChoice> otherChoices)", "author": "martint", "createdAt": "2020-09-11T18:13:11Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ChoicesScalarFunctionImplementation.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionInvoker;\n+import io.prestosql.metadata.ScalarFunctionAdapter;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.metadata.ScalarFunctionAdapter.NullAdaptationPolicy.UNSUPPORTED;\n+import static io.prestosql.spi.StandardErrorCode.FUNCTION_NOT_FOUND;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NULL_FLAG;\n+import static java.lang.String.format;\n+import static java.util.Comparator.comparingInt;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class ChoicesScalarFunctionImplementation\n+        implements ScalarFunctionImplementation\n+{\n+    private final ScalarFunctionAdapter functionAdapter = new ScalarFunctionAdapter(UNSUPPORTED);\n+\n+    private final FunctionBinding functionBinding;\n+    private final List<ScalarImplementationChoice> choices;\n+\n+    public ChoicesScalarFunctionImplementation(\n+            FunctionBinding functionBinding,\n+            InvocationReturnConvention returnConvention,\n+            List<InvocationArgumentConvention> argumentConventions,\n+            MethodHandle methodHandle)\n+    {\n+        this(functionBinding, returnConvention, argumentConventions, ImmutableList.of(), methodHandle, Optional.empty());\n+    }\n+\n+    public ChoicesScalarFunctionImplementation(\n+            FunctionBinding functionBinding,\n+            InvocationReturnConvention returnConvention,\n+            List<InvocationArgumentConvention> argumentConventions,\n+            MethodHandle methodHandle,\n+            Optional<MethodHandle> instanceFactory)\n+    {\n+        this(functionBinding, returnConvention, argumentConventions, ImmutableList.of(), methodHandle, instanceFactory);\n+    }\n+\n+    public ChoicesScalarFunctionImplementation(\n+            FunctionBinding functionBinding,\n+            InvocationReturnConvention returnConvention,\n+            List<InvocationArgumentConvention> argumentConventions,\n+            List<Class<?>> lambdaInterfaces,\n+            MethodHandle methodHandle,\n+            Optional<MethodHandle> instanceFactory)\n+    {\n+        this(functionBinding, ImmutableList.of(new ScalarImplementationChoice(returnConvention, argumentConventions, lambdaInterfaces, methodHandle, instanceFactory)));\n+    }\n+\n+    /**\n+     * Creates a ScalarFunctionImplementation consisting of one or more choices.\n+     * <p>\n+     * All choices must have the same SQL signature, and are equivalent in what they do.\n+     * The first choice is the default choice, which is the one used for legacy access methods.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTE2Mg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r489081162", "bodyText": "This is a rename of ScalarFunctionImplementation below... the diff doesn't work out because I extracted the interface", "author": "dain", "createdAt": "2020-09-15T23:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxMDAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyOTk0NA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487229944", "bodyText": "requireNonNull is not really needed. List.copyOf will fail with NPE if the reference is null.", "author": "martint", "createdAt": "2020-09-11T18:55:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TypeOperatorDeclaration.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.OperatorMethodHandle;\n+import io.prestosql.spi.function.OperatorType;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NULL_FLAG;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.function.InvocationConvention.simpleConvention;\n+import static java.lang.String.format;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class TypeOperatorDeclaration\n+{\n+    public static final TypeOperatorDeclaration NO_TYPE_OPERATOR_DECLARATION = builder(boolean.class).build();\n+\n+    private final Collection<OperatorMethodHandle> equalOperators;\n+    private final Collection<OperatorMethodHandle> hashCodeOperators;\n+    private final Collection<OperatorMethodHandle> xxHash64Operators;\n+    private final Collection<OperatorMethodHandle> distinctFromOperators;\n+    private final Collection<OperatorMethodHandle> indeterminateOperators;\n+\n+    private TypeOperatorDeclaration(\n+            Collection<OperatorMethodHandle> equalOperators,\n+            Collection<OperatorMethodHandle> hashCodeOperators,\n+            Collection<OperatorMethodHandle> xxHash64Operators,\n+            Collection<OperatorMethodHandle> distinctFromOperators,\n+            Collection<OperatorMethodHandle> indeterminateOperators)\n+    {\n+        this.equalOperators = List.copyOf(requireNonNull(equalOperators, \"equalOperators is null\"));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4MDE4NQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487280185", "bodyText": "This method operates on the first argument, so its name and the fact that it takes a list of arguments makes it a little confusing. Consider renaming it to extractFirstArgumentConvention or extractNextArgumentConvention", "author": "martint", "createdAt": "2020-09-11T20:40:12Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TypeOperatorDeclaration.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.BlockIndex;\n+import io.prestosql.spi.function.BlockPosition;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.OperatorMethodHandle;\n+import io.prestosql.spi.function.OperatorType;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NULL_FLAG;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.function.InvocationConvention.simpleConvention;\n+import static java.lang.String.format;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class TypeOperatorDeclaration\n+{\n+    public static final TypeOperatorDeclaration NO_TYPE_OPERATOR_DECLARATION = builder(boolean.class).build();\n+\n+    private final Collection<OperatorMethodHandle> equalOperators;\n+    private final Collection<OperatorMethodHandle> hashCodeOperators;\n+    private final Collection<OperatorMethodHandle> xxHash64Operators;\n+    private final Collection<OperatorMethodHandle> distinctFromOperators;\n+    private final Collection<OperatorMethodHandle> indeterminateOperators;\n+\n+    private TypeOperatorDeclaration(\n+            Collection<OperatorMethodHandle> equalOperators,\n+            Collection<OperatorMethodHandle> hashCodeOperators,\n+            Collection<OperatorMethodHandle> xxHash64Operators,\n+            Collection<OperatorMethodHandle> distinctFromOperators,\n+            Collection<OperatorMethodHandle> indeterminateOperators)\n+    {\n+        this.equalOperators = List.copyOf(requireNonNull(equalOperators, \"equalOperators is null\"));\n+        this.hashCodeOperators = List.copyOf(requireNonNull(hashCodeOperators, \"hashCodeOperators is null\"));\n+        this.xxHash64Operators = List.copyOf(requireNonNull(xxHash64Operators, \"xxHash64Operators is null\"));\n+        this.distinctFromOperators = List.copyOf(requireNonNull(distinctFromOperators, \"distinctFromOperators is null\"));\n+        this.indeterminateOperators = List.copyOf(requireNonNull(indeterminateOperators, \"indeterminateOperators is null\"));\n+    }\n+\n+    public boolean isComparable()\n+    {\n+        return !equalOperators.isEmpty();\n+    }\n+\n+    public Collection<OperatorMethodHandle> getEqualOperators()\n+    {\n+        return equalOperators;\n+    }\n+\n+    public Collection<OperatorMethodHandle> getHashCodeOperators()\n+    {\n+        return hashCodeOperators;\n+    }\n+\n+    public Collection<OperatorMethodHandle> getXxHash64Operators()\n+    {\n+        return xxHash64Operators;\n+    }\n+\n+    public Collection<OperatorMethodHandle> getDistinctFromOperators()\n+    {\n+        return distinctFromOperators;\n+    }\n+\n+    public Collection<OperatorMethodHandle> getIndeterminateOperators()\n+    {\n+        return indeterminateOperators;\n+    }\n+\n+    public static Builder builder(Class<?> typeJavaType)\n+    {\n+        return new Builder(typeJavaType);\n+    }\n+\n+    public static TypeOperatorDeclaration extractOperatorDeclaration(Class<?> operatorsClass, Lookup lookup, Class<?> typeJavaType)\n+    {\n+        return new Builder(typeJavaType)\n+                .addOperators(operatorsClass, lookup)\n+                .build();\n+    }\n+\n+    public static class Builder\n+    {\n+        private final Class<?> typeJavaType;\n+\n+        private final Collection<OperatorMethodHandle> equalOperators = new ArrayList<>();\n+        private final Collection<OperatorMethodHandle> hashCodeOperators = new ArrayList<>();\n+        private final Collection<OperatorMethodHandle> xxHash64Operators = new ArrayList<>();\n+        private final Collection<OperatorMethodHandle> distinctFromOperators = new ArrayList<>();\n+        private final Collection<OperatorMethodHandle> indeterminateOperators = new ArrayList<>();\n+\n+        public Builder(Class<?> typeJavaType)\n+        {\n+            this.typeJavaType = requireNonNull(typeJavaType, \"typeJavaType is null\");\n+            checkArgument(!typeJavaType.equals(void.class), \"void type is not supported\");\n+        }\n+\n+        public Builder addEqualOperator(OperatorMethodHandle equalOperator)\n+        {\n+            verifyMethodHandleSignature(2, boolean.class, equalOperator);\n+            this.equalOperators.add(equalOperator);\n+            return this;\n+        }\n+\n+        public Builder addEqualOperators(Collection<OperatorMethodHandle> equalOperators)\n+        {\n+            for (OperatorMethodHandle equalOperator : equalOperators) {\n+                verifyMethodHandleSignature(2, boolean.class, equalOperator);\n+            }\n+            this.equalOperators.addAll(equalOperators);\n+            return this;\n+        }\n+\n+        public Builder addHashCodeOperator(OperatorMethodHandle hashCodeOperator)\n+        {\n+            verifyMethodHandleSignature(1, long.class, hashCodeOperator);\n+            this.hashCodeOperators.add(hashCodeOperator);\n+            return this;\n+        }\n+\n+        public Builder addHashCodeOperators(Collection<OperatorMethodHandle> hashCodeOperators)\n+        {\n+            for (OperatorMethodHandle hashCodeOperator : hashCodeOperators) {\n+                verifyMethodHandleSignature(1, long.class, hashCodeOperator);\n+            }\n+            this.hashCodeOperators.addAll(hashCodeOperators);\n+            return this;\n+        }\n+\n+        public Builder addXxHash64Operator(OperatorMethodHandle xxHash64Operator)\n+        {\n+            verifyMethodHandleSignature(1, long.class, xxHash64Operator);\n+            this.xxHash64Operators.add(xxHash64Operator);\n+            return this;\n+        }\n+\n+        public Builder addXxHash64Operators(Collection<OperatorMethodHandle> xxHash64Operators)\n+        {\n+            for (OperatorMethodHandle xxHash64Operator : xxHash64Operators) {\n+                verifyMethodHandleSignature(1, long.class, xxHash64Operator);\n+            }\n+            this.xxHash64Operators.addAll(xxHash64Operators);\n+            return this;\n+        }\n+\n+        public Builder addDistinctFromOperator(OperatorMethodHandle distinctFromOperator)\n+        {\n+            verifyMethodHandleSignature(2, boolean.class, distinctFromOperator);\n+            this.distinctFromOperators.add(distinctFromOperator);\n+            return this;\n+        }\n+\n+        public Builder addDistinctFromOperators(Collection<OperatorMethodHandle> distinctFromOperators)\n+        {\n+            for (OperatorMethodHandle distinctFromOperator : distinctFromOperators) {\n+                verifyMethodHandleSignature(2, boolean.class, distinctFromOperator);\n+            }\n+            this.distinctFromOperators.addAll(distinctFromOperators);\n+            return this;\n+        }\n+\n+        public Builder addIndeterminateOperator(OperatorMethodHandle indeterminateOperator)\n+        {\n+            verifyMethodHandleSignature(1, boolean.class, indeterminateOperator);\n+            this.indeterminateOperators.add(indeterminateOperator);\n+            return this;\n+        }\n+\n+        public Builder addIndeterminateOperators(Collection<OperatorMethodHandle> indeterminateOperators)\n+        {\n+            for (OperatorMethodHandle indeterminateOperator : indeterminateOperators) {\n+                verifyMethodHandleSignature(1, boolean.class, indeterminateOperator);\n+            }\n+            this.indeterminateOperators.addAll(indeterminateOperators);\n+            return this;\n+        }\n+\n+        public Builder addOperators(Class<?> operatorsClass, Lookup lookup)\n+        {\n+            boolean addedOperator = false;\n+            for (Method method : operatorsClass.getDeclaredMethods()) {\n+                ScalarOperator scalarOperator = method.getAnnotation(ScalarOperator.class);\n+                if (scalarOperator == null) {\n+                    continue;\n+                }\n+                OperatorType operatorType = scalarOperator.value();\n+\n+                MethodHandle methodHandle;\n+                try {\n+                    methodHandle = lookup.unreflect(method);\n+                }\n+                catch (IllegalAccessException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+                switch (operatorType) {\n+                    case EQUAL:\n+                        addEqualOperator(new OperatorMethodHandle(parseInvocationConvention(operatorType, typeJavaType, method, boolean.class), methodHandle));\n+                        break;\n+                    case HASH_CODE:\n+                        addHashCodeOperator(new OperatorMethodHandle(parseInvocationConvention(operatorType, typeJavaType, method, long.class), methodHandle));\n+                        break;\n+                    case XX_HASH_64:\n+                        addXxHash64Operator(new OperatorMethodHandle(parseInvocationConvention(operatorType, typeJavaType, method, long.class), methodHandle));\n+                        break;\n+                    case IS_DISTINCT_FROM:\n+                        addDistinctFromOperator(new OperatorMethodHandle(parseInvocationConvention(operatorType, typeJavaType, method, boolean.class), methodHandle));\n+                        break;\n+                    case INDETERMINATE:\n+                        addIndeterminateOperator(new OperatorMethodHandle(parseInvocationConvention(operatorType, typeJavaType, method, boolean.class), methodHandle));\n+                        break;\n+                    default:\n+                        throw new IllegalArgumentException(operatorType + \" operator is not supported: \" + method);\n+                }\n+                addedOperator = true;\n+            }\n+            if (!addedOperator) {\n+                throw new IllegalArgumentException(operatorsClass + \" does not contain any operators\");\n+            }\n+            return this;\n+        }\n+\n+        private void verifyMethodHandleSignature(int expectedArgumentCount, Class<?> returnJavaType, OperatorMethodHandle operatorMethodHandle)\n+        {\n+            MethodType methodType = operatorMethodHandle.getMethodHandle().type();\n+            InvocationConvention convention = operatorMethodHandle.getCallingConvention();\n+\n+            checkArgument(convention.getArgumentConventions().size() == expectedArgumentCount,\n+                    \"Expected %s arguments, but got %s\", expectedArgumentCount, convention.getArgumentConventions().size());\n+\n+            checkArgument(methodType.parameterList().stream().noneMatch(ConnectorSession.class::equals),\n+                    \"Session is not supported in type operators\");\n+\n+            int expectedParameterCount = convention.getArgumentConventions().stream()\n+                    .mapToInt(InvocationArgumentConvention::getParameterCount)\n+                    .sum();\n+            checkArgument(expectedParameterCount == methodType.parameterCount(),\n+                    \"Expected %s method parameters, but got %s\", expectedParameterCount, methodType.parameterCount());\n+\n+            int parameterIndex = 0;\n+            for (InvocationArgumentConvention argumentConvention : convention.getArgumentConventions()) {\n+                Class<?> parameterType = methodType.parameterType(parameterIndex);\n+                checkArgument(!parameterType.equals(ConnectorSession.class), \"Session is not supported in type operators\");\n+                switch (argumentConvention) {\n+                    case NEVER_NULL:\n+                        checkArgument(parameterType.isAssignableFrom(typeJavaType),\n+                                \"Expected argument type to be %s, but is %s\", typeJavaType, parameterType);\n+                        break;\n+                    case NULL_FLAG:\n+                        checkArgument(parameterType.isAssignableFrom(typeJavaType),\n+                                \"Expected argument type to be %s, but is %s\", typeJavaType, parameterType);\n+                        checkArgument(methodType.parameterType(parameterIndex + 1).equals(boolean.class),\n+                                \"Expected null flag parameter to be followed by a boolean parameter\");\n+                        break;\n+                    case BOXED_NULLABLE:\n+                        checkArgument(parameterType.isAssignableFrom(wrap(typeJavaType)),\n+                                \"Expected argument type to be %s, but is %s\", wrap(typeJavaType), parameterType);\n+                        break;\n+                    case BLOCK_POSITION:\n+                        checkArgument(parameterType.equals(Block.class) && methodType.parameterType(parameterIndex + 1).equals(int.class),\n+                                \"Expected BLOCK_POSITION argument have parameters Block and int\");\n+                        break;\n+                    case FUNCTION:\n+                        throw new IllegalArgumentException(\"Function argument convention is not supported in type operators\");\n+                    default:\n+                        throw new UnsupportedOperationException(\"Unknown argument convention: \" + argumentConvention);\n+                }\n+                parameterIndex += argumentConvention.getParameterCount();\n+            }\n+\n+            InvocationReturnConvention returnConvention = convention.getReturnConvention();\n+            switch (returnConvention) {\n+                case FAIL_ON_NULL:\n+                    checkArgument(methodType.returnType().equals(returnJavaType),\n+                            \"Expected return type to be %s, but is %s\", returnJavaType, methodType.returnType());\n+                    break;\n+                case NULLABLE_RETURN:\n+                    checkArgument(methodType.returnType().equals(wrap(returnJavaType)),\n+                            \"Expected return type to be %s, but is %s\", returnJavaType, wrap(methodType.returnType()));\n+                    break;\n+                default:\n+                    throw new UnsupportedOperationException(\"Unknown return convention: \" + returnConvention);\n+            }\n+        }\n+\n+        private static InvocationConvention parseInvocationConvention(OperatorType operatorType, Class<?> typeJavaType, Method method, Class<?> expectedReturnType)\n+        {\n+            checkArgument(expectedReturnType.isPrimitive(), \"Expected return type must be a primitive: \" + expectedReturnType);\n+\n+            InvocationReturnConvention returnConvention = getReturnConvention(expectedReturnType, operatorType, method);\n+\n+            List<Class<?>> parameterTypes = List.of(method.getParameterTypes());\n+            List<Annotation[]> parameterAnnotations = List.of(method.getParameterAnnotations());\n+\n+            InvocationArgumentConvention leftArgumentConvention = extractArgumentConvention(typeJavaType, parameterTypes, parameterAnnotations, operatorType, method);\n+            if (leftArgumentConvention.getParameterCount() == parameterTypes.size()) {\n+                return simpleConvention(returnConvention, leftArgumentConvention);\n+            }\n+\n+            InvocationArgumentConvention rightArgumentConvention = extractArgumentConvention(\n+                    typeJavaType,\n+                    parameterTypes.subList(leftArgumentConvention.getParameterCount(), parameterTypes.size()),\n+                    parameterAnnotations.subList(leftArgumentConvention.getParameterCount(), parameterTypes.size()),\n+                    operatorType,\n+                    method);\n+\n+            checkArgument(leftArgumentConvention.getParameterCount() + rightArgumentConvention.getParameterCount() == parameterTypes.size(),\n+                    \"Unexpected parameters for %s operator: %s\", operatorType, method);\n+\n+            return simpleConvention(returnConvention, leftArgumentConvention, rightArgumentConvention);\n+        }\n+\n+        private static boolean isAnnotationPresent(Annotation[] annotations, Class<? extends Annotation> annotationType)\n+        {\n+            return Arrays.stream(annotations).anyMatch(annotationType::isInstance);\n+        }\n+\n+        private static InvocationReturnConvention getReturnConvention(Class<?> expectedReturnType, OperatorType operatorType, Method method)\n+        {\n+            InvocationReturnConvention returnConvention;\n+            if (!method.isAnnotationPresent(SqlNullable.class) && method.getReturnType().equals(expectedReturnType)) {\n+                returnConvention = FAIL_ON_NULL;\n+            }\n+            else if (method.isAnnotationPresent(SqlNullable.class) && method.getReturnType().equals(wrap(expectedReturnType))) {\n+                returnConvention = NULLABLE_RETURN;\n+            }\n+            else {\n+                throw new IllegalArgumentException(format(\"Expected %s operator to return %s: %s\", operatorType, expectedReturnType, method));\n+            }\n+            return returnConvention;\n+        }\n+\n+        private static InvocationArgumentConvention extractArgumentConvention(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4NzY1OA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487287658", "bodyText": "Since this class is used in a global injection point that lives for the duration of the server, do we want to limit the size of the cache to avoid a slow memory leak? At a minimum, we may want to expose the size via JMX so it can be observed externally.", "author": "martint", "createdAt": "2020-09-11T20:58:47Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TypeOperators.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention;\n+import io.prestosql.spi.function.OperatorMethodHandle;\n+import io.prestosql.spi.function.OperatorType;\n+import io.prestosql.spi.function.ScalarFunctionAdapter;\n+import io.prestosql.spi.function.ScalarFunctionAdapter.NullAdaptationPolicy;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringJoiner;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static io.prestosql.spi.StandardErrorCode.FUNCTION_NOT_FOUND;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NULL_FLAG;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.function.InvocationConvention.simpleConvention;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.filterReturnValue;\n+import static java.lang.invoke.MethodHandles.guardWithTest;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class TypeOperators\n+{\n+    private final ScalarFunctionAdapter functionAdapter = new ScalarFunctionAdapter(NullAdaptationPolicy.UNSUPPORTED);\n+    private final ConcurrentMap<OperatorConvention, OperatorAdaptor> cache = new ConcurrentHashMap<>();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI5MTU3NQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487291575", "bodyText": "This is not ideal. When would this method see those instances of GenericXXX?", "author": "martint", "createdAt": "2020-09-11T21:08:33Z", "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionRegistry.java", "diffHunk": "@@ -775,6 +722,23 @@ public FunctionRegistry(Supplier<BlockEncodingSerde> blockEncodingSerdeSupplier,\n     public final synchronized void addFunctions(List<? extends SqlFunction> functions)\n     {\n         for (SqlFunction function : functions) {\n+            String name = function.getFunctionMetadata().getSignature().getName();\n+            if (isOperatorName(name) && !(function instanceof GenericEqualOperator) &&\n+                    !(function instanceof GenericNotEqualOperator) &&\n+                    !(function instanceof GenericHashCodeOperator) &&\n+                    !(function instanceof GenericXxHash64Operator) &&\n+                    !(function instanceof GenericDistinctFromOperator) &&\n+                    !(function instanceof GenericIndeterminateOperator)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTg5Mg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r489081892", "bodyText": "All \"added\" functions go through this verification.  This gets cleaned up later, but for now it is the easiest technique to say \"these must be supplied by the type itself\"", "author": "dain", "createdAt": "2020-09-15T23:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI5MTU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI5ODE1Nw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487298157", "bodyText": "What does nanRepresentation mean in this context? Isn't the argument just the long representation of a float?", "author": "martint", "createdAt": "2020-09-11T21:26:38Z", "path": "presto-main/src/test/java/io/prestosql/type/TestRealOperators.java", "diffHunk": "@@ -303,24 +308,40 @@ public void testIndeterminate()\n \n     @Test\n     public void testNanHash()\n+            throws Throwable\n     {\n         int[] nanRepresentations = {floatToIntBits(Float.NaN), 0xffc00000, 0x7fc00000, 0x7fc01234, 0xffc01234};\n         for (int nanRepresentation : nanRepresentations) {\n             assertTrue(isNaN(intBitsToFloat(nanRepresentation)));\n-            assertEquals(RealOperators.hashCode(nanRepresentation), RealOperators.hashCode(nanRepresentations[0]));\n-            assertEquals(RealOperators.xxHash64(nanRepresentation), RealOperators.xxHash64(nanRepresentations[0]));\n+            assertEquals(executeHashOperator(nanRepresentation), executeHashOperator(nanRepresentations[0]));\n+            assertEquals(executeXxHas64hOperator(nanRepresentation), executeXxHas64hOperator(nanRepresentations[0]));\n         }\n     }\n \n     @Test\n     public void testZeroHash()\n+            throws Throwable\n     {\n         int[] zeroes = {floatToIntBits(0.0f), floatToIntBits(-0.0f)};\n         for (int zero : zeroes) {\n             //noinspection SimplifiedTestNGAssertion\n             assertTrue(intBitsToFloat(zero) == 0f);\n-            assertEquals(RealOperators.hashCode(zero), RealOperators.hashCode(zeroes[0]));\n-            assertEquals(RealOperators.xxHash64(zero), RealOperators.xxHash64(zeroes[0]));\n+            assertEquals(executeHashOperator(zero), executeHashOperator(zeroes[0]));\n+            assertEquals(executeXxHas64hOperator(zero), executeXxHas64hOperator(zeroes[0]));\n         }\n     }\n+\n+    private long executeHashOperator(long nanRepresentation)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2MzI0MQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r496363241", "bodyText": "It is an artifact of the method extraction. I renamed it to value", "author": "dain", "createdAt": "2020-09-29T03:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI5ODE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMzY3MA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487313670", "bodyText": "Did this move from somewhere else or is it new code?", "author": "martint", "createdAt": "2020-09-11T22:13:46Z", "path": "presto-spi/src/main/java/io/prestosql/spi/block/SingleMapBlock.java", "diffHunk": "@@ -168,7 +169,51 @@ public int seekKey(Object nativeValue)\n             Boolean match;\n             try {\n                 // assuming maps with indeterminate keys are not supported\n-                match = (Boolean) mapBlock.getMapType().getKeyBlockNativeEquals().invoke(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n+                match = (Boolean) mapBlock.getMapType().getKeyBlockNativeEqual().invoke(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n+            }\n+            catch (Throwable throwable) {\n+                throw handleThrowable(throwable);\n+            }\n+            checkNotIndeterminate(match);\n+            if (match) {\n+                return keyPosition * 2 + 1;\n+            }\n+            position++;\n+            if (position == hashTableSize) {\n+                position = 0;\n+            }\n+        }\n+    }\n+\n+    public int seekKey(MethodHandle keyEqualOperator, MethodHandle keyHashOperator, Block targetKeyBlock, int targetKeyPosition)\n+    {\n+        if (positionCount == 0) {\n+            return -1;\n+        }\n+\n+        mapBlock.ensureHashTableLoaded();\n+        int[] hashTable = mapBlock.getHashTables().get();\n+\n+        long hashCode;\n+        try {\n+            hashCode = (long) keyHashOperator.invoke(targetKeyBlock, targetKeyPosition);\n+        }\n+        catch (Throwable throwable) {\n+            throw handleThrowable(throwable);\n+        }\n+\n+        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n+        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n+        int position = computePosition(hashCode, hashTableSize);\n+        while (true) {\n+            int keyPosition = hashTable[hashTableOffset + position];\n+            if (keyPosition == -1) {\n+                return -1;\n+            }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MjU0Mw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r489082543", "bodyText": "The class contains several specialized versions of these methods... this is a new version.", "author": "dain", "createdAt": "2020-09-15T23:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMzY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMzk0Ng==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487313946", "bodyText": "Needs to be volatile", "author": "martint", "createdAt": "2020-09-11T22:14:40Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/ArrayType.java", "diffHunk": "@@ -20,29 +20,140 @@\n import io.prestosql.spi.block.BlockBuilder;\n import io.prestosql.spi.block.BlockBuilderStatus;\n import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.OperatorMethodHandle;\n \n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NULL_FLAG;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.function.InvocationConvention.simpleConvention;\n import static io.prestosql.spi.type.StandardTypes.ARRAY;\n+import static io.prestosql.spi.type.TypeUtils.NULL_HASH_CODE;\n import static io.prestosql.spi.type.TypeUtils.checkElementNotNull;\n import static io.prestosql.spi.type.TypeUtils.hashPosition;\n+import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n import static java.util.Objects.requireNonNull;\n \n public class ArrayType\n         extends AbstractType\n {\n-    private final Type elementType;\n+    private static final InvocationConvention EQUAL_CONVENTION = simpleConvention(NULLABLE_RETURN, NEVER_NULL, NEVER_NULL);\n+    private static final InvocationConvention HASH_CODE_CONVENTION = simpleConvention(FAIL_ON_NULL, NEVER_NULL);\n+    private static final InvocationConvention DISTINCT_FROM_CONVENTION = simpleConvention(FAIL_ON_NULL, BOXED_NULLABLE, BOXED_NULLABLE);\n+    private static final InvocationConvention INDETERMINATE_CONVENTION = simpleConvention(FAIL_ON_NULL, NULL_FLAG);\n+\n+    private static final MethodHandle EQUAL;\n+    private static final MethodHandle HASH_CODE;\n+    private static final MethodHandle DISTINCT_FROM;\n+    private static final MethodHandle INDETERMINATE;\n+\n+    static {\n+        try {\n+            Lookup lookup = MethodHandles.lookup();\n+            EQUAL = lookup.findStatic(ArrayType.class, \"equalOperator\", MethodType.methodType(Boolean.class, MethodHandle.class, Block.class, Block.class));\n+            HASH_CODE = lookup.findStatic(ArrayType.class, \"hashOperator\", MethodType.methodType(long.class, MethodHandle.class, Block.class));\n+            DISTINCT_FROM = lookup.findStatic(ArrayType.class, \"distinctFromOperator\", MethodType.methodType(boolean.class, MethodHandle.class, Block.class, Block.class));\n+            INDETERMINATE = lookup.findStatic(ArrayType.class, \"indeterminateOperator\", MethodType.methodType(boolean.class, MethodHandle.class, Block.class, boolean.class));\n+        }\n+        catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n     public static final String ARRAY_NULL_ELEMENT_MSG = \"ARRAY comparison not supported for arrays with null elements\";\n \n+    private final Type elementType;\n+\n+    // this field is used in double checked locking\n+    @SuppressWarnings(\"FieldAccessedSynchronizedAndUnsynchronized\")\n+    private TypeOperatorDeclaration operatorDeclaration;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDU1Mg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487314552", "bodyText": "Needs to be volatile", "author": "martint", "createdAt": "2020-09-11T22:16:56Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/RowType.java", "diffHunk": "@@ -20,25 +20,89 @@\n import io.prestosql.spi.block.BlockBuilderStatus;\n import io.prestosql.spi.block.RowBlockBuilder;\n import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.OperatorMethodHandle;\n \n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles.Lookup;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n \n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BOXED_NULLABLE;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.function.InvocationConvention.simpleConvention;\n import static io.prestosql.spi.type.StandardTypes.ROW;\n+import static io.prestosql.spi.type.TypeUtils.NULL_HASH_CODE;\n+import static java.lang.Boolean.FALSE;\n+import static java.lang.Boolean.TRUE;\n+import static java.lang.invoke.MethodHandles.collectArguments;\n+import static java.lang.invoke.MethodHandles.constant;\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodHandles.permuteArguments;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n \n /**\n  * As defined in ISO/IEC FCD 9075-2 (SQL 2011), section 4.8\n  */\n public class RowType\n         extends AbstractType\n {\n+    private static final InvocationConvention EQUAL_CONVENTION = simpleConvention(NULLABLE_RETURN, NEVER_NULL, NEVER_NULL);\n+    private static final InvocationConvention HASH_CODE_CONVENTION = simpleConvention(FAIL_ON_NULL, NEVER_NULL);\n+    private static final InvocationConvention DISTINCT_FROM_CONVENTION = simpleConvention(FAIL_ON_NULL, BOXED_NULLABLE, BOXED_NULLABLE);\n+    private static final InvocationConvention INDETERMINATE_CONVENTION = simpleConvention(FAIL_ON_NULL, BOXED_NULLABLE);\n+\n+    private static final MethodHandle EQUAL;\n+    private static final MethodHandle CHAIN_EQUAL;\n+    private static final MethodHandle HASH_CODE;\n+    private static final MethodHandle CHAIN_HASH_CODE;\n+    private static final MethodHandle DISTINCT_FROM;\n+    private static final MethodHandle CHAIN_DISTINCT_FROM_START;\n+    private static final MethodHandle CHAIN_DISTINCT_FROM;\n+    private static final MethodHandle INDETERMINATE;\n+    private static final MethodHandle CHAIN_INDETERMINATE;\n+    private static final int MEGAMORPHIC_FIELD_COUNT = 64;\n+\n+    // this field is used in double checked locking\n+    @SuppressWarnings(\"FieldAccessedSynchronizedAndUnsynchronized\")\n+    private TypeOperatorDeclaration typeOperatorDeclaration;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNjA5NA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r487316094", "bodyText": "What caused this change?", "author": "martint", "createdAt": "2020-09-11T22:22:39Z", "path": "presto-testing/src/main/java/io/prestosql/testing/AbstractTestAggregations.java", "diffHunk": "@@ -738,8 +738,8 @@ public void testApproximateCountDistinct()\n         assertQuery(\"SELECT approx_distinct(CAST(custkey AS DECIMAL(18, 0)), 0.023) FROM orders\", \"SELECT 990\");\n \n         // test long decimal\n-        assertQuery(\"SELECT approx_distinct(CAST(custkey AS DECIMAL(25, 20))) FROM orders\", \"SELECT 1013\");\n-        assertQuery(\"SELECT approx_distinct(CAST(custkey AS DECIMAL(25, 20)), 0.023) FROM orders\", \"SELECT 1013\");\n+        assertQuery(\"SELECT approx_distinct(CAST(custkey AS DECIMAL(25, 20))) FROM orders\", \"SELECT 988\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5NTg0Nw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r488295847", "bodyText": "xxhash implementation changed", "author": "dain", "createdAt": "2020-09-14T23:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNjA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzkwMg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490463902", "bodyText": "Depending on where this class (BlockTypeOperators) is being used, we may want to 1) limit the cache size to avoid memory leaks, 2) expose the size via JMX for visibility (similar to earlier comment about TypeOperators)", "author": "martint", "createdAt": "2020-09-17T18:18:38Z", "path": "presto-main/src/main/java/io/prestosql/type/BlockTypeOperators.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.type;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.inject.Inject;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.Supplier;\n+\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.NULLABLE_RETURN;\n+import static io.prestosql.spi.function.InvocationConvention.simpleConvention;\n+import static io.prestosql.type.SingleAccessMethodCompiler.compileSingleAccessMethod;\n+import static io.prestosql.type.TypeUtils.NULL_HASH_CODE;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class BlockTypeOperators\n+{\n+    private static final InvocationConvention BLOCK_EQUAL_CONVENTION = simpleConvention(NULLABLE_RETURN, BLOCK_POSITION, BLOCK_POSITION);\n+    private static final InvocationConvention HASH_CODE_CONVENTION = simpleConvention(FAIL_ON_NULL, BLOCK_POSITION);\n+    private static final InvocationConvention XX_HASH_64_CONVENTION = simpleConvention(FAIL_ON_NULL, BLOCK_POSITION);\n+    private static final InvocationConvention IS_DISTINCT_FROM_CONVENTION = simpleConvention(FAIL_ON_NULL, BLOCK_POSITION, BLOCK_POSITION);\n+\n+    private final ConcurrentMap<GeneratedBlockOperatorKey<?>, GeneratedBlockOperator<?>> generatedBlockOperatorCache = new ConcurrentHashMap<>();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzI1OQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490467259", "bodyText": "We may need to use DynamicClassLoader here. If I recall correctly, we used to have problems with classes not being unloaded unless we did that.", "author": "martint", "createdAt": "2020-09-17T18:24:45Z", "path": "presto-main/src/main/java/io/prestosql/type/SingleAccessMethodCompiler.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.type;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.bytecode.ClassDefinition;\n+import io.airlift.bytecode.MethodDefinition;\n+import io.airlift.bytecode.expression.BytecodeExpression;\n+import io.prestosql.sql.gen.CallSiteBinder;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.airlift.bytecode.Access.FINAL;\n+import static io.airlift.bytecode.Access.PUBLIC;\n+import static io.airlift.bytecode.Access.SYNTHETIC;\n+import static io.airlift.bytecode.Access.a;\n+import static io.airlift.bytecode.Parameter.arg;\n+import static io.airlift.bytecode.ParameterizedType.type;\n+import static io.airlift.bytecode.expression.BytecodeExpressions.invokeDynamic;\n+import static io.prestosql.sql.gen.Bootstrap.BOOTSTRAP_METHOD;\n+import static io.prestosql.util.CompilerUtils.defineClass;\n+import static io.prestosql.util.CompilerUtils.makeClassName;\n+import static java.lang.invoke.MethodType.methodType;\n+\n+final class SingleAccessMethodCompiler\n+{\n+    private SingleAccessMethodCompiler() {}\n+\n+    // Note: this currently only handles interfaces, and has no mechanism to declare generic types.\n+    public static <T> T compileSingleAccessMethod(String suggestedClassName, Class<T> interfaceType, MethodHandle methodHandle)\n+    {\n+        ClassDefinition classDefinition = new ClassDefinition(\n+                a(PUBLIC, FINAL, SYNTHETIC),\n+                makeClassName(suggestedClassName),\n+                type(Object.class),\n+                type(interfaceType));\n+\n+        classDefinition.declareDefaultConstructor(a(PUBLIC));\n+\n+        Method method = getSingleAbstractMethod(interfaceType);\n+        Class<?>[] parameterTypes = method.getParameterTypes();\n+        MethodHandle adaptedMethodHandle = methodHandle.asType(methodType(method.getReturnType(), parameterTypes));\n+\n+        List<io.airlift.bytecode.Parameter> parameters = new ArrayList<>();\n+        for (int i = 0; i < parameterTypes.length; i++) {\n+            parameters.add(arg(\"arg\" + i, parameterTypes[i]));\n+        }\n+\n+        MethodDefinition methodDefinition = classDefinition.declareMethod(\n+                a(PUBLIC),\n+                method.getName(),\n+                type(method.getReturnType()),\n+                parameters);\n+\n+        CallSiteBinder callSiteBinder = new CallSiteBinder();\n+        BytecodeExpression invocation = invokeDynamic(\n+                BOOTSTRAP_METHOD,\n+                ImmutableList.of(callSiteBinder.bind(adaptedMethodHandle).getBindingId()),\n+                method.getName(),\n+                method.getReturnType(),\n+                parameters);\n+        if (method.getReturnType() != void.class) {\n+            invocation = invocation.ret();\n+        }\n+        methodDefinition.getBody().append(invocation);\n+        // note this will not work if interface class is not visible from this class loader,\n+        // but we must use this class loader to ensure the bootstrap method is visible\n+        ClassLoader classLoader = SingleAccessMethodCompiler.class.getClassLoader();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2NjIzNA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r496366234", "bodyText": "The defineClass call below wrappers classLoader in a DynamicClassLoader", "author": "dain", "createdAt": "2020-09-29T04:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NDk1Nw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490474957", "bodyText": "I can't find why this had to change in this commit.", "author": "martint", "createdAt": "2020-09-17T18:38:47Z", "path": "presto-main/src/main/java/io/prestosql/operator/annotations/ScalarImplementationDependency.java", "diffHunk": "@@ -27,10 +28,12 @@\n         implements ImplementationDependency\n {\n     private final Optional<InvocationConvention> invocationConvention;\n+    private final Class<?> type;\n \n-    protected ScalarImplementationDependency(Optional<InvocationConvention> invocationConvention)\n+    protected ScalarImplementationDependency(Optional<InvocationConvention> invocationConvention, Class<?> type)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5OTYwNA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r497199604", "bodyText": "The core of TypedSet changed, and 99% of this commit is just feeding into those few lines of code.", "author": "dain", "createdAt": "2020-09-30T01:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ3NDk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MDMxMw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490480313", "bodyText": "Is this a change from the weaker hash to xxhash64? If so, we may want to do that in a separate PR/commit.", "author": "martint", "createdAt": "2020-09-17T18:48:20Z", "path": "presto-main/src/test/java/io/prestosql/operator/aggregation/TestChecksumAggregation.java", "diffHunk": "@@ -116,13 +119,14 @@ public void testArray()\n \n     private static SqlVarbinary expectedChecksum(Type type, Block block)\n     {\n+        BlockPositionXxHash64 xxHash64Operator = blockTypeOperators.getXxHash64Operator(type);\n         long result = 0;\n         for (int i = 0; i < block.getPositionCount(); i++) {\n             if (block.isNull(i)) {\n                 result += PRIME64;\n             }\n             else {\n-                result += type.hash(block, i) * PRIME64;\n+                result += xxHash64Operator.xxHash64(block, i) * PRIME64;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MjEyNg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490482126", "bodyText": "Boolean.TRUE.equals(result), as there's no guarantee that result is the same instance as Boolean.TRUE.", "author": "martint", "createdAt": "2020-09-17T18:51:45Z", "path": "presto-spi/src/main/java/io/prestosql/spi/predicate/EquatableValueSet.java", "diffHunk": "@@ -428,8 +444,18 @@ public boolean equals(Object obj)\n                 return false;\n             }\n             ValueEntry other = (ValueEntry) obj;\n-            return Objects.equals(this.type, other.type)\n-                    && type.equalTo(this.block, 0, other.block, 0);\n+            if (!Objects.equals(this.type, other.type)) {\n+                return false;\n+            }\n+\n+            Boolean result;\n+            try {\n+                result = (Boolean) equalOperator.invokeExact(this.block, 0, other.block, 0);\n+            }\n+            catch (Throwable throwable) {\n+                throw handleThrowable(throwable);\n+            }\n+            return result == Boolean.TRUE;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4MjQ5MA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490482490", "bodyText": "Boolean.TRUE.equals(...)", "author": "martint", "createdAt": "2020-09-17T18:52:25Z", "path": "presto-spi/src/main/java/io/prestosql/spi/predicate/Marker.java", "diffHunk": "@@ -286,7 +307,17 @@ public boolean equals(Object obj)\n         return Objects.equals(this.type, other.type)\n                 && this.bound == other.bound\n                 && ((this.valueBlock.isPresent()) == (other.valueBlock.isPresent()))\n-                && (this.valueBlock.isEmpty() || type.equalTo(this.valueBlock.get(), 0, other.valueBlock.get(), 0));\n+                && (this.valueBlock.isEmpty() || valueEqual(this.valueBlock.get(), other.valueBlock.get()));\n+    }\n+\n+    private boolean valueEqual(Block leftBlock, Block rightBlock)\n+    {\n+        try {\n+            return ((Boolean) equalOperator.invokeExact(leftBlock, 0, rightBlock, 0)) == Boolean.TRUE;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NDk1Nw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490484957", "bodyText": "Boolean.TRUE.equals(...)", "author": "martint", "createdAt": "2020-09-17T18:56:58Z", "path": "presto-spi/src/main/java/io/prestosql/spi/predicate/NullableValue.java", "diffHunk": "@@ -109,7 +140,17 @@ public boolean equals(Object obj)\n         NullableValue other = (NullableValue) obj;\n         return Objects.equals(this.type, other.type)\n                 && (this.value == null) == (other.value == null)\n-                && (this.value == null || type.equalTo(Utils.nativeValueToBlock(type, value), 0, Utils.nativeValueToBlock(other.type, other.value), 0));\n+                && (this.value == null || valueEquals(other.value));\n+    }\n+\n+    private boolean valueEquals(Object otherValue)\n+    {\n+        try {\n+            return ((Boolean) equalOperator.invokeExact(value, otherValue)) == Boolean.TRUE;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NjkwNg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490486906", "bodyText": "typo: millis?", "author": "martint", "createdAt": "2020-09-17T19:00:32Z", "path": "presto-orc/src/main/java/io/prestosql/orc/ValidationHash.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.orc;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.type.AbstractLongType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import static com.google.common.base.Throwables.throwIfUnchecked;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.type.StandardTypes.ARRAY;\n+import static io.prestosql.spi.type.StandardTypes.MAP;\n+import static io.prestosql.spi.type.StandardTypes.ROW;\n+import static io.prestosql.spi.type.TimestampType.TIMESTAMP;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.util.Objects.requireNonNull;\n+\n+class ValidationHash\n+{\n+    // This value is a large arbitrary prime\n+    private static final long NULL_HASH_CODE = 0x6e3efbd56c16a0cbL;\n+\n+    private static final MethodHandle MAP_HASH;\n+    private static final MethodHandle ARRAY_HASH;\n+    private static final MethodHandle ROW_HASH;\n+    private static final MethodHandle TIMESTAMP_HASH;\n+\n+    static {\n+        try {\n+            MAP_HASH = lookup().findStatic(\n+                    ValidationHash.class,\n+                    \"mapSkipNullKeysHash\",\n+                    MethodType.methodType(long.class, Type.class, ValidationHash.class, ValidationHash.class, Block.class, int.class));\n+            ARRAY_HASH = lookup().findStatic(\n+                    ValidationHash.class,\n+                    \"arrayHash\",\n+                    MethodType.methodType(long.class, Type.class, ValidationHash.class, Block.class, int.class));\n+            ROW_HASH = lookup().findStatic(\n+                    ValidationHash.class,\n+                    \"rowHash\",\n+                    MethodType.methodType(long.class, Type.class, ValidationHash[].class, Block.class, int.class));\n+            TIMESTAMP_HASH = lookup().findStatic(\n+                    ValidationHash.class,\n+                    \"timestampHash\",\n+                    MethodType.methodType(long.class, Block.class, int.class));\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    // This should really come from the environment, but there is not good way to get a value here\n+    private static final TypeOperators VALIDATION_TYPE_OPERATORS_CACHE = new TypeOperators();\n+\n+    public static ValidationHash createValidationHash(Type type)\n+    {\n+        requireNonNull(type, \"type is null\");\n+        if (type.getTypeSignature().getBase().equals(MAP)) {\n+            ValidationHash keyHash = createValidationHash(type.getTypeParameters().get(0));\n+            ValidationHash valueHash = createValidationHash(type.getTypeParameters().get(1));\n+            return new ValidationHash(MAP_HASH.bindTo(type).bindTo(keyHash).bindTo(valueHash));\n+        }\n+\n+        if (type.getTypeSignature().getBase().equals(ARRAY)) {\n+            ValidationHash elementHash = createValidationHash(type.getTypeParameters().get(0));\n+            return new ValidationHash(ARRAY_HASH.bindTo(type).bindTo(elementHash));\n+        }\n+\n+        if (type.getTypeSignature().getBase().equals(ROW)) {\n+            ValidationHash[] fieldHashes = type.getTypeParameters().stream()\n+                    .map(ValidationHash::createValidationHash)\n+                    .toArray(ValidationHash[]::new);\n+            return new ValidationHash(ROW_HASH.bindTo(type).bindTo(fieldHashes));\n+        }\n+\n+        if (type.getTypeSignature().getBase().equals(StandardTypes.TIMESTAMP)) {\n+            return new ValidationHash(TIMESTAMP_HASH);\n+        }\n+\n+        return new ValidationHash(VALIDATION_TYPE_OPERATORS_CACHE.getHashCodeOperator(type, InvocationConvention.simpleConvention(FAIL_ON_NULL, BLOCK_POSITION)));\n+    }\n+\n+    private final MethodHandle hashCodeOperator;\n+\n+    private ValidationHash(MethodHandle hashCodeOperator)\n+    {\n+        this.hashCodeOperator = requireNonNull(hashCodeOperator, \"hashCodeOperator is null\");\n+    }\n+\n+    public long hash(Block block, int position)\n+    {\n+        if (block.isNull(position)) {\n+            return NULL_HASH_CODE;\n+        }\n+        try {\n+            return (long) hashCodeOperator.invokeExact(block, position);\n+        }\n+        catch (Throwable throwable) {\n+            throwIfUnchecked(throwable);\n+            throw new RuntimeException(throwable);\n+        }\n+    }\n+\n+    private static long mapSkipNullKeysHash(Type type, ValidationHash keyHash, ValidationHash valueHash, Block block, int position)\n+    {\n+        Block mapBlock = (Block) type.getObject(block, position);\n+        long hash = 0;\n+        for (int i = 0; i < mapBlock.getPositionCount(); i += 2) {\n+            if (!mapBlock.isNull(i)) {\n+                hash += keyHash.hash(mapBlock, i) ^ valueHash.hash(mapBlock, i + 1);\n+            }\n+        }\n+        return hash;\n+    }\n+\n+    private static long arrayHash(Type type, ValidationHash elementHash, Block block, int position)\n+    {\n+        Block array = (Block) type.getObject(block, position);\n+        long hash = 0;\n+        for (int i = 0; i < array.getPositionCount(); i++) {\n+            hash = 31 * hash + elementHash.hash(array, i);\n+        }\n+        return hash;\n+    }\n+\n+    private static long rowHash(Type type, ValidationHash[] fieldHashes, Block block, int position)\n+    {\n+        Block row = (Block) type.getObject(block, position);\n+        long hash = 0;\n+        for (int i = 0; i < row.getPositionCount(); i++) {\n+            hash = 31 * hash + fieldHashes[i].hash(row, i);\n+        }\n+        return hash;\n+    }\n+\n+    private static long timestampHash(Block block, int position)\n+    {\n+        // A flaw in ORC encoding makes it impossible to represent timestamp\n+        // between 1969-12-31 23:59:59.000, exclusive, and 1970-01-01 00:00:00.000, exclusive.\n+        // Therefore, such data won't round trip. The data read back is expected to be 1 second later than the original value.\n+        long mills = TIMESTAMP.getLong(block, position);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4Nzk3OQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490487979", "bodyText": "Don't use the deprecated TIMESTAMP constant. Use TIMESTAMP_MILLIS instead.", "author": "martint", "createdAt": "2020-09-17T19:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4NjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyMjU4MA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490522580", "bodyText": "Is there a better place for this method? It's weird for this to be implemented in GenericGreaterThanOperator and be imported by GenericGreatedThanOrEqualOperator", "author": "martint", "createdAt": "2020-09-17T19:51:42Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/GenericGreaterThanOperator.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.primitives.Ints;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionInvoker;\n+import io.prestosql.metadata.SqlOperator;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention;\n+import io.prestosql.spi.function.OperatorType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.spi.type.TypeSignature;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.metadata.Signature.orderableTypeParameter;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+public class GenericGreaterThanOperator\n+        extends SqlOperator\n+{\n+    private final TypeOperators typeOperators;\n+\n+    public GenericGreaterThanOperator(TypeOperators typeOperators)\n+    {\n+        super(\n+                OperatorType.GREATER_THAN,\n+                ImmutableList.of(orderableTypeParameter(\"T\")),\n+                ImmutableList.of(),\n+                BOOLEAN.getTypeSignature(),\n+                ImmutableList.of(new TypeSignature(\"T\"), new TypeSignature(\"T\")),\n+                false);\n+        this.typeOperators = requireNonNull(typeOperators, \"typeOperators is null\");\n+    }\n+\n+    @Override\n+    protected ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+    {\n+        Type type = functionBinding.getTypeVariable(\"T\");\n+        return invocationConvention -> {\n+            MethodHandle methodHandle = reverseBinaryOperatorArgs(invocationConvention, convention -> typeOperators.getLessThanOperator(type, convention));\n+            return new FunctionInvoker(methodHandle, Optional.empty());\n+        };\n+    }\n+\n+    static MethodHandle reverseBinaryOperatorArgs(InvocationConvention invocationConvention, Function<InvocationConvention, MethodHandle> operatorLoader)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3MzEzNw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r500673137", "bodyText": "This class is removed in a later commit, and this keeps that removal more contained.", "author": "dain", "createdAt": "2020-10-07T00:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyMjU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyMzkwMw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490523903", "bodyText": "Shouldn't these be inherited from the provided invocationConvention? (i.e., invocationConvention.supportsSession(), etc)?", "author": "martint", "createdAt": "2020-09-17T19:53:16Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/GenericGreaterThanOperator.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.primitives.Ints;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionInvoker;\n+import io.prestosql.metadata.SqlOperator;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention;\n+import io.prestosql.spi.function.OperatorType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.spi.type.TypeSignature;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.metadata.Signature.orderableTypeParameter;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+public class GenericGreaterThanOperator\n+        extends SqlOperator\n+{\n+    private final TypeOperators typeOperators;\n+\n+    public GenericGreaterThanOperator(TypeOperators typeOperators)\n+    {\n+        super(\n+                OperatorType.GREATER_THAN,\n+                ImmutableList.of(orderableTypeParameter(\"T\")),\n+                ImmutableList.of(),\n+                BOOLEAN.getTypeSignature(),\n+                ImmutableList.of(new TypeSignature(\"T\"), new TypeSignature(\"T\")),\n+                false);\n+        this.typeOperators = requireNonNull(typeOperators, \"typeOperators is null\");\n+    }\n+\n+    @Override\n+    protected ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+    {\n+        Type type = functionBinding.getTypeVariable(\"T\");\n+        return invocationConvention -> {\n+            MethodHandle methodHandle = reverseBinaryOperatorArgs(invocationConvention, convention -> typeOperators.getLessThanOperator(type, convention));\n+            return new FunctionInvoker(methodHandle, Optional.empty());\n+        };\n+    }\n+\n+    static MethodHandle reverseBinaryOperatorArgs(InvocationConvention invocationConvention, Function<InvocationConvention, MethodHandle> operatorLoader)\n+    {\n+        checkArgument(invocationConvention.getArgumentConventions().size() == 2, \"Expected binary convention\");\n+\n+        InvocationConvention reverseArgConvention = new InvocationConvention(\n+                List.of(invocationConvention.getArgumentConvention(1), invocationConvention.getArgumentConvention(0)),\n+                invocationConvention.getReturnConvention(),\n+                false,\n+                false);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3MzE4OA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r500673188", "bodyText": "Same", "author": "dain", "createdAt": "2020-10-07T00:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyMzkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNDQ5NQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490524495", "bodyText": "Remove?", "author": "martint", "createdAt": "2020-09-17T19:54:20Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/GenericGreaterThanOperator.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.primitives.Ints;\n+import io.prestosql.metadata.FunctionBinding;\n+import io.prestosql.metadata.FunctionInvoker;\n+import io.prestosql.metadata.SqlOperator;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention;\n+import io.prestosql.spi.function.OperatorType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.spi.type.TypeSignature;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.metadata.Signature.orderableTypeParameter;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static java.lang.invoke.MethodType.methodType;\n+import static java.util.Objects.requireNonNull;\n+\n+public class GenericGreaterThanOperator\n+        extends SqlOperator\n+{\n+    private final TypeOperators typeOperators;\n+\n+    public GenericGreaterThanOperator(TypeOperators typeOperators)\n+    {\n+        super(\n+                OperatorType.GREATER_THAN,\n+                ImmutableList.of(orderableTypeParameter(\"T\")),\n+                ImmutableList.of(),\n+                BOOLEAN.getTypeSignature(),\n+                ImmutableList.of(new TypeSignature(\"T\"), new TypeSignature(\"T\")),\n+                false);\n+        this.typeOperators = requireNonNull(typeOperators, \"typeOperators is null\");\n+    }\n+\n+    @Override\n+    protected ScalarFunctionImplementation specialize(FunctionBinding functionBinding)\n+    {\n+        Type type = functionBinding.getTypeVariable(\"T\");\n+        return invocationConvention -> {\n+            MethodHandle methodHandle = reverseBinaryOperatorArgs(invocationConvention, convention -> typeOperators.getLessThanOperator(type, convention));\n+            return new FunctionInvoker(methodHandle, Optional.empty());\n+        };\n+    }\n+\n+    static MethodHandle reverseBinaryOperatorArgs(InvocationConvention invocationConvention, Function<InvocationConvention, MethodHandle> operatorLoader)\n+    {\n+        checkArgument(invocationConvention.getArgumentConventions().size() == 2, \"Expected binary convention\");\n+\n+        InvocationConvention reverseArgConvention = new InvocationConvention(\n+                List.of(invocationConvention.getArgumentConvention(1), invocationConvention.getArgumentConvention(0)),\n+                invocationConvention.getReturnConvention(),\n+                false,\n+                false);\n+\n+        MethodHandle methodHandle = operatorLoader.apply(reverseArgConvention);\n+\n+        // reverse the argument order\n+        InvocationArgumentConvention leftConvention = reverseArgConvention.getArgumentConvention(0);\n+        InvocationArgumentConvention rightConvention = reverseArgConvention.getArgumentConvention(1);\n+\n+        // reorder index\n+        List<Integer> reorderIndexes = new ArrayList<>();\n+        for (int i = 0; i < leftConvention.getParameterCount(); i++) {\n+            reorderIndexes.add(rightConvention.getParameterCount() + i);\n+        }\n+        for (int i = 0; i < rightConvention.getParameterCount(); i++) {\n+            reorderIndexes.add(i);\n+        }\n+\n+        // MethodHandles.permuteArguments(methodHandle, methodType(boolean.class, long.class, Block.class, int.class), 1, 2, 0)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3MzIyOA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r500673228", "bodyText": "Same", "author": "dain", "createdAt": "2020-10-07T00:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNDQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNTcwOA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490525708", "bodyText": "Won't this become polymorphic?", "author": "martint", "createdAt": "2020-09-17T19:56:32Z", "path": "presto-main/src/main/java/io/prestosql/type/BlockTypeOperators.java", "diffHunk": "@@ -114,6 +116,56 @@ public BlockPositionIsDistinctFrom getDistinctFromOperator(Type type)\n         boolean isDistinctFrom(Block left, int leftPosition, Block right, int rightPosition);\n     }\n \n+    public BlockPositionComparison getComparisonOperator(Type type)\n+    {\n+        return getBlockOperator(type, BlockPositionComparison.class, () -> typeOperators.getComparisonOperator(type, COMPARISON_CONVENTION));\n+    }\n+\n+    public interface BlockPositionComparison\n+    {\n+        long compare(Block left, int leftPosition, Block right, int rightPosition);\n+\n+        default BlockPositionComparison reversed()\n+        {\n+            return ReversedBlockPositionComparison.createReversedBlockPositionComparison(this);\n+        }\n+    }\n+\n+    private static class ReversedBlockPositionComparison\n+            implements BlockPositionComparison\n+    {\n+        private final BlockPositionComparison comparison;\n+\n+        static BlockPositionComparison createReversedBlockPositionComparison(BlockPositionComparison comparison)\n+        {\n+            if (comparison instanceof ReversedBlockPositionComparison) {\n+                return ((ReversedBlockPositionComparison) comparison).comparison;\n+            }\n+            return new ReversedBlockPositionComparison(comparison);\n+        }\n+\n+        private ReversedBlockPositionComparison(BlockPositionComparison comparison)\n+        {\n+            this.comparison = comparison;\n+        }\n+\n+        @Override\n+        public long compare(Block leftBlock, int leftIndex, Block rightBlock, int rightIndex)\n+        {\n+            return comparison.compare(rightBlock, rightIndex, leftBlock, leftIndex);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwNjQ4MQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r497206481", "bodyText": "Added todo", "author": "dain", "createdAt": "2020-09-30T02:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNTcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzMDAzNQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490530035", "bodyText": "This seems like a (pre-existing) bug. If two arrays are equal to each other, then arrays_overlap should return true. Therefore, since array[] == array[] => arrays_overlap(array[], array[]) should return true.\nIt's especially confusing that arrays_overlap(x, x) might ever return false.", "author": "martint", "createdAt": "2020-09-17T20:04:50Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ArraysOverlapFunction.java", "diffHunk": "@@ -21,80 +21,93 @@\n import io.prestosql.spi.function.SqlNullable;\n import io.prestosql.spi.function.SqlType;\n import io.prestosql.spi.function.TypeParameter;\n-import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.function.TypeParameterSpecialization;\n import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.Type;\n import io.prestosql.type.BlockTypeOperators.BlockPositionComparison;\n-import it.unimi.dsi.fastutil.ints.AbstractIntComparator;\n import it.unimi.dsi.fastutil.ints.IntArrays;\n import it.unimi.dsi.fastutil.ints.IntComparator;\n-\n-import java.util.Arrays;\n+import it.unimi.dsi.fastutil.longs.LongArrays;\n \n import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n import static io.prestosql.spi.function.OperatorType.COMPARISON;\n-import static io.prestosql.spi.type.BigintType.BIGINT;\n-import static io.prestosql.spi.type.IntegerType.INTEGER;\n \n @ScalarFunction(\"arrays_overlap\")\n @Description(\"Returns true if arrays have common elements\")\n public final class ArraysOverlapFunction\n {\n-    private int[] leftPositions;\n-    private int[] rightPositions;\n+    private int[] leftPositions = new int[0];\n+    private int[] rightPositions = new int[0];\n \n-    private long[] leftLongArray;\n-    private long[] rightLongArray;\n+    private long[] leftLongArray = new long[0];\n+    private long[] rightLongArray = new long[0];\n \n     @TypeParameter(\"E\")\n     public ArraysOverlapFunction(@TypeParameter(\"E\") Type elementType) {}\n \n-    private static IntComparator intBlockCompare(BlockPositionComparison comparisonOperator, Block block)\n-    {\n-        return new AbstractIntComparator()\n-        {\n-            @Override\n-            public int compare(int left, int right)\n-            {\n-                if (block.isNull(left) && block.isNull(right)) {\n-                    return 0;\n-                }\n-                if (block.isNull(left)) {\n-                    return 1;\n-                }\n-                if (block.isNull(right)) {\n-                    return -1;\n-                }\n-                return (int) comparisonOperator.compare(block, left, block, right);\n-            }\n-        };\n-    }\n-\n     @SqlNullable\n+    @TypeParameter(\"E\")\n+    @TypeParameterSpecialization(name = \"E\", nativeContainerType = long.class)\n     @SqlType(StandardTypes.BOOLEAN)\n     public Boolean arraysOverlapInt(\n             @OperatorDependency(\n                     operator = COMPARISON,\n-                    argumentTypes = {\"integer\", \"integer\"},\n-                    convention = @Convention(arguments = {BLOCK_POSITION, BLOCK_POSITION}, result = FAIL_ON_NULL)) BlockPositionComparison comparisonOperator,\n-            @SqlType(\"array(integer)\") Block leftArray,\n-            @SqlType(\"array(integer)\") Block rightArray)\n+                    argumentTypes = {\"E\", \"E\"},\n+                    convention = @Convention(arguments = {NEVER_NULL, NEVER_NULL}, result = FAIL_ON_NULL)) LongComparison comparisonOperator,\n+            @TypeParameter(\"E\") Type type,\n+            @SqlType(\"array(E)\") Block leftArray,\n+            @SqlType(\"array(E)\") Block rightArray)\n     {\n-        return genericArraysOverlap(leftArray, rightArray, INTEGER);\n+        int leftSize = leftArray.getPositionCount();\n+        int rightSize = rightArray.getPositionCount();\n+\n+        if (leftSize == 0 || rightSize == 0) {\n+            return false;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxMDAzMQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r497210031", "bodyText": "This is how the function is documented. We can change this in another PR if we want.", "author": "dain", "createdAt": "2020-09-30T02:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzMDAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzMTM5NQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490531395", "bodyText": "Why * 2?", "author": "martint", "createdAt": "2020-09-17T20:07:23Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/ArraysOverlapFunction.java", "diffHunk": "@@ -21,80 +21,93 @@\n import io.prestosql.spi.function.SqlNullable;\n import io.prestosql.spi.function.SqlType;\n import io.prestosql.spi.function.TypeParameter;\n-import io.prestosql.spi.type.AbstractType;\n+import io.prestosql.spi.function.TypeParameterSpecialization;\n import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.Type;\n import io.prestosql.type.BlockTypeOperators.BlockPositionComparison;\n-import it.unimi.dsi.fastutil.ints.AbstractIntComparator;\n import it.unimi.dsi.fastutil.ints.IntArrays;\n import it.unimi.dsi.fastutil.ints.IntComparator;\n-\n-import java.util.Arrays;\n+import it.unimi.dsi.fastutil.longs.LongArrays;\n \n import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.BLOCK_POSITION;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n import static io.prestosql.spi.function.OperatorType.COMPARISON;\n-import static io.prestosql.spi.type.BigintType.BIGINT;\n-import static io.prestosql.spi.type.IntegerType.INTEGER;\n \n @ScalarFunction(\"arrays_overlap\")\n @Description(\"Returns true if arrays have common elements\")\n public final class ArraysOverlapFunction\n {\n-    private int[] leftPositions;\n-    private int[] rightPositions;\n+    private int[] leftPositions = new int[0];\n+    private int[] rightPositions = new int[0];\n \n-    private long[] leftLongArray;\n-    private long[] rightLongArray;\n+    private long[] leftLongArray = new long[0];\n+    private long[] rightLongArray = new long[0];\n \n     @TypeParameter(\"E\")\n     public ArraysOverlapFunction(@TypeParameter(\"E\") Type elementType) {}\n \n-    private static IntComparator intBlockCompare(BlockPositionComparison comparisonOperator, Block block)\n-    {\n-        return new AbstractIntComparator()\n-        {\n-            @Override\n-            public int compare(int left, int right)\n-            {\n-                if (block.isNull(left) && block.isNull(right)) {\n-                    return 0;\n-                }\n-                if (block.isNull(left)) {\n-                    return 1;\n-                }\n-                if (block.isNull(right)) {\n-                    return -1;\n-                }\n-                return (int) comparisonOperator.compare(block, left, block, right);\n-            }\n-        };\n-    }\n-\n     @SqlNullable\n+    @TypeParameter(\"E\")\n+    @TypeParameterSpecialization(name = \"E\", nativeContainerType = long.class)\n     @SqlType(StandardTypes.BOOLEAN)\n     public Boolean arraysOverlapInt(\n             @OperatorDependency(\n                     operator = COMPARISON,\n-                    argumentTypes = {\"integer\", \"integer\"},\n-                    convention = @Convention(arguments = {BLOCK_POSITION, BLOCK_POSITION}, result = FAIL_ON_NULL)) BlockPositionComparison comparisonOperator,\n-            @SqlType(\"array(integer)\") Block leftArray,\n-            @SqlType(\"array(integer)\") Block rightArray)\n+                    argumentTypes = {\"E\", \"E\"},\n+                    convention = @Convention(arguments = {NEVER_NULL, NEVER_NULL}, result = FAIL_ON_NULL)) LongComparison comparisonOperator,\n+            @TypeParameter(\"E\") Type type,\n+            @SqlType(\"array(E)\") Block leftArray,\n+            @SqlType(\"array(E)\") Block rightArray)\n     {\n-        return genericArraysOverlap(leftArray, rightArray, INTEGER);\n+        int leftSize = leftArray.getPositionCount();\n+        int rightSize = rightArray.getPositionCount();\n+\n+        if (leftSize == 0 || rightSize == 0) {\n+            return false;\n+        }\n+\n+        if (leftLongArray.length < leftSize) {\n+            leftLongArray = new long[leftSize * 2];", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIwNzA0Mw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r497207043", "bodyText": "This is from the existing code.  The array is reused across invocations of this method, so it allocates extra space to accommodate larger arrays in future calls.", "author": "dain", "createdAt": "2020-09-30T02:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzMTM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0MTc3Ng==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490541776", "bodyText": "This is not a visitor method, so let's call it something different such as \"processIsDistinctFrom\" or \"evaluateIsDistinctFrom\".", "author": "martint", "createdAt": "2020-09-17T20:27:10Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ExpressionInterpreter.java", "diffHunk": "@@ -726,41 +727,93 @@ protected Object visitArithmeticBinary(ArithmeticBinaryExpression node, Object c\n         protected Object visitComparisonExpression(ComparisonExpression node, Object context)\n         {\n             ComparisonExpression.Operator operator = node.getOperator();\n+            Expression left = node.getLeft();\n+            Expression right = node.getRight();\n+\n+            if (operator == Operator.IS_DISTINCT_FROM) {\n+                return visitIsDistinctFrom(context, left, right);\n+            }\n+            // Execution engine does not have not equal and greater than operators, so interpret with\n+            // equal or less than, but do not flip operator in result, as many optimizers depend on\n+            // operators not flipping\n+            if (node.getOperator() == Operator.NOT_EQUAL) {\n+                Object result = visitComparisonExpression(flipComparison(node), context);\n+                if (result == null) {\n+                    return null;\n+                }\n+                if (result instanceof ComparisonExpression) {\n+                    return flipComparison((ComparisonExpression) result);\n+                }\n+                return !(Boolean) result;\n+            }\n+            if (node.getOperator() == Operator.GREATER_THAN || node.getOperator() == Operator.GREATER_THAN_OR_EQUAL) {\n+                Object result = visitComparisonExpression(flipComparison(node), context);\n+                if (result instanceof ComparisonExpression) {\n+                    return flipComparison((ComparisonExpression) result);\n+                }\n+                return result;\n+            }\n \n-            if (operator == ComparisonExpression.Operator.IS_DISTINCT_FROM) {\n-                Object left = process(node.getLeft(), context);\n-                Object right = process(node.getRight(), context);\n+            return visitComparisonExpression(context, operator, left, right);\n+        }\n \n-                if (left == null && right instanceof Expression) {\n-                    return new IsNotNullPredicate((Expression) right);\n-                }\n+        private Object visitIsDistinctFrom(Object context, Expression leftExpression, Expression rightExpression)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0MTgzOA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490541838", "bodyText": "Same here.", "author": "martint", "createdAt": "2020-09-17T20:27:18Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ExpressionInterpreter.java", "diffHunk": "@@ -726,41 +727,93 @@ protected Object visitArithmeticBinary(ArithmeticBinaryExpression node, Object c\n         protected Object visitComparisonExpression(ComparisonExpression node, Object context)\n         {\n             ComparisonExpression.Operator operator = node.getOperator();\n+            Expression left = node.getLeft();\n+            Expression right = node.getRight();\n+\n+            if (operator == Operator.IS_DISTINCT_FROM) {\n+                return visitIsDistinctFrom(context, left, right);\n+            }\n+            // Execution engine does not have not equal and greater than operators, so interpret with\n+            // equal or less than, but do not flip operator in result, as many optimizers depend on\n+            // operators not flipping\n+            if (node.getOperator() == Operator.NOT_EQUAL) {\n+                Object result = visitComparisonExpression(flipComparison(node), context);\n+                if (result == null) {\n+                    return null;\n+                }\n+                if (result instanceof ComparisonExpression) {\n+                    return flipComparison((ComparisonExpression) result);\n+                }\n+                return !(Boolean) result;\n+            }\n+            if (node.getOperator() == Operator.GREATER_THAN || node.getOperator() == Operator.GREATER_THAN_OR_EQUAL) {\n+                Object result = visitComparisonExpression(flipComparison(node), context);\n+                if (result instanceof ComparisonExpression) {\n+                    return flipComparison((ComparisonExpression) result);\n+                }\n+                return result;\n+            }\n \n-            if (operator == ComparisonExpression.Operator.IS_DISTINCT_FROM) {\n-                Object left = process(node.getLeft(), context);\n-                Object right = process(node.getRight(), context);\n+            return visitComparisonExpression(context, operator, left, right);\n+        }\n \n-                if (left == null && right instanceof Expression) {\n-                    return new IsNotNullPredicate((Expression) right);\n-                }\n+        private Object visitIsDistinctFrom(Object context, Expression leftExpression, Expression rightExpression)\n+        {\n+            Object left = process(leftExpression, context);\n+            Object right = process(rightExpression, context);\n \n-                if (right == null && left instanceof Expression) {\n-                    return new IsNotNullPredicate((Expression) left);\n-                }\n+            if (left == null && right instanceof Expression) {\n+                return new IsNotNullPredicate((Expression) right);\n+            }\n \n-                if (left instanceof Expression || right instanceof Expression) {\n-                    return new ComparisonExpression(operator, toExpression(left, type(node.getLeft())), toExpression(right, type(node.getRight())));\n-                }\n+            if (right == null && left instanceof Expression) {\n+                return new IsNotNullPredicate((Expression) left);\n+            }\n \n-                return invokeOperator(OperatorType.valueOf(operator.name()), types(node.getLeft(), node.getRight()), Arrays.asList(left, right));\n+            if (left instanceof Expression || right instanceof Expression) {\n+                return new ComparisonExpression(Operator.IS_DISTINCT_FROM, toExpression(left, type(leftExpression)), toExpression(right, type(rightExpression)));\n             }\n \n-            Object left = process(node.getLeft(), context);\n+            return invokeOperator(OperatorType.valueOf(Operator.IS_DISTINCT_FROM.name()), types(leftExpression, rightExpression), Arrays.asList(left, right));\n+        }\n+\n+        private Object visitComparisonExpression(Object context, Operator operator, Expression leftExpression, Expression rightExpression)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0NzcyNQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490547725", "bodyText": "Argument on next line", "author": "martint", "createdAt": "2020-09-17T20:37:47Z", "path": "presto-main/src/main/java/io/prestosql/operator/TopNOperator.java", "diffHunk": "@@ -99,7 +105,7 @@ public AdapterWorkProcessorOperator createAdapterOperator(ProcessorContext proce\n                     sourceTypes,\n                     n,\n                     sortChannels,\n-                    sortOrders);\n+                    sortOrders, typeOperators);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0OTA5Ng==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490549096", "bodyText": "First argument on next line", "author": "martint", "createdAt": "2020-09-17T20:40:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/IndexJoinOptimizer.java", "diffHunk": "@@ -96,13 +99,19 @@ public PlanNode optimize(PlanNode plan, Session session, TypeProvider type, Symb\n         private final SymbolAllocator symbolAllocator;\n         private final PlanNodeIdAllocator idAllocator;\n         private final Metadata metadata;\n+        private final TypeOperators typeOperators;\n         private final Session session;\n \n-        private Rewriter(SymbolAllocator symbolAllocator, PlanNodeIdAllocator idAllocator, Metadata metadata, Session session)\n+        private Rewriter(SymbolAllocator symbolAllocator,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0OTE4OQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490549189", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:40:31Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/IndexJoinOptimizer.java", "diffHunk": "@@ -243,15 +254,21 @@ private static PlanNode createIndexJoinWithExpectedOutputs(List<Symbol> expected\n         private final SymbolAllocator symbolAllocator;\n         private final PlanNodeIdAllocator idAllocator;\n         private final Metadata metadata;\n+        private final TypeOperators typeOperators;\n         private final DomainTranslator domainTranslator;\n         private final Session session;\n \n-        private IndexSourceRewriter(SymbolAllocator symbolAllocator, PlanNodeIdAllocator idAllocator, Metadata metadata, Session session)\n+        private IndexSourceRewriter(SymbolAllocator symbolAllocator,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0OTM5NQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490549395", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:41:00Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PropertyDerivations.java", "diffHunk": "@@ -109,17 +110,29 @@\n {\n     private PropertyDerivations() {}\n \n-    public static ActualProperties derivePropertiesRecursively(PlanNode node, Metadata metadata, Session session, TypeProvider types, TypeAnalyzer typeAnalyzer)\n+    public static ActualProperties derivePropertiesRecursively(\n+            PlanNode node,\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            TypeProvider types,\n+            TypeAnalyzer typeAnalyzer)\n     {\n         List<ActualProperties> inputProperties = node.getSources().stream()\n-                .map(source -> derivePropertiesRecursively(source, metadata, session, types, typeAnalyzer))\n+                .map(source -> derivePropertiesRecursively(source, metadata, typeOperators, session, types, typeAnalyzer))\n                 .collect(toImmutableList());\n-        return deriveProperties(node, inputProperties, metadata, session, types, typeAnalyzer);\n+        return deriveProperties(node, inputProperties, metadata, typeOperators, session, types, typeAnalyzer);\n     }\n \n-    public static ActualProperties deriveProperties(PlanNode node, List<ActualProperties> inputProperties, Metadata metadata, Session session, TypeProvider types, TypeAnalyzer typeAnalyzer)\n+    public static ActualProperties deriveProperties(PlanNode node,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0OTQ2Ng==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490549466", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:41:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PropertyDerivations.java", "diffHunk": "@@ -134,22 +147,30 @@ public static ActualProperties deriveProperties(PlanNode node, List<ActualProper\n         return output;\n     }\n \n-    public static ActualProperties streamBackdoorDeriveProperties(PlanNode node, List<ActualProperties> inputProperties, Metadata metadata, Session session, TypeProvider types, TypeAnalyzer typeAnalyzer)\n+    public static ActualProperties streamBackdoorDeriveProperties(PlanNode node,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0OTU3MA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490549570", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:41:19Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/StreamPropertyDerivations.java", "diffHunk": "@@ -97,20 +98,38 @@\n {\n     private StreamPropertyDerivations() {}\n \n-    public static StreamProperties derivePropertiesRecursively(PlanNode node, Metadata metadata, Session session, TypeProvider types, TypeAnalyzer typeAnalyzer)\n+    public static StreamProperties derivePropertiesRecursively(PlanNode node,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0OTY2Mw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490549663", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:41:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/StreamPropertyDerivations.java", "diffHunk": "@@ -97,20 +98,38 @@\n {\n     private StreamPropertyDerivations() {}\n \n-    public static StreamProperties derivePropertiesRecursively(PlanNode node, Metadata metadata, Session session, TypeProvider types, TypeAnalyzer typeAnalyzer)\n+    public static StreamProperties derivePropertiesRecursively(PlanNode node,\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            TypeProvider types,\n+            TypeAnalyzer typeAnalyzer)\n     {\n         List<StreamProperties> inputProperties = node.getSources().stream()\n-                .map(source -> derivePropertiesRecursively(source, metadata, session, types, typeAnalyzer))\n+                .map(source -> derivePropertiesRecursively(source, metadata, typeOperators, session, types, typeAnalyzer))\n                 .collect(toImmutableList());\n-        return StreamPropertyDerivations.deriveProperties(node, inputProperties, metadata, session, types, typeAnalyzer);\n+        return deriveProperties(node, inputProperties, metadata, typeOperators, session, types, typeAnalyzer);\n     }\n \n-    public static StreamProperties deriveProperties(PlanNode node, StreamProperties inputProperties, Metadata metadata, Session session, TypeProvider types, TypeAnalyzer typeAnalyzer)\n+    public static StreamProperties deriveProperties(PlanNode node,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0OTg2NA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490549864", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:41:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/AllFunctionsResolved.java", "diffHunk": "@@ -35,7 +36,13 @@\n     private static final Visitor VISITOR = new Visitor();\n \n     @Override\n-    public void validate(PlanNode planNode, Session session, Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, WarningCollector warningCollector)\n+    public void validate(PlanNode planNode,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0OTkxNg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490549916", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:41:55Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/DynamicFiltersChecker.java", "diffHunk": "@@ -50,7 +51,13 @@\n         implements PlanSanityChecker.Checker\n {\n     @Override\n-    public void validate(PlanNode plan, Session session, Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, WarningCollector warningCollector)\n+    public void validate(PlanNode plan,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU0OTk2Nw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490549967", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:42:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/NoDuplicatePlanNodeIdsChecker.java", "diffHunk": "@@ -33,7 +34,13 @@\n         implements PlanSanityChecker.Checker\n {\n     @Override\n-    public void validate(PlanNode planNode, Session session, Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, WarningCollector warningCollector)\n+    public void validate(PlanNode planNode,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU1MDAyNg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490550026", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:42:08Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/NoIdentifierLeftChecker.java", "diffHunk": "@@ -29,7 +30,13 @@\n         implements PlanSanityChecker.Checker\n {\n     @Override\n-    public void validate(PlanNode plan, Session session, Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, WarningCollector warningCollector)\n+    public void validate(PlanNode plan,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU1MDEwMg==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490550102", "bodyText": "First arg on next line", "author": "martint", "createdAt": "2020-09-17T20:42:17Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/NoSubqueryExpressionLeftChecker.java", "diffHunk": "@@ -30,7 +31,13 @@\n         implements PlanSanityChecker.Checker\n {\n     @Override\n-    public void validate(PlanNode plan, Session session, Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, WarningCollector warningCollector)\n+    public void validate(PlanNode plan,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU1MTA0NQ==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r490551045", "bodyText": "What's this for?", "author": "martint", "createdAt": "2020-09-17T20:44:10Z", "path": "presto-main/src/main/java/io/prestosql/type/BlockTypeOperators.java", "diffHunk": "@@ -179,11 +197,13 @@ public BlockPositionLessThan generateBlockPositionLessThan(Type type)\n     {\n         private final Type type;\n         private final Class<T> operatorInterface;\n+        private final Optional<Object> additionalKey;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM5MTAzMA==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r496391030", "bodyText": "It is used to for sort order in the ordering operator above", "author": "dain", "createdAt": "2020-09-29T04:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU1MTA0NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE5OTI5Mw==", "url": "https://github.com/trinodb/trino/pull/4647#discussion_r497199293", "bodyText": "@martint This is the stuff that changed", "author": "dain", "createdAt": "2020-09-30T01:52:14Z", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/TypedSet.java", "diffHunk": "@@ -157,14 +223,14 @@ public int positionOf(Block block, int position)\n      */\n     private int getHashPositionOfElement(Block block, int position)\n     {\n-        int hashPosition = getMaskedHash(hashPosition(elementType, block, position));\n+        int hashPosition = getMaskedHash(elementHashCodeOperator.hashCodeNullSafe(block, position));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "a7e91f3b6974f32ae8daf750211e4836163d7117", "url": "https://github.com/trinodb/trino/commit/a7e91f3b6974f32ae8daf750211e4836163d7117", "message": "Remove fallback to interpreter for JoinCompiler", "committedDate": "2020-10-07T03:25:49Z", "type": "commit"}, {"oid": "c04708a870d990329c0945fbeba4c08b82fb39fb", "url": "https://github.com/trinodb/trino/commit/c04708a870d990329c0945fbeba4c08b82fb39fb", "message": "Remove HashTable from JsonUtil", "committedDate": "2020-10-07T03:29:16Z", "type": "commit"}, {"oid": "23bf56addc4e5bfa1cd1cdb07333ef617a38f7a6", "url": "https://github.com/trinodb/trino/commit/23bf56addc4e5bfa1cd1cdb07333ef617a38f7a6", "message": "Remove unused PagesHashStrategy positionEqualsRow method", "committedDate": "2020-10-07T03:29:16Z", "type": "commit"}, {"oid": "e57fbd078a71fd3ed10ae9fdb7b899445b370887", "url": "https://github.com/trinodb/trino/commit/e57fbd078a71fd3ed10ae9fdb7b899445b370887", "message": "Simplify lambda interface handling in FunctionInvoker\n\nMatch lambda interface handling to aggregation and window functions", "committedDate": "2020-10-07T03:29:16Z", "type": "commit"}, {"oid": "5c8e28c64badc4c8bb7cd79202a8b55af4268ef8", "url": "https://github.com/trinodb/trino/commit/5c8e28c64badc4c8bb7cd79202a8b55af4268ef8", "message": "Verify scalar function signature", "committedDate": "2020-10-07T03:29:16Z", "type": "commit"}, {"oid": "cab99e8944b44c8bd3b0099af2bc6c37a7843510", "url": "https://github.com/trinodb/trino/commit/cab99e8944b44c8bd3b0099af2bc6c37a7843510", "message": "Merge FunctionInvokerProvider into ScalarFunctionImplementation", "committedDate": "2020-10-07T03:29:16Z", "type": "commit"}, {"oid": "e4f2b2f341003bf79a804a80b3fe5edc38cac724", "url": "https://github.com/trinodb/trino/commit/e4f2b2f341003bf79a804a80b3fe5edc38cac724", "message": "Extract ScalarFunctionImplementation interface", "committedDate": "2020-10-07T03:29:16Z", "type": "commit"}, {"oid": "89b6279b02c527017c6197cf616f7d2768c71a87", "url": "https://github.com/trinodb/trino/commit/89b6279b02c527017c6197cf616f7d2768c71a87", "message": "Move ScalarFunctionAdapter to SPI", "committedDate": "2020-10-07T03:29:16Z", "type": "commit"}, {"oid": "beb8eba04e6553bc0e4908c78e800c5aa498ffae", "url": "https://github.com/trinodb/trino/commit/beb8eba04e6553bc0e4908c78e800c5aa498ffae", "message": "Add operator declaration to type", "committedDate": "2020-10-07T03:29:16Z", "type": "commit"}, {"oid": "59179e3919c9f853c79c021f524140f45b511b0a", "url": "https://github.com/trinodb/trino/commit/59179e3919c9f853c79c021f524140f45b511b0a", "message": "Move comparison operators to type", "committedDate": "2020-10-07T03:29:16Z", "type": "commit"}, {"oid": "3aad4a8d0a1f74014254ef649584729a9db43063", "url": "https://github.com/trinodb/trino/commit/3aad4a8d0a1f74014254ef649584729a9db43063", "message": "Remove unnecessary calls to resolve operator", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "06d190e2ee3ec681a49f16f9698978c1c037f099", "url": "https://github.com/trinodb/trino/commit/06d190e2ee3ec681a49f16f9698978c1c037f099", "message": "Add BlockTypeOperators", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "a2fe7061e251503f45979437988921bbbb2b4504", "url": "https://github.com/trinodb/trino/commit/a2fe7061e251503f45979437988921bbbb2b4504", "message": "Remove Type equalTo and hash uses in Histogram", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "fade4a55762da278dca5c3d6c7235874a55132fd", "url": "https://github.com/trinodb/trino/commit/fade4a55762da278dca5c3d6c7235874a55132fd", "message": "Remove Type equalTo and hash uses in TypedSet", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "0cb7c4641208e38c5f3c92833439fe2d1ef78f3e", "url": "https://github.com/trinodb/trino/commit/0cb7c4641208e38c5f3c92833439fe2d1ef78f3e", "message": "Remove Type equalTo and hash uses in map agg and union", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "0a074713ec6809c0db48a95615057737a72eef8b", "url": "https://github.com/trinodb/trino/commit/0a074713ec6809c0db48a95615057737a72eef8b", "message": "Remove Type equalTo and hash uses in DynamicTupleFilterFactory", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "c1fb13b8871a742e3a88de5a65b191e0d9bccfbc", "url": "https://github.com/trinodb/trino/commit/c1fb13b8871a742e3a88de5a65b191e0d9bccfbc", "message": "Remove Type equalTo and hash uses in IndexLoader", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "9ad995a031d1a3e6211cf581859496c8ca3e82ca", "url": "https://github.com/trinodb/trino/commit/9ad995a031d1a3e6211cf581859496c8ca3e82ca", "message": "Remove Type equalTo and hash uses in PagesIndex", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "bbb5ee37e5fb53308e048a666467fbc3bdcaf0b6", "url": "https://github.com/trinodb/trino/commit/bbb5ee37e5fb53308e048a666467fbc3bdcaf0b6", "message": "Remove Type equalTo and hash uses in group by hash", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "0c98584ef62584bd7a4d84d4908cad5ada63a375", "url": "https://github.com/trinodb/trino/commit/0c98584ef62584bd7a4d84d4908cad5ada63a375", "message": "Remove Type equalTo and hash uses in checksum function", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "7e204f0dc249852c855bf8f072b01c2cc5db3e26", "url": "https://github.com/trinodb/trino/commit/7e204f0dc249852c855bf8f072b01c2cc5db3e26", "message": "Change checksum function to use xxhash", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "d1bebddd13528f091c4004546be87c46bb9eedfe", "url": "https://github.com/trinodb/trino/commit/d1bebddd13528f091c4004546be87c46bb9eedfe", "message": "Remove Type equalTo and hash uses in tuple domain", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "533980fcd6dd76d24cdfdbd3bbd4301c1754899d", "url": "https://github.com/trinodb/trino/commit/533980fcd6dd76d24cdfdbd3bbd4301c1754899d", "message": "Remove Type equalTo and hash uses in black hole connector", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "bfec6ad00034bd3417648fa596a1d207cafe9649", "url": "https://github.com/trinodb/trino/commit/bfec6ad00034bd3417648fa596a1d207cafe9649", "message": "Remove Type equalTo and hash uses in Hive writers", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "dc42b2218a017ea3f7a6551313b944e59ec4de10", "url": "https://github.com/trinodb/trino/commit/dc42b2218a017ea3f7a6551313b944e59ec4de10", "message": "Remove Type equalTo and hash uses in JoinCompiler", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "dd0219195c92a4755159ab4354cd2f58b99dc67d", "url": "https://github.com/trinodb/trino/commit/dd0219195c92a4755159ab4354cd2f58b99dc67d", "message": "Remove Type equalTo and hash uses in tests", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "33cd11f32e8dbc9a9a1782f06e21270769f7eb70", "url": "https://github.com/trinodb/trino/commit/33cd11f32e8dbc9a9a1782f06e21270769f7eb70", "message": "Remove Type equalTo and hash methods", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "047adc5db4643b90199a7abd8171e8b9747006e1", "url": "https://github.com/trinodb/trino/commit/047adc5db4643b90199a7abd8171e8b9747006e1", "message": "Move inequality operators to type\n\nAdd comparison operator", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "12b743e90f51546362b255ddaf48275a95925c43", "url": "https://github.com/trinodb/trino/commit/12b743e90f51546362b255ddaf48275a95925c43", "message": "Cleanup ArraySortFunction", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "a5ca830ef54619cffbc3ba451eb6029aa906c331", "url": "https://github.com/trinodb/trino/commit/a5ca830ef54619cffbc3ba451eb6029aa906c331", "message": "Cleanup ArraysOverlapFunction", "committedDate": "2020-10-07T03:29:17Z", "type": "commit"}, {"oid": "646772f41c0cef5f88176b29e61ffb25dea97359", "url": "https://github.com/trinodb/trino/commit/646772f41c0cef5f88176b29e61ffb25dea97359", "message": "Remove Type compareTo with block and position", "committedDate": "2020-10-07T03:42:54Z", "type": "commit"}, {"oid": "7eab1e62a67c42be923ea75701dae45c0c8eaf73", "url": "https://github.com/trinodb/trino/commit/7eab1e62a67c42be923ea75701dae45c0c8eaf73", "message": "Switch min/max and greates/least to use comparison operator", "committedDate": "2020-10-07T03:42:55Z", "type": "commit"}, {"oid": "eb35d8c691e64cc772ad1601fe2bf0d0a925f954", "url": "https://github.com/trinodb/trino/commit/eb35d8c691e64cc772ad1601fe2bf0d0a925f954", "message": "Remove not equal and greater operators from execution", "committedDate": "2020-10-07T03:42:55Z", "type": "commit"}, {"oid": "ea423f2779740858ba3b73a289e2cedf0cd4f064", "url": "https://github.com/trinodb/trino/commit/ea423f2779740858ba3b73a289e2cedf0cd4f064", "message": "Add expiry to operators cache", "committedDate": "2020-10-07T03:42:55Z", "type": "commit"}, {"oid": "ea423f2779740858ba3b73a289e2cedf0cd4f064", "url": "https://github.com/trinodb/trino/commit/ea423f2779740858ba3b73a289e2cedf0cd4f064", "message": "Add expiry to operators cache", "committedDate": "2020-10-07T03:42:55Z", "type": "forcePushed"}]}