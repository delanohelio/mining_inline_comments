{"pr_number": 3533, "pr_title": "Handle unwrapping of casts with partial injective coercion", "pr_createdAt": "2020-04-24T00:22:48Z", "pr_url": "https://github.com/trinodb/trino/pull/3533", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2MjU1Nw==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r414662557", "bodyText": "The additional condition is redundant. For PARTIAL, the allowed range for literal here is well within source type range. Instead, please add a comment.", "author": "kasiafi", "createdAt": "2020-04-24T15:25:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -309,7 +332,7 @@ private Expression unwrapCast(ComparisonExpression expression)\n                         return TRUE_LITERAL;\n                     case LESS_THAN:\n                     case LESS_THAN_OR_EQUAL:\n-                        if (sourceRange.isPresent() && compare(sourceType, sourceRange.get().getMin(), literalInSourceType) == 0) {\n+                        if (sourceRange.isPresent() && compare(sourceType, sourceRange.get().getMin(), literalInSourceType) == 0 && implicitInjectiveCoercionAbility == FULL) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2Mjc2OA==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r414662768", "bodyText": "The additional condition is redundant. For PARTIAL, the allowed range for literal here is well within source type range. Instead, please add a comment.", "author": "kasiafi", "createdAt": "2020-04-24T15:25:39Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -339,7 +362,7 @@ private Expression unwrapCast(ComparisonExpression expression)\n                         return new ComparisonExpression(LESS_THAN, cast.getExpression(), literalEncoder.toExpression(literalInSourceType, sourceType));\n                     case GREATER_THAN:\n                     case GREATER_THAN_OR_EQUAL:\n-                        if (sourceRange.isPresent() && compare(sourceType, sourceRange.get().getMax(), literalInSourceType) == 0) {\n+                        if (sourceRange.isPresent() && compare(sourceType, sourceRange.get().getMax(), literalInSourceType) == 0 && implicitInjectiveCoercionAbility == FULL) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2NTExMQ==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r414665111", "bodyText": "Please add a type check to the if-conditions instead of try-catch.", "author": "kasiafi", "createdAt": "2020-04-24T15:28:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -178,14 +181,34 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n-            if (!hasInjectiveImplicitCoercion(sourceType, targetType)) {\n+            ImplicitInjectiveCoercionAbility implicitInjectiveCoercionAbility = getImplicitInjectiveCoercionAbility(sourceType, targetType);\n+            if (implicitInjectiveCoercionAbility == NONE) {\n                 return expression;\n             }\n+            if (implicitInjectiveCoercionAbility == PARTIAL) {\n+                try {\n+                    if (targetType.equals(DOUBLE) && sourceType.equals(BIGINT)) {\n+                        Double rightDouble = (Double) right;\n+                        if (rightDouble.isInfinite() || rightDouble.isNaN() || rightDouble >= 1L << 53 || rightDouble <= -1L << 53) {\n+                            return expression;\n+                        }\n+                    }\n+                    if (targetType.equals(REAL) && (sourceType.equals(BIGINT) || sourceType.equals(INTEGER))) {\n+                        Float rightReal = Float.intBitsToFloat(((Long) right).intValue());\n+                        if (rightReal.isInfinite() || rightReal.isNaN() || rightReal >= 1L << 23 || rightReal <= -1L << 23) {\n+                            return expression;\n+                        }\n+                    }\n+                }\n+                catch (ClassCastException e) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2NTkzMw==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r414665933", "bodyText": "Flipping conjuncts would improve readability.", "author": "kasiafi", "createdAt": "2020-04-24T15:29:57Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -178,14 +181,34 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n-            if (!hasInjectiveImplicitCoercion(sourceType, targetType)) {\n+            ImplicitInjectiveCoercionAbility implicitInjectiveCoercionAbility = getImplicitInjectiveCoercionAbility(sourceType, targetType);\n+            if (implicitInjectiveCoercionAbility == NONE) {\n                 return expression;\n             }\n+            if (implicitInjectiveCoercionAbility == PARTIAL) {\n+                try {\n+                    if (targetType.equals(DOUBLE) && sourceType.equals(BIGINT)) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTU1MQ==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r414669551", "bodyText": "No need to give up here. Most of the cases could be handled:\n\na comparison with NaN\na comparison with any Double outside of Bigint range (including infinity)", "author": "kasiafi", "createdAt": "2020-04-24T15:35:03Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -178,14 +181,34 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n-            if (!hasInjectiveImplicitCoercion(sourceType, targetType)) {\n+            ImplicitInjectiveCoercionAbility implicitInjectiveCoercionAbility = getImplicitInjectiveCoercionAbility(sourceType, targetType);\n+            if (implicitInjectiveCoercionAbility == NONE) {\n                 return expression;\n             }\n+            if (implicitInjectiveCoercionAbility == PARTIAL) {\n+                try {\n+                    if (targetType.equals(DOUBLE) && sourceType.equals(BIGINT)) {\n+                        Double rightDouble = (Double) right;\n+                        if (rightDouble.isInfinite() || rightDouble.isNaN() || rightDouble >= 1L << 53 || rightDouble <= -1L << 53) {\n+                            return expression;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5NDM3Ng==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r414694376", "bodyText": "Ok, yes. I think they can be handled too :\n\nfor NaN, should we just remove the check? currently I think there is no optimization for NaN - we could add some check to detect NaN and return false predicate.\nif the double value is outside the bigint range, then probably we can do a true/false predicate depending on the operator. are you referring to that?", "author": "rohangarg", "createdAt": "2020-04-24T16:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMTczNw==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r414701737", "bodyText": "if the double value is outside the bigint range, then probably we can do a true/false predicate depending on the operator. are you referring to that?\n\nyes, but mind the null. There's helper methods for that falseIfNotNull(), trueIfNotNull().\n\nwe could add some check to detect NaN and return false predicate.\n\nThat depends on the comparison operator, too. For NOT_EQUAL and for IS_DISTINCT_FROM  it will be true. And mind the null.", "author": "kasiafi", "createdAt": "2020-04-24T16:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNjAxNQ==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r414726015", "bodyText": "yes, but mind the null. There's helper methods for that falseIfNotNull(), trueIfNotNull().\n\nOk, yes. Ideally, we can also let the optimizations done for boundary (or out of bound) values done in the rule. I think they can handle the case where double value >= 2^63 and <= -2^63. I will test that.\n\nThat depends on the comparison operator, too. For NOT_EQUAL and for IS_DISTINCT_FROM it will be true. And mind the null.\n\nYes, that's true.", "author": "rohangarg", "createdAt": "2020-04-24T17:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0NTIzMQ==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r414745231", "bodyText": "Ok, yes. Ideally, we can also let the optimizations done for boundary (or out of bound) values done in the rule. I think they can handle the case where double value >= 2^63 and <= -2^63. I will test that.\n\nExactly. That I meant by \"a comparison with any Double outside of Bigint range (including infinity)\".\nAfter this is done, the only uncovered areas will be those for the Double value ranging from (+/-) 2^35 until 2^63. Please add tests for all boundary values.", "author": "kasiafi", "createdAt": "2020-04-24T17:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2OTU1MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxMDE5Mw==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r418310193", "bodyText": "I think it can be assumed here that right is a Double (because of how expressionOptimizer works).", "author": "kasiafi", "createdAt": "2020-04-30T21:52:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -178,14 +181,41 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n-            if (!hasInjectiveImplicitCoercion(sourceType, targetType)) {\n+            ImplicitInjectiveCoercionAbility implicitInjectiveCoercionAbility = getImplicitInjectiveCoercionAbility(sourceType, targetType);\n+            boolean boundaryChecksAllowed = implicitInjectiveCoercionAbility == FULL;\n+            if (implicitInjectiveCoercionAbility == NONE) {\n                 return expression;\n             }\n+            if (implicitInjectiveCoercionAbility == PARTIAL) {\n+                if (sourceType.equals(BIGINT) && targetType.equals(DOUBLE) && right instanceof Double) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxMDM2NQ==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r418310365", "bodyText": "I think it can be assumed here that right is a Long (because of how expressionOptimizer works).", "author": "kasiafi", "createdAt": "2020-04-30T21:53:04Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -178,14 +181,41 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n-            if (!hasInjectiveImplicitCoercion(sourceType, targetType)) {\n+            ImplicitInjectiveCoercionAbility implicitInjectiveCoercionAbility = getImplicitInjectiveCoercionAbility(sourceType, targetType);\n+            boolean boundaryChecksAllowed = implicitInjectiveCoercionAbility == FULL;\n+            if (implicitInjectiveCoercionAbility == NONE) {\n                 return expression;\n             }\n+            if (implicitInjectiveCoercionAbility == PARTIAL) {\n+                if (sourceType.equals(BIGINT) && targetType.equals(DOUBLE) && right instanceof Double) {\n+                    double rightDouble = (Double) right;\n+                    if (rightDouble > Long.MAX_VALUE || rightDouble < Long.MIN_VALUE) {\n+                        // the double constant is greater (or smaller) than all bigints when casted to double\n+                        boundaryChecksAllowed = true;\n+                    }\n+                    else if (rightDouble >= 1L << 53 || rightDouble <= -1L << 53) {\n+                        // in (-2^53, 2^53), bigint follows an injective implicit coercion w.r.t double\n+                        return expression;\n+                    }\n+                }\n+                if ((sourceType.equals(BIGINT) || sourceType.equals(INTEGER)) && targetType.equals(REAL) && right instanceof Long) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxMTg3Mg==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r418311872", "bodyText": "float rightReal = intBitsToFloat(toIntExact((Long) right))", "author": "kasiafi", "createdAt": "2020-04-30T21:56:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -178,14 +181,41 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n-            if (!hasInjectiveImplicitCoercion(sourceType, targetType)) {\n+            ImplicitInjectiveCoercionAbility implicitInjectiveCoercionAbility = getImplicitInjectiveCoercionAbility(sourceType, targetType);\n+            boolean boundaryChecksAllowed = implicitInjectiveCoercionAbility == FULL;\n+            if (implicitInjectiveCoercionAbility == NONE) {\n                 return expression;\n             }\n+            if (implicitInjectiveCoercionAbility == PARTIAL) {\n+                if (sourceType.equals(BIGINT) && targetType.equals(DOUBLE) && right instanceof Double) {\n+                    double rightDouble = (Double) right;\n+                    if (rightDouble > Long.MAX_VALUE || rightDouble < Long.MIN_VALUE) {\n+                        // the double constant is greater (or smaller) than all bigints when casted to double\n+                        boundaryChecksAllowed = true;\n+                    }\n+                    else if (rightDouble >= 1L << 53 || rightDouble <= -1L << 53) {\n+                        // in (-2^53, 2^53), bigint follows an injective implicit coercion w.r.t double\n+                        return expression;\n+                    }\n+                }\n+                if ((sourceType.equals(BIGINT) || sourceType.equals(INTEGER)) && targetType.equals(REAL) && right instanceof Long) {\n+                    float rightReal = Float.intBitsToFloat(((Long) right).intValue());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxMjcwNg==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r418312706", "bodyText": "This case handles infinity. You could mention it in a comment.\nRegarding special values, NaN is not handled still. It should fail at literalInSourceType = coerce(right, targetToSource); (line 315)", "author": "kasiafi", "createdAt": "2020-04-30T21:58:28Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -178,14 +181,41 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n-            if (!hasInjectiveImplicitCoercion(sourceType, targetType)) {\n+            ImplicitInjectiveCoercionAbility implicitInjectiveCoercionAbility = getImplicitInjectiveCoercionAbility(sourceType, targetType);\n+            boolean boundaryChecksAllowed = implicitInjectiveCoercionAbility == FULL;\n+            if (implicitInjectiveCoercionAbility == NONE) {\n                 return expression;\n             }\n+            if (implicitInjectiveCoercionAbility == PARTIAL) {\n+                if (sourceType.equals(BIGINT) && targetType.equals(DOUBLE) && right instanceof Double) {\n+                    double rightDouble = (Double) right;\n+                    if (rightDouble > Long.MAX_VALUE || rightDouble < Long.MIN_VALUE) {\n+                        // the double constant is greater (or smaller) than all bigints when casted to double", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNjI4OA==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r418316288", "bodyText": "This comment looks like a general rule for partial injective types, but it's not.\nNow, that the out-of-bound cases are supported, it is not obvious that the condition is false. Actually, it is false because such cases would be handled / excluded until this point.\n(see the comment on code structure)", "author": "kasiafi", "createdAt": "2020-04-30T22:06:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -309,6 +339,7 @@ private Expression unwrapCast(ComparisonExpression expression)\n                         return TRUE_LITERAL;\n                     case LESS_THAN:\n                     case LESS_THAN_OR_EQUAL:\n+                        // this condition will never be true for PARTIAL injective types", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNjM1Mg==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r418316352", "bodyText": "same as above", "author": "kasiafi", "createdAt": "2020-04-30T22:07:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -339,6 +370,7 @@ private Expression unwrapCast(ComparisonExpression expression)\n                         return new ComparisonExpression(LESS_THAN, cast.getExpression(), literalEncoder.toExpression(literalInSourceType, sourceType));\n                     case GREATER_THAN:\n                     case GREATER_THAN_OR_EQUAL:\n+                        // this condition will never be true for PARTIAL injective types", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyMTYzNg==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r418321636", "bodyText": "Instead of adding a boolean, I would restructure the code so that there are different methods for different unwrapping routines. It would be easier to follow the flow:\nFULL --> out-of-bound unwrapping --> in-bound unwrapping --> give up\nPARTIAL --> analyse rightValue --> either out-of-bound unwrapping or in-bound unwrapping or NaN or give up", "author": "kasiafi", "createdAt": "2020-04-30T22:20:33Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -178,14 +181,41 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n-            if (!hasInjectiveImplicitCoercion(sourceType, targetType)) {\n+            ImplicitInjectiveCoercionAbility implicitInjectiveCoercionAbility = getImplicitInjectiveCoercionAbility(sourceType, targetType);\n+            boolean boundaryChecksAllowed = implicitInjectiveCoercionAbility == FULL;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MTYyOQ==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r436361629", "bodyText": "Cast value to primitive long and use toIntExact() instead of intValue().", "author": "kasiafi", "createdAt": "2020-06-07T13:09:18Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -351,14 +352,25 @@ private Expression unwrapCast(ComparisonExpression expression)\n             return new ComparisonExpression(operator, cast.getExpression(), literalEncoder.toExpression(literalInSourceType, sourceType));\n         }\n \n-        private boolean hasInjectiveImplicitCoercion(Type source, Type target)\n+        private boolean hasInjectiveImplicitCoercion(Type source, Type target, Object value)\n         {\n             if ((source.equals(BIGINT) && target.equals(DOUBLE)) ||\n                     (source.equals(BIGINT) && target.equals(REAL)) ||\n                     (source.equals(INTEGER) && target.equals(REAL))) {\n                 // Not every BIGINT fits in DOUBLE/REAL due to 64 bit vs 53-bit/23-bit mantissa. Similarly,\n                 // not every INTEGER fits in a REAL (32-bit vs 23-bit mantissa)\n-                return false;\n+                if (target.equals(DOUBLE)) {\n+                    double doubleValue = (double) value;\n+                    return doubleValue > Long.MAX_VALUE ||\n+                            doubleValue < Long.MIN_VALUE ||\n+                            (doubleValue > -1L << 53 && doubleValue < 1L << 53); // in (-2^53, 2^53), bigint follows an injective implicit coercion w.r.t double\n+                }\n+                else {\n+                    float realValue = intBitsToFloat(((Long) value).intValue());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjgyNg==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r436442826", "bodyText": "done", "author": "rohangarg", "createdAt": "2020-06-08T03:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MTYyOQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4NjkxMw==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r437486913", "bodyText": "BIGINT ?", "author": "kasiafi", "createdAt": "2020-06-09T14:53:39Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestUnwrapCastInComparison.java", "diffHunk": "@@ -263,6 +299,30 @@ public void testLessThan()\n                 anyTree(\n                         filter(\"A IS NULL AND NULL\",\n                                 values(\"A\"))));\n+\n+        assertPlan(\n+                \"SELECT * FROM (VALUES BIGINT '0') t(a) WHERE a < DOUBLE '1'\",\n+                anyTree(\n+                        filter(\"A < BIGINT '1'\",\n+                                values(\"A\"))));\n+\n+        assertPlan(\n+                \"SELECT * FROM (VALUES BIGINT '0') t(a) WHERE a < DOUBLE '1.1'\",\n+                anyTree(\n+                        filter(\"A <= SMALLINT '1'\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU1MDI0OQ==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r437550249", "bodyText": "Yes, it should be BIGINT - but the test still passes. I checked and have a couple of findings :\n\nboth the literals BIGINT 1 (after the unwrap) and SMALLINT 1 are converted to GenericLiterals when being converted to expression. bigints are converted to generic literals when the value is in integer range, and the integers are rep as LongLiterals. I'm not sure about the reason behind not keeping integers as generic and bigints as longLiterals. could be due to some optimization or the timeline of the datatypes.\nwhen comparing two generic literals, ExpressionVerifier doesn't check their types. It just checks whether the values are same or not. Hence, the tests pass. I'm not sure whether this is intentional.", "author": "rohangarg", "createdAt": "2020-06-09T16:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4NjkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNTc2Mg==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r437725762", "bodyText": "#3981", "author": "findepi", "createdAt": "2020-06-09T21:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4NjkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4NzM2Mw==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r437487363", "bodyText": "BIGINT ?", "author": "kasiafi", "createdAt": "2020-06-09T14:54:15Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestUnwrapCastInComparison.java", "diffHunk": "@@ -263,6 +299,30 @@ public void testLessThan()\n                 anyTree(\n                         filter(\"A IS NULL AND NULL\",\n                                 values(\"A\"))));\n+\n+        assertPlan(\n+                \"SELECT * FROM (VALUES BIGINT '0') t(a) WHERE a < DOUBLE '1'\",\n+                anyTree(\n+                        filter(\"A < BIGINT '1'\",\n+                                values(\"A\"))));\n+\n+        assertPlan(\n+                \"SELECT * FROM (VALUES BIGINT '0') t(a) WHERE a < DOUBLE '1.1'\",\n+                anyTree(\n+                        filter(\"A <= SMALLINT '1'\",\n+                                values(\"A\"))));\n+\n+        assertPlan(\n+                \"SELECT * FROM (VALUES BIGINT '0') t(a) WHERE a < DOUBLE '1.9'\",\n+                anyTree(\n+                        filter(\"A < SMALLINT '2'\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "url": "https://github.com/trinodb/trino/commit/4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "message": "Handle unwrapping of casts with partial injective coercion", "committedDate": "2020-06-21T15:44:34Z", "type": "commit"}, {"oid": "4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "url": "https://github.com/trinodb/trino/commit/4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "message": "Handle unwrapping of casts with partial injective coercion", "committedDate": "2020-06-21T15:44:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk5MDYzNw==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r443990637", "bodyText": "Can you explain why we return true in these cases?", "author": "martint", "createdAt": "2020-06-23T06:31:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -382,14 +382,27 @@ private Expression unwrapCast(ComparisonExpression expression)\n             return new ComparisonExpression(operator, cast.getExpression(), literalEncoder.toExpression(literalInSourceType, sourceType));\n         }\n \n-        private boolean hasInjectiveImplicitCoercion(Type source, Type target)\n+        private boolean hasInjectiveImplicitCoercion(Type source, Type target, Object value)\n         {\n             if ((source.equals(BIGINT) && target.equals(DOUBLE)) ||\n                     (source.equals(BIGINT) && target.equals(REAL)) ||\n                     (source.equals(INTEGER) && target.equals(REAL))) {\n                 // Not every BIGINT fits in DOUBLE/REAL due to 64 bit vs 53-bit/23-bit mantissa. Similarly,\n                 // not every INTEGER fits in a REAL (32-bit vs 23-bit mantissa)\n-                return false;\n+                if (target.equals(DOUBLE)) {\n+                    double doubleValue = (double) value;\n+                    return doubleValue > Long.MAX_VALUE ||\n+                            doubleValue < Long.MIN_VALUE ||\n+                            Double.isNaN(doubleValue) ||", "originalCommit": "4b04deceba1ad7ec4a49e296ca4a63473c01cee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk5NjM5OQ==", "url": "https://github.com/trinodb/trino/pull/3533#discussion_r443996399", "bodyText": "For cases where the double literal is greater (or less) than any possible bigint value when casted to a double, we can treat it as a beyond/below type boundary check for bigint type - example if the expression is like bigint_col < cast(2^100 as double), then we can unwrap that case.\nThe NaN case is sent true because it gets unwrapped later as a part of NaN unwrap opt. done recently.", "author": "rohangarg", "createdAt": "2020-06-23T06:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk5MDYzNw=="}], "type": "inlineReview"}]}