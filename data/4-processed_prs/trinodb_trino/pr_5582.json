{"pr_number": 5582, "pr_title": "WIP Add post-PPD rewrite", "pr_createdAt": "2020-10-17T17:00:44Z", "pr_url": "https://github.com/trinodb/trino/pull/5582", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMTg5OA==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515021898", "bodyText": "Maybe more elegant way would be to add boolean forDelete to TableScanNode. Then we could simply use PlanNodeSearcher within a rule to search for TableScans with such flag.\nIn current approach delete logic (context goes to left) becomes part of IterativeOptimizers itself", "author": "sopel39", "createdAt": "2020-10-30T11:10:33Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/IterativeOptimizer.java", "diffHunk": "@@ -182,15 +188,25 @@ private boolean exploreNode(int group, Context context)\n         return Rule.Result.empty();\n     }\n \n-    private boolean exploreChildren(int group, Context context)\n+    private boolean exploreChildren(int group, Context context, Context deleteContext)\n     {\n         boolean progress = false;\n \n         PlanNode expression = context.memo.getNode(group);\n-        for (PlanNode child : expression.getSources()) {\n+        for (int i = 0; i < expression.getSources().size(); i++) {\n+            PlanNode child = expression.getSources().get(i);\n             checkState(child instanceof GroupReference, \"Expected child to be a group reference. Found: \" + child.getClass().getName());\n \n-            if (exploreGroup(((GroupReference) child).getGroupId(), context)) {\n+            Context childContext;\n+            if (i == 0) {\n+                // pass the context of Delete to the left branch of plan", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyNTQyOA==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515025428", "bodyText": "remove?", "author": "sopel39", "createdAt": "2020-10-30T11:17:09Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDereferencePushDown.java", "diffHunk": "@@ -38,6 +40,11 @@\n public class TestDereferencePushDown\n         extends BasePlanTest\n {\n+   /* public TestDereferencePushDown()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyNjE3OQ==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515026179", "bodyText": "Do we care that it's not rewritten? In other tests it seem to make sense, but in this one not neccecerly.", "author": "sopel39", "createdAt": "2020-10-30T11:18:31Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestQuantifiedComparison.java", "diffHunk": "@@ -35,7 +37,12 @@\n     public void testQuantifiedComparisonEqualsAny()\n     {\n         String query = \"SELECT orderkey, custkey FROM orders WHERE orderkey = ANY (VALUES ROW(CAST(5 as BIGINT)), ROW(CAST(3 as BIGINT)))\";\n-        assertPlan(query, anyTree(\n+        assertPlan(\n+                query,\n+                Session.builder(getQueryRunner().getDefaultSession())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyNjUxNA==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515026514", "bodyText": "add a test case for semi join rewrite here.", "author": "sopel39", "createdAt": "2020-10-30T11:19:02Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -1555,4 +1557,11 @@ private Session automaticJoinDistribution()\n                 .setSystemProperty(JOIN_DISTRIBUTION_TYPE, JoinDistributionType.AUTOMATIC.name())\n                 .build();\n     }\n+", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMzkyNQ==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515933925", "bodyText": "is there any way to test it?", "author": "sopel39", "createdAt": "2020-11-02T12:19:58Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -201,7 +202,8 @@ protected RelationPlan visitTable(Table node, Void context)\n             }\n \n             List<Symbol> outputSymbols = outputSymbolsBuilder.build();\n-            PlanNode root = TableScanNode.newInstance(idAllocator.getNextId(), handle, outputSymbols, columns.build());\n+            boolean isDeleteTarget = analysis.isDeleteTarget(createQualifiedObjectName(session, node, node.getName()));\n+            PlanNode root = TableScanNode.newInstance(idAllocator.getNextId(), handle, outputSymbols, columns.build(), isDeleteTarget);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2MjY3MA==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r516962670", "bodyText": "I didn't find a way. DELETE queries are rejected in TestLogicalPlanner", "author": "kasiafi", "createdAt": "2020-11-03T21:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzMzkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNzA0Mg==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515937042", "bodyText": "nit: why not to create equi condition immediatelly?", "author": "sopel39", "createdAt": "2020-11-02T12:27:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.SemiJoinNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.SystemSessionProperties.isRewriteFilteringSemiJoinToInnerJoin;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.ExpressionUtils.extractConjuncts;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.semiJoin;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static java.util.function.Predicate.not;\n+\n+/**\n+ * Rewrite filtering semi-join to inner join.\n+ * <p/>\n+ * Transforms:\n+ * <pre>\n+ * - Filter (semiJoinSymbol AND predicate)\n+ *    - SemiJoin (semiJoinSymbol <- (a IN b))\n+ *        source: plan A producing symbol a\n+ *        filtering source: plan B producing symbol b\n+ * </pre>\n+ * <p/>\n+ * Into:\n+ * <pre>\n+ * - Filter (predicate)\n+ *    - Project (semiJoinSymbol <- TRUE)\n+ *       - Join INNER on (a = b)\n+ *          - source\n+ *          - Aggregation distinct(b)\n+ *             - filtering source\n+ * </pre>\n+ */\n+public class TransformFilteringSemiJoinToInnerJoin\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<SemiJoinNode> SEMI_JOIN = newCapture();\n+\n+    private static final Pattern<FilterNode> PATTERN = filter()\n+            .with(source().matching(semiJoin().capturedAs(SEMI_JOIN)));\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isRewriteFilteringSemiJoinToInnerJoin(session);\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode filterNode, Captures captures, Context context)\n+    {\n+        SemiJoinNode semiJoin = captures.get(SEMI_JOIN);\n+\n+        // Do not transform semi-join in context of DELETE\n+        if (PlanNodeSearcher.searchFrom(semiJoin.getSource(), context.getLookup())\n+                .where(node -> node instanceof TableScanNode && ((TableScanNode) node).isForDelete())\n+                .matches()) {\n+            return Result.empty();\n+        }\n+\n+        Symbol semiJoinSymbol = semiJoin.getSemiJoinOutput();\n+        Predicate<Expression> isSemiJoinSymbol = expression -> expression.equals(semiJoinSymbol.toSymbolReference());\n+\n+        List<Expression> conjuncts = extractConjuncts(filterNode.getPredicate());\n+        if (conjuncts.stream().noneMatch(isSemiJoinSymbol)) {\n+            return Result.empty();\n+        }\n+        Expression filteredPredicate = and(conjuncts.stream()\n+                .filter(not(isSemiJoinSymbol))\n+                .collect(toImmutableList()));\n+\n+        PlanNode filteringSourceDistinct = new AggregationNode(\n+                context.getIdAllocator().getNextId(),\n+                semiJoin.getFilteringSource(),\n+                ImmutableMap.of(),\n+                singleGroupingSet(ImmutableList.of(semiJoin.getFilteringSourceJoinSymbol())),\n+                ImmutableList.of(),\n+                SINGLE,\n+                Optional.empty(),\n+                Optional.empty());\n+\n+        Expression joinFilter = new ComparisonExpression(EQUAL, semiJoin.getSourceJoinSymbol().toSymbolReference(), semiJoin.getFilteringSourceJoinSymbol().toSymbolReference());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNzc3MA==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515937770", "bodyText": "why not to put filteredPredicate immediatelly?", "author": "sopel39", "createdAt": "2020-11-02T12:28:48Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.SemiJoinNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.SystemSessionProperties.isRewriteFilteringSemiJoinToInnerJoin;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.ExpressionUtils.extractConjuncts;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.semiJoin;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static java.util.function.Predicate.not;\n+\n+/**\n+ * Rewrite filtering semi-join to inner join.\n+ * <p/>\n+ * Transforms:\n+ * <pre>\n+ * - Filter (semiJoinSymbol AND predicate)\n+ *    - SemiJoin (semiJoinSymbol <- (a IN b))\n+ *        source: plan A producing symbol a\n+ *        filtering source: plan B producing symbol b\n+ * </pre>\n+ * <p/>\n+ * Into:\n+ * <pre>\n+ * - Filter (predicate)\n+ *    - Project (semiJoinSymbol <- TRUE)\n+ *       - Join INNER on (a = b)\n+ *          - source\n+ *          - Aggregation distinct(b)\n+ *             - filtering source\n+ * </pre>\n+ */\n+public class TransformFilteringSemiJoinToInnerJoin\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<SemiJoinNode> SEMI_JOIN = newCapture();\n+\n+    private static final Pattern<FilterNode> PATTERN = filter()\n+            .with(source().matching(semiJoin().capturedAs(SEMI_JOIN)));\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isRewriteFilteringSemiJoinToInnerJoin(session);\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode filterNode, Captures captures, Context context)\n+    {\n+        SemiJoinNode semiJoin = captures.get(SEMI_JOIN);\n+\n+        // Do not transform semi-join in context of DELETE\n+        if (PlanNodeSearcher.searchFrom(semiJoin.getSource(), context.getLookup())\n+                .where(node -> node instanceof TableScanNode && ((TableScanNode) node).isForDelete())\n+                .matches()) {\n+            return Result.empty();\n+        }\n+\n+        Symbol semiJoinSymbol = semiJoin.getSemiJoinOutput();\n+        Predicate<Expression> isSemiJoinSymbol = expression -> expression.equals(semiJoinSymbol.toSymbolReference());\n+\n+        List<Expression> conjuncts = extractConjuncts(filterNode.getPredicate());\n+        if (conjuncts.stream().noneMatch(isSemiJoinSymbol)) {\n+            return Result.empty();\n+        }\n+        Expression filteredPredicate = and(conjuncts.stream()\n+                .filter(not(isSemiJoinSymbol))\n+                .collect(toImmutableList()));\n+\n+        PlanNode filteringSourceDistinct = new AggregationNode(\n+                context.getIdAllocator().getNextId(),\n+                semiJoin.getFilteringSource(),\n+                ImmutableMap.of(),\n+                singleGroupingSet(ImmutableList.of(semiJoin.getFilteringSourceJoinSymbol())),\n+                ImmutableList.of(),\n+                SINGLE,\n+                Optional.empty(),\n+                Optional.empty());\n+\n+        Expression joinFilter = new ComparisonExpression(EQUAL, semiJoin.getSourceJoinSymbol().toSymbolReference(), semiJoin.getFilteringSourceJoinSymbol().toSymbolReference());\n+\n+        JoinNode innerJoin = new JoinNode(\n+                semiJoin.getId(),\n+                INNER,\n+                semiJoin.getSource(),\n+                filteringSourceDistinct,\n+                ImmutableList.of(),\n+                semiJoin.getSource().getOutputSymbols(),\n+                ImmutableList.of(),\n+                Optional.of(joinFilter),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2MzE2MA==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r516963160", "bodyText": "filteredPredicate might depend on the semi join symbol.", "author": "kasiafi", "createdAt": "2020-11-03T21:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNzc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzOTE5MQ==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515939191", "bodyText": "You probably could skip generating of filteredPredicate and just put entire predicate in io.prestosql.sql.planner.plan.JoinNode#filter (assuming true for isSemiJoinSymbol). That would simplify rule.", "author": "sopel39", "createdAt": "2020-11-02T12:31:40Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/TransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.PlanNodeSearcher;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.SemiJoinNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.SystemSessionProperties.isRewriteFilteringSemiJoinToInnerJoin;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.ExpressionUtils.and;\n+import static io.prestosql.sql.ExpressionUtils.extractConjuncts;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.semiJoin;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static java.util.function.Predicate.not;\n+\n+/**\n+ * Rewrite filtering semi-join to inner join.\n+ * <p/>\n+ * Transforms:\n+ * <pre>\n+ * - Filter (semiJoinSymbol AND predicate)\n+ *    - SemiJoin (semiJoinSymbol <- (a IN b))\n+ *        source: plan A producing symbol a\n+ *        filtering source: plan B producing symbol b\n+ * </pre>\n+ * <p/>\n+ * Into:\n+ * <pre>\n+ * - Filter (predicate)\n+ *    - Project (semiJoinSymbol <- TRUE)\n+ *       - Join INNER on (a = b)\n+ *          - source\n+ *          - Aggregation distinct(b)\n+ *             - filtering source\n+ * </pre>\n+ */\n+public class TransformFilteringSemiJoinToInnerJoin\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<SemiJoinNode> SEMI_JOIN = newCapture();\n+\n+    private static final Pattern<FilterNode> PATTERN = filter()\n+            .with(source().matching(semiJoin().capturedAs(SEMI_JOIN)));\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isRewriteFilteringSemiJoinToInnerJoin(session);\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode filterNode, Captures captures, Context context)\n+    {\n+        SemiJoinNode semiJoin = captures.get(SEMI_JOIN);\n+\n+        // Do not transform semi-join in context of DELETE\n+        if (PlanNodeSearcher.searchFrom(semiJoin.getSource(), context.getLookup())\n+                .where(node -> node instanceof TableScanNode && ((TableScanNode) node).isForDelete())\n+                .matches()) {\n+            return Result.empty();\n+        }\n+\n+        Symbol semiJoinSymbol = semiJoin.getSemiJoinOutput();\n+        Predicate<Expression> isSemiJoinSymbol = expression -> expression.equals(semiJoinSymbol.toSymbolReference());\n+\n+        List<Expression> conjuncts = extractConjuncts(filterNode.getPredicate());\n+        if (conjuncts.stream().noneMatch(isSemiJoinSymbol)) {\n+            return Result.empty();\n+        }\n+        Expression filteredPredicate = and(conjuncts.stream()\n+                .filter(not(isSemiJoinSymbol))\n+                .collect(toImmutableList()));\n+\n+        PlanNode filteringSourceDistinct = new AggregationNode(\n+                context.getIdAllocator().getNextId(),\n+                semiJoin.getFilteringSource(),\n+                ImmutableMap.of(),\n+                singleGroupingSet(ImmutableList.of(semiJoin.getFilteringSourceJoinSymbol())),\n+                ImmutableList.of(),\n+                SINGLE,\n+                Optional.empty(),\n+                Optional.empty());\n+\n+        Expression joinFilter = new ComparisonExpression(EQUAL, semiJoin.getSourceJoinSymbol().toSymbolReference(), semiJoin.getFilteringSourceJoinSymbol().toSymbolReference());\n+\n+        JoinNode innerJoin = new JoinNode(\n+                semiJoin.getId(),\n+                INNER,\n+                semiJoin.getSource(),\n+                filteringSourceDistinct,\n+                ImmutableList.of(),\n+                semiJoin.getSource().getOutputSymbols(),\n+                ImmutableList.of(),\n+                Optional.of(joinFilter),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                semiJoin.getDynamicFilterId()\n+                        .map(id -> ImmutableMap.of(id, semiJoin.getFilteringSourceJoinSymbol()))\n+                        .orElse(ImmutableMap.of()),\n+                Optional.empty());\n+\n+        ProjectNode project = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                innerJoin,\n+                Assignments.builder()\n+                        .putIdentities(innerJoin.getOutputSymbols())\n+                        .put(semiJoinSymbol, TRUE_LITERAL)\n+                        .build());\n+\n+        if (filteredPredicate.equals(TRUE_LITERAL)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4Mjc1OQ==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r516982759", "bodyText": "done", "author": "kasiafi", "createdAt": "2020-11-03T22:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzOTE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0MDYwNA==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r515940604", "bodyText": "static import INNER", "author": "sopel39", "createdAt": "2020-11-02T12:34:26Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestQuantifiedComparison.java", "diffHunk": "@@ -36,11 +39,11 @@ public void testQuantifiedComparisonEqualsAny()\n     {\n         String query = \"SELECT orderkey, custkey FROM orders WHERE orderkey = ANY (VALUES ROW(CAST(5 as BIGINT)), ROW(CAST(3 as BIGINT)))\";\n         assertPlan(query, anyTree(\n-                    filter(\"S\",\n-                            project(\n-                                    semiJoin(\"X\", \"Y\", \"S\",\n-                                            anyTree(tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n-                                            anyTree(values(ImmutableMap.of(\"Y\", 0))))))));\n+                join(\n+                        JoinNode.Type.INNER,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "72258a4e62d0ca7357cc883c1dc5b4b1e5f2694e", "url": "https://github.com/trinodb/trino/commit/72258a4e62d0ca7357cc883c1dc5b4b1e5f2694e", "message": "Add \"forDelete\" property to TableScanNode", "committedDate": "2020-11-04T07:53:20Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2ODU1OA==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r517268558", "bodyText": "static import expression", "author": "sopel39", "createdAt": "2020-11-04T11:11:38Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestTransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.aggregation;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.equiJoinClause;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.join;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.singleGroupingSet;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.prestosql.sql.planner.iterative.rule.test.PlanBuilder.expression;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+\n+public class TestTransformFilteringSemiJoinToInnerJoin\n+        extends BaseRuleTest\n+{\n+    @Test\n+    public void testTransformSemiJoinToInnerJoin()\n+    {\n+        tester().assertThat(new TransformFilteringSemiJoinToInnerJoin())\n+                .on(p -> {\n+                    Symbol a = p.symbol(\"a\");\n+                    Symbol b = p.symbol(\"b\");\n+                    Symbol aInB = p.symbol(\"a_in_b\");\n+                    return p.filter(\n+                            expression(\"a_in_b AND a > 5\"),\n+                            p.semiJoin(\n+                                    p.values(a),\n+                                    p.values(b),\n+                                    a,\n+                                    b,\n+                                    aInB,\n+                                    Optional.empty(),\n+                                    Optional.empty(),\n+                                    Optional.empty()));\n+                })\n+                .matches(project(\n+                        ImmutableMap.of(\"a\", PlanMatchPattern.expression(\"a\"), \"a_in_b\", PlanMatchPattern.expression(\"true\")),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI4NjU2Ng==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r517286566", "bodyText": "Can't import it due to collision with PlanBuilder.expression()", "author": "kasiafi", "createdAt": "2020-11-04T11:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2ODU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NzczNw==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r517997737", "bodyText": "Could we have a test that the rule does not fire with forDelete TS?\nAre there tests for DELETE query with IN (semi-join)?", "author": "sopel39", "createdAt": "2020-11-05T11:59:02Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestTransformFilteringSemiJoinToInnerJoin.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.aggregation;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.equiJoinClause;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.join;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.singleGroupingSet;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.prestosql.sql.planner.iterative.rule.test.PlanBuilder.expression;\n+import static io.prestosql.sql.planner.plan.AggregationNode.Step.SINGLE;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+\n+public class TestTransformFilteringSemiJoinToInnerJoin\n+        extends BaseRuleTest\n+{\n+    @Test", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAwNzY2Ng==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r518007666", "bodyText": "There's testDelete() in AbstractTestDistributedQueries. It covers the case of SemiJoin under DeleteNode. It runs for Raptor.", "author": "kasiafi", "createdAt": "2020-11-05T12:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NzczNw=="}], "type": "inlineReview"}, {"oid": "61330e14cfbf888c7a1c524d3128df85669c89d5", "url": "https://github.com/trinodb/trino/commit/61330e14cfbf888c7a1c524d3128df85669c89d5", "message": "Rewrite filtering semi join to inner join", "committedDate": "2020-11-05T12:53:13Z", "type": "commit"}, {"oid": "61330e14cfbf888c7a1c524d3128df85669c89d5", "url": "https://github.com/trinodb/trino/commit/61330e14cfbf888c7a1c524d3128df85669c89d5", "message": "Rewrite filtering semi join to inner join", "committedDate": "2020-11-05T12:53:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMTY4OA==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r518031688", "bodyText": "nit: you could probably extend some exiting method and add an override, but it's also fine", "author": "sopel39", "createdAt": "2020-11-05T12:59:39Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/test/PlanBuilder.java", "diffHunk": "@@ -482,6 +483,17 @@ public CorrelatedJoinNode correlatedJoin(List<Symbol> correlation, PlanNode inpu\n         return new CorrelatedJoinNode(idAllocator.getNextId(), input, subquery, correlation, type, filter, originSubquery);\n     }\n \n+    public TableScanNode tableScan(List<Symbol> symbols, boolean forDelete)", "originalCommit": "61330e14cfbf888c7a1c524d3128df85669c89d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNjQ3Mw==", "url": "https://github.com/trinodb/trino/pull/5582#discussion_r518036473", "bodyText": "I decided to add a separate method for now. I think we could reorganize the tableScan() methods later when forDelete property is more used and tested.", "author": "kasiafi", "createdAt": "2020-11-05T13:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMTY4OA=="}], "type": "inlineReview"}]}