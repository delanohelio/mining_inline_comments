{"pr_number": 6178, "pr_title": "Glue metastore statistics integration", "pr_createdAt": "2020-12-02T17:19:17Z", "pr_url": "https://github.com/trinodb/trino/pull/6178", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMyOTIwMw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559329203", "bodyText": "@electrum What do we feel about updating to latest vs the first version that added the support for Glue statistics API? (Which would be 1.11.811).", "author": "hashhar", "createdAt": "2021-01-18T05:47:28Z", "path": "pom.xml", "diffHunk": "@@ -48,7 +48,7 @@\n         <dep.antlr.version>4.8</dep.antlr.version>\n         <dep.airlift.version>201</dep.airlift.version>\n         <dep.packaging.version>${dep.airlift.version}</dep.packaging.version>\n-        <dep.aws-sdk.version>1.11.749</dep.aws-sdk.version>\n+        <dep.aws-sdk.version>1.11.901</dep.aws-sdk.version>", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM2MDk5MA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559360990", "bodyText": "Nevermind, seems like we are already updated to an even newer version on master.", "author": "hashhar", "createdAt": "2021-01-18T07:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMyOTIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc2MzQ2Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559763463", "bodyText": "yes after rebase we are running on 1.11.921", "author": "GaruGaru", "createdAt": "2021-01-18T19:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMyOTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMyOTU1NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559329555", "bodyText": "How are these values decided? If there's a limit to the maximum/minimum value then please document it as a code comment or as a runtime check via something like verify().", "author": "hashhar", "createdAt": "2021-01-18T05:48:41Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.prestosql.plugin.hive.HiveBasicStatistics;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.statistics.ColumnStatisticType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc2MzY3MA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559763670", "bodyText": "Right, I've added the explanation with the aws api reference link", "author": "GaruGaru", "createdAt": "2021-01-18T19:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMyOTU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMTIyOQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559331229", "bodyText": "Is it possible to build this directly without iterating over columnStatsBuilder first? ie. populate this while collecting the futures in the loop above?\nSame applicable in getPartitionColumnStatistics.", "author": "hashhar", "createdAt": "2021-01-18T05:55:21Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.prestosql.plugin.hive.HiveBasicStatistics;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.statistics.ColumnStatisticType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        final List<String> columnNames = getAllColumns(table);\n+        final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+        ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+        columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+            final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                    .withCatalogId(catalogId)\n+                    .withDatabaseName(table.getDatabaseName())\n+                    .withTableName(table.getTableName())\n+                    .withColumnNames(partialColumns);\n+\n+            return glueClient.getColumnStatisticsForTable(request);\n+        }, readExecutor)));\n+\n+        final ImmutableList.Builder<ColumnStatistics> columnStatsBuilder = ImmutableList.builder();\n+        for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+            final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, PrestoException.class);\n+            columnStatsBuilder.addAll(tableColumnsStats.getColumnStatisticsList());\n+        }\n+\n+        final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+\n+        final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc2MzgyNg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559763826", "bodyText": "Nice catch, I've changed the implementation as you suggested", "author": "GaruGaru", "createdAt": "2021-01-18T19:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMTIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMTY1Mg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559331652", "bodyText": "We prefer Guava immutable collections over JDK unmodifiable collections where possible. Since this list won't have nulls use toImmutableList (static import from Guava).", "author": "hashhar", "createdAt": "2021-01-18T05:56:49Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.prestosql.plugin.hive.HiveBasicStatistics;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.statistics.ColumnStatisticType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        final List<String> columnNames = getAllColumns(table);\n+        final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+        ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+        columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+            final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                    .withCatalogId(catalogId)\n+                    .withDatabaseName(table.getDatabaseName())\n+                    .withTableName(table.getTableName())\n+                    .withColumnNames(partialColumns);\n+\n+            return glueClient.getColumnStatisticsForTable(request);\n+        }, readExecutor)));\n+\n+        final ImmutableList.Builder<ColumnStatistics> columnStatsBuilder = ImmutableList.builder();\n+        for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+            final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, PrestoException.class);\n+            columnStatsBuilder.addAll(tableColumnsStats.getColumnStatisticsList());\n+        }\n+\n+        final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+\n+        final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+        columnStatsBuilder.build()\n+                .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+        return columnStatsMapBuilder.build();\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+        ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+        columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+            final List<String> columnsNames = partialColumns.stream()\n+                    .map(Column::getName)\n+                    .collect(Collectors.toUnmodifiableList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMjYxNQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559332615", "bodyText": "Can we add this feature behind a config toggle for now? Since the planner will invoke stats calls and it's easy for people to run into Glue API rate limits so I can see people wanting to have the ability to disable this if needed.\nIt can/should default to true though.", "author": "hashhar", "createdAt": "2021-01-18T06:00:14Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.prestosql.plugin.hive.HiveBasicStatistics;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.statistics.ColumnStatisticType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM2MTM4NA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559361384", "bodyText": "Nevermind, I saw that you are picking the impl. based on the config toggle so that impls. don't need to be aware if things are enabled or disabled. Nice.", "author": "hashhar", "createdAt": "2021-01-18T07:30:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMjYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc2NDUxMg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559764512", "bodyText": "Yes, I'm not sure if having a No op implementation is a common pattern in the codebase, we may also change the default implementation to use a toggle flag if you think it's more appropriate", "author": "GaruGaru", "createdAt": "2021-01-18T19:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMjYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkyOTM2MA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559929360", "bodyText": "We do have some no-op implementations in other places in the code. It looks fine to me.\nBut I'll let the maintainers take the call on this one.\ncc: @findepi @electrum", "author": "hashhar", "createdAt": "2021-01-19T05:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMjYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTk3NTMwMw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559975303", "bodyText": "We did have a no-op implementation because stats for glue was extensions point. It was needed until Glue provided first-class stats support.\nWe should maintain the extension point for a while, before we can remove it.\nSo the DefaultGCSP can change its' behavior, but should not be used uncondintionally. cc @sopel39\nAlso, we need a safety toggle to be able to ignore stats, should users run into any problems.\n@GaruGaru can you please confirm hive.table-statistics-enabled can be used to skip getting stats from Glue?", "author": "findepi", "createdAt": "2021-01-19T07:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMjYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0OTA4MQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560049081", "bodyText": "In order to enable/disable the statistics get/update I've introduced the hive.metastore.glue.statistics-enabled flag, do you think we can use hive.table-statistics-enabled directly or we should check them both ?", "author": "GaruGaru", "createdAt": "2021-01-19T09:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMjYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA5MjY0OA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560092648", "bodyText": "One flag should be enough. You cannot use 2 metastores at the same time anyway.", "author": "findepi", "createdAt": "2021-01-19T11:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMjYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDMwOTEyMQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560309121", "bodyText": "I've removed hive.metastore.glue.statistics-enabled in favour of hive.table-statistics-enabled", "author": "GaruGaru", "createdAt": "2021-01-19T16:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMjYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMjgxOA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559332818", "bodyText": "Rename var to partitionColumnStats.", "author": "hashhar", "createdAt": "2021-01-18T06:00:57Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.prestosql.plugin.hive.HiveBasicStatistics;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.statistics.ColumnStatisticType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        final List<String> columnNames = getAllColumns(table);\n+        final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+        ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+        columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+            final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                    .withCatalogId(catalogId)\n+                    .withDatabaseName(table.getDatabaseName())\n+                    .withTableName(table.getTableName())\n+                    .withColumnNames(partialColumns);\n+\n+            return glueClient.getColumnStatisticsForTable(request);\n+        }, readExecutor)));\n+\n+        final ImmutableList.Builder<ColumnStatistics> columnStatsBuilder = ImmutableList.builder();\n+        for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+            final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, PrestoException.class);\n+            columnStatsBuilder.addAll(tableColumnsStats.getColumnStatisticsList());\n+        }\n+\n+        final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+\n+        final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+        columnStatsBuilder.build()\n+                .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+        return columnStatsMapBuilder.build();\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+        ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+        columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+            final List<String> columnsNames = partialColumns.stream()\n+                    .map(Column::getName)\n+                    .collect(Collectors.toUnmodifiableList());\n+\n+            final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                    .withCatalogId(catalogId)\n+                    .withDatabaseName(partition.getDatabaseName())\n+                    .withTableName(partition.getTableName())\n+                    .withColumnNames(columnsNames)\n+                    .withPartitionValues(partition.getValues());\n+\n+            return glueClient.getColumnStatisticsForPartition(request);\n+        }, readExecutor)));\n+\n+        final ImmutableList.Builder<ColumnStatistics> columnStatsBuilder = ImmutableList.builder();\n+        for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+            final GetColumnStatisticsForPartitionResult tableColumnsStats = MoreFutures.getFutureValue(future, PrestoException.class);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMzI5Ng==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559333296", "bodyText": "Are we swallowing exceptions here? I think this method should throw a PrestoException with HIVE_METASTORE_ERROR.\nOr am I reading this incorrectly?\nSame applicable to other places where Glue responses are collected.", "author": "hashhar", "createdAt": "2021-01-18T06:03:11Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.prestosql.plugin.hive.HiveBasicStatistics;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.statistics.ColumnStatisticType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        final List<String> columnNames = getAllColumns(table);\n+        final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+        ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+        columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+            final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                    .withCatalogId(catalogId)\n+                    .withDatabaseName(table.getDatabaseName())\n+                    .withTableName(table.getTableName())\n+                    .withColumnNames(partialColumns);\n+\n+            return glueClient.getColumnStatisticsForTable(request);\n+        }, readExecutor)));\n+\n+        final ImmutableList.Builder<ColumnStatistics> columnStatsBuilder = ImmutableList.builder();\n+        for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+            final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, PrestoException.class);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDMxMTU2Nw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560311567", "bodyText": "I solved this but at the moment I'm catching AWSGlueException, should the catch clause also check for more generic exceptions ?", "author": "GaruGaru", "createdAt": "2021-01-19T16:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzMzI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzNzU1NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559337555", "bodyText": "This condition works today because we are always fetching table statistics.\nIf we make the feature toggleable then the stats object being empty doesn't mean stats have to be dropped.\nInstead, what if we:\n\nGet current stats from Glue.\nCalculate the ones that have changed (i.e. current - updated) and the ones that are now missing.\nMake an API call to update only the ones that have changed.\nMake an API call to delete the ones that are missing.\n\nSame is applicable to updatePartitionStatistics.", "author": "hashhar", "createdAt": "2021-01-18T06:18:22Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.prestosql.plugin.hive.HiveBasicStatistics;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.statistics.ColumnStatisticType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        final List<String> columnNames = getAllColumns(table);\n+        final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+        ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+        columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+            final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                    .withCatalogId(catalogId)\n+                    .withDatabaseName(table.getDatabaseName())\n+                    .withTableName(table.getTableName())\n+                    .withColumnNames(partialColumns);\n+\n+            return glueClient.getColumnStatisticsForTable(request);\n+        }, readExecutor)));\n+\n+        final ImmutableList.Builder<ColumnStatistics> columnStatsBuilder = ImmutableList.builder();\n+        for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+            final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, PrestoException.class);\n+            columnStatsBuilder.addAll(tableColumnsStats.getColumnStatisticsList());\n+        }\n+\n+        final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+\n+        final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+        columnStatsBuilder.build()\n+                .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+        return columnStatsMapBuilder.build();\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+        ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+        columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+            final List<String> columnsNames = partialColumns.stream()\n+                    .map(Column::getName)\n+                    .collect(Collectors.toUnmodifiableList());\n+\n+            final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                    .withCatalogId(catalogId)\n+                    .withDatabaseName(partition.getDatabaseName())\n+                    .withTableName(partition.getTableName())\n+                    .withColumnNames(columnsNames)\n+                    .withPartitionValues(partition.getValues());\n+\n+            return glueClient.getColumnStatisticsForPartition(request);\n+        }, readExecutor)));\n+\n+        final ImmutableList.Builder<ColumnStatistics> columnStatsBuilder = ImmutableList.builder();\n+        for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+            final GetColumnStatisticsForPartitionResult tableColumnsStats = MoreFutures.getFutureValue(future, PrestoException.class);\n+            columnStatsBuilder.addAll(tableColumnsStats.getColumnStatisticsList());\n+        }\n+\n+        final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+\n+        final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+        columnStatsBuilder.build().forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+        return columnStatsMapBuilder.build();\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+        if (columnStatistics.isEmpty()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM2MjAxMw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559362013", "bodyText": "I now see that this class is used only when stats are enabled so the condition to switch on makes sense.\nStill, this method behaves differently compared to the one for ThriftHiveMetastore. The impl I'm suggesting would preserve semantics.", "author": "hashhar", "createdAt": "2021-01-18T07:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzNzU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4OTcwMg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559789702", "bodyText": "Agree, the code with the boolean flag / check was written that way to preserve the ThriftHiveMetastore behaviour but keeping the same semantic is the right thing to do here in both updatePartitionStatisticsand  updateTableColumnStatistics.\nThis change is likely to impact the performance of the implementation (glue api call) but from my understanding the update statistics process is not that latency sensitive", "author": "GaruGaru", "createdAt": "2021-01-18T20:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzNzU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzODcwMA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559338700", "bodyText": "Is this Table object coming from Hive metastore API?\nI think it's unclean to depend on the Thrift models for Glue. If TableInput has something missing we can add a wrapper over it maybe?", "author": "hashhar", "createdAt": "2021-01-18T06:22:27Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/DisabledGlueColumnStatisticsProvider.java", "diffHunk": "@@ -51,15 +49,15 @@\n     }\n \n     @Override\n-    public void updateTableColumnStatistics(TableInput table, Map<String, HiveColumnStatistics> columnStatistics)\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzODc0Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559338743", "bodyText": "Same for Partition below.", "author": "hashhar", "createdAt": "2021-01-18T06:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzODcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc3MzYwNw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559773607", "bodyText": "I agree, We may have a more defined separation between the packages but we need models defined by Table, Column ,Partition` classes.\nWe can either duplicates the attributes to some Glue specific wrappers or create some shared definitions but that may be risky in case of hive/glue api changes", "author": "GaruGaru", "createdAt": "2021-01-18T20:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzODcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDcxMzA4OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560713089", "bodyText": "This is fine to keep as is. If there is some breakage in future (unlikely) then we can take a look at extracting a wrapper.", "author": "hashhar", "createdAt": "2021-01-20T06:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzODcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzOTAzMw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559339033", "bodyText": "Rename to something more descriptive.", "author": "hashhar", "createdAt": "2021-01-18T06:23:54Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -163,18 +163,20 @@\n     private final Optional<String> defaultDir;\n     private final String catalogId;\n     private final int partitionSegments;\n-    private final Executor executor;\n+    private final Executor partitionsExecutor;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTMzOTk0OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559339949", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @ConfigDescription(\"Enabled statistics for glue tables\")\n          \n          \n            \n                @ConfigDescription(\"Enable statistics for glue tables\")", "author": "hashhar", "createdAt": "2021-01-18T06:26:51Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastoreConfig.java", "diffHunk": "@@ -242,4 +245,45 @@ public GlueHiveMetastoreConfig setAssumeCanonicalPartitionKeys(boolean assumeCan\n         this.assumeCanonicalPartitionKeys = assumeCanonicalPartitionKeys;\n         return this;\n     }\n+\n+    public boolean getEnableColumnStatistics()\n+    {\n+        return enableColumnStatistics;\n+    }\n+\n+    @Config(\"hive.metastore.glue.enable-column-stat\")\n+    @ConfigDescription(\"Enabled statistics for glue tables\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0MDA1Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559340053", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Config(\"hive.metastore.glue.enable-column-stat\")\n          \n          \n            \n                @Config(\"hive.metastore.glue.statistics-enabled\")", "author": "hashhar", "createdAt": "2021-01-18T06:27:10Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastoreConfig.java", "diffHunk": "@@ -242,4 +245,45 @@ public GlueHiveMetastoreConfig setAssumeCanonicalPartitionKeys(boolean assumeCan\n         this.assumeCanonicalPartitionKeys = assumeCanonicalPartitionKeys;\n         return this;\n     }\n+\n+    public boolean getEnableColumnStatistics()\n+    {\n+        return enableColumnStatistics;\n+    }\n+\n+    @Config(\"hive.metastore.glue.enable-column-stat\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0MDQ5OA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559340498", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @ConfigDescription(\"Number of threads for parallel read column statistics fetches from Glue\")\n          \n          \n            \n                @ConfigDescription(\"Number of threads for parallel statistics reads from Glue\")", "author": "hashhar", "createdAt": "2021-01-18T06:28:34Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastoreConfig.java", "diffHunk": "@@ -242,4 +245,45 @@ public GlueHiveMetastoreConfig setAssumeCanonicalPartitionKeys(boolean assumeCan\n         this.assumeCanonicalPartitionKeys = assumeCanonicalPartitionKeys;\n         return this;\n     }\n+\n+    public boolean getEnableColumnStatistics()\n+    {\n+        return enableColumnStatistics;\n+    }\n+\n+    @Config(\"hive.metastore.glue.enable-column-stat\")\n+    @ConfigDescription(\"Enabled statistics for glue tables\")\n+    public GlueHiveMetastoreConfig setEnableColumnStatistics(boolean enableColumnStatistics)\n+    {\n+        this.enableColumnStatistics = enableColumnStatistics;\n+        return this;\n+    }\n+\n+    @Min(1)\n+    public int getReadStatisticsThreads()\n+    {\n+        return readStatisticsThreads;\n+    }\n+\n+    @Config(\"hive.metastore.glue.read-statistics-threads\")\n+    @ConfigDescription(\"Number of threads for parallel read column statistics fetches from Glue\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0MDYwMg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559340602", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @ConfigDescription(\"Number of threads for parallel column writing statistics fetches from Glue\")\n          \n          \n            \n                @ConfigDescription(\"Number of threads for parallel statistics writes to Glue\")", "author": "hashhar", "createdAt": "2021-01-18T06:28:55Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastoreConfig.java", "diffHunk": "@@ -242,4 +245,45 @@ public GlueHiveMetastoreConfig setAssumeCanonicalPartitionKeys(boolean assumeCan\n         this.assumeCanonicalPartitionKeys = assumeCanonicalPartitionKeys;\n         return this;\n     }\n+\n+    public boolean getEnableColumnStatistics()\n+    {\n+        return enableColumnStatistics;\n+    }\n+\n+    @Config(\"hive.metastore.glue.enable-column-stat\")\n+    @ConfigDescription(\"Enabled statistics for glue tables\")\n+    public GlueHiveMetastoreConfig setEnableColumnStatistics(boolean enableColumnStatistics)\n+    {\n+        this.enableColumnStatistics = enableColumnStatistics;\n+        return this;\n+    }\n+\n+    @Min(1)\n+    public int getReadStatisticsThreads()\n+    {\n+        return readStatisticsThreads;\n+    }\n+\n+    @Config(\"hive.metastore.glue.read-statistics-threads\")\n+    @ConfigDescription(\"Number of threads for parallel read column statistics fetches from Glue\")\n+    public GlueHiveMetastoreConfig setReadStatisticsThreads(int getReadStatisticsThreads)\n+    {\n+        this.readStatisticsThreads = getReadStatisticsThreads;\n+        return this;\n+    }\n+\n+    @Min(1)\n+    public int getWriteStatisticsThreads()\n+    {\n+        return writeStatisticsThreads;\n+    }\n+\n+    @Config(\"hive.metastore.glue.write-statistics-threads\")\n+    @ConfigDescription(\"Number of threads for parallel column writing statistics fetches from Glue\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0MDc2MA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559340760", "bodyText": "Please revert. This is just a syntax change.", "author": "hashhar", "createdAt": "2021-01-18T06:29:32Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueMetastoreModule.java", "diffHunk": "@@ -46,19 +46,28 @@\n     protected void setup(Binder binder)\n     {\n         configBinder(binder).bindConfig(GlueHiveMetastoreConfig.class);\n-\n-        newOptionalBinder(binder, GlueColumnStatisticsProvider.class)\n-                .setDefault().to(DisabledGlueColumnStatisticsProvider.class).in(Scopes.SINGLETON);\n-\n         newOptionalBinder(binder, Key.get(RequestHandler2.class, ForGlueHiveMetastore.class));\n \n-        newOptionalBinder(binder, Key.get(new TypeLiteral<Predicate<Table>>() {}, ForGlueHiveMetastore.class))\n+        newOptionalBinder(binder, Key.get(new TypeLiteral<Predicate<Table>>()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0MTIxOA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559341218", "bodyText": "MILLIS_PER_DAY?", "author": "hashhar", "createdAt": "2021-01-18T06:31:02Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.prestosql.plugin.hive.HiveType;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long DAY_TO_MILLISECOND_FACTOR = TimeUnit.DAYS.toMillis(1);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0MTM0MQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559341341", "bodyText": "Rename to trinoColumnStats.", "author": "hashhar", "createdAt": "2021-01-18T06:31:29Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.prestosql.plugin.hive.HiveType;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long DAY_TO_MILLISECOND_FACTOR = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> prestoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(prestoColumnStats.size());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM1MjU1NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559352555", "bodyText": "Are the various allowed column types documented somewhere? Can there be a case where a HiveType isn't supported by Glue?", "author": "hashhar", "createdAt": "2021-01-18T07:06:35Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.prestosql.plugin.hive.HiveType;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long DAY_TO_MILLISECOND_FACTOR = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> prestoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(prestoColumnStats.size());\n+\n+        prestoColumnStats.forEach((columnName, statistics) -> {\n+            final Optional<Column> column = columnByName(partition, columnName);\n+            HiveType columnType = column.get().getType();\n+\n+            ColumnStatistics catalogColumnStatistics = new ColumnStatistics();\n+\n+            catalogColumnStatistics.setColumnName(columnName);\n+            catalogColumnStatistics.setColumnType(columnType.toString());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM1MjYzMg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559352632", "bodyText": "Same in toGlueColumnStatistics.", "author": "hashhar", "createdAt": "2021-01-18T07:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM1MjU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc3Nzc1MQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559777751", "bodyText": "The switch case follow the aws glue api reference, if the type is not supported a TrinoException with HIVE_INVALID_METADATA is thrown in both toGlueColumnStatisticsData and fromGlueColumnStatistics,\nDo you think we can handle this better ? Should I also add the docs link as reference to the to/from methods ?\napi reference: https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html#aws-glue-api-common-ColumnStatistics", "author": "GaruGaru", "createdAt": "2021-01-18T20:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM1MjU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDcxMzMyOQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560713329", "bodyText": "This makes sense. Consider this resolved.", "author": "hashhar", "createdAt": "2021-01-20T06:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM1MjU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM1MzY1Mg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559353652", "bodyText": "We can instead loop on partition.getColumns to avoid the lookup in columnByName.\nI don't think there can be cases where partition.getColumns doesn't match columns in prestoColumnStats. Please correct me if I'm wrong.", "author": "hashhar", "createdAt": "2021-01-18T07:09:35Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.prestosql.plugin.hive.HiveType;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long DAY_TO_MILLISECOND_FACTOR = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> prestoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(prestoColumnStats.size());\n+\n+        prestoColumnStats.forEach((columnName, statistics) -> {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM1NTU4Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559355583", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static ColumnStatisticsData getGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n          \n          \n            \n                private static ColumnStatisticsData toGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n          \n      \n    \n    \n  \n\nnit: Rename the method to follow the fromXXX and toXXX pattern.", "author": "hashhar", "createdAt": "2021-01-18T07:15:07Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.prestosql.plugin.hive.HiveType;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long DAY_TO_MILLISECOND_FACTOR = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> prestoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(prestoColumnStats.size());\n+\n+        prestoColumnStats.forEach((columnName, statistics) -> {\n+            final Optional<Column> column = columnByName(partition, columnName);\n+            HiveType columnType = column.get().getType();\n+\n+            ColumnStatistics catalogColumnStatistics = new ColumnStatistics();\n+\n+            catalogColumnStatistics.setColumnName(columnName);\n+            catalogColumnStatistics.setColumnType(columnType.toString());\n+            ColumnStatisticsData catalogColumnStatisticsData = getGlueColumnStatisticsData(statistics, columnType, rowCount);\n+            catalogColumnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+            catalogColumnStatistics.setAnalyzedTime(new Date());\n+            catalogColumnStatisticsList.add(catalogColumnStatistics);\n+        });\n+\n+        return catalogColumnStatisticsList;\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> prestoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(prestoColumnStats.size());\n+\n+        prestoColumnStats.forEach((columnName, statistics) -> {\n+            HiveType columnType = table.getColumn(columnName).get().getType();\n+            ColumnStatistics catalogColumnStatistics = new ColumnStatistics();\n+\n+            catalogColumnStatistics.setColumnName(columnName);\n+            catalogColumnStatistics.setColumnType(columnType.toString());\n+            ColumnStatisticsData catalogColumnStatisticsData = getGlueColumnStatisticsData(statistics, columnType, rowCount);\n+            catalogColumnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+            catalogColumnStatistics.setAnalyzedTime(new Date());\n+\n+            catalogColumnStatisticsList.add(catalogColumnStatistics);\n+        });\n+\n+        return catalogColumnStatisticsList;\n+    }\n+\n+    private static Optional<Column> columnByName(Partition partition, String columnName)\n+    {\n+        for (Column column : partition.getColumns()) {\n+            if (column.getName().equals(columnName)) {\n+                return Optional.of(column);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new PrestoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData getGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM1NjcyMw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559356723", "bodyText": "Someone more familiar with datetime gotchas should take a look at this.", "author": "hashhar", "createdAt": "2021-01-18T07:17:51Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.prestosql.plugin.hive.HiveType;\n+import io.prestosql.plugin.hive.metastore.Column;\n+import io.prestosql.plugin.hive.metastore.HiveColumnStatistics;\n+import io.prestosql.plugin.hive.metastore.Partition;\n+import io.prestosql.plugin.hive.metastore.Table;\n+import io.prestosql.spi.PrestoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.prestosql.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long DAY_TO_MILLISECOND_FACTOR = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> prestoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(prestoColumnStats.size());\n+\n+        prestoColumnStats.forEach((columnName, statistics) -> {\n+            final Optional<Column> column = columnByName(partition, columnName);\n+            HiveType columnType = column.get().getType();\n+\n+            ColumnStatistics catalogColumnStatistics = new ColumnStatistics();\n+\n+            catalogColumnStatistics.setColumnName(columnName);\n+            catalogColumnStatistics.setColumnType(columnType.toString());\n+            ColumnStatisticsData catalogColumnStatisticsData = getGlueColumnStatisticsData(statistics, columnType, rowCount);\n+            catalogColumnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+            catalogColumnStatistics.setAnalyzedTime(new Date());\n+            catalogColumnStatisticsList.add(catalogColumnStatistics);\n+        });\n+\n+        return catalogColumnStatisticsList;\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> prestoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(prestoColumnStats.size());\n+\n+        prestoColumnStats.forEach((columnName, statistics) -> {\n+            HiveType columnType = table.getColumn(columnName).get().getType();\n+            ColumnStatistics catalogColumnStatistics = new ColumnStatistics();\n+\n+            catalogColumnStatistics.setColumnName(columnName);\n+            catalogColumnStatistics.setColumnType(columnType.toString());\n+            ColumnStatisticsData catalogColumnStatisticsData = getGlueColumnStatisticsData(statistics, columnType, rowCount);\n+            catalogColumnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+            catalogColumnStatistics.setAnalyzedTime(new Date());\n+\n+            catalogColumnStatisticsList.add(catalogColumnStatistics);\n+        });\n+\n+        return catalogColumnStatisticsList;\n+    }\n+\n+    private static Optional<Column> columnByName(Partition partition, String columnName)\n+    {\n+        for (Column column : partition.getColumns()) {\n+            if (column.getName().equals(columnName)) {\n+                return Optional.of(column);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new PrestoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData getGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n+    {\n+        TypeInfo typeInfo = columnType.getTypeInfo();\n+        checkArgument(typeInfo.getCategory() == PRIMITIVE, \"unsupported type: %s\", columnType);\n+\n+        ColumnStatisticsData catalogColumnStatisticsData = new ColumnStatisticsData();\n+\n+        switch (((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory()) {\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = new BooleanColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBooleanData::setNumberOfNulls);\n+                statistics.getBooleanStatistics().ifPresent(booleanStatistics -> {\n+                    booleanStatistics.getFalseCount().ifPresent(catalogBooleanData::setNumberOfFalses);\n+                    booleanStatistics.getTrueCount().ifPresent(catalogBooleanData::setNumberOfTrues);\n+                });\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BOOLEAN.toString());\n+                catalogColumnStatisticsData.setBooleanColumnStatisticsData(catalogBooleanData);\n+                break;\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = new BinaryColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBinaryData::setNumberOfNulls);\n+                catalogBinaryData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogBinaryData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BINARY.toString());\n+                catalogColumnStatisticsData.setBinaryColumnStatisticsData(catalogBinaryData);\n+                break;\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = new DateColumnStatisticsData();\n+                statistics.getDateStatistics().ifPresent(dateStatistics -> {\n+                    dateStatistics.getMin().ifPresent(value -> catalogDateData.setMinimumValue(localDateToDate(value)));\n+                    dateStatistics.getMax().ifPresent(value -> catalogDateData.setMaximumValue(localDateToDate(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDateData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDateData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DATE.toString());\n+                catalogColumnStatisticsData.setDateColumnStatisticsData(catalogDateData);\n+                break;\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = new DecimalColumnStatisticsData();\n+                statistics.getDecimalStatistics().ifPresent(decimalStatistics -> {\n+                    decimalStatistics.getMin().ifPresent(value -> catalogDecimalData.setMinimumValue(bigDecimalToGlueDecimal(value)));\n+                    decimalStatistics.getMax().ifPresent(value -> catalogDecimalData.setMaximumValue(bigDecimalToGlueDecimal(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDecimalData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDecimalData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DECIMAL.toString());\n+                catalogColumnStatisticsData.setDecimalColumnStatisticsData(catalogDecimalData);\n+                break;\n+            case FLOAT:\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = new DoubleColumnStatisticsData();\n+                statistics.getDoubleStatistics().ifPresent(doubleStatistics -> {\n+                    doubleStatistics.getMin().ifPresent(catalogDoubleData::setMinimumValue);\n+                    doubleStatistics.getMax().ifPresent(catalogDoubleData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDoubleData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDoubleData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DOUBLE.toString());\n+                catalogColumnStatisticsData.setDoubleColumnStatisticsData(catalogDoubleData);\n+                break;\n+            case BYTE:\n+            case SHORT:\n+            case INT:\n+            case LONG:\n+            case TIMESTAMP:\n+                LongColumnStatisticsData catalogLongData = new LongColumnStatisticsData();\n+                statistics.getIntegerStatistics().ifPresent(integerStatistics -> {\n+                    integerStatistics.getMin().ifPresent(catalogLongData::setMinimumValue);\n+                    integerStatistics.getMax().ifPresent(catalogLongData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogLongData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogLongData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.LONG.toString());\n+                catalogColumnStatisticsData.setLongColumnStatisticsData(catalogLongData);\n+                break;\n+            case VARCHAR:\n+            case CHAR:\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = new StringColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogStringData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogStringData::setNumberOfDistinctValues);\n+                catalogStringData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogStringData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.STRING.toString());\n+                catalogColumnStatisticsData.setStringColumnStatisticsData(catalogStringData);\n+                break;\n+            default:\n+                throw new PrestoException(HIVE_INVALID_METADATA, \"Invalid column statistics type: \" + statistics);\n+        }\n+        return catalogColumnStatisticsData;\n+    }\n+\n+    private static DecimalNumber bigDecimalToGlueDecimal(BigDecimal decimal)\n+    {\n+        Decimal hiveDecimal = new Decimal((short) decimal.scale(), ByteBuffer.wrap(decimal.unscaledValue().toByteArray()));\n+        DecimalNumber catalogDecimal = new DecimalNumber();\n+        catalogDecimal.setUnscaledValue(ByteBuffer.wrap(hiveDecimal.getUnscaled()));\n+        catalogDecimal.setScale((int) hiveDecimal.getScale());\n+        return catalogDecimal;\n+    }\n+\n+    private static Optional<BigDecimal> glueDecimalToBigDecimal(DecimalNumber catalogDecimal)\n+    {\n+        Decimal decimal = new Decimal();\n+        decimal.setUnscaled(catalogDecimal.getUnscaledValue());\n+        decimal.setScale(catalogDecimal.getScale().shortValue());\n+        return Optional.of(new BigDecimal(new BigInteger(decimal.getUnscaled()), decimal.getScale()));\n+    }\n+\n+    private static Optional<LocalDate> dateToLocalDate(Date date)\n+    {\n+        long daysSinceEpoch = date.getTime() / DAY_TO_MILLISECOND_FACTOR;\n+        return Optional.of(LocalDate.ofEpochDay(daysSinceEpoch));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4Mjk0Nw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559782947", "bodyText": "We may use  LocalDate.ofInstant but I'm not sure how to handle the ZoneId parameter", "author": "GaruGaru", "createdAt": "2021-01-18T20:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM1NjcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM2MDYwMw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559360603", "bodyText": "Can we then change this to an assertThat(super.testUpdateTableColumnStatisticsEmptyOptionalFields()).throws(xxx)?\nThat way if Glue's behaviour changes in future we'll know that we can/need to change our impl.\nSame for other commented out tests.", "author": "hashhar", "createdAt": "2021-01-18T07:28:11Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/metastore/glue/TestHiveGlueMetastore.java", "diffHunk": "@@ -152,34 +154,59 @@ public void testRenameTable()\n         // rename table is not yet supported by Glue\n     }\n \n-    @Override\n-    public void testPartitionStatisticsSampling()\n-    {\n-        // Glue metastore does not support column level statistics\n-    }\n-\n     @Override\n     public void testUpdateTableColumnStatistics()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        // The original implementation AbstractTestHiveClient#testUpdateTableColumnStatistics assumes each update call to metastore would override\n+        // the previous update call but this is not entirely true for Glue.\n+        // For example, there are 5 columns of a table. if you update 2 columns and then update the remaining 3 columns in two separate calls.\n+        // The second update call would not override the first update call (assume the first 2 and remaining 3 columns are exclusive).\n+        // Following this rationale, provide an empty column stat does not clear all the existing column stats.\n+        // (Glue actually does not accept the empty column stat).\n+        SchemaTableName tableName = temporaryTable(\"update_table_column_statistics\");\n+        try {\n+            doCreateEmptyTable(tableName, ORC, STATISTICS_TABLE_COLUMNS);\n+            // STATISTICS_1_1 must be subset of STATISTICS_1\n+            testUpdateTableStatistics(tableName, EMPTY_TABLE_STATISTICS, STATISTICS_1_1, STATISTICS_1);\n+        }\n+        finally {\n+            dropTable(tableName);\n+        }\n     }\n \n     @Override\n     public void testUpdateTableColumnStatisticsEmptyOptionalFields()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        // this test is not really meaningful for Glue, for numeric columns, min/max stat should always be available\n+        // The only exception is when all rows are NULLs. Glue requires min/max to be set.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4NjQ2OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559786469", "bodyText": "Agree, but we should also be careful with this since glue is returning http status code 500 so this case is not handled by their api yet, I've added some specific check on the error message to address this", "author": "GaruGaru", "createdAt": "2021-01-18T20:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM2MDYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM2MjY4NA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559362684", "bodyText": "Does the change suggested in updateTableColumnStatistics allow us to remove this boolean control variable?\nI'm not in favour of using boolean arguments to decide method behaviour.", "author": "hashhar", "createdAt": "2021-01-18T07:33:26Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueColumnStatisticsProvider.java", "diffHunk": "@@ -32,7 +30,7 @@\n \n     Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition);\n \n-    void updateTableColumnStatistics(TableInput table, Map<String, HiveColumnStatistics> columnStatistics);\n+    void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics);\n \n-    void updatePartitionStatistics(PartitionInput partition, Map<String, HiveColumnStatistics> columnStatistics);\n+    void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> columnStatistics, boolean forPartitionCreation);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4NzYxNQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559787615", "bodyText": "Totally agree with removing the boolean flag, the proposed change should address this", "author": "GaruGaru", "createdAt": "2021-01-18T20:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM2MjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4NzQ0Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r559787443", "bodyText": "throw new SkipException would be more appropriate, but i'd still want to understand better what is supposed to be tested here and cannot be", "author": "findepi", "createdAt": "2021-01-18T20:44:07Z", "path": "plugin/trino-hive/src/test/java/io/trino/plugin/hive/metastore/glue/TestHiveGlueMetastore.java", "diffHunk": "@@ -152,34 +154,59 @@ public void testRenameTable()\n         // rename table is not yet supported by Glue\n     }\n \n-    @Override\n-    public void testPartitionStatisticsSampling()\n-    {\n-        // Glue metastore does not support column level statistics\n-    }\n-\n     @Override\n     public void testUpdateTableColumnStatistics()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        // The original implementation AbstractTestHiveClient#testUpdateTableColumnStatistics assumes each update call to metastore would override\n+        // the previous update call but this is not entirely true for Glue.\n+        // For example, there are 5 columns of a table. if you update 2 columns and then update the remaining 3 columns in two separate calls.\n+        // The second update call would not override the first update call (assume the first 2 and remaining 3 columns are exclusive).\n+        // Following this rationale, provide an empty column stat does not clear all the existing column stats.\n+        // (Glue actually does not accept the empty column stat).\n+        SchemaTableName tableName = temporaryTable(\"update_table_column_statistics\");\n+        try {\n+            doCreateEmptyTable(tableName, ORC, STATISTICS_TABLE_COLUMNS);\n+            // STATISTICS_1_1 must be subset of STATISTICS_1\n+            testUpdateTableStatistics(tableName, EMPTY_TABLE_STATISTICS, STATISTICS_1_1, STATISTICS_1);\n+        }\n+        finally {\n+            dropTable(tableName);\n+        }\n     }\n \n     @Override\n     public void testUpdateTableColumnStatisticsEmptyOptionalFields()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        // this test is not really meaningful for Glue, for numeric columns, min/max stat should always be available\n+        // The only exception is when all rows are NULLs. Glue requires min/max to be set.\n     }\n \n     @Override\n-    public void testUpdatePartitionColumnStatistics()\n+    public void testUpdatePartitionColumnStatisticsEmptyOptionalFields()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        // this test is not really meaningful for Glue, for numeric columns, min/max stat should always be available\n+        // The only exception is when all rows are NULLs. Glue requires min/max to be set.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDM3MDIyNA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560370224", "bodyText": "This is kinda strange, from my understanding here the test try to perform a statistics update for all the columns but without min/max values.\nMin / Max values are actually optional according to the docs .\nBut the Glue api answer with an Status Code: 500; Error Code: InternalServiceException Without giving much context.\nRequests were all the statistics (min, max, nulls ...) are specified are completing correctly", "author": "GaruGaru", "createdAt": "2021-01-19T17:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4NzQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU4MjQyOQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569582429", "bodyText": "@GaruGaru knowing the deficiency of Glue can we make the code write minimal/maximal value for a type if actual min/max is not present in HiveColumnStatistics?\nSo for BIGINT we would write -2^63/2^63 - 1 for INTEGER -2^31``/2^31 - 1` ... and so on.", "author": "losipiuk", "createdAt": "2021-02-03T17:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4NzQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTk2MTcwMg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571961702", "bodyText": "@GaruGaru has this one been addressed?", "author": "losipiuk", "createdAt": "2021-02-08T11:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc4NzQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDcwNDAxNA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560704014", "bodyText": "Add static import for fromGlueColumnStatistics.\nAlso in getPartitionColumnStatistics.", "author": "hashhar", "createdAt": "2021-01-20T06:18:24Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -92,17 +98,14 @@ public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catal\n             return glueClient.getColumnStatisticsForTable(request);\n         }, readExecutor)));\n \n-        final ImmutableList.Builder<ColumnStatistics> columnStatsBuilder = ImmutableList.builder();\n+        final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+        final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n         for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n-            final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, PrestoException.class);\n-            columnStatsBuilder.addAll(tableColumnsStats.getColumnStatisticsList());\n+            final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+            tableColumnsStats.getColumnStatisticsList()\n+                    .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDcwNDc5Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560704793", "bodyText": "How does the statistics object look when logged?\nWould it be more useful to just log ((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory()?", "author": "hashhar", "createdAt": "2021-01-20T06:20:31Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -279,7 +279,7 @@ private static ColumnStatisticsData getGlueColumnStatisticsData(HiveColumnStatis\n                 catalogColumnStatisticsData.setStringColumnStatisticsData(catalogStringData);\n                 break;\n             default:\n-                throw new PrestoException(HIVE_INVALID_METADATA, \"Invalid column statistics type: \" + statistics);\n+                throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics type: \" + statistics);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDcwNzc0Mg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r560707742", "bodyText": "I'd keep the comment about why this fails. Glue requires min/max to be set or more accurately Glue doesn't have any optional fields in statistics.\nBut this doesn't match the documentation from AWS somehow. They mention min/max as Required: No.\nIf it's possible can you take a look at the response returned from AWS by enabling their debug logging as decribed at https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/java-dg-logging.html#sdk-net-logging-request-response.", "author": "hashhar", "createdAt": "2021-01-20T06:29:13Z", "path": "plugin/trino-hive/src/test/java/io/trino/plugin/hive/metastore/glue/TestHiveGlueMetastore.java", "diffHunk": "@@ -179,16 +179,18 @@ public void testUpdateTableColumnStatistics()\n     public void testUpdateTableColumnStatisticsEmptyOptionalFields()\n             throws Exception\n     {\n-        // this test is not really meaningful for Glue, for numeric columns, min/max stat should always be available\n-        // The only exception is when all rows are NULLs. Glue requires min/max to be set.\n+        assertThatThrownBy(super::testUpdateTableColumnStatisticsEmptyOptionalFields)\n+                .hasMessageContaining(\"Service: AWSGlue; Status Code: 500; Error Code: InternalServiceException;\")\n+                .isInstanceOf(TrinoException.class);\n     }\n \n     @Override\n     public void testUpdatePartitionColumnStatisticsEmptyOptionalFields()\n             throws Exception\n     {\n-        // this test is not really meaningful for Glue, for numeric columns, min/max stat should always be available\n-        // The only exception is when all rows are NULLs. Glue requires min/max to be set.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA5Nzk4Ng==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562097986", "bodyText": "please setup that in the module:\n        installModuleIf(\n                HiveConfig.class,\n                HiveConfig::isTableStatisticsEnabled,\n                innerBinder -> innerBinder.bind(GlueColumnStatisticsProvider.class).to(DefaultGlueColumnStatisticsProvider.class).in(Scopes.SINGLETON),\n                innerBinder -> innerBinder.bind(GlueColumnStatisticsProvider.class).to(DisabledGlueColumnStatisticsProvider.class).in(Scopes.SINGLETON));\n\nshould do", "author": "losipiuk", "createdAt": "2021-01-21T18:17:31Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -185,10 +189,16 @@ public GlueHiveMetastore(\n         this.defaultDir = glueConfig.getDefaultWarehouseDir();\n         this.catalogId = glueConfig.getCatalogId().orElse(null);\n         this.partitionSegments = glueConfig.getPartitionSegments();\n-        this.executor = requireNonNull(executor, \"executor is null\");\n-        this.columnStatisticsProvider = requireNonNull(columnStatisticsProvider, \"columnStatisticsProvider is null\");\n+        this.partitionsReadExecutor = requireNonNull(partitionsReadExecutor, \"executor is null\");\n         this.assumeCanonicalPartitionKeys = glueConfig.isAssumeCanonicalPartitionKeys();\n         this.tableFilter = requireNonNull(tableFilter, \"tableFilter is null\");\n+        this.enableColumnStatistics = hiveConfig.isTableStatisticsEnabled();\n+        if (this.enableColumnStatistics) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEwMjkxOQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562102919", "bodyText": "Oh I see that it would require some more refactor regarding stats so those are guice bound too. I guess it can be done as a followup.", "author": "losipiuk", "createdAt": "2021-01-21T18:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA5Nzk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEwNjExNg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562106116", "bodyText": "Do we need those configuration parameters? Do we expect that we would need to bump it? If not I would rather not have those. The less config params the better.", "author": "losipiuk", "createdAt": "2021-01-21T18:30:02Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/GlueHiveMetastoreConfig.java", "diffHunk": "@@ -40,6 +40,8 @@\n     private Optional<String> catalogId = Optional.empty();\n     private int partitionSegments = 5;\n     private int getPartitionThreads = 20;\n+    private int readStatisticsThreads = 1;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQ4NzYzOA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562487638", "bodyText": "I agree with having as few params as possible but this parameters are useful for performance tuning when working with tables with an high amount of columns, also making the concurrency configurable should help users to deal with the AWS Glue rate limits.", "author": "GaruGaru", "createdAt": "2021-01-22T09:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEwNjExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEwODE3Mg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562108172", "bodyText": "It feels to me that you should not need this one as it is bind in HIveModule which should be always present.", "author": "losipiuk", "createdAt": "2021-01-21T18:33:21Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/GlueMetastoreModule.java", "diffHunk": "@@ -46,10 +47,7 @@\n     protected void setup(Binder binder)\n     {\n         configBinder(binder).bindConfig(GlueHiveMetastoreConfig.class);\n-\n-        newOptionalBinder(binder, GlueColumnStatisticsProvider.class)\n-                .setDefault().to(DisabledGlueColumnStatisticsProvider.class).in(Scopes.SINGLETON);\n-\n+        configBinder(binder).bindConfig(HiveConfig.class);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY2OTk0OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562669949", "bodyText": "Do we have a test that verify this ?", "author": "GaruGaru", "createdAt": "2021-01-22T14:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEwODE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU1NTcyMg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r563555722", "bodyText": "I do not believe we have. AFAIK (and I could not find any) we have no proper product-tests coverage for Trino run agains AWS.\ncc: @findepi", "author": "losipiuk", "createdAt": "2021-01-25T09:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEwODE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzcwOTkxNQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r563709915", "bodyText": "Correct, we have only non-product tests, like TestHiveGlueMetastore\nthis is tracked by #5426", "author": "findepi", "createdAt": "2021-01-25T13:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEwODE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjExNjEwOQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562116109", "bodyText": "those are not used anywhere.", "author": "losipiuk", "createdAt": "2021-01-21T18:46:23Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/GlueMetastoreModule.java", "diffHunk": "@@ -59,6 +57,17 @@ protected void setup(Binder binder)\n                 .annotatedWith(ForRecordingHiveMetastore.class)\n                 .to(GlueHiveMetastore.class)\n                 .in(Scopes.SINGLETON);\n+\n+        binder.bind(HiveMetastore.class)\n+                .annotatedWith(ForGlueColumnStatisticsRead.class)\n+                .to(GlueHiveMetastore.class)\n+                .in(Scopes.SINGLETON);\n+\n+        binder.bind(HiveMetastore.class)\n+                .annotatedWith(ForGlueColumnStatisticsWrite.class)\n+                .to(GlueHiveMetastore.class)\n+                .in(Scopes.SINGLETON);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY2OTYwMQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562669601", "bodyText": "Used in GlueHiveMetastore's constructor", "author": "GaruGaru", "createdAt": "2021-01-22T14:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjExNjEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU0NzI2Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r563547263", "bodyText": "The Executors (which are bound below) are used in GlueHiveMetastore. This one is adding binging for HiveMetastore (annotated with ForGlueColumnStatisticsRead and ForGlueColumnStatisticsWrite).", "author": "losipiuk", "createdAt": "2021-01-25T08:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjExNjEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjExOTU3NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562119575", "bodyText": "drop final modifiers on non-fields. We do not have a convention in Trino to use them.", "author": "losipiuk", "createdAt": "2021-01-21T18:51:45Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(trinoColumnStats.size());\n+\n+        trinoColumnStats.forEach((columnName, statistics) -> {\n+            final Optional<Column> column = columnByName(partition, columnName);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEyMDQ0Ng==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562120446", "bodyText": "extract helper method to create executor given number of threads and name. All three look exactly the same.", "author": "losipiuk", "createdAt": "2021-01-21T18:53:13Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/GlueMetastoreModule.java", "diffHunk": "@@ -75,7 +84,33 @@ public Executor createExecutor(CatalogName catalogName, GlueHiveMetastoreConfig\n             return directExecutor();\n         }\n         return new BoundedExecutor(\n-                newCachedThreadPool(daemonThreadsNamed(\"hive-glue-%s\")),\n+                newCachedThreadPool(daemonThreadsNamed(\"hive-glue-partitions-%s\")),\n                 hiveConfig.getGetPartitionThreads());\n     }\n+\n+    @Provides\n+    @Singleton\n+    @ForGlueColumnStatisticsRead\n+    public Executor createStatisticsReadExecutor(CatalogName catalogName, GlueHiveMetastoreConfig hiveConfig)\n+    {\n+        if (hiveConfig.getReadStatisticsThreads() == 1) {\n+            return directExecutor();\n+        }\n+        return new BoundedExecutor(\n+                newCachedThreadPool(daemonThreadsNamed(\"hive-glue-statistics-read-%s\")),\n+                hiveConfig.getReadStatisticsThreads());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEyMjUyNw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562122527", "bodyText": "static import MoreFutures.getFutureValue", "author": "losipiuk", "createdAt": "2021-01-21T18:56:31Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEyNjAxNg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562126016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n          \n          \n            \n                        final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n          \n          \n            \n                        for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n          \n          \n            \n                            final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n          \n          \n            \n                            tableColumnsStats.getColumnStatisticsList()\n          \n          \n            \n                                    .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                        return columnStatsMapBuilder.build();\n          \n          \n            \n                        HiveBasicStatistics tableBasicStatistics = getHiveBasicStatistics(table.getParameters());\n          \n          \n            \n                        ImmutableMap.Builder<String, HiveColumnStatistics> tableColumnStatistics = ImmutableMap.builder();\n          \n          \n            \n                        for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n          \n          \n            \n                            GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n          \n          \n            \n                            for (ColumnStatistics singleColumnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n          \n          \n            \n                                tableColumnStatistics.put(\n          \n          \n            \n                                        singleColumnStatistics.getColumnName(),\n          \n          \n            \n                                        fromGlueColumnStatistics(singleColumnStatistics.getStatisticsData(), tableBasicStatistics.getRowCount()));\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                        return tableColumnStatistics.build();", "author": "losipiuk", "createdAt": "2021-01-21T19:01:58Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEyNjgwMA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562126800", "bodyText": "Please restructure in similar way as above. I think it make the code more readable.", "author": "losipiuk", "createdAt": "2021-01-21T19:03:20Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEyNzc1Nw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562127757", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Write limit for AWS Glue API GetColumnStatisticsForPartition\n          \n          \n            \n                // Read limit for AWS Glue API GetColumnStatisticsForPartition", "author": "losipiuk", "createdAt": "2021-01-21T19:05:04Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEyOTY1NA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562129654", "bodyText": "can you please check if stream.map.collect would not look nicer?", "author": "losipiuk", "createdAt": "2021-01-21T19:08:15Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEzNTQwOQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562135409", "bodyText": "maybe\n                getFutureValue(allOf(writeFutures.toArray(CompletableFuture[]::new)));\n\nI am not super convinced. I would be more if there was allOf which takes a list ....", "author": "losipiuk", "createdAt": "2021-01-21T19:17:57Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(\n+                                new DeleteColumnStatisticsForTableRequest()\n+                                        .withCatalogId(catalogId)\n+                                        .withDatabaseName(table.getDatabaseName())\n+                                        .withTableName(table.getTableName())\n+                                        .withColumnName(column.getName())), writeExecutor))\n+                        .collect(Collectors.toUnmodifiableList());\n+\n+                for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                    MoreFutures.getFutureValue(writeFuture);\n+                }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEzNTg1MA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562135850", "bodyText": "static import runAsync", "author": "losipiuk", "createdAt": "2021-01-21T19:18:43Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEzNjA5MA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562136090", "bodyText": "static import", "author": "losipiuk", "createdAt": "2021-01-21T19:19:02Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(\n+                                new DeleteColumnStatisticsForTableRequest()\n+                                        .withCatalogId(catalogId)\n+                                        .withDatabaseName(table.getDatabaseName())\n+                                        .withTableName(table.getTableName())\n+                                        .withColumnName(column.getName())), writeExecutor))\n+                        .collect(Collectors.toUnmodifiableList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEzNjI1Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562136253", "bodyText": "static import", "author": "losipiuk", "createdAt": "2021-01-21T19:19:21Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(\n+                                new DeleteColumnStatisticsForTableRequest()\n+                                        .withCatalogId(catalogId)\n+                                        .withDatabaseName(table.getDatabaseName())\n+                                        .withTableName(table.getTableName())\n+                                        .withColumnName(column.getName())), writeExecutor))\n+                        .collect(Collectors.toUnmodifiableList());\n+\n+                for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                    MoreFutures.getFutureValue(writeFuture);\n+                }\n+            }\n+\n+            final List<ColumnStatistics> columnStats = GlueStatConverter.toGlueColumnStatistics(table, columnStatistics, tableStats.getRowCount());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjEzNzU5MQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562137591", "bodyText": "missing return?", "author": "losipiuk", "createdAt": "2021-01-21T19:21:30Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(\n+                                new DeleteColumnStatisticsForTableRequest()\n+                                        .withCatalogId(catalogId)\n+                                        .withDatabaseName(table.getDatabaseName())\n+                                        .withTableName(table.getTableName())\n+                                        .withColumnName(column.getName())), writeExecutor))\n+                        .collect(Collectors.toUnmodifiableList());\n+\n+                for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                    MoreFutures.getFutureValue(writeFuture);\n+                }\n+            }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0MDMwOA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562140308", "bodyText": "static import", "author": "losipiuk", "createdAt": "2021-01-21T19:24:47Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(\n+                                new DeleteColumnStatisticsForTableRequest()\n+                                        .withCatalogId(catalogId)\n+                                        .withDatabaseName(table.getDatabaseName())\n+                                        .withTableName(table.getTableName())\n+                                        .withColumnName(column.getName())), writeExecutor))\n+                        .collect(Collectors.toUnmodifiableList());\n+\n+                for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                    MoreFutures.getFutureValue(writeFuture);\n+                }\n+            }\n+\n+            final List<ColumnStatistics> columnStats = GlueStatConverter.toGlueColumnStatistics(table, columnStatistics, tableStats.getRowCount());\n+            final List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            final List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> CompletableFuture.runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(Collectors.toUnmodifiableList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0MDM4NA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562140384", "bodyText": "static import runAsync", "author": "losipiuk", "createdAt": "2021-01-21T19:24:55Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(\n+                                new DeleteColumnStatisticsForTableRequest()\n+                                        .withCatalogId(catalogId)\n+                                        .withDatabaseName(table.getDatabaseName())\n+                                        .withTableName(table.getTableName())\n+                                        .withColumnName(column.getName())), writeExecutor))\n+                        .collect(Collectors.toUnmodifiableList());\n+\n+                for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                    MoreFutures.getFutureValue(writeFuture);\n+                }\n+            }\n+\n+            final List<ColumnStatistics> columnStats = GlueStatConverter.toGlueColumnStatistics(table, columnStatistics, tableStats.getRowCount());\n+            final List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            final List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> CompletableFuture.runAsync(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0NDc2OA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562144768", "bodyText": "name the variables columnChunk", "author": "losipiuk", "createdAt": "2021-01-21T19:32:16Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(\n+                                new DeleteColumnStatisticsForTableRequest()\n+                                        .withCatalogId(catalogId)\n+                                        .withDatabaseName(table.getDatabaseName())\n+                                        .withTableName(table.getTableName())\n+                                        .withColumnName(column.getName())), writeExecutor))\n+                        .collect(Collectors.toUnmodifiableList());\n+\n+                for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                    MoreFutures.getFutureValue(writeFuture);\n+                }\n+            }\n+\n+            final List<ColumnStatistics> columnStats = GlueStatConverter.toGlueColumnStatistics(table, columnStatistics, tableStats.getRowCount());\n+            final List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            final List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> CompletableFuture.runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(Collectors.toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeChunkFuture : writeChunkFutures) {\n+                MoreFutures.getFutureValue(writeChunkFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> updatedColumnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics partitionStats = getHiveBasicStatistics(partition.getParameters());\n+            final List<ColumnStatistics> columnStats = GlueStatConverter.toGlueColumnStatistics(partition, updatedColumnStatistics, partitionStats.getRowCount());\n+\n+            final List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            final List<CompletableFuture<Void>> writePartitionStatsFutures = columnChunks.stream()\n+                    .map(column ->", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0NTA0Mg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562145042", "bodyText": "Why don't we need analogous code in updateTableColumnStatistics?", "author": "losipiuk", "createdAt": "2021-01-21T19:32:47Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(\n+                                new DeleteColumnStatisticsForTableRequest()\n+                                        .withCatalogId(catalogId)\n+                                        .withDatabaseName(table.getDatabaseName())\n+                                        .withTableName(table.getTableName())\n+                                        .withColumnName(column.getName())), writeExecutor))\n+                        .collect(Collectors.toUnmodifiableList());\n+\n+                for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                    MoreFutures.getFutureValue(writeFuture);\n+                }\n+            }\n+\n+            final List<ColumnStatistics> columnStats = GlueStatConverter.toGlueColumnStatistics(table, columnStatistics, tableStats.getRowCount());\n+            final List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            final List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> CompletableFuture.runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(Collectors.toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeChunkFuture : writeChunkFutures) {\n+                MoreFutures.getFutureValue(writeChunkFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> updatedColumnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics partitionStats = getHiveBasicStatistics(partition.getParameters());\n+            final List<ColumnStatistics> columnStats = GlueStatConverter.toGlueColumnStatistics(partition, updatedColumnStatistics, partitionStats.getRowCount());\n+\n+            final List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            final List<CompletableFuture<Void>> writePartitionStatsFutures = columnChunks.stream()\n+                    .map(column ->\n+                            CompletableFuture.runAsync(() -> glueClient.updateColumnStatisticsForPartition(new UpdateColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnStatisticsList(column)), writeExecutor)\n+                    ).collect(Collectors.toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writePartitionStatsFuture : writePartitionStatsFutures) {\n+                MoreFutures.getFutureValue(writePartitionStatsFuture);\n+            }\n+\n+            final boolean partitionExists = partitionExists(partition);\n+            final Map<String, HiveColumnStatistics> currentColumnStatistics = partitionExists ? this.getPartitionColumnStatistics(partition) : Collections.emptyMap();\n+            final Set<String> removedStatistics = difference(currentColumnStatistics.keySet(), updatedColumnStatistics.keySet());\n+\n+            final List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0NTg0Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562145843", "bodyText": "Use ImmutableListBuilder like everywhere", "author": "losipiuk", "createdAt": "2021-01-21T19:34:23Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.airlift.concurrent.MoreFutures;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Write limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            final List<String> columnNames = getAllColumns(table);\n+            final List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(table.getDatabaseName())\n+                        .withTableName(table.getTableName())\n+                        .withColumnNames(partialColumns);\n+\n+                return glueClient.getColumnStatisticsForTable(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForTableResult tableColumnsStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                tableColumnsStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(), GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            final List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                final List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                final GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            final HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            final ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                final GetColumnStatisticsForPartitionResult partitionColumnStats = MoreFutures.getFutureValue(future, TrinoException.class);\n+                partitionColumnStats.getColumnStatisticsList()\n+                        .forEach(col -> columnStatsMapBuilder.put(col.getColumnName(),\n+                                GlueStatConverter.fromGlueColumnStatistics(col.getStatisticsData(), tableStatistics.getRowCount())));\n+            }\n+\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> columnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+\n+            if (columnStatistics.isEmpty()) {\n+                final List<CompletableFuture<Void>> writeFutures = Stream.concat(table.getDataColumns().stream(), table.getPartitionColumns().stream())\n+                        .map(column -> CompletableFuture.runAsync(() -> glueClient.deleteColumnStatisticsForTable(\n+                                new DeleteColumnStatisticsForTableRequest()\n+                                        .withCatalogId(catalogId)\n+                                        .withDatabaseName(table.getDatabaseName())\n+                                        .withTableName(table.getTableName())\n+                                        .withColumnName(column.getName())), writeExecutor))\n+                        .collect(Collectors.toUnmodifiableList());\n+\n+                for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                    MoreFutures.getFutureValue(writeFuture);\n+                }\n+            }\n+\n+            final List<ColumnStatistics> columnStats = GlueStatConverter.toGlueColumnStatistics(table, columnStatistics, tableStats.getRowCount());\n+            final List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            final List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> CompletableFuture.runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(Collectors.toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeChunkFuture : writeChunkFutures) {\n+                MoreFutures.getFutureValue(writeChunkFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> updatedColumnStatistics)\n+    {\n+        try {\n+            final HiveBasicStatistics partitionStats = getHiveBasicStatistics(partition.getParameters());\n+            final List<ColumnStatistics> columnStats = GlueStatConverter.toGlueColumnStatistics(partition, updatedColumnStatistics, partitionStats.getRowCount());\n+\n+            final List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            final List<CompletableFuture<Void>> writePartitionStatsFutures = columnChunks.stream()\n+                    .map(column ->\n+                            CompletableFuture.runAsync(() -> glueClient.updateColumnStatisticsForPartition(new UpdateColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnStatisticsList(column)), writeExecutor)\n+                    ).collect(Collectors.toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writePartitionStatsFuture : writePartitionStatsFutures) {\n+                MoreFutures.getFutureValue(writePartitionStatsFuture);\n+            }\n+\n+            final boolean partitionExists = partitionExists(partition);\n+            final Map<String, HiveColumnStatistics> currentColumnStatistics = partitionExists ? this.getPartitionColumnStatistics(partition) : Collections.emptyMap();\n+            final Set<String> removedStatistics = difference(currentColumnStatistics.keySet(), updatedColumnStatistics.keySet());\n+\n+            final List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> CompletableFuture.runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForPartition(new DeleteColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnName(column)), writeExecutor)\n+                    ).collect(Collectors.toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                MoreFutures.getFutureValue(writeFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    private boolean partitionExists(Partition partition)\n+    {\n+        final BatchGetPartitionResult results = glueClient.batchGetPartition(new BatchGetPartitionRequest()\n+                .withCatalogId(catalogId)\n+                .withDatabaseName(partition.getDatabaseName())\n+                .withTableName(partition.getTableName())\n+                .withPartitionsToGet(\n+                        new PartitionValueList().withValues(partition.getValues())\n+                )\n+        );\n+        return !results.getPartitions().isEmpty() || !results.getUnprocessedKeys().isEmpty();\n+    }\n+\n+    private List<String> getAllColumns(Table table)\n+    {\n+        final List<String> allColumns = new ArrayList<>(table.getDataColumns().size() + table.getPartitionColumns().size());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0ODA3NA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562148074", "bodyText": "this is O(N^2) which with 1000 columns will start to be substantial cost. Pre-build String->Column map", "author": "losipiuk", "createdAt": "2021-01-21T19:38:18Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(trinoColumnStats.size());\n+\n+        trinoColumnStats.forEach((columnName, statistics) -> {\n+            final Optional<Column> column = columnByName(partition, columnName);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0OTY3OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562149679", "bodyText": "Naa - it is only partition columns. So I guess we will not have 1000 of those :)", "author": "losipiuk", "createdAt": "2021-01-21T19:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0ODA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQyMDcxMQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562420711", "bodyText": "Still should be easy to remedy and there's no reason to avoid this unless it's more difficult than expected - #6178 (comment)", "author": "hashhar", "createdAt": "2021-01-22T06:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0ODA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY2ODI2Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562668263", "bodyText": "fixed", "author": "GaruGaru", "createdAt": "2021-01-22T14:29:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0ODA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE1MDA1MA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562150050", "bodyText": "can you extract common part for column and partition stats to helper method?", "author": "losipiuk", "createdAt": "2021-01-21T19:42:02Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(trinoColumnStats.size());\n+\n+        trinoColumnStats.forEach((columnName, statistics) -> {\n+            final Optional<Column> column = columnByName(partition, columnName);\n+            HiveType columnType = column.get().getType();\n+\n+            ColumnStatistics catalogColumnStatistics = new ColumnStatistics();\n+\n+            catalogColumnStatistics.setColumnName(columnName);\n+            catalogColumnStatistics.setColumnType(columnType.toString());\n+            ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+            catalogColumnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+            catalogColumnStatistics.setAnalyzedTime(new Date());\n+            catalogColumnStatisticsList.add(catalogColumnStatistics);\n+        });\n+\n+        return catalogColumnStatisticsList;\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(trinoColumnStats.size());\n+\n+        trinoColumnStats.forEach((columnName, statistics) -> {\n+            HiveType columnType = table.getColumn(columnName).get().getType();\n+            ColumnStatistics catalogColumnStatistics = new ColumnStatistics();\n+\n+            catalogColumnStatistics.setColumnName(columnName);\n+            catalogColumnStatistics.setColumnType(columnType.toString());\n+            ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+            catalogColumnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+            catalogColumnStatistics.setAnalyzedTime(new Date());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE1MDYxNw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562150617", "bodyText": "put this one below columnByName", "author": "losipiuk", "createdAt": "2021-01-21T19:43:01Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(trinoColumnStats.size());\n+\n+        trinoColumnStats.forEach((columnName, statistics) -> {\n+            final Optional<Column> column = columnByName(partition, columnName);\n+            HiveType columnType = column.get().getType();\n+\n+            ColumnStatistics catalogColumnStatistics = new ColumnStatistics();\n+\n+            catalogColumnStatistics.setColumnName(columnName);\n+            catalogColumnStatistics.setColumnType(columnType.toString());\n+            ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+            catalogColumnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+            catalogColumnStatistics.setAnalyzedTime(new Date());\n+            catalogColumnStatisticsList.add(catalogColumnStatistics);\n+        });\n+\n+        return catalogColumnStatisticsList;\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        List<ColumnStatistics> catalogColumnStatisticsList = new ArrayList<>(trinoColumnStats.size());\n+\n+        trinoColumnStats.forEach((columnName, statistics) -> {\n+            HiveType columnType = table.getColumn(columnName).get().getType();\n+            ColumnStatistics catalogColumnStatistics = new ColumnStatistics();\n+\n+            catalogColumnStatistics.setColumnName(columnName);\n+            catalogColumnStatistics.setColumnType(columnType.toString());\n+            ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+            catalogColumnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+            catalogColumnStatistics.setAnalyzedTime(new Date());\n+\n+            catalogColumnStatisticsList.add(catalogColumnStatistics);\n+        });\n+\n+        return catalogColumnStatisticsList;\n+    }\n+\n+    private static Optional<Column> columnByName(Partition partition, String columnName)\n+    {\n+        for (Column column : partition.getColumns()) {\n+            if (column.getName().equals(columnName)) {\n+                return Optional.of(column);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData toGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE1MTkwOQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562151909", "bodyText": "seems not needed. revert", "author": "losipiuk", "createdAt": "2021-01-21T19:45:26Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueToTrinoConverter.java", "diffHunk": "@@ -93,7 +93,7 @@ public static Table convertTable(com.amazonaws.services.glue.model.Table glueTab\n         return tableBuilder.build();\n     }\n \n-    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n+    public static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE1Mzc0Nw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562153747", "bodyText": "this does not seem right? Is that a flow we can get into in real life?", "author": "losipiuk", "createdAt": "2021-01-21T19:48:26Z", "path": "plugin/trino-hive/src/test/java/io/trino/plugin/hive/metastore/glue/TestHiveGlueMetastore.java", "diffHunk": "@@ -152,34 +158,61 @@ public void testRenameTable()\n         // rename table is not yet supported by Glue\n     }\n \n-    @Override\n-    public void testPartitionStatisticsSampling()\n-    {\n-        // Glue metastore does not support column level statistics\n-    }\n-\n     @Override\n     public void testUpdateTableColumnStatistics()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        // The original implementation AbstractTestHiveClient#testUpdateTableColumnStatistics assumes each update call to metastore would override\n+        // the previous update call but this is not entirely true for Glue.\n+        // For example, there are 5 columns of a table. if you update 2 columns and then update the remaining 3 columns in two separate calls.\n+        // The second update call would not override the first update call (assume the first 2 and remaining 3 columns are exclusive).\n+        // Following this rationale, provide an empty column stat does not clear all the existing column stats.\n+        // (Glue actually does not accept the empty column stat).\n+        SchemaTableName tableName = temporaryTable(\"update_table_column_statistics\");\n+        try {\n+            doCreateEmptyTable(tableName, ORC, STATISTICS_TABLE_COLUMNS);\n+            // STATISTICS_1_1 must be subset of STATISTICS_1\n+            testUpdateTableStatistics(tableName, EMPTY_TABLE_STATISTICS, STATISTICS_1_1, STATISTICS_1);\n+        }\n+        finally {\n+            dropTable(tableName);\n+        }\n     }\n \n     @Override\n     public void testUpdateTableColumnStatisticsEmptyOptionalFields()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        assertThatThrownBy(super::testUpdateTableColumnStatisticsEmptyOptionalFields)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE1MzgwNA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r562153804", "bodyText": "same here", "author": "losipiuk", "createdAt": "2021-01-21T19:48:31Z", "path": "plugin/trino-hive/src/test/java/io/trino/plugin/hive/metastore/glue/TestHiveGlueMetastore.java", "diffHunk": "@@ -152,34 +158,61 @@ public void testRenameTable()\n         // rename table is not yet supported by Glue\n     }\n \n-    @Override\n-    public void testPartitionStatisticsSampling()\n-    {\n-        // Glue metastore does not support column level statistics\n-    }\n-\n     @Override\n     public void testUpdateTableColumnStatistics()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        // The original implementation AbstractTestHiveClient#testUpdateTableColumnStatistics assumes each update call to metastore would override\n+        // the previous update call but this is not entirely true for Glue.\n+        // For example, there are 5 columns of a table. if you update 2 columns and then update the remaining 3 columns in two separate calls.\n+        // The second update call would not override the first update call (assume the first 2 and remaining 3 columns are exclusive).\n+        // Following this rationale, provide an empty column stat does not clear all the existing column stats.\n+        // (Glue actually does not accept the empty column stat).\n+        SchemaTableName tableName = temporaryTable(\"update_table_column_statistics\");\n+        try {\n+            doCreateEmptyTable(tableName, ORC, STATISTICS_TABLE_COLUMNS);\n+            // STATISTICS_1_1 must be subset of STATISTICS_1\n+            testUpdateTableStatistics(tableName, EMPTY_TABLE_STATISTICS, STATISTICS_1_1, STATISTICS_1);\n+        }\n+        finally {\n+            dropTable(tableName);\n+        }\n     }\n \n     @Override\n     public void testUpdateTableColumnStatisticsEmptyOptionalFields()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        assertThatThrownBy(super::testUpdateTableColumnStatisticsEmptyOptionalFields)\n+                .hasMessageContaining(\"Service: AWSGlue; Status Code: 500; Error Code: InternalServiceException;\")\n+                .isInstanceOf(TrinoException.class);\n     }\n \n     @Override\n-    public void testUpdatePartitionColumnStatistics()\n+    public void testUpdatePartitionColumnStatisticsEmptyOptionalFields()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        assertThatThrownBy(super::testUpdatePartitionColumnStatisticsEmptyOptionalFields)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTMyNDE4OA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r565324188", "bodyText": "What happens if getPartitionStatistics is called for a non-existent partition?\nThere will be 1 API call on the not exists path but 2 on the exists path. Can we avoid this by using the exception thrown when a partition doesn't exist as a control variable instead of the boolean?\nLots of people run into Glue rate-limits so we should strive to reduce API calls to Glue.", "author": "hashhar", "createdAt": "2021-01-27T13:53:13Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount())\n+                    );\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount())\n+                    );\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(toUnmodifiableList());\n+\n+            getFutureValue(allOf(\n+                    writeChunkFutures.toArray(CompletableFuture[]::new)\n+            ));\n+\n+            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForTable(\n+                                    new DeleteColumnStatisticsForTableRequest()\n+                                            .withCatalogId(catalogId)\n+                                            .withDatabaseName(table.getDatabaseName())\n+                                            .withTableName(table.getTableName())\n+                                            .withColumnName(column)))\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                getFutureValue(writeFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> updatedColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics partitionStats = getHiveBasicStatistics(partition.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(partition, updatedColumnStatistics, partitionStats.getRowCount());\n+\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writePartitionStatsFutures = columnChunks.stream()\n+                    .map(columnChunk ->\n+                            runAsync(() -> glueClient.updateColumnStatisticsForPartition(new UpdateColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnStatisticsList(columnChunk)), writeExecutor)\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writePartitionStatsFuture : writePartitionStatsFutures) {\n+                getFutureValue(writePartitionStatsFuture);\n+            }\n+\n+            boolean partitionExists = partitionExists(partition);\n+            Map<String, HiveColumnStatistics> currentColumnStatistics = partitionExists ? this.getPartitionColumnStatistics(partition) : Collections.emptyMap();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODg4NzgxNw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r568887817", "bodyText": "When called on a non existing partition glue client throw an exception, we may use the exception to check if the partition is present as it will reduce the number of api calls.\nIn getPartitionColumnStatistics we should check for EntityNotFoundException raised by glue client and in that case return an empty partition statistics object, do you think if may be a good compromise between readability and api calls count ?", "author": "GaruGaru", "createdAt": "2021-02-02T19:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTMyNDE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3NDQxNQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569274415", "bodyText": "nit: Reformat to place each argument on separate line.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n          \n          \n            \n                        Partition partition,\n          \n          \n            \n                        Map<String, HiveColumnStatistics> trinoColumnStats,\n          \n          \n            \n                        OptionalLong rowCount)", "author": "hashhar", "createdAt": "2021-02-03T09:52:13Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3NjE5Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569276193", "bodyText": "nit: Reformat\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n          \n          \n            \n                        Table table,\n          \n          \n            \n                        Map<String, HiveColumnStatistics> trinoColumnStats,\n          \n          \n            \n                        OptionalLong rowCount)", "author": "hashhar", "createdAt": "2021-02-03T09:54:38Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxMzM2Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569413363", "bodyText": "Is fromMetastoreNullsCount(nullsCountOfBinary) intentionally missing here (it's used in other branches).", "author": "hashhar", "createdAt": "2021-02-03T13:30:42Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return trinoColumnStats.entrySet().stream()\n+                .map(e -> toColumnStatistics(table.getColumn(e.getKey()).get(), e.getValue(), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    private static ColumnStatistics toColumnStatistics(Column column, HiveColumnStatistics statistics, OptionalLong rowCount)\n+    {\n+        ColumnStatistics columnStatistics = new ColumnStatistics();\n+        HiveType columnType = column.getType();\n+        columnStatistics.setColumnName(column.getName());\n+        columnStatistics.setColumnType(columnType.toString());\n+        ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+        columnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+        columnStatistics.setAnalyzedTime(new Date());\n+        return columnStatistics;\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTEyNjkwNw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571126907", "bodyText": "the nullsCountOfBinary variable is the result of fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls()); in this method is assigned to a variable because the value is used twice", "author": "GaruGaru", "createdAt": "2021-02-05T17:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxMzM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNTYxNw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569415617", "bodyText": "Possible NPE here. Take a look at ThriftMetastoreUtil#fromMetastoreDate.", "author": "hashhar", "createdAt": "2021-02-03T13:34:05Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return trinoColumnStats.entrySet().stream()\n+                .map(e -> toColumnStatistics(table.getColumn(e.getKey()).get(), e.getValue(), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    private static ColumnStatistics toColumnStatistics(Column column, HiveColumnStatistics statistics, OptionalLong rowCount)\n+    {\n+        ColumnStatistics columnStatistics = new ColumnStatistics();\n+        HiveType columnType = column.getType();\n+        columnStatistics.setColumnName(column.getName());\n+        columnStatistics.setColumnType(columnType.toString());\n+        ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+        columnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+        columnStatistics.setAnalyzedTime(new Date());\n+        return columnStatistics;\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData toGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n+    {\n+        TypeInfo typeInfo = columnType.getTypeInfo();\n+        checkArgument(typeInfo.getCategory() == PRIMITIVE, \"unsupported type: %s\", columnType);\n+\n+        ColumnStatisticsData catalogColumnStatisticsData = new ColumnStatisticsData();\n+\n+        switch (((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory()) {\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = new BooleanColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBooleanData::setNumberOfNulls);\n+                statistics.getBooleanStatistics().ifPresent(booleanStatistics -> {\n+                    booleanStatistics.getFalseCount().ifPresent(catalogBooleanData::setNumberOfFalses);\n+                    booleanStatistics.getTrueCount().ifPresent(catalogBooleanData::setNumberOfTrues);\n+                });\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BOOLEAN.toString());\n+                catalogColumnStatisticsData.setBooleanColumnStatisticsData(catalogBooleanData);\n+                break;\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = new BinaryColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBinaryData::setNumberOfNulls);\n+                catalogBinaryData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogBinaryData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BINARY.toString());\n+                catalogColumnStatisticsData.setBinaryColumnStatisticsData(catalogBinaryData);\n+                break;\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = new DateColumnStatisticsData();\n+                statistics.getDateStatistics().ifPresent(dateStatistics -> {\n+                    dateStatistics.getMin().ifPresent(value -> catalogDateData.setMinimumValue(localDateToDate(value)));\n+                    dateStatistics.getMax().ifPresent(value -> catalogDateData.setMaximumValue(localDateToDate(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDateData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDateData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DATE.toString());\n+                catalogColumnStatisticsData.setDateColumnStatisticsData(catalogDateData);\n+                break;\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = new DecimalColumnStatisticsData();\n+                statistics.getDecimalStatistics().ifPresent(decimalStatistics -> {\n+                    decimalStatistics.getMin().ifPresent(value -> catalogDecimalData.setMinimumValue(bigDecimalToGlueDecimal(value)));\n+                    decimalStatistics.getMax().ifPresent(value -> catalogDecimalData.setMaximumValue(bigDecimalToGlueDecimal(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDecimalData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDecimalData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DECIMAL.toString());\n+                catalogColumnStatisticsData.setDecimalColumnStatisticsData(catalogDecimalData);\n+                break;\n+            case FLOAT:\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = new DoubleColumnStatisticsData();\n+                statistics.getDoubleStatistics().ifPresent(doubleStatistics -> {\n+                    doubleStatistics.getMin().ifPresent(catalogDoubleData::setMinimumValue);\n+                    doubleStatistics.getMax().ifPresent(catalogDoubleData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDoubleData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDoubleData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DOUBLE.toString());\n+                catalogColumnStatisticsData.setDoubleColumnStatisticsData(catalogDoubleData);\n+                break;\n+            case BYTE:\n+            case SHORT:\n+            case INT:\n+            case LONG:\n+            case TIMESTAMP:\n+                LongColumnStatisticsData catalogLongData = new LongColumnStatisticsData();\n+                statistics.getIntegerStatistics().ifPresent(integerStatistics -> {\n+                    integerStatistics.getMin().ifPresent(catalogLongData::setMinimumValue);\n+                    integerStatistics.getMax().ifPresent(catalogLongData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogLongData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogLongData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.LONG.toString());\n+                catalogColumnStatisticsData.setLongColumnStatisticsData(catalogLongData);\n+                break;\n+            case VARCHAR:\n+            case CHAR:\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = new StringColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogStringData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogStringData::setNumberOfDistinctValues);\n+                catalogStringData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogStringData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.STRING.toString());\n+                catalogColumnStatisticsData.setStringColumnStatisticsData(catalogStringData);\n+                break;\n+            default:\n+                throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics type: \" + statistics);\n+        }\n+        return catalogColumnStatisticsData;\n+    }\n+\n+    private static DecimalNumber bigDecimalToGlueDecimal(BigDecimal decimal)\n+    {\n+        Decimal hiveDecimal = new Decimal((short) decimal.scale(), ByteBuffer.wrap(decimal.unscaledValue().toByteArray()));\n+        DecimalNumber catalogDecimal = new DecimalNumber();\n+        catalogDecimal.setUnscaledValue(ByteBuffer.wrap(hiveDecimal.getUnscaled()));\n+        catalogDecimal.setScale((int) hiveDecimal.getScale());\n+        return catalogDecimal;\n+    }\n+\n+    private static Optional<BigDecimal> glueDecimalToBigDecimal(DecimalNumber catalogDecimal)\n+    {\n+        Decimal decimal = new Decimal();\n+        decimal.setUnscaled(catalogDecimal.getUnscaledValue());\n+        decimal.setScale(catalogDecimal.getScale().shortValue());\n+        return Optional.of(new BigDecimal(new BigInteger(decimal.getUnscaled()), decimal.getScale()));\n+    }\n+\n+    private static Optional<LocalDate> dateToLocalDate(Date date)\n+    {\n+        long daysSinceEpoch = date.getTime() / MILLIS_PER_DAY;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTEyNjg0OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571126849", "bodyText": "Do you think that we can use ThriftMetastoreUtil here or is better to  keep the implementations as separated as possibile ?", "author": "GaruGaru", "createdAt": "2021-02-05T17:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNTYxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTE1MzYxMg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571153612", "bodyText": "I think it's safe to do so. We already use ThriftMetastoreUtil in GlueHiveMetastore for other things.", "author": "hashhar", "createdAt": "2021-02-05T18:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNTYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjg5Mg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569416892", "bodyText": "Possible NPE here. Take a look at ThriftMetastoreUtil#toMetastoreDate.", "author": "hashhar", "createdAt": "2021-02-03T13:35:53Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return trinoColumnStats.entrySet().stream()\n+                .map(e -> toColumnStatistics(table.getColumn(e.getKey()).get(), e.getValue(), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    private static ColumnStatistics toColumnStatistics(Column column, HiveColumnStatistics statistics, OptionalLong rowCount)\n+    {\n+        ColumnStatistics columnStatistics = new ColumnStatistics();\n+        HiveType columnType = column.getType();\n+        columnStatistics.setColumnName(column.getName());\n+        columnStatistics.setColumnType(columnType.toString());\n+        ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+        columnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+        columnStatistics.setAnalyzedTime(new Date());\n+        return columnStatistics;\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData toGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n+    {\n+        TypeInfo typeInfo = columnType.getTypeInfo();\n+        checkArgument(typeInfo.getCategory() == PRIMITIVE, \"unsupported type: %s\", columnType);\n+\n+        ColumnStatisticsData catalogColumnStatisticsData = new ColumnStatisticsData();\n+\n+        switch (((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory()) {\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = new BooleanColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBooleanData::setNumberOfNulls);\n+                statistics.getBooleanStatistics().ifPresent(booleanStatistics -> {\n+                    booleanStatistics.getFalseCount().ifPresent(catalogBooleanData::setNumberOfFalses);\n+                    booleanStatistics.getTrueCount().ifPresent(catalogBooleanData::setNumberOfTrues);\n+                });\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BOOLEAN.toString());\n+                catalogColumnStatisticsData.setBooleanColumnStatisticsData(catalogBooleanData);\n+                break;\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = new BinaryColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBinaryData::setNumberOfNulls);\n+                catalogBinaryData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogBinaryData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BINARY.toString());\n+                catalogColumnStatisticsData.setBinaryColumnStatisticsData(catalogBinaryData);\n+                break;\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = new DateColumnStatisticsData();\n+                statistics.getDateStatistics().ifPresent(dateStatistics -> {\n+                    dateStatistics.getMin().ifPresent(value -> catalogDateData.setMinimumValue(localDateToDate(value)));\n+                    dateStatistics.getMax().ifPresent(value -> catalogDateData.setMaximumValue(localDateToDate(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDateData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDateData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DATE.toString());\n+                catalogColumnStatisticsData.setDateColumnStatisticsData(catalogDateData);\n+                break;\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = new DecimalColumnStatisticsData();\n+                statistics.getDecimalStatistics().ifPresent(decimalStatistics -> {\n+                    decimalStatistics.getMin().ifPresent(value -> catalogDecimalData.setMinimumValue(bigDecimalToGlueDecimal(value)));\n+                    decimalStatistics.getMax().ifPresent(value -> catalogDecimalData.setMaximumValue(bigDecimalToGlueDecimal(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDecimalData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDecimalData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DECIMAL.toString());\n+                catalogColumnStatisticsData.setDecimalColumnStatisticsData(catalogDecimalData);\n+                break;\n+            case FLOAT:\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = new DoubleColumnStatisticsData();\n+                statistics.getDoubleStatistics().ifPresent(doubleStatistics -> {\n+                    doubleStatistics.getMin().ifPresent(catalogDoubleData::setMinimumValue);\n+                    doubleStatistics.getMax().ifPresent(catalogDoubleData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDoubleData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDoubleData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DOUBLE.toString());\n+                catalogColumnStatisticsData.setDoubleColumnStatisticsData(catalogDoubleData);\n+                break;\n+            case BYTE:\n+            case SHORT:\n+            case INT:\n+            case LONG:\n+            case TIMESTAMP:\n+                LongColumnStatisticsData catalogLongData = new LongColumnStatisticsData();\n+                statistics.getIntegerStatistics().ifPresent(integerStatistics -> {\n+                    integerStatistics.getMin().ifPresent(catalogLongData::setMinimumValue);\n+                    integerStatistics.getMax().ifPresent(catalogLongData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogLongData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogLongData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.LONG.toString());\n+                catalogColumnStatisticsData.setLongColumnStatisticsData(catalogLongData);\n+                break;\n+            case VARCHAR:\n+            case CHAR:\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = new StringColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogStringData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogStringData::setNumberOfDistinctValues);\n+                catalogStringData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogStringData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.STRING.toString());\n+                catalogColumnStatisticsData.setStringColumnStatisticsData(catalogStringData);\n+                break;\n+            default:\n+                throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics type: \" + statistics);\n+        }\n+        return catalogColumnStatisticsData;\n+    }\n+\n+    private static DecimalNumber bigDecimalToGlueDecimal(BigDecimal decimal)\n+    {\n+        Decimal hiveDecimal = new Decimal((short) decimal.scale(), ByteBuffer.wrap(decimal.unscaledValue().toByteArray()));\n+        DecimalNumber catalogDecimal = new DecimalNumber();\n+        catalogDecimal.setUnscaledValue(ByteBuffer.wrap(hiveDecimal.getUnscaled()));\n+        catalogDecimal.setScale((int) hiveDecimal.getScale());\n+        return catalogDecimal;\n+    }\n+\n+    private static Optional<BigDecimal> glueDecimalToBigDecimal(DecimalNumber catalogDecimal)\n+    {\n+        Decimal decimal = new Decimal();\n+        decimal.setUnscaled(catalogDecimal.getUnscaledValue());\n+        decimal.setScale(catalogDecimal.getScale().shortValue());\n+        return Optional.of(new BigDecimal(new BigInteger(decimal.getUnscaled()), decimal.getScale()));\n+    }\n+\n+    private static Optional<LocalDate> dateToLocalDate(Date date)\n+    {\n+        long daysSinceEpoch = date.getTime() / MILLIS_PER_DAY;\n+        return Optional.of(LocalDate.ofEpochDay(daysSinceEpoch));\n+    }\n+\n+    private static Date localDateToDate(LocalDate date)\n+    {\n+        long millisecondsSinceEpoch = date.toEpochDay() * MILLIS_PER_DAY;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTEyNjYzMQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571126631", "bodyText": "the ThriftMetastoreUtil#toMetastoreDate doesn't look like it can handle null references for its argument since it calls arg.toEpochDay().\nHow do you think we should handle this particular case ?", "author": "GaruGaru", "createdAt": "2021-02-05T17:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTE1MzAyNQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571153025", "bodyText": "That method doesn't need to check since the caller only calls it if the Optional has a value.\nI think you are safe too since this method isn't ever called with a possible null value. Consider this resolved.", "author": "hashhar", "createdAt": "2021-02-05T18:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxNjg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxODA1NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569418055", "bodyText": "Possible NPE. Let's be defensive here because even though AWS Glue documents these fields to be required but we already know the docs are not 100% correct.", "author": "hashhar", "createdAt": "2021-02-03T13:37:34Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return trinoColumnStats.entrySet().stream()\n+                .map(e -> toColumnStatistics(table.getColumn(e.getKey()).get(), e.getValue(), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    private static ColumnStatistics toColumnStatistics(Column column, HiveColumnStatistics statistics, OptionalLong rowCount)\n+    {\n+        ColumnStatistics columnStatistics = new ColumnStatistics();\n+        HiveType columnType = column.getType();\n+        columnStatistics.setColumnName(column.getName());\n+        columnStatistics.setColumnType(columnType.toString());\n+        ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+        columnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+        columnStatistics.setAnalyzedTime(new Date());\n+        return columnStatistics;\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData toGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n+    {\n+        TypeInfo typeInfo = columnType.getTypeInfo();\n+        checkArgument(typeInfo.getCategory() == PRIMITIVE, \"unsupported type: %s\", columnType);\n+\n+        ColumnStatisticsData catalogColumnStatisticsData = new ColumnStatisticsData();\n+\n+        switch (((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory()) {\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = new BooleanColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBooleanData::setNumberOfNulls);\n+                statistics.getBooleanStatistics().ifPresent(booleanStatistics -> {\n+                    booleanStatistics.getFalseCount().ifPresent(catalogBooleanData::setNumberOfFalses);\n+                    booleanStatistics.getTrueCount().ifPresent(catalogBooleanData::setNumberOfTrues);\n+                });\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BOOLEAN.toString());\n+                catalogColumnStatisticsData.setBooleanColumnStatisticsData(catalogBooleanData);\n+                break;\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = new BinaryColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBinaryData::setNumberOfNulls);\n+                catalogBinaryData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogBinaryData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BINARY.toString());\n+                catalogColumnStatisticsData.setBinaryColumnStatisticsData(catalogBinaryData);\n+                break;\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = new DateColumnStatisticsData();\n+                statistics.getDateStatistics().ifPresent(dateStatistics -> {\n+                    dateStatistics.getMin().ifPresent(value -> catalogDateData.setMinimumValue(localDateToDate(value)));\n+                    dateStatistics.getMax().ifPresent(value -> catalogDateData.setMaximumValue(localDateToDate(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDateData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDateData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DATE.toString());\n+                catalogColumnStatisticsData.setDateColumnStatisticsData(catalogDateData);\n+                break;\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = new DecimalColumnStatisticsData();\n+                statistics.getDecimalStatistics().ifPresent(decimalStatistics -> {\n+                    decimalStatistics.getMin().ifPresent(value -> catalogDecimalData.setMinimumValue(bigDecimalToGlueDecimal(value)));\n+                    decimalStatistics.getMax().ifPresent(value -> catalogDecimalData.setMaximumValue(bigDecimalToGlueDecimal(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDecimalData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDecimalData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DECIMAL.toString());\n+                catalogColumnStatisticsData.setDecimalColumnStatisticsData(catalogDecimalData);\n+                break;\n+            case FLOAT:\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = new DoubleColumnStatisticsData();\n+                statistics.getDoubleStatistics().ifPresent(doubleStatistics -> {\n+                    doubleStatistics.getMin().ifPresent(catalogDoubleData::setMinimumValue);\n+                    doubleStatistics.getMax().ifPresent(catalogDoubleData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDoubleData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDoubleData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DOUBLE.toString());\n+                catalogColumnStatisticsData.setDoubleColumnStatisticsData(catalogDoubleData);\n+                break;\n+            case BYTE:\n+            case SHORT:\n+            case INT:\n+            case LONG:\n+            case TIMESTAMP:\n+                LongColumnStatisticsData catalogLongData = new LongColumnStatisticsData();\n+                statistics.getIntegerStatistics().ifPresent(integerStatistics -> {\n+                    integerStatistics.getMin().ifPresent(catalogLongData::setMinimumValue);\n+                    integerStatistics.getMax().ifPresent(catalogLongData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogLongData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogLongData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.LONG.toString());\n+                catalogColumnStatisticsData.setLongColumnStatisticsData(catalogLongData);\n+                break;\n+            case VARCHAR:\n+            case CHAR:\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = new StringColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogStringData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogStringData::setNumberOfDistinctValues);\n+                catalogStringData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogStringData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.STRING.toString());\n+                catalogColumnStatisticsData.setStringColumnStatisticsData(catalogStringData);\n+                break;\n+            default:\n+                throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics type: \" + statistics);\n+        }\n+        return catalogColumnStatisticsData;\n+    }\n+\n+    private static DecimalNumber bigDecimalToGlueDecimal(BigDecimal decimal)\n+    {\n+        Decimal hiveDecimal = new Decimal((short) decimal.scale(), ByteBuffer.wrap(decimal.unscaledValue().toByteArray()));\n+        DecimalNumber catalogDecimal = new DecimalNumber();\n+        catalogDecimal.setUnscaledValue(ByteBuffer.wrap(hiveDecimal.getUnscaled()));\n+        catalogDecimal.setScale((int) hiveDecimal.getScale());\n+        return catalogDecimal;\n+    }\n+\n+    private static Optional<BigDecimal> glueDecimalToBigDecimal(DecimalNumber catalogDecimal)\n+    {\n+        Decimal decimal = new Decimal();\n+        decimal.setUnscaled(catalogDecimal.getUnscaledValue());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxODMwOA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569418308", "bodyText": "Possible NPE. Let's be defensive here because even though AWS Glue documents these fields to be required but we already know the docs are not 100% correct.", "author": "hashhar", "createdAt": "2021-02-03T13:37:55Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return trinoColumnStats.entrySet().stream()\n+                .map(e -> toColumnStatistics(table.getColumn(e.getKey()).get(), e.getValue(), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    private static ColumnStatistics toColumnStatistics(Column column, HiveColumnStatistics statistics, OptionalLong rowCount)\n+    {\n+        ColumnStatistics columnStatistics = new ColumnStatistics();\n+        HiveType columnType = column.getType();\n+        columnStatistics.setColumnName(column.getName());\n+        columnStatistics.setColumnType(columnType.toString());\n+        ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+        columnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+        columnStatistics.setAnalyzedTime(new Date());\n+        return columnStatistics;\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData toGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n+    {\n+        TypeInfo typeInfo = columnType.getTypeInfo();\n+        checkArgument(typeInfo.getCategory() == PRIMITIVE, \"unsupported type: %s\", columnType);\n+\n+        ColumnStatisticsData catalogColumnStatisticsData = new ColumnStatisticsData();\n+\n+        switch (((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory()) {\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = new BooleanColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBooleanData::setNumberOfNulls);\n+                statistics.getBooleanStatistics().ifPresent(booleanStatistics -> {\n+                    booleanStatistics.getFalseCount().ifPresent(catalogBooleanData::setNumberOfFalses);\n+                    booleanStatistics.getTrueCount().ifPresent(catalogBooleanData::setNumberOfTrues);\n+                });\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BOOLEAN.toString());\n+                catalogColumnStatisticsData.setBooleanColumnStatisticsData(catalogBooleanData);\n+                break;\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = new BinaryColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBinaryData::setNumberOfNulls);\n+                catalogBinaryData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogBinaryData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BINARY.toString());\n+                catalogColumnStatisticsData.setBinaryColumnStatisticsData(catalogBinaryData);\n+                break;\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = new DateColumnStatisticsData();\n+                statistics.getDateStatistics().ifPresent(dateStatistics -> {\n+                    dateStatistics.getMin().ifPresent(value -> catalogDateData.setMinimumValue(localDateToDate(value)));\n+                    dateStatistics.getMax().ifPresent(value -> catalogDateData.setMaximumValue(localDateToDate(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDateData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDateData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DATE.toString());\n+                catalogColumnStatisticsData.setDateColumnStatisticsData(catalogDateData);\n+                break;\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = new DecimalColumnStatisticsData();\n+                statistics.getDecimalStatistics().ifPresent(decimalStatistics -> {\n+                    decimalStatistics.getMin().ifPresent(value -> catalogDecimalData.setMinimumValue(bigDecimalToGlueDecimal(value)));\n+                    decimalStatistics.getMax().ifPresent(value -> catalogDecimalData.setMaximumValue(bigDecimalToGlueDecimal(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDecimalData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDecimalData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DECIMAL.toString());\n+                catalogColumnStatisticsData.setDecimalColumnStatisticsData(catalogDecimalData);\n+                break;\n+            case FLOAT:\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = new DoubleColumnStatisticsData();\n+                statistics.getDoubleStatistics().ifPresent(doubleStatistics -> {\n+                    doubleStatistics.getMin().ifPresent(catalogDoubleData::setMinimumValue);\n+                    doubleStatistics.getMax().ifPresent(catalogDoubleData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDoubleData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDoubleData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DOUBLE.toString());\n+                catalogColumnStatisticsData.setDoubleColumnStatisticsData(catalogDoubleData);\n+                break;\n+            case BYTE:\n+            case SHORT:\n+            case INT:\n+            case LONG:\n+            case TIMESTAMP:\n+                LongColumnStatisticsData catalogLongData = new LongColumnStatisticsData();\n+                statistics.getIntegerStatistics().ifPresent(integerStatistics -> {\n+                    integerStatistics.getMin().ifPresent(catalogLongData::setMinimumValue);\n+                    integerStatistics.getMax().ifPresent(catalogLongData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogLongData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogLongData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.LONG.toString());\n+                catalogColumnStatisticsData.setLongColumnStatisticsData(catalogLongData);\n+                break;\n+            case VARCHAR:\n+            case CHAR:\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = new StringColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogStringData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogStringData::setNumberOfDistinctValues);\n+                catalogStringData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogStringData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.STRING.toString());\n+                catalogColumnStatisticsData.setStringColumnStatisticsData(catalogStringData);\n+                break;\n+            default:\n+                throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics type: \" + statistics);\n+        }\n+        return catalogColumnStatisticsData;\n+    }\n+\n+    private static DecimalNumber bigDecimalToGlueDecimal(BigDecimal decimal)\n+    {\n+        Decimal hiveDecimal = new Decimal((short) decimal.scale(), ByteBuffer.wrap(decimal.unscaledValue().toByteArray()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTEyOTI3OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571129279", "bodyText": "Agree but in this cases the method is called inside an Optional#isPresent lambda, NPEs should not happen.\nIn order to be as defensive as possible do you think we can return an Optional here and set min/max when present ?", "author": "GaruGaru", "createdAt": "2021-02-05T17:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxODMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTE1NDczNw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571154737", "bodyText": "I missed the call-site when reviewing. This should be fine. Please mark other such instances as resolved. Sorry for the false alarms.", "author": "hashhar", "createdAt": "2021-02-05T18:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxODMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxOTk4NA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569419984", "bodyText": "We can make the error message more explicit like Unsupported statistics type: %s so that users don't need to look at stack-trace.", "author": "hashhar", "createdAt": "2021-02-03T13:40:15Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return trinoColumnStats.entrySet().stream()\n+                .map(e -> toColumnStatistics(table.getColumn(e.getKey()).get(), e.getValue(), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    private static ColumnStatistics toColumnStatistics(Column column, HiveColumnStatistics statistics, OptionalLong rowCount)\n+    {\n+        ColumnStatistics columnStatistics = new ColumnStatistics();\n+        HiveType columnType = column.getType();\n+        columnStatistics.setColumnName(column.getName());\n+        columnStatistics.setColumnType(columnType.toString());\n+        ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+        columnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+        columnStatistics.setAnalyzedTime(new Date());\n+        return columnStatistics;\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData toGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n+    {\n+        TypeInfo typeInfo = columnType.getTypeInfo();\n+        checkArgument(typeInfo.getCategory() == PRIMITIVE, \"unsupported type: %s\", columnType);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTYzMDc1MQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571630751", "bodyText": "Should we also add some context to the error ? eg Unsupported statistics type: %s, Only primitive types are supported", "author": "GaruGaru", "createdAt": "2021-02-07T15:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxOTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4NzQyMg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571687422", "bodyText": "I don't think users would know what a PrimitiveType is as defined by the metastore. I'll defer on this to @trinodb/maintainers .", "author": "hashhar", "createdAt": "2021-02-07T20:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQxOTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyNDMwMQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569424301", "bodyText": "Some of these branches look impossible to hit because we don't/can't write stats for such types into Glue. e.g. TIMESTAMP.\nAm I correct? Or misunderstanding something?", "author": "hashhar", "createdAt": "2021-02-03T13:46:31Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return trinoColumnStats.entrySet().stream()\n+                .map(e -> toColumnStatistics(table.getColumn(e.getKey()).get(), e.getValue(), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    private static ColumnStatistics toColumnStatistics(Column column, HiveColumnStatistics statistics, OptionalLong rowCount)\n+    {\n+        ColumnStatistics columnStatistics = new ColumnStatistics();\n+        HiveType columnType = column.getType();\n+        columnStatistics.setColumnName(column.getName());\n+        columnStatistics.setColumnType(columnType.toString());\n+        ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+        columnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+        columnStatistics.setAnalyzedTime(new Date());\n+        return columnStatistics;\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData toGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n+    {\n+        TypeInfo typeInfo = columnType.getTypeInfo();\n+        checkArgument(typeInfo.getCategory() == PRIMITIVE, \"unsupported type: %s\", columnType);\n+\n+        ColumnStatisticsData catalogColumnStatisticsData = new ColumnStatisticsData();\n+\n+        switch (((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory()) {\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = new BooleanColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBooleanData::setNumberOfNulls);\n+                statistics.getBooleanStatistics().ifPresent(booleanStatistics -> {\n+                    booleanStatistics.getFalseCount().ifPresent(catalogBooleanData::setNumberOfFalses);\n+                    booleanStatistics.getTrueCount().ifPresent(catalogBooleanData::setNumberOfTrues);\n+                });\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BOOLEAN.toString());\n+                catalogColumnStatisticsData.setBooleanColumnStatisticsData(catalogBooleanData);\n+                break;\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = new BinaryColumnStatisticsData();\n+                statistics.getNullsCount().ifPresent(catalogBinaryData::setNumberOfNulls);\n+                catalogBinaryData.setMaximumLength(statistics.getMaxValueSizeInBytes().orElse(0));\n+                catalogBinaryData.setAverageLength(getAverageColumnLength(statistics.getTotalSizeInBytes(), rowCount, statistics.getNullsCount()).orElse(0));\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.BINARY.toString());\n+                catalogColumnStatisticsData.setBinaryColumnStatisticsData(catalogBinaryData);\n+                break;\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = new DateColumnStatisticsData();\n+                statistics.getDateStatistics().ifPresent(dateStatistics -> {\n+                    dateStatistics.getMin().ifPresent(value -> catalogDateData.setMinimumValue(localDateToDate(value)));\n+                    dateStatistics.getMax().ifPresent(value -> catalogDateData.setMaximumValue(localDateToDate(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDateData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDateData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DATE.toString());\n+                catalogColumnStatisticsData.setDateColumnStatisticsData(catalogDateData);\n+                break;\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = new DecimalColumnStatisticsData();\n+                statistics.getDecimalStatistics().ifPresent(decimalStatistics -> {\n+                    decimalStatistics.getMin().ifPresent(value -> catalogDecimalData.setMinimumValue(bigDecimalToGlueDecimal(value)));\n+                    decimalStatistics.getMax().ifPresent(value -> catalogDecimalData.setMaximumValue(bigDecimalToGlueDecimal(value)));\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDecimalData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDecimalData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DECIMAL.toString());\n+                catalogColumnStatisticsData.setDecimalColumnStatisticsData(catalogDecimalData);\n+                break;\n+            case FLOAT:\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = new DoubleColumnStatisticsData();\n+                statistics.getDoubleStatistics().ifPresent(doubleStatistics -> {\n+                    doubleStatistics.getMin().ifPresent(catalogDoubleData::setMinimumValue);\n+                    doubleStatistics.getMax().ifPresent(catalogDoubleData::setMaximumValue);\n+                });\n+                statistics.getNullsCount().ifPresent(catalogDoubleData::setNumberOfNulls);\n+                toMetastoreDistinctValuesCount(statistics.getDistinctValuesCount(), statistics.getNullsCount()).ifPresent(catalogDoubleData::setNumberOfDistinctValues);\n+                catalogColumnStatisticsData.setType(ColumnStatisticsType.DOUBLE.toString());\n+                catalogColumnStatisticsData.setDoubleColumnStatisticsData(catalogDoubleData);\n+                break;\n+            case BYTE:\n+            case SHORT:\n+            case INT:\n+            case LONG:\n+            case TIMESTAMP:", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTYzMjg4NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571632885", "bodyText": "The intent here is to handle all the types (SHORT,INT,LONG,TIMESTAMP) Using the same logic by leveraging java switch multiple cases, so in this case all the defined types are written with the LongColumnStatisticsData object to glue, Glue doesn't support short, int and timestamp values.\nShould we make this more explicit ?\nAnother possible change is to handle timestamp type as Date instead of long but I'm not sure if this can help", "author": "GaruGaru", "createdAt": "2021-02-07T15:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyNDMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyOTAwOA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569429008", "bodyText": "Let's catch any RuntimeException here and wrap in TrinoException.", "author": "hashhar", "createdAt": "2021-02-03T13:53:01Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQyOTI4OA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569429288", "bodyText": "Let's catch any RuntimeException here and wrap in TrinoException here.", "author": "hashhar", "createdAt": "2021-02-03T13:53:23Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQzMzA4Ng==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569433086", "bodyText": "In a follow-up we may want to make this execute in the order that futures complete to avoid being blocked on a single slow API call - maybe by adding a callback to the future. Just thinking out loud.", "author": "hashhar", "createdAt": "2021-02-03T13:58:27Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYxNzA2Ng==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569617066", "bodyText": "getFutureValue(allOf should work here. But +1 to keep it as a followup.", "author": "losipiuk", "createdAt": "2021-02-03T17:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQzMzA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQzMzQwOQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569433409", "bodyText": "Let's catch any RuntimeException here and wrap in TrinoException here.", "author": "hashhar", "createdAt": "2021-02-03T13:58:51Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(toUnmodifiableList());\n+\n+            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n+\n+            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForTable(\n+                                    new DeleteColumnStatisticsForTableRequest()\n+                                            .withCatalogId(catalogId)\n+                                            .withDatabaseName(table.getDatabaseName())\n+                                            .withTableName(table.getTableName())\n+                                            .withColumnName(column)))\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                getFutureValue(writeFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQzMzUwMw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569433503", "bodyText": "Let's catch any RuntimeException here and wrap in TrinoException here.", "author": "hashhar", "createdAt": "2021-02-03T13:58:58Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(toUnmodifiableList());\n+\n+            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n+\n+            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForTable(\n+                                    new DeleteColumnStatisticsForTableRequest()\n+                                            .withCatalogId(catalogId)\n+                                            .withDatabaseName(table.getDatabaseName())\n+                                            .withTableName(table.getTableName())\n+                                            .withColumnName(column)))\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                getFutureValue(writeFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> updatedColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics partitionStats = getHiveBasicStatistics(partition.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(partition, updatedColumnStatistics, partitionStats.getRowCount());\n+\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writePartitionStatsFutures = columnChunks.stream()\n+                    .map(columnChunk ->\n+                            runAsync(() -> glueClient.updateColumnStatisticsForPartition(new UpdateColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnStatisticsList(columnChunk)), writeExecutor)\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writePartitionStatsFuture : writePartitionStatsFutures) {\n+                getFutureValue(writePartitionStatsFuture);\n+            }\n+\n+            boolean partitionExists = partitionExists(partition);\n+            Map<String, HiveColumnStatistics> currentColumnStatistics = partitionExists ? this.getPartitionColumnStatistics(partition) : Collections.emptyMap();\n+            Set<String> removedStatistics = difference(currentColumnStatistics.keySet(), updatedColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForPartition(new DeleteColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnName(column)), writeExecutor)\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                getFutureValue(writeFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1MjE0Ng==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569552146", "bodyText": "nit: move closing brackets to previous line. I wonder why checkstyle didn't complain though.", "author": "hashhar", "createdAt": "2021-02-03T16:22:17Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(toUnmodifiableList());\n+\n+            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n+\n+            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForTable(\n+                                    new DeleteColumnStatisticsForTableRequest()\n+                                            .withCatalogId(catalogId)\n+                                            .withDatabaseName(table.getDatabaseName())\n+                                            .withTableName(table.getTableName())\n+                                            .withColumnName(column)))\n+                    ).collect(toUnmodifiableList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1MzU3Nw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569553577", "bodyText": "Let's change all occurrences of loops over future where returned values are not checked into something like getFutureValue(allOf(...))? Or is that not equivalent?", "author": "hashhar", "createdAt": "2021-02-03T16:24:09Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(toUnmodifiableList());\n+\n+            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n+\n+            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForTable(\n+                                    new DeleteColumnStatisticsForTableRequest()\n+                                            .withCatalogId(catalogId)\n+                                            .withDatabaseName(table.getDatabaseName())\n+                                            .withTableName(table.getTableName())\n+                                            .withColumnName(column)))\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                getFutureValue(writeFuture);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYwOTM0Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569609343", "bodyText": "Yeah - please do that. So we acutally wait for all the futures to complete. And we are not leaving work still being processed in executors.", "author": "losipiuk", "createdAt": "2021-02-03T17:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1MzU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1NDAyMw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569554023", "bodyText": "nit: move closing brackets to previous line. I wonder why checkstyle didn't complain though.", "author": "hashhar", "createdAt": "2021-02-03T16:24:48Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(toUnmodifiableList());\n+\n+            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n+\n+            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForTable(\n+                                    new DeleteColumnStatisticsForTableRequest()\n+                                            .withCatalogId(catalogId)\n+                                            .withDatabaseName(table.getDatabaseName())\n+                                            .withTableName(table.getTableName())\n+                                            .withColumnName(column)))\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                getFutureValue(writeFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> updatedColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics partitionStats = getHiveBasicStatistics(partition.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(partition, updatedColumnStatistics, partitionStats.getRowCount());\n+\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writePartitionStatsFutures = columnChunks.stream()\n+                    .map(columnChunk ->\n+                            runAsync(() -> glueClient.updateColumnStatisticsForPartition(new UpdateColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnStatisticsList(columnChunk)), writeExecutor)\n+                    ).collect(toUnmodifiableList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1NDM2Nw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569554367", "bodyText": "Let's test for an exception to be thrown instead to avoid an API call. WDYT @losipiuk.", "author": "hashhar", "createdAt": "2021-02-03T16:25:17Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(toUnmodifiableList());\n+\n+            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n+\n+            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForTable(\n+                                    new DeleteColumnStatisticsForTableRequest()\n+                                            .withCatalogId(catalogId)\n+                                            .withDatabaseName(table.getDatabaseName())\n+                                            .withTableName(table.getTableName())\n+                                            .withColumnName(column)))\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                getFutureValue(writeFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> updatedColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics partitionStats = getHiveBasicStatistics(partition.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(partition, updatedColumnStatistics, partitionStats.getRowCount());\n+\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writePartitionStatsFutures = columnChunks.stream()\n+                    .map(columnChunk ->\n+                            runAsync(() -> glueClient.updateColumnStatisticsForPartition(new UpdateColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnStatisticsList(columnChunk)), writeExecutor)\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writePartitionStatsFuture : writePartitionStatsFutures) {\n+                getFutureValue(writePartitionStatsFuture);\n+            }\n+\n+            boolean partitionExists = partitionExists(partition);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU3MTkzNQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569571935", "bodyText": "If there is clear error code in exception with \"partition not found\" meaning I think we should use exception to avoid extra API call on success path.", "author": "losipiuk", "createdAt": "2021-02-03T16:47:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1NDM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1OTYxMw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569559613", "bodyText": "Let's add some comment about why this is failing? AFAIR you said that even though Glue API docs say that some fields are \"not required\" not setting them when making the API call causes an error. Correct?", "author": "hashhar", "createdAt": "2021-02-03T16:31:32Z", "path": "plugin/trino-hive/src/test/java/io/trino/plugin/hive/metastore/glue/TestHiveGlueMetastore.java", "diffHunk": "@@ -152,34 +158,22 @@ public void testRenameTable()\n         // rename table is not yet supported by Glue\n     }\n \n-    @Override\n-    public void testPartitionStatisticsSampling()\n-    {\n-        // Glue metastore does not support column level statistics\n-    }\n-\n-    @Override\n-    public void testUpdateTableColumnStatistics()\n-    {\n-        // column statistics are not supported by Glue\n-    }\n-\n     @Override\n     public void testUpdateTableColumnStatisticsEmptyOptionalFields()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n-    }\n-\n-    @Override\n-    public void testUpdatePartitionColumnStatistics()\n-    {\n-        // column statistics are not supported by Glue\n+        assertThatThrownBy(super::testUpdateTableColumnStatisticsEmptyOptionalFields)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njk5MzE1NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r576993155", "bodyText": "I added a comment in the discussion about this issue", "author": "GaruGaru", "createdAt": "2021-02-16T17:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1OTYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1OTc1OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569559759", "bodyText": "Let's add some comment about why this is failing? AFAIR you said that even though Glue API docs say that some fields are \"not required\" not setting them when making the API call causes an error. Correct?", "author": "hashhar", "createdAt": "2021-02-03T16:31:44Z", "path": "plugin/trino-hive/src/test/java/io/trino/plugin/hive/metastore/glue/TestHiveGlueMetastore.java", "diffHunk": "@@ -152,34 +158,22 @@ public void testRenameTable()\n         // rename table is not yet supported by Glue\n     }\n \n-    @Override\n-    public void testPartitionStatisticsSampling()\n-    {\n-        // Glue metastore does not support column level statistics\n-    }\n-\n-    @Override\n-    public void testUpdateTableColumnStatistics()\n-    {\n-        // column statistics are not supported by Glue\n-    }\n-\n     @Override\n     public void testUpdateTableColumnStatisticsEmptyOptionalFields()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n-    }\n-\n-    @Override\n-    public void testUpdatePartitionColumnStatistics()\n-    {\n-        // column statistics are not supported by Glue\n+        assertThatThrownBy(super::testUpdateTableColumnStatisticsEmptyOptionalFields)\n+                .hasMessageContaining(\"Service: AWSGlue; Status Code: 500; Error Code: InternalServiceException;\")\n+                .isInstanceOf(TrinoException.class);\n     }\n \n     @Override\n     public void testUpdatePartitionColumnStatisticsEmptyOptionalFields()\n+            throws Exception\n     {\n-        // column statistics are not supported by Glue\n+        assertThatThrownBy(super::testUpdatePartitionColumnStatisticsEmptyOptionalFields)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njk5MzI0NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r576993245", "bodyText": "I added a comment in the discussion about this issue", "author": "GaruGaru", "createdAt": "2021-02-16T17:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU1OTc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU2MTk4Nw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569561987", "bodyText": "Why this change? This indicates to me that are we somehow calculating data size differently for Thrift vs Glue?", "author": "hashhar", "createdAt": "2021-02-03T16:34:49Z", "path": "plugin/trino-hive/src/test/java/io/trino/plugin/hive/AbstractTestHive.java", "diffHunk": "@@ -513,23 +513,23 @@ private static RowType toRowType(List<ColumnMetadata> columns)\n                             .put(\"t_float\", createDoubleColumnStatistics(OptionalDouble.of(123.25), OptionalDouble.of(567.58), OptionalLong.of(9), OptionalLong.of(10)))\n                             .put(\"t_string\", createStringColumnStatistics(OptionalLong.of(10), OptionalLong.of(50), OptionalLong.of(3), OptionalLong.of(7)))\n                             .put(\"t_varchar\", createStringColumnStatistics(OptionalLong.of(100), OptionalLong.of(230), OptionalLong.of(5), OptionalLong.of(3)))\n-                            .put(\"t_char\", createStringColumnStatistics(OptionalLong.of(5), OptionalLong.of(500), OptionalLong.of(1), OptionalLong.of(4)))\n-                            .put(\"t_varbinary\", createBinaryColumnStatistics(OptionalLong.of(4), OptionalLong.of(300), OptionalLong.of(1)))\n+                            .put(\"t_char\", createStringColumnStatistics(OptionalLong.of(5), OptionalLong.of(50), OptionalLong.of(1), OptionalLong.of(4)))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY0NDU0Ng==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571644546", "bodyText": "Here I'm using the ThriftMetastoreUtil#getAverageColumnLength function I had to change the values because Glue  reject logically inconsistent statistics.\nIn particular:\nt_varbinary\ntest data: \n rows:  15\n nulls: 1\n max_size:   4\n total_size: 300\n\navg size: 300/(15rows - 1null) = 20...  > 4 (max)  # ERROR \n\nt_char\n rows: 15\n nulls: 1 \n max_size: 5\n total_size: 500\n\navg size: 500/(15rows - 1null) = 35... > 5 (max) # ERROR", "author": "GaruGaru", "createdAt": "2021-02-07T16:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU2MTk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTk1NTg2Ng==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571955866", "bodyText": "because Glue reject logically inconsistent statistics\n\nAre we sure that statistics computation mechanism used by Tino will not trigger this safety valve?\ncc: @findepi", "author": "losipiuk", "createdAt": "2021-02-08T11:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU2MTk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU2MjkyOA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569562928", "bodyText": "@losipiuk does it make sense for a follow-up task in future to normalize such incorrect stats? Or does the engine already ignore/correct for such stats.\ncc: @sopel", "author": "hashhar", "createdAt": "2021-02-03T16:36:02Z", "path": "plugin/trino-hive/src/test/java/io/trino/plugin/hive/AbstractTestHive.java", "diffHunk": "@@ -545,10 +545,10 @@ private static RowType toRowType(List<ColumnMetadata> columns)\n                             .put(\"t_bigint\", createIntegerColumnStatistics(OptionalLong.of(2345L), OptionalLong.of(6789L), OptionalLong.of(4), OptionalLong.of(7)))\n                             .put(\"t_integer\", createIntegerColumnStatistics(OptionalLong.of(234L), OptionalLong.of(678L), OptionalLong.of(5), OptionalLong.of(6)))\n                             .put(\"t_smallint\", createIntegerColumnStatistics(OptionalLong.of(23L), OptionalLong.of(65L), OptionalLong.of(7), OptionalLong.of(5)))\n-                            .put(\"t_tinyint\", createIntegerColumnStatistics(OptionalLong.of(12), OptionalLong.of(3L), OptionalLong.of(2), OptionalLong.of(3)))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU4NDg3NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569584875", "bodyText": "Hmmmm, @GaruGaru I think logically incorrect stats value SHOULD NOT be a problem. i.e. will Glue reject such statistics when writing?\nIf you changed these values just because they were logically inconsistent, let's revert the change.", "author": "hashhar", "createdAt": "2021-02-03T17:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU2MjkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTYzNjEyNg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571636126", "bodyText": "I had to change those values because Glue api reject values that are logically inconsistent ( eg avg > max)", "author": "GaruGaru", "createdAt": "2021-02-07T15:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTU2MjkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYyNDQ1NA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569624454", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n          \n          \n            \n            \n          \n          \n            \n                        columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n          \n          \n            \n                            List<String> columnsNames = partialColumns.stream()\n          \n          \n            \n                                    .map(Column::getName)\n          \n          \n            \n                                    .collect(toImmutableList());\n          \n          \n            \n            \n          \n          \n            \n                            GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n          \n          \n            \n                                    .withCatalogId(catalogId)\n          \n          \n            \n                                    .withDatabaseName(partition.getDatabaseName())\n          \n          \n            \n                                    .withTableName(partition.getTableName())\n          \n          \n            \n                                    .withColumnNames(columnsNames)\n          \n          \n            \n                                    .withPartitionValues(partition.getValues());\n          \n          \n            \n            \n          \n          \n            \n                            return glueClient.getColumnStatisticsForPartition(request);\n          \n          \n            \n                        }, readExecutor)));\n          \n          \n            \n                        List<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = columnChunks.stream()\n          \n          \n            \n                                .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n          \n          \n            \n                                    List<String> columnsNames = partialColumns.stream()\n          \n          \n            \n                                            .map(Column::getName)\n          \n          \n            \n                                            .collect(toImmutableList());\n          \n          \n            \n            \n          \n          \n            \n                                    GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n          \n          \n            \n                                            .withCatalogId(catalogId)\n          \n          \n            \n                                            .withDatabaseName(partition.getDatabaseName())\n          \n          \n            \n                                            .withTableName(partition.getTableName())\n          \n          \n            \n                                            .withColumnNames(columnsNames)\n          \n          \n            \n                                            .withPartitionValues(partition.getValues());\n          \n          \n            \n                                    return glueClient.getColumnStatisticsForPartition(request);\n          \n          \n            \n                                }, readExecutor))\n          \n          \n            \n                                .collect(toImmutableList());\n          \n      \n    \n    \n  \n\n@hashhar which one looks nicer to you?", "author": "losipiuk", "createdAt": "2021-02-03T17:53:28Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYyNjg1MA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569626850", "bodyText": "Oh I see that you go this appraach in getTableColumnStatistics. Please be consistent.", "author": "losipiuk", "createdAt": "2021-02-03T17:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYyNDQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTk1ODI2Nw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571958267", "bodyText": "Still not consistent. getPartitionColumnStatistics uses forEach ... getStatsFutures.add(. And getTableColumnStatistics uses .collect(toImmutableList());. Please migrate to .collect(toImmutableList()); with both.", "author": "losipiuk", "createdAt": "2021-02-08T11:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYyNDQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njc3Mjc0Mw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r576772743", "bodyText": "Sorry you're right !", "author": "GaruGaru", "createdAt": "2021-02-16T12:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYyNDQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYyNzQwNQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569627405", "bodyText": "drop final", "author": "losipiuk", "createdAt": "2021-02-03T17:57:39Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(toUnmodifiableList());\n+\n+            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n+\n+            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYyOTc3NA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569629774", "bodyText": "is there a reason to do updates first and removals later? It feels to me it would be better to gather the futures on single list and call getFutureValue(allOf just once.\nSo even in case of an error for some of the calls we have as many changes applied as possible.", "author": "losipiuk", "createdAt": "2021-02-03T18:00:57Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYzMTAzMg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569631032", "bodyText": "same here. Wouldn't it be better to collect futures on single list?", "author": "losipiuk", "createdAt": "2021-02-03T18:03:05Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.AmazonServiceException;\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.BatchGetPartitionRequest;\n+import com.amazonaws.services.glue.model.BatchGetPartitionResult;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.PartitionValueList;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk))))\n+                    .collect(toUnmodifiableList());\n+\n+            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n+\n+            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForTable(\n+                                    new DeleteColumnStatisticsForTableRequest()\n+                                            .withCatalogId(catalogId)\n+                                            .withDatabaseName(table.getDatabaseName())\n+                                            .withTableName(table.getTableName())\n+                                            .withColumnName(column)))\n+                    ).collect(toUnmodifiableList());\n+\n+            for (CompletableFuture<Void> writeFuture : writeFutures) {\n+                getFutureValue(writeFuture);\n+            }\n+        }\n+        catch (AmazonServiceException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> updatedColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics partitionStats = getHiveBasicStatistics(partition.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(partition, updatedColumnStatistics, partitionStats.getRowCount());\n+\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writePartitionStatsFutures = columnChunks.stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYzNjIwNQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569636205", "bodyText": "please move call to columnStatisticsProvider.updatePartitionStatistics below glueClient.updatePartition we update the basic stats first.", "author": "losipiuk", "createdAt": "2021-02-03T18:11:07Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -385,8 +397,10 @@ public void updatePartitionStatistics(HiveIdentity identity, Table table, String\n \n         try {\n             PartitionInput partitionInput = GlueInputConverter.convertPartition(partition);\n-            partitionInput.setParameters(updateStatisticsParameters(partition.getParameters(), updatedStatistics.getBasicStatistics()));\n-            columnStatisticsProvider.updatePartitionStatistics(partitionInput, updatedStatistics.getColumnStatistics());\n+            final Map<String, String> updateStatisticsParameters = updateStatisticsParameters(partition.getParameters(), updatedStatistics.getBasicStatistics());\n+            partitionInput.setParameters(updateStatisticsParameters);\n+            partition = Partition.builder(partition).setParameters(updateStatisticsParameters).build();\n+            columnStatisticsProvider.updatePartitionStatistics(partition, updatedStatistics.getColumnStatistics());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTYzNjQ2OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569636469", "bodyText": "plase move the call to columnStatisticsProvider.updateTableColumnStatistics(table, updatedStatistics.getColumnStatistics());  below glueClient.updateTable so we update basic stats first.", "author": "losipiuk", "createdAt": "2021-02-03T18:11:34Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -358,8 +368,10 @@ public void updateTableStatistics(HiveIdentity identity, String databaseName, St\n \n         try {\n             TableInput tableInput = GlueInputConverter.convertTable(table);\n-            tableInput.setParameters(updateStatisticsParameters(table.getParameters(), updatedStatistics.getBasicStatistics()));\n-            columnStatisticsProvider.updateTableColumnStatistics(tableInput, updatedStatistics.getColumnStatistics());\n+            final Map<String, String> statisticsParameters = updateStatisticsParameters(table.getParameters(), updatedStatistics.getBasicStatistics());\n+            tableInput.setParameters(statisticsParameters);\n+            table = Table.builder(table).setParameters(statisticsParameters).build();\n+            columnStatisticsProvider.updateTableColumnStatistics(table, updatedStatistics.getColumnStatistics());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTY1Mjk2Nw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569652967", "bodyText": "Use braces. This will allow you to use shorter variable names. Like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        case DATE:\n          \n          \n            \n                            DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n          \n          \n            \n                            Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n          \n          \n            \n                            Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n          \n          \n            \n                            OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n          \n          \n            \n                            OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n          \n          \n            \n                            return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n          \n          \n            \n            \n          \n          \n            \n                        case DECIMAL:\n          \n          \n            \n                            DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n          \n          \n            \n                            Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n          \n          \n            \n                            Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n          \n          \n            \n                            OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n          \n          \n            \n                            OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n          \n          \n            \n                            return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n          \n          \n            \n                        case DATE: {\n          \n          \n            \n                            DateColumnStatisticsData data = catalogColumnStatisticsData.getDateColumnStatisticsData();\n          \n          \n            \n                            Optional<LocalDate> min = dateToLocalDate(data.getMinimumValue());\n          \n          \n            \n                            Optional<LocalDate> max = dateToLocalDate(data.getMaximumValue());\n          \n          \n            \n                            OptionalLong nullsCount = fromMetastoreNullsCount(data.getNumberOfNulls());\n          \n          \n            \n                            OptionalLong numberOfDistinctValues = OptionalLong.of(data.getNumberOfDistinctValues());\n          \n          \n            \n                            return createDateColumnStatistics(min, max, nullsCount, fromMetastoreDistinctValuesCount(numberOfDistinctValues, nullsCount, rowCount));\n          \n          \n            \n                        }\n          \n          \n            \n                        case DECIMAL: {\n          \n          \n            \n                            DecimalColumnStatisticsData data = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n          \n          \n            \n                            Optional<BigDecimal> min = glueDecimalToBigDecimal(data.getMinimumValue());\n          \n          \n            \n                            Optional<BigDecimal> max = glueDecimalToBigDecimal(data.getMaximumValue());\n          \n          \n            \n                            OptionalLong numberOfDistinctValues = OptionalLong.of(data.getNumberOfDistinctValues());\n          \n          \n            \n                            OptionalLong nullsCount = fromMetastoreNullsCount(data.getNumberOfNulls());\n          \n          \n            \n                            return createDecimalColumnStatistics(min, max, nullsCount, fromMetastoreDistinctValuesCount(numberOfDistinctValues, nullsCount, rowCount));\n          \n          \n            \n                        }", "author": "losipiuk", "createdAt": "2021-02-03T18:37:50Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return trinoColumnStats.entrySet().stream()\n+                .map(e -> toColumnStatistics(table.getColumn(e.getKey()).get(), e.getValue(), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    private static ColumnStatistics toColumnStatistics(Column column, HiveColumnStatistics statistics, OptionalLong rowCount)\n+    {\n+        ColumnStatistics columnStatistics = new ColumnStatistics();\n+        HiveType columnType = column.getType();\n+        columnStatistics.setColumnName(column.getName());\n+        columnStatistics.setColumnType(columnType.toString());\n+        ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+        columnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+        columnStatistics.setAnalyzedTime(new Date());\n+        return columnStatistics;\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTY1MzQ3MQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r569653471", "bodyText": "use braces here to to have separate namespace for each type considered.", "author": "losipiuk", "createdAt": "2021-02-03T18:38:34Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/converter/GlueStatConverter.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue.converter;\n+\n+import com.amazonaws.services.glue.model.BinaryColumnStatisticsData;\n+import com.amazonaws.services.glue.model.BooleanColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.ColumnStatisticsData;\n+import com.amazonaws.services.glue.model.ColumnStatisticsType;\n+import com.amazonaws.services.glue.model.DateColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalColumnStatisticsData;\n+import com.amazonaws.services.glue.model.DecimalNumber;\n+import com.amazonaws.services.glue.model.DoubleColumnStatisticsData;\n+import com.amazonaws.services.glue.model.LongColumnStatisticsData;\n+import com.amazonaws.services.glue.model.StringColumnStatisticsData;\n+import io.trino.plugin.hive.HiveType;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.spi.TrinoException;\n+import org.apache.hadoop.hive.metastore.api.Decimal;\n+import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;\n+import org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.time.LocalDate;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalDouble;\n+import java.util.OptionalLong;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_INVALID_METADATA;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBinaryColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createBooleanColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDateColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDecimalColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createDoubleColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createIntegerColumnStatistics;\n+import static io.trino.plugin.hive.metastore.HiveColumnStatistics.createStringColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreDistinctValuesCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.fromMetastoreNullsCount;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getAverageColumnLength;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getTotalSizeInBytes;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.toMetastoreDistinctValuesCount;\n+import static org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category.PRIMITIVE;\n+\n+public class GlueStatConverter\n+{\n+    private GlueStatConverter() {}\n+\n+    private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Partition partition, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return partition.getColumns().stream()\n+                .filter(column -> trinoColumnStats.containsKey(column.getName()))\n+                .map(c -> toColumnStatistics(c, trinoColumnStats.get(c.getName()), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    public static List<ColumnStatistics> toGlueColumnStatistics(\n+            Table table, Map<String, HiveColumnStatistics> trinoColumnStats, OptionalLong rowCount)\n+    {\n+        return trinoColumnStats.entrySet().stream()\n+                .map(e -> toColumnStatistics(table.getColumn(e.getKey()).get(), e.getValue(), rowCount))\n+                .collect(toImmutableList());\n+    }\n+\n+    private static ColumnStatistics toColumnStatistics(Column column, HiveColumnStatistics statistics, OptionalLong rowCount)\n+    {\n+        ColumnStatistics columnStatistics = new ColumnStatistics();\n+        HiveType columnType = column.getType();\n+        columnStatistics.setColumnName(column.getName());\n+        columnStatistics.setColumnType(columnType.toString());\n+        ColumnStatisticsData catalogColumnStatisticsData = toGlueColumnStatisticsData(statistics, columnType, rowCount);\n+        columnStatistics.setStatisticsData(catalogColumnStatisticsData);\n+        columnStatistics.setAnalyzedTime(new Date());\n+        return columnStatistics;\n+    }\n+\n+    public static HiveColumnStatistics fromGlueColumnStatistics(ColumnStatisticsData catalogColumnStatisticsData, OptionalLong rowCount)\n+    {\n+        ColumnStatisticsType type = ColumnStatisticsType.fromValue(catalogColumnStatisticsData.getType());\n+        switch (type) {\n+            case BINARY:\n+                BinaryColumnStatisticsData catalogBinaryData = catalogColumnStatisticsData.getBinaryColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfBinary = OptionalLong.of(catalogBinaryData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfBinary = OptionalDouble.of(catalogBinaryData.getAverageLength());\n+                OptionalLong nullsCountOfBinary = fromMetastoreNullsCount(catalogBinaryData.getNumberOfNulls());\n+                return createBinaryColumnStatistics(\n+                        maxColumnLengthOfBinary,\n+                        getTotalSizeInBytes(averageColumnLengthOfBinary, rowCount, nullsCountOfBinary),\n+                        nullsCountOfBinary);\n+\n+            case BOOLEAN:\n+                BooleanColumnStatisticsData catalogBooleanData = catalogColumnStatisticsData.getBooleanColumnStatisticsData();\n+                return createBooleanColumnStatistics(\n+                        OptionalLong.of(catalogBooleanData.getNumberOfTrues()),\n+                        OptionalLong.of(catalogBooleanData.getNumberOfFalses()),\n+                        fromMetastoreNullsCount(catalogBooleanData.getNumberOfNulls()));\n+\n+            case DATE:\n+                DateColumnStatisticsData catalogDateData = catalogColumnStatisticsData.getDateColumnStatisticsData();\n+                Optional<LocalDate> minOfDate = dateToLocalDate(catalogDateData.getMinimumValue());\n+                Optional<LocalDate> maxOfDate = dateToLocalDate(catalogDateData.getMaximumValue());\n+                OptionalLong nullsCountOfDate = fromMetastoreNullsCount(catalogDateData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDate = OptionalLong.of(catalogDateData.getNumberOfDistinctValues());\n+                return createDateColumnStatistics(minOfDate, maxOfDate, nullsCountOfDate, fromMetastoreDistinctValuesCount(distinctValuesCountOfDate, nullsCountOfDate, rowCount));\n+\n+            case DECIMAL:\n+                DecimalColumnStatisticsData catalogDecimalData = catalogColumnStatisticsData.getDecimalColumnStatisticsData();\n+                Optional<BigDecimal> minOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMinimumValue());\n+                Optional<BigDecimal> maxOfDecimal = glueDecimalToBigDecimal(catalogDecimalData.getMaximumValue());\n+                OptionalLong distinctValuesCountOfDecimal = OptionalLong.of(catalogDecimalData.getNumberOfDistinctValues());\n+                OptionalLong nullsCountOfDecimal = fromMetastoreNullsCount(catalogDecimalData.getNumberOfNulls());\n+                return createDecimalColumnStatistics(minOfDecimal, maxOfDecimal, nullsCountOfDecimal, fromMetastoreDistinctValuesCount(distinctValuesCountOfDecimal, nullsCountOfDecimal, rowCount));\n+\n+            case DOUBLE:\n+                DoubleColumnStatisticsData catalogDoubleData = catalogColumnStatisticsData.getDoubleColumnStatisticsData();\n+                OptionalDouble minOfDouble = OptionalDouble.of(catalogDoubleData.getMinimumValue());\n+                OptionalDouble maxOfDouble = OptionalDouble.of(catalogDoubleData.getMaximumValue());\n+                OptionalLong nullsCountOfDouble = fromMetastoreNullsCount(catalogDoubleData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfDouble = OptionalLong.of(catalogDoubleData.getNumberOfDistinctValues());\n+                return createDoubleColumnStatistics(minOfDouble, maxOfDouble, nullsCountOfDouble, fromMetastoreDistinctValuesCount(distinctValuesCountOfDouble, nullsCountOfDouble, rowCount));\n+\n+            case LONG:\n+                LongColumnStatisticsData catalogLongData = catalogColumnStatisticsData.getLongColumnStatisticsData();\n+                OptionalLong minOfLong = OptionalLong.of(catalogLongData.getMinimumValue());\n+                OptionalLong maxOfLong = OptionalLong.of(catalogLongData.getMaximumValue());\n+                OptionalLong nullsCountOfLong = fromMetastoreNullsCount(catalogLongData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfLong = OptionalLong.of(catalogLongData.getNumberOfDistinctValues());\n+                return createIntegerColumnStatistics(minOfLong, maxOfLong, nullsCountOfLong, fromMetastoreDistinctValuesCount(distinctValuesCountOfLong, nullsCountOfLong, rowCount));\n+\n+            case STRING:\n+                StringColumnStatisticsData catalogStringData = catalogColumnStatisticsData.getStringColumnStatisticsData();\n+                OptionalLong maxColumnLengthOfString = OptionalLong.of(catalogStringData.getMaximumLength());\n+                OptionalDouble averageColumnLengthOfString = OptionalDouble.of(catalogStringData.getAverageLength());\n+                OptionalLong nullsCountOfString = fromMetastoreNullsCount(catalogStringData.getNumberOfNulls());\n+                OptionalLong distinctValuesCountOfString = OptionalLong.of(catalogStringData.getNumberOfDistinctValues());\n+\n+                return createStringColumnStatistics(\n+                        maxColumnLengthOfString,\n+                        getTotalSizeInBytes(averageColumnLengthOfString, rowCount, nullsCountOfString),\n+                        nullsCountOfString,\n+                        fromMetastoreDistinctValuesCount(distinctValuesCountOfString, nullsCountOfString, rowCount));\n+        }\n+\n+        throw new TrinoException(HIVE_INVALID_METADATA, \"Invalid column statistics data: \" + catalogColumnStatisticsData);\n+    }\n+\n+    private static ColumnStatisticsData toGlueColumnStatisticsData(HiveColumnStatistics statistics, HiveType columnType, OptionalLong rowCount)\n+    {\n+        TypeInfo typeInfo = columnType.getTypeInfo();\n+        checkArgument(typeInfo.getCategory() == PRIMITIVE, \"unsupported type: %s\", columnType);\n+\n+        ColumnStatisticsData catalogColumnStatisticsData = new ColumnStatisticsData();\n+\n+        switch (((PrimitiveTypeInfo) typeInfo).getPrimitiveCategory()) {\n+            case BOOLEAN:", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4ODEzMA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571688130", "bodyText": "@losipiuk should we fail if Trino tries to fetch statistics for a partition which doesn't exist? Or return empty stats?", "author": "hashhar", "createdAt": "2021-02-07T20:28:38Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -156,7 +150,10 @@ public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catal\n             }\n             return columnStatsMapBuilder.build();\n         }\n-        catch (AmazonServiceException ex) {\n+        catch (EntityNotFoundException ex) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4OTAxOA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571689018", "bodyText": "Btw, this was changed to avoid catching the TrinoException(HIVE_METASTORE_ERROR, EntityNotFoundException) in the caller to detect that a partition doesn't exist.\nI'd prefer if this responsibility of handling EntityNotFoundException would be given to the caller since this is a public method and part of the API.\nWDYT @losipiuk ?", "author": "hashhar", "createdAt": "2021-02-07T20:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4ODEzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTk1NDg1MQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571954851", "bodyText": "I think we should throw here and catch in updatePartitionStatistics. Please add a PARTITION_NOT_FOUND error code to HiveErrorCode class so you can determine if you shiould just skip deleting for this partition in updatePartitionStatistics, or should you rather rethrow exception to the caller.", "author": "losipiuk", "createdAt": "2021-02-08T10:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4ODEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4ODQ3OQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571688479", "bodyText": "nit: move collect to new line.", "author": "hashhar", "createdAt": "2021-02-07T20:31:17Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -169,34 +166,32 @@ public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStati\n             List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n             List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n \n-            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+            List<CompletableFuture<Void>> updateFutures = columnChunks.stream().map(columnChunk -> runAsync(\n                     () -> glueClient.updateColumnStatisticsForTable(\n                             new UpdateColumnStatisticsForTableRequest()\n                                     .withCatalogId(catalogId)\n                                     .withDatabaseName(table.getDatabaseName())\n                                     .withTableName(table.getTableName())\n-                                    .withColumnStatisticsList(columnChunk))))\n+                                    .withColumnStatisticsList(columnChunk)), this.writeExecutor))\n                     .collect(toUnmodifiableList());\n \n-            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n-\n-            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n             Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n-            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+            List<CompletableFuture<Void>> deleteFutures = removedStatistics.stream()\n                     .map(column -> runAsync(() ->\n                             glueClient.deleteColumnStatisticsForTable(\n                                     new DeleteColumnStatisticsForTableRequest()\n                                             .withCatalogId(catalogId)\n                                             .withDatabaseName(table.getDatabaseName())\n                                             .withTableName(table.getTableName())\n-                                            .withColumnName(column)))\n-                    ).collect(toUnmodifiableList());\n+                                            .withColumnName(column)), this.writeExecutor)).collect(toUnmodifiableList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4ODUwNA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571688504", "bodyText": "drop final.", "author": "hashhar", "createdAt": "2021-02-07T20:31:36Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -169,34 +166,32 @@ public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStati\n             List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n             List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n \n-            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+            List<CompletableFuture<Void>> updateFutures = columnChunks.stream().map(columnChunk -> runAsync(\n                     () -> glueClient.updateColumnStatisticsForTable(\n                             new UpdateColumnStatisticsForTableRequest()\n                                     .withCatalogId(catalogId)\n                                     .withDatabaseName(table.getDatabaseName())\n                                     .withTableName(table.getTableName())\n-                                    .withColumnStatisticsList(columnChunk))))\n+                                    .withColumnStatisticsList(columnChunk)), this.writeExecutor))\n                     .collect(toUnmodifiableList());\n \n-            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n-\n-            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n             Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n-            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+            List<CompletableFuture<Void>> deleteFutures = removedStatistics.stream()\n                     .map(column -> runAsync(() ->\n                             glueClient.deleteColumnStatisticsForTable(\n                                     new DeleteColumnStatisticsForTableRequest()\n                                             .withCatalogId(catalogId)\n                                             .withDatabaseName(table.getDatabaseName())\n                                             .withTableName(table.getTableName())\n-                                            .withColumnName(column)))\n-                    ).collect(toUnmodifiableList());\n+                                            .withColumnName(column)), this.writeExecutor)).collect(toUnmodifiableList());\n \n-            for (CompletableFuture<Void> writeFuture : writeFutures) {\n-                getFutureValue(writeFuture);\n-            }\n+            final ImmutableList.Builder<CompletableFuture<Void>> updateOperationsFutures = ImmutableList.builderWithExpectedSize(updateFutures.size() + deleteFutures.size());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4ODU0Mg==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571688542", "bodyText": "nit: move collect to new line.", "author": "hashhar", "createdAt": "2021-02-07T20:32:07Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -217,45 +212,29 @@ public void updatePartitionStatistics(Partition partition, Map<String, HiveColum\n                                     .withDatabaseName(partition.getDatabaseName())\n                                     .withTableName(partition.getTableName())\n                                     .withPartitionValues(partition.getValues())\n-                                    .withColumnStatisticsList(columnChunk)), writeExecutor)\n-                    ).collect(toUnmodifiableList());\n+                                    .withColumnStatisticsList(columnChunk)), writeExecutor)).collect(toUnmodifiableList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4ODYwMQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571688601", "bodyText": "nit: move collect to new line.", "author": "hashhar", "createdAt": "2021-02-07T20:32:35Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -217,45 +212,29 @@ public void updatePartitionStatistics(Partition partition, Map<String, HiveColum\n                                     .withDatabaseName(partition.getDatabaseName())\n                                     .withTableName(partition.getTableName())\n                                     .withPartitionValues(partition.getValues())\n-                                    .withColumnStatisticsList(columnChunk)), writeExecutor)\n-                    ).collect(toUnmodifiableList());\n+                                    .withColumnStatisticsList(columnChunk)), writeExecutor)).collect(toUnmodifiableList());\n \n-            for (CompletableFuture<Void> writePartitionStatsFuture : writePartitionStatsFutures) {\n-                getFutureValue(writePartitionStatsFuture);\n-            }\n-\n-            boolean partitionExists = partitionExists(partition);\n-            Map<String, HiveColumnStatistics> currentColumnStatistics = partitionExists ? this.getPartitionColumnStatistics(partition) : Collections.emptyMap();\n+            Map<String, HiveColumnStatistics> currentColumnStatistics = this.getPartitionColumnStatistics(partition);\n             Set<String> removedStatistics = difference(currentColumnStatistics.keySet(), updatedColumnStatistics.keySet());\n-            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+            List<CompletableFuture<Void>> deleteStatsFutures = removedStatistics.stream()\n                     .map(column -> runAsync(() ->\n                             glueClient.deleteColumnStatisticsForPartition(new DeleteColumnStatisticsForPartitionRequest()\n                                     .withCatalogId(catalogId)\n                                     .withDatabaseName(partition.getDatabaseName())\n                                     .withTableName(partition.getTableName())\n                                     .withPartitionValues(partition.getValues())\n-                                    .withColumnName(column)), writeExecutor)\n-                    ).collect(toUnmodifiableList());\n+                                    .withColumnName(column)), writeExecutor)).collect(toUnmodifiableList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4ODYwNw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571688607", "bodyText": "drop final.", "author": "hashhar", "createdAt": "2021-02-07T20:32:41Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -217,45 +212,29 @@ public void updatePartitionStatistics(Partition partition, Map<String, HiveColum\n                                     .withDatabaseName(partition.getDatabaseName())\n                                     .withTableName(partition.getTableName())\n                                     .withPartitionValues(partition.getValues())\n-                                    .withColumnStatisticsList(columnChunk)), writeExecutor)\n-                    ).collect(toUnmodifiableList());\n+                                    .withColumnStatisticsList(columnChunk)), writeExecutor)).collect(toUnmodifiableList());\n \n-            for (CompletableFuture<Void> writePartitionStatsFuture : writePartitionStatsFutures) {\n-                getFutureValue(writePartitionStatsFuture);\n-            }\n-\n-            boolean partitionExists = partitionExists(partition);\n-            Map<String, HiveColumnStatistics> currentColumnStatistics = partitionExists ? this.getPartitionColumnStatistics(partition) : Collections.emptyMap();\n+            Map<String, HiveColumnStatistics> currentColumnStatistics = this.getPartitionColumnStatistics(partition);\n             Set<String> removedStatistics = difference(currentColumnStatistics.keySet(), updatedColumnStatistics.keySet());\n-            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+            List<CompletableFuture<Void>> deleteStatsFutures = removedStatistics.stream()\n                     .map(column -> runAsync(() ->\n                             glueClient.deleteColumnStatisticsForPartition(new DeleteColumnStatisticsForPartitionRequest()\n                                     .withCatalogId(catalogId)\n                                     .withDatabaseName(partition.getDatabaseName())\n                                     .withTableName(partition.getTableName())\n                                     .withPartitionValues(partition.getValues())\n-                                    .withColumnName(column)), writeExecutor)\n-                    ).collect(toUnmodifiableList());\n+                                    .withColumnName(column)), writeExecutor)).collect(toUnmodifiableList());\n \n-            for (CompletableFuture<Void> writeFuture : writeFutures) {\n-                getFutureValue(writeFuture);\n-            }\n+            final ImmutableList.Builder<CompletableFuture<Void>> updateOperationsFutures = ImmutableList.builderWithExpectedSize(writePartitionStatsFutures.size() + deleteStatsFutures.size());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTk0NTc0MA==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571945740", "bodyText": "simplify as above", "author": "losipiuk", "createdAt": "2021-02-08T10:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTY4ODYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTk0NDkzNw==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571944937", "bodyText": "this is not performance critical so let's just use builder() and make ti fluent:\n            List<CompletableFuture<Void>> allFutures = ImmutableList.<CompletableFuture<Void>>builder()\n                    .addAll(updateFutures)\n                    .addAll(deleteFutures)\n                    .build();\n            getFutureValue(allOf(allFutures.toArray(CompletableFuture[]::new)));", "author": "losipiuk", "createdAt": "2021-02-08T10:44:25Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -169,34 +166,32 @@ public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStati\n             List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n             List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n \n-            List<CompletableFuture<Void>> writeChunkFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+            List<CompletableFuture<Void>> updateFutures = columnChunks.stream().map(columnChunk -> runAsync(\n                     () -> glueClient.updateColumnStatisticsForTable(\n                             new UpdateColumnStatisticsForTableRequest()\n                                     .withCatalogId(catalogId)\n                                     .withDatabaseName(table.getDatabaseName())\n                                     .withTableName(table.getTableName())\n-                                    .withColumnStatisticsList(columnChunk))))\n+                                    .withColumnStatisticsList(columnChunk)), this.writeExecutor))\n                     .collect(toUnmodifiableList());\n \n-            getFutureValue(allOf(writeChunkFutures.toArray(CompletableFuture[]::new)));\n-\n-            final Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n             Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n-            List<CompletableFuture<Void>> writeFutures = removedStatistics.stream()\n+            List<CompletableFuture<Void>> deleteFutures = removedStatistics.stream()\n                     .map(column -> runAsync(() ->\n                             glueClient.deleteColumnStatisticsForTable(\n                                     new DeleteColumnStatisticsForTableRequest()\n                                             .withCatalogId(catalogId)\n                                             .withDatabaseName(table.getDatabaseName())\n                                             .withTableName(table.getTableName())\n-                                            .withColumnName(column)))\n-                    ).collect(toUnmodifiableList());\n+                                            .withColumnName(column)), this.writeExecutor)).collect(toUnmodifiableList());\n \n-            for (CompletableFuture<Void> writeFuture : writeFutures) {\n-                getFutureValue(writeFuture);\n-            }\n+            final ImmutableList.Builder<CompletableFuture<Void>> updateOperationsFutures = ImmutableList.builderWithExpectedSize(updateFutures.size() + deleteFutures.size());\n+            updateOperationsFutures.addAll(updateFutures);\n+            updateOperationsFutures.addAll(deleteFutures);\n+            getFutureValue(allOf(updateOperationsFutures.build().toArray(CompletableFuture[]::new)));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTk2MjI0NQ==", "url": "https://github.com/trinodb/trino/pull/6178#discussion_r571962245", "bodyText": "drop final", "author": "losipiuk", "createdAt": "2021-02-08T11:11:07Z", "path": "plugin/trino-hive/src/main/java/io/trino/plugin/hive/metastore/glue/DefaultGlueColumnStatisticsProvider.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.trino.plugin.hive.metastore.glue;\n+\n+import com.amazonaws.services.glue.AWSGlueAsync;\n+import com.amazonaws.services.glue.model.ColumnStatistics;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.DeleteColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.EntityNotFoundException;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForPartitionResult;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableRequest;\n+import com.amazonaws.services.glue.model.GetColumnStatisticsForTableResult;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForPartitionRequest;\n+import com.amazonaws.services.glue.model.UpdateColumnStatisticsForTableRequest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import io.trino.plugin.hive.HiveBasicStatistics;\n+import io.trino.plugin.hive.metastore.Column;\n+import io.trino.plugin.hive.metastore.HiveColumnStatistics;\n+import io.trino.plugin.hive.metastore.Partition;\n+import io.trino.plugin.hive.metastore.Table;\n+import io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil;\n+import io.trino.spi.TrinoException;\n+import io.trino.spi.statistics.ColumnStatisticType;\n+import io.trino.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.Sets.difference;\n+import static io.airlift.concurrent.MoreFutures.getFutureValue;\n+import static io.trino.plugin.hive.HiveErrorCode.HIVE_METASTORE_ERROR;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.fromGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.glue.converter.GlueStatConverter.toGlueColumnStatistics;\n+import static io.trino.plugin.hive.metastore.thrift.ThriftMetastoreUtil.getHiveBasicStatistics;\n+import static java.util.concurrent.CompletableFuture.allOf;\n+import static java.util.concurrent.CompletableFuture.runAsync;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+\n+public class DefaultGlueColumnStatisticsProvider\n+        implements GlueColumnStatisticsProvider\n+{\n+    // Read limit for AWS Glue API GetColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-GetColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_READ_STAT_PAGE_SIZE = 100;\n+\n+    // Write limit for AWS Glue API UpdateColumnStatisticsForPartition\n+    // https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-partitions.html#aws-glue-api-catalog-partitions-UpdateColumnStatisticsForPartition\n+    private static final int GLUE_COLUMN_WRITE_STAT_PAGE_SIZE = 25;\n+\n+    private final AWSGlueAsync glueClient;\n+    private final String catalogId;\n+    private final Executor readExecutor;\n+    private final Executor writeExecutor;\n+\n+    public DefaultGlueColumnStatisticsProvider(AWSGlueAsync glueClient, String catalogId, Executor readExecutor, Executor writeExecutor)\n+    {\n+        this.glueClient = glueClient;\n+        this.catalogId = catalogId;\n+        this.readExecutor = readExecutor;\n+        this.writeExecutor = writeExecutor;\n+    }\n+\n+    @Override\n+    public Set<ColumnStatisticType> getSupportedColumnStatistics(Type type)\n+    {\n+        return ThriftMetastoreUtil.getSupportedColumnStatistics(type);\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getTableColumnStatistics(Table table)\n+    {\n+        try {\n+            List<String> columnNames = getAllColumns(table);\n+            List<List<String>> columnChunks = Lists.partition(columnNames, GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+            List<CompletableFuture<GetColumnStatisticsForTableResult>> getStatsFutures = columnChunks.stream()\n+                    .map(partialColumns -> CompletableFuture.supplyAsync(() -> {\n+                        GetColumnStatisticsForTableRequest request = new GetColumnStatisticsForTableRequest()\n+                                .withCatalogId(catalogId)\n+                                .withDatabaseName(table.getDatabaseName())\n+                                .withTableName(table.getTableName())\n+                                .withColumnNames(partialColumns);\n+                        return glueClient.getColumnStatisticsForTable(request);\n+                    }, readExecutor))\n+                    .collect(toImmutableList());\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(table.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForTableResult> future : getStatsFutures) {\n+                GetColumnStatisticsForTableResult tableColumnsStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : tableColumnsStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (RuntimeException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, HiveColumnStatistics> getPartitionColumnStatistics(Partition partition)\n+    {\n+        try {\n+            List<List<Column>> columnChunks = Lists.partition(partition.getColumns(), GLUE_COLUMN_READ_STAT_PAGE_SIZE);\n+\n+            ImmutableList.Builder<CompletableFuture<GetColumnStatisticsForPartitionResult>> getStatsFutures = ImmutableList.builder();\n+            columnChunks.forEach(partialColumns -> getStatsFutures.add(CompletableFuture.supplyAsync(() -> {\n+                List<String> columnsNames = partialColumns.stream()\n+                        .map(Column::getName)\n+                        .collect(toImmutableList());\n+                GetColumnStatisticsForPartitionRequest request = new GetColumnStatisticsForPartitionRequest()\n+                        .withCatalogId(catalogId)\n+                        .withDatabaseName(partition.getDatabaseName())\n+                        .withTableName(partition.getTableName())\n+                        .withColumnNames(columnsNames)\n+                        .withPartitionValues(partition.getValues());\n+                return glueClient.getColumnStatisticsForPartition(request);\n+            }, readExecutor)));\n+\n+            HiveBasicStatistics tableStatistics = getHiveBasicStatistics(partition.getParameters());\n+            ImmutableMap.Builder<String, HiveColumnStatistics> columnStatsMapBuilder = ImmutableMap.builder();\n+            for (CompletableFuture<GetColumnStatisticsForPartitionResult> future : getStatsFutures.build()) {\n+                GetColumnStatisticsForPartitionResult partitionColumnStats = getFutureValue(future, TrinoException.class);\n+                for (ColumnStatistics columnStatistics : partitionColumnStats.getColumnStatisticsList()) {\n+                    columnStatsMapBuilder.put(\n+                            columnStatistics.getColumnName(),\n+                            fromGlueColumnStatistics(columnStatistics.getStatisticsData(), tableStatistics.getRowCount()));\n+                }\n+            }\n+            return columnStatsMapBuilder.build();\n+        }\n+        catch (EntityNotFoundException ex) {\n+            return ImmutableMap.of();\n+        }\n+        catch (RuntimeException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updateTableColumnStatistics(Table table, Map<String, HiveColumnStatistics> updatedTableColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics tableStats = getHiveBasicStatistics(table.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(table, updatedTableColumnStatistics, tableStats.getRowCount());\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> updateFutures = columnChunks.stream().map(columnChunk -> runAsync(\n+                    () -> glueClient.updateColumnStatisticsForTable(\n+                            new UpdateColumnStatisticsForTableRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(table.getDatabaseName())\n+                                    .withTableName(table.getTableName())\n+                                    .withColumnStatisticsList(columnChunk)), this.writeExecutor))\n+                    .collect(toUnmodifiableList());\n+\n+            Map<String, HiveColumnStatistics> currentTableColumnStatistics = this.getTableColumnStatistics(table);\n+            Set<String> removedStatistics = difference(currentTableColumnStatistics.keySet(), updatedTableColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> deleteFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForTable(\n+                                    new DeleteColumnStatisticsForTableRequest()\n+                                            .withCatalogId(catalogId)\n+                                            .withDatabaseName(table.getDatabaseName())\n+                                            .withTableName(table.getTableName())\n+                                            .withColumnName(column)), this.writeExecutor)).collect(toUnmodifiableList());\n+\n+            final ImmutableList.Builder<CompletableFuture<Void>> updateOperationsFutures = ImmutableList.builderWithExpectedSize(updateFutures.size() + deleteFutures.size());\n+            updateOperationsFutures.addAll(updateFutures);\n+            updateOperationsFutures.addAll(deleteFutures);\n+            getFutureValue(allOf(updateOperationsFutures.build().toArray(CompletableFuture[]::new)));\n+        }\n+        catch (RuntimeException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    @Override\n+    public void updatePartitionStatistics(Partition partition, Map<String, HiveColumnStatistics> updatedColumnStatistics)\n+    {\n+        try {\n+            HiveBasicStatistics partitionStats = getHiveBasicStatistics(partition.getParameters());\n+            List<ColumnStatistics> columnStats = toGlueColumnStatistics(partition, updatedColumnStatistics, partitionStats.getRowCount());\n+\n+            List<List<ColumnStatistics>> columnChunks = Lists.partition(columnStats, GLUE_COLUMN_WRITE_STAT_PAGE_SIZE);\n+\n+            List<CompletableFuture<Void>> writePartitionStatsFutures = columnChunks.stream()\n+                    .map(columnChunk ->\n+                            runAsync(() -> glueClient.updateColumnStatisticsForPartition(new UpdateColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnStatisticsList(columnChunk)), writeExecutor)).collect(toUnmodifiableList());\n+\n+            Map<String, HiveColumnStatistics> currentColumnStatistics = this.getPartitionColumnStatistics(partition);\n+            Set<String> removedStatistics = difference(currentColumnStatistics.keySet(), updatedColumnStatistics.keySet());\n+            List<CompletableFuture<Void>> deleteStatsFutures = removedStatistics.stream()\n+                    .map(column -> runAsync(() ->\n+                            glueClient.deleteColumnStatisticsForPartition(new DeleteColumnStatisticsForPartitionRequest()\n+                                    .withCatalogId(catalogId)\n+                                    .withDatabaseName(partition.getDatabaseName())\n+                                    .withTableName(partition.getTableName())\n+                                    .withPartitionValues(partition.getValues())\n+                                    .withColumnName(column)), writeExecutor)).collect(toUnmodifiableList());\n+\n+            final ImmutableList.Builder<CompletableFuture<Void>> updateOperationsFutures = ImmutableList.builderWithExpectedSize(writePartitionStatsFutures.size() + deleteStatsFutures.size());\n+            updateOperationsFutures.addAll(writePartitionStatsFutures);\n+            updateOperationsFutures.addAll(deleteStatsFutures);\n+            getFutureValue(allOf(updateOperationsFutures.build().toArray(CompletableFuture[]::new)));\n+        }\n+        catch (RuntimeException ex) {\n+            throw new TrinoException(HIVE_METASTORE_ERROR, ex);\n+        }\n+    }\n+\n+    private List<String> getAllColumns(Table table)\n+    {\n+        final ImmutableList.Builder<String> allColumns = ImmutableList.builderWithExpectedSize(table.getDataColumns().size() + table.getPartitionColumns().size());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f1bcfa786eee05bd1f2667b66eee52d6d0670f21", "url": "https://github.com/trinodb/trino/commit/f1bcfa786eee05bd1f2667b66eee52d6d0670f21", "message": "Glue metastore statistics integration", "committedDate": "2021-02-24T06:22:21Z", "type": "commit"}]}