{"pr_number": 5704, "pr_title": "Simplify 128 bit operations", "pr_createdAt": "2020-10-27T06:56:09Z", "pr_url": "https://github.com/trinodb/trino/pull/5704", "timeline": [{"oid": "f398139194a39236035ab3892d3ff3973ffa9c3a", "url": "https://github.com/trinodb/trino/commit/f398139194a39236035ab3892d3ff3973ffa9c3a", "message": "Extract simple bit operations to methods", "committedDate": "2020-10-27T06:53:57Z", "type": "commit"}, {"oid": "8261784b6e6d7bb72995afccca0887bf7c4b3b96", "url": "https://github.com/trinodb/trino/commit/8261784b6e6d7bb72995afccca0887bf7c4b3b96", "message": "Generify 128-bit multiplication\n\nMake both 128x64 and 128x128 multiplications use one generic method", "committedDate": "2020-10-27T06:53:57Z", "type": "commit"}, {"oid": "d44acf0a7642b5c75722a11929e74db5cc4cd7ca", "url": "https://github.com/trinodb/trino/commit/d44acf0a7642b5c75722a11929e74db5cc4cd7ca", "message": "Simplify and speed-up 128-bit multiplication\n\nRemove conditional statements from 64x64 -> 128 bit multiplication", "committedDate": "2020-10-27T06:53:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyMzQ3Mw==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r515923473", "bodyText": "Please add reverse comment (to other method), to suggest what could be written better. Now you say how it can be done worse.\nExample:\n// Consider x to increase performance by ~y%", "author": "kokosing", "createdAt": "2020-11-02T11:57:08Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -655,6 +610,7 @@ public static void multiply(Slice left, int right, Slice result)\n         pack(result, (int) z0, (int) z1, (int) z2, (int) z3, leftNegative != rightNegative);\n     }\n \n+    // Using multiply(long, long, long, long, Slice) here decreases performance by ~40%", "originalCommit": "8261784b6e6d7bb72995afccca0887bf7c4b3b96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1NzgyMA==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r515957820", "bodyText": "This is not a TODO. The code is optimal (to some degree) at this point. The comment is made so that no one wants to try generalize it more and end up loosing performance.", "author": "skrzypo987", "createdAt": "2020-11-02T13:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyMzQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk2MjQ3OA==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r515962478", "bodyText": "Consider rewriting this to stress the actual goal.", "author": "kokosing", "createdAt": "2020-11-02T13:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyMzQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyNzQ5MQ==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r515927491", "bodyText": "toUnsignedLong(getInt(left, 0)) is different than getRawLong(left, 0).\nOne expect 32 bits storage space, while other expects 64 bits.\nHow does it work?", "author": "kokosing", "createdAt": "2020-11-02T12:05:54Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -474,19 +474,24 @@ public static void multiply(Slice left, Slice right, Slice result)\n     {\n         checkArgument(result.length() == NUMBER_OF_LONGS * Long.BYTES);\n \n-        long l0 = toUnsignedLong(getInt(left, 0));\n-        long l1 = toUnsignedLong(getInt(left, 1));\n-        long l2 = toUnsignedLong(getInt(left, 2));\n-        int l3raw = getRawInt(left, 3);\n-        boolean leftNegative = isNegative(l3raw);\n-        long l3 = toUnsignedLong(unpackUnsignedInt(l3raw));\n+        multiply(getRawLong(left, 0), getRawLong(left, 1), getRawLong(right, 0), getRawLong(right, 1), result);", "originalCommit": "8261784b6e6d7bb72995afccca0887bf7c4b3b96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk1NTM5NA==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r515955394", "bodyText": "toUnsignedLong(getInt(left, 0)) does:\n\nget low 32-bits from left. If we replace 0 with 3 then the high-most bit (sign) is erased\ncast them to long as unsigned\n\nwhile getRawLong(left, 0) gets low 64 bits without any logic.\nThis is by no mean a replacement for the above. The actual sign logic and making 32-bit values is done inside the multiply method", "author": "skrzypo987", "createdAt": "2020-11-02T13:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyNzQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyOTA3Ng==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r515929076", "bodyText": "I guess this if supposed to be an optimization. Do you say that it is opposite?", "author": "kokosing", "createdAt": "2020-11-02T12:09:23Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -630,23 +630,19 @@ public static void multiply(long left, long right, Slice result)\n         long z2 = 0;\n         long z3 = 0;\n \n-        if (l0 != 0) {", "originalCommit": "d44acf0a7642b5c75722a11929e74db5cc4cd7ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk2MDMxNA==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r515960314", "bodyText": "Every if in the code enables the branch prediction mechanism (an probably many more) in CPU. Sometimes it is better to make few more ops than introduce branch programming. This appears to be the case since the code inside the brackets is fairly small.\nAnd this is not the case in the generalized multiply method.\nAt least that what benchmarks tell me.", "author": "skrzypo987", "createdAt": "2020-11-02T13:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyOTA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2NTAxOA==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r516065018", "bodyText": "How is this being measured? What benchmarks are you trying? When I wrote it this way it was precisely because some benchmarks indicated it was faster this way.", "author": "martint", "createdAt": "2020-11-02T15:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyOTA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3MzIwMg==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r516073202", "bodyText": "BenchmarkDecimalOperators.\nThis has been discussed in https://prestosql.slack.com/archives/CP1MUNEUX/p1597832153058600.\nThe generic 128x128 bit method is faster with ifs, as well as 128x64 one (which is removed in this PR).\nThe 64x64 one is in turn faster without any branches.", "author": "skrzypo987", "createdAt": "2020-11-02T15:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyOTA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NDkzMw==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r516084933", "bodyText": "Any chance for vectorization in 64x64 in java 11?", "author": "kokosing", "createdAt": "2020-11-02T16:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyOTA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjEyNjE3OQ==", "url": "https://github.com/trinodb/trino/pull/5704#discussion_r516126179", "bodyText": "TLDR - no\nThis is actually an extremely interesting subject. I discussed it with Karol heavily.\nJava will (with a little bit of help) use SIMD registers in certain situations. Unfortunately it requires operating on arrays, not single values like we do here. Making operators and functions use entire columns will likely help.\nSo we only need to reimplement half of core presto to make it work. Might seems a little excessive at this point though.\nThis - https://openjdk.java.net/jeps/338 - may help.", "author": "skrzypo987", "createdAt": "2020-11-02T17:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyOTA3Ng=="}], "type": "inlineReview"}]}