{"pr_number": 4669, "pr_title": "Apply DomainTranslator to STARTS_WITH function", "pr_createdAt": "2020-08-02T18:19:48Z", "pr_url": "https://github.com/trinodb/trino/pull/4669", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NjQ2MA==", "url": "https://github.com/trinodb/trino/pull/4669#discussion_r464276460", "bodyText": "please extarct args.get(0) and args.get(1) as separate variables", "author": "sopel39", "createdAt": "2020-08-03T08:46:44Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainTranslator.java", "diffHunk": "@@ -928,7 +931,55 @@ protected ExtractionResult visitLikePredicate(LikePredicate node, Boolean comple\n             }\n \n             Slice constantPrefix = LikeFunctions.unescapeLiteralLikePattern(pattern.slice(0, patternConstantPrefixBytes), escape);\n+            return createRangeDomain(type, constantPrefix).map(domain -> new ExtractionResult(TupleDomain.withColumnDomains(ImmutableMap.of(symbol, domain)), node));\n+        }\n+\n+        @Override\n+        protected ExtractionResult visitFunctionCall(FunctionCall node, Boolean complement)\n+        {\n+            String name = ResolvedFunction.extractFunctionName(node.getName());\n+            if (name.equals(\"starts_with\")) {\n+                Optional<ExtractionResult> result = tryVisitStartsWithFunction(node, complement);\n+                if (result.isPresent()) {\n+                    return result.get();\n+                }\n+            }\n+            return visitExpression(node, complement);\n+        }\n+\n+        private Optional<ExtractionResult> tryVisitStartsWithFunction(FunctionCall node, Boolean complement)\n+        {\n+            List<Expression> args = node.getArguments();\n+            if (args.size() != 2) {\n+                return Optional.empty();\n+            }\n+            if (!(args.get(0) instanceof SymbolReference)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ1NjE5OQ==", "url": "https://github.com/trinodb/trino/pull/4669#discussion_r464456199", "bodyText": "fixed.", "author": "takezoe", "createdAt": "2020-08-03T14:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NjQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NzgxMQ==", "url": "https://github.com/trinodb/trino/pull/4669#discussion_r464277811", "bodyText": "add some edge cases like:\n\nempty pattern.\npattern with trailing spaces\npattern with escaped .* or /", "author": "sopel39", "createdAt": "2020-08-03T08:49:14Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainTranslator.java", "diffHunk": "@@ -1582,6 +1582,30 @@ public void testLikePredicate()\n         assertUnsupportedPredicate(not(like(C_VARCHAR, stringLiteral(\"abc\\\\_def\"))));\n     }\n \n+    @Test\n+    public void testStartsWithFunction()\n+    {\n+        Type varcharType = createUnboundedVarcharType();\n+\n+        // constant\n+        testSimpleComparison(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MTQ5OA==", "url": "https://github.com/trinodb/trino/pull/4669#discussion_r464461498", "bodyText": "Added empty pattern which is not supported in domain translation and _ prefix pattern which is treated as a constant string as different from LIKE.\n\n\npattern with trailing spaces\npattern with escaped .* or /\n\n\nWhat do these cases test? Unlike LIKE predicate, STARTS_WITH function always treats the second argument as  a constant string. It doesn't care whether characters are escaped or not.", "author": "takezoe", "createdAt": "2020-08-03T14:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NTc4Mg==", "url": "https://github.com/trinodb/trino/pull/4669#discussion_r464475782", "bodyText": "What do these cases test? Unlike LIKE predicate, STARTS_WITH function always treats the second argument as a constant string. It doesn't care whether characters are escaped or not.\n\nYou are right.", "author": "sopel39", "createdAt": "2020-08-03T15:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NzgxMQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NTk0Ng==", "url": "https://github.com/trinodb/trino/pull/4669#discussion_r464475946", "bodyText": "Could you add test for complement case?", "author": "sopel39", "createdAt": "2020-08-03T15:08:48Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainTranslator.java", "diffHunk": "@@ -1582,6 +1582,39 @@ public void testLikePredicate()\n         assertUnsupportedPredicate(not(like(C_VARCHAR, stringLiteral(\"abc\\\\_def\"))));\n     }\n \n+    @Test\n+    public void testStartsWithFunction()\n+    {\n+        Type varcharType = createUnboundedVarcharType();\n+\n+        // constant\n+        testSimpleComparison(\n+                startsWith(C_VARCHAR, stringLiteral(\"abc\")),\n+                C_VARCHAR,\n+                startsWith(C_VARCHAR, stringLiteral(\"abc\")),\n+                Domain.create(ValueSet.ofRanges(Range.range(varcharType, utf8Slice(\"abc\"), true, utf8Slice(\"abd\"), false)), false));\n+\n+        testSimpleComparison(\n+                startsWith(C_VARCHAR, stringLiteral(\"_abc\")),\n+                C_VARCHAR,\n+                startsWith(C_VARCHAR, stringLiteral(\"_abc\")),\n+                Domain.create(ValueSet.ofRanges(Range.range(varcharType, utf8Slice(\"_abc\"), true, utf8Slice(\"_abd\"), false)), false));\n+\n+        // empty\n+        assertUnsupportedPredicate(startsWith(C_VARCHAR, stringLiteral(\"\")));\n+\n+        // non-ASCII\n+        testSimpleComparison(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0Mzg4Ng==", "url": "https://github.com/trinodb/trino/pull/4669#discussion_r464543886", "bodyText": "Added.", "author": "takezoe", "createdAt": "2020-08-03T17:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NTk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NzMxOA==", "url": "https://github.com/trinodb/trino/pull/4669#discussion_r464477318", "bodyText": "Could you add a test for generic function call (that it's not supported)?", "author": "sopel39", "createdAt": "2020-08-03T15:11:02Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainTranslator.java", "diffHunk": "@@ -1582,6 +1582,39 @@ public void testLikePredicate()\n         assertUnsupportedPredicate(not(like(C_VARCHAR, stringLiteral(\"abc\\\\_def\"))));\n     }\n \n+    @Test\n+    public void testStartsWithFunction()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0NDExNg==", "url": "https://github.com/trinodb/trino/pull/4669#discussion_r464544116", "bodyText": "Added testUnsupportedFunctions() which tests some unsupported functions.", "author": "takezoe", "createdAt": "2020-08-03T17:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NzMxOA=="}], "type": "inlineReview"}, {"oid": "990129e242961fc0603e186a746c4f53070efe55", "url": "https://github.com/trinodb/trino/commit/990129e242961fc0603e186a746c4f53070efe55", "message": "Apply DomainTranslator to STARTS_WITH function", "committedDate": "2020-08-03T17:05:29Z", "type": "commit"}, {"oid": "990129e242961fc0603e186a746c4f53070efe55", "url": "https://github.com/trinodb/trino/commit/990129e242961fc0603e186a746c4f53070efe55", "message": "Apply DomainTranslator to STARTS_WITH function", "committedDate": "2020-08-03T17:05:29Z", "type": "forcePushed"}]}