{"pr_number": 3305, "pr_title": "Call applyProjection during table scan column pruning", "pr_createdAt": "2020-04-01T18:07:24Z", "pr_url": "https://github.com/trinodb/trino/pull/3305", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTc1MQ==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402139751", "bodyText": "what's the relation between this rule and PushProjectionIntoTableScan?", "author": "findepi", "createdAt": "2020-04-02T08:30:47Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0NTI0Nw==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402445247", "bodyText": "That's a good question. PushProjectionIntoTableScan is more general, as it can push down arbitrary sub-expressions from the projection. We'll probably want to remove this one, but I didn't want to conflate issues in this PR.", "author": "martint", "createdAt": "2020-04-02T16:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzNjIxMg==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402136212", "bodyText": "`filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains);", "author": "kokosing", "createdAt": "2020-04-02T08:24:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzNjcwNg==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402136706", "bodyText": "toImmutableMap", "author": "kokosing", "createdAt": "2020-04-02T08:25:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()\n+                .filter(referencedOutputs::contains)\n+                .collect(toImmutableList());\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(Collectors.toMap(Symbol::getName, node.getAssignments()::get)));\n+\n+        Map<Symbol, ColumnHandle> newAssignments;\n+        // Attempt to push down the constrained list of columns into the connector.\n+        // Bail out if the connector does anything other than limit the list of columns (e.g., if it synthesizes arbitrary expressions)\n+        if (result.isPresent() && result.get().getProjections().stream().allMatch(Variable.class::isInstance)) {\n+            handle = result.get().getHandle();\n+\n+            Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));\n+\n+            ImmutableMap.Builder<Symbol, ColumnHandle> builder = ImmutableMap.builder();\n+            for (int i = 0; i < newOutputs.size(); i++) {\n+                Variable variable = (Variable) result.get().getProjections().get(i);\n+                builder.put(newOutputs.get(i), assignments.get(variable.getName()));\n+            }\n+\n+            newAssignments = builder.build();\n+        }\n+        else {\n+            newAssignments = newOutputs.stream()\n+                    .collect(Collectors.toMap(Function.identity(), node.getAssignments()::get));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzNjc3Ng==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402136776", "bodyText": "toImmutableMap", "author": "kokosing", "createdAt": "2020-04-02T08:25:38Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()\n+                .filter(referencedOutputs::contains)\n+                .collect(toImmutableList());\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(Collectors.toMap(Symbol::getName, node.getAssignments()::get)));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTE2NQ==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402139165", "bodyText": "I think we should fail in case when connector returns something that engine does not support. Otherwise applyProjection is ineffective.\nIs it an actual case? Is there such connector that does something more than limit of columns?", "author": "kokosing", "createdAt": "2020-04-02T08:29:48Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()\n+                .filter(referencedOutputs::contains)\n+                .collect(toImmutableList());\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(Collectors.toMap(Symbol::getName, node.getAssignments()::get)));\n+\n+        Map<Symbol, ColumnHandle> newAssignments;\n+        // Attempt to push down the constrained list of columns into the connector.\n+        // Bail out if the connector does anything other than limit the list of columns (e.g., if it synthesizes arbitrary expressions)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0ODE3OA==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402448178", "bodyText": "No, it's perfectly legal for a connector to produce projections other than simple column references. For instance, it might decide that a column is constant and return a constant expression in its place.\n\nOtherwise applyProjection is ineffective.\n\nSee my comment here #3305 (comment)", "author": "martint", "createdAt": "2020-04-02T16:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxMzI2Mg==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402913262", "bodyText": "it's perfectly legal for a connector to produce projections other than simple column references\n\nI get that.\nHowever, we trying here to pushdown limiting identity projection here (no fancy expressions here). Connector returned new table handle and some expressions. In case when we notice that there are some expressions we do not support, we should fail and not to try to return table scan node that has old handle and new assignments (that do not match table handle stored in table scan node) like it is right now.  Is it safe to just ignore what connector returned?", "author": "kokosing", "createdAt": "2020-04-03T10:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA3Nzk0Nw==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r403077947", "bodyText": "We could ask connector to project all ROW's fields.\nAnd connector says \"hey, i will give you the ROW itself\", and please do projections on the engine side.\nI don't know why connector would choose that, but that's supposed to be legal, but cannot be accepted with current code.\n@martint i think this if deserves a TODO note, along maybe with \"merge PruneTableScanColumns with PushProjectionIntoTableScan rules\".", "author": "findepi", "createdAt": "2020-04-03T15:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2NzE3Mw==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r403267173", "bodyText": "I don't know why connector would choose that, but that's supposed to be legal, but cannot be accepted with current code.\n\nIndeed. That's beyond the scope of this change and is handled by PushProjectionIntoTableScan (given the expectation that when pruning columns with rules there's always a projection above the tablescan). As I said above, this rule should probably be replaced by PushProjectionIntoTableScan, but I didn't want to go down that path just yet as it's a more involved process of tracking down all the places where it needs to be replaced, ensuring there are no other unwanted side-effects, etc.\nI'll add a TODO, though. That seems fair.", "author": "martint", "createdAt": "2020-04-03T19:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEzOTI4OQ==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402139289", "bodyText": "toImmutableMap", "author": "kokosing", "createdAt": "2020-04-02T08:29:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,109 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n-import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = node.getOutputSymbols().stream()\n+                .filter(referencedOutputs::contains)\n+                .collect(toImmutableList());\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(Collectors.toMap(Symbol::getName, node.getAssignments()::get)));\n+\n+        Map<Symbol, ColumnHandle> newAssignments;\n+        // Attempt to push down the constrained list of columns into the connector.\n+        // Bail out if the connector does anything other than limit the list of columns (e.g., if it synthesizes arbitrary expressions)\n+        if (result.isPresent() && result.get().getProjections().stream().allMatch(Variable.class::isInstance)) {\n+            handle = result.get().getHandle();\n+\n+            Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MDEzMg==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402140132", "bodyText": "private", "author": "kokosing", "createdAt": "2020-04-02T08:31:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PruneUnreferencedOutputs.java", "diffHunk": "@@ -118,12 +130,27 @@ public PlanNode optimize(PlanNode plan, Session session, TypeProvider types, Sym\n         requireNonNull(symbolAllocator, \"symbolAllocator is null\");\n         requireNonNull(idAllocator, \"idAllocator is null\");\n \n-        return SimplePlanRewriter.rewriteWith(new Rewriter(), plan, ImmutableSet.of());\n+        return SimplePlanRewriter.rewriteWith(new Rewriter(metadata, types, typeAnalyzer, symbolAllocator, session), plan, ImmutableSet.of());\n     }\n \n     private static class Rewriter\n             extends SimplePlanRewriter<Set<Symbol>>\n     {\n+        private final Metadata metadata;\n+        private final TypeProvider types;\n+        private final TypeAnalyzer typeAnalyzer;\n+        private final SymbolAllocator symbolAllocator;\n+        private final Session session;\n+\n+        public Rewriter(Metadata metadata, TypeProvider types, TypeAnalyzer typeAnalyzer, SymbolAllocator symbolAllocator, Session session)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0OTcxOQ==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402449719", "bodyText": "From the point of view of the class, the constructor is public. The class itself is private.", "author": "martint", "createdAt": "2020-04-02T16:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE0MDEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MDg3Ng==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402850876", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(Symbol::toSymbolReference)\n          \n          \n            \n                            .map(expression -> ConnectorExpressionTranslator.translate(\n          \n          \n            \n                                    session,\n          \n          \n            \n                                    expression,\n          \n          \n            \n                                    typeAnalyzer,\n          \n          \n            \n                                    types))\n          \n          \n            \n                            .map(Optional::get)\n          \n          \n            \n                            .map(symbol -> new Variable(symbol.getName(), types.get(symbol)))\n          \n      \n    \n    \n  \n\nnot only simple, this has added benefit that i dont have to wonder whether Optional can be empty ie whether ::get is safe", "author": "findepi", "createdAt": "2020-04-03T08:52:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,108 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = filteredCopy(node.getOutputSymbols(), referencedOutputs::contains);\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NDEyNw==", "url": "https://github.com/trinodb/trino/pull/3305#discussion_r402894127", "bodyText": "#3324 prevents NPE here.", "author": "findepi", "createdAt": "2020-04-03T09:57:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -13,34 +13,108 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;\n \n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.TypeProvider;\n import io.prestosql.sql.planner.plan.PlanNode;\n import io.prestosql.sql.planner.plan.TableScanNode;\n \n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n \n-import static com.google.common.collect.Maps.filterKeys;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n import static io.prestosql.util.MoreLists.filteredCopy;\n+import static java.util.Objects.requireNonNull;\n \n public class PruneTableScanColumns\n         extends ProjectOffPushDownRule<TableScanNode>\n {\n-    public PruneTableScanColumns()\n+    private final Metadata metadata;\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n     {\n         super(tableScan());\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n     }\n \n     @Override\n-    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode tableScanNode, Set<Symbol> referencedOutputs)\n+    protected Optional<PlanNode> pushDownProjectOff(Context context, TableScanNode node, Set<Symbol> referencedOutputs)\n     {\n-        return Optional.of(\n-                new TableScanNode(\n-                        tableScanNode.getId(),\n-                        tableScanNode.getTable(),\n-                        filteredCopy(tableScanNode.getOutputSymbols(), referencedOutputs::contains),\n-                        filterKeys(tableScanNode.getAssignments(), referencedOutputs::contains),\n-                        tableScanNode.getEnforcedConstraint()));\n+        Session session = context.getSession();\n+        TypeProvider types = context.getSymbolAllocator().getTypes();\n+\n+        return pruneColumns(metadata, typeAnalyzer, types, session, node, referencedOutputs);\n+    }\n+\n+    public static Optional<PlanNode> pruneColumns(Metadata metadata, TypeAnalyzer typeAnalyzer, TypeProvider types, Session session, TableScanNode node, Set<Symbol> referencedOutputs)\n+    {\n+        List<Symbol> newOutputs = filteredCopy(node.getOutputSymbols(), referencedOutputs::contains);\n+\n+        if (newOutputs.size() == node.getOutputSymbols().size()) {\n+            return Optional.empty();\n+        }\n+\n+        List<ConnectorExpression> projections = newOutputs.stream()\n+                .map(Symbol::toSymbolReference)\n+                .map(expression -> ConnectorExpressionTranslator.translate(\n+                        session,\n+                        expression,\n+                        typeAnalyzer,\n+                        types))\n+                .map(Optional::get)\n+                .collect(toImmutableList());\n+\n+        TableHandle handle = node.getTable();\n+        Optional<ProjectionApplicationResult<TableHandle>> result = metadata.applyProjection(\n+                session,\n+                handle,\n+                projections,\n+                newOutputs.stream()\n+                        .collect(toImmutableMap(Symbol::getName, node.getAssignments()::get)));\n+\n+        Map<Symbol, ColumnHandle> newAssignments;\n+        // Attempt to push down the constrained list of columns into the connector.\n+        // Bail out if the connector does anything other than limit the list of columns (e.g., if it synthesizes arbitrary expressions)\n+        if (result.isPresent() && result.get().getProjections().stream().allMatch(Variable.class::isInstance)) {\n+            handle = result.get().getHandle();\n+\n+            Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n+                    .collect(toImmutableMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));\n+\n+            ImmutableMap.Builder<Symbol, ColumnHandle> builder = ImmutableMap.builder();\n+            for (int i = 0; i < newOutputs.size(); i++) {\n+                Variable variable = (Variable) result.get().getProjections().get(i);\n+                builder.put(newOutputs.get(i), assignments.get(variable.getName()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "79d2872545279db7ebae6aa2c8ef7b678c58ced5", "url": "https://github.com/trinodb/trino/commit/79d2872545279db7ebae6aa2c8ef7b678c58ced5", "message": "Call applyProjection during table scan column pruning\n\nThe existing code was limiting the columns in the TableScan node\nbut wasn't providing this information to connectors. Some connectors\ncan leverage this information during split generation.", "committedDate": "2020-04-03T21:27:25Z", "type": "commit"}, {"oid": "79d2872545279db7ebae6aa2c8ef7b678c58ced5", "url": "https://github.com/trinodb/trino/commit/79d2872545279db7ebae6aa2c8ef7b678c58ced5", "message": "Call applyProjection during table scan column pruning\n\nThe existing code was limiting the columns in the TableScan node\nbut wasn't providing this information to connectors. Some connectors\ncan leverage this information during split generation.", "committedDate": "2020-04-03T21:27:25Z", "type": "forcePushed"}]}