{"pr_number": 3414, "pr_title": "Allow blocking page source until dynamic filters are ready", "pr_createdAt": "2020-04-11T12:22:48Z", "pr_url": "https://github.com/trinodb/trino/pull/3414", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgyNTcwMA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r409825700", "bodyText": "Call this DynamicFilter", "author": "martint", "createdAt": "2020-04-16T20:22:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DynamicFilterSupplier.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.TupleDomain;\n+\n+public interface DynamicFilterSupplier", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgyNjE1MA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r409826150", "bodyText": "Call this isBlocked, similar to how we do it elsewhere (e.g., ConnectorPageSource)", "author": "martint", "createdAt": "2020-04-16T20:23:20Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DynamicFilterSupplier.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.TupleDomain;\n+\n+public interface DynamicFilterSupplier\n+{\n+    DynamicFilterSupplier EMPTY = new DynamicFilterSupplier() {\n+        @Override\n+        public ListenableFuture<?> getBlockingFuture()\n+        {\n+            return Futures.immediateFuture(null);  // no blocking\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();  // no filtering\n+        }\n+    };\n+\n+    ListenableFuture<?> getBlockingFuture();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgyNzA2NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r409827065", "bodyText": "What are the semantics of this method with respect to getCurrentPredicate? Is it intended to block until there is some predicate available, even if the predicate continues to change after?", "author": "martint", "createdAt": "2020-04-16T20:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgyNjE1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI5MDEzNA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r410290134", "bodyText": "What are the semantics of this method with respect to getCurrentPredicate?\n\nIt should block until all dynamic filters are collected, or the specified timeout expires.\nIf the timeout expires, the predicate returned by getCurrentPredicate may change after all filters are eventually collected.\nI have added the comment here, and also at LocalDynamicFiltersCollector and LocalExecutionPlanner.", "author": "rzeyde-varada", "createdAt": "2020-04-17T15:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgyNjE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgzMzMwMQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r409833301", "bodyText": "Something to watch out for is who adds listeners to this future and how many times this happens. We've seen problems in the past where we \"leak\" registrations (rather, add too many listeners, which end up causing performance problems and OOM)", "author": "martint", "createdAt": "2020-04-16T20:37:20Z", "path": "presto-main/src/main/java/io/prestosql/operator/ScanFilterAndProjectOperator.java", "diffHunk": "@@ -242,16 +245,23 @@ else if (cursor != null) {\n \n             checkState(cursor == null && pageSource == null, \"Table scan split already set\");\n \n-            if (!dynamicFilter.get().isAll()) {\n-                dynamicFilterSplitsProcessed++;\n+            ListenableFuture<?> dynamicFilterFuture = dynamicFilterSupplier.getBlockingFuture();\n+            if (!dynamicFilterFuture.isDone()) {\n+                return blocked(dynamicFilterFuture);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTUzNA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r410429534", "bodyText": "IIUC, we propagate this future to Driver#firstFinishedFuture, which registers a single listener for each blocked operator future:\nhttps://github.com/prestosql/presto/blob/6541b8fd0bcb05b86755274b495673d67b4dea37/presto-main/src/main/java/io/prestosql/operator/Driver.java#L635-L648\n(found by running testJoinDynamicFilteringBlockProbeSide integration test)\nNot sure though whether it's the only place where this future is being used.", "author": "rzeyde-varada", "createdAt": "2020-04-17T19:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgzMzMwMQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3MDc2MA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r423570760", "bodyText": "you could extract this as:\n    ListenableFuture<?> NOT_BLOCKED = Futures.immediateFuture(null);", "author": "sopel39", "createdAt": "2020-05-12T08:52:08Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DynamicFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.TupleDomain;\n+\n+public interface DynamicFilter\n+{\n+    DynamicFilter EMPTY = new DynamicFilter() {\n+        @Override\n+        public ListenableFuture<?> isBlocked()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI5NDg4NA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r424294884", "bodyText": "Done.", "author": "rzeyde-varada", "createdAt": "2020-05-13T09:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3MDc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NTcwMw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r423575703", "bodyText": "I think we might want to any dynamic filter to materialize. You might never get all dynamic filters (e.g TopN filters could constantly narrow dawn domain).", "author": "sopel39", "createdAt": "2020-05-12T08:59:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DynamicFilter.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.TupleDomain;\n+\n+public interface DynamicFilter\n+{\n+    DynamicFilter EMPTY = new DynamicFilter() {\n+        @Override\n+        public ListenableFuture<?> isBlocked()\n+        {\n+            return Futures.immediateFuture(null);  // no blocking\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();  // no filtering\n+        }\n+    };\n+\n+    // Block until all dynamic filters are collected, or the a timeout expires.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI5NDk3NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r424294975", "bodyText": "Done.", "author": "rzeyde-varada", "createdAt": "2020-05-13T09:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3NTcwMw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkwNjMxMg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r442906312", "bodyText": "let's move that to SPI", "author": "sopel39", "createdAt": "2020-06-19T15:29:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DynamicFilter.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxMDY0OA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r442910648", "bodyText": "Let's change the contract for it:\nBlock until dynamic filter is narrowed down.\nDynamic filter might be narrowed down multiple times during query runtime.", "author": "sopel39", "createdAt": "2020-06-19T15:38:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DynamicFilter.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.TupleDomain;\n+\n+public interface DynamicFilter\n+{\n+    ListenableFuture<?> NOT_BLOCKED = Futures.immediateFuture(null);\n+\n+    DynamicFilter EMPTY = new DynamicFilter()\n+    {\n+        @Override\n+        public ListenableFuture<?> isBlocked()\n+        {\n+            return NOT_BLOCKED;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();  // no filtering\n+        }\n+    };\n+\n+    // Block until any dynamic filter is collected, or the a timeout expires.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxMTE4Mw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r442911183", "bodyText": "Javadoc uses\n/**\n * comment\n */\n\nstyle", "author": "sopel39", "createdAt": "2020-06-19T15:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxMDY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxMTUyOQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r442911529", "bodyText": "Let's add another method:\n/**\n * Returns true it dynamic filter cannot be narrowed more.\n */\nboolean isComplete();", "author": "sopel39", "createdAt": "2020-06-19T15:39:47Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DynamicFilter.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.TupleDomain;\n+\n+public interface DynamicFilter\n+{\n+    ListenableFuture<?> NOT_BLOCKED = Futures.immediateFuture(null);\n+\n+    DynamicFilter EMPTY = new DynamicFilter()\n+    {\n+        @Override\n+        public ListenableFuture<?> isBlocked()\n+        {\n+            return NOT_BLOCKED;\n+        }\n+\n+        @Override\n+        public TupleDomain<ColumnHandle> getCurrentPredicate()\n+        {\n+            return TupleDomain.all();  // no filtering\n+        }\n+    };\n+\n+    // Block until any dynamic filter is collected, or the a timeout expires.\n+    // If the timeout expires, the predicate returned below may change after all filters are eventually collected.\n+    ListenableFuture<?> isBlocked();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxMjk0OA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r442912948", "bodyText": "Let's split it into two commits (at least):\n\nFirst commit that introduces possibility for connectors to wait for dynamic filters in ConnectorPageSourceProvider\nA second commit that adds dynamic_filtering_probe_side_blocking_timeout if we decide we want this parameter after all.\n\nAlternatively, we could just have two PRs", "author": "sopel39", "createdAt": "2020-06-19T15:42:30Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestOrcPageSourceMemoryTracking.java", "diffHunk": "@@ -46,6 +46,7 @@\n import io.prestosql.spi.type.Type;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxNDQ2Mw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r442914463", "bodyText": "I would simplify this property and just make it:\ndynamic_filtering_blocking_timeout\n\nnow that we have partition pruning on coordinator. Note that lazy dynamic filters on coordinator should be separate PR (and not this one).", "author": "sopel39", "createdAt": "2020-06-19T15:45:32Z", "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -125,6 +125,7 @@\n     public static final String QUERY_MAX_TOTAL_MEMORY_PER_NODE = \"query_max_total_memory_per_node\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_ROW_COUNT = \"dynamic_filtering_max_per_driver_row_count\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_SIZE = \"dynamic_filtering_max_per_driver_size\";\n+    public static final String DYNAMIC_FILTERING_PROBE_SIDE_BLOCKING_TIMEOUT = \"dynamic_filtering_probe_side_blocking_timeout\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIxMTg3Nw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450211877", "bodyText": "Rebase on: #4224", "author": "sopel39", "createdAt": "2020-07-06T13:15:13Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/DynamicFilter.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.predicate.TupleDomain;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface DynamicFilter", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIxNTk4MA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450215980", "bodyText": "In other tests we just use:\n        Set<Long> rowsRead = stats.getOperatorSummaries()\n                .stream()\n                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n                .map(OperatorStats::getInputPositions)\n                .collect(toImmutableSet());\n\nWe could abstract this code instead", "author": "sopel39", "createdAt": "2020-07-06T13:22:10Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -83,6 +91,49 @@ public void testSelect()\n         assertQueryResult(\"SELECT count(*) FROM test_select\", 75L);\n     }\n \n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n+                .setSystemProperty(PUSH_PARTIAL_AGGREGATION_THROUGH_JOIN, \"true\")\n+                .build();\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, \"SELECT MAX(quantity) FROM lineitem JOIN orders \" +\n+                \"ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\");\n+\n+        OperatorStats probeStats = getProbeSideScanStats(result.getQueryId());\n+        assertEquals(probeStats.getInputPositions(), 6L);\n+    }\n+\n+    private OperatorStats getProbeSideScanStats(QueryId queryId)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNTgxNg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450225816", "bodyText": "remove", "author": "sopel39", "createdAt": "2020-07-06T13:37:49Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -83,6 +91,49 @@ public void testSelect()\n         assertQueryResult(\"SELECT count(*) FROM test_select\", 75L);\n     }\n \n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n+                .setSystemProperty(PUSH_PARTIAL_AGGREGATION_THROUGH_JOIN, \"true\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMxMTQwOA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r453311408", "bodyText": "I have rewritten the test to use multi-join in order to verify the blocking behaviour:\nhttps://github.com/prestosql/presto/pull/3414/files#diff-6102dfcf993241d1413b4fc63e4ca5a9R128\nWDYT?", "author": "rzeyde-varada", "createdAt": "2020-07-12T12:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNTgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNjQ0Mw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450226443", "bodyText": "add aggregation explicitly below join within query, e.g:\nSELECT * FROM (SELECT MAX(quantity), orderkey FROM lineitem GROUP BY orderkey) JOIN orders on ...", "author": "sopel39", "createdAt": "2020-07-06T13:38:54Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -83,6 +91,49 @@ public void testSelect()\n         assertQueryResult(\"SELECT count(*) FROM test_select\", 75L);\n     }\n \n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n+                .setSystemProperty(PUSH_PARTIAL_AGGREGATION_THROUGH_JOIN, \"true\")\n+                .build();\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, \"SELECT MAX(quantity) FROM lineitem JOIN orders \" +", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMxMTI3Nw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r453311277", "bodyText": "Not sure I understand the suggestion - if I use the following query:\nSELECT * \nFROM (SELECT MAX(quantity), orderkey FROM lineitem GROUP BY orderkey) l\nJOIN orders \nON   l.orderkey = orders.orderkey;\nIt results in a distributed join (due to a repartition operator between the TableScan of lineitem and MAX aggregation:\n Fragment 1 [HASH]                                                                                                                                                                                          \n     Output layout: [max, orderkey, custkey, orderstatus, totalprice, orderdate, orderpriority, clerk, shippriority, comment_10]                                                                            \n     Output partitioning: SINGLE []                                                                                                                                                                         \n     Stage Execution Strategy: UNGROUPED_EXECUTION                                                                                                                                                          \n     InnerJoin[(\"orderkey\" = \"orderkey_9\")][$hashvalue_59, $hashvalue_60]                                                                                                                                   \n     \u2502   Layout: [orderkey:bigint, max:double, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_10:var\n     \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}                                                                                                                                            \n     \u2502   Distribution: PARTITIONED                                                                                                                                                                          \n     \u2502   dynamicFilterAssignments = {orderkey_9 -> df_283}                                                                                                                                                  \n     \u251c\u2500 Project[]                                                                                                                                                                                           \n     \u2502  \u2502   Layout: [orderkey:bigint, max:double, $hashvalue_59:bigint]                                                                                                                                     \n     \u2502  \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}                                                                                                                                         \n     \u2502  \u2502   $hashvalue_59 := combine_hash(bigint '0', COALESCE(\"$operator$hash_code\"(\"orderkey\"), 0))                                                                                                       \n     \u2502  \u2514\u2500 Aggregate[orderkey]                                                                                                                                                                              \n     \u2502     \u2502   Layout: [orderkey:bigint, max:double]                                                                                                                                                        \n     \u2502     \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}                                                                                                                                      \n     \u2502     \u2502   max := max(\"quantity\")                                                                                                                                                                       \n     \u2502     \u2514\u2500 LocalExchange[HASH][$hashvalue] (\"orderkey\")                                                                                                                                                  \n     \u2502        \u2502   Layout: [orderkey:bigint, quantity:double, $hashvalue:bigint]                                                                                                                             \n     \u2502        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: ?}                                                                                                                                  \n     \u2502        \u2514\u2500 RemoteSource[2]                                                                                                                                                                            \n     \u2502               Layout: [orderkey:bigint, quantity:double, $hashvalue_57:bigint]                                                                                                                       \n     \u2514\u2500 LocalExchange[HASH][$hashvalue_60] (\"orderkey_9\")                                                                                                                                                   \n        \u2502   Layout: [orderkey_9:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_10:varchar(79\n        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: ?}                                                                                                                                        \n        \u2514\u2500 RemoteSource[3]                                                                                                                                                                                  \n               Layout: [orderkey_9:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_10:varchar\n\nBut then, local dynamic filtering doesn't take place - because it needs broadcast join...", "author": "rzeyde-varada", "createdAt": "2020-07-12T12:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyNjQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyODYxMg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450228612", "bodyText": "Instead, add a wrapping page source, e.g:\nDynamicFilteringPageSource\n\nthat would have FixedPageSource as a delegate field", "author": "sopel39", "createdAt": "2020-07-06T13:42:14Z", "path": "presto-memory/src/main/java/io/prestosql/plugin/memory/MemoryPageSourceProvider.java", "diffHunk": "@@ -83,9 +76,33 @@ public ConnectorPageSource createPageSource(\n                 expectedRows,\n                 memorySplit.getLimit(),\n                 sampleRatio);\n-        return new FixedPageSource(pages.stream()\n-                .map(page -> applyFilter(page, domains))\n-                .collect(toList()));\n+\n+        return new FixedPageSource(pages)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMxMDEwMA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r453310100", "bodyText": "Hope I did it correctly at https://github.com/prestosql/presto/pull/3414/files#diff-8b4a37d650086d97552712b506dfb6a8...", "author": "rzeyde-varada", "createdAt": "2020-07-12T12:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIyODYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMTM0OA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450231348", "bodyText": "add a feature toggle for disabling lazy dynamic filtering in memory connector", "author": "sopel39", "createdAt": "2020-07-06T13:46:20Z", "path": "presto-memory/src/main/java/io/prestosql/plugin/memory/MemoryPageSourceProvider.java", "diffHunk": "@@ -13,7 +13,6 @@\n  */", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMwOTk2NA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r453309964", "bodyText": "Should I also add a session property to allow disabling this feature in runtime?", "author": "rzeyde-varada", "createdAt": "2020-07-12T12:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYzMzUyMg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475633522", "bodyText": "Should I also add a session property to allow disabling this feature in runtime?\n\nI don't think it's needed", "author": "sopel39", "createdAt": "2020-08-24T14:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMTQ2MA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450231460", "bodyText": "unrelated, undo", "author": "sopel39", "createdAt": "2020-07-06T13:46:29Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestShowQueries.java", "diffHunk": "@@ -107,7 +107,7 @@ public void testShowSessionLike()\n     {\n         assertThat(assertions.query(\n                 \"SHOW SESSION LIKE '%page_row_c%'\"))\n-                .matches(\"VALUES ('filter_and_project_min_output_page_row_count', cast('256' as VARCHAR(14)), cast('256' as VARCHAR(14)), 'integer', cast('Experimental: Minimum output page row count for filter and project operators' as VARCHAR(118)))\");\n+                .matches(\"VALUES (cast('filter_and_project_min_output_page_row_count' as VARCHAR(44)), cast('256' as VARCHAR(14)), cast('256' as VARCHAR(14)), 'integer', cast('Experimental: Minimum output page row count for filter and project operators' as VARCHAR(118)))\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMTUzNA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450231534", "bodyText": "ditto", "author": "sopel39", "createdAt": "2020-07-06T13:46:36Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestShowQueries.java", "diffHunk": "@@ -119,7 +119,7 @@ public void testShowSessionLikeWithEscape()\n                 .hasMessage(\"Escape string must be a single character\");\n         assertThat(assertions.query(\n                 \"SHOW SESSION LIKE '%page$_row$_c%' ESCAPE '$'\"))\n-                .matches(\"VALUES ('filter_and_project_min_output_page_row_count', cast('256' as VARCHAR(14)), cast('256' as VARCHAR(14)), 'integer', cast('Experimental: Minimum output page row count for filter and project operators' as VARCHAR(118)))\");\n+                .matches(\"VALUES (cast('filter_and_project_min_output_page_row_count' as VARCHAR(44)), cast('256' as VARCHAR(14)), cast('256' as VARCHAR(14)), 'integer', cast('Experimental: Minimum output page row count for filter and project operators' as VARCHAR(118)))\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzMzA3OQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450233079", "bodyText": "restore this check using:\nif (!dynamicFilter.getCurrentPredicate().isAll())", "author": "sopel39", "createdAt": "2020-07-06T13:49:00Z", "path": "presto-main/src/main/java/io/prestosql/operator/TableScanOperator.java", "diffHunk": "@@ -292,9 +292,6 @@ public Page getOutput()\n             return null;\n         }\n         if (source == null) {\n-            if (!dynamicFilter.get().isAll()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzNTExOQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450235119", "bodyText": "I don't think we can remove this check yet as join above TS will still hold probe until lookup source is ready", "author": "sopel39", "createdAt": "2020-07-06T13:52:10Z", "path": "presto-main/src/main/java/io/prestosql/split/PageSourceManager.java", "diffHunk": "@@ -50,24 +48,20 @@ public void removeConnectorPageSourceProvider(CatalogName catalogName)\n     }\n \n     @Override\n-    public ConnectorPageSource createPageSource(Session session, Split split, TableHandle table, List<ColumnHandle> columns, Supplier<TupleDomain<ColumnHandle>> dynamicFilter)\n+    public ConnectorPageSource createPageSource(Session session, Split split, TableHandle table, List<ColumnHandle> columns, DynamicFilter dynamicFilter)\n     {\n         requireNonNull(columns, \"columns is null\");\n         checkArgument(split.getCatalogName().equals(table.getCatalogName()), \"mismatched split and table\");\n         CatalogName catalogName = split.getCatalogName();\n \n         ConnectorPageSourceProvider provider = getPageSourceProvider(catalogName);\n-        TupleDomain<ColumnHandle> constraint = dynamicFilter.get();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzNTk3NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450235975", "bodyText": "We don't need this toggle, please remove. Let's make blocking a connector decision.\nFor some connectors 1s will be way to small for potential benefits", "author": "sopel39", "createdAt": "2020-07-06T13:53:33Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -130,6 +131,7 @@\n     private boolean enableDynamicFiltering = true;\n     private int dynamicFilteringMaxPerDriverRowCount = 100;\n     private DataSize dynamicFilteringMaxPerDriverSize = DataSize.of(10, KILOBYTE);\n+    private Duration dynamicFilteringProbeSideBlockingTimeout = new Duration(1, SECONDS);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDIzOTMwMw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450239303", "bodyText": "io.prestosql.sql.planner.LocalDynamicFiltersCollector#getDynamicFilter should return DynamicFilter. If needed, we could have another method for testing there, but it would be preferred to test DynamicFilter directly", "author": "sopel39", "createdAt": "2020-07-06T13:58:14Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -1361,20 +1363,44 @@ private PhysicalOperation visitTableScan(TableScanNode node, Expression filterEx\n             return Optional.of(staticFilter);\n         }\n \n-        private Supplier<TupleDomain<ColumnHandle>> getDynamicFilter(\n+        private DynamicFilter getDynamicFilter(\n                 TableScanNode tableScanNode,\n                 Expression filterExpression,\n                 LocalExecutionPlanContext context)\n         {\n             DynamicFilters.ExtractResult extractDynamicFilterResult = extractDynamicFilters(filterExpression);\n             List<DynamicFilters.Descriptor> dynamicFilters = extractDynamicFilterResult.getDynamicConjuncts();\n             if (dynamicFilters.isEmpty()) {\n-                return TupleDomain::all;\n+                return DynamicFilter.EMPTY;\n             }\n+\n             log.debug(\"[TableScan] Dynamic filters: %s\", dynamicFilters);\n-            return () -> {\n-                TupleDomain<Symbol> predicate = context.getDynamicFiltersCollector().getDynamicFilter(tableScanNode.getAssignments().keySet());\n-                return predicate.transform(tableScanNode.getAssignments()::get);\n+            LocalDynamicFiltersCollector collector = context.getDynamicFiltersCollector();\n+            List<DynamicFilterId> filterIds = dynamicFilters.stream()\n+                    .map(DynamicFilters.Descriptor::getId)\n+                    .collect(Collectors.toList());\n+\n+            return new DynamicFilter()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI0ODk5NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r450248995", "bodyText": "This becomes very similar to DynamicFilterService from #4224.\nCan we untangle these classes a bit?\n\n\nLocalDynamicFiltersCollector should hold Map<DynamicFilterId, SettableFuture<Domain>> dynamicFilters\n\n\nThere should be method DynamicFilter LocalDynamicFiltersCollector#getDynamicFilter(List<DynamicFilters.Descriptor> dynamicFilters, Map<Symbol, ColumnHandle> columnHandles), similar as in DynamicFilterService\n\n\nLocalDynamicFiltersCollector#addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains) would become addDynamicFilter(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n\n\nThis would simplify LocalDynamicFilterConsumer as it wouldn't need to perform dynamic filter id -> symbol translation in io.prestosql.sql.planner.LocalDynamicFilterConsumer#convertTupleDomainForLocalFilters and some code could be reused between DynamicFilterService and LocalDynamicFiltersCollector", "author": "sopel39", "createdAt": "2020-07-06T14:12:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,28 +13,52 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.util.concurrent.SettableFuture;\n+import io.airlift.log.Logger;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n+import java.util.Collection;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import static com.google.common.base.Verify.verify;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static io.airlift.concurrent.MoreFutures.toCompletableFuture;\n+import static io.airlift.concurrent.MoreFutures.whenAnyComplete;\n+import static io.prestosql.spi.connector.DynamicFilter.NOT_BLOCKED;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n+    private static final Logger log = Logger.get(LocalDynamicFiltersCollector.class);\n+\n     /**\n      * May contains domains for dynamic filters for different table scans\n      * (e.g. in case of co-located joins).\n      */\n     @GuardedBy(\"this\")\n     private Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n \n+    // Each future blocks until its dynamic filter is collected.\n+    @GuardedBy(\"this\")\n+    private Map<DynamicFilterId, SettableFuture<Void>> futures = new HashMap<>();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzMwOTg0NA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r453309844", "bodyText": "I did a bit different refactoring - allowing a bit more efficient implementation of DynamicFilter, by caching the resulting predicate and the blocked future:\nhttps://github.com/prestosql/presto/pull/3414/files#diff-fc014adc6614290fe6f8a48d7b0f6739\nWDYT?", "author": "rzeyde-varada", "createdAt": "2020-07-12T12:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI0ODk5NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2Njg0NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473066845", "bodyText": "nit: I would extract this as a separate commit, but we can keep it as is", "author": "sopel39", "createdAt": "2020-08-19T14:20:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFilterConsumer.java", "diffHunk": "@@ -108,32 +83,6 @@ private synchronized void addPartition(TupleDomain<DynamicFilterId> tupleDomain)\n         }\n     }\n \n-    private Map<Symbol, Domain> convertTupleDomainForLocalFilters(TupleDomain<DynamicFilterId> result)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTExNTAxMg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475115012", "bodyText": "Kept as a part of this commit.", "author": "rzeyde-varada", "createdAt": "2020-08-22T17:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2Njg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2OTU1Mg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473069552", "bodyText": "make register accept Set<DynamicFilterId> instead of singular filter", "author": "sopel39", "createdAt": "2020-08-19T14:24:14Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3MDE4NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473070185", "bodyText": "I don't think it needs to be synchronized as local planning is single threaded", "author": "sopel39", "createdAt": "2020-08-19T14:25:04Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3MDMzMw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473070333", "bodyText": "make it final", "author": "sopel39", "createdAt": "2020-08-19T14:25:14Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3MjE1NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473072155", "bodyText": "This comment is inaccurate. It's used during execution", "author": "sopel39", "createdAt": "2020-08-19T14:27:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        verify(futures.put(filterId, SettableFuture.create()) == null, \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId);\n+    }\n+\n+    // Used during build-side planning", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3MjQ1MQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473072451", "bodyText": "remove synchronized as map doesn't change", "author": "sopel39", "createdAt": "2020-08-19T14:28:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        verify(futures.put(filterId, SettableFuture.create()) == null, \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId);\n+    }\n+\n+    // Used during build-side planning\n+    public synchronized void complete(Map<DynamicFilterId, Domain> dynamicFilterDomains)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3MzUwNg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473073506", "bodyText": "let's use dynamicFilterDomains.forEach instead", "author": "sopel39", "createdAt": "2020-08-19T14:29:25Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        verify(futures.put(filterId, SettableFuture.create()) == null, \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId);\n+    }\n+\n+    // Used during build-side planning\n+    public synchronized void complete(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        for (Map.Entry<DynamicFilterId, Domain> entry : dynamicFilterDomains.entrySet()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3Mzk5Nw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473073997", "bodyText": "synchronization is not needed, planning is single threaded", "author": "sopel39", "createdAt": "2020-08-19T14:30:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        verify(futures.put(filterId, SettableFuture.create()) == null, \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId);\n+    }\n+\n+    // Used during build-side planning\n+    public synchronized void complete(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        for (Map.Entry<DynamicFilterId, Domain> entry : dynamicFilterDomains.entrySet()) {\n+            SettableFuture<Domain> future = requireNonNull(futures.get(entry.getKey()), () -> format(\"Unknown dynamic filter %s\", entry.getKey()));\n+            verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+        }\n+    }\n+\n+    // Called during TableScan planning\n+    public synchronized DynamicFilter getDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3NjQ2NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473076465", "bodyText": "Call it createDynamicFilter to match DynamicFilterService#createDynamicFilter", "author": "sopel39", "createdAt": "2020-08-19T14:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3Mzk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3NTgyNQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473075825", "bodyText": "call it symbolsMapBuilder", "author": "sopel39", "createdAt": "2020-08-19T14:32:17Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        verify(futures.put(filterId, SettableFuture.create()) == null, \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId);\n+    }\n+\n+    // Used during build-side planning\n+    public synchronized void complete(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        for (Map.Entry<DynamicFilterId, Domain> entry : dynamicFilterDomains.entrySet()) {\n+            SettableFuture<Domain> future = requireNonNull(futures.get(entry.getKey()), () -> format(\"Unknown dynamic filter %s\", entry.getKey()));\n+            verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+        }\n+    }\n+\n+    // Called during TableScan planning\n+    public synchronized DynamicFilter getDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n+    {\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> builder = ImmutableMultimap.builder();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA4NDU3Nw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473084577", "bodyText": "remove () around domain", "author": "sopel39", "createdAt": "2020-08-19T14:43:45Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        verify(futures.put(filterId, SettableFuture.create()) == null, \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId);\n+    }\n+\n+    // Used during build-side planning\n+    public synchronized void complete(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        for (Map.Entry<DynamicFilterId, Domain> entry : dynamicFilterDomains.entrySet()) {\n+            SettableFuture<Domain> future = requireNonNull(futures.get(entry.getKey()), () -> format(\"Unknown dynamic filter %s\", entry.getKey()));\n+            verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+        }\n+    }\n+\n+    // Called during TableScan planning\n+    public synchronized DynamicFilter getDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n+    {\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> builder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            builder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = builder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = filterIds.stream()\n+                .map(filterId -> {\n+                    // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n+                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n+                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n+                            .collect(toImmutableList());\n+                    return Futures.transform(\n+                            futures.get(filterId),\n+                            // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n+                            (domain) -> TupleDomain.withColumnDomains(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MTUyOA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473091528", "bodyText": "remove this.", "author": "sopel39", "createdAt": "2020-08-19T14:53:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        verify(futures.put(filterId, SettableFuture.create()) == null, \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId);\n+    }\n+\n+    // Used during build-side planning\n+    public synchronized void complete(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        for (Map.Entry<DynamicFilterId, Domain> entry : dynamicFilterDomains.entrySet()) {\n+            SettableFuture<Domain> future = requireNonNull(futures.get(entry.getKey()), () -> format(\"Unknown dynamic filter %s\", entry.getKey()));\n+            verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+        }\n+    }\n+\n+    // Called during TableScan planning\n+    public synchronized DynamicFilter getDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n+    {\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> builder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            builder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = builder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = filterIds.stream()\n+                .map(filterId -> {\n+                    // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n+                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n+                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n+                            .collect(toImmutableList());\n+                    return Futures.transform(\n+                            futures.get(filterId),\n+                            // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n+                            (domain) -> TupleDomain.withColumnDomains(\n+                                    probeColumns.stream()\n+                                            .collect(toImmutableMap(\n+                                                    (column) -> column,\n+                                                    (column) -> domain))),\n+                            directExecutor());\n+                })\n+                .collect(toImmutableList());\n+        return new TableSpecificDynamicFilter(predicateFutures);\n+    }\n+\n+    // Table-specific dynamic filter (collects all domains for a specific table scan)\n+    private static class TableSpecificDynamicFilter\n+            implements DynamicFilter\n+    {\n+        @GuardedBy(\"this\")\n+        private CompletableFuture<?> isBlocked;\n+\n+        @GuardedBy(\"this\")\n+        private TupleDomain<ColumnHandle> currentPredicate;\n+\n+        @GuardedBy(\"this\")\n+        private int futuresLeft;\n+\n+        public TableSpecificDynamicFilter(List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures)\n+        {\n+            this.futuresLeft = predicateFutures.size();\n+            this.isBlocked = isComplete() ? NOT_BLOCKED : new CompletableFuture();\n+            this.currentPredicate = TupleDomain.all();\n+            predicateFutures.stream().forEach(future -> addSuccessCallback(future, this::update, directExecutor()));\n+        }\n+\n+        private synchronized void update(TupleDomain<ColumnHandle> predicate)\n+        {\n+            this.futuresLeft -= 1;\n+            verify(this.futuresLeft >= 0);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwMDYyMw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473100623", "bodyText": "this. is not needed", "author": "sopel39", "createdAt": "2020-08-19T15:05:25Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        verify(futures.put(filterId, SettableFuture.create()) == null, \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId);\n+    }\n+\n+    // Used during build-side planning\n+    public synchronized void complete(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        for (Map.Entry<DynamicFilterId, Domain> entry : dynamicFilterDomains.entrySet()) {\n+            SettableFuture<Domain> future = requireNonNull(futures.get(entry.getKey()), () -> format(\"Unknown dynamic filter %s\", entry.getKey()));\n+            verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+        }\n+    }\n+\n+    // Called during TableScan planning\n+    public synchronized DynamicFilter getDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n+    {\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> builder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            builder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = builder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = filterIds.stream()\n+                .map(filterId -> {\n+                    // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n+                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n+                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n+                            .collect(toImmutableList());\n+                    return Futures.transform(\n+                            futures.get(filterId),\n+                            // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n+                            (domain) -> TupleDomain.withColumnDomains(\n+                                    probeColumns.stream()\n+                                            .collect(toImmutableMap(\n+                                                    (column) -> column,\n+                                                    (column) -> domain))),\n+                            directExecutor());\n+                })\n+                .collect(toImmutableList());\n+        return new TableSpecificDynamicFilter(predicateFutures);\n+    }\n+\n+    // Table-specific dynamic filter (collects all domains for a specific table scan)\n+    private static class TableSpecificDynamicFilter\n+            implements DynamicFilter\n+    {\n+        @GuardedBy(\"this\")\n+        private CompletableFuture<?> isBlocked;\n+\n+        @GuardedBy(\"this\")\n+        private TupleDomain<ColumnHandle> currentPredicate;\n+\n+        @GuardedBy(\"this\")\n+        private int futuresLeft;\n+\n+        public TableSpecificDynamicFilter(List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures)\n+        {\n+            this.futuresLeft = predicateFutures.size();\n+            this.isBlocked = isComplete() ? NOT_BLOCKED : new CompletableFuture();\n+            this.currentPredicate = TupleDomain.all();\n+            predicateFutures.stream().forEach(future -> addSuccessCallback(future, this::update, directExecutor()));\n+        }\n+\n+        private synchronized void update(TupleDomain<ColumnHandle> predicate)\n+        {\n+            this.futuresLeft -= 1;\n+            verify(this.futuresLeft >= 0);\n+            verify(this.isBlocked.complete(null));\n+\n+            this.isBlocked = isComplete() ? NOT_BLOCKED : new CompletableFuture();\n+            this.currentPredicate = this.currentPredicate.intersect(predicate);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNTU0MA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r473105540", "bodyText": "this should be executed outside of synchronization section, see: io.prestosql.operator.exchange.LocalExchangeSource#addPage\n        ...\n        // notify readers outside of lock since this may result in a callback\n        notEmptyFuture.set(null);\n\nit's a good practice to do callbacks outside of synchronization section", "author": "sopel39", "createdAt": "2020-08-19T15:12:19Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,142 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n+    // Each future blocks until its dynamic filter is collected.\n     @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n+    private Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n \n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    public LocalDynamicFiltersCollector()\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Called during JoinNode planning\n+    public synchronized void register(DynamicFilterId filterId)\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        verify(futures.put(filterId, SettableFuture.create()) == null, \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId);\n+    }\n+\n+    // Used during build-side planning\n+    public synchronized void complete(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        for (Map.Entry<DynamicFilterId, Domain> entry : dynamicFilterDomains.entrySet()) {\n+            SettableFuture<Domain> future = requireNonNull(futures.get(entry.getKey()), () -> format(\"Unknown dynamic filter %s\", entry.getKey()));\n+            verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+        }\n+    }\n+\n+    // Called during TableScan planning\n+    public synchronized DynamicFilter getDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n+    {\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> builder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            builder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = builder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = filterIds.stream()\n+                .map(filterId -> {\n+                    // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n+                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n+                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n+                            .collect(toImmutableList());\n+                    return Futures.transform(\n+                            futures.get(filterId),\n+                            // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n+                            (domain) -> TupleDomain.withColumnDomains(\n+                                    probeColumns.stream()\n+                                            .collect(toImmutableMap(\n+                                                    (column) -> column,\n+                                                    (column) -> domain))),\n+                            directExecutor());\n+                })\n+                .collect(toImmutableList());\n+        return new TableSpecificDynamicFilter(predicateFutures);\n+    }\n+\n+    // Table-specific dynamic filter (collects all domains for a specific table scan)\n+    private static class TableSpecificDynamicFilter\n+            implements DynamicFilter\n+    {\n+        @GuardedBy(\"this\")\n+        private CompletableFuture<?> isBlocked;\n+\n+        @GuardedBy(\"this\")\n+        private TupleDomain<ColumnHandle> currentPredicate;\n+\n+        @GuardedBy(\"this\")\n+        private int futuresLeft;\n+\n+        public TableSpecificDynamicFilter(List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures)\n+        {\n+            this.futuresLeft = predicateFutures.size();\n+            this.isBlocked = isComplete() ? NOT_BLOCKED : new CompletableFuture();\n+            this.currentPredicate = TupleDomain.all();\n+            predicateFutures.stream().forEach(future -> addSuccessCallback(future, this::update, directExecutor()));\n+        }\n+\n+        private synchronized void update(TupleDomain<ColumnHandle> predicate)\n+        {\n+            this.futuresLeft -= 1;\n+            verify(this.futuresLeft >= 0);\n+            verify(this.isBlocked.complete(null));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyNzM4Mg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474027382", "bodyText": "nit: consider renaming complete to collectDynamicTupleDomain for consistency", "author": "sopel39", "createdAt": "2020-08-20T14:29:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -612,6 +612,7 @@ public LocalDynamicFiltersCollector getDynamicFiltersCollector()\n         private void addDynamicFilter(Map<DynamicFilterId, Domain> dynamicTupleDomain)\n         {\n             taskContext.collectDynamicTupleDomain(dynamicTupleDomain);\n+            dynamicFiltersCollector.complete(dynamicTupleDomain);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAzNzE4OQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474037189", "bodyText": "you can use org.testng.Assert#assertFalse(boolean) instead", "author": "sopel39", "createdAt": "2020-08-20T14:43:02Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -16,102 +16,194 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.connector.TestingColumnHandle;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n import org.testng.annotations.Test;\n \n-import java.util.Map;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n import static io.prestosql.spi.type.BigintType.BIGINT;\n import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class TestLocalDynamicFiltersCollector\n {\n     @Test\n-    public void testCollector()\n+    public void testSingle()\n     {\n-        Symbol symbol = new Symbol(\"symbol\");\n-        Set<Symbol> probeSymbols = ImmutableSet.of(symbol);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(ImmutableMap.of());\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 1L, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MDU0MA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474040540", "bodyText": "this check is redundant", "author": "sopel39", "createdAt": "2020-08-20T14:47:40Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -16,102 +16,194 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.connector.TestingColumnHandle;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n import org.testng.annotations.Test;\n \n-import java.util.Map;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n import static io.prestosql.spi.type.BigintType.BIGINT;\n import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class TestLocalDynamicFiltersCollector\n {\n     @Test\n-    public void testCollector()\n+    public void testSingle()\n     {\n-        Symbol symbol = new Symbol(\"symbol\");\n-        Set<Symbol> probeSymbols = ImmutableSet.of(symbol);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(ImmutableMap.of());\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 1L, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScans()\n+    public void testMultipleProbeColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), tupleDomain(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(\n-                ImmutableSet.of(symbol1, symbol2)),\n-                TupleDomain.withColumnDomains(ImmutableMap.of(\n-                        symbol1, Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L)),\n-                        symbol2, Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L)))));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        // Same build-side column being matched to multiple probe-side columns.\n+        Symbol s1 = new Symbol(\"s1\");\n+        Symbol s2 = new Symbol(\"s2\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        ColumnHandle c2 = new TestingColumnHandle(\"c2\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f1, s2.toSymbolReference())),\n+                ImmutableMap.of(s1, c1, s2, c2));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain, c2, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScansNone()\n+    public void testMultipleBuildColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-\n-        collector.addDynamicFilter(ImmutableMap.of(symbol1, Domain.none(BIGINT)));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        DynamicFilterId f2 = new DynamicFilterId(\"f2\");\n+        collector.register(f1);\n+        collector.register(f2);\n+\n+        // Multiple build-side columns matching the same probe-side column.\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f2, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocking and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain d1 = Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L));\n+        collector.complete(ImmutableMap.of(f1, d1));\n+\n+        // Unblocked, but not completed.\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));\n+\n+        // Create a new blocking future, waiting for next completion.\n+        isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MDYyNA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474040624", "bodyText": "make sure new future is blocked", "author": "sopel39", "createdAt": "2020-08-20T14:47:46Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -16,102 +16,194 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.connector.TestingColumnHandle;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n import org.testng.annotations.Test;\n \n-import java.util.Map;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n import static io.prestosql.spi.type.BigintType.BIGINT;\n import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class TestLocalDynamicFiltersCollector\n {\n     @Test\n-    public void testCollector()\n+    public void testSingle()\n     {\n-        Symbol symbol = new Symbol(\"symbol\");\n-        Set<Symbol> probeSymbols = ImmutableSet.of(symbol);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(ImmutableMap.of());\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 1L, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScans()\n+    public void testMultipleProbeColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), tupleDomain(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(\n-                ImmutableSet.of(symbol1, symbol2)),\n-                TupleDomain.withColumnDomains(ImmutableMap.of(\n-                        symbol1, Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L)),\n-                        symbol2, Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L)))));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        // Same build-side column being matched to multiple probe-side columns.\n+        Symbol s1 = new Symbol(\"s1\");\n+        Symbol s2 = new Symbol(\"s2\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        ColumnHandle c2 = new TestingColumnHandle(\"c2\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f1, s2.toSymbolReference())),\n+                ImmutableMap.of(s1, c1, s2, c2));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain, c2, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScansNone()\n+    public void testMultipleBuildColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-\n-        collector.addDynamicFilter(ImmutableMap.of(symbol1, Domain.none(BIGINT)));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        DynamicFilterId f2 = new DynamicFilterId(\"f2\");\n+        collector.register(f1);\n+        collector.register(f2);\n+\n+        // Multiple build-side columns matching the same probe-side column.\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f2, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocking and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain d1 = Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L));\n+        collector.complete(ImmutableMap.of(f1, d1));\n+\n+        // Unblocked, but not completed.\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));\n+\n+        // Create a new blocking future, waiting for next completion.\n+        isBlocked = filter.isBlocked();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MTkxOA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474041918", "bodyText": "Use io.prestosql.spi.predicate.Domain#singleValue instead", "author": "sopel39", "createdAt": "2020-08-20T14:49:37Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -16,102 +16,194 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.connector.TestingColumnHandle;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n import org.testng.annotations.Test;\n \n-import java.util.Map;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n import static io.prestosql.spi.type.BigintType.BIGINT;\n import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class TestLocalDynamicFiltersCollector\n {\n     @Test\n-    public void testCollector()\n+    public void testSingle()\n     {\n-        Symbol symbol = new Symbol(\"symbol\");\n-        Set<Symbol> probeSymbols = ImmutableSet.of(symbol);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(ImmutableMap.of());\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 1L, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScans()\n+    public void testMultipleProbeColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), tupleDomain(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(\n-                ImmutableSet.of(symbol1, symbol2)),\n-                TupleDomain.withColumnDomains(ImmutableMap.of(\n-                        symbol1, Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L)),\n-                        symbol2, Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L)))));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        // Same build-side column being matched to multiple probe-side columns.\n+        Symbol s1 = new Symbol(\"s1\");\n+        Symbol s2 = new Symbol(\"s2\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        ColumnHandle c2 = new TestingColumnHandle(\"c2\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f1, s2.toSymbolReference())),\n+                ImmutableMap.of(s1, c1, s2, c2));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain, c2, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScansNone()\n+    public void testMultipleBuildColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-\n-        collector.addDynamicFilter(ImmutableMap.of(symbol1, Domain.none(BIGINT)));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        DynamicFilterId f2 = new DynamicFilterId(\"f2\");\n+        collector.register(f1);\n+        collector.register(f2);\n+\n+        // Multiple build-side columns matching the same probe-side column.\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f2, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocking and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain d1 = Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L));\n+        collector.complete(ImmutableMap.of(f1, d1));\n+\n+        // Unblocked, but not completed.\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));\n+\n+        // Create a new blocking future, waiting for next completion.\n+        isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));\n+\n+        Domain d2 = Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L, 4L));\n+        collector.complete(ImmutableMap.of(f2, d2));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1.intersect(d2))));\n     }\n \n-    private TupleDomain<Symbol> tupleDomain(Symbol symbol, Long... values)\n+    @Test\n+    public void testUnusedDynamicFilter()\n     {\n-        return TupleDomain.withColumnDomains(ImmutableMap.of(symbol, Domain.multipleValues(BIGINT, ImmutableList.copyOf(values))));\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        DynamicFilterId f2 = new DynamicFilterId(\"f2\");\n+        collector.register(f1);\n+        collector.register(f2);\n+\n+        // One of the dynamic filters is not used for the the table scan.\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocking and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain d2 = Domain.multipleValues(BIGINT, ImmutableList.of(2L));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MjgwMA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474042800", "bodyText": "rename f1 to filter1, similarly for s1 (symbol1) and c1 (column1). Here and in other tests", "author": "sopel39", "createdAt": "2020-08-20T14:50:50Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -16,102 +16,194 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.connector.TestingColumnHandle;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n import org.testng.annotations.Test;\n \n-import java.util.Map;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n import static io.prestosql.spi.type.BigintType.BIGINT;\n import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class TestLocalDynamicFiltersCollector\n {\n     @Test\n-    public void testCollector()\n+    public void testSingle()\n     {\n-        Symbol symbol = new Symbol(\"symbol\");\n-        Set<Symbol> probeSymbols = ImmutableSet.of(symbol);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(ImmutableMap.of());\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 1L, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MzM3NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474043375", "bodyText": "to make it clearer you could call them usedFilter and unusedFilter", "author": "sopel39", "createdAt": "2020-08-20T14:51:28Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -16,102 +16,194 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.connector.TestingColumnHandle;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n import org.testng.annotations.Test;\n \n-import java.util.Map;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n import static io.prestosql.spi.type.BigintType.BIGINT;\n import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class TestLocalDynamicFiltersCollector\n {\n     @Test\n-    public void testCollector()\n+    public void testSingle()\n     {\n-        Symbol symbol = new Symbol(\"symbol\");\n-        Set<Symbol> probeSymbols = ImmutableSet.of(symbol);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(ImmutableMap.of());\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 1L, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScans()\n+    public void testMultipleProbeColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), tupleDomain(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(\n-                ImmutableSet.of(symbol1, symbol2)),\n-                TupleDomain.withColumnDomains(ImmutableMap.of(\n-                        symbol1, Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L)),\n-                        symbol2, Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L)))));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        // Same build-side column being matched to multiple probe-side columns.\n+        Symbol s1 = new Symbol(\"s1\");\n+        Symbol s2 = new Symbol(\"s2\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        ColumnHandle c2 = new TestingColumnHandle(\"c2\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f1, s2.toSymbolReference())),\n+                ImmutableMap.of(s1, c1, s2, c2));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain, c2, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScansNone()\n+    public void testMultipleBuildColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-\n-        collector.addDynamicFilter(ImmutableMap.of(symbol1, Domain.none(BIGINT)));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        DynamicFilterId f2 = new DynamicFilterId(\"f2\");\n+        collector.register(f1);\n+        collector.register(f2);\n+\n+        // Multiple build-side columns matching the same probe-side column.\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f2, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocking and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain d1 = Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L));\n+        collector.complete(ImmutableMap.of(f1, d1));\n+\n+        // Unblocked, but not completed.\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));\n+\n+        // Create a new blocking future, waiting for next completion.\n+        isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));\n+\n+        Domain d2 = Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L, 4L));\n+        collector.complete(ImmutableMap.of(f2, d2));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1.intersect(d2))));\n     }\n \n-    private TupleDomain<Symbol> tupleDomain(Symbol symbol, Long... values)\n+    @Test\n+    public void testUnusedDynamicFilter()\n     {\n-        return TupleDomain.withColumnDomains(ImmutableMap.of(symbol, Domain.multipleValues(BIGINT, ImmutableList.copyOf(values))));\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0NDA0OA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474044048", "bodyText": "you can just inline Domain.multipleValues(...) calls. No need for extra local variable", "author": "sopel39", "createdAt": "2020-08-20T14:52:27Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -16,102 +16,194 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.connector.TestingColumnHandle;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n import org.testng.annotations.Test;\n \n-import java.util.Map;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n import static io.prestosql.spi.type.BigintType.BIGINT;\n import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class TestLocalDynamicFiltersCollector\n {\n     @Test\n-    public void testCollector()\n+    public void testSingle()\n     {\n-        Symbol symbol = new Symbol(\"symbol\");\n-        Set<Symbol> probeSymbols = ImmutableSet.of(symbol);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(ImmutableMap.of());\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 1L, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScans()\n+    public void testMultipleProbeColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), tupleDomain(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(\n-                ImmutableSet.of(symbol1, symbol2)),\n-                TupleDomain.withColumnDomains(ImmutableMap.of(\n-                        symbol1, Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L)),\n-                        symbol2, Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L)))));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        // Same build-side column being matched to multiple probe-side columns.\n+        Symbol s1 = new Symbol(\"s1\");\n+        Symbol s2 = new Symbol(\"s2\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        ColumnHandle c2 = new TestingColumnHandle(\"c2\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f1, s2.toSymbolReference())),\n+                ImmutableMap.of(s1, c1, s2, c2));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain, c2, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScansNone()\n+    public void testMultipleBuildColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-\n-        collector.addDynamicFilter(ImmutableMap.of(symbol1, Domain.none(BIGINT)));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        DynamicFilterId f2 = new DynamicFilterId(\"f2\");\n+        collector.register(f1);\n+        collector.register(f2);\n+\n+        // Multiple build-side columns matching the same probe-side column.\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f2, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocking and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain d1 = Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0NjMxNQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474046315", "bodyText": "add a TODO: don't register dynamic filters that are not collected locally\nCurrently, DFs are relatively small, but they might become larger, so we might not want to keep them if they are not needed.", "author": "sopel39", "createdAt": "2020-08-20T14:55:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2001,6 +2000,11 @@ private PhysicalOperation createLookupJoin(\n                 Optional<Symbol> buildHashSymbol,\n                 LocalExecutionPlanContext context)\n         {\n+            // Register dynamic filters, allowing the scan operators to wait for the collection completion.\n+            // It is possible that not all dynamic filters are used locally (e.g. in case of distributed joins).", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyNzQ3Mw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474527473", "bodyText": "In fact, it would be great if we could only collect local DFs which are needed (as we did previously)", "author": "sopel39", "createdAt": "2020-08-21T08:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0NjMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTExNTQ5NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475115495", "bodyText": "I think that I still need to collect all DFs (for partition pruning at the coordinator), so I fixed the registration of non-local DFs at https://github.com/prestosql/presto/pull/3414/files#diff-00858ac0881ccbdcd8368d6dbae7e14eR2002-R2008.", "author": "rzeyde-varada", "createdAt": "2020-08-22T18:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0NjMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1MTE3Mw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474051173", "bodyText": "call it registeredFilter and unregisteredFilter", "author": "sopel39", "createdAt": "2020-08-20T15:01:40Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -16,102 +16,194 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.ImmutableSet;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n+import io.prestosql.spi.connector.TestingColumnHandle;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n import org.testng.annotations.Test;\n \n-import java.util.Map;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n import static io.prestosql.spi.type.BigintType.BIGINT;\n import static io.prestosql.testing.assertions.Assert.assertEquals;\n+import static org.assertj.core.api.Assertions.assertThat;\n \n public class TestLocalDynamicFiltersCollector\n {\n     @Test\n-    public void testCollector()\n+    public void testSingle()\n     {\n-        Symbol symbol = new Symbol(\"symbol\");\n-        Set<Symbol> probeSymbols = ImmutableSet.of(symbol);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(ImmutableMap.of());\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 1L, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), tupleDomain(symbol, 2L));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScans()\n+    public void testMultipleProbeColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), tupleDomain(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(\n-                ImmutableSet.of(symbol1, symbol2)),\n-                TupleDomain.withColumnDomains(ImmutableMap.of(\n-                        symbol1, Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L)),\n-                        symbol2, Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L)))));\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 0L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        collector.register(f1);\n+\n+        // Same build-side column being matched to multiple probe-side columns.\n+        Symbol s1 = new Symbol(\"s1\");\n+        Symbol s2 = new Symbol(\"s2\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        ColumnHandle c2 = new TestingColumnHandle(\"c2\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f1, s2.toSymbolReference())),\n+                ImmutableMap.of(s1, c1, s2, c2));\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.complete(ImmutableMap.of(f1, domain));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, domain, c2, domain)));\n     }\n \n     @Test\n-    public void testCollectorMultipleScansNone()\n+    public void testMultipleBuildColumns()\n     {\n-        Symbol symbol1 = new Symbol(\"symbol1\");\n-        Symbol symbol2 = new Symbol(\"symbol2\");\n-        Set<Symbol> probeSymbols1 = ImmutableSet.of(symbol1);\n-        Set<Symbol> probeSymbols2 = ImmutableSet.of(symbol2);\n-\n         LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.all());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), TupleDomain.all());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        collector.addDynamicFilter(toDomainMap(symbol2, 2L, 3L));\n-\n-        collector.addDynamicFilter(ImmutableMap.of(symbol1, Domain.none(BIGINT)));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n-\n-        collector.addDynamicFilter(toDomainMap(symbol1, 1L, 2L));\n-        assertEquals(collector.getDynamicFilter(probeSymbols1), TupleDomain.none());\n-        assertEquals(collector.getDynamicFilter(probeSymbols2), tupleDomain(symbol2, 2L, 3L));\n-        assertEquals(collector.getDynamicFilter(ImmutableSet.of(symbol1, symbol2)), TupleDomain.none());\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        DynamicFilterId f2 = new DynamicFilterId(\"f2\");\n+        collector.register(f1);\n+        collector.register(f2);\n+\n+        // Multiple build-side columns matching the same probe-side column.\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference()), new DynamicFilters.Descriptor(f2, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocking and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain d1 = Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L));\n+        collector.complete(ImmutableMap.of(f1, d1));\n+\n+        // Unblocked, but not completed.\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));\n+\n+        // Create a new blocking future, waiting for next completion.\n+        isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));\n+\n+        Domain d2 = Domain.multipleValues(BIGINT, ImmutableList.of(2L, 3L, 4L));\n+        collector.complete(ImmutableMap.of(f2, d2));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1.intersect(d2))));\n     }\n \n-    private TupleDomain<Symbol> tupleDomain(Symbol symbol, Long... values)\n+    @Test\n+    public void testUnusedDynamicFilter()\n     {\n-        return TupleDomain.withColumnDomains(ImmutableMap.of(symbol, Domain.multipleValues(BIGINT, ImmutableList.copyOf(values))));\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");\n+        DynamicFilterId f2 = new DynamicFilterId(\"f2\");\n+        collector.register(f1);\n+        collector.register(f2);\n+\n+        // One of the dynamic filters is not used for the the table scan.\n+        Symbol s1 = new Symbol(\"s1\");\n+        ColumnHandle c1 = new TestingColumnHandle(\"c1\");\n+        DynamicFilter filter = collector.getDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(f1, s1.toSymbolReference())),\n+                ImmutableMap.of(s1, c1));\n+\n+        // Filter is blocking and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain d2 = Domain.multipleValues(BIGINT, ImmutableList.of(2L));\n+        collector.complete(ImmutableMap.of(f2, d2));\n+\n+        // This dynamic filter is unused here - has no effect on blocking/completion of the above future.\n+        assertThat(filter.isComplete()).isFalse();\n+        assertThat(isBlocked.isDone()).isFalse();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain d1 = Domain.multipleValues(BIGINT, ImmutableList.of(2L));\n+        collector.complete(ImmutableMap.of(f1, d1));\n+\n+        // Unblocked and completed.\n+        assertThat(filter.isComplete()).isTrue();\n+        assertThat(isBlocked.isDone()).isTrue();\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(c1, d1)));\n     }\n \n-    private Map<Symbol, Domain> toDomainMap(Symbol symbol, Long... values)\n+    @Test\n+    public void testUnregisteredDynamicFilter()\n     {\n-        return ImmutableMap.of(symbol, Domain.multipleValues(BIGINT, ImmutableList.copyOf(values)));\n+        // One dynamic filter is not collected locally (e.g. due to a distributed join)\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector();\n+        DynamicFilterId f1 = new DynamicFilterId(\"f1\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1OTc0MQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474059741", "bodyText": "we avoid ? :  conditions, use normal if instead:\nif (enableLazyDynamicFiltering) {\n  return dynamicFilter.isBlocked()\n}\n\nreturn NOT_BLOCKED", "author": "sopel39", "createdAt": "2020-08-20T15:12:55Z", "path": "presto-memory/src/main/java/io/prestosql/plugin/memory/MemoryPageSourceProvider.java", "diffHunk": "@@ -83,34 +78,104 @@ public ConnectorPageSource createPageSource(\n                 expectedRows,\n                 memorySplit.getLimit(),\n                 sampleRatio);\n-        return new FixedPageSource(pages.stream()\n-                .map(page -> applyFilter(page, domains))\n-                .collect(toList()));\n+\n+        return new DynamicFilteringPageSource(new FixedPageSource(pages), columns, dynamicFilter, enableLazyDynamicFiltering);\n     }\n \n-    private Page applyFilter(Page page, Map<Integer, Domain> domains)\n+    private static class DynamicFilteringPageSource\n+            implements ConnectorPageSource\n     {\n-        int[] positions = new int[page.getPositionCount()];\n-        int length = 0;\n-        for (int position = 0; position < page.getPositionCount(); ++position) {\n-            if (positionMatchesPredicate(page, position, domains)) {\n-                positions[length++] = position;\n+        private final FixedPageSource delegate;\n+        private final List<ColumnHandle> columns;\n+        private final DynamicFilter dynamicFilter;\n+        private final boolean enableLazyDynamicFiltering;\n+\n+        private DynamicFilteringPageSource(FixedPageSource delegate, List<ColumnHandle> columns, DynamicFilter dynamicFilter, boolean enableLazyDynamicFiltering)\n+        {\n+            this.delegate = delegate;\n+            this.columns = columns;\n+            this.dynamicFilter = dynamicFilter;\n+            this.enableLazyDynamicFiltering = enableLazyDynamicFiltering;\n+        }\n+\n+        @Override\n+        public long getCompletedBytes()\n+        {\n+            return delegate.getCompletedBytes();\n+        }\n+\n+        @Override\n+        public long getReadTimeNanos()\n+        {\n+            return delegate.getReadTimeNanos();\n+        }\n+\n+        @Override\n+        public boolean isFinished()\n+        {\n+            return delegate.isFinished();\n+        }\n+\n+        @Override\n+        public Page getNextPage()\n+        {\n+            if (enableLazyDynamicFiltering && !dynamicFilter.isComplete()) {\n+                return null;\n+            }\n+            TupleDomain<ColumnHandle> predicate = dynamicFilter.getCurrentPredicate();\n+            if (predicate.isNone()) {\n+                close();\n+                return null;\n             }\n+            Page page = delegate.getNextPage();\n+            if (page != null) {\n+                page = applyFilter(page, predicate.transform(columns::indexOf).getDomains().get());\n+            }\n+            return page;\n         }\n-        return page.getPositions(positions, 0, length);\n-    }\n \n-    private boolean positionMatchesPredicate(Page page, int position, Map<Integer, Domain> domains)\n-    {\n-        for (Map.Entry<Integer, Domain> entry : domains.entrySet()) {\n-            int channel = entry.getKey();\n-            Domain domain = entry.getValue();\n-            Object value = TypeUtils.readNativeValue(domain.getType(), page.getBlock(channel), position);\n-            if (!domain.includesNullableValue(value)) {\n-                return false;\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return enableLazyDynamicFiltering ? dynamicFilter.isBlocked() : NOT_BLOCKED;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MDc2NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474060765", "bodyText": "move these to top-level class MemoryPageSourceProvider. This way there should be less changes overall", "author": "sopel39", "createdAt": "2020-08-20T15:14:20Z", "path": "presto-memory/src/main/java/io/prestosql/plugin/memory/MemoryPageSourceProvider.java", "diffHunk": "@@ -83,34 +78,104 @@ public ConnectorPageSource createPageSource(\n                 expectedRows,\n                 memorySplit.getLimit(),\n                 sampleRatio);\n-        return new FixedPageSource(pages.stream()\n-                .map(page -> applyFilter(page, domains))\n-                .collect(toList()));\n+\n+        return new DynamicFilteringPageSource(new FixedPageSource(pages), columns, dynamicFilter, enableLazyDynamicFiltering);\n     }\n \n-    private Page applyFilter(Page page, Map<Integer, Domain> domains)\n+    private static class DynamicFilteringPageSource\n+            implements ConnectorPageSource\n     {\n-        int[] positions = new int[page.getPositionCount()];\n-        int length = 0;\n-        for (int position = 0; position < page.getPositionCount(); ++position) {\n-            if (positionMatchesPredicate(page, position, domains)) {\n-                positions[length++] = position;\n+        private final FixedPageSource delegate;\n+        private final List<ColumnHandle> columns;\n+        private final DynamicFilter dynamicFilter;\n+        private final boolean enableLazyDynamicFiltering;\n+\n+        private DynamicFilteringPageSource(FixedPageSource delegate, List<ColumnHandle> columns, DynamicFilter dynamicFilter, boolean enableLazyDynamicFiltering)\n+        {\n+            this.delegate = delegate;\n+            this.columns = columns;\n+            this.dynamicFilter = dynamicFilter;\n+            this.enableLazyDynamicFiltering = enableLazyDynamicFiltering;\n+        }\n+\n+        @Override\n+        public long getCompletedBytes()\n+        {\n+            return delegate.getCompletedBytes();\n+        }\n+\n+        @Override\n+        public long getReadTimeNanos()\n+        {\n+            return delegate.getReadTimeNanos();\n+        }\n+\n+        @Override\n+        public boolean isFinished()\n+        {\n+            return delegate.isFinished();\n+        }\n+\n+        @Override\n+        public Page getNextPage()\n+        {\n+            if (enableLazyDynamicFiltering && !dynamicFilter.isComplete()) {\n+                return null;\n+            }\n+            TupleDomain<ColumnHandle> predicate = dynamicFilter.getCurrentPredicate();\n+            if (predicate.isNone()) {\n+                close();\n+                return null;\n             }\n+            Page page = delegate.getNextPage();\n+            if (page != null) {\n+                page = applyFilter(page, predicate.transform(columns::indexOf).getDomains().get());\n+            }\n+            return page;\n         }\n-        return page.getPositions(positions, 0, length);\n-    }\n \n-    private boolean positionMatchesPredicate(Page page, int position, Map<Integer, Domain> domains)\n-    {\n-        for (Map.Entry<Integer, Domain> entry : domains.entrySet()) {\n-            int channel = entry.getKey();\n-            Domain domain = entry.getValue();\n-            Object value = TypeUtils.readNativeValue(domain.getType(), page.getBlock(channel), position);\n-            if (!domain.includesNullableValue(value)) {\n-                return false;\n+        @Override\n+        public CompletableFuture<?> isBlocked()\n+        {\n+            return enableLazyDynamicFiltering ? dynamicFilter.isBlocked() : NOT_BLOCKED;\n+        }\n+\n+        @Override\n+        public long getSystemMemoryUsage()\n+        {\n+            return delegate.getSystemMemoryUsage();\n+        }\n+\n+        @Override\n+        public void close()\n+        {\n+            delegate.close();\n+        }\n+\n+        private static Page applyFilter(Page page, Map<Integer, Domain> domains)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjE2MQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474062161", "bodyText": "nit: this could be separate commit", "author": "sopel39", "createdAt": "2020-08-20T15:16:25Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -129,13 +120,45 @@ public void testJoinDynamicFilteringSingleValue()\n         assertEquals(result.getResult().getRowCount(), 6);\n \n         // Probe-side is dynamically filtered:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId(), \"ScanFilterAndProjectOperator\");\n+        assertEquals(rowsRead, ImmutableSet.of(6L, countRows(\"orders\")));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n+                .build();\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                session,\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\");\n+        assertEquals(result.getResult().getRowCount(), 1);\n+\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId(), \"ScanFilterAndProjectOperator\");\n+        assertEquals(rowsRead, ImmutableSet.of(1L, countRows(\"orders\"), countRows(\"part\")));\n+    }\n+\n+    private Long countRows(String tableName)\n+    {\n+        return (Long) getQueryRunner().execute(\"SELECT count() FROM \" + tableName).getOnlyValue();\n+    }\n+\n+    private static Set<Long> getOperatorRowsRead(DistributedQueryRunner runner, QueryId queryId, String operatorType)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTExNTU3MQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475115571", "bodyText": "Extracted memory-related changes into ba93c07", "author": "rzeyde-varada", "createdAt": "2020-08-22T18:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjQ5OA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474062498", "bodyText": "no need for operatorType argument. It's always ScanFilterAndProjectOperator", "author": "sopel39", "createdAt": "2020-08-20T15:16:54Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -129,13 +120,45 @@ public void testJoinDynamicFilteringSingleValue()\n         assertEquals(result.getResult().getRowCount(), 6);\n \n         // Probe-side is dynamically filtered:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId(), \"ScanFilterAndProjectOperator\");\n+        assertEquals(rowsRead, ImmutableSet.of(6L, countRows(\"orders\")));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n+                .build();\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                session,\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\");\n+        assertEquals(result.getResult().getRowCount(), 1);\n+\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId(), \"ScanFilterAndProjectOperator\");\n+        assertEquals(rowsRead, ImmutableSet.of(1L, countRows(\"orders\"), countRows(\"part\")));\n+    }\n+\n+    private Long countRows(String tableName)\n+    {\n+        return (Long) getQueryRunner().execute(\"SELECT count() FROM \" + tableName).getOnlyValue();\n+    }\n+\n+    private static Set<Long> getOperatorRowsRead(DistributedQueryRunner runner, QueryId queryId, String operatorType)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjkzMg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474062932", "bodyText": "please also make sure that without lazy filtering all rows (15_000L) are read", "author": "sopel39", "createdAt": "2020-08-20T15:17:33Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -86,8 +87,6 @@ public void testSelect()\n     @Test\n     public void testJoinDynamicFilteringNone()\n     {\n-        final long buildSideRowsCount = 15_000L;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTExMzk1NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475113955", "bodyText": "I am afraid that even without lazy filtering, sometimes the build side may finish its execution before the probe side starts (due to non-deterministic scheduling), so I am not sure how to write a non-flaky test for that scenario (i.e. disabled lazy DF results in probe side full scan).", "author": "rzeyde-varada", "createdAt": "2020-08-22T17:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYzNjkzOQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475636939", "bodyText": "I am afraid that even without lazy filtering, sometimes the build side may finish its execution before the probe side starts\n\nOk. I see. Let's skip it then.", "author": "sopel39", "createdAt": "2020-08-24T14:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2Njk5NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474066995", "bodyText": "could you assert that each of joins itself with part and orders doesn't narrow lineitem to single row. This way we can assert that probe waits for DF from both tables", "author": "sopel39", "createdAt": "2020-08-20T15:23:28Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -129,13 +120,45 @@ public void testJoinDynamicFilteringSingleValue()\n         assertEquals(result.getResult().getRowCount(), 6);\n \n         // Probe-side is dynamically filtered:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId(), \"ScanFilterAndProjectOperator\");\n+        assertEquals(rowsRead, ImmutableSet.of(6L, countRows(\"orders\")));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n+                .build();\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                session,\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2NzY2NA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r474067664", "bodyText": "Put counts as static finals\nprivate static final ORDERS_COUNT = ...\nprivate static final PART_COUNT = ...\n\nthis way we don't run extra queries in tests", "author": "sopel39", "createdAt": "2020-08-20T15:24:29Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -100,21 +99,13 @@ public void testJoinDynamicFilteringNone()\n         assertEquals(result.getResult().getRowCount(), 0);\n \n         // Probe-side is not scanned at all, due to dynamic filtering:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n-                .stream()\n-                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n-                .map(OperatorStats::getInputPositions)\n-                .collect(toImmutableSet());\n-        assertEquals(rowsRead, ImmutableSet.of(0L, buildSideRowsCount));\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId(), \"ScanFilterAndProjectOperator\");\n+        assertEquals(rowsRead, ImmutableSet.of(0L, countRows(\"orders\")));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "url": "https://github.com/trinodb/trino/commit/ba93c071fde690b2ae6bdf79ec9988770b59c894", "message": "Support lazy dynamic filtering at memory connector", "committedDate": "2020-08-22T17:37:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4NzYwOA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475587608", "bodyText": "you can use com.google.common.collect.ImmutableSetMultimap#toImmutableSetMultimap:\ndescriptors.stream()\n  .collect(toImmutableSetMultimap(Descriptor::getId(), descriptor -> Symbol.from(descriptor.getInput()));", "author": "sopel39", "createdAt": "2020-08-24T13:09:31Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> symbolsMapBuilder = ImmutableMultimap.builder();", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4OTY1Mg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475589652", "bodyText": "You can now change it too:\nsymbolsMap.keySet().stream()\n  .map(filterId -> ...", "author": "sopel39", "createdAt": "2020-08-24T13:13:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> symbolsMapBuilder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            symbolsMapBuilder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = symbolsMapBuilder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0Mzg1NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475843855", "bodyText": "I am not sure that I understand... is it correct to replace:\nSet<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\nwith:\nSet<DynamicFilterId> filterIds = symbolsMap.keySet();\nFor example, in case of a partitioned join, symbolsMap.keySet() may contain dynamic filters collected in another stage - causing the following line to fail:\nrequireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId))", "author": "rzeyde-varada", "createdAt": "2020-08-24T19:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4OTY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI5OTA3MA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r476299070", "bodyText": "You are right. We cannot simplify it.", "author": "sopel39", "createdAt": "2020-08-25T09:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4OTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5MTM5NA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475591394", "bodyText": "ah. This name doesn't make sense (it's not TupleDomain). Just rename it to collectDynamicFilterDomains here and in TaskContext", "author": "sopel39", "createdAt": "2020-08-24T13:15:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU5MjE2NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475592165", "bodyText": "I would not rely on isComplete() method in constructor. What if somebody changes order of assignments? Just inline condition here", "author": "sopel39", "createdAt": "2020-08-24T13:17:11Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> symbolsMapBuilder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            symbolsMapBuilder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = symbolsMapBuilder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = filterIds.stream()\n+                .map(filterId -> {\n+                    // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n+                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n+                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n+                            .collect(toImmutableList());\n+                    return Futures.transform(\n+                            futures.get(filterId),\n+                            // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n+                            domain -> TupleDomain.withColumnDomains(\n+                                    probeColumns.stream()\n+                                            .collect(toImmutableMap(\n+                                                    column -> column,\n+                                                    column -> domain))),\n+                            directExecutor());\n+                })\n+                .collect(toImmutableList());\n+        return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Table-specific dynamic filter (collects all domains for a specific table scan)\n+    private static class TableSpecificDynamicFilter\n+            implements DynamicFilter\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        @GuardedBy(\"this\")\n+        private CompletableFuture<?> isBlocked;\n+\n+        @GuardedBy(\"this\")\n+        private TupleDomain<ColumnHandle> currentPredicate;\n+\n+        @GuardedBy(\"this\")\n+        private int futuresLeft;\n+\n+        public TableSpecificDynamicFilter(List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures)\n+        {\n+            this.futuresLeft = predicateFutures.size();\n+            this.isBlocked = isComplete() ? NOT_BLOCKED : new CompletableFuture();", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYyODU5Mg==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475628592", "bodyText": "use requireNotNull(futures.get(filterId), ...", "author": "sopel39", "createdAt": "2020-08-24T13:56:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,155 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.DynamicFilters;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n+    {\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicTupleDomain(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<DynamicFilters.Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        ImmutableMultimap.Builder<DynamicFilterId, Symbol> symbolsMapBuilder = ImmutableMultimap.builder();\n+        for (DynamicFilters.Descriptor descriptor : descriptors) {\n+            symbolsMapBuilder.put(descriptor.getId(), Symbol.from(descriptor.getInput()));\n+        }\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = symbolsMapBuilder.build();\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = filterIds.stream()\n+                .map(filterId -> {\n+                    // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n+                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n+                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n+                            .collect(toImmutableList());\n+                    return Futures.transform(\n+                            futures.get(filterId),", "originalCommit": "ae0dc5dedebf7d33817ee2b0a0bd4f8988af5874", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYzNzYzOQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475637639", "bodyText": "put each argument in new line", "author": "sopel39", "createdAt": "2020-08-24T14:05:20Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -100,21 +103,32 @@ public void testJoinDynamicFilteringNone()\n         assertEquals(result.getResult().getRowCount(), 0);\n \n         // Probe-side is not scanned at all, due to dynamic filtering:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n-                .stream()\n-                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n-                .map(OperatorStats::getInputPositions)\n-                .collect(toImmutableSet());\n-        assertEquals(rowsRead, ImmutableSet.of(0L, buildSideRowsCount));\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId());\n+        assertEquals(rowsRead, ImmutableSet.of(0L, ORDERS_COUNT));\n     }\n \n     @Test\n-    public void testJoinDynamicFilteringSingleValue()\n+    public void testPartitionedJoinNoDynamicFiltering()\n     {\n-        final long buildSideRowsCount = 15_000L;\n+        assertQueryResult(\"SELECT COUNT() FROM orders WHERE totalprice < 0\", 0L);\n+\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.PARTITIONED.name())\n+                .build();\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, \"SELECT * FROM lineitem JOIN orders \" +", "originalCommit": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYzODEzOA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475638138", "bodyText": "you don't need to run this assertion for every test case", "author": "sopel39", "createdAt": "2020-08-24T14:06:01Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -100,21 +103,32 @@ public void testJoinDynamicFilteringNone()\n         assertEquals(result.getResult().getRowCount(), 0);\n \n         // Probe-side is not scanned at all, due to dynamic filtering:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n-                .stream()\n-                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n-                .map(OperatorStats::getInputPositions)\n-                .collect(toImmutableSet());\n-        assertEquals(rowsRead, ImmutableSet.of(0L, buildSideRowsCount));\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId());\n+        assertEquals(rowsRead, ImmutableSet.of(0L, ORDERS_COUNT));\n     }\n \n     @Test\n-    public void testJoinDynamicFilteringSingleValue()\n+    public void testPartitionedJoinNoDynamicFiltering()\n     {\n-        final long buildSideRowsCount = 15_000L;\n+        assertQueryResult(\"SELECT COUNT() FROM orders WHERE totalprice < 0\", 0L);", "originalCommit": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MDA5NA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475640094", "bodyText": "you can remove this test case. It's essentially identical to the one above", "author": "sopel39", "createdAt": "2020-08-24T14:09:06Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -129,13 +143,48 @@ public void testJoinDynamicFilteringSingleValue()\n         assertEquals(result.getResult().getRowCount(), 6);\n \n         // Probe-side is dynamically filtered:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n+        Set<Long> rowsRead = getOperatorRowsRead(runner, result.getQueryId());\n+        assertEquals(rowsRead, ImmutableSet.of(6L, ORDERS_COUNT));\n+    }\n+\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, FeaturesConfig.JoinReorderingStrategy.NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n+                .build();\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // Wait for both build sides to finish before starting the scan of 'lineitem' table (should be very selective given the dynamic filters).\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                session,\n+                \"SELECT l.comment\" +\n+                        \" FROM  lineitem l, part p, orders o\" +\n+                        \" WHERE l.orderkey = o.orderkey AND o.comment = 'nstructions sleep furiously among '\" +\n+                        \" AND p.partkey = l.partkey AND p.comment = 'onic deposits'\");\n+        assertEquals(result.getResult().getRowCount(), 1);\n+        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), ImmutableSet.of(1L, ORDERS_COUNT, PART_COUNT));\n+\n+        // Make sure that a single join doesn't doesn't narrow lineitem to single row.", "originalCommit": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0MTQwMQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475741401", "bodyText": "Oops, thanks for catching this!\nRemove the duplicate and added a new test case to testJoinDynamicFilteringSingleValue.", "author": "rzeyde-varada", "createdAt": "2020-08-24T16:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MDA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MDk5OA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475640998", "bodyText": "please add a test case where build side is large. see #4946, e.g:\nSELECT * FROM orders a JOIN tpch.tiny.orders b ON a.orderkey = b.orderkey\n\nThe query should not be blocked", "author": "sopel39", "createdAt": "2020-08-24T14:10:24Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -43,6 +44,10 @@\n public class TestMemorySmoke\n         extends AbstractTestQueryFramework\n {\n+    private static final long LINEITEM_COUNT = 60175;", "originalCommit": "ba93c071fde690b2ae6bdf79ec9988770b59c894", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0NjYxNA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r475846614", "bodyText": "Cherry-picked 0f34989 and added testJoinLargeBuildSideNoDynamicFiltering.", "author": "rzeyde-varada", "createdAt": "2020-08-24T19:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY0MDk5OA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMDAzNw==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r476310037", "bodyText": "how do you know that p.comment = 'onic deposits' produces single row?", "author": "sopel39", "createdAt": "2020-08-25T09:27:10Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -124,18 +154,50 @@ public void testJoinDynamicFilteringSingleValue()\n                 .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n                 .build();\n         DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n-        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, \"SELECT * FROM lineitem JOIN orders \" +\n-                \"ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\");\n+\n+        // Join lineitem with a single row of orders\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                session,\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\");\n         assertEquals(result.getResult().getRowCount(), 6);\n+        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), ImmutableSet.of(6L, ORDERS_COUNT));\n+\n+        // Join lineitem with a single row of part", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0MjgyOQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r476542829", "bodyText": "Good point, added an assertion query to testJoinDynamicFilteringSingleValue:\n        assertQueryResult(\"SELECT partkey FROM part WHERE comment = 'onic deposits'\", 1552L);\n        assertQueryResult(\"SELECT COUNT() FROM lineitem WHERE partkey = 1552\", 39L);", "author": "rzeyde-varada", "createdAt": "2020-08-25T15:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMDAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMDM1Ng==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r476310356", "bodyText": ".setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\") is not needed, so you can remove it from tests (as a separate commit)", "author": "sopel39", "createdAt": "2020-08-25T09:27:41Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -124,18 +154,50 @@ public void testJoinDynamicFilteringSingleValue()\n                 .setSystemProperty(JOIN_DISTRIBUTION_TYPE, FeaturesConfig.JoinDistributionType.BROADCAST.name())\n                 .build();\n         DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n-        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, \"SELECT * FROM lineitem JOIN orders \" +\n-                \"ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\");\n+\n+        // Join lineitem with a single row of orders\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                session,\n+                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.comment = 'nstructions sleep furiously among '\");\n         assertEquals(result.getResult().getRowCount(), 6);\n+        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), ImmutableSet.of(6L, ORDERS_COUNT));\n+\n+        // Join lineitem with a single row of part\n+        result = runner.executeWithQueryId(\n+                session,\n+                \"SELECT l.comment FROM  lineitem l, part p WHERE p.partkey = l.partkey AND p.comment = 'onic deposits'\");\n+        assertEquals(result.getResult().getRowCount(), 39);\n+        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), ImmutableSet.of(39L, PART_COUNT));\n+    }\n \n-        // Probe-side is dynamically filtered:\n-        QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(result.getQueryId()).getQueryStats();\n-        Set<Long> rowsRead = stats.getOperatorSummaries()\n+    @Test\n+    public void testJoinDynamicFilteringBlockProbeSide()\n+    {\n+        Session session = Session.builder(getSession())\n+                .setSystemProperty(ENABLE_DYNAMIC_FILTERING, \"true\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "88691c75aa5689810df34d2758a4f7e325b7d013", "url": "https://github.com/trinodb/trino/commit/88691c75aa5689810df34d2758a4f7e325b7d013", "message": "Do not enable dynamic filtering explicitly in TestMemorySmoke\n\nIt is enabled by default.", "committedDate": "2020-08-25T18:57:41Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4MzI3MQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r477183271", "bodyText": "let's convert that into stream:\nsymbolsMap.keySet().stream()\n  .filter(filterId -> futures.keySet()::contains)\n  .map(...)", "author": "sopel39", "createdAt": "2020-08-26T09:58:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,152 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSetMultimap.toImmutableSetMultimap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static io.prestosql.sql.DynamicFilters.Descriptor;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n+    {\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4NDMzMA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r477184330", "bodyText": "Let's convert that into stream:\nSet<DynamicFilterId> node.getDynamicFilters().keySet().stream()\n  .filter(getConsumedDynamicFilterIds(probeNode)::contains)\n  .collect(toImmutableSet())", "author": "sopel39", "createdAt": "2020-08-26T10:00:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -1998,6 +1999,13 @@ private PhysicalOperation createLookupJoin(\n                 Optional<Symbol> buildHashSymbol,\n                 LocalExecutionPlanContext context)\n         {\n+            // Register dynamic filters, allowing the scan operators to wait for the collection completion.\n+            // Skip dynamic filters that are not used locally (e.g. in case of distributed joins).\n+            Set<DynamicFilterId> localDynamicFilters = Sets.intersection(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4NDk5NA==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r477184994", "bodyText": "make the constructor private", "author": "sopel39", "createdAt": "2020-08-26T10:01:45Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -13,40 +13,152 @@\n  */\n package io.prestosql.sql.planner;\n \n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.DynamicFilter;\n import io.prestosql.spi.predicate.Domain;\n import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.plan.DynamicFilterId;\n \n import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n \n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSetMultimap.toImmutableSetMultimap;\n+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n+import static io.airlift.concurrent.MoreFutures.addSuccessCallback;\n+import static io.prestosql.sql.DynamicFilters.Descriptor;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n \n @ThreadSafe\n class LocalDynamicFiltersCollector\n {\n-    /**\n-     * May contains domains for dynamic filters for different table scans\n-     * (e.g. in case of co-located joins).\n-     */\n-    @GuardedBy(\"this\")\n-    private final Map<Symbol, Domain> dynamicFilterDomainsResult = new HashMap<>();\n-\n-    public synchronized TupleDomain<Symbol> getDynamicFilter(Set<Symbol> probeSymbols)\n+    // Each future blocks until its dynamic filter is collected.\n+    private final Map<DynamicFilterId, SettableFuture<Domain>> futures = new HashMap<>();\n+\n+    public LocalDynamicFiltersCollector()\n+    {\n+    }\n+\n+    // Called during JoinNode planning (no need to be synchronized as local planning is single threaded)\n+    public void register(Set<DynamicFilterId> filterIds)\n     {\n-        Map<Symbol, Domain> probeSymbolDomains = dynamicFilterDomainsResult.entrySet().stream()\n-                .filter(entry -> probeSymbols.contains(entry.getKey()))\n-                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n-        return TupleDomain.withColumnDomains(probeSymbolDomains);\n+        filterIds.forEach(filterId -> verify(\n+                futures.put(filterId, SettableFuture.create()) == null,\n+                \"LocalDynamicFiltersCollector: duplicate filter %s\", filterId));\n+    }\n+\n+    // Used during execution (after build-side dynamic filter collection is over).\n+    // No need to be synchronized as the futures map doesn't change.\n+    public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        dynamicFilterDomains\n+                .entrySet()\n+                .stream()\n+                .forEach(entry -> {\n+                    SettableFuture<Domain> future = futures.get(entry.getKey());\n+                    // Skip dynamic filters that are not applied locally.\n+                    if (future != null) {\n+                        verify(future.set(entry.getValue()), \"Dynamic filter %s already collected\", entry.getKey());\n+                    }\n+                });\n+    }\n+\n+    // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n+    public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n+    {\n+        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+\n+        // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n+        // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n+        // It is also possible that not all local dynamic filters are needed for this specific table scan.\n+        Set<DynamicFilterId> filterIds = Sets.intersection(symbolsMap.keySet(), futures.keySet());\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = filterIds.stream()\n+                .map(filterId -> {\n+                    // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n+                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n+                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n+                            .collect(toImmutableList());\n+                    return Futures.transform(\n+                            requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n+                            // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n+                            domain -> TupleDomain.withColumnDomains(\n+                                    probeColumns.stream()\n+                                            .collect(toImmutableMap(\n+                                                    column -> column,\n+                                                    column -> domain))),\n+                            directExecutor());\n+                })\n+                .collect(toImmutableList());\n+        return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n-    public synchronized void addDynamicFilter(Map<Symbol, Domain> dynamicFilterDomains)\n+    // Table-specific dynamic filter (collects all domains for a specific table scan)\n+    private static class TableSpecificDynamicFilter\n+            implements DynamicFilter\n     {\n-        for (Map.Entry<Symbol, Domain> entry : dynamicFilterDomains.entrySet()) {\n-            dynamicFilterDomainsResult.merge(entry.getKey(), entry.getValue(), Domain::intersect);\n+        @GuardedBy(\"this\")\n+        private CompletableFuture<?> isBlocked;\n+\n+        @GuardedBy(\"this\")\n+        private TupleDomain<ColumnHandle> currentPredicate;\n+\n+        @GuardedBy(\"this\")\n+        private int futuresLeft;\n+\n+        public TableSpecificDynamicFilter(List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE4Njc0NQ==", "url": "https://github.com/trinodb/trino/pull/3414#discussion_r477186745", "bodyText": "skip filtering when for predicate.isAll()", "author": "sopel39", "createdAt": "2020-08-26T10:04:59Z", "path": "presto-memory/src/main/java/io/prestosql/plugin/memory/MemoryPageSourceProvider.java", "diffHunk": "@@ -83,12 +78,85 @@ public ConnectorPageSource createPageSource(\n                 expectedRows,\n                 memorySplit.getLimit(),\n                 sampleRatio);\n-        return new FixedPageSource(pages.stream()\n-                .map(page -> applyFilter(page, domains))\n-                .collect(toList()));\n+\n+        return new DynamicFilteringPageSource(new FixedPageSource(pages), columns, dynamicFilter, enableLazyDynamicFiltering);\n+    }\n+\n+    private static class DynamicFilteringPageSource\n+            implements ConnectorPageSource\n+    {\n+        private final FixedPageSource delegate;\n+        private final List<ColumnHandle> columns;\n+        private final DynamicFilter dynamicFilter;\n+        private final boolean enableLazyDynamicFiltering;\n+\n+        private DynamicFilteringPageSource(FixedPageSource delegate, List<ColumnHandle> columns, DynamicFilter dynamicFilter, boolean enableLazyDynamicFiltering)\n+        {\n+            this.delegate = delegate;\n+            this.columns = columns;\n+            this.dynamicFilter = dynamicFilter;\n+            this.enableLazyDynamicFiltering = enableLazyDynamicFiltering;\n+        }\n+\n+        @Override\n+        public long getCompletedBytes()\n+        {\n+            return delegate.getCompletedBytes();\n+        }\n+\n+        @Override\n+        public long getReadTimeNanos()\n+        {\n+            return delegate.getReadTimeNanos();\n+        }\n+\n+        @Override\n+        public boolean isFinished()\n+        {\n+            return delegate.isFinished();\n+        }\n+\n+        @Override\n+        public Page getNextPage()\n+        {\n+            if (enableLazyDynamicFiltering && !dynamicFilter.isComplete()) {\n+                return null;\n+            }\n+            TupleDomain<ColumnHandle> predicate = dynamicFilter.getCurrentPredicate();\n+            if (predicate.isNone()) {\n+                close();\n+                return null;\n+            }\n+            Page page = delegate.getNextPage();\n+            if (page != null) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "572115ef83ffc4b5427635db4634a0f533f4a1a5", "url": "https://github.com/trinodb/trino/commit/572115ef83ffc4b5427635db4634a0f533f4a1a5", "message": "Allow blocking page source until dynamic filters are ready\n\nWe allow the connector to block according to dynamic filter collection\nstate. Some connectors would prefer to wait a bit, to benefit from\nmore selective scanning (using the collected dynamic filters).", "committedDate": "2020-08-26T10:50:19Z", "type": "commit"}, {"oid": "d5bb8c84c7b779cbef2747edc8cb9bab8571b54d", "url": "https://github.com/trinodb/trino/commit/d5bb8c84c7b779cbef2747edc8cb9bab8571b54d", "message": "Support lazy dynamic filtering at memory connector", "committedDate": "2020-08-26T10:50:19Z", "type": "commit"}, {"oid": "d5bb8c84c7b779cbef2747edc8cb9bab8571b54d", "url": "https://github.com/trinodb/trino/commit/d5bb8c84c7b779cbef2747edc8cb9bab8571b54d", "message": "Support lazy dynamic filtering at memory connector", "committedDate": "2020-08-26T10:50:19Z", "type": "forcePushed"}]}