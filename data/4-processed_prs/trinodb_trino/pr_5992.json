{"pr_number": 5992, "pr_title": "Stream container statistics", "pr_createdAt": "2020-11-17T19:30:23Z", "pr_url": "https://github.com/trinodb/trino/pull/5992", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ1NjI4OA==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r525456288", "bodyText": ".mapToInt(String::length)\n.max()\n.orElse(0);\n\nwhat about", "author": "findepi", "createdAt": "2020-11-17T19:52:47Z", "path": "presto-product-tests-launcher/src/main/java/io/prestosql/tests/product/launcher/env/EnvironmentListener.java", "diffHunk": "@@ -216,47 +218,65 @@ public void containerStopping(DockerContainer container, InspectContainerRespons\n     static EnvironmentListener statsPrintingListener()\n     {\n         ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2, daemonThreadsNamed(\"container-stats-%d\"));\n-        List<ScheduledFuture<?>> futures = new ArrayList<>();\n+        Map<String, StatisticsFetcher> fetchers = new HashMap<>();\n \n         return new EnvironmentListener()\n         {\n             @Override\n-            public void containerStarting(DockerContainer container, InspectContainerResponse response)\n+            public void containerStarted(DockerContainer container, InspectContainerResponse response)\n             {\n-                // Print stats every 30 seconds\n-                futures.add(executorService.scheduleWithFixedDelay(() ->\n-                {\n-                    StatisticsFetcher.Stats stats = container.getStats();\n-                    if (stats.areCalculated()) {\n-                        log.info(\"%s - %s\", container.getLogicalName(), container.getStats());\n-                    }\n-                }, 5 * 1000L, 30 * 1000L, MILLISECONDS));\n+                // Start listening on statistics stream\n+                fetcher(container).start();\n             }\n \n             @Override\n-            public void containerStopping(DockerContainer container, InspectContainerResponse response)\n+            public void environmentStopping(Environment environment)\n             {\n-                log.info(\"Container %s final statistics - %s\", container, container.getStats());\n-            }\n+                log.info(\"Container final stats: \");\n+                printContainerStats();\n \n-            @Override\n-            public void containerStarted(DockerContainer container, InspectContainerResponse containerInfo)\n-            {\n-                // Force fetching of stats so CPU usage can be calculated from delta\n-                container.getStats();\n+                fetchers.values().forEach(StatisticsFetcher::close);\n+                executorService.shutdownNow();\n             }\n \n             @Override\n-            public void environmentStopping(Environment environment)\n+            public void environmentStarted(Environment environment)\n             {\n-                futures.forEach(future -> future.cancel(true));\n+                // Print stats for all containers every 30s after environment is started\n+                executorService.scheduleWithFixedDelay(() ->\n+                {\n+                    log.info(\"Container stats:\");\n+                    printContainerStats();\n+                }, 5 * 1000L, 30 * 1000L, MILLISECONDS);\n             }\n \n             @Override\n             public void environmentStopped(Environment environment)\n             {\n                 executorService.shutdown();\n             }\n+\n+            private StatisticsFetcher fetcher(DockerContainer container)\n+            {\n+                return fetchers.computeIfAbsent(container.getLogicalName(), key -> new StatisticsFetcher(container.getContainerId(), container.getLogicalName()));\n+            }\n+\n+            private void printContainerStats()\n+            {\n+                int maxLength = fetchers.keySet().stream()\n+                        .map(String::length)\n+                        .max(Integer::compareTo)\n+                        .get();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTcwMA==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r525551700", "bodyText": "nit: closing and then printing seems more natural.", "author": "losipiuk", "createdAt": "2020-11-17T21:57:33Z", "path": "presto-product-tests-launcher/src/main/java/io/prestosql/tests/product/launcher/env/EnvironmentListener.java", "diffHunk": "@@ -216,47 +218,65 @@ public void containerStopping(DockerContainer container, InspectContainerRespons\n     static EnvironmentListener statsPrintingListener()\n     {\n         ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2, daemonThreadsNamed(\"container-stats-%d\"));\n-        List<ScheduledFuture<?>> futures = new ArrayList<>();\n+        Map<String, StatisticsFetcher> fetchers = new TreeMap<>(); // keep map sorted\n \n         return new EnvironmentListener()\n         {\n             @Override\n-            public void containerStarting(DockerContainer container, InspectContainerResponse response)\n+            public void containerStarted(DockerContainer container, InspectContainerResponse response)\n             {\n-                // Print stats every 30 seconds\n-                futures.add(executorService.scheduleWithFixedDelay(() ->\n-                {\n-                    StatisticsFetcher.Stats stats = container.getStats();\n-                    if (stats.areCalculated()) {\n-                        log.info(\"%s - %s\", container.getLogicalName(), container.getStats());\n-                    }\n-                }, 5 * 1000L, 30 * 1000L, MILLISECONDS));\n+                // Start listening on statistics stream\n+                fetcher(container).start();\n             }\n \n             @Override\n-            public void containerStopping(DockerContainer container, InspectContainerResponse response)\n+            public void environmentStopping(Environment environment)\n             {\n-                log.info(\"Container %s final statistics - %s\", container, container.getStats());\n-            }\n+                log.info(\"Container final stats: \");\n+                printContainerStats();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0MDc0NA==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r525940744", "bodyText": "makes sense", "author": "wendigo", "createdAt": "2020-11-18T09:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjcyNQ==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r525552725", "bodyText": "final", "author": "losipiuk", "createdAt": "2020-11-17T21:59:32Z", "path": "presto-product-tests-launcher/src/main/java/io/prestosql/tests/product/launcher/env/StatisticsFetcher.java", "diffHunk": "@@ -13,55 +13,69 @@\n  */\n package io.prestosql.tests.product.launcher.env;\n \n+import com.github.dockerjava.api.async.ResultCallback;\n import com.github.dockerjava.api.model.MemoryStatsConfig;\n import com.github.dockerjava.api.model.StatisticNetworksConfig;\n import com.github.dockerjava.api.model.Statistics;\n-import com.github.dockerjava.core.InvocationBuilder;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Strings;\n import io.airlift.log.Logger;\n import io.airlift.units.DataSize;\n-import net.jodah.failsafe.FailsafeExecutor;\n import org.testcontainers.DockerClientFactory;\n \n+import java.io.Closeable;\n import java.io.IOException;\n-import java.io.UncheckedIOException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Supplier;\n import java.util.stream.Stream;\n \n+import static io.airlift.units.DataSize.Unit.GIGABYTE;\n+import static io.airlift.units.DataSize.Unit.MEGABYTE;\n import static java.lang.String.format;\n import static java.util.Objects.requireNonNull;\n \n public class StatisticsFetcher\n+        implements AutoCloseable\n {\n-    private final DockerContainer container;\n-    private final FailsafeExecutor executor;\n+    private final String containerId;\n     private static final Logger log = Logger.get(StatisticsFetcher.class);\n+    private final String containerLogicalName;\n     private AtomicReference<Stats> lastStats = new AtomicReference<>(new Stats());\n+    private AtomicBoolean started = new AtomicBoolean(false);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1Njg1OA==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r525556858", "bodyText": "actually this one does not seem to be used at all", "author": "losipiuk", "createdAt": "2020-11-17T22:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzODIwOA==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r526138208", "bodyText": "It is now", "author": "wendigo", "createdAt": "2020-11-18T14:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjgyMw==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r525552823", "bodyText": "final", "author": "losipiuk", "createdAt": "2020-11-17T21:59:42Z", "path": "presto-product-tests-launcher/src/main/java/io/prestosql/tests/product/launcher/env/StatisticsFetcher.java", "diffHunk": "@@ -13,55 +13,69 @@\n  */\n package io.prestosql.tests.product.launcher.env;\n \n+import com.github.dockerjava.api.async.ResultCallback;\n import com.github.dockerjava.api.model.MemoryStatsConfig;\n import com.github.dockerjava.api.model.StatisticNetworksConfig;\n import com.github.dockerjava.api.model.Statistics;\n-import com.github.dockerjava.core.InvocationBuilder;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Strings;\n import io.airlift.log.Logger;\n import io.airlift.units.DataSize;\n-import net.jodah.failsafe.FailsafeExecutor;\n import org.testcontainers.DockerClientFactory;\n \n+import java.io.Closeable;\n import java.io.IOException;\n-import java.io.UncheckedIOException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Supplier;\n import java.util.stream.Stream;\n \n+import static io.airlift.units.DataSize.Unit.GIGABYTE;\n+import static io.airlift.units.DataSize.Unit.MEGABYTE;\n import static java.lang.String.format;\n import static java.util.Objects.requireNonNull;\n \n public class StatisticsFetcher\n+        implements AutoCloseable\n {\n-    private final DockerContainer container;\n-    private final FailsafeExecutor executor;\n+    private final String containerId;\n     private static final Logger log = Logger.get(StatisticsFetcher.class);\n+    private final String containerLogicalName;\n     private AtomicReference<Stats> lastStats = new AtomicReference<>(new Stats());\n+    private AtomicBoolean started = new AtomicBoolean(false);\n+    private AtomicBoolean closed = new AtomicBoolean(false);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1OTcxNQ==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r525559715", "bodyText": "Do we need to close callbackClosable here. I would expect not given fact that this close is called by dockerjava", "author": "losipiuk", "createdAt": "2020-11-17T22:13:08Z", "path": "presto-product-tests-launcher/src/main/java/io/prestosql/tests/product/launcher/env/StatisticsFetcher.java", "diffHunk": "@@ -87,20 +101,56 @@ private Stats toStats(Statistics statistics, Stats previousStats)\n         }\n \n         MemoryStatsConfig memoryStats = statistics.getMemoryStats();\n-        stats.memoryLimit = DataSize.ofBytes(memoryStats.getLimit()).succinct();\n-        stats.memoryUsage = DataSize.ofBytes(memoryStats.getUsage()).succinct();\n-        stats.memoryMaxUsage = DataSize.ofBytes(memoryStats.getMaxUsage()).succinct();\n+        stats.memoryLimit = DataSize.ofBytes(memoryStats.getLimit()).to(GIGABYTE);\n+        stats.memoryUsage = DataSize.ofBytes(memoryStats.getUsage()).to(GIGABYTE);\n+        stats.memoryMaxUsage = DataSize.ofBytes(memoryStats.getMaxUsage()).to(GIGABYTE);\n         stats.memoryUsagePerc = 100.0 * memoryStats.getUsage() / memoryStats.getLimit();\n \n         stats.pids = statistics.getPidsStats().getCurrent();\n \n         Supplier<Stream<StatisticNetworksConfig>> stream = () -> statistics.getNetworks().values().stream();\n-        stats.networkReceived = DataSize.ofBytes(stream.get().map(StatisticNetworksConfig::getRxBytes).reduce(0L, Long::sum)).succinct();\n-        stats.networkSent = DataSize.ofBytes(stream.get().map(StatisticNetworksConfig::getRxBytes).reduce(0L, Long::sum)).succinct();\n+        stats.networkReceived = DataSize.ofBytes(stream.get().map(StatisticNetworksConfig::getRxBytes).reduce(0L, Long::sum)).to(MEGABYTE);\n+        stats.networkSent = DataSize.ofBytes(stream.get().map(StatisticNetworksConfig::getRxBytes).reduce(0L, Long::sum)).to(MEGABYTE);\n \n         return stats;\n     }\n \n+    private class StatisticsCallback\n+            implements ResultCallback<Statistics>\n+    {\n+        @Override\n+        public void onNext(Statistics statistics)\n+        {\n+            lastStats.getAndUpdate(previousStats -> toStats(statistics, previousStats));\n+        }\n+\n+        @Override\n+        public void onStart(Closeable closeable)\n+        {\n+            callbackCloseable = closeable;\n+        }\n+\n+        @Override\n+        public void onError(Throwable throwable)\n+        {\n+            // we don't care here - in worst case scenario we will just have stale statistics\n+        }\n+\n+        @Override\n+        public void onComplete()\n+        {\n+            log.info(\"Statistics for container %s stopped streaming\", containerLogicalName);\n+        }\n+\n+        @Override\n+        public void close()\n+                throws IOException\n+        {\n+            callbackCloseable.close();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzODY4OQ==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r526138689", "bodyText": "We need if we close before stream ends (ie when pt timeout occurs)", "author": "wendigo", "createdAt": "2020-11-18T14:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1OTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2MDI0MA==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r525560240", "bodyText": "it is not obvious that callbackClosable cannot be null.", "author": "losipiuk", "createdAt": "2020-11-17T22:14:13Z", "path": "presto-product-tests-launcher/src/main/java/io/prestosql/tests/product/launcher/env/StatisticsFetcher.java", "diffHunk": "@@ -13,55 +13,69 @@\n  */\n package io.prestosql.tests.product.launcher.env;\n \n+import com.github.dockerjava.api.async.ResultCallback;\n import com.github.dockerjava.api.model.MemoryStatsConfig;\n import com.github.dockerjava.api.model.StatisticNetworksConfig;\n import com.github.dockerjava.api.model.Statistics;\n-import com.github.dockerjava.core.InvocationBuilder;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Strings;\n import io.airlift.log.Logger;\n import io.airlift.units.DataSize;\n-import net.jodah.failsafe.FailsafeExecutor;\n import org.testcontainers.DockerClientFactory;\n \n+import java.io.Closeable;\n import java.io.IOException;\n-import java.io.UncheckedIOException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Supplier;\n import java.util.stream.Stream;\n \n+import static io.airlift.units.DataSize.Unit.GIGABYTE;\n+import static io.airlift.units.DataSize.Unit.MEGABYTE;\n import static java.lang.String.format;\n import static java.util.Objects.requireNonNull;\n \n public class StatisticsFetcher\n+        implements AutoCloseable\n {\n-    private final DockerContainer container;\n-    private final FailsafeExecutor executor;\n+    private final String containerId;\n     private static final Logger log = Logger.get(StatisticsFetcher.class);\n+    private final String containerLogicalName;\n     private AtomicReference<Stats> lastStats = new AtomicReference<>(new Stats());\n+    private AtomicBoolean started = new AtomicBoolean(false);\n+    private AtomicBoolean closed = new AtomicBoolean(false);\n+    private Closeable callbackCloseable;\n \n-    public StatisticsFetcher(DockerContainer container, FailsafeExecutor executor)\n+    public StatisticsFetcher(String containerId, String containerLogicalName)\n     {\n-        this.container = requireNonNull(container, \"container is null\");\n-        this.executor = requireNonNull(executor, \"executor is null\");\n+        this.containerId = requireNonNull(containerId, \"containerId is null\");\n+        this.containerLogicalName = requireNonNull(containerLogicalName, \"containerLogicalName is null\");\n     }\n \n     public Stats get()\n     {\n-        if (!container.isRunning()) {\n-            log.warn(\"Could not get statistics for stopped container %s\", container.getLogicalName());\n-            return lastStats.get();\n-        }\n+        return lastStats.get();\n+    }\n \n-        try (InvocationBuilder.AsyncResultCallback<Statistics> callback = new InvocationBuilder.AsyncResultCallback<>()) {\n-            DockerClientFactory.lazyClient().statsCmd(container.getContainerId()).exec(callback);\n+    public void start()\n+    {\n+        DockerClientFactory.lazyClient()\n+                .statsCmd(containerId)\n+                .exec(new StatisticsCallback());\n \n-            return lastStats.getAndUpdate(previousStats -> toStats((Statistics) executor.get(callback::awaitResult), previousStats));\n-        }\n-        catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-        catch (RuntimeException e) {\n-            log.error(e, \"Could not fetch container %s statistics\", container.getLogicalName());\n-            return lastStats.get();\n+        log.info(\"Started listening for container %s statistics stream...\", containerLogicalName);\n+    }\n+\n+    @Override\n+    public void close()\n+    {\n+        if (closed.compareAndSet(false, true)) {\n+            try {\n+                callbackCloseable.close();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzNzAyNQ==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r526137025", "bodyText": "It\u2019s not but I can add an assertion here", "author": "wendigo", "createdAt": "2020-11-18T14:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2MDI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2MDk0Mw==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r525560943", "bodyText": "can we still log something (we are logging in onComplete)", "author": "losipiuk", "createdAt": "2020-11-17T22:15:35Z", "path": "presto-product-tests-launcher/src/main/java/io/prestosql/tests/product/launcher/env/StatisticsFetcher.java", "diffHunk": "@@ -87,20 +101,56 @@ private Stats toStats(Statistics statistics, Stats previousStats)\n         }\n \n         MemoryStatsConfig memoryStats = statistics.getMemoryStats();\n-        stats.memoryLimit = DataSize.ofBytes(memoryStats.getLimit()).succinct();\n-        stats.memoryUsage = DataSize.ofBytes(memoryStats.getUsage()).succinct();\n-        stats.memoryMaxUsage = DataSize.ofBytes(memoryStats.getMaxUsage()).succinct();\n+        stats.memoryLimit = DataSize.ofBytes(memoryStats.getLimit()).to(GIGABYTE);\n+        stats.memoryUsage = DataSize.ofBytes(memoryStats.getUsage()).to(GIGABYTE);\n+        stats.memoryMaxUsage = DataSize.ofBytes(memoryStats.getMaxUsage()).to(GIGABYTE);\n         stats.memoryUsagePerc = 100.0 * memoryStats.getUsage() / memoryStats.getLimit();\n \n         stats.pids = statistics.getPidsStats().getCurrent();\n \n         Supplier<Stream<StatisticNetworksConfig>> stream = () -> statistics.getNetworks().values().stream();\n-        stats.networkReceived = DataSize.ofBytes(stream.get().map(StatisticNetworksConfig::getRxBytes).reduce(0L, Long::sum)).succinct();\n-        stats.networkSent = DataSize.ofBytes(stream.get().map(StatisticNetworksConfig::getRxBytes).reduce(0L, Long::sum)).succinct();\n+        stats.networkReceived = DataSize.ofBytes(stream.get().map(StatisticNetworksConfig::getRxBytes).reduce(0L, Long::sum)).to(MEGABYTE);\n+        stats.networkSent = DataSize.ofBytes(stream.get().map(StatisticNetworksConfig::getRxBytes).reduce(0L, Long::sum)).to(MEGABYTE);\n \n         return stats;\n     }\n \n+    private class StatisticsCallback\n+            implements ResultCallback<Statistics>\n+    {\n+        @Override\n+        public void onNext(Statistics statistics)\n+        {\n+            lastStats.getAndUpdate(previousStats -> toStats(statistics, previousStats));\n+        }\n+\n+        @Override\n+        public void onStart(Closeable closeable)\n+        {\n+            callbackCloseable = closeable;\n+        }\n+\n+        @Override\n+        public void onError(Throwable throwable)\n+        {\n+            // we don't care here - in worst case scenario we will just have stale statistics", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzNzYzMg==", "url": "https://github.com/trinodb/trino/pull/5992#discussion_r526137632", "bodyText": "It will log always (when container is stopped we will get recv() eof error)", "author": "wendigo", "createdAt": "2020-11-18T14:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2MDk0Mw=="}], "type": "inlineReview"}, {"oid": "c83482bd28dced1ce9ed4fe3f24daf924dd50bde", "url": "https://github.com/trinodb/trino/commit/c83482bd28dced1ce9ed4fe3f24daf924dd50bde", "message": "Stream container statistics", "committedDate": "2020-11-19T09:41:47Z", "type": "commit"}, {"oid": "c83482bd28dced1ce9ed4fe3f24daf924dd50bde", "url": "https://github.com/trinodb/trino/commit/c83482bd28dced1ce9ed4fe3f24daf924dd50bde", "message": "Stream container statistics", "committedDate": "2020-11-19T09:41:47Z", "type": "forcePushed"}]}