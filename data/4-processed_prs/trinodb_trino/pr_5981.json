{"pr_number": 5981, "pr_title": "Optimize execution for output duplicates insensitive joins", "pr_createdAt": "2020-11-16T17:38:19Z", "pr_url": "https://github.com/trinodb/trino/pull/5981", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDY4NzQzOQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r524687439", "bodyText": "Would that allow us to remove special treatment of streaming aggregations now?", "author": "findepi", "createdAt": "2020-11-16T22:34:53Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/JoinNode.java", "diffHunk": "@@ -52,6 +52,7 @@\n     private final List<EquiJoinClause> criteria;\n     private final List<Symbol> leftOutputSymbols;\n     private final List<Symbol> rightOutputSymbols;\n+    private final boolean cardinalityInsensitive;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDY5Mzk1OA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r524693958", "bodyText": "I don't think so. Streaming aggregations use constant memory and aggregate actual functions.", "author": "sopel39", "createdAt": "2020-11-16T22:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDY4NzQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI3NjIwNA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525276204", "bodyText": "But I think we can improve correlated EXISTS(... corr_x < y) subqueries by removing UniqueId and StreamingAggergation operators", "author": "sopel39", "createdAt": "2020-11-17T15:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDY4NzQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDU4Mzg1OA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r524583858", "bodyText": "Not assuming any particular order of applying this rule and OptimizeCardinalityInsensitiveJoinRule, both might match the same plan. At a closer look, we always get a valid transformation, but depending on the order of the rules applied, the resulting plans differ in JoinNode having the \"cardinality insensitive\" flag or not.\nTo avoid this issue, I suggest that we add another rule to capture the common case (and exclude the case from other rules):\n- Aggregation (no aggregations; GROUP BY all left source symbols)\n      - LEFT join\n            - left source\n            - right source\n\nShould be transformed into:\n- Aggregation ((no aggregations; GROUP BY all left source symbols)\n      - left source", "author": "kasiafi", "createdAt": "2020-11-16T21:09:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationThroughOuterJoin.java", "diffHunk": "@@ -153,6 +153,7 @@ public Result apply(AggregationNode aggregation, Captures captures, Context cont\n                     join.getCriteria(),\n                     join.getLeft().getOutputSymbols(),\n                     ImmutableList.copyOf(rewrittenAggregation.getAggregations().keySet()),\n+                    join.isCardinalityInsensitive(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2OTIyNw==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525569227", "bodyText": "Since aggregation is pushed down and outer rows were guaranteed to be distinct we can just set cardinalityInsensitive to false here", "author": "sopel39", "createdAt": "2020-11-17T22:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDU4Mzg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDY3MzIyMA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r524673220", "bodyText": "I think we could try to find a different name for this property.\n\"cardinality insensitive\" suggests that the output of JoinNode is independent of cardinality of its inputs. This is true only for certain cases depending on implementation. Actually, this property captures a relation between the JoinNode and its parent.\nI would rename it to \"is in cardinality insensitive context\", or simply \"can skip duplicates\".", "author": "kasiafi", "createdAt": "2020-11-16T22:21:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/JoinNode.java", "diffHunk": "@@ -52,6 +52,7 @@\n     private final List<EquiJoinClause> criteria;\n     private final List<Symbol> leftOutputSymbols;\n     private final List<Symbol> rightOutputSymbols;\n+    private final boolean cardinalityInsensitive;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM0NTc4OA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525345788", "bodyText": "What about outputCardinalityInsensitive or `canSkipOutputDuplicates?\ncan skip duplicates also doesn't say if it's input or output", "author": "sopel39", "createdAt": "2020-11-17T17:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDY3MzIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1MDc5MA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525350790", "bodyText": "canSkipOutputDuplicates is great.", "author": "kasiafi", "createdAt": "2020-11-17T17:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDY3MzIyMA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI4NjIzMw==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525286233", "bodyText": "Add tests with projections and filters between AggregationNode and JoinNode (both deterministic and non-deterministic), Also, for JoinNode nested in JoinNode with non-deterministic filter.", "author": "kasiafi", "createdAt": "2020-11-17T16:10:23Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestOptimizeCardinalityInsensitiveJoinRule.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.aggregation;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.join;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.values;\n+import static io.prestosql.sql.planner.iterative.rule.test.PlanBuilder.expression;\n+import static io.prestosql.sql.planner.plan.JoinNode.Type.INNER;\n+\n+public class TestOptimizeCardinalityInsensitiveJoinRule", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI5MTYzMQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525291631", "bodyText": "Should these be extracted to another commit?", "author": "kasiafi", "createdAt": "2020-11-17T16:17:27Z", "path": "presto-server-main/etc/config.properties", "diffHunk": "@@ -4,29 +4,23 @@\n # This configuration file is for development only and should NOT be used\n # in production. For example configuration, see the Presto documentation.\n #\n-", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMwNzQwOA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525307408", "bodyText": "unrelated", "author": "kasiafi", "createdAt": "2020-11-17T16:36:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -3109,7 +3162,7 @@ else if (target instanceof InsertTarget) {\n             else if (target instanceof TableWriterNode.RefreshMaterializedViewTarget) {\n                 TableWriterNode.RefreshMaterializedViewTarget refreshTarget = (TableWriterNode.RefreshMaterializedViewTarget) target;\n                 return metadata.finishRefreshMaterializedView(session, refreshTarget.getTableHandle(), refreshTarget.getInsertHandle(),\n-                    fragments, statistics, refreshTarget.getSourceTableHandles());\n+                        fragments, statistics, refreshTarget.getSourceTableHandles());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMjg4MQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r525332881", "bodyText": "Could you please add tests:\n\nwith FULL join,\nwith GROUP BY build symbols,\nwith multiple grouping sets?", "author": "kasiafi", "createdAt": "2020-11-17T17:06:54Z", "path": "presto-testing/src/main/java/io/prestosql/testing/AbstractTestJoinQueries.java", "diffHunk": "@@ -2279,4 +2282,42 @@ public void testMultiJoinWithEligibleForDynamicFiltering()\n                         \"AND customer.name >= 'Customer#000001463' \",\n                 \"VALUES 3\");\n     }\n+\n+    @Test\n+    public void testCardinalityInsensitiveJoin()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4MzgwMw==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526083803", "bodyText": "What if we could make pass this flag (matchSingleBuildRow) so when we build the hashTable we could make sure that only one element exists ? Or override getNextJoinPosition to return -1. Not sure if it would affect other places", "author": "Praveen2112", "createdAt": "2020-11-18T13:23:36Z", "path": "presto-main/src/main/java/io/prestosql/operator/LookupJoinOperator.java", "diffHunk": "@@ -336,8 +342,13 @@ private boolean joinCurrentPosition(LookupSource lookupSource, DriverYieldSignal\n                     joinSourcePositions++;\n                 }\n \n-                // get next position on lookup side for this probe row\n-                joinPosition = lookupSource.getNextJoinPosition(joinPosition, probe.getPosition(), probe.getPage());\n+                if (!matchSingleBuildRow || !currentProbePositionProducedRow) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4ODMyMQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526088321", "bodyText": "Or maybe a simple PositionalLink that could return -1 for PositionalLink#next", "author": "Praveen2112", "createdAt": "2020-11-18T13:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4MzgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEzNTg3Nw==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526135877", "bodyText": "That would work when there are no extra filters in JoinNode#filter. It's a good idea. Could it be a follow up?", "author": "sopel39", "createdAt": "2020-11-18T14:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA4MzgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MDMwMg==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526340302", "bodyText": "This will affect the computed estimates for the join, but I don't see anything in this PR that adjusts that logic. The resulting cardinality should be no larger than that of the left side of the join.", "author": "martint", "createdAt": "2020-11-18T18:52:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/JoinNode.java", "diffHunk": "@@ -302,6 +306,12 @@ public PlanNode getRight()\n         return spillable;\n     }\n \n+    @JsonProperty(\"canSkipOutputDuplicates\")\n+    public boolean isCanSkipOutputDuplicates()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5MDEzOQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526390139", "bodyText": "Currently, OptimizeOutputDuplicatesInsensitiveJoinRule is executed after ReorderJoins since ReorderJoins creates new JoinNodes without canSkipOutputDuplicates property.\nI think, we could improve ReorderJoins to understand that entire join subtree matches canSkipOutputDuplicates, but this is not part of this PR.", "author": "sopel39", "createdAt": "2020-11-18T20:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MDMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MTg1MA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526341850", "bodyText": "canSkipOutputDuplicates = true only makes sense if the only columns being output come from the left side of the join (or are equi-join keys in the case of an inner join). Also, this doesn't work for RIGHT or FULL join, so we should validate we're not creating an inconsistent node.\nAlso, given the semantics of this property, I'm not sure canSkipOutputDuplicates is the best name. It'd be more accurate to call it \"outputsFirstMatchOnly\" or something similar.", "author": "martint", "createdAt": "2020-11-18T18:54:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/JoinNode.java", "diffHunk": "@@ -98,6 +100,7 @@ public JoinNode(\n         this.criteria = ImmutableList.copyOf(criteria);\n         this.leftOutputSymbols = ImmutableList.copyOf(leftOutputSymbols);\n         this.rightOutputSymbols = ImmutableList.copyOf(rightOutputSymbols);\n+        this.canSkipOutputDuplicates = canSkipOutputDuplicates;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM3NjM5MQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526376391", "bodyText": "Also, this doesn't work for RIGHT or FULL join, so we should validate we're not creating an inconsistent node.\n\n@martint Initially I thought about making JoinNode#canSkipOutputDuplicates implementation specific (to model how LookupJoinOperator and cross join work). However, this complicates reasoning and is more prone to rune ordering. For example, with current approach following scenario would work:\n\nOptimizeOutputDuplicatesInsensitiveJoinRule could mark RIGHT join as canSkipOutputDuplicates\nlater some other rule could flip join sides, but canSkipOutputDuplicates property is preserved.\n\nSimilarly, other rules like PPD, unalias or pruning can fire but canSkipOutputDuplicates property is preserved. If I connected canSkipOutputDuplicates with some concrete join implementation, that would require additional checks if canSkipOutputDuplicates can be preserved. In worst case, canSkipOutputDuplicates property is lost during planning.\nBy making canSkipOutputDuplicates property of the join algebra itself (and not join implementation) planning logic get simpler and is more stable.\nIt seems that eventually we should have different concrete plan nodes for different join implementations (e.g LookupJoin, SortJoin, CrossJoin). That would have additional benefit of being able to compare plans with different join implementations.", "author": "sopel39", "createdAt": "2020-11-18T19:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MTg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM5OTg1OA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526399858", "bodyText": "Like I suggested in #6005, we need to sort it out before we start optimizing other plans based on canSkipOutputDuplicates property.\nIn the case captured by the OptimizeOutputDuplicatesInsensitiveJoinRule , the aggregation remains in the plan, so the result is the same, no matter if the join is or is not eventually optimized. However, before we add other transformations depending on join dropping duplicates, we need to find a way to ensure that the execution will follow - that is, that the join will not flip.", "author": "kasiafi", "createdAt": "2020-11-18T20:28:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MTg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQxNjE5NA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r526416194", "bodyText": "However, before we add other transformations depending on join dropping duplicates, we need to find a way to ensure that the execution will follow - that is, that the join will not flip.\n\nThis looks like committing to some concrete implementation of join that has extra properties (e.g cannot be flipped). IIRC some planners actually plan first with abstract node types and only then have rules that choose concrete implementation.\nOn one hand committing to some operator implementation can open new optimization possibilities, but on the other hand it can close others. Memo based optimizer would be helpful in such case.", "author": "sopel39", "createdAt": "2020-11-18T20:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1NDc2MA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r537854760", "bodyText": "Can we make this agnostic about where it runs relative to join reordering? What kind of issue does it cause for join reordering that forces this to run after?", "author": "martint", "createdAt": "2020-12-07T21:43:44Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -672,7 +673,11 @@ public PlanOptimizers(\n                 ruleStats,\n                 statsCalculator,\n                 costCalculator,\n-                ImmutableSet.of(new PushDeleteIntoConnector(metadata)))); // Must run before AddExchanges\n+                ImmutableSet.of(\n+                        // Must run before AddExchanges\n+                        new PushDeleteIntoConnector(metadata),\n+                        // Must run before AddExchanges and after join reordering\n+                        new OptimizeOutputDuplicatesInsensitiveJoinRule(metadata))));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ0MDUzMg==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r553440532", "bodyText": "I've added comment here:\n// Must run after join reordering because join reordering creates\n// new join nodes without JoinNode.maySkipOutputDuplicates flag set", "author": "sopel39", "createdAt": "2021-01-07T16:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1NDc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1NjEzOA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r537856138", "bodyText": "This name is too generic. I can imagine many other places where an operation would be insensitive to duplicates, so the name should be more explicit about the fact that it's optimizing something involving aggregation and join.", "author": "martint", "createdAt": "2020-12-07T21:46:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/OptimizeOutputDuplicatesInsensitiveJoinRule.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.GroupReference;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanVisitor;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.prestosql.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizeOutputDuplicatesInsensitiveJoinRule", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1ODc2Mg==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r537858762", "bodyText": "We should avoid visitor-based rewrites as much as possible. We're trying to move away from them, as they make it hard to have a fully exploratory optimizer that considers multiple plans simultaneously.\nWhat we need to do this generically is a description of the properties (traits) of the data coming out of the source of the aggregation, possibly, involving functional dependencies to be able to infer whether certain columns are guaranteed to be unique based on whether they are derived from other unique columns.", "author": "martint", "createdAt": "2020-12-07T21:50:33Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/OptimizeOutputDuplicatesInsensitiveJoinRule.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.GroupReference;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.JoinNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanVisitor;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.prestosql.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizeOutputDuplicatesInsensitiveJoinRule\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(aggregation -> aggregation.getAggregations().isEmpty());\n+\n+    private final Metadata metadata;\n+\n+    public OptimizeOutputDuplicatesInsensitiveJoinRule(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isOptimizeOutputDuplicatesInsensitiveJoins(session);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode aggregation, Captures captures, Context context)\n+    {\n+        return aggregation.getSource().accept(new Rewriter(metadata, context.getLookup()), null)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ2MjM3NQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r553462375", "bodyText": "I agree. In this case, there should be a way to tell optimizer that I want an input plan node which is producing given trait. Optimizer should try to satisfy such requirement (if possible).\nWe had some ideas around how this can be done in: https://docs.google.com/presentation/d/1rbtJLG89GxEYLZYA09TH5cD4S6UvYXtq0OmdNqQnmws/edit#slide=id.g1fce08ab98_0_4", "author": "sopel39", "createdAt": "2021-01-07T17:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg1ODc2Mg=="}], "type": "inlineReview"}, {"oid": "8b99e074537561c694fda2caa86a9020e772dfa6", "url": "https://github.com/trinodb/trino/commit/8b99e074537561c694fda2caa86a9020e772dfa6", "message": "Fix formatting", "committedDate": "2021-01-07T12:41:33Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "3b31bd4164623a3ff6e46c852de5bf4ca64db539", "url": "https://github.com/trinodb/trino/commit/3b31bd4164623a3ff6e46c852de5bf4ca64db539", "message": "Add JoinNode#maySkipOutputDuplicates", "committedDate": "2021-01-07T14:45:32Z", "type": "commit"}, {"oid": "50d15f7822eddf91a81c9547fe1e607abed2c469", "url": "https://github.com/trinodb/trino/commit/50d15f7822eddf91a81c9547fe1e607abed2c469", "message": "Add \"may skip output duplicates\" as part of tpcds/tpcds plans testing", "committedDate": "2021-01-07T14:53:06Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NTEzNg==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556885136", "bodyText": "I don't think \"empty aggregation\" is the best name for this. It's an aggregation with no aggregate function calls.\nI would rename this to \"optimize duplicate-insensitive joins\"", "author": "martint", "createdAt": "2021-01-13T22:04:51Z", "path": "core/trino-main/src/main/java/io/trino/SystemSessionProperties.java", "diffHunk": "@@ -548,6 +549,11 @@ public SystemSessionProperties(\n                         \"Rewrite semi join in filtering context to inner join\",\n                         featuresConfig.isRewriteFilteringSemiJoinToInnerJoin(),\n                         false),\n+                booleanProperty(\n+                        OPTIMIZE_JOINS_BELOW_EMPTY_AGGREGATION,\n+                        \"Optimize joins below empty aggregations\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4NTg0Mg==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556885842", "bodyText": "isOptimizeDuplicateInsensitiveJoins", "author": "martint", "createdAt": "2021-01-13T22:05:39Z", "path": "core/trino-main/src/main/java/io/trino/SystemSessionProperties.java", "diffHunk": "@@ -1000,6 +1006,11 @@ public static boolean isRewriteFilteringSemiJoinToInnerJoin(Session session)\n         return session.getSystemProperty(FILTERING_SEMI_JOIN_TO_INNER, Boolean.class);\n     }\n \n+    public static boolean isOptimizeOutputDuplicatesInsensitiveJoins(Session session)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MDEzMQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556890131", "bodyText": "Maybe invert the condition for readability:\n                if (matchSingleBuildRow && currentProbePositionProducedRow) {\n                    joinPosition = -1;\n                }\n                else {\n                    // get next position on lookup side for this probe row\n                    joinPosition = lookupSource.getNextJoinPosition(joinPosition, probe.getPosition(), probe.getPage());\n                }", "author": "martint", "createdAt": "2021-01-13T22:09:39Z", "path": "core/trino-main/src/main/java/io/trino/operator/LookupJoinOperator.java", "diffHunk": "@@ -337,8 +342,13 @@ private boolean joinCurrentPosition(LookupSource lookupSource, DriverYieldSignal\n                     joinSourcePositions++;\n                 }\n \n-                // get next position on lookup side for this probe row\n-                joinPosition = lookupSource.getNextJoinPosition(joinPosition, probe.getPosition(), probe.getPage());\n+                if (!matchSingleBuildRow || !currentProbePositionProducedRow) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MTIzMw==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556891233", "bodyText": "I'd call this \"outputSingleMatch\". It's not about matching a single row, but outputting a single row from all the ones that match.", "author": "martint", "createdAt": "2021-01-13T22:10:38Z", "path": "core/trino-main/src/main/java/io/trino/operator/LookupJoinOperator.java", "diffHunk": "@@ -162,6 +164,7 @@ public void close()\n         private final LookupJoinPageBuilder pageBuilder;\n         private final Map<Integer, SavedRow> spilledRows = new HashMap<>();\n         private final boolean probeOnOuterSide;\n+        private final boolean matchSingleBuildRow;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5NTM3OA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556895378", "bodyText": "OptimizeDuplicateInsensitiveJoins", "author": "martint", "createdAt": "2021-01-13T22:14:31Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/OptimizeJoinsBelowEmptyAggregationRule.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.trino.Session;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.metadata.Metadata;\n+import io.trino.sql.planner.iterative.GroupReference;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.planner.plan.JoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanVisitor;\n+import io.trino.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.trino.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.trino.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.trino.sql.planner.plan.Patterns.aggregation;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * For empty aggregations duplicate input rows can be skipped.\n+ * This rule takes advantage of this fact and sets\n+ * {@link JoinNode#withMaySkipOutputDuplicates()} for joins below\n+ * such aggregation.\n+ */\n+public class OptimizeJoinsBelowEmptyAggregationRule", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkwNjg4Mg==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556906882", "bodyText": "I'm not sure I understand this. If the join node is already marked with maySkipOutputDuplicates, why would we not preserve it regardless? If a join with a non-deterministic non equi condition is incompatible with isMaySkipOutputDuplicates, we would've never got in this state (and we should validate that somewhere else -- e.g., when pushing filters into join and/or when constructing a join node)", "author": "martint", "createdAt": "2021-01-13T22:25:18Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/OptimizeJoinsBelowEmptyAggregationRule.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.trino.Session;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.metadata.Metadata;\n+import io.trino.sql.planner.iterative.GroupReference;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.planner.plan.JoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanVisitor;\n+import io.trino.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.trino.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.trino.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.trino.sql.planner.plan.Patterns.aggregation;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * For empty aggregations duplicate input rows can be skipped.\n+ * This rule takes advantage of this fact and sets\n+ * {@link JoinNode#withMaySkipOutputDuplicates()} for joins below\n+ * such aggregation.\n+ */\n+public class OptimizeJoinsBelowEmptyAggregationRule\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(aggregation -> aggregation.getAggregations().isEmpty());\n+\n+    private final Metadata metadata;\n+\n+    public OptimizeJoinsBelowEmptyAggregationRule(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isOptimizeOutputDuplicatesInsensitiveJoins(session);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode aggregation, Captures captures, Context context)\n+    {\n+        return aggregation.getSource().accept(new Rewriter(metadata, context.getLookup()), null)\n+                .map(rewrittenSource -> Result.ofPlanNode(aggregation.replaceChildren(ImmutableList.of(rewrittenSource))))\n+                .orElse(Result.empty());\n+    }\n+\n+    private static class Rewriter\n+            extends PlanVisitor<Optional<PlanNode>, Void>\n+    {\n+        private final Metadata metadata;\n+        private final Lookup lookup;\n+\n+        private Rewriter(Metadata metadata, Lookup lookup)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.lookup = requireNonNull(lookup, \"lookup is null\");\n+        }\n+\n+        @Override\n+        protected Optional<PlanNode> visitPlan(PlanNode node, Void context)\n+        {\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitFilter(FilterNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getPredicate(), metadata)) {\n+                // non-deterministic expressions could filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitProject(ProjectNode node, Void context)\n+        {\n+            boolean isDeterministic = node.getAssignments().getExpressions().stream()\n+                    .allMatch(expression -> isDeterministic(expression, metadata));\n+            if (!isDeterministic) {\n+                // non-deterministic projections could be used in downstream filters which could\n+                // filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitJoin(JoinNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getFilter().orElse(TRUE_LITERAL), metadata)) {\n+                // LookupJoinOperator will evaluate non-deterministic condition on output rows until one of the\n+                // rows matches. Therefore it's safe to set maySkipOutputDuplicates for joins with non-deterministic\n+                // filters.\n+                if (node.isMaySkipOutputDuplicates()) {\n+                    return Optional.empty();\n+                }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMwMzc0NQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r557303745", "bodyText": "I'm not sure I understand this. If the join node is already marked with maySkipOutputDuplicates, why would we not preserve it regardless?\n\nIt is preserved. If non empty Optional would be returned here, the rule would loop forever. Added comment", "author": "sopel39", "createdAt": "2021-01-14T10:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkwNjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkwODM3MQ==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556908371", "bodyText": "Why would we undo isMaySkipOutputDuplicates for a node that has already been determined as able to do it?", "author": "martint", "createdAt": "2021-01-13T22:26:39Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/iterative/rule/OptimizeJoinsBelowEmptyAggregationRule.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.trino.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.trino.Session;\n+import io.trino.matching.Captures;\n+import io.trino.matching.Pattern;\n+import io.trino.metadata.Metadata;\n+import io.trino.sql.planner.iterative.GroupReference;\n+import io.trino.sql.planner.iterative.Lookup;\n+import io.trino.sql.planner.iterative.Rule;\n+import io.trino.sql.planner.plan.AggregationNode;\n+import io.trino.sql.planner.plan.FilterNode;\n+import io.trino.sql.planner.plan.JoinNode;\n+import io.trino.sql.planner.plan.PlanNode;\n+import io.trino.sql.planner.plan.PlanVisitor;\n+import io.trino.sql.planner.plan.ProjectNode;\n+\n+import java.util.Optional;\n+\n+import static io.trino.SystemSessionProperties.isOptimizeOutputDuplicatesInsensitiveJoins;\n+import static io.trino.sql.planner.DeterminismEvaluator.isDeterministic;\n+import static io.trino.sql.planner.plan.Patterns.aggregation;\n+import static io.trino.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * For empty aggregations duplicate input rows can be skipped.\n+ * This rule takes advantage of this fact and sets\n+ * {@link JoinNode#withMaySkipOutputDuplicates()} for joins below\n+ * such aggregation.\n+ */\n+public class OptimizeJoinsBelowEmptyAggregationRule\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(aggregation -> aggregation.getAggregations().isEmpty());\n+\n+    private final Metadata metadata;\n+\n+    public OptimizeJoinsBelowEmptyAggregationRule(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isOptimizeOutputDuplicatesInsensitiveJoins(session);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode aggregation, Captures captures, Context context)\n+    {\n+        return aggregation.getSource().accept(new Rewriter(metadata, context.getLookup()), null)\n+                .map(rewrittenSource -> Result.ofPlanNode(aggregation.replaceChildren(ImmutableList.of(rewrittenSource))))\n+                .orElse(Result.empty());\n+    }\n+\n+    private static class Rewriter\n+            extends PlanVisitor<Optional<PlanNode>, Void>\n+    {\n+        private final Metadata metadata;\n+        private final Lookup lookup;\n+\n+        private Rewriter(Metadata metadata, Lookup lookup)\n+        {\n+            this.metadata = requireNonNull(metadata, \"metadata is null\");\n+            this.lookup = requireNonNull(lookup, \"lookup is null\");\n+        }\n+\n+        @Override\n+        protected Optional<PlanNode> visitPlan(PlanNode node, Void context)\n+        {\n+            return Optional.empty();\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitFilter(FilterNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getPredicate(), metadata)) {\n+                // non-deterministic expressions could filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitProject(ProjectNode node, Void context)\n+        {\n+            boolean isDeterministic = node.getAssignments().getExpressions().stream()\n+                    .allMatch(expression -> isDeterministic(expression, metadata));\n+            if (!isDeterministic) {\n+                // non-deterministic projections could be used in downstream filters which could\n+                // filter duplicate rows probabilistically\n+                return Optional.empty();\n+            }\n+\n+            return node.getSource().accept(this, null)\n+                    .map(source -> node.replaceChildren(ImmutableList.of(source)));\n+        }\n+\n+        @Override\n+        public Optional<PlanNode> visitJoin(JoinNode node, Void context)\n+        {\n+            if (!isDeterministic(node.getFilter().orElse(TRUE_LITERAL), metadata)) {\n+                // LookupJoinOperator will evaluate non-deterministic condition on output rows until one of the\n+                // rows matches. Therefore it's safe to set maySkipOutputDuplicates for joins with non-deterministic\n+                // filters.\n+                if (node.isMaySkipOutputDuplicates()) {\n+                    return Optional.empty();\n+                }\n+\n+                return Optional.of(node.withMaySkipOutputDuplicates());\n+            }\n+\n+            Optional<PlanNode> rewrittenLeft = node.getLeft().accept(this, null);\n+            Optional<PlanNode> rewrittenRight = node.getRight().accept(this, null);\n+\n+            if (node.isMaySkipOutputDuplicates() && rewrittenLeft.isEmpty() && rewrittenRight.isEmpty()) {\n+                return Optional.empty();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMwNDMzNA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r557304334", "bodyText": "It is preserved. If it's already marked as maySkipOutputDuplicates and left and right children did not change, we need to return empty to prevent rule from looping forever. Added comment", "author": "sopel39", "createdAt": "2021-01-14T10:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkwODM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxMTAxMA==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r556911010", "bodyText": "maybe call this matching?", "author": "martint", "createdAt": "2021-01-13T22:29:08Z", "path": "core/trino-main/src/test/java/io/trino/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -844,6 +844,28 @@ MatchResult detailMatches(PlanNode node, StatsProvider stats, Session session, M\n         return match(newAliases.build());\n     }\n \n+    public <T extends PlanNode> PlanMatchPattern with(Class<T> clazz, Predicate<T> predicate)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMyMDMyMw==", "url": "https://github.com/trinodb/trino/pull/5981#discussion_r557320323", "bodyText": "It's simplification of with method below that accepts full Matcher. Also withXXX seems to be convention in this class.", "author": "sopel39", "createdAt": "2021-01-14T11:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxMTAxMA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "da74bbe588ceaaf6ca2dcb2738ad2115c9038223", "url": "https://github.com/trinodb/trino/commit/da74bbe588ceaaf6ca2dcb2738ad2115c9038223", "message": "Optimize execution for joins below empty aggregation\n\nFor empty aggregations duplicate input rows can be skipped.\nUpstream joins can take advantage of this fact and skip producing\nof duplicate output rows.", "committedDate": "2021-01-14T12:24:27Z", "type": "commit"}, {"oid": "da74bbe588ceaaf6ca2dcb2738ad2115c9038223", "url": "https://github.com/trinodb/trino/commit/da74bbe588ceaaf6ca2dcb2738ad2115c9038223", "message": "Optimize execution for joins below empty aggregation\n\nFor empty aggregations duplicate input rows can be skipped.\nUpstream joins can take advantage of this fact and skip producing\nof duplicate output rows.", "committedDate": "2021-01-14T12:24:27Z", "type": "forcePushed"}]}