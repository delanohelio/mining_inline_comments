{"pr_number": 3783, "pr_title": "Implement parametric timestamp type", "pr_createdAt": "2020-05-19T05:13:38Z", "pr_url": "https://github.com/trinodb/trino/pull/3783", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTQ4Ng==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432879486", "bodyText": "This is a possibly backwards incompatible change, so make sure to add this to the release notes.", "author": "dain", "createdAt": "2020-05-30T19:08:22Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/DateTimeFunctions.java", "diffHunk": "@@ -205,22 +205,24 @@ public static double toUnixTimeFromTimestampWithTimeZone(@SqlType(StandardTypes.\n     }\n \n     @ScalarFunction(\"to_iso8601\")\n-    @SqlType(\"varchar(35)\")\n-    // YYYY-MM-DDTHH:MM:SS.mmm+HH:MM is a standard notation, and it requires 29 characters.\n-    // However extended notation with format \u00b1(Y)+-MM-DDTHH:MM:SS.mmm+HH:MM is also acceptable and as\n-    // the maximum year represented by 64bits timestamp is ~584944387 it may require up to 35 characters.\n+    @SqlType(\"varchar(29)\")\n+    // YYYY-MM-DDTHH:MM:SS.mmm is a standard notation, and it requires 23 characters.\n+    // However extended notation with format \u00b1(Y)+-MM-DDTHH:MM:SS.mmm is also acceptable and as\n+    // the maximum year represented by 64bits timestamp is ~584944387 it may require up to 29 characters.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNDc3Nw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432904777", "bodyText": "It's a tighter result which is coercible to the previous type, so it shouldn't break any existing usages.", "author": "martint", "createdAt": "2020-05-31T03:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDYyNA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432880624", "bodyText": "add\n        if (entryPositionCount != 0) {\n            throw new IllegalStateException(\"Current entry must be closed before a null can be written\");\n        }", "author": "dain", "createdAt": "2020-05-30T19:27:21Z", "path": "presto-spi/src/main/java/io/prestosql/spi/block/Int96ArrayBlockBuilder.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.block;\n+\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Arrays;\n+import java.util.function.BiConsumer;\n+\n+import static io.airlift.slice.SizeOf.SIZE_OF_LONG;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static io.prestosql.spi.block.BlockUtil.calculateBlockResetSize;\n+import static io.prestosql.spi.block.BlockUtil.checkArrayRange;\n+import static io.prestosql.spi.block.BlockUtil.checkValidRegion;\n+import static io.prestosql.spi.block.BlockUtil.compactArray;\n+import static io.prestosql.spi.block.BlockUtil.countUsedPositions;\n+import static io.prestosql.spi.block.Int96ArrayBlock.INT96_BYTES;\n+import static java.lang.Math.max;\n+\n+public class Int96ArrayBlockBuilder\n+        implements BlockBuilder\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(Int96ArrayBlockBuilder.class).instanceSize();\n+    private static final Block NULL_VALUE_BLOCK = new Int96ArrayBlock(0, 1, new boolean[] {true}, new long[1], new int[1]);\n+\n+    @Nullable\n+    private final BlockBuilderStatus blockBuilderStatus;\n+    private boolean initialized;\n+    private final int initialEntryCount;\n+\n+    private int positionCount;\n+    private boolean hasNullValue;\n+    private boolean hasNonNullValue;\n+\n+    // it is assumed that these arrays are the same length\n+    private boolean[] valueIsNull = new boolean[0];\n+    private long[] high = new long[0];\n+    private int[] low = new int[0];\n+\n+    private long retainedSizeInBytes;\n+\n+    private int entryPositionCount;\n+\n+    public Int96ArrayBlockBuilder(@Nullable BlockBuilderStatus blockBuilderStatus, int expectedEntries)\n+    {\n+        this.blockBuilderStatus = blockBuilderStatus;\n+        this.initialEntryCount = max(expectedEntries, 1);\n+\n+        updateDataSize();\n+    }\n+\n+    @Override\n+    public BlockBuilder writeLong(long high)\n+    {\n+        if (entryPositionCount != 0) {\n+            throw new IllegalArgumentException(\"long can only be written at the beginning of the entry\");\n+        }\n+\n+        if (valueIsNull.length <= positionCount) {\n+            growCapacity();\n+        }\n+\n+        this.high[positionCount] = high;\n+        hasNonNullValue = true;\n+        entryPositionCount++;\n+        return this;\n+    }\n+\n+    @Override\n+    public BlockBuilder writeInt(int low)\n+    {\n+        if (entryPositionCount != 1) {\n+            throw new IllegalArgumentException(\"int can only be written at the end of the entry\");\n+        }\n+\n+        if (valueIsNull.length <= positionCount) {\n+            growCapacity();\n+        }\n+\n+        this.low[positionCount] = low;\n+        hasNonNullValue = true;\n+        entryPositionCount++;\n+        return this;\n+    }\n+\n+    @Override\n+    public BlockBuilder closeEntry()\n+    {\n+        if (entryPositionCount != 2) {\n+            throw new IllegalStateException(\"Expected entry size to be exactly \" + INT96_BYTES + \" bytes but was \" + (entryPositionCount * SIZE_OF_LONG));\n+        }\n+\n+        positionCount++;\n+        entryPositionCount = 0;\n+        if (blockBuilderStatus != null) {\n+            blockBuilderStatus.addBytes(Byte.BYTES + INT96_BYTES);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public BlockBuilder appendNull()\n+    {\n+        if (valueIsNull.length <= positionCount) {\n+            growCapacity();\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzE0MQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432883141", "bodyText": "Don't forget to add this in the release notes", "author": "dain", "createdAt": "2020-05-30T20:07:26Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveIntegrationSmokeTest.java", "diffHunk": "@@ -5109,12 +5109,12 @@ public void testCollectColumnStatisticsOnCreateTable()\n                 \"  VALUES \" +\n                 \"    (null, null, null, null, null, null, 'p1'), \" +\n                 \"    (null, null, null, null, null, null, 'p1'), \" +\n-                \"    (true, BIGINT '1', DOUBLE '2.2', TIMESTAMP '2012-08-08 01:00', CAST('abc1' AS VARCHAR), CAST('bcd1' AS VARBINARY), 'p1'),\" +\n-                \"    (false, BIGINT '0', DOUBLE '1.2', TIMESTAMP '2012-08-08 00:00', CAST('abc2' AS VARCHAR), CAST('bcd2' AS VARBINARY), 'p1'),\" +\n+                \"    (true, BIGINT '1', DOUBLE '2.2', TIMESTAMP '2012-08-08 01:00:00.000', CAST('abc1' AS VARCHAR), CAST('bcd1' AS VARBINARY), 'p1'),\" +", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mzk4Mw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432883983", "bodyText": "What if I add 1000 milliseconds?", "author": "dain", "createdAt": "2020-05-30T20:17:01Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/DateAdd.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.operator.scalar.DateTimeFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.StandardTypes;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.type.Timestamps.scaleEpochMicrosToMillis;\n+import static io.prestosql.type.Timestamps.scaleEpochMillisToMicros;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.Math.floorMod;\n+import static java.lang.Math.toIntExact;\n+\n+@Description(\"Add the specified amount of time to the given timestamp\")\n+@ScalarFunction(\"date_add\")\n+public class DateAdd\n+{\n+    private static final Slice MILLISECOND = Slices.utf8Slice(\"millisecond\");\n+\n+    private DateAdd()\n+    {\n+    }\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"timestamp(p)\")\n+    public static long add(\n+            @LiteralParameter(\"p\") long precision,\n+            ConnectorSession session,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"timestamp(p)\") long timestamp)\n+    {\n+        if (precision < 3 && unit.equals(MILLISECOND)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNDc5MQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432904791", "bodyText": "Yup, that's a bug. What I really need to do is truncate the result to the expected precision.", "author": "martint", "createdAt": "2020-05-31T03:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mzk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDIzMQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432884231", "bodyText": "you might want a named function for this", "author": "dain", "createdAt": "2020-05-30T20:18:42Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/DateAdd.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.operator.scalar.DateTimeFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.StandardTypes;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.type.Timestamps.scaleEpochMicrosToMillis;\n+import static io.prestosql.type.Timestamps.scaleEpochMillisToMicros;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.Math.floorMod;\n+import static java.lang.Math.toIntExact;\n+\n+@Description(\"Add the specified amount of time to the given timestamp\")\n+@ScalarFunction(\"date_add\")\n+public class DateAdd\n+{\n+    private static final Slice MILLISECOND = Slices.utf8Slice(\"millisecond\");\n+\n+    private DateAdd()\n+    {\n+    }\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"timestamp(p)\")\n+    public static long add(\n+            @LiteralParameter(\"p\") long precision,\n+            ConnectorSession session,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"timestamp(p)\") long timestamp)\n+    {\n+        if (precision < 3 && unit.equals(MILLISECOND)) {\n+            // if precision is less than 3, adding milliseconds not observable, so skip it\n+            return timestamp;\n+        }\n+\n+        long epochMillis = timestamp;\n+        long microFraction = 0;\n+        if (precision > 3) {\n+            epochMillis = scaleEpochMicrosToMillis(timestamp);\n+            microFraction = floorMod(timestamp, 1_000_000);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDM4Nw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432884387", "bodyText": "Maybe add a named function from this", "author": "dain", "createdAt": "2020-05-30T20:19:59Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/DateAdd.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.prestosql.operator.scalar.DateTimeFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.Description;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.StandardTypes;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.type.Timestamps.scaleEpochMicrosToMillis;\n+import static io.prestosql.type.Timestamps.scaleEpochMillisToMicros;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.Math.floorMod;\n+import static java.lang.Math.toIntExact;\n+\n+@Description(\"Add the specified amount of time to the given timestamp\")\n+@ScalarFunction(\"date_add\")\n+public class DateAdd\n+{\n+    private static final Slice MILLISECOND = Slices.utf8Slice(\"millisecond\");\n+\n+    private DateAdd()\n+    {\n+    }\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(\"timestamp(p)\")\n+    public static long add(\n+            @LiteralParameter(\"p\") long precision,\n+            ConnectorSession session,\n+            @SqlType(\"varchar(x)\") Slice unit,\n+            @SqlType(StandardTypes.BIGINT) long value,\n+            @SqlType(\"timestamp(p)\") long timestamp)\n+    {\n+        if (precision < 3 && unit.equals(MILLISECOND)) {\n+            // if precision is less than 3, adding milliseconds not observable, so skip it\n+            return timestamp;\n+        }\n+\n+        long epochMillis = timestamp;\n+        long microFraction = 0;\n+        if (precision > 3) {\n+            epochMillis = scaleEpochMicrosToMillis(timestamp);\n+            microFraction = floorMod(timestamp, 1_000_000);\n+        }\n+\n+        long result;\n+        if (session.isLegacyTimestamp()) {\n+            result = DateTimeFunctions.getTimestampField(getChronology(session.getTimeZoneKey()), unit).add(epochMillis, toIntExact(value));\n+        }\n+        else {\n+            result = DateTimeFunctions.getTimestampField(ISOChronology.getInstanceUTC(), unit).add(epochMillis, toIntExact(value));\n+        }\n+\n+        if (precision > 3) {\n+            return scaleEpochMillisToMicros(result) + microFraction;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NTAwNQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432885005", "bodyText": "We should add this to the documentation", "author": "dain", "createdAt": "2020-05-30T20:28:53Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/DateFormat.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.StandardTypes;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.operator.scalar.DateTimeFunctions.dateFormat;\n+import static io.prestosql.type.Timestamps.scaleEpochMicrosToMillis;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+\n+@ScalarFunction\n+public class DateFormat\n+{\n+    private DateFormat() {}\n+\n+    @LiteralParameters({\"x\", \"p\"})\n+    @SqlType(StandardTypes.VARCHAR)\n+    public static Slice format(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"timestamp(p)\") long timestamp, @SqlType(\"varchar(x)\") Slice formatString)\n+    {\n+        // TODO: currently, date formatting only supports up to millis, so anything below that granularity gets truncated", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NjMxNg==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432976316", "bodyText": "It's already documented. I guess it comes from MySQL's documentation:\n\n.. [#f] Timestamp is truncated to milliseconds.", "author": "martint", "createdAt": "2020-05-31T19:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NTQ5OQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432885499", "bodyText": "@Description(\"Formats the given timestamp by the given format\")", "author": "dain", "createdAt": "2020-05-30T20:37:28Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/DateFormat.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.StandardTypes;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.operator.scalar.DateTimeFunctions.dateFormat;\n+import static io.prestosql.type.Timestamps.scaleEpochMicrosToMillis;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+\n+@ScalarFunction", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NjEwNQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432886105", "bodyText": "Maybe add a utility for this", "author": "dain", "createdAt": "2020-05-30T20:47:15Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/LocalTimestamp.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+\n+import static io.prestosql.type.Timestamps.scaleEpochMicrosToMillis;\n+import static io.prestosql.type.Timestamps.truncate;\n+import static java.time.temporal.ChronoField.MICRO_OF_SECOND;\n+\n+@ScalarFunction(value = \"$localtimestamp\", hidden = true)\n+public final class LocalTimestamp\n+{\n+    private LocalTimestamp() {}\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(\"timestamp(p)\")\n+    public static long localTimestamp(\n+            @LiteralParameter(\"p\") long precision,\n+            ConnectorSession session,\n+            @SqlNullable @SqlType(\"timestamp(p)\") Long dummy) // need a dummy value since the type inferencer can't bind type arguments exclusively from return type\n+    {\n+        Instant start = session.getStart();\n+\n+        if (!session.isLegacyTimestamp()) {\n+            start = LocalDateTime.ofInstant(session.getStart(), ZoneId.of(session.getTimeZoneKey().getId()))\n+                    .toInstant(ZoneOffset.UTC);\n+        }\n+\n+        long epochMicros = start.getEpochSecond() * 1_000_000 + start.getLong(MICRO_OF_SECOND);\n+        epochMicros = truncate(epochMicros, (int) (6 - precision));\n+\n+        if (precision <= 3) {\n+            epochMicros = scaleEpochMicrosToMillis(epochMicros);\n+        }\n+\n+        return epochMicros;\n+    }\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(\"timestamp(p)\")\n+    public static LongTimestamp localTimestamp(\n+            @LiteralParameter(\"p\") long precision,\n+            ConnectorSession session,\n+            @SqlNullable @SqlType(\"timestamp(p)\") LongTimestamp dummy) // need a dummy value since the type inferencer can't bind type arguments exclusively from return type\n+    {\n+        Instant start = session.getStart();\n+\n+        if (!session.isLegacyTimestamp()) {\n+            start = LocalDateTime.ofInstant(session.getStart(), ZoneId.of(session.getTimeZoneKey().getId()))\n+                    .toInstant(ZoneOffset.UTC);\n+        }\n+\n+        return new LongTimestamp(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NjI4Mw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432886283", "bodyText": "multiply exact?", "author": "dain", "createdAt": "2020-05-30T20:50:04Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/SequenceIntervalDayToSecond.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.LongTimestampType;\n+import io.prestosql.spi.type.ShortTimestampType;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.operator.scalar.SequenceFunction.checkMaxEntry;\n+import static io.prestosql.operator.scalar.SequenceFunction.checkValidStep;\n+import static io.prestosql.spi.type.TimestampType.MAX_SHORT_PRECISION;\n+import static java.lang.Math.toIntExact;\n+\n+@ScalarFunction(\"sequence\")\n+public class SequenceIntervalDayToSecond\n+{\n+    // We need these because it's currently not possible to inject the fully-bound type into the methods that require them below\n+    private static final ShortTimestampType SHORT_TYPE = new ShortTimestampType(0);\n+    private static final LongTimestampType LONG_TYPE = new LongTimestampType(MAX_SHORT_PRECISION + 1);\n+\n+    private SequenceIntervalDayToSecond() {}\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(\"array(timestamp(p))\")\n+    public static Block sequence(\n+            @LiteralParameter(\"p\") long precision,\n+            @SqlType(\"timestamp(p)\") long start,\n+            @SqlType(\"timestamp(p)\") long stop,\n+            @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long step)\n+    {\n+        if (precision > 3) {\n+            // scale to micros\n+            step *= 1000;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NjkwNA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432886904", "bodyText": "Consider adding a special method that takes long and int.", "author": "dain", "createdAt": "2020-05-30T20:59:54Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/SequenceIntervalDayToSecond.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.LongTimestampType;\n+import io.prestosql.spi.type.ShortTimestampType;\n+import io.prestosql.spi.type.StandardTypes;\n+\n+import static io.prestosql.operator.scalar.SequenceFunction.checkMaxEntry;\n+import static io.prestosql.operator.scalar.SequenceFunction.checkValidStep;\n+import static io.prestosql.spi.type.TimestampType.MAX_SHORT_PRECISION;\n+import static java.lang.Math.toIntExact;\n+\n+@ScalarFunction(\"sequence\")\n+public class SequenceIntervalDayToSecond\n+{\n+    // We need these because it's currently not possible to inject the fully-bound type into the methods that require them below\n+    private static final ShortTimestampType SHORT_TYPE = new ShortTimestampType(0);\n+    private static final LongTimestampType LONG_TYPE = new LongTimestampType(MAX_SHORT_PRECISION + 1);\n+\n+    private SequenceIntervalDayToSecond() {}\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(\"array(timestamp(p))\")\n+    public static Block sequence(\n+            @LiteralParameter(\"p\") long precision,\n+            @SqlType(\"timestamp(p)\") long start,\n+            @SqlType(\"timestamp(p)\") long stop,\n+            @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long step)\n+    {\n+        if (precision > 3) {\n+            // scale to micros\n+            step *= 1000;\n+        }\n+\n+        checkValidStep(start, stop, step);\n+\n+        int length = toIntExact((stop - start) / step + 1L);\n+        checkMaxEntry(length);\n+\n+        BlockBuilder blockBuilder = SHORT_TYPE.createBlockBuilder(null, length);\n+        for (long i = 0, value = start; i < length; ++i, value += step) {\n+            SHORT_TYPE.writeLong(blockBuilder, value);\n+        }\n+        return blockBuilder.build();\n+    }\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(\"array(timestamp(p))\")\n+    public static Block sequence(\n+            @SqlType(\"timestamp(p)\") LongTimestamp start,\n+            @SqlType(\"timestamp(p)\") LongTimestamp stop,\n+            @SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long step)\n+    {\n+        step *= 1000; // scale to micros\n+\n+        long startMicros = start.getEpochMicros();\n+        long stopMicros = stop.getEpochMicros();\n+        checkValidStep(startMicros, stopMicros, step);\n+\n+        int length = toIntExact((stopMicros - startMicros) / step + 1L);\n+        checkMaxEntry(length);\n+\n+        BlockBuilder blockBuilder = LONG_TYPE.createBlockBuilder(null, length);\n+        for (long i = 0, value = startMicros; i < length; ++i, value += step) {\n+            LONG_TYPE.writeObject(blockBuilder, new LongTimestamp(value, start.getFraction()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NzA4NQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432887085", "bodyText": "s/WIT/WITH", "author": "dain", "createdAt": "2020-05-30T21:02:07Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimeWithTimezoneToTimestampCast.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.StandardTypes;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.temporal.ChronoField;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static io.prestosql.type.TimeWithTimeZoneOperators.REFERENCE_TIMESTAMP_UTC;\n+import static io.prestosql.type.Timestamps.scaleEpochMillisToMicros;\n+import static io.prestosql.type.Timestamps.truncate;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+\n+@ScalarOperator(CAST)\n+public final class TimeWithTimezoneToTimestampCast\n+{\n+    private TimeWithTimezoneToTimestampCast() {}\n+\n+    @LiteralParameters(\"p\")\n+    @SqlType(\"timestamp(p)\")\n+    public static long cast(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(StandardTypes.TIME_WITH_TIME_ZONE) long time)\n+    {\n+        long epochMillis;\n+        if (session.isLegacyTimestamp()) {\n+            epochMillis = unpackMillisUtc(time);\n+        }\n+        else {\n+            // This is hack that we need to use as the timezone interpretation depends on date (not only on time)\n+            // TODO remove REFERENCE_TIMESTAMP_UTC when removing support for political time zones in TIME WIT TIME ZONE", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5MzUwNQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432893505", "bodyText": "We should decide on this before pushing", "author": "dain", "createdAt": "2020-05-30T22:53:29Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampToTimestampCast.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+\n+import static io.prestosql.spi.function.OperatorType.CAST;\n+import static io.prestosql.spi.type.TimestampType.MAX_PRECISION;\n+import static io.prestosql.type.Timestamps.scaleEpochMicrosToMillis;\n+import static io.prestosql.type.Timestamps.scaleEpochMillisToMicros;\n+import static io.prestosql.type.Timestamps.truncate;\n+\n+@ScalarOperator(CAST)\n+public final class TimestampToTimestampCast\n+{\n+    private TimestampToTimestampCast() {}\n+\n+    @LiteralParameters({\"sourcePrecision\", \"targetPrecision\"})\n+    @SqlType(\"timestamp(targetPrecision)\")\n+    public static long shortToShort(\n+            @LiteralParameter(\"sourcePrecision\") long sourcePrecision,\n+            @LiteralParameter(\"targetPrecision\") long targetPrecision,\n+            @SqlType(\"timestamp(sourcePrecision)\") long value)\n+    {\n+        long micros = value;\n+        if (sourcePrecision <= 3) {\n+            micros = scaleEpochMillisToMicros(micros);\n+        }\n+\n+        if (sourcePrecision <= targetPrecision) {\n+            if (targetPrecision <= 3) {\n+                return scaleEpochMicrosToMillis(micros);\n+            }\n+\n+            return micros;\n+        }\n+\n+        long factor = (long) Math.pow(10, 6 - targetPrecision);\n+        micros = (micros / factor) * factor; // truncate -- TODO: should we round?", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNTMwNA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432905304", "bodyText": "I'm leaning towards truncation. The math is much simpler than rounding, especially when dealing with negative epoch values. Thoughts?", "author": "martint", "createdAt": "2020-05-31T03:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5MzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5Mzc4MA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432893780", "bodyText": "maybe move the formula to a constant", "author": "dain", "createdAt": "2020-05-30T22:56:57Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/ToIso8601.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarFunction;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.type.Constraint;\n+\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+\n+import static io.airlift.slice.Slices.utf8Slice;\n+import static io.prestosql.type.Timestamps.formatTimestamp;\n+import static io.prestosql.type.Timestamps.scaleEpochMillisToMicros;\n+\n+@ScalarFunction(\"to_iso8601\")\n+public final class ToIso8601\n+{\n+    public static final ZoneId ZULU = ZoneId.of(\"Z\");\n+    private static final DateTimeFormatter ISO8601_FORMATTER = DateTimeFormatter.ofPattern(\"uuuu-MM-dd'T'HH:mm:ss\");\n+\n+    private ToIso8601() {}\n+\n+    @LiteralParameters({\"p\", \"n\"})\n+    @SqlType(\"varchar(n)\")\n+    // 1 digit for year sign\n+    // 6 digits for year -- TODO: we should constrain this further. A 6-digit year seems useless\n+    // 15 digits for -MM-DDTHH:MM:SS\n+    // min(p, 1) for the fractional second period (i.e., no period if p == 0)\n+    // p for the fractional digits\n+    @Constraint(variable = \"n\", expression = \"1 + 6 + 15 + min(p, 1) + p\")\n+    public static Slice toIso8601(@LiteralParameter(\"p\") long precision, ConnectorSession session, @SqlType(\"timestamp(p)\") long timestamp)\n+    {\n+        long epochMicros = timestamp;\n+        if (precision <= 3) {\n+            epochMicros = scaleEpochMillisToMicros(timestamp);\n+        }\n+\n+        ZoneId zoneId = ZULU;\n+        if (session.isLegacyTimestamp()) {\n+            zoneId = ZoneId.of(session.getTimeZoneKey().getId());\n+        }\n+\n+        return utf8Slice(formatTimestamp((int) precision, epochMicros, 0, zoneId, ISO8601_FORMATTER));\n+    }\n+\n+    @LiteralParameters({\"p\", \"n\"})\n+    @SqlType(\"varchar(n)\")\n+    // 1 digit for year sign\n+    // 6 digits for year -- TODO: we should constrain this further. A 6-digit year seems useless\n+    // 15 digits for -MM-DDTHH:MM:SS\n+    // min(p, 1) for the fractional second period (i.e., no period if p == 0)\n+    // p for the fractional digits\n+    @Constraint(variable = \"n\", expression = \"1 + 6 + 15 + min(p, 1) + p\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NDg2OA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432894868", "bodyText": "Why not use the lookup table", "author": "dain", "createdAt": "2020-05-30T23:17:36Z", "path": "presto-main/src/main/java/io/prestosql/type/Timestamps.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.type;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import io.prestosql.spi.type.TimestampType;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static io.prestosql.spi.type.LongTimestamp.fromEpochSecondsAndFraction;\n+import static io.prestosql.spi.type.TimestampType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimestampType.MAX_SHORT_PRECISION;\n+import static java.lang.Math.floorDiv;\n+import static java.lang.Math.floorMod;\n+import static java.lang.String.format;\n+\n+public final class Timestamps\n+{\n+    public static final ZoneId ZULU = ZoneId.of(\"Z\");\n+    public static final Pattern DATETIME_PATTERN = Pattern.compile(\"\" +\n+            \"(?<year>\\\\d\\\\d\\\\d\\\\d)-(?<month>\\\\d{1,2})-(?<day>\\\\d{1,2})\" +\n+            \"(?: (?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:.(?<fraction>\\\\d+))?)?)?\" +\n+            \"\\\\s*(?<timezone>.+)?\");\n+    private static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern(\"uuuu-MM-dd HH:mm:ss\");\n+\n+    private static final long[] POWERS_OF_TEN = {\n+            1L,\n+            10L,\n+            100L,\n+            1000L,\n+            10_000L,\n+            100_000L,\n+            1_000_000L,\n+            10_000_000L,\n+            100_000_000L,\n+            1_000_000_000L,\n+            10_000_000_000L,\n+            100_000_000_000L,\n+            1000_000_000_000L\n+    };\n+\n+    private Timestamps() {}\n+\n+    public static long scaleEpochMicrosToMillis(long value)\n+    {\n+        return floorDiv(value, 1000);\n+    }\n+\n+    public static long scaleEpochMillisToMicros(long epochMillis)\n+    {\n+        return epochMillis * 1000;\n+    }\n+\n+    public static long truncate(long value, int magnitude)\n+    {\n+        long factor = (long) Math.pow(10, magnitude);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNDgzOA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432904838", "bodyText": "Leftover from before I had that lookup table. I'll update", "author": "martint", "createdAt": "2020-05-31T03:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NDg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NzQwMQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432897401", "bodyText": "Did you mean to leave this in?  It seems like a good verification to have", "author": "dain", "createdAt": "2020-05-31T00:12:00Z", "path": "presto-main/src/test/java/io/prestosql/metadata/TestFunctionRegistry.java", "diffHunk": "@@ -86,9 +86,15 @@ public void testExactMatchBeforeCoercion()\n             if (function.getSignature().getArgumentTypes().stream().anyMatch(TypeSignature::isCalculated)) {\n                 continue;\n             }\n-            List<Type> argumentTypes = function.getSignature().getArgumentTypes().stream()\n-                    .map(metadata::getType)\n-                    .collect(toImmutableList());\n+            List<Type> argumentTypes = null;\n+            try {\n+                argumentTypes = function.getSignature().getArgumentTypes().stream()\n+                        .map(metadata::getType)\n+                        .collect(toImmutableList());\n+            }\n+            catch (Exception e) {\n+                e.printStackTrace();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNDg2Nw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432904867", "bodyText": "No, leftover from some debugging I was doing.", "author": "martint", "createdAt": "2020-05-31T03:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5NzQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5ODA1MQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432898051", "bodyText": "make sure precision is positive?", "author": "dain", "createdAt": "2020-05-31T00:25:44Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TimestampType.java", "diffHunk": "@@ -13,49 +13,61 @@\n  */\n package io.prestosql.spi.type;\n \n-import io.prestosql.spi.block.Block;\n-import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.PrestoException;\n+\n+import static io.prestosql.spi.StandardErrorCode.NUMERIC_VALUE_OUT_OF_RANGE;\n+import static java.lang.String.format;\n \n /**\n  * A timestamp is stored as milliseconds from 1970-01-01T00:00:00 UTC and is to be interpreted as date-time in UTC.\n  * In legacy timestamp semantics, timestamp is stored as milliseconds from 1970-01-01T00:00:00 UTC and is to be\n  * interpreted in session time zone.\n  */\n-public final class TimestampType\n-        extends AbstractLongType\n+public abstract class TimestampType\n+        extends AbstractType\n+        implements FixedWidthType\n {\n-    public static final TimestampType TIMESTAMP = new TimestampType();\n+    public static final int MAX_PRECISION = 12;\n+\n+    public static final int MAX_SHORT_PRECISION = 6;\n+    private static final int DEFAULT_PRECISION = 3; // TODO: should be 6 per SQL spec\n+\n+    public static final TimestampType TIMESTAMP = createTimestampType(DEFAULT_PRECISION);\n+\n+    private final int precision;\n \n-    private TimestampType()\n+    public static TimestampType createTimestampType(int precision)\n     {\n-        super(new TypeSignature(StandardTypes.TIMESTAMP));\n+        if (precision <= MAX_SHORT_PRECISION) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5OTIxOQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432899219", "bodyText": "I'm surprised you need this", "author": "dain", "createdAt": "2020-05-31T00:51:13Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/ShortTimestampType.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.airlift.slice.Slice;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.LongArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+\n+import static java.lang.Long.rotateLeft;\n+\n+/**\n+ * Encodes timestamps up to p = 6.\n+ *\n+ * For 0 <= p <= 3, the value is encoded as milliseconds from the 1970-01-01 00:00:00 epoch.\n+ * For 3 < p <= 6, the value is encoded as microseconds from the 1970-01-01 00:00:00 epoch.\n+ */\n+public class ShortTimestampType\n+        extends TimestampType\n+{\n+    public ShortTimestampType(int precision)\n+    {\n+        super(precision, long.class);\n+    }\n+\n+    @Override\n+    public final int getFixedSize()\n+    {\n+        return Long.BYTES;\n+    }\n+\n+    @Override\n+    public final long getLong(Block block, int position)\n+    {\n+        return block.getLong(position, 0);\n+    }\n+\n+    @Override\n+    public final Slice getSlice(Block block, int position)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNDkyMQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432904921", "bodyText": "Probably not needed. I copied from AbstractLongBlock when I had to split the implementation for short vs long.", "author": "martint", "createdAt": "2020-05-31T03:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg5OTIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMDI0NA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432900244", "bodyText": "Long + Int?", "author": "dain", "createdAt": "2020-05-31T01:13:29Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimestampType.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.Int96ArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+\n+import static io.airlift.slice.SizeOf.SIZE_OF_LONG;\n+import static io.prestosql.spi.type.UnscaledDecimal128Arithmetic.compare;\n+\n+public class LongTimestampType\n+        extends TimestampType\n+{\n+    public LongTimestampType(int precision)\n+    {\n+        super(precision, LongTimestamp.class);\n+    }\n+\n+    @Override\n+    public int getFixedSize()\n+    {\n+        return Long.BYTES + Long.BYTES;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMDQ0OA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432900448", "bodyText": "I would not use the UnscaledDecimal128Arithmetic code for this.  Instead I would do something like\nint value = Long.compare(leftHigh, rightHigh);\nif (value != 0) {\n    return value;\n}\nreturn Int.compareUnsigned(leftLow, rightLow);", "author": "dain", "createdAt": "2020-05-31T01:19:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimestampType.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.Int96ArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+\n+import static io.airlift.slice.SizeOf.SIZE_OF_LONG;\n+import static io.prestosql.spi.type.UnscaledDecimal128Arithmetic.compare;\n+\n+public class LongTimestampType\n+        extends TimestampType\n+{\n+    public LongTimestampType(int precision)\n+    {\n+        super(precision, LongTimestamp.class);\n+    }\n+\n+    @Override\n+    public int getFixedSize()\n+    {\n+        return Long.BYTES + Long.BYTES;\n+    }\n+\n+    @Override\n+    public BlockBuilder createBlockBuilder(BlockBuilderStatus blockBuilderStatus, int expectedEntries, int expectedBytesPerEntry)\n+    {\n+        int maxBlockSizeInBytes;\n+        if (blockBuilderStatus == null) {\n+            maxBlockSizeInBytes = PageBuilderStatus.DEFAULT_MAX_PAGE_SIZE_IN_BYTES;\n+        }\n+        else {\n+            maxBlockSizeInBytes = blockBuilderStatus.getMaxPageSizeInBytes();\n+        }\n+        return new Int96ArrayBlockBuilder(\n+                blockBuilderStatus,\n+                Math.min(expectedEntries, maxBlockSizeInBytes / getFixedSize()));\n+    }\n+\n+    @Override\n+    public BlockBuilder createBlockBuilder(BlockBuilderStatus blockBuilderStatus, int expectedEntries)\n+    {\n+        return createBlockBuilder(blockBuilderStatus, expectedEntries, getFixedSize());\n+    }\n+\n+    @Override\n+    public BlockBuilder createFixedSizeBlockBuilder(int positionCount)\n+    {\n+        return new Int96ArrayBlockBuilder(null, positionCount);\n+    }\n+\n+    @Override\n+    public boolean equalTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        return compareTo(leftBlock, leftPosition, rightBlock, rightPosition) == 0;\n+    }\n+\n+    @Override\n+    public int compareTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        long leftHigh = leftBlock.getLong(leftPosition, 0);\n+        int leftLow = leftBlock.getInt(leftPosition, SIZE_OF_LONG);\n+        long rightHigh = rightBlock.getLong(rightPosition, 0);\n+        int rightLow = rightBlock.getInt(rightPosition, SIZE_OF_LONG);\n+        return compare(leftLow, leftHigh, rightLow, rightHigh);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNDk5OA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432904998", "bodyText": "Good catch. That was not intended. I originally copied some methods from LongDecimalType and forgot to update.", "author": "martint", "createdAt": "2020-05-31T03:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMDQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMDQ3OA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432900478", "bodyText": "maybe add a helper method for getLow and getHigh", "author": "dain", "createdAt": "2020-05-31T01:19:50Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimestampType.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.Int96ArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+\n+import static io.airlift.slice.SizeOf.SIZE_OF_LONG;\n+import static io.prestosql.spi.type.UnscaledDecimal128Arithmetic.compare;\n+\n+public class LongTimestampType\n+        extends TimestampType\n+{\n+    public LongTimestampType(int precision)\n+    {\n+        super(precision, LongTimestamp.class);\n+    }\n+\n+    @Override\n+    public int getFixedSize()\n+    {\n+        return Long.BYTES + Long.BYTES;\n+    }\n+\n+    @Override\n+    public BlockBuilder createBlockBuilder(BlockBuilderStatus blockBuilderStatus, int expectedEntries, int expectedBytesPerEntry)\n+    {\n+        int maxBlockSizeInBytes;\n+        if (blockBuilderStatus == null) {\n+            maxBlockSizeInBytes = PageBuilderStatus.DEFAULT_MAX_PAGE_SIZE_IN_BYTES;\n+        }\n+        else {\n+            maxBlockSizeInBytes = blockBuilderStatus.getMaxPageSizeInBytes();\n+        }\n+        return new Int96ArrayBlockBuilder(\n+                blockBuilderStatus,\n+                Math.min(expectedEntries, maxBlockSizeInBytes / getFixedSize()));\n+    }\n+\n+    @Override\n+    public BlockBuilder createBlockBuilder(BlockBuilderStatus blockBuilderStatus, int expectedEntries)\n+    {\n+        return createBlockBuilder(blockBuilderStatus, expectedEntries, getFixedSize());\n+    }\n+\n+    @Override\n+    public BlockBuilder createFixedSizeBlockBuilder(int positionCount)\n+    {\n+        return new Int96ArrayBlockBuilder(null, positionCount);\n+    }\n+\n+    @Override\n+    public boolean equalTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        return compareTo(leftBlock, leftPosition, rightBlock, rightPosition) == 0;\n+    }\n+\n+    @Override\n+    public int compareTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n+    {\n+        long leftHigh = leftBlock.getLong(leftPosition, 0);\n+        int leftLow = leftBlock.getInt(leftPosition, SIZE_OF_LONG);\n+        long rightHigh = rightBlock.getLong(rightPosition, 0);\n+        int rightLow = rightBlock.getInt(rightPosition, SIZE_OF_LONG);\n+        return compare(leftLow, leftHigh, rightLow, rightHigh);\n+    }\n+\n+    @Override\n+    public long hash(Block block, int position)\n+    {\n+        long high = block.getLong(position, 0);\n+        long low = block.getInt(position, SIZE_OF_LONG);\n+        return hash(high, low);\n+    }\n+\n+    @Override\n+    public void appendTo(Block block, int position, BlockBuilder blockBuilder)\n+    {\n+        if (block.isNull(position)) {\n+            blockBuilder.appendNull();\n+        }\n+        else {\n+            blockBuilder.writeLong(block.getLong(position, 0));\n+            blockBuilder.writeInt(block.getInt(position, SIZE_OF_LONG));\n+            blockBuilder.closeEntry();\n+        }\n+    }\n+\n+    @Override\n+    public Object getObject(Block block, int position)\n+    {\n+        return new LongTimestamp(block.getLong(position, 0), block.getInt(position, SIZE_OF_LONG));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMDYxOA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432900618", "bodyText": "verify fraction is not > 1_000_000?", "author": "dain", "createdAt": "2020-05-31T01:22:36Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimestamp.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import java.util.Objects;\n+\n+public final class LongTimestamp\n+{\n+    private final long epochMicros;\n+    private final int fraction; // number of picoSeconds of the microsecond corresponding to epochMicros\n+\n+    public static LongTimestamp fromEpochSecondsAndFraction(long epochSecond, long fractionInPicos)\n+    {\n+        return new LongTimestamp(\n+                epochSecond * 1_000_000 + fractionInPicos / 1_000_000,\n+                (int) (fractionInPicos % 1_000_000));\n+    }\n+\n+    public LongTimestamp(long epochMicros, int fraction)\n+    {\n+        if (fraction < 0) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMTAxOA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432901018", "bodyText": "Maybe add a comment here.  I expect we will use this flag for timestamp and time with and without TZ", "author": "dain", "createdAt": "2020-05-31T01:31:22Z", "path": "presto-client/src/main/java/io/prestosql/client/ClientCapabilities.java", "diffHunk": "@@ -15,5 +15,6 @@\n \n public enum ClientCapabilities\n {\n-    PATH;\n+    PATH,\n+    PARAMETRIC_DATETIME;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMTUwNA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432901504", "bodyText": "I'm not sure how all clients work, but they might not expect the parametric timestamp in the returned type list of the results metadata. To address that you would change io.prestosql.server.protocol.Query#toClientTypeSignature", "author": "dain", "createdAt": "2020-05-31T01:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNTA1Nw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432905057", "bodyText": "That's a good question. In client type signature, they appear as parameters in a separate structure. I wonder whether clients validate that there are no parameters for timestamp or just match on the name and ignore the parameters if they are present.", "author": "martint", "createdAt": "2020-05-31T03:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxNTEwNg==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r433315106", "bodyText": "@electrum, any thoughts?", "author": "martint", "createdAt": "2020-06-01T15:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNDM5OA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r434634398", "bodyText": "I added a check for capabilities in toClientTypeSignature.", "author": "martint", "createdAt": "2020-06-03T15:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMTAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMTEzNw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432901137", "bodyText": "Maybe add a constant for that.", "author": "dain", "createdAt": "2020-05-31T01:34:39Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/RowIterable.java", "diffHunk": "@@ -74,9 +82,34 @@ private RowIterator(ConnectorSession session, List<Type> types, Page page)\n             for (int channel = 0; channel < page.getChannelCount(); channel++) {\n                 Type type = types.get(channel);\n                 Block block = page.getBlock(channel);\n-                values.add(type.getObjectValue(session, block, position));\n+\n+                Object value = type.getObjectValue(session, block, position);\n+\n+                if (value != null && type instanceof TimestampType) {\n+                    value = renderTimestamp((TimestampType) type, (SqlTimestamp) value);\n+                }\n+\n+                values.add(value);\n             }\n             return Collections.unmodifiableList(values);\n         }\n+\n+        private Object renderTimestamp(TimestampType type, SqlTimestamp timestamp)\n+        {\n+            ZoneId zoneId;\n+            if (session.isLegacyTimestamp()) {\n+                zoneId = ZoneId.of(session.getTimeZoneKey().getId());\n+            }\n+            else {\n+                zoneId = ZoneId.of(\"Z\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMTE1Ng==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432901156", "bodyText": "We should add ZoneID to DateTimeZoneIndex", "author": "dain", "createdAt": "2020-05-31T01:35:03Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/RowIterable.java", "diffHunk": "@@ -74,9 +82,34 @@ private RowIterator(ConnectorSession session, List<Type> types, Page page)\n             for (int channel = 0; channel < page.getChannelCount(); channel++) {\n                 Type type = types.get(channel);\n                 Block block = page.getBlock(channel);\n-                values.add(type.getObjectValue(session, block, position));\n+\n+                Object value = type.getObjectValue(session, block, position);\n+\n+                if (value != null && type instanceof TimestampType) {\n+                    value = renderTimestamp((TimestampType) type, (SqlTimestamp) value);\n+                }\n+\n+                values.add(value);\n             }\n             return Collections.unmodifiableList(values);\n         }\n+\n+        private Object renderTimestamp(TimestampType type, SqlTimestamp timestamp)\n+        {\n+            ZoneId zoneId;\n+            if (session.isLegacyTimestamp()) {\n+                zoneId = ZoneId.of(session.getTimeZoneKey().getId());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwNTU1Ng==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r432905556", "bodyText": "I already added it, but forgot to update this callsite", "author": "martint", "createdAt": "2020-05-31T03:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkwMTE1Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MTIzNw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435461237", "bodyText": "This doesn't return millis", "author": "dain", "createdAt": "2020-06-04T18:24:53Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/DateDiff.java", "diffHunk": "@@ -43,16 +46,36 @@ public static long diff(\n             @SqlType(\"timestamp(p)\") long timestamp1,\n             @SqlType(\"timestamp(p)\") long timestamp2)\n     {\n+        long epochMillis1 = timestamp1;\n+        long epochMillis2 = timestamp2;\n         if (precision > 3) {\n-            timestamp1 = scaleEpochMicrosToMillis(timestamp1);\n-            timestamp2 = scaleEpochMicrosToMillis(timestamp2);\n+            epochMillis1 = scaleEpochMicrosToMillis(timestamp1);\n+            epochMillis2 = scaleEpochMicrosToMillis(timestamp2);\n         }\n \n+        ISOChronology chronology = ISOChronology.getInstanceUTC();\n         if (session.isLegacyTimestamp()) {\n-            return getTimestampField(getChronology(session.getTimeZoneKey()), unit).getDifferenceAsLong(timestamp2, timestamp1);\n+            chronology = getChronology(session.getTimeZoneKey());\n         }\n \n-        return getTimestampField(ISOChronology.getInstanceUTC(), unit).getDifferenceAsLong(timestamp2, timestamp1);\n+        long deltaMillis = getTimestampField(chronology, unit).getDifferenceAsLong(epochMillis2, epochMillis1);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MjEyNA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435462124", "bodyText": "update comment", "author": "dain", "createdAt": "2020-06-04T18:25:52Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/FormatDateTime.java", "diffHunk": "@@ -43,7 +44,7 @@ public static Slice format(@LiteralParameter(\"p\") long precision, ConnectorSessi\n     {\n         // TODO: currently, date formatting only supports up to millis, so anything below that granularity gets truncated", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2MjIxNg==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435462216", "bodyText": "Update comment", "author": "dain", "createdAt": "2020-06-04T18:25:58Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/DateFormat.java", "diffHunk": "@@ -40,7 +41,7 @@ public static Slice format(@LiteralParameter(\"p\") long precision, ConnectorSessi\n     {\n         // TODO: currently, date formatting only supports up to millis, so anything below that granularity gets truncated", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2Mzg3Nw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435463877", "bodyText": "use static import?", "author": "dain", "createdAt": "2020-06-04T18:28:23Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampToTimestampCast.java", "diffHunk": "@@ -52,7 +54,7 @@ public static long shortToShort(\n             return epochMicros;\n         }\n \n-        epochMicros = truncateEpoch(epochMicros, (int) (MAX_SHORT_PRECISION - targetPrecision));\n+        epochMicros = Timestamps.round(epochMicros, (int) (MAX_SHORT_PRECISION - targetPrecision));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NjQ3OQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435466479", "bodyText": "should this be renamed to contain the word round", "author": "dain", "createdAt": "2020-06-04T18:32:09Z", "path": "presto-main/src/main/java/io/prestosql/type/Timestamps.java", "diffHunk": "@@ -90,12 +101,12 @@ public static long scaleEpochMillisToMicros(long epochMillis)\n \n     public static long epochMillisToMicros(long epochMillis, int picosOfMilli)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NjU1MA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435466550", "bodyText": "same", "author": "dain", "createdAt": "2020-06-04T18:32:17Z", "path": "presto-main/src/main/java/io/prestosql/type/Timestamps.java", "diffHunk": "@@ -90,12 +101,12 @@ public static long scaleEpochMillisToMicros(long epochMillis)\n \n     public static long epochMillisToMicros(long epochMillis, int picosOfMilli)\n     {\n-        return scaleEpochMillisToMicros(epochMillis) + picosOfMilli / PICOSECONDS_PER_MILLISECOND;\n+        return scaleEpochMillisToMicros(epochMillis) + roundDiv(picosOfMilli, PICOSECONDS_PER_MILLISECOND);\n     }\n \n     public static long epochSecondToMicros(long epochSecond, long picoOfSecond)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NDUxOQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435574519", "bodyText": "Shouldn't the default implementation throw?\n(otherwise \"should\" -> \"can\")", "author": "findepi", "createdAt": "2020-06-04T21:54:57Z", "path": "presto-main/src/test/java/io/prestosql/block/AbstractTestBlock.java", "diffHunk": "@@ -400,6 +402,12 @@ protected boolean isSliceAccessSupported()\n         return true;\n     }\n \n+    // Subclasses should implement this method to customize how the position is compared", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1NDM1MA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435754350", "bodyText": "Yeah, \"can\" is more appropriate", "author": "martint", "createdAt": "2020-06-05T08:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NTk3NA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435575974", "bodyText": "Create an issue for these deprecations for someone to follow up", "author": "findepi", "createdAt": "2020-06-04T21:58:38Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/QueryAssertions.java", "diffHunk": "@@ -86,22 +120,43 @@ public void assertQueryAndPlan(\n         PlanAssert.assertPlan(runner.getDefaultSession(), runner.getMetadata(), runner.getStatsCalculator(), plan, pattern);\n     }\n \n+    /**\n+     * @deprecated use {@link org.assertj.core.api.Assertions#assertThat} with {@link #query(String)}\n+     */\n+    @Deprecated\n     public void assertQuery(@Language(\"SQL\") String actual, @Language(\"SQL\") String expected)\n     {\n         assertQuery(runner.getDefaultSession(), actual, expected, false);\n     }\n \n+    /**\n+     * @deprecated <p>use {@link org.assertj.core.api.Assertions#assertThat} with {@link #query(String, Session)}:", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NjY5MA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435576690", "bodyText": ".matches suggests some \"pattern matching\", while here it's equality (disregaring orders)\nany better name? returns?", "author": "findepi", "createdAt": "2020-06-04T22:00:29Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestAggregationOverJoin.java", "diffHunk": "@@ -15,24 +15,25 @@\n \n import org.testng.annotations.Test;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n+\n public class TestAggregationOverJoin\n {\n     @Test\n     public void test()\n     {\n         // https://github.com/prestodb/presto/issues/10592\n-        try (QueryAssertions queryAssertions = new QueryAssertions()) {\n-            queryAssertions\n-                    .assertQuery(\n+        try (QueryAssertions assertions = new QueryAssertions()) {\n+            assertThat(assertions.query(\n                             \"WITH \" +\n                                     \"    t (a, b) AS (VALUES (1, 'a'), (1, 'b')), \" +\n                                     \"    u (a) AS (VALUES 1) \" +\n                                     \"SELECT DISTINCT v.a \" +\n                                     \"FROM ( \" +\n                                     \"    SELECT DISTINCT a, b \" +\n                                     \"    FROM t) v \" +\n-                                    \"LEFT JOIN u on v.a = u.a\",\n-                            \"VALUES 1\");\n+                                    \"LEFT JOIN u on v.a = u.a\"))\n+                    .matches(\"VALUES 1\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3NDIyNg==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435774226", "bodyText": "Hmmm... that's a very narrow interpretation of \"matches\". That word means, generally, to \"be equal to\" or \"be similar to\". I think it conveys the intent closely enough: \"the results of the current query match the results of the given query\".\nOn the other hand, \"returns\" also suggests it returns that exact string value, so it's not necessarily a better choice.", "author": "martint", "createdAt": "2020-06-05T08:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NjY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3ODkyOQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435578929", "bodyText": "don't you need up to 12?", "author": "findepi", "createdAt": "2020-06-04T22:06:03Z", "path": "presto-jdbc/src/main/java/io/prestosql/jdbc/PrestoResultSet.java", "diffHunk": "@@ -92,7 +92,20 @@\n             .toFormatter()\n             .withOffsetParsed();\n \n-    static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSS\");\n+    static final DateTimeFormatter TIMESTAMP_FORMATTER = new DateTimeFormatterBuilder()\n+            .append(\n+                    DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSS\").getPrinter(),\n+                    new DateTimeParser[] {\n+                            DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\").getParser(),\n+                            DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.S\").getParser(),\n+                            DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SS\").getParser(),\n+                            DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSS\").getParser(),\n+                            DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSSS\").getParser(),\n+                            DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSSSS\").getParser(),\n+                            DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSS\").getParser(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2OTkwOA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435769908", "bodyText": "Yes, but that actually doesn't help anyway. Joda only supports parsing up to millisecond precision, so everything after that is lost. I changed the parser entirely to support up to nanosecond precision (what JDBC Timestamp allows).", "author": "martint", "createdAt": "2020-06-05T08:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3ODkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3OTkzMg==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435579932", "bodyText": "@deprecate, since it should not be used to determine something is a timestamp type (as in #3762)", "author": "findepi", "createdAt": "2020-06-04T22:08:48Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/TimestampType.java", "diffHunk": "@@ -13,49 +13,62 @@\n  */\n package io.prestosql.spi.type;\n \n-import io.prestosql.spi.block.Block;\n-import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.PrestoException;\n+\n+import static io.prestosql.spi.StandardErrorCode.NUMERIC_VALUE_OUT_OF_RANGE;\n+import static java.lang.String.format;\n \n /**\n  * A timestamp is stored as milliseconds from 1970-01-01T00:00:00 UTC and is to be interpreted as date-time in UTC.\n  * In legacy timestamp semantics, timestamp is stored as milliseconds from 1970-01-01T00:00:00 UTC and is to be\n  * interpreted in session time zone.\n  */\n-public final class TimestampType\n-        extends AbstractLongType\n+public abstract class TimestampType\n+        extends AbstractType\n+        implements FixedWidthType\n {\n-    public static final TimestampType TIMESTAMP = new TimestampType();\n+    public static final int MAX_PRECISION = 12;\n \n-    private TimestampType()\n-    {\n-        super(new TypeSignature(StandardTypes.TIMESTAMP));\n-    }\n+    public static final int MAX_SHORT_PRECISION = 6;\n+    private static final int DEFAULT_PRECISION = 3; // TODO: should be 6 per SQL spec\n \n-    @Override\n-    public Object getObjectValue(ConnectorSession session, Block block, int position)\n+    public static final TimestampType TIMESTAMP = createTimestampType(DEFAULT_PRECISION);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MDkzMA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435580930", "bodyText": "Define encoding within the block (the (long, int) pair semantics)", "author": "findepi", "createdAt": "2020-06-04T22:11:23Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimestampType.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.block.BlockBuilder;\n+import io.prestosql.spi.block.BlockBuilderStatus;\n+import io.prestosql.spi.block.Int96ArrayBlockBuilder;\n+import io.prestosql.spi.block.PageBuilderStatus;\n+import io.prestosql.spi.connector.ConnectorSession;\n+\n+import static io.airlift.slice.SizeOf.SIZE_OF_LONG;\n+\n+public class LongTimestampType", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4MTU2Mg==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435581562", "bodyText": "Define how should be epochMicro = -4, picosOfMicro = 42 be interpreted", "author": "findepi", "createdAt": "2020-06-04T22:13:08Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/LongTimestamp.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.type;\n+\n+import java.util.Objects;\n+\n+public final class LongTimestamp\n+{\n+    private static final int PICOSECONDS_PER_MICROSECOND = 1_000_000;\n+\n+    private final long epochMicros;\n+    private final int picosOfMicro; // number of picoSeconds of the microsecond corresponding to epochMicros", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MDcyMA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435760720", "bodyText": "Maybe worth mentioning what's the compat behavior when this is not set.", "author": "findepi", "createdAt": "2020-06-05T08:13:42Z", "path": "presto-client/src/main/java/io/prestosql/client/ClientCapabilities.java", "diffHunk": "@@ -15,5 +15,12 @@\n \n public enum ClientCapabilities\n {\n-    PATH;\n+    PATH,\n+    // Whether clients support datetime types with variable precision\n+    //   timestamp(p) with time zone\n+    //   timestamp(p) without time zone\n+    //   time(p) with time zone\n+    //   time(p) without time zone\n+    //   interval X(p1) to Y(p2)\n+    PARAMETRIC_DATETIME;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MzQyNw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435763427", "bodyText": "A particular reason for not using ZoneOffset.UTC here?\n(we tend to use ZoneOffset.UTC predominantly)", "author": "findepi", "createdAt": "2020-06-05T08:19:00Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/RowIterable.java", "diffHunk": "@@ -50,14 +56,18 @@ public RowIterable(ConnectorSession session, List<Type> types, Page page)\n     private static class RowIterator\n             extends AbstractIterator<List<Object>>\n     {\n+        private static final ZoneId ZULU = ZoneId.of(\"Z\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3NjE2NQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435776165", "bodyText": "No particular reason. They are equivalent, but I'll update it. It saves a lookup.", "author": "martint", "createdAt": "2020-06-05T08:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MzQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NjUyMw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435766523", "bodyText": "nit: Class 'LessThan' has only 'static' members, and lacks a 'private' constructor", "author": "findepi", "createdAt": "2020-06-05T08:24:44Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/timestamp/TimestampOperators.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.operator.scalar.timestamp;\n+\n+import io.airlift.slice.XxHash64;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.IsNull;\n+import io.prestosql.spi.function.LiteralParameter;\n+import io.prestosql.spi.function.LiteralParameters;\n+import io.prestosql.spi.function.ScalarOperator;\n+import io.prestosql.spi.function.SqlNullable;\n+import io.prestosql.spi.function.SqlType;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.LongTimestampType;\n+import io.prestosql.spi.type.ShortTimestampType;\n+import io.prestosql.spi.type.StandardTypes;\n+import io.prestosql.type.Constraint;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.chrono.ISOChronology;\n+\n+import static io.prestosql.spi.function.OperatorType.ADD;\n+import static io.prestosql.spi.function.OperatorType.EQUAL;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN;\n+import static io.prestosql.spi.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.HASH_CODE;\n+import static io.prestosql.spi.function.OperatorType.INDETERMINATE;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN;\n+import static io.prestosql.spi.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.NOT_EQUAL;\n+import static io.prestosql.spi.function.OperatorType.SUBTRACT;\n+import static io.prestosql.spi.function.OperatorType.XX_HASH_64;\n+import static io.prestosql.type.Timestamps.MICROSECONDS_PER_MILLISECOND;\n+import static io.prestosql.type.Timestamps.getMicrosOfMilli;\n+import static io.prestosql.type.Timestamps.rescale;\n+import static io.prestosql.type.Timestamps.scaleEpochMicrosToMillis;\n+import static io.prestosql.type.Timestamps.scaleEpochMillisToMicros;\n+import static io.prestosql.util.DateTimeZoneIndex.getChronology;\n+import static java.lang.Math.multiplyExact;\n+\n+public final class TimestampOperators\n+{\n+    private TimestampOperators() {}\n+\n+    @ScalarOperator(EQUAL)\n+    public static final class Equal\n+    {\n+        @LiteralParameters(\"p\")\n+        @SqlNullable\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static Boolean equal(@SqlType(\"timestamp(p)\") long left, @SqlType(\"timestamp(p)\") long right)\n+        {\n+            return left == right;\n+        }\n+\n+        @LiteralParameters(\"p\")\n+        @SqlNullable\n+        @SqlType(StandardTypes.BOOLEAN)\n+        public static Boolean equal(@SqlType(\"timestamp(p)\") LongTimestamp left, @SqlType(\"timestamp(p)\") LongTimestamp right)\n+        {\n+            return left.equals(right);\n+        }\n+    }\n+\n+    @ScalarOperator(NOT_EQUAL)\n+    public static final class NotEqual", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3ODczNQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435778735", "bodyText": "I think that's too noisy. We end up with a bunch of dummy constructors for no reason. It's clear that these classes are not meant to be used or instantiated.", "author": "martint", "createdAt": "2020-06-05T08:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NjUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5NzcxMw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435797713", "bodyText": "You can suppress this on top-level class level. Ignoreable IDE warning make it harder to notice the ones i shouldn't ignore.", "author": "findepi", "createdAt": "2020-06-05T09:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NjUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2OTY2Mg==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435769662", "bodyText": "nit: verify picosOfMicro is in appropriate range (primarily to catch negative values)", "author": "findepi", "createdAt": "2020-06-05T08:30:32Z", "path": "presto-main/src/main/java/io/prestosql/type/Timestamps.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.type;\n+\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.LongTimestamp;\n+import io.prestosql.spi.type.TimeZoneKey;\n+import io.prestosql.spi.type.TimestampType;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.type.TimestampType.MAX_PRECISION;\n+import static io.prestosql.spi.type.TimestampType.MAX_SHORT_PRECISION;\n+import static java.lang.Math.floorMod;\n+import static java.lang.Math.multiplyExact;\n+import static java.lang.String.format;\n+import static java.time.temporal.ChronoField.MICRO_OF_SECOND;\n+\n+public final class Timestamps\n+{\n+    public static final ZoneId ZULU = ZoneId.of(\"Z\");\n+    public static final Pattern DATETIME_PATTERN = Pattern.compile(\"\" +\n+            \"(?<year>\\\\d\\\\d\\\\d\\\\d)-(?<month>\\\\d{1,2})-(?<day>\\\\d{1,2})\" +\n+            \"(?: (?<hour>\\\\d{1,2}):(?<minute>\\\\d{1,2})(?::(?<second>\\\\d{1,2})(?:.(?<fraction>\\\\d+))?)?)?\" +\n+            \"\\\\s*(?<timezone>.+)?\");\n+    private static final DateTimeFormatter TIMESTAMP_FORMATTER = DateTimeFormatter.ofPattern(\"uuuu-MM-dd HH:mm:ss\");\n+\n+    private static final long[] POWERS_OF_TEN = {\n+            1L,\n+            10L,\n+            100L,\n+            1000L,\n+            10_000L,\n+            100_000L,\n+            1_000_000L,\n+            10_000_000L,\n+            100_000_000L,\n+            1_000_000_000L,\n+            10_000_000_000L,\n+            100_000_000_000L,\n+            1000_000_000_000L\n+    };\n+\n+    public static final int MILLISECONDS_PER_SECOND = 1000;\n+    public static final int MICROSECONDS_PER_SECOND = 1_000_000;\n+    public static final int MICROSECONDS_PER_MILLISECOND = 1000;\n+    public static final long PICOSECONDS_PER_SECOND = 1_000_000_000_000L;\n+    public static final int NANOSECONDS_PER_MICROSECOND = 1_000;\n+    public static final int PICOSECONDS_PER_MILLISECOND = 1_000_000_000;\n+    public static final int PICOSECONDS_PER_MICROSECOND = 1_000_000;\n+    public static final int PICOSECONDS_PER_NANOSECOND = 1000;\n+\n+    private Timestamps() {}\n+\n+    private static long roundDiv(long value, long factor)\n+    {\n+        checkArgument(factor > 0, \"factor must be positive\");\n+\n+        if (value >= 0) {\n+            return (value + (factor / 2)) / factor;\n+        }\n+\n+        return (value - (factor / 2)) / factor;\n+    }\n+\n+    public static long scaleEpochMicrosToMillis(long value)\n+    {\n+        return Math.floorDiv(value, MICROSECONDS_PER_MILLISECOND);\n+    }\n+\n+    private static long scaleEpochMicrosToSeconds(long epochMicros)\n+    {\n+        return Math.floorDiv(epochMicros, MICROSECONDS_PER_SECOND);\n+    }\n+\n+    public static long scaleEpochMillisToMicros(long epochMillis)\n+    {\n+        return multiplyExact(epochMillis, MICROSECONDS_PER_MILLISECOND);\n+    }\n+\n+    public static long epochSecondToMicrosWithRounding(long epochSecond, long picoOfSecond)\n+    {\n+        return epochSecond * MICROSECONDS_PER_SECOND + roundDiv(picoOfSecond, PICOSECONDS_PER_MICROSECOND);\n+    }\n+\n+    public static int getMicrosOfSecond(long epochMicros)\n+    {\n+        return floorMod(epochMicros, MICROSECONDS_PER_SECOND);\n+    }\n+\n+    public static int getMicrosOfMilli(long epochMicros)\n+    {\n+        return floorMod(epochMicros, MICROSECONDS_PER_MILLISECOND);\n+    }\n+\n+    public static long round(long value, int magnitude)\n+    {\n+        return roundToNearest(value, POWERS_OF_TEN[magnitude]);\n+    }\n+\n+    public static long roundToNearest(long value, long bound)\n+    {\n+        return roundDiv(value, bound) * bound;\n+    }\n+\n+    private static long scaleFactor(int fromPrecision, int toPrecision)\n+    {\n+        if (fromPrecision > toPrecision) {\n+            throw new IllegalArgumentException(\"fromPrecision must be <= toPrecision\");\n+        }\n+\n+        return POWERS_OF_TEN[toPrecision - fromPrecision];\n+    }\n+\n+    public static long rescale(long value, int fromPrecision, int toPrecision)\n+    {\n+        if (value < 0) {\n+            throw new IllegalArgumentException(\"value must be >= 0\");\n+        }\n+\n+        if (fromPrecision <= toPrecision) {\n+            value *= scaleFactor(fromPrecision, toPrecision);\n+        }\n+        else {\n+            value = roundDiv(value, scaleFactor(toPrecision, fromPrecision));\n+        }\n+\n+        return value;\n+    }\n+\n+    public static boolean timestampHasTimeZone(String value)\n+    {\n+        Matcher matcher = DATETIME_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(format(\"Invalid timestamp '%s'\", value));\n+        }\n+\n+        return matcher.group(\"timezone\") != null;\n+    }\n+\n+    public static int extractTimestampPrecision(String value)\n+    {\n+        Matcher matcher = DATETIME_PATTERN.matcher(value);\n+        if (!matcher.matches()) {\n+            throw new IllegalArgumentException(format(\"Invalid timestamp '%s'\", value));\n+        }\n+\n+        String fraction = matcher.group(\"fraction\");\n+        if (fraction == null) {\n+            return 0;\n+        }\n+\n+        return fraction.length();\n+    }\n+\n+    public static LocalDateTime toLocalDateTime(TimestampType type, ConnectorSession session, Block block, int position)\n+    {\n+        int precision = type.getPrecision();\n+\n+        long epochMicros;\n+        int picosOfMicro = 0;\n+        if (precision <= 3) {\n+            epochMicros = scaleEpochMillisToMicros(type.getLong(block, position));\n+        }\n+        else if (precision <= MAX_SHORT_PRECISION) {\n+            epochMicros = type.getLong(block, position);\n+        }\n+        else {\n+            LongTimestamp timestamp = (LongTimestamp) type.getObject(block, position);\n+            epochMicros = timestamp.getEpochMicros();\n+            picosOfMicro = timestamp.getPicosOfMicro();\n+        }\n+\n+        long epochSecond = scaleEpochMicrosToSeconds(epochMicros);\n+        int nanoFraction = getMicrosOfSecond(epochMicros) * NANOSECONDS_PER_MICROSECOND + (int) (roundToNearest(picosOfMicro, PICOSECONDS_PER_NANOSECOND) / PICOSECONDS_PER_NANOSECOND);\n+\n+        Instant instant = Instant.ofEpochSecond(epochSecond, nanoFraction);\n+        if (session.isLegacyTimestamp()) {\n+            return LocalDateTime.ofInstant(instant, session.getTimeZoneKey().getZoneId());\n+        }\n+\n+        return LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n+    }\n+\n+    public static String formatTimestamp(int precision, long epochMicros, int picosOfMicro, ZoneId zoneId)\n+    {\n+        return formatTimestamp(precision, epochMicros, picosOfMicro, zoneId, TIMESTAMP_FORMATTER);\n+    }\n+\n+    public static String formatTimestamp(int precision, long epochMicros, int picosOfMicro, ZoneId zoneId, DateTimeFormatter yearToSecondFormatter)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTU3Ng==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435771576", "bodyText": "For precision=0 the second fraction is truncated.\nFor precision>0, the value is rounded.\nSee TODO here (& consider adding as a test case):\n@Test\npublic void testFormatTimestamp()\n{\n    assertEquals(formatTimestamp(0, -1_000_000, 123456, UTC), \"1969-12-31 23:59:59\");\n    assertEquals(formatTimestamp(0, -1_000_000, 654321, UTC), \"1969-12-31 23:59:59\"); // TODO rounding\n    assertEquals(formatTimestamp(0, 1_000_000, 123456, UTC), \"1970-01-01 00:00:01\");\n    assertEquals(formatTimestamp(0, 1_000_000, 654321, UTC), \"1970-01-01 00:00:01\"); // TODO rounding\n\n    assertEquals(formatTimestamp(9, -1_000_000, 0, UTC), \"1969-12-31 23:59:59.000000000\");\n    assertEquals(formatTimestamp(9, -1_000_000, 123456, UTC), \"1969-12-31 23:59:59.000000123\");\n    assertEquals(formatTimestamp(9, 0, 0, UTC), \"1970-01-01 00:00:00.000000000\");\n    assertEquals(formatTimestamp(9, 0, 123456, UTC), \"1970-01-01 00:00:00.000000123\");\n    assertEquals(formatTimestamp(9, 1_000_000, 123456, UTC), \"1970-01-01 00:00:01.000000123\");\n\n    assertEquals(formatTimestamp(3, 1_234_567, 890123, UTC), \"1970-01-01 00:00:01.235\");\n    assertEquals(formatTimestamp(6, 1_234_567, 890123, UTC), \"1970-01-01 00:00:01.234568\"); // rounding\n    assertEquals(formatTimestamp(9, 1_234_567, 890123, UTC), \"1970-01-01 00:00:01.234567890\");\n    assertEquals(formatTimestamp(12, 1_234_567, 890123, UTC), \"1970-01-01 00:00:01.234567890123\");\n\n    // TODO cover other zones\n}", "author": "findepi", "createdAt": "2020-06-05T08:33:39Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/SqlTimestamp.java", "diffHunk": "@@ -103,9 +165,33 @@ public String toString()\n                 .map(ZoneId::of)\n                 .orElse(ZoneOffset.UTC);\n \n-        return Instant.ofEpochMilli(millis)\n-                .atZone(zoneId)\n-                .format(JSON_FORMATTER);\n+        return formatTimestamp(precision, epochMicros, picosOfMicros, zoneId);\n+    }\n+\n+    public static String formatTimestamp(int precision, long epochMicros, int picosOfMicro, ZoneId zoneId)\n+    {\n+        Instant instant = Instant.ofEpochSecond(Math.floorDiv(epochMicros, MICROSECONDS_PER_SECOND));\n+        LocalDateTime dateTime = LocalDateTime.ofInstant(instant, zoneId);\n+\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(TIMESTAMP_FORMATTER.format(dateTime));\n+        if (precision > 0) {\n+            long picoFraction = ((long) floorMod(epochMicros, MICROSECONDS_PER_SECOND)) * PICOSECONDS_PER_MICROSECOND + picosOfMicro;\n+            long scaledFraction = roundDiv(picoFraction, POWERS_OF_TEN[MAX_PRECISION - precision]);\n+            builder.append(\".\");\n+            builder.append(format(\"%0\" + precision + \"d\", scaledFraction));\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MDAxNQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435780015", "bodyText": "Good catch!", "author": "martint", "createdAt": "2020-06-05T08:49:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MjI0Ng==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435782246", "bodyText": "Actually, no, it doesn't matter. It turns out that the values are already pre-rounded to the expected precision by the time this object is constructed -- all the positions after the given precision will be 0. So the rounding in this method is unnecessary. I'll simplify it.", "author": "martint", "createdAt": "2020-06-05T08:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NTM4Nw==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435785387", "bodyText": "I'll also add validation or rounding in the various constructors.", "author": "martint", "createdAt": "2020-06-05T08:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5OTA0MA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r435799040", "bodyText": "This method is responsible for rounding (data is not pre-rounded) when the client does not support new capability.\nFor this cases at least please do add test cases. (precision=3, values: any)\n(In the test you also have a comment why you are not testing certain cases, as they are not possible in real code.)", "author": "findepi", "createdAt": "2020-06-05T09:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4Njc5OQ==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r436086799", "bodyText": "No, this method is not the one that's used for rendering to the client. It's the default toString implementation for SqlTimestamp. In any case, I simplified this whole thing a bit. I added a roundTo() method to SqlTimestamp and updated the protocol layer to use that instead and not deal with calling the formatting code directly. I added some tests (and found a minor bug along the way).", "author": "martint", "createdAt": "2020-06-05T18:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyOTExMg==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r436129112", "bodyText": "No, this method is not the one that's used for rendering to the client.\n\nPerhaps i got mislead because we have similar (but not equal) formatTimestamp in SqlTimestamp and Timestamps.\nWhat's the reason?", "author": "findepi", "createdAt": "2020-06-05T19:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzMjM3MA==", "url": "https://github.com/trinodb/trino/pull/3783#discussion_r436132370", "bodyText": "Visibility. SqlTimestamp is in the SPI, but Timestamps is not (and should not be -- it has too many low-level implementation methods)", "author": "martint", "createdAt": "2020-06-05T19:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTU3Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "e7899bf1306c2422989b0f5c630a817ea798660c", "url": "https://github.com/trinodb/trino/commit/e7899bf1306c2422989b0f5c630a817ea798660c", "message": "Make tests single-threaded\n\nThese tests rely on shared state and need to be executed exclusively.\nSimplify the tests by relying on TestNg's ability to run them in\nsingle-threaded mode.", "committedDate": "2020-06-05T20:54:33Z", "type": "commit"}, {"oid": "a381258408d3e571ce255c838dae307873da1cac", "url": "https://github.com/trinodb/trino/commit/a381258408d3e571ce255c838dae307873da1cac", "message": "Use assertj for query assertions\n\nThis makes it possible to write assertions as:\n\n    assertThat(assertions.query(\"<query>\"))\n        .matches(\"<another query>\")\n\nand add any other assertions that might be relevant using the power of AssertJ", "committedDate": "2020-06-05T20:54:33Z", "type": "commit"}, {"oid": "b6c2233e964f1418ebced68baabc89cdfca80e0b", "url": "https://github.com/trinodb/trino/commit/b6c2233e964f1418ebced68baabc89cdfca80e0b", "message": "Render timestamps as ISO8601 without a timezone\n\nTimestamps do not have an associated timezone, so they shouldn't be\nrender with one attached.", "committedDate": "2020-06-05T20:54:33Z", "type": "commit"}, {"oid": "089d53ccafb3f5d9cc560142cf24e2ab351f810d", "url": "https://github.com/trinodb/trino/commit/089d53ccafb3f5d9cc560142cf24e2ab351f810d", "message": "Add Int96Array block", "committedDate": "2020-06-05T20:54:33Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "bb416fd72111a2c5c5344d7fc92c58af51fa5a02", "url": "https://github.com/trinodb/trino/commit/bb416fd72111a2c5c5344d7fc92c58af51fa5a02", "message": "Implement parametric timestamp type\n\nSupports timestamp(p) with p in [0..12]\n\nIt introduces a 3-form representation:\n* When p <= 3, it uses a long containing the number of milliseconds since the epoch. This\n  makes it possible to maintain backward compatibility with existing connectors that rely\n  on this encoding\n* When 3 < p <= 6, it uses a long containing the number of microseconds since the epoch.\n* When 6 < p <= 12, it uses a custom object containing a long+int", "committedDate": "2020-06-06T06:52:29Z", "type": "commit"}, {"oid": "c6209612e25752645e54dde9e6dcf9c17e779ded", "url": "https://github.com/trinodb/trino/commit/c6209612e25752645e54dde9e6dcf9c17e779ded", "message": "Provide backward-compatibility mode for clients\n\nIf clients declare they support the PARAMETRIC_DATETIME capability,\ndatetime types will be rendered with variable precision.", "committedDate": "2020-06-06T06:52:29Z", "type": "commit"}, {"oid": "c6209612e25752645e54dde9e6dcf9c17e779ded", "url": "https://github.com/trinodb/trino/commit/c6209612e25752645e54dde9e6dcf9c17e779ded", "message": "Provide backward-compatibility mode for clients\n\nIf clients declare they support the PARAMETRIC_DATETIME capability,\ndatetime types will be rendered with variable precision.", "committedDate": "2020-06-06T06:52:29Z", "type": "forcePushed"}]}