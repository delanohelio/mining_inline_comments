{"pr_number": 4956, "pr_title": "Add support for TopN to cost", "pr_createdAt": "2020-08-24T13:28:56Z", "pr_url": "https://github.com/trinodb/trino/pull/4956", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNjk5MA==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r475816990", "bodyText": "Name testTopNWithLongInput", "author": "losipiuk", "createdAt": "2020-08-24T18:36:27Z", "path": "presto-main/src/test/java/io/prestosql/cost/TestTopNStatsRule.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.prestosql.cost;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+import org.testng.annotations.Test;\n+\n+public class TestTopNStatsRule\n+        extends BaseStatsCalculatorTest\n+{\n+    @Test\n+    public void testShorterTopN()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3ODA5OQ==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476278099", "bodyText": "fixed", "author": "kabunchi", "createdAt": "2020-08-25T08:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNjk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNzEwNQ==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r475817105", "bodyText": "Name testTopNWithSmallInput", "author": "losipiuk", "createdAt": "2020-08-24T18:36:40Z", "path": "presto-main/src/test/java/io/prestosql/cost/TestTopNStatsRule.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.prestosql.cost;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+import org.testng.annotations.Test;\n+\n+public class TestTopNStatsRule\n+        extends BaseStatsCalculatorTest\n+{\n+    @Test\n+    public void testShorterTopN()\n+    {\n+        // Test case with more rows in data than in topN SINGLE step\n+        tester().assertStatsFor(pb -> pb\n+                .topN(10, ImmutableList.of(pb.symbol(\"i1\")), pb.values(pb.symbol(\"i1\"), pb.symbol(\"i2\"))))\n+                .withSourceStats(0, PlanNodeStatsEstimate.builder()\n+                        .setOutputRowCount(100)\n+                        .addSymbolStatistics(new Symbol(\"i1\"), SymbolStatsEstimate.builder()\n+                                .setLowValue(1)\n+                                .setHighValue(10)\n+                                .setDistinctValuesCount(5)\n+                                .setNullsFraction(0)\n+                                .build())\n+                        .addSymbolStatistics(new Symbol(\"i2\"), SymbolStatsEstimate.builder()\n+                                .setLowValue(0)\n+                                .setHighValue(3)\n+                                .setDistinctValuesCount(4)\n+                                .setNullsFraction(0)\n+                                .build())\n+                        .build())\n+                .check(check -> check\n+                        .outputRowsCount(10) //Expect TopN to limit\n+                        .symbolStats(\"i1\", assertion -> assertion\n+                                .lowValue(1)\n+                                .highValue(10)\n+                                .distinctValuesCount(5)\n+                                .dataSizeUnknown()\n+                                .nullsFraction(0))\n+                        .symbolStats(\"i2\", assertion -> assertion\n+                                .lowValue(0)\n+                                .highValue(3)\n+                                .dataSizeUnknown()\n+                                .distinctValuesCount(4)\n+                                .nullsFraction(0)));\n+\n+        // Test case with more rows in data than in topN PARTIAL step\n+        tester().assertStatsFor(pb -> pb\n+                .topN(10, ImmutableList.of(pb.symbol(\"i1\")), TopNNode.Step.PARTIAL, pb.values(pb.symbol(\"i1\"), pb.symbol(\"i2\"))))\n+                .withSourceStats(0, PlanNodeStatsEstimate.builder()\n+                        .setOutputRowCount(100)\n+                        .addSymbolStatistics(new Symbol(\"i1\"), SymbolStatsEstimate.builder()\n+                                .setLowValue(1)\n+                                .setHighValue(10)\n+                                .setDistinctValuesCount(5)\n+                                .setNullsFraction(0)\n+                                .build())\n+                        .addSymbolStatistics(new Symbol(\"i2\"), SymbolStatsEstimate.builder()\n+                                .setLowValue(0)\n+                                .setHighValue(3)\n+                                .setDistinctValuesCount(4)\n+                                .setNullsFraction(0)\n+                                .build())\n+                        .build())\n+                .check(check -> check\n+                        .outputRowsCount(100) //Expect TopN not to limit\n+                        .symbolStats(\"i1\", assertion -> assertion\n+                                .lowValue(1)\n+                                .highValue(10)\n+                                .distinctValuesCount(5)\n+                                .dataSizeUnknown()\n+                                .nullsFraction(0))\n+                        .symbolStats(\"i2\", assertion -> assertion\n+                                .lowValue(0)\n+                                .highValue(3)\n+                                .dataSizeUnknown()\n+                                .distinctValuesCount(4)\n+                                .nullsFraction(0)));\n+    }\n+\n+    @Test\n+    public void testLongerTopN()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3ODE2MQ==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476278161", "bodyText": "fixed", "author": "kabunchi", "createdAt": "2020-08-25T08:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNzEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxODAwMg==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r475818002", "bodyText": "I think you should reset nulls fraction to 0 here. Or is it done anyway somewhere else. Can you please add test where input has non-zero null fraction.", "author": "losipiuk", "createdAt": "2020-08-24T18:38:26Z", "path": "presto-main/src/main/java/io/prestosql/cost/TopNStatsRule.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.cost;\n+\n+import io.prestosql.Session;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.TypeProvider;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.sql.planner.plan.Patterns.topN;\n+\n+public class TopNStatsRule\n+        extends SimpleStatsRule<TopNNode>\n+{\n+    private static final Pattern<TopNNode> PATTERN = topN();\n+\n+    public TopNStatsRule(StatsNormalizer normalizer)\n+    {\n+        super(normalizer);\n+    }\n+\n+    @Override\n+    public Pattern<TopNNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    protected Optional<PlanNodeStatsEstimate> doCalculate(TopNNode node, StatsProvider statsProvider, Lookup lookup, Session session, TypeProvider types)\n+    {\n+        PlanNodeStatsEstimate sourceStats = statsProvider.getStats(node.getSource());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI4MTYxNA==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476281614", "bodyText": "not sure I follow.\nI completely disregard the null fraction as I validate only against the outputRows. adding it to a test won't really affect the changes.\nI can change one of the stats in the test to hold fraction other than 0..\nbtw, I just followed LimitStatsRule.java", "author": "kabunchi", "createdAt": "2020-08-25T08:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxODAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyOTcyNQ==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476329725", "bodyText": "Reseting nulls fraction to 0 is an overstatement. But IMO nulls handling could be improved here.\nLet use two example queries:\npresto:default> select * from (values 1, NULL, 2, NULL, 3, NULL, 4, NULL, 5) t(a) order by a limit 6;\n  a\n------\n    1\n    2\n    3\n    4\n    5\n NULL\n\npresto:default> select * from (values 1, NULL, 2, NULL, 3, NULL, 4, NULL, 5) t(a) order by a desc limit 6;\n  a\n------\n    5\n    4\n    3\n    2\n    1\n NULL\n(6 rows)\n\nHere we have a TopN operator on column a. No matter what sort order we are using, NULLs will always end up last. So estimated nulls-fraction for an output should be adjusted. Something like this should do:\nif limit > input.rowsCount {\n  return input stats\n}\n\ninputNonNullsCount = input.rowCount - input.rowCount * input.nullsFraction;;\n\noutputRowCount = limit\nif limit < inputNonNullsCount {\n   outputNullsCount = 0\n} else {\n   outputNullsCount = limit - inputNonNullsCount\n}\n\noutputNullsFraction = outputNullsCount/outputRowCount\n\nNote that if ordering uses multiple columns, above logic is valid only for the first one.", "author": "losipiuk", "createdAt": "2020-08-25T09:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxODAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM2NTYxMg==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476365612", "bodyText": "Got you now.\nStill now sure how to proceed.\nMainly because I didn't fully understood the first column comment, how do I differ? what the single null fraction value stands for in case of multiple columns?\nRegardless,  because one can also use order by 1 NULLS first I must look at the sortOrder to re-calculate the null fraction correctly", "author": "kabunchi", "createdAt": "2020-08-25T11:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxODAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM3NTY2Mg==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476375662", "bodyText": "Mainly because I didn't fully understood the first column comment, how do I differ? what the single null fraction value stands for in case of multiple columns?\n\nThere is no single nulls-fraction value. The nulls-fraction is stored per column. You can modify it either using PlanNodeStatsEstimate.mapSymbolColumnStatistics or explicitly setting via PlanNodeStatsEstimate.Builder#addSymbolStatistics().\nIf there are multiple columns used for ordering, I think we cannot derive anything reasonable regarding nulls fraction for any column but first. So I think we should leave source null-fraction for other ones.\n\nRegardless, because one can also use order by 1 NULLS first I must look at the sortOrder to re-calculate the null fraction correctly\n\nGood point.", "author": "losipiuk", "createdAt": "2020-08-25T11:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxODAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyMjA4NQ==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476422085", "bodyText": "ended up a bit ugly:\nSymbol symbol = node.getOrderingScheme().getOrderBy().get(0); // Assuming not empty list\n       SymbolStatsEstimate symbolStatsEstimate = sourceStats.getSymbolStatistics().get(symbol);\n       SortOrder sortOrder = node.getOrderingScheme().getOrdering(symbol);\n       long count = node.getCount();\n\n       if ((symbolStatsEstimate == null) || (sortOrder == null)) {\n           return Optional.of(PlanNodeStatsEstimate.buildFrom(sourceStats)\n                                                   .setOutputRowCount(count)\n                                                   .build());\n       }\n\n       double nullCount = rowCount * symbolStatsEstimate.getNullsFraction();\n       double outNullFraction;\n\n       if (sortOrder.isNullsFirst()) {\n           if (nullCount > count) {\n               outNullFraction = 1;\n           }\n           else {\n               outNullFraction = nullCount / count;\n           }\n       }\n       else {\n           double nonNullCount = (rowCount - nullCount);\n           if (nonNullCount > count) {\n               outNullFraction = 0;\n           }\n           else {\n               outNullFraction = (count - nonNullCount) / count;\n           }\n       }\n       SymbolStatsEstimate newSymbolStatsEstimate = SymbolStatsEstimate.buildFrom(symbolStatsEstimate).setNullsFraction(outNullFraction).build();\n\n       // TopN actually limits (or when there was no row count estimated for source)\n       return Optional.of(PlanNodeStatsEstimate.buildFrom(sourceStats)\n               .setOutputRowCount(count)\n               .addSymbolStatistics(symbol, newSymbolStatsEstimate)\n               .build());\n   }\n\n\nstill think it worth it?", "author": "kabunchi", "createdAt": "2020-08-25T12:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxODAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3OTA3Ng==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476479076", "bodyText": "You can make it (IMO) a bit cleaner with mapSymbolColumStatistics. Like this:\n    @Override\n    protected Optional<PlanNodeStatsEstimate> doCalculate(TopNNode node, StatsProvider statsProvider, Lookup lookup, Session session, TypeProvider types)\n    {\n        PlanNodeStatsEstimate sourceStats = statsProvider.getStats(node.getSource());\n        if (sourceStats.getOutputRowCount() <= node.getCount()) {\n            return Optional.of(sourceStats);\n        }\n\n        Symbol firstOrderSymbol = node.getOrderingScheme().getOrderBy().get(0); // Assuming not empty list\n        SortOrder sortOrder = node.getOrderingScheme().getOrdering(firstOrderSymbol);\n        long limitCount = node.getCount();\n\n        PlanNodeStatsEstimate resultStats = PlanNodeStatsEstimate.buildFrom(sourceStats)\n                .setOutputRowCount(limitCount)\n                .build();\n\n        // augment null fraction estimation for first ORDER BY symbol\n        double rowCount = sourceStats.getOutputRowCount();\n        resultStats = resultStats.mapSymbolColumnStatistics(firstOrderSymbol, symbolStats -> {\n            SymbolStatsEstimate.Builder newStats = SymbolStatsEstimate.buildFrom(symbolStats);\n            double nullCount = rowCount * symbolStats.getNullsFraction();\n            if (sortOrder.isNullsFirst()) {\n                if (nullCount > limitCount) {\n                    newStats.setNullsFraction(1.0);\n                }\n                else {\n                    newStats.setNullsFraction(nullCount / limitCount);\n                }\n            }\n            else {\n                double nonNullCount = (rowCount - nullCount);\n                if (nonNullCount > limitCount) {\n                    newStats.setNullsFraction(0.0);\n                }\n                else {\n                    newStats.setNullsFraction((limitCount - nonNullCount) / limitCount);\n                }\n            }\n            return newStats.build();\n        });\n        return Optional.of(resultStats);\n    }\nI think it is nice to have. What needs to be added to above is handling division by 0.0. And testing.", "author": "losipiuk", "createdAt": "2020-08-25T14:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxODAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1Njk4MQ==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476556981", "bodyText": "fixed and pushed.\nthanks for the very responsive review.", "author": "kabunchi", "createdAt": "2020-08-25T15:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxODAwMg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4MDE0NA==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476580144", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public TopNNode topN(long count, List<Symbol> orderBy, TopNNode.Step step, PlanNode source, SortOrder sortOrder)\n          \n          \n            \n                public TopNNode topN(long count, List<Symbol> orderBy, TopNNode.Step step, SortOrder sortOrder, PlanNode source)", "author": "losipiuk", "createdAt": "2020-08-25T16:29:21Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/test/PlanBuilder.java", "diffHunk": "@@ -259,13 +259,17 @@ public TopNNode topN(long count, List<Symbol> orderBy, PlanNode source)\n \n     public TopNNode topN(long count, List<Symbol> orderBy, TopNNode.Step step, PlanNode source)\n     {\n-        return new TopNNode(\n+        return topN(count, orderBy, step, source, SortOrder.ASC_NULLS_FIRST);\n+    }\n+\n+    public TopNNode topN(long count, List<Symbol> orderBy, TopNNode.Step step, PlanNode source, SortOrder sortOrder)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4ODkwOQ==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476588909", "bodyText": "fixed and pushed.", "author": "kabunchi", "createdAt": "2020-08-25T16:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4MDE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4NTQ5MA==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r476585490", "bodyText": "Not sure about PARTIAL handling. It does not limit output size to same extent as FINAL, yet it still can very substantially limit it vs size of the input to queryParalellism*limit.\n@findepi do you have an idea how to do better estimation here? (or pass to someone who may have more context here)", "author": "losipiuk", "createdAt": "2020-08-25T16:37:40Z", "path": "presto-main/src/main/java/io/prestosql/cost/TopNStatsRule.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.cost;\n+\n+import io.prestosql.Session;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeProvider;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.sql.planner.plan.Patterns.topN;\n+\n+public class TopNStatsRule\n+        extends SimpleStatsRule<TopNNode>\n+{\n+    private static final Pattern<TopNNode> PATTERN = topN();\n+\n+    public TopNStatsRule(StatsNormalizer normalizer)\n+    {\n+        super(normalizer);\n+    }\n+\n+    @Override\n+    public Pattern<TopNNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    protected Optional<PlanNodeStatsEstimate> doCalculate(TopNNode node, StatsProvider statsProvider, Lookup lookup, Session session, TypeProvider types)\n+    {\n+        PlanNodeStatsEstimate sourceStats = statsProvider.getStats(node.getSource());\n+        double rowCount = sourceStats.getOutputRowCount();\n+\n+        if ((rowCount <= node.getCount()) || (node.getStep() == TopNNode.Step.PARTIAL)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ4MzkzNA==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r477483934", "bodyText": "There's no good answer for PARTIAL. The number of global rows coming out of that operation will depend on the number of tasks that get created at runtime, and that's not known in advance.", "author": "martint", "createdAt": "2020-08-26T17:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4NTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzUwODI1Mg==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r477508252", "bodyText": "See also https://github.com/prestosql/presto/blob/c74b775e103a7a239aafef1b7ca15fe6370495fe/presto-main/src/main/java/io/prestosql/cost/AggregationStatsRule.java#L56-L58", "author": "findepi", "createdAt": "2020-08-26T18:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4NTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ2NTYxMA==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r478465610", "bodyText": "After discussing with @findepi  i think we should go same approach here:\nif (node.getStep() != SINGLE) {\n    return Optional.empty();\n}\nIt should still help as join enumeration, which uses stats is happening before SINGLE TopNNodes are split into PARTIAL and FINAL (unless I am misreading the code). (*)\n(*) It looks like the only way TopNNode can be converted into PARTIAL, before join enumeration, is due to execution of PushLimitThroughOuterJoin or PushLimitThroughUnion, which enforce partial flag on LimitNode they produce. Not sure if that logic is needed - I will look more into that.", "author": "losipiuk", "createdAt": "2020-08-27T14:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4NTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3MzQxMg==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r479673412", "bodyText": "just wondering why Optional.empty() and not Optional.of(sourceStats);?\nto carry on the stats already calculated.", "author": "kabunchi", "createdAt": "2020-08-29T17:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4NTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NDYwMg==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r479984602", "bodyText": "Optional.empty() means we cannot compute statistics which is accurate. The Optional.of(sourceStats) is not correct as the output of PARTIAL aggregation does not match its input.", "author": "losipiuk", "createdAt": "2020-08-31T08:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4NTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMwNzM0MA==", "url": "https://github.com/trinodb/trino/pull/4956#discussion_r480307340", "bodyText": "got it. thanks.", "author": "kabunchi", "createdAt": "2020-08-31T18:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4NTQ5MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "18cc6f11a79050981aa30f1a4c76ad2e95321892", "url": "https://github.com/trinodb/trino/commit/18cc6f11a79050981aa30f1a4c76ad2e95321892", "message": "Add support for TopN to cost", "committedDate": "2020-09-01T06:52:55Z", "type": "commit"}, {"oid": "18cc6f11a79050981aa30f1a4c76ad2e95321892", "url": "https://github.com/trinodb/trino/commit/18cc6f11a79050981aa30f1a4c76ad2e95321892", "message": "Add support for TopN to cost", "committedDate": "2020-09-01T06:52:55Z", "type": "forcePushed"}]}