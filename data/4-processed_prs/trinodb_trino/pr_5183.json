{"pr_number": 5183, "pr_title": "Send dynamic filters from coordinator to workers", "pr_createdAt": "2020-09-16T08:27:46Z", "pr_url": "https://github.com/trinodb/trino/pull/5183", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2MTIwNw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r489261207", "bodyText": "In this implementation we send dynamic filters only along with scheduling of splits. Ideally we should send dynamic filters as they become ready. Current approach works reasonably well for hive as it generates splits in batches.", "author": "raunaqmorarka", "createdAt": "2020-09-16T08:34:01Z", "path": "presto-main/src/main/java/io/prestosql/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -509,7 +516,11 @@ private synchronized void sendUpdate()\n                 fragment,\n                 sources,\n                 outputBuffers.get(),\n-                totalPartitions);\n+                totalPartitions,\n+                dynamicFilters.entrySet().stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzE2ODY3MA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r613168670", "bodyText": "This should be Map<DynamicFilterId, Domain>\nWill dynamic filters be sent with every TaskUpdateRequest?\nCurrently, we have a dedicated endpoint for fetching dynamic filters that keeps track of versioning. This way, we transfer only new (or updated) dynamic filters from workers to coordinator.\nThis scales better and allows us to send bigger DFs. Also we could potentially change protocol to be a binary one.\nWe might want to have similar approach when sending dynamic filters from coordinator to workers. Either we somehow refactor io.trino.server.remotetask.DynamicFiltersFetcher (e.g to work bi-directionally and keep track of worker version of coordinator DFs) or create another similar service.\nThe question is: does it make sense to send entire TaskUpdateRequest when DF is available or it's better to use another, dedicated communication channel?\nIn any case, I think initial DFs should be send in TaskUpdateRequest to reduce latency (if they are any)\nNote that I don't think worker needs to specifically keep version of coordinator DFs, but it can be coordinator that logically tracks which domains were actually received by workers.", "author": "sopel39", "createdAt": "2021-04-14T11:36:07Z", "path": "core/trino-main/src/main/java/io/trino/server/TaskUpdateRequest.java", "diffHunk": "@@ -38,6 +39,7 @@\n     private final List<TaskSource> sources;\n     private final OutputBuffers outputIds;\n     private final OptionalInt totalPartitions;\n+    private final Map<PlanNodeId, DynamicFilterUpdate> dynamicFilter;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzE3MTA5NA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r613171094", "bodyText": "not needed as io.trino.server.HttpRemoteTaskFactory already has DynamicFilterService", "author": "sopel39", "createdAt": "2021-04-14T11:40:14Z", "path": "core/trino-main/src/main/java/io/trino/execution/RemoteTaskFactory.java", "diffHunk": "@@ -35,5 +37,6 @@ RemoteTask createRemoteTask(\n             OptionalInt totalPartitions,\n             OutputBuffers outputBuffers,\n             PartitionedSplitCountTracker partitionedSplitCountTracker,\n+            Map<PlanNodeId, DynamicFilter> dynamicFilters,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzgxOTE2NQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r613819165", "bodyText": "i'm extracting dynamicFilters in SqlStageExecution and passing it down into RemoteTaskFactory to avoid repeating that work on creation of every task.", "author": "raunaqmorarka", "createdAt": "2021-04-15T07:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzE3MTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzIyOTg2Ng==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r613229866", "bodyText": "Using DynamicFiler for notifications is problematic because we don't know what domains changed specifically (take a look at io.trino.execution.DynamicFiltersCollector#updateDomains of how we send filters from worker to coordinator).\nWe should have a method like:\nDynamicFilterService#registerFragmentDynamicFiltersListener(\n  PlanFragment plan,\n  Consumer<Map<DynamicFilterId, Domain> newDynamicFilters> listener)\n\nIt will also be better testable this way", "author": "sopel39", "createdAt": "2021-04-14T13:07:03Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlStageExecution.java", "diffHunk": "@@ -167,6 +177,34 @@ private SqlStageExecution(\n             }\n         }\n         this.exchangeSources = fragmentToExchangeSource.build();\n+\n+        if (isEnableDynamicFiltering(stateMachine.getSession())) {\n+            TypeProvider typeProvider = TypeProvider.copyOf(stateMachine.getFragment().getSymbols());\n+            ImmutableMap.Builder<PlanNodeId, DynamicFilter> dynamicFiltersBuilder = ImmutableMap.builder();\n+            PlanNodeSearcher.searchFrom(stateMachine.getFragment().getRoot())\n+                    .where(node -> {\n+                        if (!(node instanceof FilterNode)) {\n+                            return false;\n+                        }\n+                        FilterNode filterNode = (FilterNode) node;\n+                        return filterNode.getSource() instanceof TableScanNode;\n+                    })\n+                    .findAll().stream().map(FilterNode.class::cast)\n+                    .forEach(filterNode -> {\n+                        List<DynamicFilters.Descriptor> dynamicFilters = extractDynamicFilters(filterNode.getPredicate()).getDynamicConjuncts();\n+                        if (!dynamicFilters.isEmpty()) {\n+                            TableScanNode tableScanNode = (TableScanNode) filterNode.getSource();\n+                            dynamicFiltersBuilder.put(\n+                                    tableScanNode.getId(),\n+                                    dynamicFilterService.createDynamicFilter(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzIzNjQ2MA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r613236460", "bodyText": "undo", "author": "sopel39", "createdAt": "2021-04-14T13:15:37Z", "path": "core/trino-main/src/main/java/io/trino/execution/scheduler/SqlQueryScheduler.java", "diffHunk": "@@ -183,8 +183,8 @@ private SqlQueryScheduler(\n         this.queryStateMachine = requireNonNull(queryStateMachine, \"queryStateMachine is null\");\n         this.executionPolicy = requireNonNull(executionPolicy, \"executionPolicy is null\");\n         this.schedulerStats = requireNonNull(schedulerStats, \"schedulerStats is null\");\n-        this.summarizeTaskInfo = summarizeTaskInfo;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzI2NjcwOA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r613266708", "bodyText": "We should pass filters back to io.trino.sql.planner.LocalDynamicFiltersCollector#collectDynamicFilterDomains.\nFor that it needs to be part of TaskContext.\nThe question is what to do with early DFs. DFs sending could be started in io.trino.server.remotetask.HttpRemoteTask.UpdateResponseHandler#success (assuming we have separate service for that).", "author": "sopel39", "createdAt": "2021-04-14T13:52:22Z", "path": "core/trino-main/src/main/java/io/trino/operator/TaskContext.java", "diffHunk": "@@ -107,6 +116,9 @@\n     private final MemoryTrackingContext taskMemoryContext;\n     private final DynamicFiltersCollector dynamicFiltersCollector;\n \n+    // Dynamic filters received from coordinator", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzMyODQ1Ng==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r613328456", "bodyText": "Does it mean there is just once chance to send DFs? If DFs were not present at HttpRemoteTask creation we would not send them later on?", "author": "sopel39", "createdAt": "2021-04-14T15:01:07Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -161,6 +164,8 @@\n \n     private final AtomicBoolean aborting = new AtomicBoolean(false);\n \n+    private final Map<PlanNodeId, DynamicFilter> dynamicFilters;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzgwNjY2OA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r613806668", "bodyText": "We're creating dynamicFilters in SqlStageExecution based on the DFs in the stage's plan fragment and that is passed down to HttpRemoteTask.\nIn HttpRemoteTask#sendUpdate we call DynamicFilter#getCurrentPredicate on the dynamicFilters entries to send the current predicate along with TaskUpdateRequest.", "author": "raunaqmorarka", "createdAt": "2021-04-15T07:01:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMzMyODQ1Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDU0NDE1OQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660544159", "bodyText": "call it outboundDynamicFilterIds", "author": "sopel39", "createdAt": "2021-06-29T11:56:31Z", "path": "core/trino-main/src/main/java/io/trino/execution/MemoryTrackingRemoteTaskFactory.java", "diffHunk": "@@ -49,6 +51,7 @@ public RemoteTask createRemoteTask(\n             OptionalInt totalPartitions,\n             OutputBuffers outputBuffers,\n             PartitionedSplitCountTracker partitionedSplitCountTracker,\n+            Set<DynamicFilterId> dynamicFilterIds,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDU0NDI5Ng==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660544296", "bodyText": "call it outboundDynamicFilterIds", "author": "sopel39", "createdAt": "2021-06-29T11:56:43Z", "path": "core/trino-main/src/main/java/io/trino/execution/RemoteTaskFactory.java", "diffHunk": "@@ -35,5 +37,6 @@ RemoteTask createRemoteTask(\n             OptionalInt totalPartitions,\n             OutputBuffers outputBuffers,\n             PartitionedSplitCountTracker partitionedSplitCountTracker,\n+            Set<DynamicFilterId> dynamicFilterIds,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDU0NDQ2NQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660544465", "bodyText": "call it outboundDynamicFilterIds", "author": "sopel39", "createdAt": "2021-06-29T11:57:00Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlStageExecution.java", "diffHunk": "@@ -107,6 +110,8 @@\n \n     private final ListenerManager<Set<Lifespan>> completedLifespansChangeListeners = new ListenerManager<>();\n \n+    private final Set<DynamicFilterId> dynamicFilterIds;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDU1NjM0NA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660556344", "bodyText": "use ImmutableSet.copyOf", "author": "sopel39", "createdAt": "2021-06-29T12:14:27Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -333,6 +347,14 @@ public void stageCannotScheduleMoreTasks(StageId stageId, int numberOfTasks)\n         executor.submit(() -> collectDynamicFilters(stageId, Optional.empty()));\n     }\n \n+    public static Set<DynamicFilterId> getInterStageConsumedDynamicFilters(PlanFragment plan)\n+    {\n+        // dynamic filters which are consumed by the given stage but produced by a different stage\n+        return difference(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDU2NTI1OA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660565258", "bodyText": "Call it getOutboundDynamicFilters (plus javadoc) or something similar. Current name is too specific and InterStageConsumedDynamic is really a detail.\nAlso, I already used interStageDynamicFilters within getLazyDynamicFilters", "author": "sopel39", "createdAt": "2021-06-29T12:26:38Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -333,6 +347,14 @@ public void stageCannotScheduleMoreTasks(StageId stageId, int numberOfTasks)\n         executor.submit(() -> collectDynamicFilters(stageId, Optional.empty()));\n     }\n \n+    public static Set<DynamicFilterId> getInterStageConsumedDynamicFilters(PlanFragment plan)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDU3MjIyNg==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660572226", "bodyText": "just use taskExecution.getTaskContext().addDynamicFilter(dynamicFilterDomains);", "author": "sopel39", "createdAt": "2021-06-29T12:35:48Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlTask.java", "diffHunk": "@@ -441,6 +450,7 @@ public TaskInfo updateTask(Session session, Optional<PlanFragment> fragment, Lis\n \n             if (taskExecution != null) {\n                 taskExecution.addSources(sources);\n+                taskExecution.addDynamicFilter(dynamicFilterDomains);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDU3ODM3OQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660578379", "bodyText": "Why do we have to merge local and coordinator dynamic filters?\nWe can just use existing getLocalDynamicFiltersCollector (we probably don't need io.trino.sql.planner.LocalDynamicFiltersCollector#register anymore)", "author": "sopel39", "createdAt": "2021-06-29T12:43:20Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -1760,7 +1780,42 @@ private DynamicFilter getDynamicFilter(\n             }\n \n             log.debug(\"[TableScan] Dynamic filters: %s\", dynamicFilters);\n-            return context.getDynamicFiltersCollector().createDynamicFilter(dynamicFilters, tableScanNode.getAssignments(), context.getTypes());\n+            DynamicFilter localDynamicFilter = context.getLocalDynamicFiltersCollector().createDynamicFilter(dynamicFilters, tableScanNode.getAssignments(), context.getTypes());\n+\n+            DynamicFilter coordinatorDynamicFilter = context.createCoordinatorDynamicFilter(dynamicFilters, tableScanNode, metadata, typeOperators);\n+            return new DynamicFilter() {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTE0NTUxNA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661145514", "bodyText": "ya, the merging is unnecessary now (it's left over from some previous iteration).\ni've simplified this now, one reason to keep LocalDynamicFiltersCollector#register is if we want to implement a flag for this change, then if the flag is off we need to avoid registering non-local DFs in LocalExecutionPlanner.\ni can remove it if we don't want to add the flag.", "author": "raunaqmorarka", "createdAt": "2021-06-30T05:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDU3ODM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY1OTI5Mg==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660659292", "bodyText": "remove this method, see d2f820c#r660572226", "author": "sopel39", "createdAt": "2021-06-29T14:13:06Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlTaskExecution.java", "diffHunk": "@@ -321,6 +323,11 @@ public void addSources(List<TaskSource> sources)\n         }\n     }\n \n+    public void addDynamicFilter(Map<DynamicFilterId, Domain> dynamicFilterDomains)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY2MjUxNA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660662514", "bodyText": "just skip \"already collected\" check in io.trino.sql.planner.LocalDynamicFiltersCollector#collectDynamicFilterDomains. We already skip it in io.trino.server.DynamicFilterService.DynamicFilterContext#addTaskDynamicFilters", "author": "sopel39", "createdAt": "2021-06-29T14:16:27Z", "path": "core/trino-main/src/main/java/io/trino/operator/TaskContext.java", "diffHunk": "@@ -590,4 +601,33 @@ public QueryContext getQueryContext()\n     {\n         return queryContext;\n     }\n+\n+    public void addDynamicFilter(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        if (dynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+        synchronized (coordinatorDynamicFilters) {\n+            ImmutableMap.Builder<DynamicFilterId, Domain> domainsForConsumer = ImmutableMap.builder();\n+            dynamicFilterDomains.forEach((dynamicFilterId, dynamicFilterDomain) -> {\n+                Domain previousDomain = coordinatorDynamicFilters.put(dynamicFilterId, dynamicFilterDomain);\n+                // Coordinator may re-send dynamicFilterDomain if sendUpdate request fails\n+                // It's possible that the request failed after the DF was already collected here\n+                if (previousDomain != null && previousDomain.equals(dynamicFilterDomain)) {\n+                    return;\n+                }\n+                verify(previousDomain == null, \"Dynamic filter %s already collected\", dynamicFilterId);\n+                domainsForConsumer.put(dynamicFilterId, dynamicFilterDomain);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY2ODg2Mg==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660668862", "bodyText": "Move io.trino.sql.planner.LocalExecutionPlanner.LocalExecutionPlanContext#dynamicFiltersCollector to TaskContext instead of extra layer of indirection", "author": "sopel39", "createdAt": "2021-06-29T14:22:30Z", "path": "core/trino-main/src/main/java/io/trino/operator/TaskContext.java", "diffHunk": "@@ -590,4 +601,33 @@ public QueryContext getQueryContext()\n     {\n         return queryContext;\n     }\n+\n+    public void addDynamicFilter(Map<DynamicFilterId, Domain> dynamicFilterDomains)\n+    {\n+        if (dynamicFilterDomains.isEmpty()) {\n+            return;\n+        }\n+        synchronized (coordinatorDynamicFilters) {\n+            ImmutableMap.Builder<DynamicFilterId, Domain> domainsForConsumer = ImmutableMap.builder();\n+            dynamicFilterDomains.forEach((dynamicFilterId, dynamicFilterDomain) -> {\n+                Domain previousDomain = coordinatorDynamicFilters.put(dynamicFilterId, dynamicFilterDomain);\n+                // Coordinator may re-send dynamicFilterDomain if sendUpdate request fails\n+                // It's possible that the request failed after the DF was already collected here\n+                if (previousDomain != null && previousDomain.equals(dynamicFilterDomain)) {\n+                    return;\n+                }\n+                verify(previousDomain == null, \"Dynamic filter %s already collected\", dynamicFilterId);\n+                domainsForConsumer.put(dynamicFilterId, dynamicFilterDomain);\n+            });\n+            coordinatorDynamicFilterConsumers.forEach(consumer -> consumer.accept(domainsForConsumer.build()));\n+        }\n+    }\n+\n+    public void addCoordinatorDynamicFiltersConsumer(Consumer<Map<DynamicFilterId, Domain>> consumer)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY3MDM4MA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660670380", "bodyText": "Make it accept Set<DynamicFilterId> dynamicFilters\ndomainConsumer -> consumer", "author": "sopel39", "createdAt": "2021-06-29T14:24:04Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -309,6 +313,16 @@ public boolean isAwaitable()\n         };\n     }\n \n+    public void registerDynamicFilterConsumer(QueryId queryId, DynamicFilterId dynamicFilterId, Consumer<Domain> domainConsumer)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY5Mzk2MQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660693961", "bodyText": "more accurate comment would be:\n// filter has already been collected\n\n// filter has been collected concurrently referred to broadcast join where any task that produced DF \"completed\" filter", "author": "sopel39", "createdAt": "2021-06-29T14:48:10Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -643,7 +668,24 @@ private DynamicFilterContext(\n             this.dynamicFilters = requireNonNull(dynamicFilters, \"dynamicFilters is null\");\n             this.lazyDynamicFilters = requireNonNull(lazyDynamicFilters, \"lazyDynamicFilters is null\");\n             this.replicatedDynamicFilters = requireNonNull(replicatedDynamicFilters, \"replicatedDynamicFilters is null\");\n-            dynamicFilters.forEach(filter -> taskDynamicFilters.put(filter, new ConcurrentHashMap<>()));\n+            dynamicFilters.forEach(filter -> {\n+                taskDynamicFilters.put(filter, new ConcurrentHashMap<>());\n+                dynamicFilterConsumers.put(filter, new ArrayList<>());\n+            });\n+        }\n+\n+        void addDynamicFilterConsumer(DynamicFilterId dynamicFilterId, Consumer<Domain> domainConsumer)\n+        {\n+            synchronized (dynamicFilterConsumersLock) {\n+                List<Consumer<Domain>> consumers = dynamicFilterConsumers.get(dynamicFilterId);\n+                if (consumers == null) {\n+                    // filter has been collected concurrently", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDY5NzI1OQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660697259", "bodyText": "callback should be outside of critical section", "author": "sopel39", "createdAt": "2021-06-29T14:51:40Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -643,7 +668,24 @@ private DynamicFilterContext(\n             this.dynamicFilters = requireNonNull(dynamicFilters, \"dynamicFilters is null\");\n             this.lazyDynamicFilters = requireNonNull(lazyDynamicFilters, \"lazyDynamicFilters is null\");\n             this.replicatedDynamicFilters = requireNonNull(replicatedDynamicFilters, \"replicatedDynamicFilters is null\");\n-            dynamicFilters.forEach(filter -> taskDynamicFilters.put(filter, new ConcurrentHashMap<>()));\n+            dynamicFilters.forEach(filter -> {\n+                taskDynamicFilters.put(filter, new ConcurrentHashMap<>());\n+                dynamicFilterConsumers.put(filter, new ArrayList<>());\n+            });\n+        }\n+\n+        void addDynamicFilterConsumer(DynamicFilterId dynamicFilterId, Consumer<Domain> domainConsumer)\n+        {\n+            synchronized (dynamicFilterConsumersLock) {\n+                List<Consumer<Domain>> consumers = dynamicFilterConsumers.get(dynamicFilterId);\n+                if (consumers == null) {\n+                    // filter has been collected concurrently\n+                    Optional.ofNullable(dynamicFilterSummaries.get(dynamicFilterId))\n+                            .ifPresent(domainConsumer);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDcwMjM4OA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660702388", "bodyText": "Why guard on separate object? Just guard on itself", "author": "sopel39", "createdAt": "2021-06-29T14:57:12Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -631,6 +653,9 @@ public String toString()\n         // when map value for given filter id is empty it means that dynamic filter has already been collected\n         // and no partial task domains are required\n         private final Map<DynamicFilterId, Map<TaskId, Domain>> taskDynamicFilters = new ConcurrentHashMap<>();\n+        @GuardedBy(\"dynamicFilterConsumersLock\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDcwMjY3Ng==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660702676", "bodyText": "callback should be called outside of critical section", "author": "sopel39", "createdAt": "2021-06-29T14:57:32Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -681,9 +723,16 @@ private void addDynamicFilters(Map<DynamicFilterId, List<Domain>> newDynamicFilt\n                     // filter has been collected concurrently\n                     return;\n                 }\n-                dynamicFilterSummaries.put(filter, union(domain));\n+                Domain dynamicFilterDomain = union(domain);\n+                dynamicFilterSummaries.put(filter, dynamicFilterDomain);\n                 Optional.ofNullable(lazyDynamicFilters.get(filter)).ifPresent(future -> future.set(null));\n                 dynamicFilterCollectionTime.put(filter, System.nanoTime());\n+                synchronized (dynamicFilterConsumersLock) {\n+                    List<Consumer<Domain>> consumers = dynamicFilterConsumers.remove(filter);\n+                    if (consumers != null) {\n+                        consumers.forEach(domainConsumer -> domainConsumer.accept(dynamicFilterDomain));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDc3NjI1MQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660776251", "bodyText": "call it outboundDynamicFilterIds", "author": "sopel39", "createdAt": "2021-06-29T16:21:51Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -201,6 +210,7 @@ public HttpRemoteTask(\n         requireNonNull(taskUpdateRequestCodec, \"taskUpdateRequestCodec is null\");\n         requireNonNull(partitionedSplitCountTracker, \"partitionedSplitCountTracker is null\");\n         requireNonNull(stats, \"stats is null\");\n+        requireNonNull(dynamicFilterIds, \"dynamicFilterIds is null\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDc3Nzk2OA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660777968", "bodyText": "taskDynamicFiltersCollector -> outboundDynamicFiltersCollector", "author": "sopel39", "createdAt": "2021-06-29T16:24:06Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -119,6 +123,10 @@\n     private final ContinuousTaskStatusFetcher taskStatusFetcher;\n     private final DynamicFiltersFetcher dynamicFiltersFetcher;\n \n+    private final DynamicFiltersCollector taskDynamicFiltersCollector;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTI3NzU3Mg==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661277572", "bodyText": "I don't think you pushed changes", "author": "sopel39", "createdAt": "2021-06-30T09:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDc3Nzk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTM4OTgwOQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661389809", "bodyText": "pushed this now", "author": "raunaqmorarka", "createdAt": "2021-06-30T11:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDc3Nzk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDc4MjU0OQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r660782549", "bodyText": "undo", "author": "sopel39", "createdAt": "2021-06-29T16:30:08Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -515,12 +536,21 @@ private synchronized void sendUpdate()\n     {\n         TaskStatus taskStatus = getTaskStatus();\n         // don't update if the task hasn't been started yet or if it is already finished\n-        if (!started.get() || !needsUpdate.get() || taskStatus.getState().isDone()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTI2MzUwNA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661263504", "bodyText": "Make it Consumer<Map<DynamicFilterId, Domain>> consumer", "author": "sopel39", "createdAt": "2021-06-30T08:53:41Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -309,6 +315,16 @@ public boolean isAwaitable()\n         };\n     }\n \n+    public void registerDynamicFilterConsumer(QueryId queryId, Set<DynamicFilterId> dynamicFilterIds, Consumer<Entry<DynamicFilterId, Domain>> consumer)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTI3MTMxMg==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661271312", "bodyText": "We could split dynamicFilterIds into collected and uncollected ones.\nThen we could have one callback for all collected ones. This way we would\nsave on number of callbacks and task update requests when DFs are already collected (e.g when new source stage tasks are added)", "author": "sopel39", "createdAt": "2021-06-30T09:03:59Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -643,7 +669,28 @@ private DynamicFilterContext(\n             this.dynamicFilters = requireNonNull(dynamicFilters, \"dynamicFilters is null\");\n             this.lazyDynamicFilters = requireNonNull(lazyDynamicFilters, \"lazyDynamicFilters is null\");\n             this.replicatedDynamicFilters = requireNonNull(replicatedDynamicFilters, \"replicatedDynamicFilters is null\");\n-            dynamicFilters.forEach(filter -> taskDynamicFilters.put(filter, new ConcurrentHashMap<>()));\n+            dynamicFilters.forEach(filter -> {\n+                taskDynamicFilters.put(filter, new ConcurrentHashMap<>());\n+                dynamicFilterConsumers.put(filter, new ArrayList<>());\n+            });\n+        }\n+\n+        void addDynamicFilterConsumer(Set<DynamicFilterId> dynamicFilterIds, Consumer<Entry<DynamicFilterId, Domain>> consumer)\n+        {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTI3NzI2OA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661277268", "bodyText": "similarly you could reduce number of callbacks by constructing\nMap<Consumer, Set<DynamicFilterId>> completedConsumers\n\nand then making just one callback per consumer", "author": "sopel39", "createdAt": "2021-06-30T09:12:15Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -681,9 +728,18 @@ private void addDynamicFilters(Map<DynamicFilterId, List<Domain>> newDynamicFilt\n                     // filter has been collected concurrently\n                     return;\n                 }\n-                dynamicFilterSummaries.put(filter, union(domain));\n+                Domain dynamicFilterDomain = union(domain);\n+                dynamicFilterSummaries.put(filter, dynamicFilterDomain);\n                 Optional.ofNullable(lazyDynamicFilters.get(filter)).ifPresent(future -> future.set(null));\n                 dynamicFilterCollectionTime.put(filter, System.nanoTime());\n+                List<Consumer<Entry<DynamicFilterId, Domain>>> consumers;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTI4Njk2NA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661286964", "bodyText": "extract this to separate method, e.g needsUpdate() or triggerUpdate()", "author": "sopel39", "createdAt": "2021-06-30T09:25:12Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -285,6 +295,18 @@ public HttpRemoteTask(\n                 }\n             });\n \n+            this.taskDynamicFiltersCollector = new DynamicFiltersCollector(() -> {\n+                synchronized (this) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTI4NzI0NA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661287244", "bodyText": "undo", "author": "sopel39", "createdAt": "2021-06-30T09:25:38Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -515,12 +537,21 @@ private synchronized void sendUpdate()\n     {\n         TaskStatus taskStatus = getTaskStatus();\n         // don't update if the task hasn't been started yet or if it is already finished\n-        if (!started.get() || !needsUpdate.get() || taskStatus.getState().isDone()) {\n+        if (!started.get() || taskStatus.getState().isDone()) {\n             return;\n         }\n \n         // if there is a request already running, wait for it to complete", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTI5MDQyNQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661290425", "bodyText": "You don't need any special action here apart:\nVersionedDynamicFilterDomains dynamicFilterDomains = taskDynamicFiltersCollector.acknowledgeAndGetNewDomains(sentDynamicFilterVersion);", "author": "sopel39", "createdAt": "2021-06-30T09:29:41Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -515,12 +537,21 @@ private synchronized void sendUpdate()\n     {\n         TaskStatus taskStatus = getTaskStatus();\n         // don't update if the task hasn't been started yet or if it is already finished\n-        if (!started.get() || !needsUpdate.get() || taskStatus.getState().isDone()) {\n+        if (!started.get() || taskStatus.getState().isDone()) {\n             return;\n         }\n \n         // if there is a request already running, wait for it to complete\n-        if (this.currentRequest != null && !this.currentRequest.isDone()) {\n+        // currentRequest is always cleared when request is complete\n+        if (currentRequest != null) {\n+            return;\n+        }\n+\n+        VersionedDynamicFilterDomains dynamicFilterDomains = taskDynamicFiltersCollector.acknowledgeAndGetNewDomains(sentDynamicFilterVersion);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTI5MTM4Nw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661291387", "bodyText": "remove", "author": "sopel39", "createdAt": "2021-06-30T09:30:59Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -515,12 +537,21 @@ private synchronized void sendUpdate()\n     {\n         TaskStatus taskStatus = getTaskStatus();\n         // don't update if the task hasn't been started yet or if it is already finished\n-        if (!started.get() || !needsUpdate.get() || taskStatus.getState().isDone()) {\n+        if (!started.get() || taskStatus.getState().isDone()) {\n             return;\n         }\n \n         // if there is a request already running, wait for it to complete\n-        if (this.currentRequest != null && !this.currentRequest.isDone()) {\n+        // currentRequest is always cleared when request is complete\n+        if (currentRequest != null) {\n+            return;\n+        }\n+\n+        VersionedDynamicFilterDomains dynamicFilterDomains = taskDynamicFiltersCollector.acknowledgeAndGetNewDomains(sentDynamicFilterVersion);\n+        if (!dynamicFilterDomains.getDynamicFilterDomains().isEmpty()) {\n+            needsUpdate.set(true);\n+        }\n+        if (!needsUpdate.get()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTMwNTIxMw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661305213", "bodyText": "add a comment what it means", "author": "sopel39", "createdAt": "2021-06-30T09:49:56Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -119,6 +123,10 @@\n     private final ContinuousTaskStatusFetcher taskStatusFetcher;\n     private final DynamicFiltersFetcher dynamicFiltersFetcher;\n \n+    private final DynamicFiltersCollector taskDynamicFiltersCollector;\n+    @GuardedBy(\"this\")\n+    private long sentDynamicFilterVersion = INITIAL_DYNAMIC_FILTERS_VERSION;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTMxMjQyNw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661312427", "bodyText": "I don't think it synchronizes on right this", "author": "sopel39", "createdAt": "2021-06-30T09:59:57Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -285,6 +295,18 @@ public HttpRemoteTask(\n                 }\n             });\n \n+            this.taskDynamicFiltersCollector = new DynamicFiltersCollector(() -> {\n+                synchronized (this) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTMxMzAzNQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661313035", "bodyText": "you should also acknowledgeAndGetNewDomains to clear pending DFs", "author": "sopel39", "createdAt": "2021-06-30T10:00:48Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -803,6 +840,7 @@ public void success(TaskInfo value)\n                         currentRequest = null;\n                         sendPlan.set(value.isNeedsPlan());\n                         currentRequestStartNanos = HttpRemoteTask.this.currentRequestStartNanos;\n+                        sentDynamicFilterVersion = currentRequestDynamicFilterVersion;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTMyNzA3NA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661327074", "bodyText": "note that this callback might be called some time after request is finished, which means that if outbound DF came in the meantime it will resend DFs. I'm not sure we can easily avoid it since it would require to wait for success callback to finish first before scheduling new update.\nMaybe we could keep in-flight DFs that would be sent only in case of failure.", "author": "sopel39", "createdAt": "2021-06-30T10:21:56Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -803,6 +840,7 @@ public void success(TaskInfo value)\n                         currentRequest = null;\n                         sendPlan.set(value.isNeedsPlan());\n                         currentRequestStartNanos = HttpRemoteTask.this.currentRequestStartNanos;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjE0ODE4NQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662148185", "bodyText": "This is being handled by the change to avoid starting next update until currentRequest != null\nThe success callback handler sets it back to null after taking a lock and the also updates sentDynamicFiltersVersion in critical section.", "author": "raunaqmorarka", "createdAt": "2021-07-01T09:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTMyNzA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTMyODYzNQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r661328635", "bodyText": "use sepatate feature toggle for enabling sending of DFs to workers since it increases communication overhead number_of_worker times.", "author": "sopel39", "createdAt": "2021-06-30T10:24:25Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlStageExecution.java", "diffHunk": "@@ -167,6 +171,7 @@ private SqlStageExecution(\n             }\n         }\n         this.exchangeSources = fragmentToExchangeSource.build();\n+        this.outboundDynamicFilterIds = getOutboundDynamicFilters(stateMachine.getFragment());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU2Mjg4Mg==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662562882", "bodyText": "please extract this change to separate commit", "author": "sopel39", "createdAt": "2021-07-01T20:11:51Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -520,7 +538,8 @@ private synchronized void sendUpdate()\n         }\n \n         // if there is a request already running, wait for it to complete\n-        if (this.currentRequest != null && !this.currentRequest.isDone()) {\n+        // currentRequest is always cleared when request is complete", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU2ODU5OQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662568599", "bodyText": "make it more explicit, e.g:\nenable_coordinator_dynamic_filters_distribution", "author": "sopel39", "createdAt": "2021-07-01T20:22:54Z", "path": "core/trino-main/src/main/java/io/trino/SystemSessionProperties.java", "diffHunk": "@@ -126,6 +126,7 @@\n     public static final String PREDICATE_PUSHDOWN_USE_TABLE_PROPERTIES = \"predicate_pushdown_use_table_properties\";\n     public static final String LATE_MATERIALIZATION = \"late_materialization\";\n     public static final String ENABLE_DYNAMIC_FILTERING = \"enable_dynamic_filtering\";\n+    public static final String ENABLE_DISTRIBUTE_DYNAMIC_FILTERS = \"enable_distribute_dynamic_filters\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU3MDYxNQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662570615", "bodyText": "Don't we need to check if DF are enabled in general too?", "author": "sopel39", "createdAt": "2021-07-01T20:25:03Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlStageExecution.java", "diffHunk": "@@ -167,6 +174,12 @@ private SqlStageExecution(\n             }\n         }\n         this.exchangeSources = fragmentToExchangeSource.build();\n+        if (distributeDynamicFilters) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjc1MTk4NA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662751984", "bodyText": "If DF is disabled, then the plan won't have any DFs and getOutboundDynamicFilters should come back empty", "author": "raunaqmorarka", "createdAt": "2021-07-02T05:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU3MDYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU3MTcyMA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662571720", "bodyText": "moving localDynamicFiltersCollector to TaskContext should be separate commit", "author": "sopel39", "createdAt": "2021-07-01T20:26:41Z", "path": "core/trino-main/src/main/java/io/trino/operator/TaskContext.java", "diffHunk": "@@ -107,6 +108,10 @@\n     private final MemoryTrackingContext taskMemoryContext;\n     private final DynamicFiltersCollector dynamicFiltersCollector;\n \n+    // The collector is shared with all subContexts to allow local dynamic filtering\n+    // with multiple table scans (e.g. co-located joins).\n+    private final LocalDynamicFiltersCollector localDynamicFiltersCollector;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU3MTgwOQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662571809", "bodyText": "update comment, subContexts is no longer relevant", "author": "sopel39", "createdAt": "2021-07-01T20:26:52Z", "path": "core/trino-main/src/main/java/io/trino/operator/TaskContext.java", "diffHunk": "@@ -107,6 +108,10 @@\n     private final MemoryTrackingContext taskMemoryContext;\n     private final DynamicFiltersCollector dynamicFiltersCollector;\n \n+    // The collector is shared with all subContexts to allow local dynamic filtering", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU3MzcyNw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662573727", "bodyText": "use getDynamicFiltersCollector", "author": "sopel39", "createdAt": "2021-07-01T20:30:29Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -677,12 +672,26 @@ public TypeProvider getTypes()\n \n         public LocalDynamicFiltersCollector getDynamicFiltersCollector()\n         {\n-            return dynamicFiltersCollector;\n+            return taskContext.getLocalDynamicFiltersCollector();\n         }\n \n         private void addLocalDynamicFilters(Map<DynamicFilterId, Domain> dynamicTupleDomain)\n         {\n-            dynamicFiltersCollector.collectDynamicFilterDomains(dynamicTupleDomain);\n+            taskContext.addDynamicFilter(dynamicTupleDomain);\n+        }\n+\n+        private void registerCoordinatorDynamicFilters(List<DynamicFilters.Descriptor> dynamicFilters)\n+        {\n+            if (!isEnableDistributeDynamicFilters(taskContext.getSession())) {\n+                return;\n+            }\n+            Set<DynamicFilterId> consumedFilterIds = dynamicFilters.stream()\n+                    .map(DynamicFilters.Descriptor::getId)\n+                    .collect(toImmutableSet());\n+            // Don't wait for coordinator to send a dynamic filter which is only collected locally\n+            LocalDynamicFiltersCollector dynamicFiltersCollector = taskContext.getLocalDynamicFiltersCollector();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU4NDAxNQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662584015", "bodyText": "This can't happen because of taskDynamicFilters.remove(filter) == null check before. This section will be executed only once", "author": "sopel39", "createdAt": "2021-07-01T20:50:27Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -676,14 +728,36 @@ private OptionalInt getNumberOfTasks(StageId stageId)\n \n         private void addDynamicFilters(Map<DynamicFilterId, List<Domain>> newDynamicFilters)\n         {\n+            SetMultimap<Consumer<Map<DynamicFilterId, Domain>>, DynamicFilterId> completedConsumers = HashMultimap.create();\n             newDynamicFilters.forEach((filter, domain) -> {\n                 if (taskDynamicFilters.remove(filter) == null) {\n                     // filter has been collected concurrently\n                     return;\n                 }\n-                dynamicFilterSummaries.put(filter, union(domain));\n+                Domain dynamicFilterDomain = union(domain);\n+                dynamicFilterSummaries.put(filter, dynamicFilterDomain);\n                 Optional.ofNullable(lazyDynamicFilters.get(filter)).ifPresent(future -> future.set(null));\n                 dynamicFilterCollectionTime.put(filter, System.nanoTime());\n+                List<Consumer<Map<DynamicFilterId, Domain>>> consumers;\n+                synchronized (dynamicFilterConsumers) {\n+                    consumers = dynamicFilterConsumers.remove(filter);\n+                    if (consumers == null) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU4NTk1Nw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662585957", "bodyText": "nit: please add a comment why it cannot be ConcurrentHashMap like the others", "author": "sopel39", "createdAt": "2021-07-01T20:54:25Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -631,6 +657,8 @@ public String toString()\n         // when map value for given filter id is empty it means that dynamic filter has already been collected\n         // and no partial task domains are required\n         private final Map<DynamicFilterId, Map<TaskId, Domain>> taskDynamicFilters = new ConcurrentHashMap<>();\n+        @GuardedBy(\"dynamicFilterConsumers\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU4OTk4Nw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662589987", "bodyText": "undo", "author": "sopel39", "createdAt": "2021-07-01T21:02:05Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -676,14 +728,36 @@ private OptionalInt getNumberOfTasks(StageId stageId)\n \n         private void addDynamicFilters(Map<DynamicFilterId, List<Domain>> newDynamicFilters)\n         {\n+            SetMultimap<Consumer<Map<DynamicFilterId, Domain>>, DynamicFilterId> completedConsumers = HashMultimap.create();\n             newDynamicFilters.forEach((filter, domain) -> {\n                 if (taskDynamicFilters.remove(filter) == null) {\n                     // filter has been collected concurrently\n                     return;\n                 }\n-                dynamicFilterSummaries.put(filter, union(domain));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU5MjQ2OA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662592468", "bodyText": "simplify:\nconsumer.accept(\n  dynamicFilterIds.stream()\n    .collect(toImmutableMap(identity(), filterId -> requireNotNull(dynamicFilterSummaries.get(filterId))))", "author": "sopel39", "createdAt": "2021-07-01T21:07:22Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -676,14 +728,36 @@ private OptionalInt getNumberOfTasks(StageId stageId)\n \n         private void addDynamicFilters(Map<DynamicFilterId, List<Domain>> newDynamicFilters)\n         {\n+            SetMultimap<Consumer<Map<DynamicFilterId, Domain>>, DynamicFilterId> completedConsumers = HashMultimap.create();\n             newDynamicFilters.forEach((filter, domain) -> {\n                 if (taskDynamicFilters.remove(filter) == null) {\n                     // filter has been collected concurrently\n                     return;\n                 }\n-                dynamicFilterSummaries.put(filter, union(domain));\n+                Domain dynamicFilterDomain = union(domain);\n+                dynamicFilterSummaries.put(filter, dynamicFilterDomain);\n                 Optional.ofNullable(lazyDynamicFilters.get(filter)).ifPresent(future -> future.set(null));\n                 dynamicFilterCollectionTime.put(filter, System.nanoTime());\n+                List<Consumer<Map<DynamicFilterId, Domain>>> consumers;\n+                synchronized (dynamicFilterConsumers) {\n+                    consumers = dynamicFilterConsumers.remove(filter);\n+                    if (consumers == null) {\n+                        return;\n+                    }\n+                }\n+                // dynamic filter updates are batched up per-consumer to reduce number of callbacks\n+                consumers.forEach(consumer -> completedConsumers.put(consumer, filter));\n+            });\n+            completedConsumers.asMap().forEach((consumer, dynamicFilterIds) -> {\n+                Map<DynamicFilterId, Domain> collectedDomain = dynamicFilterIds.stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU5MzA3Mw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662593073", "bodyText": "this cannot really happen since we just collected filter, requireNonNull is sufficient", "author": "sopel39", "createdAt": "2021-07-01T21:08:29Z", "path": "core/trino-main/src/main/java/io/trino/server/DynamicFilterService.java", "diffHunk": "@@ -676,14 +728,36 @@ private OptionalInt getNumberOfTasks(StageId stageId)\n \n         private void addDynamicFilters(Map<DynamicFilterId, List<Domain>> newDynamicFilters)\n         {\n+            SetMultimap<Consumer<Map<DynamicFilterId, Domain>>, DynamicFilterId> completedConsumers = HashMultimap.create();\n             newDynamicFilters.forEach((filter, domain) -> {\n                 if (taskDynamicFilters.remove(filter) == null) {\n                     // filter has been collected concurrently\n                     return;\n                 }\n-                dynamicFilterSummaries.put(filter, union(domain));\n+                Domain dynamicFilterDomain = union(domain);\n+                dynamicFilterSummaries.put(filter, dynamicFilterDomain);\n                 Optional.ofNullable(lazyDynamicFilters.get(filter)).ifPresent(future -> future.set(null));\n                 dynamicFilterCollectionTime.put(filter, System.nanoTime());\n+                List<Consumer<Map<DynamicFilterId, Domain>>> consumers;\n+                synchronized (dynamicFilterConsumers) {\n+                    consumers = dynamicFilterConsumers.remove(filter);\n+                    if (consumers == null) {\n+                        return;\n+                    }\n+                }\n+                // dynamic filter updates are batched up per-consumer to reduce number of callbacks\n+                consumers.forEach(consumer -> completedConsumers.put(consumer, filter));\n+            });\n+            completedConsumers.asMap().forEach((consumer, dynamicFilterIds) -> {\n+                Map<DynamicFilterId, Domain> collectedDomain = dynamicFilterIds.stream()\n+                        .map(filterId -> {\n+                            Domain domain = requireNonNull(\n+                                    dynamicFilterSummaries.get(filterId),\n+                                    () -> format(\"Missing dynamic filter %s\", filterId));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjU5NDQ2Ng==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662594466", "bodyText": "nit: would be great to add a comment why it needs to be synchronized (so that needsUpdate is not cleared in sendUpdate before actual request is sent)", "author": "sopel39", "createdAt": "2021-07-01T21:11:11Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -511,6 +523,12 @@ private void scheduleUpdate()\n         executor.execute(this::sendUpdate);\n     }\n \n+    private synchronized void triggerUpdate()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjYwNDQ2NQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662604465", "bodyText": "how does this relate to code below? It has nothing to do with waiting", "author": "sopel39", "createdAt": "2021-07-01T21:32:33Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -677,12 +672,26 @@ public TypeProvider getTypes()\n \n         public LocalDynamicFiltersCollector getDynamicFiltersCollector()\n         {\n-            return dynamicFiltersCollector;\n+            return taskContext.getLocalDynamicFiltersCollector();\n         }\n \n         private void addLocalDynamicFilters(Map<DynamicFilterId, Domain> dynamicTupleDomain)\n         {\n-            dynamicFiltersCollector.collectDynamicFilterDomains(dynamicTupleDomain);\n+            taskContext.addDynamicFilter(dynamicTupleDomain);\n+        }\n+\n+        private void registerCoordinatorDynamicFilters(List<DynamicFilters.Descriptor> dynamicFilters)\n+        {\n+            if (!isEnableDistributeDynamicFilters(taskContext.getSession())) {\n+                return;\n+            }\n+            Set<DynamicFilterId> consumedFilterIds = dynamicFilters.stream()\n+                    .map(DynamicFilters.Descriptor::getId)\n+                    .collect(toImmutableSet());\n+            // Don't wait for coordinator to send a dynamic filter which is only collected locally", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjYwNTA4OA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662605088", "bodyText": "this will fail if there are 2 table scans (e.g colocated joins) that consume same DF (io.trino.sql.planner.LocalDynamicFiltersCollector#register prevents duplicate registration)", "author": "sopel39", "createdAt": "2021-07-01T21:33:59Z", "path": "core/trino-main/src/main/java/io/trino/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -677,12 +672,26 @@ public TypeProvider getTypes()\n \n         public LocalDynamicFiltersCollector getDynamicFiltersCollector()\n         {\n-            return dynamicFiltersCollector;\n+            return taskContext.getLocalDynamicFiltersCollector();\n         }\n \n         private void addLocalDynamicFilters(Map<DynamicFilterId, Domain> dynamicTupleDomain)\n         {\n-            dynamicFiltersCollector.collectDynamicFilterDomains(dynamicTupleDomain);\n+            taskContext.addDynamicFilter(dynamicTupleDomain);\n+        }\n+\n+        private void registerCoordinatorDynamicFilters(List<DynamicFilters.Descriptor> dynamicFilters)\n+        {\n+            if (!isEnableDistributeDynamicFilters(taskContext.getSession())) {\n+                return;\n+            }\n+            Set<DynamicFilterId> consumedFilterIds = dynamicFilters.stream()\n+                    .map(DynamicFilters.Descriptor::getId)\n+                    .collect(toImmutableSet());\n+            // Don't wait for coordinator to send a dynamic filter which is only collected locally\n+            LocalDynamicFiltersCollector dynamicFiltersCollector = taskContext.getLocalDynamicFiltersCollector();\n+            dynamicFiltersCollector.register(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjc4MDk0OQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662780949", "bodyText": "would we have duplicate registration though ?\ni'm registering difference(consumedFilterIds, dynamicFiltersCollector.getRegisteredDynamicFilterIds())", "author": "raunaqmorarka", "createdAt": "2021-07-02T06:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjYwNTA4OA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjg5ODc4Mw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662898783", "bodyText": "nit: would it be possible to add test to TestHttpRemoteTask?", "author": "sopel39", "createdAt": "2021-07-02T10:06:11Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -520,7 +520,8 @@ private synchronized void sendUpdate()\n         }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzIwOTc1MQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663209751", "bodyText": "Added some testing around sending of DFs in TestHttpRemoteTask\nI didn't see a reasonable way to test the race condition though", "author": "raunaqmorarka", "createdAt": "2021-07-02T19:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjg5ODc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjg5OTE2NQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662899165", "bodyText": "before the callback has recorded the stats for current request. -> before the callback has recorded the stats for previous request.", "author": "sopel39", "createdAt": "2021-07-02T10:06:57Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -520,7 +520,8 @@ private synchronized void sendUpdate()\n         }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzEyNTQyNg==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663125426", "bodyText": "updated in #8460", "author": "raunaqmorarka", "createdAt": "2021-07-02T16:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjg5OTE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjkwMzY3OA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662903678", "bodyText": "you can just use isEnableCoordinatorDynamicFiltersDistribution(stateMachine.getSession())", "author": "sopel39", "createdAt": "2021-07-02T10:14:45Z", "path": "core/trino-main/src/main/java/io/trino/execution/SqlStageExecution.java", "diffHunk": "@@ -167,6 +174,12 @@ private SqlStageExecution(\n             }\n         }\n         this.exchangeSources = fragmentToExchangeSource.build();\n+        if (dynamicFiltersDistribution) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk0ODUyNw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662948527", "bodyText": "please add some comments what's happening in various stages in test", "author": "sopel39", "createdAt": "2021-07-02T11:37:14Z", "path": "core/trino-main/src/test/java/io/trino/server/TestDynamicFilterService.java", "diffHunk": "@@ -632,6 +638,120 @@ public void testMultipleColumnMapping()\n                         column2, domain)));\n     }\n \n+    @Test\n+    public void testDynamicFilterConsumer()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk0ODc3OQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662948779", "bodyText": "ditto", "author": "sopel39", "createdAt": "2021-07-02T11:37:42Z", "path": "core/trino-main/src/test/java/io/trino/server/TestDynamicFilterService.java", "diffHunk": "@@ -632,6 +638,120 @@ public void testMultipleColumnMapping()\n                         column2, domain)));\n     }\n \n+    @Test\n+    public void testDynamicFilterConsumer()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(metadata, typeOperators, newDirectExecutorService());\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        DynamicFilterId filterId2 = new DynamicFilterId(\"df2\");\n+        Set<DynamicFilterId> dynamicFilters = ImmutableSet.of(filterId1, filterId2);\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId = new StageId(queryId, 0);\n+\n+        dynamicFilterService.registerQuery(queryId, session, dynamicFilters, dynamicFilters, ImmutableSet.of());\n+        dynamicFilterService.stageCannotScheduleMoreTasks(stageId, 2);\n+\n+        Map<DynamicFilterId, Domain> consumerCollectedFilters = new HashMap<>();\n+        dynamicFilterService.registerDynamicFilterConsumer(\n+                queryId,\n+                dynamicFilters,\n+                (domains) -> domains.forEach((filter, domain) -> assertNull(consumerCollectedFilters.put(filter, domain))));\n+        assertTrue(consumerCollectedFilters.isEmpty());\n+\n+        dynamicFilterService.addTaskDynamicFilters(\n+                new TaskId(stageId, 0),\n+                ImmutableMap.of(filterId1, singleValue(INTEGER, 1L)));\n+        assertTrue(consumerCollectedFilters.isEmpty());\n+\n+        dynamicFilterService.addTaskDynamicFilters(\n+                new TaskId(stageId, 1),\n+                ImmutableMap.of(\n+                        filterId1, singleValue(INTEGER, 3L),\n+                        filterId2, singleValue(INTEGER, 2L)));\n+        assertEquals(consumerCollectedFilters, ImmutableMap.of(filterId1, multipleValues(INTEGER, ImmutableList.of(1L, 3L))));\n+\n+        Map<DynamicFilterId, Domain> secondConsumerCollectedFilters = new HashMap<>();\n+        dynamicFilterService.registerDynamicFilterConsumer(\n+                queryId,\n+                ImmutableSet.of(filterId1),\n+                (domains) -> domains.forEach((filter, domain) -> assertNull(secondConsumerCollectedFilters.put(filter, domain))));\n+        assertEquals(secondConsumerCollectedFilters, ImmutableMap.of(filterId1, multipleValues(INTEGER, ImmutableList.of(1L, 3L))));\n+\n+        dynamicFilterService.addTaskDynamicFilters(\n+                new TaskId(stageId, 0),\n+                ImmutableMap.of(filterId2, singleValue(INTEGER, 4L)));\n+        assertEquals(\n+                consumerCollectedFilters,\n+                ImmutableMap.of(\n+                        filterId1, multipleValues(INTEGER, ImmutableList.of(1L, 3L)),\n+                        filterId2, multipleValues(INTEGER, ImmutableList.of(2L, 4L))));\n+        assertEquals(\n+                secondConsumerCollectedFilters,\n+                ImmutableMap.of(filterId1, multipleValues(INTEGER, ImmutableList.of(1L, 3L))));\n+    }\n+\n+    @Test\n+    public void testDynamicFilterConsumerCallbackCount()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1MDYwOQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662950609", "bodyText": "separate commit", "author": "sopel39", "createdAt": "2021-07-02T11:41:33Z", "path": "plugin/trino-memory/src/test/java/io/trino/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -72,11 +72,16 @@ protected QueryRunner createQueryRunner()\n     {\n         return createMemoryQueryRunner(\n                 // Adjust DF limits to test edge cases\n-                ImmutableMap.of(\n-                        \"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\",\n-                        \"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\",\n-                        \"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\",\n-                        \"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\"),\n+                ImmutableMap.<String, String>builder()\n+                        .put(\"dynamic-filtering.small-broadcast.max-distinct-values-per-driver\", \"100\")\n+                        .put(\"dynamic-filtering.small-broadcast.range-row-limit-per-driver\", \"100\")\n+                        .put(\"dynamic-filtering.large-broadcast.max-distinct-values-per-driver\", \"100\")\n+                        .put(\"dynamic-filtering.large-broadcast.range-row-limit-per-driver\", \"100000\")\n+                        .put(\"dynamic-filtering.large-partitioned.max-distinct-values-per-driver\", \"100\")\n+                        .put(\"dynamic-filtering.large-partitioned.range-row-limit-per-driver\", \"100000\")\n+                        // disable semi join to inner join rewrite to test semi join operators explicitly", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1MTYyMA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662951620", "bodyText": "moving of method should be separate commit so it's easier to review (now diff is scattered)", "author": "sopel39", "createdAt": "2021-07-02T11:43:37Z", "path": "plugin/trino-memory/src/test/java/io/trino/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -437,24 +425,6 @@ private Session withPartitionedJoin()\n                 .collect(toImmutableList());\n     }\n \n-    @Test", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1MzczNQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662953735", "bodyText": "nit: I think it would be easier to just create arrays", "author": "sopel39", "createdAt": "2021-07-02T11:47:45Z", "path": "plugin/trino-memory/src/test/java/io/trino/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -383,46 +368,49 @@ public void testCrossJoinLargeBuildSideDynamicFiltering()\n         // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n         assertDynamicFiltering(\n                 \"SELECT * FROM orders o, customer c WHERE o.custkey < c.custkey AND c.name < 'Customer#000001000' AND o.custkey > 1000\",\n-                withBroadcastJoin(),\n+                noJoinReordering(BROADCAST),\n                 0,\n                 ORDERS_COUNT, CUSTOMER_COUNT);\n     }\n \n-    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, int... expectedOperatorRowsRead)\n+    @Test(timeOut = 30_000, dataProvider = \"joinDistributionTypes\")\n+    public void testJoinDynamicFilteringMultiJoin(JoinDistributionType joinDistributionType)\n     {\n-        ResultWithQueryId<MaterializedResult> result = getDistributedQueryRunner().executeWithQueryId(session, selectQuery);\n+        assertUpdate(\"DROP TABLE IF EXISTS t0\");\n+        assertUpdate(\"DROP TABLE IF EXISTS t1\");\n+        assertUpdate(\"DROP TABLE IF EXISTS t2\");\n+        assertUpdate(\"CREATE TABLE t0 (k0 integer, v0 real)\");\n+        assertUpdate(\"CREATE TABLE t1 (k1 integer, v1 real)\");\n+        assertUpdate(\"CREATE TABLE t2 (k2 integer, v2 real)\");\n+        assertUpdate(\"INSERT INTO t0 VALUES (1, 1.0)\", 1);\n+        assertUpdate(\"INSERT INTO t1 VALUES (1, 2.0)\", 1);\n+        assertUpdate(\"INSERT INTO t2 VALUES (1, 3.0)\", 1);\n \n-        assertEquals(result.getResult().getRowCount(), expectedRowCount);\n-        assertEquals(getOperatorRowsRead(getDistributedQueryRunner(), result.getQueryId()), Ints.asList(expectedOperatorRowsRead));\n+        assertQuery(\n+                noJoinReordering(joinDistributionType),\n+                \"SELECT k0, k1, k2 FROM t0, t1, t2 WHERE (k0 = k1) AND (k0 = k2) AND (v0 + v1 = v2)\",\n+                \"SELECT 1, 1, 1\");\n     }\n \n-    private Session withBroadcastJoin()\n+    @DataProvider\n+    public Object[][] joinDistributionTypes()\n     {\n-        return Session.builder(getSession())\n-                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, BROADCAST.name())\n-                .build();\n+        return Stream.of(BROADCAST, PARTITIONED)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NDQ2Nw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662954467", "bodyText": "separate commit", "author": "sopel39", "createdAt": "2021-07-02T11:49:15Z", "path": "testing/trino-tests/src/test/java/io/trino/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -118,52 +124,40 @@ protected QueryRunner createQueryRunner()\n                 .setSystemProperty(TASK_CONCURRENCY, \"2\")\n                 .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n                 .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name())\n+                // disable semi join to inner join rewrite to test semi join operators explicitly", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NTIwMQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662955201", "bodyText": "why it's removed?", "author": "sopel39", "createdAt": "2021-07-02T11:50:33Z", "path": "testing/trino-tests/src/test/java/io/trino/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -215,17 +209,6 @@ public void testIsNotDistinctFromJoinWithSelectiveBuildSide()\n                         Domain.onlyNull(BIGINT))));\n     }\n \n-    @Test(timeOut = 30_000)\n-    public void testBroadcastJoinWithSelectiveBuildSide()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk2NDk0Mw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662964943", "bodyText": "It's redundant with the parameterized testJoinWithEmptyBuildSide now", "author": "raunaqmorarka", "createdAt": "2021-07-02T12:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzgwMjU5Ng==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663802596", "bodyText": "selective is not exactly the same as empty. I think we should keep the test", "author": "sopel39", "createdAt": "2021-07-05T09:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzgxNDkyMw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663814923", "bodyText": "it's actually redundant with parameterised testJoinWithSelectiveBuildSide now", "author": "raunaqmorarka", "createdAt": "2021-07-05T10:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NTMyNQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662955325", "bodyText": "why it's removed?", "author": "sopel39", "createdAt": "2021-07-02T11:50:47Z", "path": "testing/trino-tests/src/test/java/io/trino/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -304,76 +289,52 @@ public void testRightJoinWithSelectiveBuildSide()\n                         singleValue(BIGINT, 1L))));\n     }\n \n-    @Test(timeOut = 30_000)\n-    public void testSemiJoinWithEmptyBuildSide()\n+    @Test(timeOut = 30_000, dataProvider = \"testJoinDistributionType\")\n+    public void testSemiJoinWithEmptyBuildSide(JoinDistributionType joinDistributionType, boolean coordinatorDynamicFiltersDistribution)\n     {\n         assertQueryDynamicFilters(\n+                noJoinReordering(joinDistributionType, coordinatorDynamicFiltersDistribution),\n                 \"SELECT * FROM lineitem WHERE lineitem.suppkey IN (SELECT supplier.suppkey FROM tpch.tiny.supplier WHERE supplier.name = 'abc')\",\n                 TupleDomain.none());\n     }\n \n-    @Test(timeOut = 30_000)\n-    public void testBroadcastSemiJoinWithEmptyBuildSide()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk2NzA5NA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662967094", "bodyText": "it's redundant with the parameterized testSemiJoinWithEmptyBuildSide now", "author": "raunaqmorarka", "createdAt": "2021-07-02T12:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NTMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NTkzNQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662955935", "bodyText": "we can expect expectedTableScanDynamicFilter for broadcast join too", "author": "sopel39", "createdAt": "2021-07-02T11:52:00Z", "path": "testing/trino-tests/src/test/java/io/trino/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -397,7 +367,14 @@ private void assertQueryDynamicFilters(@Language(\"SQL\") String query, TupleDomai\n \n     private void assertQueryDynamicFilters(Session session, @Language(\"SQL\") String query, TupleDomain<ColumnHandle> expectedTupleDomain)\n     {\n-        expectedDynamicFilter = expectedTupleDomain;\n+        expectedCoordinatorDynamicFilter = expectedTupleDomain;\n+        if (!isEnableCoordinatorDynamicFiltersDistribution(session) && getJoinDistributionType(session).equals(PARTITIONED)) {\n+            expectedTableScanDynamicFilter = TupleDomain.all();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk3OTIwMQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662979201", "bodyText": "we do, we're skipping it only when coordinator DF distribution is off and the join type is PARTITIONED", "author": "raunaqmorarka", "createdAt": "2021-07-02T12:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjk1NjcyMA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r662956720", "bodyText": "add a comment why it isn't racy (normally DF might be collected after page source is created)", "author": "sopel39", "createdAt": "2021-07-02T11:53:30Z", "path": "testing/trino-tests/src/test/java/io/trino/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -525,7 +502,26 @@ public ConnectorPageSource createPageSource(\n                         List<ColumnHandle> columns,\n                         DynamicFilter dynamicFilter)\n                 {\n-                    return new EmptyPageSource();\n+                    return new EmptyPageSource() {\n+                        @Override\n+                        public CompletableFuture<?> isBlocked()\n+                        {\n+                            return dynamicFilter.isBlocked();\n+                        }\n+\n+                        @Override\n+                        public boolean isFinished()\n+                        {\n+                            if (!dynamicFilter.isComplete()) {\n+                                return false;\n+                            }\n+\n+                            assertEquals(dynamicFilter.getCurrentPredicate(), expectedTableScanDynamicFilter);\n+                            assertTrue(dynamicFilter.isBlocked().isDone());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc2OTM0Ng==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663769346", "bodyText": "this should be separate commit", "author": "sopel39", "createdAt": "2021-07-05T09:11:36Z", "path": "core/trino-main/src/main/java/io/trino/server/remotetask/HttpRemoteTask.java", "diffHunk": "@@ -359,8 +375,7 @@ public synchronized void addSplits(Multimap<PlanNodeId, Split> splitsBySource)\n         updateSplitQueueSpace();\n \n         if (needsUpdate) {\n-            this.needsUpdate.set(true);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc5NTQwOA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663795408", "bodyText": "make it explicit call createPlan(filterId1, filterId1)", "author": "sopel39", "createdAt": "2021-07-05T09:47:22Z", "path": "core/trino-main/src/test/java/io/trino/server/TestDynamicFilterService.java", "diffHunk": "@@ -641,7 +768,27 @@ public void testSourceStageInnerLazyDynamicFilters()\n         assertEquals(getSourceStageInnerLazyDynamicFilters(createPlan(dynamicFilterId, SOURCE_DISTRIBUTION, REPARTITION)), ImmutableSet.of());\n     }\n \n+    @Test\n+    public void testOutboundDynamicFilters()\n+    {\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"filterId1\");\n+        DynamicFilterId filterId2 = new DynamicFilterId(\"filterId2\");\n+        assertEquals(getOutboundDynamicFilters(createPlan(filterId1, FIXED_HASH_DISTRIBUTION, REPLICATE)), ImmutableSet.of());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc5NjM3Mw==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663796373", "bodyText": "why limit bump?", "author": "sopel39", "createdAt": "2021-07-05T09:48:47Z", "path": "core/trino-main/src/test/java/io/trino/server/remotetask/TestHttpRemoteTask.java", "diffHunk": "@@ -194,7 +195,7 @@ public void testRegular()\n         httpRemoteTaskFactory.stop();\n     }\n \n-    @Test(timeOut = 30000)\n+    @Test(timeOut = 45_000)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzgxMzQ2MA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663813460", "bodyText": "we added an extra 15 seconds of possible waiting, i'm assuming the existing limit of 30 seconds was actually needed", "author": "raunaqmorarka", "createdAt": "2021-07-05T10:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc5NjM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc5OTE1MQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663799151", "bodyText": "are outbound DFs same as inbound DFs? Would it be possible to use different DFs for outbound DFs?\nIn fact, please try to add separate unit test (I don't think it will be that verbose)", "author": "sopel39", "createdAt": "2021-07-05T09:52:49Z", "path": "core/trino-main/src/test/java/io/trino/server/remotetask/TestHttpRemoteTask.java", "diffHunk": "@@ -211,20 +212,20 @@ public void testDynamicFilters()\n \n         TestingTaskResource testingTaskResource = new TestingTaskResource(new AtomicLong(System.nanoTime()), FailureScenario.NO_FAILURE);\n         DynamicFilterService dynamicFilterService = new DynamicFilterService(createTestMetadataManager(), new TypeOperators(), newDirectExecutorService());\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                TEST_SESSION,\n+                ImmutableSet.of(filterId1, filterId2),\n+                ImmutableSet.of(filterId1, filterId2),\n+                ImmutableSet.of());\n         HttpRemoteTaskFactory httpRemoteTaskFactory = createHttpRemoteTaskFactory(testingTaskResource, dynamicFilterService);\n-        RemoteTask remoteTask = createRemoteTask(httpRemoteTaskFactory);\n+        RemoteTask remoteTask = createRemoteTask(httpRemoteTaskFactory, ImmutableSet.of(filterId1, filterId2));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzg1NzYxNQ==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663857615", "bodyText": "i've separated the test and added dynamic filters directly through DynamicFilterService in that test", "author": "raunaqmorarka", "createdAt": "2021-07-05T11:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzc5OTE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzgwMzEwMg==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663803102", "bodyText": "keep the test since selective is not exactly same as empty", "author": "sopel39", "createdAt": "2021-07-05T09:58:24Z", "path": "testing/trino-tests/src/test/java/io/trino/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -306,76 +291,52 @@ public void testRightJoinWithSelectiveBuildSide()\n                         singleValue(BIGINT, 1L))));\n     }\n \n-    @Test(timeOut = 30_000)\n-    public void testSemiJoinWithEmptyBuildSide()\n+    @Test(timeOut = 30_000, dataProvider = \"testJoinDistributionType\")\n+    public void testSemiJoinWithEmptyBuildSide(JoinDistributionType joinDistributionType, boolean coordinatorDynamicFiltersDistribution)\n     {\n         assertQueryDynamicFilters(\n+                noJoinReordering(joinDistributionType, coordinatorDynamicFiltersDistribution),\n                 \"SELECT * FROM lineitem WHERE lineitem.suppkey IN (SELECT supplier.suppkey FROM tpch.tiny.supplier WHERE supplier.name = 'abc')\",\n                 TupleDomain.none());\n     }\n \n-    @Test(timeOut = 30_000)\n-    public void testBroadcastSemiJoinWithEmptyBuildSide()\n-    {\n-        assertQueryDynamicFilters(\n-                withBroadcastJoin(),\n-                \"SELECT * FROM lineitem WHERE lineitem.suppkey IN (SELECT supplier.suppkey FROM tpch.tiny.supplier WHERE supplier.name = 'abc')\",\n-                TupleDomain.none());\n-    }\n-\n-    @Test(timeOut = 30_000)\n-    public void testSemiJoinWithLargeBuildSide()\n+    @Test(timeOut = 30_000, dataProvider = \"testJoinDistributionType\")\n+    public void testSemiJoinWithLargeBuildSide(JoinDistributionType joinDistributionType, boolean coordinatorDynamicFiltersDistribution)\n     {\n         assertQueryDynamicFilters(\n+                noJoinReordering(joinDistributionType, coordinatorDynamicFiltersDistribution),\n                 \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM tpch.tiny.orders)\",\n                 TupleDomain.all());\n     }\n \n-    @Test(timeOut = 30_000)\n-    public void testBroadcastSemiJoinWithLargeBuildSide()\n-    {\n-        assertQueryDynamicFilters(\n-                withBroadcastJoin(),\n-                \"SELECT * FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM tpch.tiny.orders)\",\n-                TupleDomain.all());\n-    }\n-\n-    @Test(timeOut = 30_000)\n-    public void testSemiJoinWithSelectiveBuildSide()\n+    @Test(timeOut = 30_000, dataProvider = \"testJoinDistributionType\")\n+    public void testSemiJoinWithSelectiveBuildSide(JoinDistributionType joinDistributionType, boolean coordinatorDynamicFiltersDistribution)\n     {\n         assertQueryDynamicFilters(\n+                noJoinReordering(joinDistributionType, coordinatorDynamicFiltersDistribution),\n                 \"SELECT * FROM lineitem WHERE lineitem.suppkey IN (SELECT supplier.suppkey FROM tpch.tiny.supplier WHERE supplier.name = 'Supplier#000000001')\",\n                 TupleDomain.withColumnDomains(ImmutableMap.of(\n                         SUPP_KEY_HANDLE,\n                         singleValue(BIGINT, 1L))));\n     }\n \n-    @Test(timeOut = 30_000)\n-    public void testBroadcastSemiJoinWithSelectiveBuildSide()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzgxNTQ4NA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r663815484", "bodyText": "it's redundant with parameterised testSemiJoinWithSelectiveBuildSide now", "author": "raunaqmorarka", "createdAt": "2021-07-05T10:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzgwMzEwMg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDM4NTI4NA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r664385284", "bodyText": "could you also assert on testingTaskResource.getCreateOrUpdateCounter()?", "author": "sopel39", "createdAt": "2021-07-06T09:19:08Z", "path": "core/trino-main/src/test/java/io/trino/server/remotetask/TestHttpRemoteTask.java", "diffHunk": "@@ -269,14 +270,99 @@ public void testDynamicFilters()\n         dynamicFilterService.stop();\n     }\n \n+    @Test(timeOut = 30_000)\n+    public void testOutboundDynamicFilters()\n+            throws Exception\n+    {\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        DynamicFilterId filterId2 = new DynamicFilterId(\"df2\");\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"DF_SYMBOL1\", BIGINT);\n+        Symbol symbol2 = symbolAllocator.newSymbol(\"DF_SYMBOL2\", BIGINT);\n+        SymbolReference df1 = symbol1.toSymbolReference();\n+        SymbolReference df2 = symbol2.toSymbolReference();\n+        ColumnHandle handle1 = new TestingColumnHandle(\"column1\");\n+        ColumnHandle handle2 = new TestingColumnHandle(\"column2\");\n+        QueryId queryId = new QueryId(\"test\");\n+\n+        TestingTaskResource testingTaskResource = new TestingTaskResource(new AtomicLong(System.nanoTime()), FailureScenario.NO_FAILURE);\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(createTestMetadataManager(), new TypeOperators(), newDirectExecutorService());\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                TEST_SESSION,\n+                ImmutableSet.of(filterId1, filterId2),\n+                ImmutableSet.of(filterId1, filterId2),\n+                ImmutableSet.of());\n+        HttpRemoteTaskFactory httpRemoteTaskFactory = createHttpRemoteTaskFactory(testingTaskResource, dynamicFilterService);\n+        RemoteTask remoteTask = createRemoteTask(httpRemoteTaskFactory, ImmutableSet.of(filterId1, filterId2));\n+        testingTaskResource.setInitialTaskInfo(remoteTask.getTaskInfo());\n+\n+        dynamicFilterService.stageCannotScheduleMoreTasks(new StageId(queryId, 1), 1);\n+\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(\n+                        new DynamicFilters.Descriptor(filterId1, df1),\n+                        new DynamicFilters.Descriptor(filterId2, df2)),\n+                ImmutableMap.of(\n+                        symbol1, handle1,\n+                        symbol2, handle2),\n+                symbolAllocator.getTypes());\n+\n+        // make sure initial dynamic filters are collected\n+        CompletableFuture<?> future = dynamicFilter.isBlocked();\n+        dynamicFilterService.addTaskDynamicFilters(\n+                remoteTask.getTaskId(),\n+                ImmutableMap.of(filterId1, Domain.singleValue(BIGINT, 1L)));\n+        future.get();\n+        assertEquals(\n+                dynamicFilter.getCurrentPredicate(),\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        handle1, Domain.singleValue(BIGINT, 1L))));\n+\n+        remoteTask.start();\n+        // schedule a couple of splits to trigger task updates\n+        addSplit(remoteTask, testingTaskResource, 1);\n+        addSplit(remoteTask, testingTaskResource, 2);\n+        // make sure dynamic filter was sent in task updates only once\n+        assertGreaterThanOrEqual(testingTaskResource.getCreateOrUpdateCounter(), 3L);\n+        assertEquals(testingTaskResource.getDynamicFiltersSentCounter(), 1);\n+        assertEquals(\n+                testingTaskResource.getLatestDynamicFilterFromCoordinator(),\n+                ImmutableMap.of(filterId1, Domain.singleValue(BIGINT, 1L)));\n+\n+        future = dynamicFilter.isBlocked();\n+        dynamicFilterService.addTaskDynamicFilters(\n+                remoteTask.getTaskId(),\n+                ImmutableMap.of(filterId2, Domain.singleValue(BIGINT, 2L)));\n+        future.get();\n+        assertEquals(\n+                dynamicFilter.getCurrentPredicate(),\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        handle1, Domain.singleValue(BIGINT, 1L),\n+                        handle2, Domain.singleValue(BIGINT, 2L))));\n+\n+        // dynamic filter should be sent even though there were no further splits scheduled\n+        assertEventually(\n+                new Duration(15, SECONDS),\n+                () -> assertEquals(testingTaskResource.getDynamicFiltersSentCounter(), 2));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDM4NzY0Ng==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r664387646", "bodyText": "could you create remoteTask after DF is collected. This can happen when we add nodes and TS tasks are scheduled on them", "author": "sopel39", "createdAt": "2021-07-06T09:22:12Z", "path": "core/trino-main/src/test/java/io/trino/server/remotetask/TestHttpRemoteTask.java", "diffHunk": "@@ -269,14 +270,99 @@ public void testDynamicFilters()\n         dynamicFilterService.stop();\n     }\n \n+    @Test(timeOut = 30_000)\n+    public void testOutboundDynamicFilters()\n+            throws Exception\n+    {\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        DynamicFilterId filterId2 = new DynamicFilterId(\"df2\");\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"DF_SYMBOL1\", BIGINT);\n+        Symbol symbol2 = symbolAllocator.newSymbol(\"DF_SYMBOL2\", BIGINT);\n+        SymbolReference df1 = symbol1.toSymbolReference();\n+        SymbolReference df2 = symbol2.toSymbolReference();\n+        ColumnHandle handle1 = new TestingColumnHandle(\"column1\");\n+        ColumnHandle handle2 = new TestingColumnHandle(\"column2\");\n+        QueryId queryId = new QueryId(\"test\");\n+\n+        TestingTaskResource testingTaskResource = new TestingTaskResource(new AtomicLong(System.nanoTime()), FailureScenario.NO_FAILURE);\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(createTestMetadataManager(), new TypeOperators(), newDirectExecutorService());\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                TEST_SESSION,\n+                ImmutableSet.of(filterId1, filterId2),\n+                ImmutableSet.of(filterId1, filterId2),\n+                ImmutableSet.of());\n+        HttpRemoteTaskFactory httpRemoteTaskFactory = createHttpRemoteTaskFactory(testingTaskResource, dynamicFilterService);\n+        RemoteTask remoteTask = createRemoteTask(httpRemoteTaskFactory, ImmutableSet.of(filterId1, filterId2));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDM4OTkyNA==", "url": "https://github.com/trinodb/trino/pull/5183#discussion_r664389924", "bodyText": "add a comment, e.g: wait for splits to be received by remote task", "author": "sopel39", "createdAt": "2021-07-06T09:25:11Z", "path": "core/trino-main/src/test/java/io/trino/server/remotetask/TestHttpRemoteTask.java", "diffHunk": "@@ -302,7 +388,16 @@ private void runTest(FailureScenario failureScenario)\n         }\n     }\n \n-    private RemoteTask createRemoteTask(HttpRemoteTaskFactory httpRemoteTaskFactory)\n+    private void addSplit(RemoteTask remoteTask, TestingTaskResource testingTaskResource, int expectedSplitsCount)\n+            throws InterruptedException\n+    {\n+        Lifespan lifespan = Lifespan.driverGroup(3);\n+        remoteTask.addSplits(ImmutableMultimap.of(TABLE_SCAN_NODE_ID, new Split(new CatalogName(\"test\"), TestingSplit.createLocalSplit(), lifespan)));\n+        poll(() -> testingTaskResource.getTaskSource(TABLE_SCAN_NODE_ID) != null);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "12fa584b91dd912756c2842dc641d2420013751a", "url": "https://github.com/trinodb/trino/commit/12fa584b91dd912756c2842dc641d2420013751a", "message": "Move LocalDynamicFiltersCollector to TaskContext", "committedDate": "2021-07-08T11:14:26Z", "type": "commit"}, {"oid": "309ad201d21147a9a44dd747a877cdc66bfb7f17", "url": "https://github.com/trinodb/trino/commit/309ad201d21147a9a44dd747a877cdc66bfb7f17", "message": "Ensure semijoins dynamic filtering is covered by tests\n\nExplicitly disable optimizer.rewrite-filtering-semi-join-to-inner-join\nin dynamic filtering tests to ensure that the semi-join related\ntests actually test the code path of semi-join dynamic filtering.", "committedDate": "2021-07-08T11:14:26Z", "type": "commit"}, {"oid": "31dbd1b7cda0a875d44fdbebb452c5412c9d36dd", "url": "https://github.com/trinodb/trino/commit/31dbd1b7cda0a875d44fdbebb452c5412c9d36dd", "message": "Move testJoinDynamicFilteringMultiJoin above helper methods", "committedDate": "2021-07-08T11:14:26Z", "type": "commit"}, {"oid": "bd3e1cfbfafed6d4660bab50303d0a80b80905b0", "url": "https://github.com/trinodb/trino/commit/bd3e1cfbfafed6d4660bab50303d0a80b80905b0", "message": "Extract method HttpRemoteTask#triggerUpdate", "committedDate": "2021-07-08T11:14:26Z", "type": "commit"}, {"oid": "d7675e2c549649ab8db611990e8370e0287c02ce", "url": "https://github.com/trinodb/trino/commit/d7675e2c549649ab8db611990e8370e0287c02ce", "message": "Send dynamic filters from coordinator to workers", "committedDate": "2021-07-08T11:14:26Z", "type": "commit"}, {"oid": "d7675e2c549649ab8db611990e8370e0287c02ce", "url": "https://github.com/trinodb/trino/commit/d7675e2c549649ab8db611990e8370e0287c02ce", "message": "Send dynamic filters from coordinator to workers", "committedDate": "2021-07-08T11:14:26Z", "type": "forcePushed"}]}