{"pr_number": 3780, "pr_title": "Clean up datetime operators", "pr_createdAt": "2020-05-19T02:17:05Z", "pr_url": "https://github.com/trinodb/trino/pull/3780", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwMTkxNQ==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428601915", "bodyText": "We generally avoid UDF impl calling other UDF, to safeguard against incorrect error messages.\nAlso, datePlusIntervalDayToSecond and intervalDayToSecondPlusDate could produce different messages (when millis of day != 0), reversing param order.\nYou could address that by keeping arg validation inline and having a shared method for the actual math (or keeping everything inline (basically dropping this commit)).\nI am leaning toward \"validate inline and shared method for the math\".\ncc @electrum as this is a general comment about functions impls", "author": "findepi", "createdAt": "2020-05-21T11:42:27Z", "path": "presto-main/src/main/java/io/prestosql/type/DateTimeOperators.java", "diffHunk": "@@ -54,10 +54,7 @@ public static long datePlusIntervalDayToSecond(@SqlType(StandardTypes.DATE) long\n     @SqlType(StandardTypes.DATE)\n     public static long intervalDayToSecondPlusDate(@SqlType(StandardTypes.INTERVAL_DAY_TO_SECOND) long interval, @SqlType(StandardTypes.DATE) long date)\n     {\n-        if (MILLIS_OF_DAY.get(interval) != 0) {\n-            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, \"Cannot add hour, minutes or seconds to a date\");\n-        }\n-        return TimeUnit.MILLISECONDS.toDays(interval) + date;\n+        return datePlusIntervalDayToSecond(date, interval);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxODQyMg==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428718422", "bodyText": "We generally avoid UDF impl calling other UDF, to safeguard against incorrect error messages.\n\nThere's no hard and fast rule about that. I want to balance maintainability (i.e., having to fix bugs twice, change things twice, etc) with an explosion of methods (having 3 methods for everything seems overkill), especially when there's no validation involved. If there is, of course, it should be structured such that the message is appropriate for each implementation (e.g., see dateMinusIntervalDayToSecond). In this case, most methods don't do any validation.\n\nAlso, datePlusIntervalDayToSecond and intervalDayToSecondPlusDate could produce different messages (when millis of day != 0), reversing param order.\n\nIt doesn't and it shouldn't. DATE 'xxxx-xxx-xxx' + INTERVAL 'xxx' should not produce a different message than INTERVAL 'xxx' + DATE 'xxxx-xxx-xxx'. In both cases, an interval is being added to a date. The order of the operands is irrelevant.\n\nI am leaning toward \"validate inline and shared method for the math\".\n\nI agree, but only when it's deserved.", "author": "martint", "createdAt": "2020-05-21T15:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwMTkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwMjg0OQ==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428602849", "bodyText": "static createConstantAnalyzer", "author": "findepi", "createdAt": "2020-05-21T11:44:48Z", "path": "presto-main/src/main/java/io/prestosql/cost/ScalarStatsCalculator.java", "diffHunk": "@@ -112,8 +112,10 @@ protected SymbolStatsEstimate visitNullLiteral(NullLiteral node, Void context)\n         @Override\n         protected SymbolStatsEstimate visitLiteral(Literal node, Void context)\n         {\n-            Object value = evaluate(metadata, session.toConnectorSession(), node);\n-            Type type = ExpressionAnalyzer.createConstantAnalyzer(metadata, new AllowAllAccessControl(), session, ImmutableMap.of(), WarningCollector.NOOP).analyze(node, Scope.create());\n+            ExpressionAnalyzer analyzer = ExpressionAnalyzer.createConstantAnalyzer(metadata, new AllowAllAccessControl(), session, ImmutableMap.of(), WarningCollector.NOOP);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNDk5OQ==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428604999", "bodyText": "Removing isLegacyTimestamp check from here is not correct.\nThis code needs to verify the literal is correct (well formed valid value), and this depends on the isLegacyTimestamp + session zone.\nFor example 1970-01:01 00:30:00 is not a valid timestamp literal if legacy timestamp and session zone is Bahia_Banderas", "author": "findepi", "createdAt": "2020-05-21T11:49:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -824,25 +824,21 @@ protected Type visitTimeLiteral(TimeLiteral node, StackableAstVisitorContext<Con\n         @Override\n         protected Type visitTimestampLiteral(TimestampLiteral node, StackableAstVisitorContext<Context> context)\n         {\n+            Type type;\n             try {\n-                if (SystemSessionProperties.isLegacyTimestamp(session)) {\n-                    parseTimestampLiteral(session.getTimeZoneKey(), node.getValue());\n+                if (timestampHasTimeZone(node.getValue())) {\n+                    type = TIMESTAMP_WITH_TIME_ZONE;\n+                    parseTimestampWithTimeZone(node.getValue());\n                 }\n                 else {\n-                    parseTimestampLiteral(node.getValue());\n+                    type = TIMESTAMP;\n+                    parseTimestamp(node.getValue());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxOTgzNA==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428719834", "bodyText": "Good catch. Too bad it wasn't caught by any tests", "author": "martint", "createdAt": "2020-05-21T15:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNDk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTIyMw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428605223", "bodyText": "parse or convert?\n(i am not sure about this code, but you are using convert* on two cases below)", "author": "findepi", "createdAt": "2020-05-21T11:50:32Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/util/KafkaLoader.java", "diffHunk": "@@ -143,13 +143,13 @@ private Object convertValue(Object value, Type type)\n                 return value;\n             }\n             if (TIME.equals(type)) {\n-                return ISO8601_FORMATTER.print(parseTimeLiteral(timeZoneKey, (String) value));\n+                return ISO8601_FORMATTER.print(parseLegacyTime(timeZoneKey, (String) value));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMTEzMw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428621133", "bodyText": "BTW this looks like you're fixing a bug. Previously the code was using parseTimeLiteral which @return stack representation of legacy TIME or TIME WITH TIME ZONE type, depending on input, yet it was handling the return value as being of TIME type.\nAs such, this deserves a separate commit and a test.", "author": "findepi", "createdAt": "2020-05-21T12:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcyODI1OQ==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428728259", "bodyText": "I'm not really sure what the semantics would be. Let me look into it more closely.", "author": "martint", "createdAt": "2020-05-21T15:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5MzQwMg==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428893402", "bodyText": "BTW, there's no \"convert\" semantics for TIME. We either required a timezone (for TIME w/ TZ) or did not allow it (for TIME w/o TZ). We don't currently do the same thing as timestamps, where we allow optional TZ for TIMESTAMP w/ TZ.", "author": "martint", "createdAt": "2020-05-21T20:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5NDcyNg==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428894726", "bodyText": "I'll fix this in a separate commit (calling the appropriate parseXXX method), but I don't know how to add a test for this.", "author": "martint", "createdAt": "2020-05-21T20:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExNzgwNw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429117807", "bodyText": "I don't know either, but i would start from io.prestosql.plugin.kafka.TestMinimalFunctionality#createMessages (but in TestKafkaIntegrationSmokeTest class)", "author": "findepi", "createdAt": "2020-05-22T08:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwNTQ2Mw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428605463", "bodyText": "rnn", "author": "findepi", "createdAt": "2020-05-21T11:51:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralInterpreter.java", "diffHunk": "@@ -47,32 +54,38 @@\n import static io.prestosql.sql.analyzer.TypeSignatureProvider.fromTypes;\n import static io.prestosql.type.JsonType.JSON;\n import static io.prestosql.util.DateTimeUtils.parseDayTimeInterval;\n-import static io.prestosql.util.DateTimeUtils.parseTimeLiteral;\n-import static io.prestosql.util.DateTimeUtils.parseTimestampLiteral;\n+import static io.prestosql.util.DateTimeUtils.parseLegacyTime;\n+import static io.prestosql.util.DateTimeUtils.parseLegacyTimestamp;\n+import static io.prestosql.util.DateTimeUtils.parseTimeWithTimeZone;\n+import static io.prestosql.util.DateTimeUtils.parseTimeWithoutTimeZone;\n+import static io.prestosql.util.DateTimeUtils.parseTimestamp;\n+import static io.prestosql.util.DateTimeUtils.parseTimestampWithTimeZone;\n import static io.prestosql.util.DateTimeUtils.parseYearMonthInterval;\n \n public final class LiteralInterpreter\n {\n     private LiteralInterpreter() {}\n \n-    public static Object evaluate(Metadata metadata, ConnectorSession session, Expression node)\n+    public static Object evaluate(Metadata metadata, ConnectorSession session, Map<NodeRef<Expression>, Type> types, Expression node)\n     {\n         if (!(node instanceof Literal)) {\n             throw new IllegalArgumentException(\"node must be a Literal\");\n         }\n-        return new LiteralVisitor(metadata).process(node, session);\n+        return new LiteralVisitor(metadata, types).process(node, session);\n     }\n \n     private static class LiteralVisitor\n             extends AstVisitor<Object, ConnectorSession>\n     {\n         private final Metadata metadata;\n         private final InterpretedFunctionInvoker functionInvoker;\n+        private final Map<NodeRef<Expression>, Type> types;\n \n-        private LiteralVisitor(Metadata metadata)\n+        private LiteralVisitor(Metadata metadata, Map<NodeRef<Expression>, Type> types)\n         {\n             this.metadata = metadata;\n             this.functionInvoker = new InterpretedFunctionInvoker(metadata);\n+            this.types = types;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwOTQxOQ==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428609419", "bodyText": "Specify in the javadoc what happens when\n\ntimestamp is a gap in the provided zone (rejected or shifted)\nvalue contains a zone specifier -- is it converted to provided zone with \"same zone\" or \"same instant\" semantics\n\nand what happens if it cannot be", "author": "findepi", "createdAt": "2020-05-21T12:00:43Z", "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -143,58 +143,37 @@ public static String printDate(int days)\n     }\n \n     /**\n-     * Parse a string (optionally containing a zone) as a value of either TIMESTAMP or TIMESTAMP WITH TIME ZONE type.\n-     * <p>\n-     * For example: {@code \"2000-01-01 01:23:00\"} is parsed to TIMESTAMP {@code 2000-01-01T01:23:00}\n-     * and {@code \"2000-01-01 01:23:00 +01:23\"} is parsed to TIMESTAMP WITH TIME ZONE\n-     * {@code 2000-01-01T01:23:00.000+01:23}.\n-     *\n-     * @return stack representation of TIMESTAMP or TIMESTAMP WITH TIME ZONE type, depending on input\n+     * Parse a legacy TIMESTAMP type. The string is interpreted in {@code timeZoneKey} zone.\n      */\n-    public static long parseTimestampLiteral(String value)\n+    @Deprecated\n+    public static long parseLegacyTimestamp(TimeZoneKey timeZoneKey, String value)\n     {\n-        try {\n-            DateTime dateTime = TIMESTAMP_WITH_TIME_ZONE_FORMATTER.parseDateTime(value);\n-            return packDateTimeWithZone(dateTime);\n-        }\n-        catch (Exception e) {\n-            return TIMESTAMP_WITHOUT_TIME_ZONE_FORMATTER.parseMillis(value);\n-        }\n+        return LEGACY_TIMESTAMP_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n     }\n \n     /**\n-     * Parse a string (optionally containing a zone) as a value of either TIMESTAMP or TIMESTAMP WITH TIME ZONE type.\n-     * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n-     *\n-     * @return stack representation of legacy TIMESTAMP or TIMESTAMP WITH TIME ZONE type, depending on input\n-     * @deprecated applicable in legacy timestamp semantics only\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type using legacy semantics.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMTYxOQ==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428621619", "bodyText": "redundant else, below too", "author": "findepi", "createdAt": "2020-05-21T12:29:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralInterpreter.java", "diffHunk": "@@ -151,27 +164,38 @@ protected Object visitGenericLiteral(GenericLiteral node, ConnectorSession sessi\n         @Override\n         protected Long visitTimeLiteral(TimeLiteral node, ConnectorSession session)\n         {\n-            if (session.isLegacyTimestamp()) {\n-                return parseTimeLiteral(session.getTimeZoneKey(), node.getValue());\n+            Type type = types.get(NodeRef.of(node));\n+\n+            if (type instanceof TimeType) {\n+                if (session.isLegacyTimestamp()) {\n+                    return parseLegacyTime(session.getTimeZoneKey(), node.getValue());\n+                }\n+                return parseTimeWithoutTimeZone(node.getValue());\n+            }\n+            else if (type instanceof TimeWithTimeZoneType) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMTcxOQ==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428621719", "bodyText": "redundant else", "author": "findepi", "createdAt": "2020-05-21T12:29:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralInterpreter.java", "diffHunk": "@@ -151,27 +164,38 @@ protected Object visitGenericLiteral(GenericLiteral node, ConnectorSession sessi\n         @Override\n         protected Long visitTimeLiteral(TimeLiteral node, ConnectorSession session)\n         {\n-            if (session.isLegacyTimestamp()) {\n-                return parseTimeLiteral(session.getTimeZoneKey(), node.getValue());\n+            Type type = types.get(NodeRef.of(node));\n+\n+            if (type instanceof TimeType) {\n+                if (session.isLegacyTimestamp()) {\n+                    return parseLegacyTime(session.getTimeZoneKey(), node.getValue());\n+                }\n+                return parseTimeWithoutTimeZone(node.getValue());\n+            }\n+            else if (type instanceof TimeWithTimeZoneType) {\n+                return parseTimeWithTimeZone(node.getValue());\n             }\n             else {\n-                return parseTimeLiteral(node.getValue());\n+                throw new IllegalStateException(\"Unexpected type: \" + type);\n             }\n         }\n \n         @Override\n         protected Long visitTimestampLiteral(TimestampLiteral node, ConnectorSession session)\n         {\n-            try {\n+            Type type = types.get(NodeRef.of(node));\n+\n+            if (type instanceof TimestampType) {\n                 if (session.isLegacyTimestamp()) {\n-                    return parseTimestampLiteral(session.getTimeZoneKey(), node.getValue());\n-                }\n-                else {\n-                    return parseTimestampLiteral(node.getValue());\n+                    return parseLegacyTimestamp(session.getTimeZoneKey(), node.getValue());\n                 }\n+                return parseTimestamp(node.getValue());\n             }\n-            catch (RuntimeException e) {\n-                throw semanticException(INVALID_LITERAL, node, \"'%s' is not a valid timestamp literal\", node.getValue());\n+            else if (type instanceof TimestampWithTimeZoneType) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyNDk2NA==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428624964", "bodyText": "This is a javadoc of something else, not this method.", "author": "findepi", "createdAt": "2020-05-21T12:36:39Z", "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -217,19 +196,35 @@ public static long parseTimestampWithoutTimeZone(String value)\n         }\n     }\n \n+    public static long parseTimestampWithTimeZone(String value)\n+    {\n+        DateTime dateTime = TIMESTAMP_WITH_TIME_ZONE_FORMATTER.withOffsetParsed().parseDateTime(value);\n+        return packDateTimeWithZone(dateTime);\n+    }\n+\n     /**\n-     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type.\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP WITH TIME ZONE type.\n      * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n+     * <p>\n+     * For example: {@code \"2000-01-01 01:23:00\"} is parsed to TIMESTAMP WITH TIME ZONE\n+     * {@code 2000-01-01T01:23:00 <provided zone>} and {@code \"2000-01-01 01:23:00 +01:23\"}\n+     * is parsed to TIMESTAMP WITH TIME ZONE {@code 2000-01-01T01:23:00.000+01:23}.\n      *\n-     * @return stack representation of legacy TIMESTAMP type\n-     * @deprecated applicable in legacy timestamp semantics only\n+     * @return stack representation of TIMESTAMP WITH TIME ZONE type\n      */\n-    @Deprecated\n-    public static long parseTimestampWithoutTimeZone(TimeZoneKey timeZoneKey, String value)\n+    public static long convertToTimestampWithTimeZone(TimeZoneKey timeZoneKey, String timestampWithTimeZone)\n     {\n-        return TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n+        DateTime dateTime = TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).withOffsetParsed().parseDateTime(timestampWithTimeZone);\n+        return packDateTimeWithZone(dateTime);\n     }\n \n+    /**\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type.\n+     * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n+     *\n+     * @return stack representation of legacy TIMESTAMP type\n+     * @deprecated applicable in legacy timestamp semantics only\n+     */", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyNTUxMw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428625513", "bodyText": "The code here used to be known as parseTimestampWithTimeZone(TimeZoneKey timeZoneKey, String timestampWithTimeZone), but in the diff it appears as a new code.", "author": "findepi", "createdAt": "2020-05-21T12:37:55Z", "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -217,19 +196,35 @@ public static long parseTimestampWithoutTimeZone(String value)\n         }\n     }\n \n+    public static long parseTimestampWithTimeZone(String value)\n+    {\n+        DateTime dateTime = TIMESTAMP_WITH_TIME_ZONE_FORMATTER.withOffsetParsed().parseDateTime(value);\n+        return packDateTimeWithZone(dateTime);\n+    }\n+\n     /**\n-     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type.\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP WITH TIME ZONE type.\n      * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n+     * <p>\n+     * For example: {@code \"2000-01-01 01:23:00\"} is parsed to TIMESTAMP WITH TIME ZONE\n+     * {@code 2000-01-01T01:23:00 <provided zone>} and {@code \"2000-01-01 01:23:00 +01:23\"}\n+     * is parsed to TIMESTAMP WITH TIME ZONE {@code 2000-01-01T01:23:00.000+01:23}.\n      *\n-     * @return stack representation of legacy TIMESTAMP type\n-     * @deprecated applicable in legacy timestamp semantics only\n+     * @return stack representation of TIMESTAMP WITH TIME ZONE type\n      */\n-    @Deprecated\n-    public static long parseTimestampWithoutTimeZone(TimeZoneKey timeZoneKey, String value)\n+    public static long convertToTimestampWithTimeZone(TimeZoneKey timeZoneKey, String timestampWithTimeZone)\n     {\n-        return TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n+        DateTime dateTime = TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).withOffsetParsed().parseDateTime(timestampWithTimeZone);\n+        return packDateTimeWithZone(dateTime);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc1ODQ1Nw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428758457", "bodyText": "Ah, that's because I inadvertently moved methods around. I'll restore the order to make the diff easier to review.", "author": "martint", "createdAt": "2020-05-21T16:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyNTUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyNjE4MA==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428626180", "bodyText": "Fix legacy/new timestamp cast to json\n\nThis should probably be \"Fix timestamp CAST to JSON in new semantics\" or something, as you are not fixing anything in the legacy semantics (right?)", "author": "findepi", "createdAt": "2020-05-21T12:39:20Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/JsonOperators.java", "diffHunk": "@@ -340,7 +340,12 @@ public static Slice castFromTimestamp(ConnectorSession session, @SqlType(TIMESTA\n         try {\n             SliceOutput output = new DynamicSliceOutput(25);\n             try (JsonGenerator jsonGenerator = createJsonGenerator(JSON_FACTORY, output)) {\n-                jsonGenerator.writeString(printTimestampWithoutTimeZone(session.getTimeZoneKey(), value));\n+                if (session.isLegacyTimestamp()) {\n+                    jsonGenerator.writeString(printTimestampWithoutTimeZone(session.getTimeZoneKey(), value));\n+                }\n+                else {\n+                    jsonGenerator.writeString(printTimestampWithoutTimeZone(value));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMjc5Nw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r428732797", "bodyText": "Yes", "author": "martint", "createdAt": "2020-05-21T15:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyNjE4MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExNzk1NA==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429117954", "bodyText": "Same in RedisLoader (there is same code there)", "author": "findepi", "createdAt": "2020-05-22T08:37:58Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/util/KafkaLoader.java", "diffHunk": "@@ -143,7 +143,7 @@ private Object convertValue(Object value, Type type)\n                 return value;\n             }\n             if (TIME.equals(type)) {\n-                return ISO8601_FORMATTER.print(parseTimeLiteral(timeZoneKey, (String) value));\n+                return ISO8601_FORMATTER.print(parseTimeWithoutTimeZone(timeZoneKey, (String) value));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExODk1Nw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429118957", "bodyText": "I assume the changes in this class in fixup: Clarify parsing of timestamps and time types are just reorder.", "author": "findepi", "createdAt": "2020-05-22T08:40:11Z", "path": "presto-main/src/main/java/io/prestosql/util/DateTimeUtils.java", "diffHunk": "@@ -196,35 +184,42 @@ public static long convertToTimestamp(String value)\n         }\n     }\n \n-    public static long parseTimestampWithTimeZone(String value)\n+    /**\n+     * Parse a legacy TIMESTAMP type. The string is interpreted in {@code timeZoneKey} zone.\n+     */\n+    @Deprecated\n+    public static long parseLegacyTimestamp(TimeZoneKey timeZoneKey, String value)\n     {\n-        DateTime dateTime = TIMESTAMP_WITH_TIME_ZONE_FORMATTER.withOffsetParsed().parseDateTime(value);\n-        return packDateTimeWithZone(dateTime);\n+        return LEGACY_TIMESTAMP_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n     }\n \n     /**\n-     * Parse a string (optionally containing a zone) as a value of TIMESTAMP WITH TIME ZONE type.\n+     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type using legacy semantics.\n      * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n-     * <p>\n-     * For example: {@code \"2000-01-01 01:23:00\"} is parsed to TIMESTAMP WITH TIME ZONE\n-     * {@code 2000-01-01T01:23:00 <provided zone>} and {@code \"2000-01-01 01:23:00 +01:23\"}\n-     * is parsed to TIMESTAMP WITH TIME ZONE {@code 2000-01-01T01:23:00.000+01:23}.\n-     *\n-     * @return stack representation of TIMESTAMP WITH TIME ZONE type\n+     * If the timestamp is in a gap in the provided timezone, the method throws an exception.\n      */\n-    public static long convertToTimestampWithTimeZone(TimeZoneKey timeZoneKey, String timestampWithTimeZone)\n+    @Deprecated\n+    public static long convertToLegacyTimestamp(TimeZoneKey timeZoneKey, String value)\n     {\n-        DateTime dateTime = TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).withOffsetParsed().parseDateTime(timestampWithTimeZone);\n-        return packDateTimeWithZone(dateTime);\n+        return TIMESTAMP_WITH_OR_WITHOUT_TIME_ZONE_FORMATTER.withChronology(getChronology(timeZoneKey)).parseMillis(value);\n     }\n \n     /**\n-     * Parse a string (optionally containing a zone) as a value of TIMESTAMP type.\n-     * If the string doesn't specify a zone, it is interpreted in {@code timeZoneKey} zone.\n+     * Parse a string as a value of TIMESTAMP type.\n      *\n-     * @return stack representation of legacy TIMESTAMP type\n-     * @deprecated applicable in legacy timestamp semantics only\n+     * @return stack representation of TIMESTAMP type\n      */\n+    public static long parseTimestamp(String value)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4NTQyMQ==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429285421", "bodyText": "Yes, it's easier to see once I squash the fixup commit.", "author": "martint", "createdAt": "2020-05-22T14:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5Mzk1MA==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429293950", "bodyText": "to be clear: I am not questioning this. just letting know i passed over this \"without deep read\"", "author": "findepi", "createdAt": "2020-05-22T14:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxNjg2Mw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429316863", "bodyText": "Yup, got it. Take a look now. I squashed the fixups, so now it should be clear what the actual changes are in that original commit.", "author": "martint", "createdAt": "2020-05-22T15:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExODk1Nw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxMTc1NA==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429311754", "bodyText": "Use a zone different from test jvm zone (to cover the fact that jvm zone doesn't impact this).\neg Vilnius\nhttps://github.com/prestosql/presto/blob/ca878d471740c07155ea29fb74fe8be0ba855a68/presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java#L129-L130\n(i used Bahia in my previous comment, because i remember when some gap is in Bahia, sorry for misguiding you)", "author": "findepi", "createdAt": "2020-05-22T15:24:16Z", "path": "presto-main/src/test/java/io/prestosql/type/TestTimestampLegacy.java", "diffHunk": "@@ -62,4 +69,17 @@ public void testCastFromSlice()\n                 TIMESTAMP,\n                 sqlTimestampOf(2001, 1, 21, 9, 0, 0, 0, session));\n     }\n+\n+    @Test\n+    public void testInvalidLiteral()\n+    {\n+        Session session = testSessionBuilder()\n+                .setSystemProperty(\"legacy_timestamp\", \"true\")\n+                .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(\"America/Bahia_Banderas\"))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyMDUzMg==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429320532", "bodyText": "Does it matter? We rely on other tests to ensure that the session timezone is being respected. This is just making sure that \"assuming session timezone is being respected => this timestamp is invalid\". If the session timezone is not being respected and the test passes due to VM timezone, then that should trigger failures elsewhere.", "author": "martint", "createdAt": "2020-05-22T15:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxMTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0NzMzMw==", "url": "https://github.com/trinodb/trino/pull/3780#discussion_r429447333", "bodyText": "It does matter. For example timestamp could be detected as invalid if it's invalid in JVM zone, but then could be shifted if it is invalid in the session zone.\nActually, i hope we also do have a test that parses timestamp being  a gap in JVM zone (but not in the session zone) and verifies it was succesful. We definitely do this in connector tests, but not sure if here.", "author": "findepi", "createdAt": "2020-05-22T20:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMxMTc1NA=="}], "type": "inlineReview"}, {"oid": "8cb5152f82d4cd888013bfd87a13cf55c2914a20", "url": "https://github.com/trinodb/trino/commit/8cb5152f82d4cd888013bfd87a13cf55c2914a20", "message": "Fix parsing of time in Kafka and Redis\n\nparseTimeLiteral handles both time w/o timezone and time w/ timezone and\nreturns a value of the corresponding type. This is not appropriate for\nthis callsite, since we know the value has to be of type time w/o timezone.", "committedDate": "2020-05-24T00:59:40Z", "type": "commit"}, {"oid": "89aac4ea636cb49cabb0b893e8fff191042e7d76", "url": "https://github.com/trinodb/trino/commit/89aac4ea636cb49cabb0b893e8fff191042e7d76", "message": "Add test for invalid legacy timestamp literal", "committedDate": "2020-05-24T01:27:57Z", "type": "commit"}, {"oid": "0f95dd21c55ca102d3f3379b0ee3f7eead6578b2", "url": "https://github.com/trinodb/trino/commit/0f95dd21c55ca102d3f3379b0ee3f7eead6578b2", "message": "Clarify variable names in DateTimeOperators", "committedDate": "2020-05-24T01:27:57Z", "type": "commit"}, {"oid": "77c8b116cd2219678d809ecd0f548e812130f92e", "url": "https://github.com/trinodb/trino/commit/77c8b116cd2219678d809ecd0f548e812130f92e", "message": "Simplify implementation of datetime operations\n\nImplement subtractions in terms of addition with a negative term,\nand commutative variants in terms of a canonical implementation.", "committedDate": "2020-05-24T01:27:57Z", "type": "commit"}, {"oid": "753d7c77531eaebc83ab0ea92e2be2557f483dc9", "url": "https://github.com/trinodb/trino/commit/753d7c77531eaebc83ab0ea92e2be2557f483dc9", "message": "Clarify parsing of timestamps and time types\n\nSeparate between parse (strict) vs convert (which can include a timezone) for timestamp types.\nParsing is used when we know it's a timestamp. convertXXX is used for the purpose of casting\nfrom a datetime string to a timestamp.", "committedDate": "2020-05-24T01:27:57Z", "type": "commit"}, {"oid": "be8b2593cab6430f8b64409fb837598f48b72c05", "url": "https://github.com/trinodb/trino/commit/be8b2593cab6430f8b64409fb837598f48b72c05", "message": "Fix timestamp CAST to JSON in new semantics", "committedDate": "2020-05-24T01:27:57Z", "type": "commit"}, {"oid": "52679d0206e32d0e6a256652be4415c2e5c0d01b", "url": "https://github.com/trinodb/trino/commit/52679d0206e32d0e6a256652be4415c2e5c0d01b", "message": "Reorder methods in DateTimeUtils", "committedDate": "2020-05-24T01:27:57Z", "type": "commit"}, {"oid": "52679d0206e32d0e6a256652be4415c2e5c0d01b", "url": "https://github.com/trinodb/trino/commit/52679d0206e32d0e6a256652be4415c2e5c0d01b", "message": "Reorder methods in DateTimeUtils", "committedDate": "2020-05-24T01:27:57Z", "type": "forcePushed"}]}