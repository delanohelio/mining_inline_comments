{"pr_number": 4477, "pr_title": "Add Kafka Json encoder", "pr_createdAt": "2020-07-16T19:49:23Z", "pr_url": "https://github.com/trinodb/trino/pull/4477", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3NzUyMQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456177521", "bodyText": "It's generally preferred not to negate the condition being tested.  Here you have 2 branches, so it's not offering any advantages.", "author": "aalbu", "createdAt": "2020-07-17T02:04:56Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3ODU3OA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456178578", "bodyText": "You could use isDateTimeType(type).", "author": "aalbu", "createdAt": "2020-07-17T02:09:23Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+        }\n+\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE3OTE4Nw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456179187", "bodyText": "No need for this.", "author": "aalbu", "createdAt": "2020-07-17T02:11:42Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+        }\n+\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    @Override\n+    protected void appendNullValue()\n+    {\n+        node.putNull(columnHandles.get(currentColumnIndex).getName());\n+    }\n+\n+    @Override\n+    protected void appendLong(long value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendInt(int value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendShort(short value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByte(byte value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendDouble(double value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendFloat(float value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendBoolean(boolean value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendString(String value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByteBuffer(ByteBuffer value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value.array());\n+    }\n+\n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE4MTQyOA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456181428", "bodyText": "Maybe have a method for DAYS.toMillis(value.getDays()?", "author": "aalbu", "createdAt": "2020-07-17T02:20:33Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+        }\n+\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    @Override\n+    protected void appendNullValue()\n+    {\n+        node.putNull(columnHandles.get(currentColumnIndex).getName());\n+    }\n+\n+    @Override\n+    protected void appendLong(long value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendInt(int value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendShort(short value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByte(byte value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendDouble(double value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendFloat(float value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendBoolean(boolean value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendString(String value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByteBuffer(ByteBuffer value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value.array());\n+    }\n+\n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestampWithTimeZone(SqlTimestampWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    private org.joda.time.format.DateTimeFormatter getCustomFormatter(String format)\n+    {\n+        try {\n+            return org.joda.time.format.DateTimeFormat.forPattern(format).withLocale(Locale.ENGLISH);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(\n+                    GENERIC_USER_ERROR,\n+                    format(\"invalid joda pattern '%s' passed as format hint\", format));\n+        }\n+    }\n+\n+    private String formatDateTime(EncoderColumnHandle columnHandle, SqlDate value)\n+    {\n+        switch (columnHandle.getDataFormat()) {\n+            case \"custom-date-time\":\n+                return (new DateTime(DAYS.toMillis(value.getDays()), DateTimeZone.UTC))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MDY1OA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456190658", "bodyText": "Can you rename the data provider so it does not start with 'test'?  Also, there is no need to provide a name in the annotation, if it's identical to the method name.", "author": "aalbu", "createdAt": "2020-07-17T02:57:00Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -160,6 +162,119 @@ private KafkaTopicFieldDescription createOneFieldDescription(String name, Type t\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n+    @Test(dataProvider = \"testJsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)\n+    {\n+        assertUpdate(\"INSERT into write_test.\" + testCase.getTableName() +\n+                \" (\" + testCase.getFieldNames() + \")\" +\n+                \" VALUES \" + testCase.getRowValues(), testCase.getNumRows());\n+        MaterializedResult actual = computeActual(getSession(), \"SELECT \" + testCase.getFieldNames() + \" FROM write_test.\" + testCase.getTableName() + \" LIMIT \" + testCase.getNumRows());\n+        MaterializedResult expected = computeActual(getSession(), \"VALUES \" + testCase.getRowValues());\n+        assertEquals(actual.getMaterializedRows(), expected.getMaterializedRows());\n+    }\n+\n+    @DataProvider(name = \"testJsonDateTimeFormatsDataProvider\")\n+    public final Object[][] testJsonDateTimeFormatsDataProvider()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MTU2Nw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456191567", "bodyText": "Since the column list is the same for each test case, you can hard-code it in the test.", "author": "aalbu", "createdAt": "2020-07-17T03:00:41Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -160,6 +162,119 @@ private KafkaTopicFieldDescription createOneFieldDescription(String name, Type t\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n+    @Test(dataProvider = \"testJsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)\n+    {\n+        assertUpdate(\"INSERT into write_test.\" + testCase.getTableName() +\n+                \" (\" + testCase.getFieldNames() + \")\" +\n+                \" VALUES \" + testCase.getRowValues(), testCase.getNumRows());\n+        MaterializedResult actual = computeActual(getSession(), \"SELECT \" + testCase.getFieldNames() + \" FROM write_test.\" + testCase.getTableName() + \" LIMIT \" + testCase.getNumRows());\n+        MaterializedResult expected = computeActual(getSession(), \"VALUES \" + testCase.getRowValues());\n+        assertEquals(actual.getMaterializedRows(), expected.getMaterializedRows());\n+    }\n+\n+    @DataProvider(name = \"testJsonDateTimeFormatsDataProvider\")\n+    public final Object[][] testJsonDateTimeFormatsDataProvider()\n+    {\n+        return testJsonDateTimeFormatsData().stream()\n+                .collect(toDataProvider());\n+    }\n+\n+    private List<JsonDateTimeTestCase> testJsonDateTimeFormatsData()\n+    {\n+        return ImmutableList.<JsonDateTimeTestCase>builder()\n+                .add(new JsonDateTimeTestCase(\n+                        \"custom_date_time\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\", \"f_date\"),\n+                        ImmutableList.of(\n+                                ImmutableList.of(\"TIME '01:02:03.456'\",\n+                                        \"TIME '01:02:03.456 UTC'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\",\n+                                        \"DATE '2020-07-15'\"))))\n+                .add(new JsonDateTimeTestCase(\n+                        \"iso8601\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\", \"f_date\"),\n+                        ImmutableList.of(\n+                                ImmutableList.of(\"TIME '01:02:03.456'\",\n+                                        \"TIME '01:02:03.456 UTC'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\",\n+                                        \"DATE '2020-07-15'\"))))\n+                .add(new JsonDateTimeTestCase(\n+                        \"rfc2822\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\", \"f_date\"),\n+                        ImmutableList.of(\n+                                ImmutableList.of(\"TIME '01:02:03'\",\n+                                        \"TIME '01:02:03 UTC'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03 UTC'\",\n+                                        \"DATE '2020-07-15'\"))))\n+                .add(new JsonDateTimeTestCase(\n+                        \"milliseconds_since_epoch\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\"),\n+                        ImmutableList.of(\n+                                ImmutableList.of(\"TIME '01:02:03.456'\",\n+                                        \"TIME '01:02:03.456 UTC'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\"))))\n+                .add(new JsonDateTimeTestCase(\n+                        \"seconds_since_epoch\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\"),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ4ODI0Ng==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456488246", "bodyText": "unfortunately seconds/milliseconds since epoch don't support date", "author": "charlesjmorgan", "createdAt": "2020-07-17T14:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MTU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5MjU0OQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456192549", "bodyText": "String::valueOf would be safer than Object::toString here.", "author": "aalbu", "createdAt": "2020-07-17T03:04:56Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -160,6 +162,119 @@ private KafkaTopicFieldDescription createOneFieldDescription(String name, Type t\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n+    @Test(dataProvider = \"testJsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)\n+    {\n+        assertUpdate(\"INSERT into write_test.\" + testCase.getTableName() +\n+                \" (\" + testCase.getFieldNames() + \")\" +\n+                \" VALUES \" + testCase.getRowValues(), testCase.getNumRows());\n+        MaterializedResult actual = computeActual(getSession(), \"SELECT \" + testCase.getFieldNames() + \" FROM write_test.\" + testCase.getTableName() + \" LIMIT \" + testCase.getNumRows());\n+        MaterializedResult expected = computeActual(getSession(), \"VALUES \" + testCase.getRowValues());\n+        assertEquals(actual.getMaterializedRows(), expected.getMaterializedRows());\n+    }\n+\n+    @DataProvider(name = \"testJsonDateTimeFormatsDataProvider\")\n+    public final Object[][] testJsonDateTimeFormatsDataProvider()\n+    {\n+        return testJsonDateTimeFormatsData().stream()\n+                .collect(toDataProvider());\n+    }\n+\n+    private List<JsonDateTimeTestCase> testJsonDateTimeFormatsData()\n+    {\n+        return ImmutableList.<JsonDateTimeTestCase>builder()\n+                .add(new JsonDateTimeTestCase(\n+                        \"custom_date_time\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\", \"f_date\"),\n+                        ImmutableList.of(\n+                                ImmutableList.of(\"TIME '01:02:03.456'\",\n+                                        \"TIME '01:02:03.456 UTC'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\",\n+                                        \"DATE '2020-07-15'\"))))\n+                .add(new JsonDateTimeTestCase(\n+                        \"iso8601\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\", \"f_date\"),\n+                        ImmutableList.of(\n+                                ImmutableList.of(\"TIME '01:02:03.456'\",\n+                                        \"TIME '01:02:03.456 UTC'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\",\n+                                        \"DATE '2020-07-15'\"))))\n+                .add(new JsonDateTimeTestCase(\n+                        \"rfc2822\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\", \"f_date\"),\n+                        ImmutableList.of(\n+                                ImmutableList.of(\"TIME '01:02:03'\",\n+                                        \"TIME '01:02:03 UTC'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03 UTC'\",\n+                                        \"DATE '2020-07-15'\"))))\n+                .add(new JsonDateTimeTestCase(\n+                        \"milliseconds_since_epoch\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\"),\n+                        ImmutableList.of(\n+                                ImmutableList.of(\"TIME '01:02:03.456'\",\n+                                        \"TIME '01:02:03.456 UTC'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03.456 UTC'\"))))\n+                .add(new JsonDateTimeTestCase(\n+                        \"seconds_since_epoch\",\n+                        ImmutableList.of(\"f_time\", \"f_time_with_time_zone\", \"f_timestamp\", \"f_timestamp_with_time_zone\"),\n+                        ImmutableList.of(\n+                                ImmutableList.of(\"TIME '01:02:03'\",\n+                                        \"TIME '01:02:03 UTC'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03'\",\n+                                        \"TIMESTAMP '2020-07-15 01:02:03 UTC'\"))))\n+                .build();\n+    }\n+\n+    private static final class JsonDateTimeTestCase\n+    {\n+        private final String tableName;\n+        private final List<String> fieldNames;\n+        private final List<List<Object>> rowValues;\n+        private final int numRows;\n+\n+        public JsonDateTimeTestCase(String tableName, List<String> fieldNames, List<List<Object>> rowValues)\n+        {\n+            this.tableName = requireNonNull(tableName, \"tableName is null\");\n+            this.fieldNames = ImmutableList.copyOf(fieldNames);\n+            this.rowValues = ImmutableList.copyOf(rowValues);\n+            this.numRows = rowValues.size();\n+        }\n+\n+        public String getTableName()\n+        {\n+            return tableName;\n+        }\n+\n+        public String getFieldNames()\n+        {\n+            return String.join(\", \", fieldNames);\n+        }\n+\n+        public int getNumRows()\n+        {\n+            return numRows;\n+        }\n+\n+        public String getRowValues()\n+        {\n+            String[] values = new String[rowValues.size()];\n+            for (int i = 0; i < rowValues.size(); i++) {\n+                values[i] = \"(\" + rowValues.get(i).stream().map(Object::toString).collect(Collectors.joining(\", \")) + \")\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzI0Nw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456197247", "bodyText": "TBH, I find this test difficult to read.  I am looking at the setup and I wouldn't be able to predict what the outcome should be (not without writing a small program).  Maybe I'm missing something, but I don't think it adds anything to the tests in TestKafkaIntegrationSmokeTest.  If you wanted to see the full JSON message that is generated, you can get that in the round-trip test too (in _message).", "author": "aalbu", "createdAt": "2020-07-17T03:25:20Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestJsonDateTime.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.prestosql.plugin.kafka.KafkaColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.RowEncoder;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.type.DateType;\n+import io.prestosql.spi.type.TimeType;\n+import io.prestosql.spi.type.TimeWithTimeZoneType;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.Test;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestJsonDateTime\n+{\n+    private static final JsonRowEncoderFactory ENCODER_FACTORY = new JsonRowEncoderFactory(new ObjectMapper());\n+\n+    private static EncoderColumnHandle createColumnHandle(String name, Type type, String dataFormat)\n+    {\n+        return createColumnHandle(name, type, dataFormat, null);\n+    }\n+\n+    private static EncoderColumnHandle createColumnHandle(String name, Type type, String dataFormat, String formatHint)\n+    {\n+        return new KafkaColumnHandle(name, type, name, dataFormat, formatHint, false, false, false);\n+    }\n+\n+    private static RowEncoder createRowEncoder(EncoderColumnHandle... columnHandles)\n+    {\n+        return ENCODER_FACTORY.create(TestingConnectorSession.SESSION, Optional.empty(), ImmutableList.copyOf(columnHandles));\n+    }\n+\n+    @Test\n+    public void testCustomFormat()\n+    {\n+        EncoderColumnHandle col1 = createColumnHandle(\"col1\", DateType.DATE, \"custom-date-time\", \"yyyy-dd-MM\");\n+        EncoderColumnHandle col2 = createColumnHandle(\"col2\", TimeType.TIME, \"custom-date-time\", \"kk:mm:ss.SSS\");\n+        EncoderColumnHandle col3 = createColumnHandle(\"col3\", TimeWithTimeZoneType.TIME_WITH_TIME_ZONE, \"custom-date-time\", \"kk:mm:ss.SSS Z\");\n+        EncoderColumnHandle col4 = createColumnHandle(\"col4\", TimestampType.createTimestampType(3), \"custom-date-time\", \"yyyy-dd-MM kk:mm:ss.SSS\");\n+        EncoderColumnHandle col5 = createColumnHandle(\"col5\", TimestampWithTimeZoneType.createTimestampWithTimeZoneType(3), \"custom-date-time\", \"yyyy-dd-MM kk:mm:ss.SSS Z\");\n+\n+        RowEncoder rowEncoder = createRowEncoder(col1, col2, col3, col4, col5);\n+\n+        Block dateBlock = DateType.DATE.createBlockBuilder(null, 1).writeInt(18458);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5MDYyNg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456490626", "bodyText": "I wrote these tests for development because they are a million times faster than the roundtrip test in TestKafkaIntegrationSmokeTest. They both serve the same purpose now, idk if it would be a good idea to keep them around for development or if I should just use the roundtrip tests.", "author": "charlesjmorgan", "createdAt": "2020-07-17T14:48:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5NzI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5OTU1Mg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456199552", "bodyText": "I think there was a suggestion in a previous review about testing with more than one record.", "author": "aalbu", "createdAt": "2020-07-17T03:34:57Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -189,10 +304,14 @@ public void testRoundTripAllFormats(RoundTripTestCase testCase)\n                         \"all_datatypes_csv\",\n                         ImmutableList.of(\"f_bigint\", \"f_int\", \"f_smallint\", \"f_tinyint\", \"f_double\", \"f_boolean\", \"f_varchar\"),\n                         ImmutableList.of(100000, 1000, 100, 10, 1000.001, true, \"'test'\")))\n+                .add(new RoundTripTestCase(\n+                        \"all_datatypes_json\",\n+                        ImmutableList.of(\"f_bigint\", \"f_int\", \"f_smallint\", \"f_tinyint\", \"f_double\", \"f_boolean\", \"f_varchar\"),\n+                        ImmutableList.of(100000, 1000, 100, 10, 1000.001, true, \"'test'\")))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5MTkyNw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456491927", "bodyText": "yes, that commit is in the raw encoder pr #4417. I'll make sure that get's brought in when it merges", "author": "charlesjmorgan", "createdAt": "2020-07-17T14:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE5OTU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNDIwMg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456304202", "bodyText": "suffix the definitions for testing timestamp with _json so it is obvious what format are we talking about.\ncustom_date_time.json -> custom_date_time_json.json\nAlternatively create write_test/json directory for definitions related to json encoder.", "author": "losipiuk", "createdAt": "2020-07-17T08:40:04Z", "path": "presto-kafka/src/test/resources/write_test/custom_date_time.json", "diffHunk": "@@ -0,0 +1,55 @@\n+{", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0NjgwMQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456346801", "bodyText": "A thought. Can we have some tests for validation? Maybe for other formats too?", "author": "losipiuk", "createdAt": "2020-07-17T10:01:50Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5MzQ0NQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456493445", "bodyText": "yes, that would be a good idea", "author": "charlesjmorgan", "createdAt": "2020-07-17T14:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0NjgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0NzUwNA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456347504", "bodyText": "check if formatHint is parsable pattern?", "author": "losipiuk", "createdAt": "2020-07-17T10:03:11Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0Nzk5MA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456347990", "bodyText": "move to the top so it is above more specific checks", "author": "losipiuk", "createdAt": "2020-07-17T10:04:03Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM4MTQyNA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456381424", "bodyText": "maybe extract columnHandles.get(currentColumnIndex).getName() as currentColumnName() ?", "author": "losipiuk", "createdAt": "2020-07-17T11:20:53Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+        }\n+\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    @Override\n+    protected void appendNullValue()\n+    {\n+        node.putNull(columnHandles.get(currentColumnIndex).getName());\n+    }\n+\n+    @Override\n+    protected void appendLong(long value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendInt(int value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendShort(short value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByte(byte value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendDouble(double value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendFloat(float value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM4MzgyMw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456383823", "bodyText": "the constants are repeating in multiple switch cases. Extract consts. Or define enum", "author": "losipiuk", "createdAt": "2020-07-17T11:27:13Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+        }\n+\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    @Override\n+    protected void appendNullValue()\n+    {\n+        node.putNull(columnHandles.get(currentColumnIndex).getName());\n+    }\n+\n+    @Override\n+    protected void appendLong(long value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendInt(int value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendShort(short value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByte(byte value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendDouble(double value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendFloat(float value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendBoolean(boolean value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendString(String value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByteBuffer(ByteBuffer value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value.array());\n+    }\n+\n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestampWithTimeZone(SqlTimestampWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    private org.joda.time.format.DateTimeFormatter getCustomFormatter(String format)\n+    {\n+        try {\n+            return org.joda.time.format.DateTimeFormat.forPattern(format).withLocale(Locale.ENGLISH);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(\n+                    GENERIC_USER_ERROR,\n+                    format(\"invalid joda pattern '%s' passed as format hint\", format));\n+        }\n+    }\n+\n+    private String formatDateTime(EncoderColumnHandle columnHandle, SqlDate value)\n+    {\n+        switch (columnHandle.getDataFormat()) {\n+            case \"custom-date-time\":", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5NDkyNg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456494926", "bodyText": "oh an enum would be good. What do you think of having separate classes for the formatters? We could precompile a list of formatters at encoder initialization.", "author": "charlesjmorgan", "createdAt": "2020-07-17T14:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM4MzgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5MjAzNQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456392035", "bodyText": "can we precompute this one. Seems thread safe and stateless.", "author": "losipiuk", "createdAt": "2020-07-17T11:47:44Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+        }\n+\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    @Override\n+    protected void appendNullValue()\n+    {\n+        node.putNull(columnHandles.get(currentColumnIndex).getName());\n+    }\n+\n+    @Override\n+    protected void appendLong(long value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendInt(int value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendShort(short value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByte(byte value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendDouble(double value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendFloat(float value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendBoolean(boolean value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendString(String value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByteBuffer(ByteBuffer value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value.array());\n+    }\n+\n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestampWithTimeZone(SqlTimestampWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    private org.joda.time.format.DateTimeFormatter getCustomFormatter(String format)\n+    {\n+        try {\n+            return org.joda.time.format.DateTimeFormat.forPattern(format).withLocale(Locale.ENGLISH);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(\n+                    GENERIC_USER_ERROR,\n+                    format(\"invalid joda pattern '%s' passed as format hint\", format));\n+        }\n+    }\n+\n+    private String formatDateTime(EncoderColumnHandle columnHandle, SqlDate value)\n+    {\n+        switch (columnHandle.getDataFormat()) {\n+            case \"custom-date-time\":\n+                return (new DateTime(DAYS.toMillis(value.getDays()), DateTimeZone.UTC))\n+                        .toString(this.getCustomFormatter(columnHandle.getFormatHint()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5NTYwOQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456495609", "bodyText": "yes", "author": "charlesjmorgan", "createdAt": "2020-07-17T14:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5MjAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5MjU0NQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456392545", "bodyText": "why go throw milliseconds and not directly DAYS.toSeconds()", "author": "losipiuk", "createdAt": "2020-07-17T11:48:58Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+        }\n+\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    @Override\n+    protected void appendNullValue()\n+    {\n+        node.putNull(columnHandles.get(currentColumnIndex).getName());\n+    }\n+\n+    @Override\n+    protected void appendLong(long value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendInt(int value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendShort(short value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByte(byte value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendDouble(double value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendFloat(float value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendBoolean(boolean value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendString(String value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByteBuffer(ByteBuffer value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value.array());\n+    }\n+\n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestampWithTimeZone(SqlTimestampWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    private org.joda.time.format.DateTimeFormatter getCustomFormatter(String format)\n+    {\n+        try {\n+            return org.joda.time.format.DateTimeFormat.forPattern(format).withLocale(Locale.ENGLISH);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(\n+                    GENERIC_USER_ERROR,\n+                    format(\"invalid joda pattern '%s' passed as format hint\", format));\n+        }\n+    }\n+\n+    private String formatDateTime(EncoderColumnHandle columnHandle, SqlDate value)\n+    {\n+        switch (columnHandle.getDataFormat()) {\n+            case \"custom-date-time\":\n+                return (new DateTime(DAYS.toMillis(value.getDays()), DateTimeZone.UTC))\n+                        .toString(this.getCustomFormatter(columnHandle.getFormatHint()));\n+            case \"rfc2822\":\n+                return Instant.ofEpochMilli(DAYS.toMillis(value.getDays()))\n+                        .atZone(UTC)\n+                        .format(RFC_FORMATTER);\n+            case \"iso8601\":\n+                return Instant.ofEpochMilli(DAYS.toMillis(value.getDays()))\n+                        .atZone(UTC)\n+                        .toLocalDate()\n+                        .format(ISO_DATE);\n+            case \"milliseconds-since-epoch\":\n+                return String.valueOf(DAYS.toMillis(value.getDays()));\n+            case \"seconds-since-epoch\":\n+                return String.valueOf(MILLISECONDS.toSeconds(DAYS.toMillis(value.getDays())));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5NDA3NQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456394075", "bodyText": "please name the formatDateTime methods similarly to append* so name contains type of formatted object.", "author": "losipiuk", "createdAt": "2020-07-17T11:52:13Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+        }\n+\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    @Override\n+    protected void appendNullValue()\n+    {\n+        node.putNull(columnHandles.get(currentColumnIndex).getName());\n+    }\n+\n+    @Override\n+    protected void appendLong(long value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendInt(int value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendShort(short value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByte(byte value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendDouble(double value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendFloat(float value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendBoolean(boolean value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendString(String value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByteBuffer(ByteBuffer value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value.array());\n+    }\n+\n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestampWithTimeZone(SqlTimestampWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    private org.joda.time.format.DateTimeFormatter getCustomFormatter(String format)\n+    {\n+        try {\n+            return org.joda.time.format.DateTimeFormat.forPattern(format).withLocale(Locale.ENGLISH);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(\n+                    GENERIC_USER_ERROR,\n+                    format(\"invalid joda pattern '%s' passed as format hint\", format));\n+        }\n+    }\n+\n+    private String formatDateTime(EncoderColumnHandle columnHandle, SqlDate value)\n+    {\n+        switch (columnHandle.getDataFormat()) {\n+            case \"custom-date-time\":\n+                return (new DateTime(DAYS.toMillis(value.getDays()), DateTimeZone.UTC))\n+                        .toString(this.getCustomFormatter(columnHandle.getFormatHint()));\n+            case \"rfc2822\":\n+                return Instant.ofEpochMilli(DAYS.toMillis(value.getDays()))\n+                        .atZone(UTC)\n+                        .format(RFC_FORMATTER);\n+            case \"iso8601\":\n+                return Instant.ofEpochMilli(DAYS.toMillis(value.getDays()))\n+                        .atZone(UTC)\n+                        .toLocalDate()\n+                        .format(ISO_DATE);\n+            case \"milliseconds-since-epoch\":\n+                return String.valueOf(DAYS.toMillis(value.getDays()));\n+            case \"seconds-since-epoch\":\n+                return String.valueOf(MILLISECONDS.toSeconds(DAYS.toMillis(value.getDays())));\n+            default:\n+                throw new PrestoException(GENERIC_USER_ERROR, format(\"invalid data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName()));\n+        }\n+    }\n+\n+    private String formatDateTime(EncoderColumnHandle columnHandle, SqlTime value)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5NTY2NQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456395665", "bodyText": "at this point it is internal error as we validate if data format is correct during encoder construction.", "author": "losipiuk", "createdAt": "2020-07-17T11:56:05Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_USER_ERROR;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.time.ZoneOffset.UTC;\n+import static java.time.format.DateTimeFormatter.ISO_DATE;\n+import static java.time.format.DateTimeFormatter.ISO_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_OFFSET_TIME;\n+import static java.time.format.DateTimeFormatter.ISO_TIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+    private static final Set<String> DATE_TIME_FORMATS = ImmutableSet.of(\n+            \"custom-date-time\", \"iso8601\", \"rfc2822\", \"milliseconds-since-epoch\", \"seconds-since-epoch\");\n+    private static final String CUSTOM_DATE_TIME_NAME = \"custom-date-time\";\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            if (!isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+            }\n+            else {\n+                checkArgument(DATE_TIME_FORMATS.contains(columnHandle.getDataFormat()), \"Incorrect data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                if (columnHandle.getDataFormat().equals(CUSTOM_DATE_TIME_NAME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+            }\n+\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+        }\n+\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    @Override\n+    protected void appendNullValue()\n+    {\n+        node.putNull(columnHandles.get(currentColumnIndex).getName());\n+    }\n+\n+    @Override\n+    protected void appendLong(long value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendInt(int value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendShort(short value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByte(byte value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendDouble(double value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendFloat(float value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendBoolean(boolean value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendString(String value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByteBuffer(ByteBuffer value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), value.array());\n+    }\n+\n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestampWithTimeZone(SqlTimestampWithTimeZone value)\n+    {\n+        node.put(columnHandles.get(currentColumnIndex).getName(), this.formatDateTime(columnHandles.get(currentColumnIndex), value));\n+    }\n+\n+    private org.joda.time.format.DateTimeFormatter getCustomFormatter(String format)\n+    {\n+        try {\n+            return org.joda.time.format.DateTimeFormat.forPattern(format).withLocale(Locale.ENGLISH);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new PrestoException(\n+                    GENERIC_USER_ERROR,\n+                    format(\"invalid joda pattern '%s' passed as format hint\", format));\n+        }\n+    }\n+\n+    private String formatDateTime(EncoderColumnHandle columnHandle, SqlDate value)\n+    {\n+        switch (columnHandle.getDataFormat()) {\n+            case \"custom-date-time\":\n+                return (new DateTime(DAYS.toMillis(value.getDays()), DateTimeZone.UTC))\n+                        .toString(this.getCustomFormatter(columnHandle.getFormatHint()));\n+            case \"rfc2822\":\n+                return Instant.ofEpochMilli(DAYS.toMillis(value.getDays()))\n+                        .atZone(UTC)\n+                        .format(RFC_FORMATTER);\n+            case \"iso8601\":\n+                return Instant.ofEpochMilli(DAYS.toMillis(value.getDays()))\n+                        .atZone(UTC)\n+                        .toLocalDate()\n+                        .format(ISO_DATE);\n+            case \"milliseconds-since-epoch\":\n+                return String.valueOf(DAYS.toMillis(value.getDays()));\n+            case \"seconds-since-epoch\":\n+                return String.valueOf(MILLISECONDS.toSeconds(DAYS.toMillis(value.getDays())));\n+            default:\n+                throw new PrestoException(GENERIC_USER_ERROR, format(\"invalid data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5OTQ3MA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456399470", "bodyText": "how is logic here different from testRoundTripAllFormats?\nCan we make testRoundTripAllFormats and testJsonDateTimeFormats share testcase definition.", "author": "losipiuk", "createdAt": "2020-07-17T12:04:52Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -160,6 +162,119 @@ private KafkaTopicFieldDescription createOneFieldDescription(String name, Type t\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n+    @Test(dataProvider = \"testJsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ5NjU5NA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r456496594", "bodyText": "yes, that's the plan when the raw encoder pr merges #4417", "author": "charlesjmorgan", "createdAt": "2020-07-17T14:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5OTQ3MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5Nzk5Mg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458197992", "bodyText": "extract helper method", "author": "losipiuk", "createdAt": "2020-07-21T15:42:41Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.dateFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.daysToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.defaultFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeWithTZFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampWithTZFormatFunction;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+    private final List<JsonFormatFunction> formatFunctions;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+\n+        ImmutableList.Builder<JsonFormatFunction> formatFunctionsBuilder = ImmutableList.builder();\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+            if (isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                JsonFormatFunctions.FormatType dataFormat;\n+                try {\n+                    dataFormat = JsonFormatFunctions.FormatType.valueOf(columnHandle.getDataFormat().toUpperCase().replaceAll(\"-\", \"_\"));\n+                }\n+                catch (IllegalArgumentException e) {\n+                    throw new IllegalArgumentException(format(\"Unable to parse data format '%s' for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName()), e);\n+                }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5OTQxMw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458199413", "bodyText": "static import FormatType", "author": "losipiuk", "createdAt": "2020-07-21T15:44:39Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.dateFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.daysToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.defaultFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeWithTZFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampWithTZFormatFunction;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+    private final List<JsonFormatFunction> formatFunctions;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+\n+        ImmutableList.Builder<JsonFormatFunction> formatFunctionsBuilder = ImmutableList.builder();\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+            if (isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                JsonFormatFunctions.FormatType dataFormat;\n+                try {\n+                    dataFormat = JsonFormatFunctions.FormatType.valueOf(columnHandle.getDataFormat().toUpperCase().replaceAll(\"-\", \"_\"));\n+                }\n+                catch (IllegalArgumentException e) {\n+                    throw new IllegalArgumentException(format(\"Unable to parse data format '%s' for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName()), e);\n+                }\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+                if (dataFormat.equals(JsonFormatFunctions.FormatType.CUSTOM_DATE_TIME)) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5OTk3OA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458199978", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (dataFormat.equals(JsonFormatFunctions.FormatType.CUSTOM_DATE_TIME)) {\n          \n          \n            \n                            if (dataFormat == FormatType.CUSTOM_DATE_TIME) {", "author": "losipiuk", "createdAt": "2020-07-21T15:45:24Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.dateFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.daysToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.defaultFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeWithTZFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampWithTZFormatFunction;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+    private final List<JsonFormatFunction> formatFunctions;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+\n+        ImmutableList.Builder<JsonFormatFunction> formatFunctionsBuilder = ImmutableList.builder();\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+            if (isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                JsonFormatFunctions.FormatType dataFormat;\n+                try {\n+                    dataFormat = JsonFormatFunctions.FormatType.valueOf(columnHandle.getDataFormat().toUpperCase().replaceAll(\"-\", \"_\"));\n+                }\n+                catch (IllegalArgumentException e) {\n+                    throw new IllegalArgumentException(format(\"Unable to parse data format '%s' for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName()), e);\n+                }\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+                if (dataFormat.equals(JsonFormatFunctions.FormatType.CUSTOM_DATE_TIME)) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMDg3OA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458200878", "bodyText": "inline", "author": "losipiuk", "createdAt": "2020-07-21T15:46:40Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.dateFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.daysToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.defaultFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeWithTZFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampWithTZFormatFunction;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+    private final List<JsonFormatFunction> formatFunctions;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+\n+        ImmutableList.Builder<JsonFormatFunction> formatFunctionsBuilder = ImmutableList.builder();\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+            if (isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                JsonFormatFunctions.FormatType dataFormat;\n+                try {\n+                    dataFormat = JsonFormatFunctions.FormatType.valueOf(columnHandle.getDataFormat().toUpperCase().replaceAll(\"-\", \"_\"));\n+                }\n+                catch (IllegalArgumentException e) {\n+                    throw new IllegalArgumentException(format(\"Unable to parse data format '%s' for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName()), e);\n+                }\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+                if (dataFormat.equals(JsonFormatFunctions.FormatType.CUSTOM_DATE_TIME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+                Optional<String> formatHint = Optional.ofNullable(columnHandle.getFormatHint());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwMTQxNA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458201414", "bodyText": "name it formatFunctions", "author": "losipiuk", "createdAt": "2020-07-21T15:47:20Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.dateFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.daysToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.defaultFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeWithTZFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampWithTZFormatFunction;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+    private final List<JsonFormatFunction> formatFunctions;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+\n+        ImmutableList.Builder<JsonFormatFunction> formatFunctionsBuilder = ImmutableList.builder();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDY0NQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458210645", "bodyText": "this one is never used in practice, as whenever you take something out of formatFunctions you cast it to JsonDateTimeFormatFunction. Is that a bug?\nAlso I do not huge fan of idea of having format functions which do not satisfy common interface in single list.", "author": "losipiuk", "createdAt": "2020-07-21T16:00:02Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/DefaultFormatFunction.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+public interface DefaultFormatFunction", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQxNTk2MA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458415960", "bodyText": "I needed a filler function for non-temporal columns. I agree this is less than ideal, I'm not sure what to replace it with. This function is never actually used in the encoder. I was thinking that in the future we could replace all the appendLong, appendBoolean... methods with a precompiled list of lambda functions to format/add the column value to the encoder. For now we need to figure out a different solution. I could change the List<JsonFormatFunctions> formatFunctions field in JsonRowEncoder to a Map and have the column handle as the key? That way I don't need to access it with the currentColumnIndex.", "author": "charlesjmorgan", "createdAt": "2020-07-21T22:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyODcwNw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458728707", "bodyText": "I find the approach with default function cumbersome. Maybe instead having a hierarchy here we can just have as set of functions and single class with methods delegating to functors. Then we can provide the fuctions we care about as lambdas via builder. The ones which are not explicitly set would just throw exception.\nSth like this:\npublic class JsonFormatFunction\n{\n    private final Function<Instant, String> formatTimestampLegacyFunc;\n    private final Function<LocalDateTime, String> formatTimestampFunc;\n    //private final Function<Something, String> formatSomething;\n\n    public JsonFormatFunction(Function<Instant, String> formatTimestampLegacyFunc, Function<LocalDateTime, String> formatTimestampFunc)\n    {\n        this.formatTimestampLegacyFunc = formatTimestampLegacyFunc;\n        this.formatTimestampFunc = formatTimestampFunc;\n    }\n\n    public String formatTimestampLegacy(Instant value)\n    {\n        return formatTimestampLegacyFunc.apply(value);\n    };\n\n    public String formatTimestamp(LocalDateTime value)\n    {\n        return formatTimestampFunc.apply(value);\n    }\n\n    public static class Builder\n    {\n        private Function<Instant, String> formatTimestampLegacyFunc = (ignored) -> { throw new RuntimeException(\"not supported argument type\"); };\n        private Function<LocalDateTime, String> formatTimestampFunc = (ignored) -> { throw new RuntimeException(\"not supported argument type\"); };\n\n        JsonFormatFunction build()\n        {\n            return new JsonFormatFunction(\n                    formatTimestampLegacyFunc,\n                    formatTimestampFunc);\n        }\n\n        public Builder setFormatTimestampLegacyFunc(Function<Instant, String> formatTimestampLegacyFunc)\n        {\n            this.formatTimestampLegacyFunc = formatTimestampLegacyFunc;\n            return this;\n        }\n\n        public Builder setFormatTimestampFunc(Function<LocalDateTime, String> formatTimestampFunc)\n        {\n            this.formatTimestampFunc = formatTimestampFunc;\n            return this;\n        }\n    }\n}\nOne downside of this is that is a bit verbose. It also involves extra boxing/unboxing - not sure how much of a problem that is with new JVMs.", "author": "losipiuk", "createdAt": "2020-07-22T11:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyODg4Ng==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458228886", "bodyText": "This looks wrong. It does not seem to me that you should not use same formatting function and just pass different version to it based on selected timestamp semantic.\nAs the semantics is different the formatting should be different. I.e it does not make sense to append any timezone information for non-legacy semantics in output string.\nIt is hard for me to wrap my head around it though.", "author": "losipiuk", "createdAt": "2020-07-21T16:26:50Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonDateTimeFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.dateFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.daysToMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.defaultFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timeWithTZFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.timestampWithTZFormatFunction;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+    private final List<JsonFormatFunction> formatFunctions;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+\n+        ImmutableList.Builder<JsonFormatFunction> formatFunctionsBuilder = ImmutableList.builder();\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+            if (isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                JsonFormatFunctions.FormatType dataFormat;\n+                try {\n+                    dataFormat = JsonFormatFunctions.FormatType.valueOf(columnHandle.getDataFormat().toUpperCase().replaceAll(\"-\", \"_\"));\n+                }\n+                catch (IllegalArgumentException e) {\n+                    throw new IllegalArgumentException(format(\"Unable to parse data format '%s' for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName()), e);\n+                }\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+                if (dataFormat.equals(JsonFormatFunctions.FormatType.CUSTOM_DATE_TIME)) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+                Optional<String> formatHint = Optional.ofNullable(columnHandle.getFormatHint());\n+\n+                formatFunctionsBuilder.add(getDateTimeFormatFunction(columnHandle.getType(), dataFormat, formatHint, columnHandle.getName()));\n+            }\n+            else {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                formatFunctionsBuilder.add(defaultFormatFunction());\n+            }\n+        }\n+\n+        this.formatFunctions = formatFunctionsBuilder.build();\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                isDateTimeType(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private JsonDateTimeFormatFunction getDateTimeFormatFunction(Type type, JsonFormatFunctions.FormatType dataFormat, Optional<String> formatHint, String name)\n+    {\n+        if (type == DATE) {\n+            return dateFormatFunction(dataFormat, formatHint);\n+        }\n+        else if (type == TIME) {\n+            return timeFormatFunction(dataFormat, formatHint);\n+        }\n+        else if (type == TIME_WITH_TIME_ZONE) {\n+            return timeWithTZFormatFunction(dataFormat, formatHint);\n+        }\n+        else if (type instanceof TimestampType) {\n+            return timestampFormatFunction(dataFormat, formatHint);\n+        }\n+        else if (type instanceof TimestampWithTimeZoneType) {\n+            return timestampWithTZFormatFunction(dataFormat, formatHint);\n+        }\n+        else {\n+            throw new IllegalArgumentException(format(\"Invalid type '%s' for temporal column '%s'\", type.getDisplayName(), dataFormat, name));\n+        }\n+    }\n+\n+    private String currentColumnName()\n+    {\n+        return columnHandles.get(currentColumnIndex).getName();\n+    }\n+\n+    @Override\n+    protected void appendNullValue()\n+    {\n+        node.putNull(currentColumnName());\n+    }\n+\n+    @Override\n+    protected void appendLong(long value)\n+    {\n+        node.put(currentColumnName(), value);\n+    }\n+\n+    @Override\n+    protected void appendInt(int value)\n+    {\n+        node.put(currentColumnName(), value);\n+    }\n+\n+    @Override\n+    protected void appendShort(short value)\n+    {\n+        node.put(currentColumnName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByte(byte value)\n+    {\n+        node.put(currentColumnName(), value);\n+    }\n+\n+    @Override\n+    protected void appendDouble(double value)\n+    {\n+        node.put(currentColumnName(), value);\n+    }\n+\n+    @Override\n+    protected void appendFloat(float value)\n+    {\n+        node.put(currentColumnName(), value);\n+    }\n+\n+    @Override\n+    protected void appendBoolean(boolean value)\n+    {\n+        node.put(currentColumnName(), value);\n+    }\n+\n+    @Override\n+    protected void appendString(String value)\n+    {\n+        node.put(currentColumnName(), value);\n+    }\n+\n+    @Override\n+    protected void appendByteBuffer(ByteBuffer value)\n+    {\n+        node.put(currentColumnName(), value.array());\n+    }\n+\n+    @Override\n+    protected void appendSqlDate(SqlDate value)\n+    {\n+        node.put(currentColumnName(), ((JsonDateTimeFormatFunction) formatFunctions.get(currentColumnIndex)).format(daysToMillis(value.getDays())));\n+    }\n+\n+    @Override\n+    protected void appendSqlTime(SqlTime value)\n+    {\n+        node.put(currentColumnName(), ((JsonDateTimeFormatFunction) formatFunctions.get(currentColumnIndex)).format(value.getMillis()));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimeWithTimeZone(SqlTimeWithTimeZone value)\n+    {\n+        node.put(currentColumnName(), ((JsonDateTimeFormatFunction) formatFunctions.get(currentColumnIndex)).format(packDateTimeWithZone(value.getMillisUtc(), value.getTimeZoneKey())));\n+    }\n+\n+    @Override\n+    protected void appendSqlTimestamp(SqlTimestamp value)\n+    {\n+        if (session.isLegacyTimestamp()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQxNzE2MA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458417160", "bodyText": "Ik the timestamp changes have me confused as well (clearly hahah). I think I've been testing with the legacy timestamp, which would explain why I haven't encountered a problem with this yet, so I'll add different functions and test with the new timestamp.", "author": "charlesjmorgan", "createdAt": "2020-07-21T22:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyODg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczNzU0Mg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458737542", "bodyText": "It seems to me that cleanest approach would be to not allow encoding timestamp in non-legacy semantic to any format which clearly denotes an instant (i.e. explicitly specifies a timezone in a value). The problem with that is it would be not compatible with what we already have in decoders (which do not care about timestamp semantics whatsoever).\nMaybe we should assume that logic in decoders only makes sense for legacy timestamp semantics, and enforce that with check in the connector. Then we can focus on implementing just legacy semantics of timestamp in encoders in a way that is compatible with decoders.\nThen we can add non-legacy semantics to both decoders and encoders?\nThe problem with that is that we would break people which use kafka timestamp decoders with timestamp semantic set to non-legacy. I do not expect that it would be many users, but one never knows.\n@findepi, as an expert on hard issues, can you chime in here?", "author": "losipiuk", "createdAt": "2020-07-22T11:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyODg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ2ODUwNw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r459468507", "bodyText": "@losipiuk i like your proposal.\ni would only add that there seems to be no fundamental problem in decoding timestamp (without zone) from a value containing a zone. You could think of it as a CAST.\nEg JDBC ResultSet.getDate can be called on a date or timestamp, and returns a date part of the value.\nI am OK with dropping this though, for non-legacy. We can always re-add this if we learn about particular requirements.", "author": "findepi", "createdAt": "2020-07-23T13:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyODg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwMDYxMQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r460000611", "bodyText": "Thanks for comment.\n\n@losipiuk i like your proposal.\ni would only add that there seems to be no fundamental problem in decoding timestamp (without zone) from a value containing a zone. You could think of it as a CAST.\nEg JDBC ResultSet.getDate can be called on a date or timestamp, and returns a date part of the value.\nI am OK with dropping this though, for non-legacy. We can always re-add this if we learn about particular requirements.\n\nYeah - it makes sense for decoding. Less so for encoding, as it not obvious what timezone use in encoded value. And even if timezone is statically defined by encoding format it is kinda smelly.", "author": "losipiuk", "createdAt": "2020-07-24T11:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyODg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjEwOQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458236109", "bodyText": "I think those test would benefit if stracture it more granurally, where single testcase defines\n\nformat\ncolumn\nexpected value\n\nSth like this:\n        testCaseBuilder.\n            .addTestCase(\"custom_date_time_json\", \"f_time\", \"TIME '01:02:03.456'\")\n            .addTestCase(\"custom_date_time_json\", \"f_time\", \"TIME '03:02:03.456'\")\n            .addTestCase(\"custom_date_time_json\", \"f_time_with_time_zone\", \"TIME '05:02:03.456 UTC'\")\n            .addTestCase(\"iso8601_json\", \"f_time\", \"TIME '05:02:03.456'\")\nI think it is easier to read as you have all information about single testcase in single line.\nWe can also focus more on data types which are more problematic and have more corner cases.\nUnder the hood we can insert whole row with all columns but one we care about set to null.\nWDYT?", "author": "losipiuk", "createdAt": "2020-07-21T16:38:09Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/TestKafkaIntegrationSmokeTest.java", "diffHunk": "@@ -160,7 +162,120 @@ private KafkaTopicFieldDescription createOneFieldDescription(String name, Type t\n         return new KafkaTopicFieldDescription(name, type, mapping, null, dataFormat, null, false);\n     }\n \n-    @Test(dataProvider = \"testRoundTripAllFormatsDataProvider\")\n+    @Test(dataProvider = \"jsonDateTimeFormatsDataProvider\")\n+    public void testJsonDateTimeFormats(JsonDateTimeTestCase testCase)\n+    {\n+        assertUpdate(\"INSERT into write_test.\" + testCase.getTableName() +\n+                \" (\" + testCase.getFieldNames() + \")\" +\n+                \" VALUES \" + testCase.getRowValues(), testCase.getNumRows());\n+        MaterializedResult actual = computeActual(getSession(), \"SELECT \" + testCase.getFieldNames() + \" FROM write_test.\" + testCase.getTableName() + \" LIMIT \" + testCase.getNumRows());\n+        MaterializedResult expected = computeActual(getSession(), \"VALUES \" + testCase.getRowValues());\n+        assertEquals(actual.getMaterializedRows(), expected.getMaterializedRows());\n+    }\n+\n+    @DataProvider\n+    public final Object[][] jsonDateTimeFormatsDataProvider()\n+    {\n+        return jsonDateTimeFormatsData().stream()\n+                .collect(toDataProvider());\n+    }\n+\n+    private List<JsonDateTimeTestCase> jsonDateTimeFormatsData()\n+    {\n+        return ImmutableList.<JsonDateTimeTestCase>builder()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0MzIyMQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458243221", "bodyText": "On the other hand maybe the unit tests we have in TestJsonDateTime are enough and these should be treated as just smoke coverage?\n@aalbu ?", "author": "losipiuk", "createdAt": "2020-07-21T16:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMzMDk1OA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458330958", "bodyText": "I agree this format would be much easier to read and debug. Could probably just use one table as well.", "author": "charlesjmorgan", "createdAt": "2020-07-21T19:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2MzQ1NQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458463455", "bodyText": "@losipiuk I think lighter coverage here and testing all edge cases in TestJsonDateTime is a good idea.  Perhaps what we would need to add here would be some round-trip tests with legacy semantics enabled.  We should talk about that.", "author": "aalbu", "createdAt": "2020-07-22T00:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUxNzY4Mg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458517682", "bodyText": "I think that it would be better to test each individual format function. The current tests in TestJsonDateTime helped me figure out how to write the format functions, but they just aren't great tests.", "author": "charlesjmorgan", "createdAt": "2020-07-22T03:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUxNzc0OQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458517749", "bodyText": "+1 to lighter smoke testing", "author": "charlesjmorgan", "createdAt": "2020-07-22T03:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczNzk4Mg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458737982", "bodyText": "we should talk about that\n\n@aalbu see #4477 (comment)", "author": "losipiuk", "createdAt": "2020-07-22T11:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0MjQ2Mg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458242462", "bodyText": "Use of datatype internal representation here make the test look cryptic. Compute 1594846503123L using java.time.* instead hardcoding it in tests?", "author": "losipiuk", "createdAt": "2020-07-21T16:47:45Z", "path": "presto-kafka/src/test/java/io/prestosql/plugin/kafka/encoder/json/TestJsonDateTime.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.prestosql.plugin.kafka.KafkaColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.RowEncoder;\n+import io.prestosql.spi.block.Block;\n+import io.prestosql.spi.type.DateType;\n+import io.prestosql.spi.type.TimeType;\n+import io.prestosql.spi.type.TimeWithTimeZoneType;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.testing.TestingConnectorSession;\n+import org.testcontainers.shaded.com.google.common.collect.ImmutableList;\n+import org.testng.annotations.Test;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.testing.assertions.Assert.assertEquals;\n+\n+public class TestJsonDateTime\n+{\n+    private static final JsonRowEncoderFactory ENCODER_FACTORY = new JsonRowEncoderFactory(new ObjectMapper());\n+\n+    private static EncoderColumnHandle createColumnHandle(String name, Type type, String dataFormat)\n+    {\n+        return createColumnHandle(name, type, dataFormat, null);\n+    }\n+\n+    private static EncoderColumnHandle createColumnHandle(String name, Type type, String dataFormat, String formatHint)\n+    {\n+        return new KafkaColumnHandle(name, type, name, dataFormat, formatHint, false, false, false);\n+    }\n+\n+    private static RowEncoder createRowEncoder(EncoderColumnHandle... columnHandles)\n+    {\n+        return ENCODER_FACTORY.create(TestingConnectorSession.SESSION, Optional.empty(), ImmutableList.copyOf(columnHandles));\n+    }\n+\n+    @Test\n+    public void testCustomFormat()\n+    {\n+        testDateHelper(18458, \"2020-15-07\", \"custom-date-time\", Optional.of(\"yyyy-dd-MM\"));\n+        testTimeHelper(1594846503123L, \"20:55:03.123\", \"custom-date-time\", Optional.of(\"kk:mm:ss.SSS\"));\n+        testTimeWithTZHelper(packDateTimeWithZone(1594846503123L, \"UTC\"), \"20:55:03.123 +0000\", \"custom-date-time\", Optional.of(\"kk:mm:ss.SSS Z\"));\n+        testTimestampHelper(1594846503123L, \"2020-15-07 20:55:03.123\", \"custom-date-time\", Optional.of(\"yyyy-dd-MM kk:mm:ss.SSS\"));\n+        testTimestampWithTZHelper(packDateTimeWithZone(1594846503123L, \"UTC\"), \"2020-15-07 20:55:03.123 +0000\", \"custom-date-time\", Optional.of(\"yyyy-dd-MM kk:mm:ss.SSS Z\"));\n+    }\n+\n+    @Test\n+    public void testIso8601Format()\n+    {\n+        testDateHelper(18458, \"2020-07-15\", \"iso8601\", Optional.empty());\n+        testTimeHelper(1594846503123L, \"20:55:03.123\", \"iso8601\", Optional.empty());\n+        testTimeWithTZHelper(packDateTimeWithZone(1594846503123L, \"UTC\"), \"20:55:03.123Z\", \"iso8601\", Optional.empty());\n+        testTimestampHelper(1594846503123L, \"2020-07-15T20:55:03.123\", \"iso8601\", Optional.empty());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4NDU5Mw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458384593", "bodyText": "Make it final, too.", "author": "aalbu", "createdAt": "2020-07-21T21:00:12Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public class CustomDateTimeFormatFunctions", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MDA4Ng==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458470086", "bodyText": "The parentheses around the return value are not necessary (and I personally feel they reduce readability).  I also like more passing the temporal value to the formatter:\nreturn millis -> formatter.print(new DateTime(millis, UTC));\nA possible optimization could be pre-instantiating formatters for all patterns when creating the encoder and reusing them (the Joda ones are thread safe), as opposed to doing it for every row.", "author": "aalbu", "createdAt": "2020-07-22T00:49:26Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static JsonDateTimeFormatFunction dateFormatFunction(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH);\n+            return (millis -> (new DateTime(millis, DateTimeZone.UTC)).toString(formatter));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUxNDA3Nw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r458514077", "bodyText": "Shouldn't these functions reuse the same DateTimeFormatter's?", "author": "charlesjmorgan", "createdAt": "2020-07-22T03:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MDA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4MzkzNg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r459683936", "bodyText": "You're right, you're actually doing what I was suggesting.  I misread the code.", "author": "aalbu", "createdAt": "2020-07-23T19:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MDA4Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyOTcxNA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r461329714", "bodyText": "I think this can be written in a less repetitive way.  Something like:\nif (type == TIME ||\n            type == TIME_WITH_TIME_ZONE ||\n            type instanceof TimestampType ||\n            type instanceof TimestampWithTimeZoneType) {\n    return true;\n}\nreturn supportsDate && type == DATE;", "author": "aalbu", "createdAt": "2020-07-28T05:37:21Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/JsonFormatFunctions.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public final class JsonFormatFunctions\n+{\n+    public enum FormatType {\n+        CUSTOM_DATE_TIME(true),\n+        ISO8601(true),\n+        RFC2822(true),\n+        MILLISECONDS_SINCE_EPOCH(false),\n+        SECONDS_SINCE_EPOCH(false);\n+\n+        private final boolean supportsDate;\n+\n+        FormatType(boolean supportsDate)\n+        {\n+            this.supportsDate = supportsDate;\n+        }\n+\n+        public boolean isSupportedType(Type type)\n+        {\n+            if (supportsDate) {\n+                return type == DATE ||\n+                        type == TIME ||\n+                        type == TIME_WITH_TIME_ZONE ||\n+                        type instanceof TimestampType ||\n+                        type instanceof TimestampWithTimeZoneType;\n+            }\n+            return type == TIME ||\n+                    type == TIME_WITH_TIME_ZONE ||\n+                    type instanceof TimestampType ||\n+                    type instanceof TimestampWithTimeZoneType;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMzMTY2OA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r461331668", "bodyText": "This gets called for TimestampType, but the encoding that seems to be expected here is that of a TimestampWithTimeZoneType.", "author": "aalbu", "createdAt": "2020-07-28T05:43:36Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public final class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static Function<Long, String> dateFormatFunction(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> (new DateTime(millis, DateTimeZone.UTC)).toString(formatter);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> timeFormatFunction(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> formatter.print(new DateTime(millis, DateTimeZone.UTC));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> timeWithTZFormatFunction(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return encodedMillisWithTZ -> formatter.print(new DateTime(\n+                    unpackMillisUtc(encodedMillisWithTZ),\n+                    DateTimeZone.forID(unpackZoneKey(encodedMillisWithTZ).getId())));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> timestampFormatFunction(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> formatter.print(new DateTime(millis, DateTimeZone.UTC));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> legacyTimestampFormatFunction(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return encodedMillisWithTZ -> formatter.print(Instant.ofEpochMilli(unpackMillisUtc(encodedMillisWithTZ)));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMzMzc4MA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r461333780", "bodyText": "I can't see where this is used outside of tests.", "author": "aalbu", "createdAt": "2020-07-28T05:49:56Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/JsonFormatFunctions.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public final class JsonFormatFunctions\n+{\n+    public enum FormatType {\n+        CUSTOM_DATE_TIME(true),\n+        ISO8601(true),\n+        RFC2822(true),\n+        MILLISECONDS_SINCE_EPOCH(false),\n+        SECONDS_SINCE_EPOCH(false);\n+\n+        private final boolean supportsDate;\n+\n+        FormatType(boolean supportsDate)\n+        {\n+            this.supportsDate = supportsDate;\n+        }\n+\n+        public boolean isSupportedType(Type type)\n+        {\n+            if (supportsDate) {\n+                return type == DATE ||\n+                        type == TIME ||\n+                        type == TIME_WITH_TIME_ZONE ||\n+                        type instanceof TimestampType ||\n+                        type instanceof TimestampWithTimeZoneType;\n+            }\n+            return type == TIME ||\n+                    type == TIME_WITH_TIME_ZONE ||\n+                    type instanceof TimestampType ||\n+                    type instanceof TimestampWithTimeZoneType;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return name().toLowerCase(Locale.ENGLISH).replaceAll(\"_\", \"-\");\n+        }\n+    }\n+\n+    private JsonFormatFunctions() {}\n+\n+    public static long daysToEpochMillis(long value)\n+    {\n+        return DAYS.toMillis(value);\n+    }\n+\n+    public static long millisToSeconds(long value)\n+    {\n+        return MILLISECONDS.toSeconds(value);\n+    }\n+\n+    public static Function<Long, String> dateFormatFunction(FormatType formatType, Optional<String> formatHint)\n+    {\n+        switch (formatType) {\n+            case CUSTOM_DATE_TIME:\n+                checkArgument(formatHint.isPresent(), \"formatHint not defined for custom-date-time column\");\n+                return CustomDateTimeFormatFunctions.dateFormatFunction(formatHint.get());\n+            case ISO8601:\n+                return ISO8601FormatFunctions.dateFormatFunction();\n+            case RFC2822:\n+                return RFC2822FormatFunctions.dateFormatFunction();\n+            case MILLISECONDS_SINCE_EPOCH:\n+                return MillisecondsFormatFunctions.millisecondsFormatFunction();\n+            case SECONDS_SINCE_EPOCH:\n+                return SecondsFormatFunctions.secondsFormatFunction();\n+            default:\n+                throw new IllegalArgumentException(format(\"Invalid dataFormat '%s'\", formatType));\n+        }\n+    }\n+\n+    public static Function<Long, String> timeFormatFunction(FormatType formatType, Optional<String> formatHint)\n+    {\n+        switch (formatType) {\n+            case CUSTOM_DATE_TIME:\n+                checkArgument(formatHint.isPresent(), \"formatHint not defined for custom-date-time column\");\n+                return CustomDateTimeFormatFunctions.timeFormatFunction(formatHint.get());\n+            case ISO8601:\n+                return ISO8601FormatFunctions.timeFormatFunction();\n+            case RFC2822:\n+                return RFC2822FormatFunctions.timeFormatFunction();\n+            case MILLISECONDS_SINCE_EPOCH:\n+                return MillisecondsFormatFunctions.millisecondsFormatFunction();\n+            case SECONDS_SINCE_EPOCH:\n+                return SecondsFormatFunctions.secondsFormatFunction();\n+            default:\n+                throw new IllegalArgumentException(format(\"Invalid dataFormat '%s'\", formatType));\n+        }\n+    }\n+\n+    public static Function<Long, String> timeWithTZFormatFunction(FormatType formatType, Optional<String> formatHint)\n+    {\n+        switch (formatType) {\n+            case CUSTOM_DATE_TIME:\n+                checkArgument(formatHint.isPresent(), \"formatHint not defined for custom-date-time column\");\n+                return CustomDateTimeFormatFunctions.timeWithTZFormatFunction(formatHint.get());\n+            case ISO8601:\n+                return ISO8601FormatFunctions.timeWithTZFormatFunction();\n+            case RFC2822:\n+                return RFC2822FormatFunctions.timeWithTZFormatFunction();\n+            case MILLISECONDS_SINCE_EPOCH:\n+                return MillisecondsFormatFunctions.millisecondsWithTZFormatFunction();\n+            case SECONDS_SINCE_EPOCH:\n+                return SecondsFormatFunctions.secondsWithTZFormatFunction();\n+            default:\n+                throw new IllegalArgumentException(format(\"Invalid dataFormat '%s'\", formatType));\n+        }\n+    }\n+\n+    public static Function<Long, String> timestampFormatFunction(FormatType formatType, Optional<String> formatHint)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxNTQzOA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r461815438", "bodyText": "removed and replaced with legacy function", "author": "charlesjmorgan", "createdAt": "2020-07-28T19:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMzMzc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMzMzk5Ng==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r461333996", "bodyText": "This is a confusing name.", "author": "aalbu", "createdAt": "2020-07-28T05:50:31Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/JsonFormatFunctions.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public final class JsonFormatFunctions\n+{\n+    public enum FormatType {\n+        CUSTOM_DATE_TIME(true),\n+        ISO8601(true),\n+        RFC2822(true),\n+        MILLISECONDS_SINCE_EPOCH(false),\n+        SECONDS_SINCE_EPOCH(false);\n+\n+        private final boolean supportsDate;\n+\n+        FormatType(boolean supportsDate)\n+        {\n+            this.supportsDate = supportsDate;\n+        }\n+\n+        public boolean isSupportedType(Type type)\n+        {\n+            if (supportsDate) {\n+                return type == DATE ||\n+                        type == TIME ||\n+                        type == TIME_WITH_TIME_ZONE ||\n+                        type instanceof TimestampType ||\n+                        type instanceof TimestampWithTimeZoneType;\n+            }\n+            return type == TIME ||\n+                    type == TIME_WITH_TIME_ZONE ||\n+                    type instanceof TimestampType ||\n+                    type instanceof TimestampWithTimeZoneType;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return name().toLowerCase(Locale.ENGLISH).replaceAll(\"_\", \"-\");\n+        }\n+    }\n+\n+    private JsonFormatFunctions() {}\n+\n+    public static long daysToEpochMillis(long value)\n+    {\n+        return DAYS.toMillis(value);\n+    }\n+\n+    public static long millisToSeconds(long value)\n+    {\n+        return MILLISECONDS.toSeconds(value);\n+    }\n+\n+    public static Function<Long, String> dateFormatFunction(FormatType formatType, Optional<String> formatHint)\n+    {\n+        switch (formatType) {\n+            case CUSTOM_DATE_TIME:\n+                checkArgument(formatHint.isPresent(), \"formatHint not defined for custom-date-time column\");\n+                return CustomDateTimeFormatFunctions.dateFormatFunction(formatHint.get());\n+            case ISO8601:\n+                return ISO8601FormatFunctions.dateFormatFunction();\n+            case RFC2822:\n+                return RFC2822FormatFunctions.dateFormatFunction();\n+            case MILLISECONDS_SINCE_EPOCH:\n+                return MillisecondsFormatFunctions.millisecondsFormatFunction();\n+            case SECONDS_SINCE_EPOCH:\n+                return SecondsFormatFunctions.secondsFormatFunction();\n+            default:\n+                throw new IllegalArgumentException(format(\"Invalid dataFormat '%s'\", formatType));\n+        }\n+    }\n+\n+    public static Function<Long, String> timeFormatFunction(FormatType formatType, Optional<String> formatHint)\n+    {\n+        switch (formatType) {\n+            case CUSTOM_DATE_TIME:\n+                checkArgument(formatHint.isPresent(), \"formatHint not defined for custom-date-time column\");\n+                return CustomDateTimeFormatFunctions.timeFormatFunction(formatHint.get());\n+            case ISO8601:\n+                return ISO8601FormatFunctions.timeFormatFunction();\n+            case RFC2822:\n+                return RFC2822FormatFunctions.timeFormatFunction();\n+            case MILLISECONDS_SINCE_EPOCH:\n+                return MillisecondsFormatFunctions.millisecondsFormatFunction();\n+            case SECONDS_SINCE_EPOCH:\n+                return SecondsFormatFunctions.secondsFormatFunction();\n+            default:\n+                throw new IllegalArgumentException(format(\"Invalid dataFormat '%s'\", formatType));\n+        }\n+    }\n+\n+    public static Function<Long, String> timeWithTZFormatFunction(FormatType formatType, Optional<String> formatHint)\n+    {\n+        switch (formatType) {\n+            case CUSTOM_DATE_TIME:\n+                checkArgument(formatHint.isPresent(), \"formatHint not defined for custom-date-time column\");\n+                return CustomDateTimeFormatFunctions.timeWithTZFormatFunction(formatHint.get());\n+            case ISO8601:\n+                return ISO8601FormatFunctions.timeWithTZFormatFunction();\n+            case RFC2822:\n+                return RFC2822FormatFunctions.timeWithTZFormatFunction();\n+            case MILLISECONDS_SINCE_EPOCH:\n+                return MillisecondsFormatFunctions.millisecondsWithTZFormatFunction();\n+            case SECONDS_SINCE_EPOCH:\n+                return SecondsFormatFunctions.secondsWithTZFormatFunction();\n+            default:\n+                throw new IllegalArgumentException(format(\"Invalid dataFormat '%s'\", formatType));\n+        }\n+    }\n+\n+    public static Function<Long, String> timestampFormatFunction(FormatType formatType, Optional<String> formatHint)\n+    {\n+        switch (formatType) {\n+            case CUSTOM_DATE_TIME:\n+                checkArgument(formatHint.isPresent(), \"formatHint not defined for custom-date-time column\");\n+                return CustomDateTimeFormatFunctions.timestampFormatFunction(formatHint.get());\n+            case ISO8601:\n+                return ISO8601FormatFunctions.timestampFormatFunction();\n+            case RFC2822:\n+                return RFC2822FormatFunctions.timestampFormatFunction();\n+            case MILLISECONDS_SINCE_EPOCH:\n+                return MillisecondsFormatFunctions.millisecondsFormatFunction();\n+            case SECONDS_SINCE_EPOCH:\n+                return SecondsFormatFunctions.secondsFormatFunction();\n+            default:\n+                throw new IllegalArgumentException(format(\"Invalid dataFormat '%s'\", formatType));\n+        }\n+    }\n+\n+    public static Function<Long, String> legacyTimestampFormatFunction(FormatType formatType, Optional<String> formatHint)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxNTU1Mw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r461815553", "bodyText": "tried to rename functions to be more descriptive", "author": "charlesjmorgan", "createdAt": "2020-07-28T19:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMzMzk5Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3OTgxMA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r461879810", "bodyText": "You actually don't need all the elses.", "author": "aalbu", "createdAt": "2020-07-28T21:07:07Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.FormatType;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.daysToEpochMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getDateFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimeFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimeWithTZFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimestampFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimestampWithTZFormatFunction;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+    private final List<JsonFormatFunction> formatFunctions;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        checkArgument(this.session.isLegacyTimestamp(), \"The JSON encoder does not support non-legacy timestamp semantics\");\n+\n+        ImmutableList.Builder<JsonFormatFunction> formatFunctions = ImmutableList.builder();\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+            if (isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                FormatType dataFormat = parseDataFormat(columnHandle.getDataFormat(), columnHandle.getName());\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+                if (dataFormat == FormatType.CUSTOM_DATE_TIME) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+\n+                formatFunctions.add(getDateTimeFormatFunction(columnHandle.getType(), dataFormat, Optional.ofNullable(columnHandle.getFormatHint()), columnHandle.getName()));\n+            }\n+            else {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                formatFunctions.add(JsonFormatFunction.builder().build());\n+            }\n+        }\n+\n+        this.formatFunctions = formatFunctions.build();\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                isDateTimeType(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private FormatType parseDataFormat(String dataFormat, String columnName)\n+    {\n+        try {\n+            return FormatType.valueOf(dataFormat.toUpperCase().replaceAll(\"-\", \"_\"));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Unable to parse data format '%s' for column '%s'\", dataFormat, columnName), e);\n+        }\n+    }\n+\n+    private JsonFormatFunction getDateTimeFormatFunction(Type type, JsonFormatFunctions.FormatType dataFormat, Optional<String> formatHint, String name)\n+    {\n+        if (type == DATE) {\n+            return JsonFormatFunction.builder().setFormatDateFunc(getDateFormatFunction(dataFormat, formatHint)).build();\n+        }\n+        else if (type == TIME) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI0NjcxMQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462246711", "bodyText": "You can use a static import (below too).", "author": "aalbu", "createdAt": "2020-07-29T12:04:07Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public final class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static Function<Long, String> formatDateFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI0OTAwMg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462249002", "bodyText": "Let's be consistent in the way we format.  Either new DateTime(...).toString(fromatter) as here, or formatter.print(new DateTime(...)) as below.", "author": "aalbu", "createdAt": "2020-07-29T12:08:25Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public final class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static Function<Long, String> formatDateFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> (new DateTime(millis, DateTimeZone.UTC)).toString(formatter);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2NzI1Mw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462267253", "bodyText": "You could define\nprivate static final Function<Long, String> UNIMPLEMENTED = ignored -> { throw new RuntimeException(\"unsupported argument type\"); };\n\nand reference that:\nprivate Function<Long, String> formatDateFunc = UNIMPLEMENTED;\nprivate Function<Long, String> formatTimeFunc = UNIMPLEMENTED;\n...", "author": "aalbu", "createdAt": "2020-07-29T12:41:31Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/JsonFormatFunction.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import java.util.function.Function;\n+\n+public class JsonFormatFunction\n+{\n+    private final Function<Long, String> formatDateFunc;\n+    private final Function<Long, String> formatTimeFunc;\n+    private final Function<Long, String> formatTimeWithTZFunc;\n+    private final Function<Long, String> formatTimestampFunc;\n+    private final Function<Long, String> formatTimestampWithTZFunc;\n+\n+    private JsonFormatFunction(\n+            Function<Long, String> formatDateFunc,\n+            Function<Long, String> formatTimeFunc,\n+            Function<Long, String> formatTimeWithTZFunc,\n+            Function<Long, String> formatTimestampFunc,\n+            Function<Long, String> formatTimestampWithTZFunc)\n+    {\n+        this.formatDateFunc = formatDateFunc;\n+        this.formatTimeFunc = formatTimeFunc;\n+        this.formatTimeWithTZFunc = formatTimeWithTZFunc;\n+        this.formatTimestampFunc = formatTimestampFunc;\n+        this.formatTimestampWithTZFunc = formatTimestampWithTZFunc;\n+    }\n+\n+    public static Builder builder()\n+    {\n+        return new Builder();\n+    }\n+\n+    public String formatDate(long value)\n+    {\n+        return formatDateFunc.apply(value);\n+    }\n+\n+    public String formatTime(long value)\n+    {\n+        return formatTimeFunc.apply(value);\n+    }\n+\n+    public String formatTimeWithTZ(long value)\n+    {\n+        return formatTimeWithTZFunc.apply(value);\n+    }\n+\n+    public String formatTimestamp(long value)\n+    {\n+        return formatTimestampFunc.apply(value);\n+    }\n+\n+    public String formatTimestampWithTZ(long value)\n+    {\n+        return formatTimestampWithTZFunc.apply(value);\n+    }\n+\n+    public static class Builder\n+    {\n+        private Function<Long, String> formatDateFunc = (ignored) -> { throw new RuntimeException(\"unsupported argument type\"); };", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI3MDYwMg==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462270602", "bodyText": "This is subjective, but you could just as well inline.  I think DAYS.toMillis(value) reads pretty well.", "author": "aalbu", "createdAt": "2020-07-29T12:47:19Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/JsonFormatFunctions.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.DAYS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public final class JsonFormatFunctions\n+{\n+    public enum FormatType {\n+        CUSTOM_DATE_TIME(true),\n+        ISO8601(true),\n+        RFC2822(true),\n+        MILLISECONDS_SINCE_EPOCH(false),\n+        SECONDS_SINCE_EPOCH(false);\n+\n+        private final boolean supportsDate;\n+\n+        FormatType(boolean supportsDate)\n+        {\n+            this.supportsDate = supportsDate;\n+        }\n+\n+        public boolean isSupportedType(Type type)\n+        {\n+            if (type == TIME ||\n+                    type == TIME_WITH_TIME_ZONE ||\n+                    type instanceof TimestampType ||\n+                    type instanceof TimestampWithTimeZoneType) {\n+                return true;\n+            }\n+            return supportsDate && type == DATE;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return name().toLowerCase(Locale.ENGLISH).replaceAll(\"_\", \"-\");\n+        }\n+    }\n+\n+    private JsonFormatFunctions() {}\n+\n+    public static long daysToEpochMillis(long value)\n+    {\n+        return DAYS.toMillis(value);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI3MjYxMA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462272610", "bodyText": "Perhaps we should not support this scenario.  This does not seem a meaningful return value - without the tz info, the milliseconds don't make much sense here, right?", "author": "aalbu", "createdAt": "2020-07-29T12:50:31Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/MillisecondsFormatFunctions.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+\n+public final class MillisecondsFormatFunctions\n+{\n+    private MillisecondsFormatFunctions() {}\n+\n+    public static Function<Long, String> formatMillisFunc()\n+    {\n+        return String::valueOf;\n+    }\n+\n+    public static Function<Long, String> formatMillisWithTZFunc()\n+    {\n+        return encodedMillisWithTZ -> String.valueOf(unpackMillisUtc(encodedMillisWithTZ));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI4MjY0OA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462282648", "bodyText": "Sorry, that was wrong.  This format implies millis since epoch.", "author": "aalbu", "createdAt": "2020-07-29T13:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI3MjYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI3NTc4NQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462275785", "bodyText": "Perhaps this would warrant being public in JsonFormatFunctions.  It's being used in ISO8601FormatFunctions, as well.", "author": "aalbu", "createdAt": "2020-07-29T12:55:47Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/RFC2822FormatFunctions.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.time.ZoneOffset.UTC;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public final class RFC2822FormatFunctions\n+{\n+    private static final DateTimeFormatter RFC_FORMATTER = DateTimeFormatter.ofPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withLocale(Locale.ENGLISH);\n+\n+    private RFC2822FormatFunctions() {}\n+\n+    public static Function<Long, String> formatDateFunc()\n+    {\n+        return millis -> RFC_FORMATTER.format(\n+                ZonedDateTime.of(\n+                        LocalDate.ofEpochDay(MILLISECONDS.toDays(millis)),\n+                        LocalTime.MIDNIGHT,\n+                        UTC));\n+    }\n+\n+    public static Function<Long, String> formatTimeFunc()\n+    {\n+        return millis -> RFC_FORMATTER.format(\n+                ZonedDateTime.of(\n+                        LocalDate.EPOCH,\n+                        localTimeOfEpochMillis(millis),\n+                        UTC));\n+    }\n+\n+    public static Function<Long, String> formatTimeWithTZFunc()\n+    {\n+        return encodedMillisWithTZ -> RFC_FORMATTER.format(\n+                ZonedDateTime.of(\n+                        LocalDate.EPOCH,\n+                        localTimeOfEpochMillis(unpackMillisUtc(encodedMillisWithTZ)),\n+                        unpackZoneKey(encodedMillisWithTZ).getZoneId()));\n+    }\n+\n+    public static Function<Long, String> formatTimestampFunc()\n+    {\n+        return millis -> RFC_FORMATTER.format(\n+                ZonedDateTime.of(\n+                        localDateTimeOfEpochMillis(millis),\n+                        UTC));\n+    }\n+\n+    public static Function<Long, String> formatTimestampWithTZFunc()\n+    {\n+        return encodedMillisWithTZ -> RFC_FORMATTER.format(\n+                ZonedDateTime.of(\n+                        localDateTimeOfEpochMillis(unpackMillisUtc(encodedMillisWithTZ)),\n+                        unpackZoneKey(encodedMillisWithTZ).getZoneId()));\n+    }\n+\n+    private static LocalDateTime localDateTimeOfEpochMillis(long epochMillis)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI3NjM4Nw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462276387", "bodyText": "Another situation in which we're throwing away tz info.", "author": "aalbu", "createdAt": "2020-07-29T12:56:39Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/SecondsFormatFunctions.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import java.util.function.Function;\n+\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.millisToSeconds;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+\n+public final class SecondsFormatFunctions\n+{\n+    private SecondsFormatFunctions() {}\n+\n+    public static Function<Long, String> formatSecondsFunc()\n+    {\n+        return millis -> String.valueOf(millisToSeconds(millis));\n+    }\n+\n+    public static Function<Long, String> formatSecondsWithTZFunc()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2MDEyNw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462860127", "bodyText": "This is like unix time(), it's fine.", "author": "findepi", "createdAt": "2020-07-30T09:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI3NjM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzNDc5OA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462334798", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n          \n          \n            \n                            checkArgument(columnHandle.getDataFormat() != null, \"No dataFormat defined for temporal column '%s'\", columnHandle.getName());", "author": "findepi", "createdAt": "2020-07-29T14:18:12Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.FormatType;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.daysToEpochMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getDateFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimeFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimeWithTZFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimestampFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimestampWithTZFormatFunction;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+    private final List<JsonFormatFunction> formatFunctions;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        checkArgument(this.session.isLegacyTimestamp(), \"The JSON encoder does not support non-legacy timestamp semantics\");\n+\n+        ImmutableList.Builder<JsonFormatFunction> formatFunctions = ImmutableList.builder();\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+            if (isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzNTcxNw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462335717", "bodyText": "redundant else (https://github.com/prestosql/presto/#additional-ide-configuration)", "author": "findepi", "createdAt": "2020-07-29T14:19:25Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/JsonRowEncoder.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.plugin.kafka.encoder.AbstractRowEncoder;\n+import io.prestosql.plugin.kafka.encoder.EncoderColumnHandle;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunction;\n+import io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.type.SqlDate;\n+import io.prestosql.spi.type.SqlTime;\n+import io.prestosql.spi.type.SqlTimeWithTimeZone;\n+import io.prestosql.spi.type.SqlTimestamp;\n+import io.prestosql.spi.type.SqlTimestampWithTimeZone;\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.TimestampWithTimeZoneType;\n+import io.prestosql.spi.type.Type;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.FormatType;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.daysToEpochMillis;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getDateFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimeFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimeWithTZFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimestampFormatFunction;\n+import static io.prestosql.plugin.kafka.encoder.json.format.JsonFormatFunctions.getTimestampWithTZFormatFunction;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n+import static io.prestosql.spi.type.DateTimeEncoding.packDateTimeWithZone;\n+import static io.prestosql.spi.type.DateType.DATE;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static io.prestosql.spi.type.TimeType.TIME;\n+import static io.prestosql.spi.type.TimeWithTimeZoneType.TIME_WITH_TIME_ZONE;\n+import static io.prestosql.spi.type.TinyintType.TINYINT;\n+import static io.prestosql.spi.type.Varchars.isVarcharType;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class JsonRowEncoder\n+        extends AbstractRowEncoder\n+{\n+    private static final Set<Type> PRIMITIVE_SUPPORTED_TYPES = ImmutableSet.of(\n+            BIGINT, INTEGER, SMALLINT, TINYINT, DOUBLE, BOOLEAN);\n+    private static final Set<Type> NON_PARAMETRIC_DATE_TIME_TYPES = ImmutableSet.of(\n+            DATE, TIME, TIME_WITH_TIME_ZONE);\n+\n+    public static final String NAME = \"json\";\n+\n+    private final ObjectMapper objectMapper;\n+    private final ObjectNode node;\n+    private final List<JsonFormatFunction> formatFunctions;\n+\n+    JsonRowEncoder(ConnectorSession session, List<EncoderColumnHandle> columnHandles, ObjectMapper objectMapper)\n+    {\n+        super(session, columnHandles);\n+        checkArgument(this.session.isLegacyTimestamp(), \"The JSON encoder does not support non-legacy timestamp semantics\");\n+\n+        ImmutableList.Builder<JsonFormatFunction> formatFunctions = ImmutableList.builder();\n+        for (EncoderColumnHandle columnHandle : this.columnHandles) {\n+            checkArgument(isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+            if (isDateTimeType(columnHandle.getType())) {\n+                checkArgument(columnHandle.getDataFormat() != null, \"Unsupported or no dataFormat '%s' defined for temporal column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                FormatType dataFormat = parseDataFormat(columnHandle.getDataFormat(), columnHandle.getName());\n+                checkArgument(dataFormat.isSupportedType(columnHandle.getType()), \"Unsupported column type '%s' for column '%s'\", columnHandle.getType(), columnHandle.getName());\n+\n+                if (dataFormat == FormatType.CUSTOM_DATE_TIME) {\n+                    checkArgument(columnHandle.getFormatHint() != null, \"No format hint defined for column '%s'\", columnHandle.getName());\n+                }\n+                else {\n+                    checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                }\n+\n+                formatFunctions.add(getDateTimeFormatFunction(columnHandle.getType(), dataFormat, Optional.ofNullable(columnHandle.getFormatHint()), columnHandle.getName()));\n+            }\n+            else {\n+                checkArgument(columnHandle.getFormatHint() == null, \"Unexpected format hint '%s' defined for column '%s'\", columnHandle.getFormatHint(), columnHandle.getName());\n+                checkArgument(columnHandle.getDataFormat() == null, \"Unexpected data format '%s' defined for column '%s'\", columnHandle.getDataFormat(), columnHandle.getName());\n+                formatFunctions.add(JsonFormatFunction.builder().build());\n+            }\n+        }\n+\n+        this.formatFunctions = formatFunctions.build();\n+        this.objectMapper = requireNonNull(objectMapper, \"objectMapper is null\");\n+        this.node = objectMapper.createObjectNode();\n+    }\n+\n+    private boolean isSupportedType(Type type)\n+    {\n+        return isVarcharType(type) ||\n+                PRIMITIVE_SUPPORTED_TYPES.contains(type) ||\n+                isDateTimeType(type);\n+    }\n+\n+    private boolean isDateTimeType(Type type)\n+    {\n+        return type instanceof TimestampType ||\n+                type instanceof TimestampWithTimeZoneType ||\n+                NON_PARAMETRIC_DATE_TIME_TYPES.contains(type);\n+    }\n+\n+    private FormatType parseDataFormat(String dataFormat, String columnName)\n+    {\n+        try {\n+            return FormatType.valueOf(dataFormat.toUpperCase().replaceAll(\"-\", \"_\"));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Unable to parse data format '%s' for column '%s'\", dataFormat, columnName), e);\n+        }\n+    }\n+\n+    private JsonFormatFunction getDateTimeFormatFunction(Type type, JsonFormatFunctions.FormatType dataFormat, Optional<String> formatHint, String name)\n+    {\n+        if (type == DATE) {\n+            return JsonFormatFunction.builder().setFormatDateFunc(getDateFormatFunction(dataFormat, formatHint)).build();\n+        }\n+        else if (type == TIME) {\n+            return JsonFormatFunction.builder().setFormatTimeFunc(getTimeFormatFunction(dataFormat, formatHint)).build();\n+        }\n+        else if (type == TIME_WITH_TIME_ZONE) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzNjQ1Ng==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462336456", "bodyText": "avoid abbreviations\nfunc -> function", "author": "findepi", "createdAt": "2020-07-29T14:20:20Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public final class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static Function<Long, String> formatDateFunc(String formatHint)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzNzczOQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462337739", "bodyText": "is the format hint documented to be Joda Time?", "author": "findepi", "createdAt": "2020-07-29T14:21:52Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public final class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static Function<Long, String> formatDateFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0MDcyOQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462340729", "bodyText": "Code is correct but I would find it more readable if the lambda was outside of try block...", "author": "findepi", "createdAt": "2020-07-29T14:25:41Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public final class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static Function<Long, String> formatDateFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> (new DateTime(millis, DateTimeZone.UTC)).toString(formatter);\n+        }\n+        catch (IllegalArgumentException e) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0MzE5MQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462343191", "bodyText": "I think it would be better to supplement the session zone here.\nThis would make it more similar to the non-legacy case, when we implement it.\nIe\nINSERT ,.. TIMESTAMP 'some_date_time'\nwould be some_date_time session_zone in legacy\nand some_date_time in non-legacy\nand if the format hint does not contain the zone,\nthey would actually be the same.", "author": "findepi", "createdAt": "2020-07-29T14:28:48Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public final class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static Function<Long, String> formatDateFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> (new DateTime(millis, DateTimeZone.UTC)).toString(formatter);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0MzcxNw==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462343717", "bodyText": "encodedMillisWithTZ -> value", "author": "findepi", "createdAt": "2020-07-29T14:29:25Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public final class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static Function<Long, String> formatDateFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> (new DateTime(millis, DateTimeZone.UTC)).toString(formatter);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> formatTimeFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> formatter.print(new DateTime(millis, DateTimeZone.UTC));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> formatTimeWithTZFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return encodedMillisWithTZ -> formatter.print(new DateTime(\n+                    unpackMillisUtc(encodedMillisWithTZ),\n+                    DateTimeZone.forID(unpackZoneKey(encodedMillisWithTZ).getId())));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> formatTimestampFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> formatter.print(Instant.ofEpochMilli(millis));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> formatTimestampWithTZFunction(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return encodedMillisWithTZ -> formatter.print(new DateTime(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0Mzc5MQ==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462343791", "bodyText": "joda -> Joda Time", "author": "findepi", "createdAt": "2020-07-29T14:29:33Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/CustomDateTimeFormatFunctions.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackMillisUtc;\n+import static io.prestosql.spi.type.DateTimeEncoding.unpackZoneKey;\n+import static java.lang.String.format;\n+\n+public final class CustomDateTimeFormatFunctions\n+{\n+    private CustomDateTimeFormatFunctions() {}\n+\n+    public static Function<Long, String> formatDateFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> (new DateTime(millis, DateTimeZone.UTC)).toString(formatter);\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> formatTimeFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> formatter.print(new DateTime(millis, DateTimeZone.UTC));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> formatTimeWithTZFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return encodedMillisWithTZ -> formatter.print(new DateTime(\n+                    unpackMillisUtc(encodedMillisWithTZ),\n+                    DateTimeZone.forID(unpackZoneKey(encodedMillisWithTZ).getId())));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> formatTimestampFunc(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return millis -> formatter.print(Instant.ofEpochMilli(millis));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);\n+        }\n+    }\n+\n+    public static Function<Long, String> formatTimestampWithTZFunction(String formatHint)\n+    {\n+        try {\n+            DateTimeFormatter formatter = DateTimeFormat.forPattern(formatHint).withLocale(Locale.ENGLISH).withZoneUTC();\n+            return encodedMillisWithTZ -> formatter.print(new DateTime(\n+                    unpackMillisUtc(encodedMillisWithTZ),\n+                    DateTimeZone.forID(unpackZoneKey(encodedMillisWithTZ).getId())));\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(format(\"Invalid joda pattern '%s' passed as format hint\", formatHint), e);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0NDUwOA==", "url": "https://github.com/trinodb/trino/pull/4477#discussion_r462344508", "bodyText": "withTZ -> withTimeZone", "author": "findepi", "createdAt": "2020-07-29T14:30:27Z", "path": "presto-kafka/src/main/java/io/prestosql/plugin/kafka/encoder/json/format/JsonFormatFunction.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.kafka.encoder.json.format;\n+\n+import java.util.function.Function;\n+\n+public class JsonFormatFunction\n+{\n+    private final Function<Long, String> formatDateFunc;\n+    private final Function<Long, String> formatTimeFunc;\n+    private final Function<Long, String> formatTimeWithTZFunc;\n+    private final Function<Long, String> formatTimestampFunc;\n+    private final Function<Long, String> formatTimestampWithTZFunc;\n+\n+    private JsonFormatFunction(\n+            Function<Long, String> formatDateFunc,\n+            Function<Long, String> formatTimeFunc,\n+            Function<Long, String> formatTimeWithTZFunc,\n+            Function<Long, String> formatTimestampFunc,\n+            Function<Long, String> formatTimestampWithTZFunc)\n+    {\n+        this.formatDateFunc = formatDateFunc;\n+        this.formatTimeFunc = formatTimeFunc;\n+        this.formatTimeWithTZFunc = formatTimeWithTZFunc;\n+        this.formatTimestampFunc = formatTimestampFunc;\n+        this.formatTimestampWithTZFunc = formatTimestampWithTZFunc;\n+    }\n+\n+    public static Builder builder()\n+    {\n+        return new Builder();\n+    }\n+\n+    public String formatDate(long value)\n+    {\n+        return formatDateFunc.apply(value);\n+    }\n+\n+    public String formatTime(long value)\n+    {\n+        return formatTimeFunc.apply(value);\n+    }\n+\n+    public String formatTimeWithTZ(long value)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "99ad68ebbb965e304717c2bd56ae01639aee5cc6", "url": "https://github.com/trinodb/trino/commit/99ad68ebbb965e304717c2bd56ae01639aee5cc6", "message": "Add Kafka Json encoder", "committedDate": "2020-07-30T16:42:38Z", "type": "commit"}, {"oid": "99ad68ebbb965e304717c2bd56ae01639aee5cc6", "url": "https://github.com/trinodb/trino/commit/99ad68ebbb965e304717c2bd56ae01639aee5cc6", "message": "Add Kafka Json encoder", "committedDate": "2020-07-30T16:42:38Z", "type": "forcePushed"}]}