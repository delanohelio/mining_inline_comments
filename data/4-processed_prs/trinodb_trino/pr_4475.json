{"pr_number": 4475, "pr_title": "Fix nested parametric timestamp compatibility with older clients", "pr_createdAt": "2020-07-16T18:24:50Z", "pr_url": "https://github.com/trinodb/trino/pull/4475", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwMDg2MA==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456000860", "bodyText": "Does ROW type also need to be handled here?\ni guess not, but worth adding a comment why", "author": "findepi", "createdAt": "2020-07-16T18:51:04Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -184,6 +179,48 @@ else if (type instanceof TimestampWithTimeZoneType) {\n         return Optional.of(unmodifiableList(row));\n     }\n \n+    private Object roundParametricDateTime(Object value, Type type)\n+    {\n+        if (supportsParametricDateTime || value == null) {\n+            return value;\n+        }\n+\n+        if (type instanceof TimestampType) {\n+            return ((SqlTimestamp) value).roundTo(3);\n+        }\n+\n+        if (type instanceof TimestampWithTimeZoneType) {\n+            return ((SqlTimestampWithTimeZone) value).roundTo(3);\n+        }\n+\n+        if (type instanceof ArrayType) {\n+            List<Object> values = (List<Object>) value;\n+\n+            ImmutableList.Builder<Object> result = ImmutableList.builder();\n+            Type elementType = ((ArrayType) type).getElementType();\n+\n+            for (int i = 0; i < values.size(); i++) {\n+                result.add(roundParametricDateTime(values.get(i), elementType));\n+            }\n+\n+            return result.build();\n+        }\n+\n+        if (type instanceof MapType) {\n+            Map<Object, Object> values = (Map<Object, Object>) value;\n+\n+            ImmutableMap.Builder<Object, Object> result = ImmutableMap.builder();\n+            Type keyType = ((MapType) type).getKeyType();\n+            Type valueType = ((MapType) type).getValueType();\n+\n+            values.entrySet().forEach(entry -> result.put(roundParametricDateTime(entry.getKey(), keyType), roundParametricDateTime(entry.getValue(), valueType)));\n+\n+            return result.build();\n+        }\n+\n+        return value;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNTg0NQ==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456005845", "bodyText": "It needs as @martint pointed me. I'm working on updated PR :)", "author": "wendigo", "createdAt": "2020-07-16T18:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwMDg2MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxMjA3NQ==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456012075", "bodyText": "static", "author": "findepi", "createdAt": "2020-07-16T19:11:20Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -184,6 +180,73 @@ else if (type instanceof TimestampWithTimeZoneType) {\n         return Optional.of(unmodifiableList(row));\n     }\n \n+    private Object roundParametricDateTime(Object value, Type type)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1MjI5NA==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456052294", "bodyText": "it can't be static, I'd need to pass supportsParametricDateTime everywhere", "author": "wendigo", "createdAt": "2020-07-16T20:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxMjA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxMjQ0OA==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456012448", "bodyText": "we shouldn't need to copy the array data, if it does not contain a timestamp type\nyou can effect that pretty concisely by making the method return optional\nwhere empty would signal \"no change\"\nthis way you would do the decomposition only once", "author": "findepi", "createdAt": "2020-07-16T19:12:05Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -184,6 +180,73 @@ else if (type instanceof TimestampWithTimeZoneType) {\n         return Optional.of(unmodifiableList(row));\n     }\n \n+    private Object roundParametricDateTime(Object value, Type type)\n+    {\n+        if (supportsParametricDateTime || value == null) {\n+            return value;\n+        }\n+\n+        if (type instanceof TimestampType) {\n+            return ((SqlTimestamp) value).roundTo(3);\n+        }\n+\n+        if (type instanceof TimestampWithTimeZoneType) {\n+            return ((SqlTimestampWithTimeZone) value).roundTo(3);\n+        }\n+\n+        if (type instanceof ArrayType) {\n+            List<Object> values = (List<Object>) value;\n+\n+            ImmutableList.Builder<Object> result = ImmutableList.builder();\n+            Type elementType = ((ArrayType) type).getElementType();\n+\n+            for (int i = 0; i < values.size(); i++) {\n+                result.add(roundParametricDateTime(values.get(i), elementType));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEwMjY5Nw==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456102697", "bodyText": "This is ok for datetime types, but it will require a rewrite if we need to add custom rules for other types. It'd be more robust to structure as:\nif (supportsParametricDateTime) {\n   // common fast path\n}\nelse {\n   // legacy path\n}\nand\nprivate Object getLegacyValue(Object value, Type type)\n{\n    if (value == null) {\n        return null;\n    }\n\n    if (!supportsParametricDateTime) {\n        if (type instanceof TimestampType) {\n            return ((SqlTimestamp) value).roundTo(3);\n        }\n        if (...) {\n            ...\n        }\n    }\n\n    // in the future, handling for other types can be added here...\n\n    if (type instanceof ArrayType) {\n        ...\n    }\n    if (type instanceof MapType) {\n        ...\n    }\n    ...\n}", "author": "martint", "createdAt": "2020-07-16T21:59:49Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -184,6 +186,76 @@ else if (type instanceof TimestampWithTimeZoneType) {\n         return Optional.of(unmodifiableList(row));\n     }\n \n+    private static Object roundParametricDateTime(Object value, Type type)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjExMjE2MQ==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456112161", "bodyText": "Yes, I know.. that's the first bit I mentioned:\nif (supportsParametricDateTime) {\n   // common fast path\n}\nelse {\n   // legacy path\n}\n\nI was just making it explicit for context.", "author": "martint", "createdAt": "2020-07-16T22:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEwMjY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjExMjc4Nw==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456112787", "bodyText": "Oh, got it :)", "author": "wendigo", "createdAt": "2020-07-16T22:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEwMjY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEwNjE5MQ==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456106191", "bodyText": "Field names may need to be quoted. Have you checked how they are rendered currently?", "author": "martint", "createdAt": "2020-07-16T22:08:04Z", "path": "presto-main/src/main/java/io/prestosql/type/TypeUtils.java", "diffHunk": "@@ -151,13 +160,46 @@ public static void checkElementNotNull(boolean isNull, String errorMsg)\n     public static String getDisplayLabel(Type type, Session session)\n     {\n         if (isOmitDateTimeTypePrecision(session)) {\n-            if (type instanceof TimestampType && ((TimestampType) type).getPrecision() == TimestampType.DEFAULT_PRECISION) {\n-                return StandardTypes.TIMESTAMP;\n-            }\n-            else if (type instanceof TimestampWithTimeZoneType && ((TimestampWithTimeZoneType) type).getPrecision() == TimestampWithTimeZoneType.DEFAULT_PRECISION) {\n-                return StandardTypes.TIMESTAMP_WITH_TIME_ZONE;\n-            }\n+            return getDisplayLabelForLegacyClients(type);\n+        }\n+        return type.getDisplayName();\n+    }\n+\n+    private static String getDisplayLabelForLegacyClients(Type type)\n+    {\n+        if (type instanceof TimestampType && ((TimestampType) type).getPrecision() == TimestampType.DEFAULT_PRECISION) {\n+            return StandardTypes.TIMESTAMP;\n+        }\n+        if (type instanceof TimestampWithTimeZoneType && ((TimestampWithTimeZoneType) type).getPrecision() == TimestampWithTimeZoneType.DEFAULT_PRECISION) {\n+            return StandardTypes.TIMESTAMP_WITH_TIME_ZONE;\n         }\n+        if (type instanceof ArrayType) {\n+            return ARRAY + \"(\" + getDisplayLabelForLegacyClients(((ArrayType) type).getElementType()) + \")\";\n+        }\n+        if (type instanceof MapType) {\n+            return MAP + \"(\" + getDisplayLabelForLegacyClients(((MapType) type).getKeyType()) + \", \" + getDisplayLabelForLegacyClients(((MapType) type).getValueType()) + \")\";\n+        }\n+        if (type instanceof RowType) {\n+            return getRowDisplayLabelForLegacyClients((RowType) type);\n+        }\n+\n         return type.getDisplayName();\n     }\n+\n+    private static String getRowDisplayLabelForLegacyClients(RowType type)\n+    {\n+        List<String> fields = type.getFields().stream()\n+                .map(field -> {\n+                    String typeDisplayName = getDisplayLabelForLegacyClients(field.getType());\n+                    if (field.getName().isPresent()) {\n+                        return field.getName().get() + ' ' + typeDisplayName;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEwODUzMw==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456108533", "bodyText": "Yes. I've copied and refactored code from RowType", "author": "wendigo", "createdAt": "2020-07-16T22:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEwNjE5MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNDg2Nw==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456134867", "bodyText": "This can be simplified to:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<Object> values = (List<Object>) value;\n          \n          \n            \n                        ImmutableList.Builder<Object> result = ImmutableList.builder();\n          \n          \n            \n            \n          \n          \n            \n                        for (int i = 0; i < values.size(); i++) {\n          \n          \n            \n                            result.add(getLegacyValue(values.get(i), elementType));\n          \n          \n            \n                        }\n          \n          \n            \n            \n          \n          \n            \n                        return result.build();\n          \n          \n            \n                        return ((List<Object>) value).stream()\n          \n          \n            \n                                .map(element -> getLegacyValue(value, elementType))\n          \n          \n            \n                                .collect(toImmutableList());", "author": "martint", "createdAt": "2020-07-16T23:32:27Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -184,6 +185,80 @@ else if (type instanceof TimestampWithTimeZoneType) {\n         return Optional.of(unmodifiableList(row));\n     }\n \n+    private Object getLegacyValue(Object value, Type type)\n+    {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        if (!supportsParametricDateTime) {\n+            // for legacy clients we need to round timestamp and timestamp with timezone to default precision (3)\n+\n+            if (type instanceof TimestampType) {\n+                return ((SqlTimestamp) value).roundTo(3);\n+            }\n+\n+            if (type instanceof TimestampWithTimeZoneType) {\n+                return ((SqlTimestampWithTimeZone) value).roundTo(3);\n+            }\n+        }\n+\n+        if (type instanceof ArrayType) {\n+            Type elementType = ((ArrayType) type).getElementType();\n+\n+            if (!(elementType instanceof TimestampType || elementType instanceof TimestampWithTimeZoneType)) {\n+                return value;\n+            }\n+\n+            List<Object> values = (List<Object>) value;\n+            ImmutableList.Builder<Object> result = ImmutableList.builder();\n+\n+            for (int i = 0; i < values.size(); i++) {\n+                result.add(getLegacyValue(values.get(i), elementType));\n+            }\n+\n+            return result.build();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNTM5Mw==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456135393", "bodyText": "This can be simplified to:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ImmutableMap.Builder<Object, Object> result = ImmutableMap.builder();\n          \n          \n            \n                        values.entrySet().forEach(entry -> result.put(getLegacyValue(entry.getKey(), keyType), getLegacyValue(entry.getValue(), valueType)));\n          \n          \n            \n                        return result.build();\n          \n          \n            \n                        return ((Map<Object, Object>) value).entrySet().stream()\n          \n          \n            \n                                .collect(toImmutableMap(entry -> getLegacyValue(entry.getKey(), keyType), entry -> getLegacyValue(entry.getValue(), valueType)));", "author": "martint", "createdAt": "2020-07-16T23:34:19Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -184,6 +185,80 @@ else if (type instanceof TimestampWithTimeZoneType) {\n         return Optional.of(unmodifiableList(row));\n     }\n \n+    private Object getLegacyValue(Object value, Type type)\n+    {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        if (!supportsParametricDateTime) {\n+            // for legacy clients we need to round timestamp and timestamp with timezone to default precision (3)\n+\n+            if (type instanceof TimestampType) {\n+                return ((SqlTimestamp) value).roundTo(3);\n+            }\n+\n+            if (type instanceof TimestampWithTimeZoneType) {\n+                return ((SqlTimestampWithTimeZone) value).roundTo(3);\n+            }\n+        }\n+\n+        if (type instanceof ArrayType) {\n+            Type elementType = ((ArrayType) type).getElementType();\n+\n+            if (!(elementType instanceof TimestampType || elementType instanceof TimestampWithTimeZoneType)) {\n+                return value;\n+            }\n+\n+            List<Object> values = (List<Object>) value;\n+            ImmutableList.Builder<Object> result = ImmutableList.builder();\n+\n+            for (int i = 0; i < values.size(); i++) {\n+                result.add(getLegacyValue(values.get(i), elementType));\n+            }\n+\n+            return result.build();\n+        }\n+\n+        if (type instanceof MapType) {\n+            Map<Object, Object> values = (Map<Object, Object>) value;\n+\n+            Type keyType = ((MapType) type).getKeyType();\n+            Type valueType = ((MapType) type).getValueType();\n+\n+            ImmutableMap.Builder<Object, Object> result = ImmutableMap.builder();\n+            values.entrySet().forEach(entry -> result.put(getLegacyValue(entry.getKey(), keyType), getLegacyValue(entry.getValue(), valueType)));\n+            return result.build();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNTkxOA==", "url": "https://github.com/trinodb/trino/pull/4475#discussion_r456135918", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ImmutableMap.Builder<String, Object> result = ImmutableMap.builder();\n          \n          \n            \n                            fields.forEach(field -> result.put(field.getName().orElseThrow(), getLegacyValue(values.get(field.getName()), field.getType())));\n          \n          \n            \n                            return result.build();\n          \n          \n            \n                            return fields.stream()\n          \n          \n            \n                                    .collect(toImmutableMap(field -> field.getName().orElseThrow(), field -> getLegacyValue(values.get(field.getName()), field.getType()));", "author": "martint", "createdAt": "2020-07-16T23:35:59Z", "path": "presto-main/src/main/java/io/prestosql/server/protocol/QueryResultRows.java", "diffHunk": "@@ -184,6 +185,80 @@ else if (type instanceof TimestampWithTimeZoneType) {\n         return Optional.of(unmodifiableList(row));\n     }\n \n+    private Object getLegacyValue(Object value, Type type)\n+    {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        if (!supportsParametricDateTime) {\n+            // for legacy clients we need to round timestamp and timestamp with timezone to default precision (3)\n+\n+            if (type instanceof TimestampType) {\n+                return ((SqlTimestamp) value).roundTo(3);\n+            }\n+\n+            if (type instanceof TimestampWithTimeZoneType) {\n+                return ((SqlTimestampWithTimeZone) value).roundTo(3);\n+            }\n+        }\n+\n+        if (type instanceof ArrayType) {\n+            Type elementType = ((ArrayType) type).getElementType();\n+\n+            if (!(elementType instanceof TimestampType || elementType instanceof TimestampWithTimeZoneType)) {\n+                return value;\n+            }\n+\n+            List<Object> values = (List<Object>) value;\n+            ImmutableList.Builder<Object> result = ImmutableList.builder();\n+\n+            for (int i = 0; i < values.size(); i++) {\n+                result.add(getLegacyValue(values.get(i), elementType));\n+            }\n+\n+            return result.build();\n+        }\n+\n+        if (type instanceof MapType) {\n+            Map<Object, Object> values = (Map<Object, Object>) value;\n+\n+            Type keyType = ((MapType) type).getKeyType();\n+            Type valueType = ((MapType) type).getValueType();\n+\n+            ImmutableMap.Builder<Object, Object> result = ImmutableMap.builder();\n+            values.entrySet().forEach(entry -> result.put(getLegacyValue(entry.getKey(), keyType), getLegacyValue(entry.getValue(), valueType)));\n+            return result.build();\n+        }\n+\n+        if (type instanceof RowType) {\n+            List<RowType.Field> fields = ((RowType) type).getFields();\n+\n+            if (value instanceof Map) {\n+                Map<String, Object> values = (Map<String, Object>) value;\n+\n+                ImmutableMap.Builder<String, Object> result = ImmutableMap.builder();\n+                fields.forEach(field -> result.put(field.getName().orElseThrow(), getLegacyValue(values.get(field.getName()), field.getType())));\n+                return result.build();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1483b0c85189d46f0bf16b909918ab33f3fb62fe", "url": "https://github.com/trinodb/trino/commit/1483b0c85189d46f0bf16b909918ab33f3fb62fe", "message": "Fix nested parametric timestamp compatibility with older clients", "committedDate": "2020-07-16T23:41:52Z", "type": "commit"}, {"oid": "1483b0c85189d46f0bf16b909918ab33f3fb62fe", "url": "https://github.com/trinodb/trino/commit/1483b0c85189d46f0bf16b909918ab33f3fb62fe", "message": "Fix nested parametric timestamp compatibility with older clients", "committedDate": "2020-07-16T23:41:52Z", "type": "forcePushed"}]}