{"pr_number": 5792, "pr_title": "Implement table scan redirection", "pr_createdAt": "2020-11-03T10:42:36Z", "pr_url": "https://github.com/trinodb/trino/pull/5792", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjQwOA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r516596408", "bodyText": "passing of sourceColumns is redundant. getRedirectedTableScan can extract these itself.", "author": "sopel39", "createdAt": "2020-11-03T11:24:55Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcMetadata.java", "diffHunk": "@@ -302,6 +304,29 @@ public JdbcTableHandle getTableHandle(ConnectorSession session, SchemaTableName\n         return Optional.of(new LimitApplicationResult<>(handle, jdbcClient.isLimitGuaranteed(session)));\n     }\n \n+    @Override\n+    public Optional<TableScanRedirectApplicationResult> applyTableScanRedirect(ConnectorSession session, ConnectorTableHandle table)\n+    {\n+        JdbcTableHandle tableHandle = (JdbcTableHandle) table;\n+\n+        List<JdbcColumnHandle> sourceColumns = tableHandle.getColumns()\n+                .map(columnSet -> (List<JdbcColumnHandle>) columnSet.stream().map(JdbcColumnHandle.class::cast).collect(toImmutableList()))\n+                .orElseGet(() -> jdbcClient.getColumns(session, tableHandle));\n+\n+        Optional<JdbcTableScanRedirectionResult> result = jdbcClient.getRedirectedTableScan(session, tableHandle, sourceColumns);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY1NDEzOQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r516654139", "bodyText": "True, though doing it here avoids repeating that code in jdbc connectors.", "author": "raunaqmorarka", "createdAt": "2020-11-03T13:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r516596806", "bodyText": "@martint this is where filter in redirection is being used", "author": "sopel39", "createdAt": "2020-11-03T11:25:41Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcMetadata.java", "diffHunk": "@@ -302,6 +304,29 @@ public JdbcTableHandle getTableHandle(ConnectorSession session, SchemaTableName\n         return Optional.of(new LimitApplicationResult<>(handle, jdbcClient.isLimitGuaranteed(session)));\n     }\n \n+    @Override\n+    public Optional<TableScanRedirectApplicationResult> applyTableScanRedirect(ConnectorSession session, ConnectorTableHandle table)\n+    {\n+        JdbcTableHandle tableHandle = (JdbcTableHandle) table;\n+\n+        List<JdbcColumnHandle> sourceColumns = tableHandle.getColumns()\n+                .map(columnSet -> (List<JdbcColumnHandle>) columnSet.stream().map(JdbcColumnHandle.class::cast).collect(toImmutableList()))\n+                .orElseGet(() -> jdbcClient.getColumns(session, tableHandle));\n+\n+        Optional<JdbcTableScanRedirectionResult> result = jdbcClient.getRedirectedTableScan(session, tableHandle, sourceColumns);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnsMapping = result.get().getDestinationColumns();\n+        return Optional.of(\n+                new TableScanRedirectApplicationResult(\n+                        result.get().getDestinationTable(),\n+                        columnsMapping,\n+                        tableHandle.getConstraint()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyNDY4NA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r517824684", "bodyText": "filter is removed from SPI now\nThe redirection rule now relies on TableScanNode#getEnforcedConstraint instead", "author": "raunaqmorarka", "createdAt": "2020-11-05T06:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyNzQ3MA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518927470", "bodyText": "The rewrite shouldn't include any filters. The retargeted table should encompass all the filters and operations represented by the TableHandle that got redirected. So, the idea is, for instance:\nGiven a plan such as:\nAggregation -> Project -> Filter -> Scan(TH0)\n\nthe \"pushdown into connector rules\" might transform it into:\nAggregation -> Scan (TH1)\n\nWhere TH1 represents a \"virtual table\" that's the result of scanning, filtering and projecting the rows.\nThen, the retargeting API would detect that it knows about a table in some other connector that has data that matches the results of TH1, and allows the engine to rewrite the query into:\nAggregation -> Scan(TH2)\n\nwhere TH2 is a table in a different connector.", "author": "martint", "createdAt": "2020-11-06T18:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMDcxMA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r519000710", "bodyText": "@martint target table might be wider than predicate pushed into source table. For example,\ntarget table might contain dates from 1990-2020, yet pushed down predicate might select dates >=2010. Therefore, we need to reapply enforced constraint and try to push it down into redirected table.", "author": "sopel39", "createdAt": "2020-11-06T20:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MzE2Mg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r522343162", "bodyText": "Fair enough. In that case, I have concerns about the current approach that relies on \"enforced predicate\".\nFrom a connector API perspective, the call says \"given this handle to a virtual table, provide me with something that replaces it\". The information included should contain everything that makes the replacement semantically equivalent. The \"enforced predicate\" is not part of this API -- it's just something that the planner \"remembered\" by storing it in the plan node associated with the table. Without that piece of information, the rewrite is incomplete and incorrect.", "author": "martint", "createdAt": "2020-11-12T18:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1ODE5Mw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r522358193", "bodyText": "@martint the initial API did include a getFilter in TableScanRedirectApplicationResult. We changed it later on to remove that and rely on enforced constraint from table scan node instead as it resulted in simpler code. Would you prefer that we just go back to returning filter through TableScanRedirectApplicationResult even if it's the same piece of information as the one in TableScanNode#getEnforcedConstraint ?", "author": "raunaqmorarka", "createdAt": "2020-11-12T19:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQyMTMyMQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r522421321", "bodyText": "As @raunaqmorarka mentioned this was the initial approach. However, the redirection rule should try to translate enforcedConstraint anyway, so returning the same constraint back from connector was redundant.\nMaybe we should document in SPI doc that redirected table does not have to enforce pushed down constraint (these will be enforced by engine)? One difference between redirection SPI and other pushdowns is that this new SPI does not return ConnectorTableHandle, so it's kind of unique.", "author": "sopel39", "createdAt": "2020-11-12T20:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExNjU2MA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r523116560", "bodyText": "The SPI should stand on its own. It can't depend on the caller keeping track of things on its own for correctness. enforcedConstraint exists for convenience and it may not exist in the future.", "author": "martint", "createdAt": "2020-11-13T17:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEyMDA1Mg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r523120052", "bodyText": "Ok. So I think we should bring back TupleDomain<String> filter as part of redirection result then", "author": "sopel39", "createdAt": "2020-11-13T17:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEyMTc4Mw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r523121783", "bodyText": "In fact, if in the future we want to add other elements such as projections and aggregations, they will need to be produced as part of the SPI response", "author": "martint", "createdAt": "2020-11-13T17:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3ODE5Ng==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r523978196", "bodyText": "I've updated the PR with the change to bring back TupleDomain<String> filter as part of redirection result and rebased to master.", "author": "raunaqmorarka", "createdAt": "2020-11-16T08:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU5NjgwNg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIyNTY4Nw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r517225687", "bodyText": "we shouldn't output filter back here, because in the future (if we support redirection after aggregtation pushdown) filters might be on unaggregated columns (before aggregation happens)", "author": "sopel39", "createdAt": "2020-11-04T09:59:42Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcMetadata.java", "diffHunk": "@@ -302,6 +304,29 @@ public JdbcTableHandle getTableHandle(ConnectorSession session, SchemaTableName\n         return Optional.of(new LimitApplicationResult<>(handle, jdbcClient.isLimitGuaranteed(session)));\n     }\n \n+    @Override\n+    public Optional<TableScanRedirectApplicationResult> applyTableScanRedirect(ConnectorSession session, ConnectorTableHandle table)\n+    {\n+        JdbcTableHandle tableHandle = (JdbcTableHandle) table;\n+\n+        List<JdbcColumnHandle> sourceColumns = tableHandle.getColumns()\n+                .map(columnSet -> (List<JdbcColumnHandle>) columnSet.stream().map(JdbcColumnHandle.class::cast).collect(toImmutableList()))\n+                .orElseGet(() -> jdbcClient.getColumns(session, tableHandle));\n+\n+        Optional<JdbcTableScanRedirectionResult> result = jdbcClient.getRedirectedTableScan(session, tableHandle, sourceColumns);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnsMapping = result.get().getDestinationColumns();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNzgwNg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518037806", "bodyText": "reverse the condition and add a comment:\nif (symbol != null) {\n  // symbol should be mapped in redirected table scan\n  return symbol;\n}", "author": "sopel39", "createdAt": "2020-11-05T13:09:58Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<ColumnHandle> enforcedConstraint = scanNode.getEnforcedConstraint();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            enforcedConstraint));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> assignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        TupleDomain<Symbol> transformedFilters = enforcedConstraint.transform(sourceColumnHandle -> {\n+            Symbol symbol = assignments.get(sourceColumnHandle);\n+            if (symbol == null) {", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0MjgyOQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518042829", "bodyText": "extract enforcedConstraint.getDomains().get().get(sourceColumnHandle).getType() as Type domainType", "author": "sopel39", "createdAt": "2020-11-05T13:18:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<ColumnHandle> enforcedConstraint = scanNode.getEnforcedConstraint();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            enforcedConstraint));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> assignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        TupleDomain<Symbol> transformedFilters = enforcedConstraint.transform(sourceColumnHandle -> {\n+            Symbol symbol = assignments.get(sourceColumnHandle);\n+            if (symbol == null) {\n+                // Column pruning after PPD into table scan can remove assignments for filter columns from the scan node\n+                String destinationColumn = requireNonNull(\n+                        columnMapping.get(sourceColumnHandle),\n+                        format(\"Did not find mapping for source column %s in table scan redirection\", sourceColumnHandle));", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0NDE2NA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518044164", "bodyText": "rename to transformedConstraint", "author": "sopel39", "createdAt": "2020-11-05T13:20:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<ColumnHandle> enforcedConstraint = scanNode.getEnforcedConstraint();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            enforcedConstraint));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> assignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        TupleDomain<Symbol> transformedFilters = enforcedConstraint.transform(sourceColumnHandle -> {", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1NDk5Mw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518054993", "bodyText": "extract into separate method", "author": "sopel39", "createdAt": "2020-11-05T13:36:35Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        ApplyTableScanRedirect tableScanRedirection =\n+                (session, handle) -> {", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1NjUzOQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518056539", "bodyText": "redundant test? what does projection change here?", "author": "sopel39", "createdAt": "2020-11-05T13:39:02Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        ApplyTableScanRedirect tableScanRedirection =\n+                (session, handle) -> {\n+                    MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n+                    Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n+                    if (projectedColumns.isEmpty()) {\n+                        return Optional.empty();\n+                    }\n+                    List<String> projectedColumnNames = projectedColumns.get().stream()\n+                            .map(MockConnectorColumnHandle.class::cast)\n+                            .map(MockConnectorColumnHandle::getName)\n+                            .collect(toImmutableList());\n+                    if (!projectedColumnNames.equals(ImmutableList.of(sourceColumnNameA))) {\n+                        return Optional.empty();\n+                    }\n+                    return Optional.of(\n+                            new TableScanRedirectApplicationResult(\n+                                    new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n+                                    redirectionMappingA));\n+                };\n+\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(tableScanRedirection, Optional.of(this::mockApplyProjection), Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+\n+            assertPlan(", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEwMzc3NA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518103774", "bodyText": "removed, it wasn't testing anything extra", "author": "raunaqmorarka", "createdAt": "2020-11-05T14:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1NjUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1OTczNw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518059737", "bodyText": "I think it should be:\nProject('dest_col_b') -> Filter('dest_col_a = 1') -> TableScan", "author": "sopel39", "createdAt": "2020-11-05T13:43:45Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        ApplyTableScanRedirect tableScanRedirection =\n+                (session, handle) -> {\n+                    MockConnectorTableHandle mockConnectorTable = (MockConnectorTableHandle) handle;\n+                    Optional<List<ColumnHandle>> projectedColumns = mockConnectorTable.getColumns();\n+                    if (projectedColumns.isEmpty()) {\n+                        return Optional.empty();\n+                    }\n+                    List<String> projectedColumnNames = projectedColumns.get().stream()\n+                            .map(MockConnectorColumnHandle.class::cast)\n+                            .map(MockConnectorColumnHandle::getName)\n+                            .collect(toImmutableList());\n+                    if (!projectedColumnNames.equals(ImmutableList.of(sourceColumnNameA))) {\n+                        return Optional.empty();\n+                    }\n+                    return Optional.of(\n+                            new TableScanRedirectApplicationResult(\n+                                    new CatalogSchemaTableName(MOCK_CATALOG, destinationTable),\n+                                    redirectionMappingA));\n+                };\n+\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(tableScanRedirection, Optional.of(this::mockApplyProjection), Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT (2 * source_col_a) + 1 FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"expr\"),\n+                            project(\n+                                    ImmutableMap.of(\"expr\", expression(\"(DEST_COL * 2) + 1\")),\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testPredicatePushdownAfterRedirect()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.empty(),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n+            // Only 'source_col_a = 1' will get pushed down into source table scan\n+            // Only 'source_col_b = 2' will get pushed down into destination table scan\n+            // This test verifies that the Filter('source_col_a = 1') produced by redirection\n+            // does not prevent pushdown of 'source_col_b = 2' into destination table scan\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table WHERE source_col_a = 1 AND source_col_b = 2\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_A\", \"DEST_COL_B\"),\n+                            filter(\n+                                    \"DEST_COL_A = 1\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleB), singleValue(INTEGER, 2L))),\n+                                            ImmutableMap.of(\n+                                                    \"DEST_COL_A\", equalTo(destinationColumnHandleA),\n+                                                    \"DEST_COL_B\", equalTo(destinationColumnHandleB))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(this::mockApplyFilter))) {\n+            // After 'source_col_a = 1' is pushed into source table scan, it's possible for 'source_col_a' table scan assignment to be pruned\n+            // Redirection results in Project('source_col_b') -> Filter('source_col_a = 1') -> TableScan for such case", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3MDE2NQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518070165", "bodyText": "extract this into utility method if possible", "author": "sopel39", "createdAt": "2020-11-05T13:58:37Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.RuleTester;\n+import io.prestosql.testing.TestingTransactionHandle;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static io.airlift.slice.Slices.utf8Slice;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.VarcharType.VARCHAR;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.expression;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.sql.planner.iterative.rule.test.RuleTester.defaultRuleTester;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestApplyTableScanRedirection\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+    private static final TableHandle TEST_TABLE_HANDLE = createTableHandle(new MockConnectorTableHandle(sourceTable));\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static TableHandle createTableHandle(ConnectorTableHandle tableHandle)\n+    {\n+        return new TableHandle(\n+                new CatalogName(MOCK_CATALOG),\n+                tableHandle,\n+                TestingTransactionHandle.create(),\n+                Optional.empty());\n+    }\n+\n+    @Test\n+    public void testDoesNotFire()\n+    {\n+        try (RuleTester ruleTester = defaultRuleTester()) {\n+            MockConnectorFactory mockFactory = createMockFactory(Optional.empty());\n+            ruleTester.getQueryRunner().createCatalog(MOCK_CATALOG, mockFactory, ImmutableMap.of());\n+\n+            ruleTester.assertThat(new ApplyTableScanRedirection(ruleTester.getMetadata()))\n+                    .on(p -> {\n+                        Symbol column = p.symbol(sourceColumnNameA, VARCHAR);\n+                        return p.tableScan(TEST_TABLE_HANDLE,\n+                                        ImmutableList.of(column),\n+                                        ImmutableMap.of(column, sourceColumnHandleA));\n+                    })\n+                    .withSession(MOCK_SESSION)\n+                    .doesNotFire();\n+        }\n+    }\n+\n+    @Test\n+    public void doesNotFireIfNoTableScan()\n+    {\n+        try (RuleTester ruleTester = defaultRuleTester()) {\n+            ApplyTableScanRedirect applyTableScanRedirect =\n+                    (session, handle) -> Optional.of(", "originalCommit": "f89a975f373ef9d4bac499ae771034783c42ecc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA3NTQxNg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r518075416", "bodyText": "let's remove:\n\nSet<JdbcColumnHandle> sourceColumns from this method.\npass JdbcTableHandle tableHandle instead.", "author": "sopel39", "createdAt": "2020-11-05T14:05:54Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcClient.java", "diffHunk": "@@ -139,4 +140,9 @@ PreparedStatement getPreparedStatement(Connection connection, String sql)\n     String quoted(RemoteTableName remoteTableName);\n \n     Map<String, Object> getTableProperties(JdbcIdentity identity, JdbcTableHandle tableHandle);\n+\n+    default Optional<TableScanRedirectApplicationResult> getTableScanRedirection(ConnectorSession session, SchemaTableName tableName, Set<JdbcColumnHandle> sourceColumns)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1MTA4NA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524051084", "bodyText": "just call it filter or destinationFilter. It's not enforced", "author": "sopel39", "createdAt": "2020-11-16T09:54:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<String> enforcedConstraint = tableScanRedirectApplicationResult.get().getFilter();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQxMTkzMg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524411932", "bodyText": "or requiredFilter", "author": "martint", "createdAt": "2020-11-16T16:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1MTA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE0MjEyMw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524142123", "bodyText": "translate source io.prestosql.sql.planner.plan.TableScanNode#enforcedConstraint from source node, as it should still be valid (on translated column handles) when tableScanRedirectApplicationResult.get().getFilter() is all", "author": "sopel39", "createdAt": "2020-11-16T11:17:10Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<String> enforcedConstraint = tableScanRedirectApplicationResult.get().getFilter();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            TupleDomain.all(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE1NjE0OQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524156149", "bodyText": "Filter('source_col_a = 1') -> Filter('dest_col_a = 1')", "author": "sopel39", "createdAt": "2020-11-16T11:29:53Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                this::mockApplyRedirectAfterProjectionPushdown,\n+                Optional.of(this::mockApplyProjection),\n+                Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+        }\n+    }\n+\n+    @Test\n+    public void testPredicatePushdownAfterRedirect()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.empty(),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n+            // Only 'source_col_a = 1' will get pushed down into source table scan\n+            // Only 'source_col_b = 2' will get pushed down into destination table scan\n+            // This test verifies that the Filter('source_col_a = 1') produced by redirection", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE2NjQ0OA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524166448", "bodyText": "remove? You can just use getMockApplyFilter(...) instead (it's almost identical)", "author": "sopel39", "createdAt": "2020-11-16T11:39:32Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                this::mockApplyRedirectAfterProjectionPushdown,\n+                Optional.of(this::mockApplyProjection),\n+                Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+        }\n+    }\n+\n+    @Test\n+    public void testPredicatePushdownAfterRedirect()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.empty(),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n+            // Only 'source_col_a = 1' will get pushed down into source table scan\n+            // Only 'source_col_b = 2' will get pushed down into destination table scan\n+            // This test verifies that the Filter('source_col_a = 1') produced by redirection\n+            // does not prevent pushdown of 'source_col_b = 2' into destination table scan\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table WHERE source_col_a = 1 AND source_col_b = 2\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_A\", \"DEST_COL_B\"),\n+                            filter(\n+                                    \"DEST_COL_A = 1\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleB), singleValue(INTEGER, 2L))),\n+                                            ImmutableMap.of(\n+                                                    \"DEST_COL_A\", equalTo(destinationColumnHandleA),\n+                                                    \"DEST_COL_B\", equalTo(destinationColumnHandleB))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(this::mockApplyFilter))) {\n+            // After 'source_col_a = 1' is pushed into source table scan, it's possible for 'source_col_a' table scan assignment to be pruned\n+            // Redirection results in Project('dest_col_b') -> Filter('dest_col_a = 1') -> TableScan for such case\n+            // Subsequent PPD and column pruning rules simplify the above as supported by the destination connector\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_b FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_B\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL_B\", equalTo(destinationColumnHandleB)))));\n+        }\n+    }\n+\n+    private LocalQueryRunner createLocalQueryRunner(\n+            ApplyTableScanRedirect applyTableScanRedirect,\n+            Optional<ApplyProjection> applyProjection,\n+            Optional<ApplyFilter> applyFilter)\n+    {\n+        LocalQueryRunner queryRunner = LocalQueryRunner.create(MOCK_SESSION);\n+        MockConnectorFactory.Builder builder = MockConnectorFactory.builder()\n+                .withGetTableHandle((session, schemaTableName) -> new MockConnectorTableHandle(schemaTableName))\n+                .withGetColumns(name -> {\n+                    if (name.equals(sourceTable)) {\n+                        return ImmutableList.of(\n+                                new ColumnMetadata(sourceColumnNameA, INTEGER),\n+                                new ColumnMetadata(sourceColumnNameB, INTEGER));\n+                    }\n+                    else if (name.equals(destinationTable)) {\n+                        return ImmutableList.of(\n+                                new ColumnMetadata(destinationColumnNameA, INTEGER),\n+                                new ColumnMetadata(destinationColumnNameB, INTEGER));\n+                    }\n+                    throw new IllegalArgumentException();\n+                })\n+                .withApplyTableScanRedirect(applyTableScanRedirect);\n+        applyProjection.ifPresent(builder::withApplyProjection);\n+        applyFilter.ifPresent(builder::withApplyFilter);\n+\n+        queryRunner.createCatalog(MOCK_CATALOG, builder.build(), ImmutableMap.of());\n+        return queryRunner;\n+    }\n+\n+    private Optional<ProjectionApplicationResult<ConnectorTableHandle>> mockApplyProjection(\n+            ConnectorSession session,\n+            ConnectorTableHandle tableHandle,\n+            List<ConnectorExpression> projections,\n+            Map<String, ColumnHandle> assignments)\n+    {\n+        MockConnectorTableHandle handle = (MockConnectorTableHandle) tableHandle;\n+\n+        List<ColumnHandle> newColumns = assignments.values().stream()\n+                .collect(toImmutableList());\n+        if (handle.getColumns().isPresent() && newColumns.equals(handle.getColumns().get())) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(\n+                new ProjectionApplicationResult<>(\n+                        new MockConnectorTableHandle(handle.getTableName(), handle.getConstraint(), Optional.of(newColumns)),\n+                        projections,\n+                        assignments.entrySet().stream()\n+                                .map(assignment -> new Assignment(\n+                                        assignment.getKey(),\n+                                        assignment.getValue(),\n+                                        ((MockConnectorColumnHandle) assignment.getValue()).getType()))\n+                                .collect(toImmutableList())));\n+    }\n+\n+    private Optional<ConstraintApplicationResult<ConnectorTableHandle>> mockApplyFilter(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE2NzQzNA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524167434", "bodyText": "remove, unused. You can use getMockApplyRedirectAfterPredicatePushdown instead", "author": "sopel39", "createdAt": "2020-11-16T11:40:23Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                this::mockApplyRedirectAfterProjectionPushdown,\n+                Optional.of(this::mockApplyProjection),\n+                Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect a filter\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingA),\n+                Optional.empty(),\n+                Optional.of(this::mockApplyFilter))) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA)))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COL\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COL\", sourceColumnNameA))));\n+        }\n+    }\n+\n+    @Test\n+    public void testPredicatePushdownAfterRedirect()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.empty(),\n+                Optional.of(getMockApplyFilter(ImmutableSet.of(sourceColumnHandleA, destinationColumnHandleB))))) {\n+            // Only 'source_col_a = 1' will get pushed down into source table scan\n+            // Only 'source_col_b = 2' will get pushed down into destination table scan\n+            // This test verifies that the Filter('source_col_a = 1') produced by redirection\n+            // does not prevent pushdown of 'source_col_b = 2' into destination table scan\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table WHERE source_col_a = 1 AND source_col_b = 2\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_A\", \"DEST_COL_B\"),\n+                            filter(\n+                                    \"DEST_COL_A = 1\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleB), singleValue(INTEGER, 2L))),\n+                                            ImmutableMap.of(\n+                                                    \"DEST_COL_A\", equalTo(destinationColumnHandleA),\n+                                                    \"DEST_COL_B\", equalTo(destinationColumnHandleB))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectAfterColumnPruningOnPushedDownPredicate()\n+    {\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                getMockApplyRedirectAfterPredicatePushdown(redirectionMappingAB),\n+                Optional.of(this::mockApplyProjection),\n+                Optional.of(this::mockApplyFilter))) {\n+            // After 'source_col_a = 1' is pushed into source table scan, it's possible for 'source_col_a' table scan assignment to be pruned\n+            // Redirection results in Project('dest_col_b') -> Filter('dest_col_a = 1') -> TableScan for such case\n+            // Subsequent PPD and column pruning rules simplify the above as supported by the destination connector\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_b FROM test_table WHERE source_col_a = 1\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL_B\"),\n+                            tableScan(\n+                                    equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                    TupleDomain.withColumnDomains(ImmutableMap.of(equalTo(destinationColumnHandleA), singleValue(INTEGER, 1L))),\n+                                    ImmutableMap.of(\"DEST_COL_B\", equalTo(destinationColumnHandleB)))));\n+        }\n+    }\n+\n+    private LocalQueryRunner createLocalQueryRunner(\n+            ApplyTableScanRedirect applyTableScanRedirect,\n+            Optional<ApplyProjection> applyProjection,\n+            Optional<ApplyFilter> applyFilter)\n+    {\n+        LocalQueryRunner queryRunner = LocalQueryRunner.create(MOCK_SESSION);\n+        MockConnectorFactory.Builder builder = MockConnectorFactory.builder()\n+                .withGetTableHandle((session, schemaTableName) -> new MockConnectorTableHandle(schemaTableName))\n+                .withGetColumns(name -> {\n+                    if (name.equals(sourceTable)) {\n+                        return ImmutableList.of(\n+                                new ColumnMetadata(sourceColumnNameA, INTEGER),\n+                                new ColumnMetadata(sourceColumnNameB, INTEGER));\n+                    }\n+                    else if (name.equals(destinationTable)) {\n+                        return ImmutableList.of(\n+                                new ColumnMetadata(destinationColumnNameA, INTEGER),\n+                                new ColumnMetadata(destinationColumnNameB, INTEGER));\n+                    }\n+                    throw new IllegalArgumentException();\n+                })\n+                .withApplyTableScanRedirect(applyTableScanRedirect);\n+        applyProjection.ifPresent(builder::withApplyProjection);\n+        applyFilter.ifPresent(builder::withApplyFilter);\n+\n+        queryRunner.createCatalog(MOCK_CATALOG, builder.build(), ImmutableMap.of());\n+        return queryRunner;\n+    }\n+\n+    private Optional<ProjectionApplicationResult<ConnectorTableHandle>> mockApplyProjection(\n+            ConnectorSession session,\n+            ConnectorTableHandle tableHandle,\n+            List<ConnectorExpression> projections,\n+            Map<String, ColumnHandle> assignments)\n+    {\n+        MockConnectorTableHandle handle = (MockConnectorTableHandle) tableHandle;\n+\n+        List<ColumnHandle> newColumns = assignments.values().stream()\n+                .collect(toImmutableList());\n+        if (handle.getColumns().isPresent() && newColumns.equals(handle.getColumns().get())) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(\n+                new ProjectionApplicationResult<>(\n+                        new MockConnectorTableHandle(handle.getTableName(), handle.getConstraint(), Optional.of(newColumns)),\n+                        projections,\n+                        assignments.entrySet().stream()\n+                                .map(assignment -> new Assignment(\n+                                        assignment.getKey(),\n+                                        assignment.getValue(),\n+                                        ((MockConnectorColumnHandle) assignment.getValue()).getType()))\n+                                .collect(toImmutableList())));\n+    }\n+\n+    private Optional<ConstraintApplicationResult<ConnectorTableHandle>> mockApplyFilter(\n+            ConnectorSession session,\n+            ConnectorTableHandle table,\n+            Constraint constraint)\n+    {\n+        MockConnectorTableHandle handle = (MockConnectorTableHandle) table;\n+\n+        TupleDomain<ColumnHandle> oldDomain = handle.getConstraint();\n+        TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain)) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(\n+                new ConstraintApplicationResult<>(\n+                        new MockConnectorTableHandle(handle.getTableName(), newDomain, Optional.empty()),\n+                        TupleDomain.all()));\n+    }\n+\n+    private Optional<TableScanRedirectApplicationResult> mockApplyRedirectAfterProjectionPushdown(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkzMDU5Mw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524930593", "bodyText": "mockApplyRedirectAfterProjectionPushdown applies redirection only if it sees projected columns.\ngetMockApplyRedirectAfterPredicatePushdown applies redirection only if it sees pushed down predicates.\nI would prefer to not mix the two implementations.", "author": "raunaqmorarka", "createdAt": "2020-11-17T07:22:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE2NzQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5NjEwMQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524996101", "bodyText": "OK. I didn't notice it.", "author": "sopel39", "createdAt": "2020-11-17T09:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE2NzQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE3MjQxNg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524172416", "bodyText": "could we add a case when filter is fully consumed and not rematerialized as part of redirection?", "author": "sopel39", "createdAt": "2020-11-16T11:44:55Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestTableScanRedirectionWithPushdown.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.execution.warnings.WarningCollector;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.connector.ConnectorTableHandle;\n+import io.prestosql.spi.connector.Constraint;\n+import io.prestosql.spi.connector.ConstraintApplicationResult;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.sql.planner.assertions.PlanAssert;\n+import io.prestosql.sql.planner.assertions.PlanMatchPattern;\n+import io.prestosql.sql.planner.optimizations.PlanOptimizer;\n+import io.prestosql.testing.LocalQueryRunner;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Predicates.equalTo;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyFilter;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyProjection;\n+import static io.prestosql.connector.MockConnectorFactory.ApplyTableScanRedirect;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.planner.LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.filter;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.output;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static io.prestosql.testing.TestingSession.testSessionBuilder;\n+\n+public class TestTableScanRedirectionWithPushdown\n+{\n+    private static final String MOCK_CATALOG = \"mock_catalog\";\n+    private static final String TEST_SCHEMA = \"test_schema\";\n+    private static final String TEST_TABLE = \"test_table\";\n+    private static final SchemaTableName sourceTable = new SchemaTableName(TEST_SCHEMA, TEST_TABLE);\n+\n+    private static final Session MOCK_SESSION = testSessionBuilder().setCatalog(MOCK_CATALOG).setSchema(TEST_SCHEMA).build();\n+\n+    private static final String sourceColumnNameA = \"source_col_a\";\n+    private static final ColumnHandle sourceColumnHandleA = new MockConnectorColumnHandle(sourceColumnNameA, INTEGER);\n+    private static final String sourceColumnNameB = \"source_col_b\";\n+    private static final ColumnHandle sourceColumnHandleB = new MockConnectorColumnHandle(sourceColumnNameB, INTEGER);\n+\n+    private static final SchemaTableName destinationTable = new SchemaTableName(\"target_schema\", \"target_table\");\n+    private static final String destinationColumnNameA = \"destination_col_a\";\n+    private static final ColumnHandle destinationColumnHandleA = new MockConnectorColumnHandle(destinationColumnNameA, INTEGER);\n+    private static final String destinationColumnNameB = \"destination_col_b\";\n+    private static final ColumnHandle destinationColumnHandleB = new MockConnectorColumnHandle(destinationColumnNameB, INTEGER);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingA = ImmutableMap.of(sourceColumnHandleA, destinationColumnNameA);\n+\n+    private static final Map<ColumnHandle, String> redirectionMappingAB = ImmutableMap.of(\n+            sourceColumnHandleA, destinationColumnNameA,\n+            sourceColumnHandleB, destinationColumnNameB);\n+\n+    @Test\n+    public void testRedirectionAfterProjectionPushdown()\n+    {\n+        // make the mock connector return a table scan on destination table only if\n+        // the connector can detect that source_col_a is projected\n+        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n+                this::mockApplyRedirectAfterProjectionPushdown,\n+                Optional.of(this::mockApplyProjection),\n+                Optional.empty())) {\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            tableScan(\"target_table\", ImmutableMap.of(\"DEST_COL\", destinationColumnNameA))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a, source_col_b FROM test_table\",\n+                    output(\n+                            ImmutableList.of(\"SOURCE_COLA\", \"SOURCE_COLB\"),\n+                            tableScan(TEST_TABLE, ImmutableMap.of(\"SOURCE_COLA\", sourceColumnNameA, \"SOURCE_COLB\", sourceColumnNameB))));\n+\n+            assertPlan(\n+                    queryRunner,\n+                    \"SELECT source_col_a FROM test_table WHERE source_col_a > 0\",\n+                    output(\n+                            ImmutableList.of(\"DEST_COL\"),\n+                            filter(\n+                                    \"DEST_COL > 0\",\n+                                    tableScan(\n+                                            equalTo(new MockConnectorTableHandle(destinationTable)),\n+                                            TupleDomain.all(),\n+                                            ImmutableMap.of(\"DEST_COL\", equalTo(destinationColumnHandleA))))));\n+        }\n+    }\n+\n+    @Test\n+    public void testRedirectionAfterPredicatePushdownIntoTableScan()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE3NTc5Ng==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524175796", "bodyText": "is orderkey > 0 pushed down? Can we make it actually filter anything (to test that TPCH correctly rematerialized predicate)?", "author": "sopel39", "createdAt": "2020-11-16T11:47:50Z", "path": "presto-tests/src/test/java/io/prestosql/tests/TestTpchTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.tests;\n+\n+import io.prestosql.Session;\n+import io.prestosql.plugin.memory.MemoryPlugin;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.tests.tpch.TpchQueryRunnerBuilder;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SystemSessionProperties.TABLE_SCAN_REDIRECTION_ENABLED;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestTpchTableScanRedirection\n+        extends AbstractTestQueryFramework\n+{\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        DistributedQueryRunner queryRunner = TpchQueryRunnerBuilder.builder()\n+                .withTableScanRedirectionCatalog(\"memory\")\n+                .withTableScanRedirectionSchema(\"test\")\n+                .build();\n+        queryRunner.installPlugin(new MemoryPlugin());\n+        queryRunner.createCatalog(\"memory\", \"memory\");\n+        return queryRunner;\n+    }\n+\n+    @Test(timeOut = 20_000)\n+    public void testTableScanRedirection()\n+    {\n+        assertQuerySucceeds(\"CREATE SCHEMA memory.test\");\n+        assertUpdate(\n+                Session.builder(getSession())\n+                        .setSystemProperty(TABLE_SCAN_REDIRECTION_ENABLED, \"false\")\n+                        .build(),\n+                \"CREATE TABLE memory.test.orders AS SELECT * FROM tpch.tiny.orders LIMIT 100\", 100L);\n+        assertEquals(computeActual(\"SELECT * FROM tpch.tiny.orders WHERE orderkey > 0\").getRowCount(), 100L);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwNzkyNA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524407924", "bodyText": "I don't think we need a global toggle for this. If a connector doesn't support this, it will be a no-op. If we need to disable it for a connector, then there should be a toggle (session property/config option) for that connector.", "author": "martint", "createdAt": "2020-11-16T16:40:04Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -976,4 +977,16 @@ public FeaturesConfig setRewriteFilteringSemiJoinToInnerJoin(boolean rewriteFilt\n         this.rewriteFilteringSemiJoinToInnerJoin = rewriteFilteringSemiJoinToInnerJoin;\n         return this;\n     }\n+\n+    public boolean isRedirectTableScansEnabled()\n+    {\n+        return redirectTableScansEnabled;\n+    }\n+\n+    @Config(\"optimizer.redirect-table-scans\")\n+    public FeaturesConfig setRedirectTableScansEnabled(boolean redirectTableScansEnabled)\n+    {\n+        this.redirectTableScansEnabled = redirectTableScansEnabled;\n+        return this;\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI3NjI4MA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525276280", "bodyText": "removed", "author": "raunaqmorarka", "createdAt": "2020-11-17T15:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQwNzkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MzE4OA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524773188", "bodyText": "This should throw some kind of Presto exception. Otherwise, it will produce an INTERNAL_ERROR, when it's an issue with a missing or stale mapping within the connector.", "author": "martint", "createdAt": "2020-11-16T23:53:25Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isTableScanRedirectionEnabled;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isTableScanRedirectionEnabled(session);\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(GENERIC_INTERNAL_ERROR, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = requireNonNull(\n+                            columnMapping.get(entry.getValue()),\n+                            format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    return requireNonNull(\n+                            destinationColumnHandles.get(destinationColumn),\n+                            format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                }));\n+\n+        TupleDomain<String> enforcedConstraint = tableScanRedirectApplicationResult.get().getFilter();\n+        if (enforcedConstraint.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            TupleDomain.all(),\n+                            scanNode.isForDelete()));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> inverseAssignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        Map<String, ColumnHandle> inverseColumnsMapping = ImmutableBiMap.copyOf(columnMapping).inverse();\n+        TupleDomain<Symbol> transformedConstraint = enforcedConstraint.transform(destinationColumn -> {\n+            ColumnHandle sourceColumnHandle = requireNonNull(\n+                    inverseColumnsMapping.get(destinationColumn),\n+                    format(\"Did not find mapping for destination column %s in table scan redirection\", destinationColumn));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk3MjAzMw==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r524972033", "bodyText": "Updated the rule to throw COLUMN_NOT_FOUND or TABLE_NOT_FOUND PrestoException", "author": "raunaqmorarka", "createdAt": "2020-11-17T08:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MzE4OA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "7637be1d92ee009198f89680ef2b913b325bc9c1", "url": "https://github.com/trinodb/trino/commit/7637be1d92ee009198f89680ef2b913b325bc9c1", "message": "Add applyTableScanRedirect SPI and ApplyTableScanRedirection rule\n\nAllows connectors to offload table scans to any other connector during\nthe plan optimization phase. The connector may choose to delegate\nbased on criteria like selected columns and applied predicates.", "committedDate": "2020-11-17T15:54:29Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg0ODk1MA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525848950", "bodyText": "why difference between 7696L and 7333L?", "author": "sopel39", "createdAt": "2020-11-18T06:47:49Z", "path": "presto-tests/src/test/java/io/prestosql/tests/TestTpchTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.tests;\n+\n+import io.prestosql.plugin.memory.MemoryPlugin;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.tests.tpch.TpchQueryRunnerBuilder;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestTpchTableScanRedirection\n+        extends AbstractTestQueryFramework\n+{\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        DistributedQueryRunner queryRunner = TpchQueryRunnerBuilder.builder()\n+                .withTableScanRedirectionCatalog(\"memory\")\n+                .withTableScanRedirectionSchema(\"test\")\n+                .build();\n+        queryRunner.installPlugin(new MemoryPlugin());\n+        queryRunner.createCatalog(\"memory\", \"memory\");\n+        // Add another tpch catalog without redirection to aid in loading data into memory connector\n+        queryRunner.createCatalog(\"tpch_data_load\", \"tpch\");\n+        return queryRunner;\n+    }\n+\n+    @Test(timeOut = 20_000)\n+    public void testTableScanRedirection()\n+    {\n+        assertQuerySucceeds(\"CREATE SCHEMA memory.test\");\n+        assertUpdate(\"CREATE TABLE memory.test.orders AS SELECT * FROM tpch_data_load.tiny.orders WHERE orderstatus IN ('O', 'P')\", 7696L);\n+        assertEquals(computeActual(\"SELECT * FROM tpch.tiny.orders WHERE orderstatus IN ('O', 'F')\").getRowCount(), 7333L);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2MDAyNQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525860025", "bodyText": "orderstatus in orders has possible values O, P and F\nI loaded only the rows corresponding to O and P in redirected table to create different result from querying original table\nThen in the test query I selected only the rows corresponding to O and F in redirected table to test out re-materialisation of filter after redirection to memory onnector while also having different result than if we had queried the original table.", "author": "raunaqmorarka", "createdAt": "2020-11-18T07:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg0ODk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1Nzk1Mg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525957952", "bodyText": "test out re-materialisation of filter after redirection to memory onnector while also having different result than if we had queried the original table.\n\nHow do you know it rematerialized (I suppose we only select data for O)? Please add a comment.", "author": "sopel39", "createdAt": "2020-11-18T10:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg0ODk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4NDMyOA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525984328", "bodyText": "added comments", "author": "raunaqmorarka", "createdAt": "2020-11-18T10:40:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg0ODk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1MzAwMg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r525953002", "bodyText": "technically, there doesn't have to be an inverse mapping for destinationColumn here, e.g this could be predicate on some other, new column", "author": "sopel39", "createdAt": "2020-11-18T09:53:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ApplyTableScanRedirection.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.TableScanRedirectApplicationResult;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.DomainTranslator;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static io.prestosql.spi.StandardErrorCode.COLUMN_NOT_FOUND;\n+import static io.prestosql.spi.StandardErrorCode.TABLE_NOT_FOUND;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ApplyTableScanRedirection\n+        implements Rule<TableScanNode>\n+{\n+    private static final Pattern<TableScanNode> PATTERN = tableScan();\n+\n+    private final Metadata metadata;\n+    private final DomainTranslator domainTranslator;\n+\n+    public ApplyTableScanRedirection(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+        this.domainTranslator = new DomainTranslator(metadata);\n+    }\n+\n+    @Override\n+    public Pattern<TableScanNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(TableScanNode scanNode, Captures captures, Context context)\n+    {\n+        Optional<TableScanRedirectApplicationResult> tableScanRedirectApplicationResult = metadata.applyTableScanRedirect(context.getSession(), scanNode.getTable());\n+        if (tableScanRedirectApplicationResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        CatalogSchemaTableName destinationTable = tableScanRedirectApplicationResult.get().getDestinationTable();\n+        Optional<TableHandle> destinationTableHandle = metadata.getTableHandle(\n+                context.getSession(),\n+                convertFromSchemaTableName(destinationTable.getCatalogName()).apply(destinationTable.getSchemaTableName()));\n+        if (destinationTableHandle.isEmpty()) {\n+            throw new PrestoException(TABLE_NOT_FOUND, format(\"Destination table %s from table scan redirection not found\", destinationTable));\n+        }\n+        if (destinationTableHandle.get().equals(scanNode.getTable())) {\n+            return Result.empty();\n+        }\n+\n+        Map<ColumnHandle, String> columnMapping = tableScanRedirectApplicationResult.get().getDestinationColumns();\n+        Map<String, ColumnHandle> destinationColumnHandles = metadata.getColumnHandles(context.getSession(), destinationTableHandle.get());\n+        Map<Symbol, ColumnHandle> newAssignments = scanNode.getAssignments().entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, entry -> {\n+                    String destinationColumn = columnMapping.get(entry.getValue());\n+                    if (destinationColumn == null) {\n+                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find mapping for source column %s in table scan redirection\", entry.getValue()));\n+                    }\n+                    ColumnHandle destinationColumnHandle = destinationColumnHandles.get(destinationColumn);\n+                    if (destinationColumnHandle == null) {\n+                        throw new PrestoException(COLUMN_NOT_FOUND, format(\"Did not find handle for column %s in destination table %s\", destinationColumn, destinationTable));\n+                    }\n+                    return destinationColumnHandle;\n+                }));\n+\n+        TupleDomain<String> requiredFilter = tableScanRedirectApplicationResult.get().getFilter();\n+        if (requiredFilter.isAll()) {\n+            return Result.ofPlanNode(\n+                    new TableScanNode(\n+                            scanNode.getId(),\n+                            destinationTableHandle.get(),\n+                            scanNode.getOutputSymbols(),\n+                            newAssignments,\n+                            TupleDomain.all(),\n+                            scanNode.isForDelete()));\n+        }\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newAssignmentsBuilder = ImmutableMap.<Symbol, ColumnHandle>builder()\n+                .putAll(newAssignments);\n+        ImmutableList.Builder<Symbol> newOutputSymbolsBuilder = ImmutableList.<Symbol>builder()\n+                .addAll(scanNode.getOutputSymbols());\n+        Map<ColumnHandle, Symbol> inverseAssignments = ImmutableBiMap.copyOf(scanNode.getAssignments()).inverse();\n+        Map<String, ColumnHandle> inverseColumnsMapping = ImmutableBiMap.copyOf(columnMapping).inverse();\n+        TupleDomain<Symbol> transformedConstraint = requiredFilter.transform(destinationColumn -> {\n+            ColumnHandle sourceColumnHandle = inverseColumnsMapping.get(destinationColumn);\n+            if (sourceColumnHandle == null) {", "originalCommit": "7637be1d92ee009198f89680ef2b913b325bc9c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0aca274b196608b223193e8636b4a0692acc2063", "url": "https://github.com/trinodb/trino/commit/0aca274b196608b223193e8636b4a0692acc2063", "message": "Implement table scan redirection in TPCH connector", "committedDate": "2020-11-18T10:40:10Z", "type": "commit"}, {"oid": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "url": "https://github.com/trinodb/trino/commit/3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "message": "Implement applyTableScanRedirect API in JdbcMetadata", "committedDate": "2020-11-18T10:40:15Z", "type": "commit"}, {"oid": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "url": "https://github.com/trinodb/trino/commit/3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "message": "Implement applyTableScanRedirect API in JdbcMetadata", "committedDate": "2020-11-18T10:40:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r635491914", "bodyText": "it's not guaranteed, since ApplyTableScanRedirection and PushPredicateIntoTableScan are part of one IterativeOptimizer. Did you intend to have them as two separate optimizers? if not, i don't know how to interpret this comment", "author": "findepi", "createdAt": "2021-05-19T18:35:18Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -537,6 +538,21 @@ public PlanOptimizers(\n                         estimatedExchangesCostCalculator,\n                         ImmutableSet.of(new TransformFilteringSemiJoinToInnerJoin()))); // must run after PredicatePushDown\n \n+        // Perform redirection before CBO rules to ensure stats from destination connector are used\n+        // Perform redirection before agg, topN, limit, sample etc. push down into table scan as the destination connector may support a different set of push downs\n+        // Perform redirection after at least one PredicatePushDown and PushPredicateIntoTableScan to allow connector to use pushed down predicates in redirection decision\n+        // Perform redirection after at least table scan pruning rules because redirected table might have fewer columns\n+        // PushPredicateIntoTableScan must be run after redirection", "originalCommit": "3c76c2029805c734bfbf0e5c83c46d921c7c8df7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTk5NDMwMg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r635994302", "bodyText": "As part of table scan redirection, we take predicates which were pushed down into source table scan and create a filter node on top of the target table scan node. Now we need to re-run PushPredicateIntoTableScan to allow this new filter node to be pushed down into the target table scan. This was done because target connector's predicate pushdown capability might be different to source connector's.\nWe are running pushIntoTableScanOptimizer next, so I thought that will ensure PPD into TS and satisfy the above requirement.", "author": "raunaqmorarka", "createdAt": "2021-05-20T10:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjE1NDI5Mg==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r636154292", "bodyText": "i read \"must be run after redirection\" as \"must not be run before\", while you're saying \"it needs to be run again afterwards\"\ncan you please consider rewording?", "author": "findepi", "createdAt": "2021-05-20T14:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjE2NzE3OA==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r636167178", "bodyText": "oh, i see now, ya PushPredicateIntoTableScan needs to be run again after redirection is more accurate, I'll update it", "author": "raunaqmorarka", "createdAt": "2021-05-20T14:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjI1NjYxMQ==", "url": "https://github.com/trinodb/trino/pull/5792#discussion_r636256611", "bodyText": "created #8002\nPTAL", "author": "raunaqmorarka", "createdAt": "2021-05-20T16:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNTQ5MTkxNA=="}], "type": "inlineReview"}]}