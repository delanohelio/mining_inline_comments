{"pr_number": 3767, "pr_title": "Add support for CREATE and DROP TABLE in BigQuery", "pr_createdAt": "2020-05-17T09:27:22Z", "pr_url": "https://github.com/trinodb/trino/pull/3767", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg1NTY0OA==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r566855648", "bodyText": "The tableIds map in BigQueryClient doesn't actually store anything useful since both the keys and values are same.\nEach get on the map is also accompanied by an API call too so we should perform the API call directly.\nI've removed this map in #6748 in favour of a cache which maintains a mapping of lowercase name to remote name.", "author": "hashhar", "createdAt": "2021-01-29T14:24:02Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryClient.java", "diffHunk": "@@ -126,6 +126,18 @@ Table update(TableInfo table)\n         return bigQuery.update(table);\n     }\n \n+    public void createTable(TableInfo tableInfo)\n+    {\n+        bigQuery.create(tableInfo);\n+        tableIds.put(tableInfo.getTableId(), tableInfo.getTableId());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIzNjc1OQ==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r567236759", "bodyText": "If #6748 is merged first, I would remove this. But, I think we should keep this line for now.", "author": "ebyhr", "createdAt": "2021-01-30T11:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg1NTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjE4MDMzMw==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r576180333", "bodyText": "Removed relevant code.", "author": "ebyhr", "createdAt": "2021-02-15T13:08:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg1NTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg1NzM4Mw==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r566857383", "bodyText": "nit: static import Field.Mode.REPEATED.", "author": "hashhar", "createdAt": "2021-01-29T14:26:32Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryType.java", "diffHunk": "@@ -182,6 +191,70 @@ static String bytesToStringConverter(Object value)\n         return format(\"FROM_BASE64('%s')\", Base64.getEncoder().encodeToString(slice.getBytes()));\n     }\n \n+    public static Field toField(String name, Type type)\n+    {\n+        if (type instanceof ArrayType) {\n+            Type elementType = ((ArrayType) type).getElementType();\n+            if (elementType instanceof RowType) {\n+                return Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) elementType)).setMode(Field.Mode.REPEATED).build();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg1ODE2Mg==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r566858162", "bodyText": "Do we do this in any other connector? Naming anonymous fields in ROW types?", "author": "hashhar", "createdAt": "2021-01-29T14:27:43Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryType.java", "diffHunk": "@@ -182,6 +191,70 @@ static String bytesToStringConverter(Object value)\n         return format(\"FROM_BASE64('%s')\", Base64.getEncoder().encodeToString(slice.getBytes()));\n     }\n \n+    public static Field toField(String name, Type type)\n+    {\n+        if (type instanceof ArrayType) {\n+            Type elementType = ((ArrayType) type).getElementType();\n+            if (elementType instanceof RowType) {\n+                return Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) elementType)).setMode(Field.Mode.REPEATED).build();\n+            }\n+            return Field.newBuilder(name, toStandardSqlTypeName(elementType)).setMode(Field.Mode.REPEATED).build();\n+        }\n+        if (type instanceof RowType) {\n+            return Field.of(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) type));\n+        }\n+        return Field.of(name, toStandardSqlTypeName(type));\n+    }\n+\n+    private static FieldList toFieldList(RowType rowType)\n+    {\n+        List<Field> fields = rowType.getFields().stream()\n+                .map(field -> toField(field.getName().orElse(\"field\" + rowType.getFields().indexOf(field)), field.getType()))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg3MTQ4NQ==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r566871485", "bodyText": "I think it depends on the connector. At least, this Field object in BigQuery doesn't allow empty name.", "author": "ebyhr", "createdAt": "2021-01-29T14:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg1ODE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzcxNzI1Ng==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r567717256", "bodyText": "Maybe we should just fail create if name is not provided for all fields. It does not feel to me that auto-generating names for CREATED tables is useful thing.", "author": "losipiuk", "createdAt": "2021-02-01T10:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg1ODE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg1ODgxNg==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r566858816", "bodyText": "nit: static import and replace with toImmutableList since we aren't modifying it after return.", "author": "hashhar", "createdAt": "2021-01-29T14:28:36Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryType.java", "diffHunk": "@@ -182,6 +191,70 @@ static String bytesToStringConverter(Object value)\n         return format(\"FROM_BASE64('%s')\", Base64.getEncoder().encodeToString(slice.getBytes()));\n     }\n \n+    public static Field toField(String name, Type type)\n+    {\n+        if (type instanceof ArrayType) {\n+            Type elementType = ((ArrayType) type).getElementType();\n+            if (elementType instanceof RowType) {\n+                return Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) elementType)).setMode(Field.Mode.REPEATED).build();\n+            }\n+            return Field.newBuilder(name, toStandardSqlTypeName(elementType)).setMode(Field.Mode.REPEATED).build();\n+        }\n+        if (type instanceof RowType) {\n+            return Field.of(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) type));\n+        }\n+        return Field.of(name, toStandardSqlTypeName(type));\n+    }\n+\n+    private static FieldList toFieldList(RowType rowType)\n+    {\n+        List<Field> fields = rowType.getFields().stream()\n+                .map(field -> toField(field.getName().orElse(\"field\" + rowType.getFields().indexOf(field)), field.getType()))\n+                .collect(Collectors.toUnmodifiableList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg2MDExOQ==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r566860119", "bodyText": "We will need to keep this in sync with the type mappings otherwise CTAS statement's schema might differ from the table that gets created.\nWould it be helpful to define a bi-directional map somewhere with this mapping and use it for both read type mappings and write mappings?", "author": "hashhar", "createdAt": "2021-01-29T14:30:27Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryType.java", "diffHunk": "@@ -182,6 +191,70 @@ static String bytesToStringConverter(Object value)\n         return format(\"FROM_BASE64('%s')\", Base64.getEncoder().encodeToString(slice.getBytes()));\n     }\n \n+    public static Field toField(String name, Type type)\n+    {\n+        if (type instanceof ArrayType) {\n+            Type elementType = ((ArrayType) type).getElementType();\n+            if (elementType instanceof RowType) {\n+                return Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) elementType)).setMode(Field.Mode.REPEATED).build();\n+            }\n+            return Field.newBuilder(name, toStandardSqlTypeName(elementType)).setMode(Field.Mode.REPEATED).build();\n+        }\n+        if (type instanceof RowType) {\n+            return Field.of(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) type));\n+        }\n+        return Field.of(name, toStandardSqlTypeName(type));\n+    }\n+\n+    private static FieldList toFieldList(RowType rowType)\n+    {\n+        List<Field> fields = rowType.getFields().stream()\n+                .map(field -> toField(field.getName().orElse(\"field\" + rowType.getFields().indexOf(field)), field.getType()))\n+                .collect(Collectors.toUnmodifiableList());\n+        return FieldList.of(fields);\n+    }\n+\n+    private static StandardSQLTypeName toStandardSqlTypeName(Type type)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg3NDI4MQ==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r566874281", "bodyText": "When we support CTAS, we will add BigQueryOutputTableHandle and the schema should be defined in same BigQueryMetadata.createTable(). So, such mismatch won't happen.", "author": "ebyhr", "createdAt": "2021-01-29T14:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg2MDExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg2MTQ3NQ==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r566861475", "bodyText": "Since CREATE TABLE is now supported we can add roundtrip tests for the data types to ensure our read and write mappings are in sync.", "author": "hashhar", "createdAt": "2021-01-29T14:32:31Z", "path": "plugin/trino-bigquery/src/test/java/io/trino/plugin/bigquery/TestBigQueryIntegrationSmokeTest.java", "diffHunk": "@@ -61,6 +63,78 @@ public void testDescribeTable()\n         assertEquals(actualColumns, expectedColumns);\n     }\n \n+    @Test\n+    public void createTableWithEveryType()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIzNzU2Mw==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r567237563", "bodyText": "We are using SqlExecutor for roundtrip tests, so it depends on #6748.", "author": "ebyhr", "createdAt": "2021-01-30T12:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njg2MTQ3NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzcxMDQ2OA==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r567710468", "bodyText": "I assume that createTable would throw if table already exists. Can you determine if reason for an exception is that table was already in bigquery. And then ignore the exception if boolean ignoreExisting is true?", "author": "losipiuk", "createdAt": "2021-02-01T10:22:35Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryMetadata.java", "diffHunk": "@@ -238,6 +240,20 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n         return new ConnectorTableProperties();\n     }\n \n+    @Override\n+    public void createTable(ConnectorSession session, ConnectorTableMetadata tableMetadata, boolean ignoreExisting)\n+    {\n+        createTable(tableMetadata);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg2ODM4Mg==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r567868382", "bodyText": "We can determine by BigQueryException (code: 409, status: ALREADY_EXISTS). Let me change.", "author": "ebyhr", "createdAt": "2021-02-01T14:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzcxMDQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzcxNTc2MA==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r567715760", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Field toField(String name, Type type)\n          \n          \n            \n                {\n          \n          \n            \n                    if (type instanceof ArrayType) {\n          \n          \n            \n                        Type elementType = ((ArrayType) type).getElementType();\n          \n          \n            \n                        if (elementType instanceof RowType) {\n          \n          \n            \n                            return Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) elementType)).setMode(REPEATED).build();\n          \n          \n            \n                        }\n          \n          \n            \n                        return Field.newBuilder(name, toStandardSqlTypeName(elementType)).setMode(REPEATED).build();\n          \n          \n            \n                    }\n          \n          \n            \n                    if (type instanceof RowType) {\n          \n          \n            \n                        return Field.of(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) type));\n          \n          \n            \n                    }\n          \n          \n            \n                    return Field.of(name, toStandardSqlTypeName(type));\n          \n          \n            \n                }\n          \n          \n            \n                public static Field toField(String name, Type type)\n          \n          \n            \n                {\n          \n          \n            \n                    if (type instanceof ArrayType) {\n          \n          \n            \n                        Type elementType = ((ArrayType) type).getElementType();\n          \n          \n            \n                        return toInnerFieldBuilder(name, elementType).setMode(REPEATED).build();\n          \n          \n            \n                    }\n          \n          \n            \n                    return toInnerFieldBuilder(name, type).build();\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private static Field.Builder toInnerFieldBuilder(String name, Type type)\n          \n          \n            \n                {\n          \n          \n            \n                    if (type instanceof RowType) {\n          \n          \n            \n                        return Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) type));\n          \n          \n            \n                    }\n          \n          \n            \n                    return Field.newBuilder(name, toStandardSqlTypeName(type));\n          \n          \n            \n                }", "author": "losipiuk", "createdAt": "2021-02-01T10:30:28Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryType.java", "diffHunk": "@@ -182,6 +192,70 @@ static String bytesToStringConverter(Object value)\n         return format(\"FROM_BASE64('%s')\", Base64.getEncoder().encodeToString(slice.getBytes()));\n     }\n \n+    public static Field toField(String name, Type type)\n+    {\n+        if (type instanceof ArrayType) {\n+            Type elementType = ((ArrayType) type).getElementType();\n+            if (elementType instanceof RowType) {\n+                return Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) elementType)).setMode(REPEATED).build();\n+            }\n+            return Field.newBuilder(name, toStandardSqlTypeName(elementType)).setMode(REPEATED).build();\n+        }\n+        if (type instanceof RowType) {\n+            return Field.of(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) type));\n+        }\n+        return Field.of(name, toStandardSqlTypeName(type));\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzcyMTEyNQ==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r567721125", "bodyText": "nit: would it take much more test-execution time to provide type and expected type via test parameters and use @DataProvider to pass those. Then each test execution would create table with just one column. Having separate tests for each type can make investigating failures later on easier.", "author": "losipiuk", "createdAt": "2021-02-01T10:38:41Z", "path": "plugin/trino-bigquery/src/test/java/io/trino/plugin/bigquery/TestBigQueryIntegrationSmokeTest.java", "diffHunk": "@@ -61,6 +63,78 @@ public void testDescribeTable()\n         assertEquals(actualColumns, expectedColumns);\n     }\n \n+    @Test\n+    public void createTableWithEveryType()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjE4MTEzMg==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r576181132", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    TableId tableId = TableId.of(projectId, bigQueryTable.getRemoteTableName().getDatasetName(), bigQueryTable.getRemoteTableName().getTableName());\n          \n          \n            \n                    TableId tableId = bigQueryTable.getRemoteTableName().toTableId();", "author": "hashhar", "createdAt": "2021-02-15T13:09:58Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryMetadata.java", "diffHunk": "@@ -286,6 +292,28 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n         return new ConnectorTableProperties();\n     }\n \n+    @Override\n+    public void createTable(ConnectorSession session, ConnectorTableMetadata tableMetadata, boolean ignoreExisting)\n+    {\n+        try {\n+            createTable(tableMetadata);\n+        }\n+        catch (BigQueryException e) {\n+            if (ignoreExisting && e.getCode() == 409) {\n+                return;\n+            }\n+            throw e;\n+        }\n+    }\n+\n+    @Override\n+    public void dropTable(ConnectorSession session, ConnectorTableHandle tableHandle)\n+    {\n+        BigQueryTableHandle bigQueryTable = (BigQueryTableHandle) tableHandle;\n+        TableId tableId = TableId.of(projectId, bigQueryTable.getRemoteTableName().getDatasetName(), bigQueryTable.getRemoteTableName().getTableName());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTI5NDYzNw==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r581294637", "bodyText": "nit: put this one just below public craeteTable", "author": "losipiuk", "createdAt": "2021-02-23T18:39:53Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryMetadata.java", "diffHunk": "@@ -396,4 +424,20 @@ public RecordCursor cursor(ConnectorTransactionHandle transactionHandle, Connect\n             }\n         };\n     }\n+\n+    private void createTable(ConnectorTableMetadata tableMetadata)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMwNjMyNg==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r581306326", "bodyText": "nit: IMO using Field as return type, passing repeated flag via parameter and using Builder only internally makes code a bit easier to read.\nWDYT:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Field toField(String name, Type type)\n          \n          \n            \n                {\n          \n          \n            \n                    if (type instanceof ArrayType) {\n          \n          \n            \n                        Type elementType = ((ArrayType) type).getElementType();\n          \n          \n            \n                        return toInnerFieldBuilder(name, elementType).setMode(REPEATED).build();\n          \n          \n            \n                    }\n          \n          \n            \n                    return toInnerFieldBuilder(name, type).build();\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private static Field.Builder toInnerFieldBuilder(String name, Type type)\n          \n          \n            \n                {\n          \n          \n            \n                    if (type instanceof RowType) {\n          \n          \n            \n                        return Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) type));\n          \n          \n            \n                    }\n          \n          \n            \n                    return Field.newBuilder(name, toStandardSqlTypeName(type));\n          \n          \n            \n                }\n          \n          \n            \n                public static Field toField(String name, Type type)\n          \n          \n            \n                {\n          \n          \n            \n                    if (type instanceof ArrayType) {\n          \n          \n            \n                        Type elementType = ((ArrayType) type).getElementType();\n          \n          \n            \n                        return toInnerField(name, elementType, true);\n          \n          \n            \n                    }\n          \n          \n            \n                    return toInnerField(name, type, false);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                private static Field toInnerField(String name, Type type, boolean repeated)\n          \n          \n            \n                {\n          \n          \n            \n                    Field.Builder builder;\n          \n          \n            \n                    if (type instanceof RowType) {\n          \n          \n            \n                        builder = Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) type));\n          \n          \n            \n                    }\n          \n          \n            \n                    else {\n          \n          \n            \n                        builder = Field.newBuilder(name, toStandardSqlTypeName(type));\n          \n          \n            \n                    }\n          \n          \n            \n                    if (repeated) {\n          \n          \n            \n                        builder = builder.setMode(REPEATED);\n          \n          \n            \n                    }\n          \n          \n            \n                    return builder.build();\n          \n          \n            \n                }", "author": "losipiuk", "createdAt": "2021-02-23T18:57:45Z", "path": "plugin/trino-bigquery/src/main/java/io/trino/plugin/bigquery/BigQueryType.java", "diffHunk": "@@ -182,6 +194,75 @@ static String bytesToStringConverter(Object value)\n         return format(\"FROM_BASE64('%s')\", Base64.getEncoder().encodeToString(slice.getBytes()));\n     }\n \n+    public static Field toField(String name, Type type)\n+    {\n+        if (type instanceof ArrayType) {\n+            Type elementType = ((ArrayType) type).getElementType();\n+            return toInnerFieldBuilder(name, elementType).setMode(REPEATED).build();\n+        }\n+        return toInnerFieldBuilder(name, type).build();\n+    }\n+\n+    private static Field.Builder toInnerFieldBuilder(String name, Type type)\n+    {\n+        if (type instanceof RowType) {\n+            return Field.newBuilder(name, StandardSQLTypeName.STRUCT, toFieldList((RowType) type));\n+        }\n+        return Field.newBuilder(name, toStandardSqlTypeName(type));\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMwODc1Mw==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r581308753", "bodyText": "let's not use random suffix here. In other tests we are not using that and we have perparatory  assertUpdate(\"DROP TABLE IF EXISTS \" + tableName); because of that.\nIf we use randomsuffixes we can pollute test environment and as far as I know we do not have any cleaner in place right now.", "author": "losipiuk", "createdAt": "2021-02-23T19:01:23Z", "path": "plugin/trino-bigquery/src/test/java/io/trino/plugin/bigquery/TestBigQueryIntegrationSmokeTest.java", "diffHunk": "@@ -61,6 +64,76 @@ public void testDescribeTable()\n         assertEquals(actualColumns, expectedColumns);\n     }\n \n+    @Test(dataProvider = \"createTableColumnTypes\")\n+    public void testCreateTableWithEveryType(String createType, String expectedType)\n+    {\n+        String tableName = \"test_types_table_\" + randomTableSuffix();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMwOTAzMQ==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r581309031", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            computeScalar(\"SElECT data_type FROM information_schema.columns WHERE table_name = '\" + tableName + \"' AND column_name = 'col1'\"),\n          \n          \n            \n                            computeScalar(\"SELECT data_type FROM information_schema.columns WHERE table_name = '\" + tableName + \"' AND column_name = 'col1'\"),", "author": "losipiuk", "createdAt": "2021-02-23T19:01:50Z", "path": "plugin/trino-bigquery/src/test/java/io/trino/plugin/bigquery/TestBigQueryIntegrationSmokeTest.java", "diffHunk": "@@ -61,6 +64,76 @@ public void testDescribeTable()\n         assertEquals(actualColumns, expectedColumns);\n     }\n \n+    @Test(dataProvider = \"createTableColumnTypes\")\n+    public void testCreateTableWithEveryType(String createType, String expectedType)\n+    {\n+        String tableName = \"test_types_table_\" + randomTableSuffix();\n+\n+        assertUpdate(\"DROP TABLE IF EXISTS \" + tableName);\n+\n+        assertUpdate(format(\"CREATE TABLE %s (col1 %s)\", tableName, createType));\n+\n+        assertEquals(\n+                computeScalar(\"SElECT data_type FROM information_schema.columns WHERE table_name = '\" + tableName + \"' AND column_name = 'col1'\"),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxMDA2NA==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r581310064", "bodyText": "maybe some test for unsupported type?", "author": "losipiuk", "createdAt": "2021-02-23T19:03:17Z", "path": "plugin/trino-bigquery/src/test/java/io/trino/plugin/bigquery/TestBigQueryIntegrationSmokeTest.java", "diffHunk": "@@ -61,6 +64,76 @@ public void testDescribeTable()\n         assertEquals(actualColumns, expectedColumns);\n     }\n \n+    @Test(dataProvider = \"createTableColumnTypes\")\n+    public void testCreateTableWithEveryType(String createType, String expectedType)\n+    {\n+        String tableName = \"test_types_table_\" + randomTableSuffix();\n+\n+        assertUpdate(\"DROP TABLE IF EXISTS \" + tableName);\n+\n+        assertUpdate(format(\"CREATE TABLE %s (col1 %s)\", tableName, createType));\n+\n+        assertEquals(\n+                computeScalar(\"SElECT data_type FROM information_schema.columns WHERE table_name = '\" + tableName + \"' AND column_name = 'col1'\"),\n+                expectedType);\n+\n+        assertUpdate(\"DROP TABLE \" + tableName);\n+    }\n+\n+    @DataProvider\n+    public Object[][] createTableColumnTypes()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjAxMjM3OA==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r582012378", "bodyText": "@losipiuk Do you mean this provider contains unsupported types? Or we should add tests  for unsupported types?\nIt seems if we use a same table name in this tests, we may get below error:\n\njava.lang.RuntimeException: Exceeded rate limits: too many table update operations for this table. For more information, see https://cloud.google.com/bigquery/troubleshooting-errors\n\n\tat io.trino.testing.AbstractTestingTrinoClient.execute(AbstractTestingTrinoClient.java:120)\n\tat io.trino.testing.DistributedQueryRunner.execute(DistributedQueryRunner.java:491)\n\tat io.trino.testing.QueryAssertions.assertUpdate(QueryAssertions.java:71)\n\tat io.trino.testing.AbstractTestQueryFramework.assertUpdate(AbstractTestQueryFramework.java:215)\n\tat io.trino.testing.AbstractTestQueryFramework.assertUpdate(AbstractTestQueryFramework.java:210)\n\tat io.trino.plugin.bigquery.TestBigQueryIntegrationSmokeTest.testCreateTableSupportedType(TestBigQueryIntegrationSmokeTest.java:74)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\n\tat org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:104)\n\tat org.testng.internal.Invoker.invokeMethod(Invoker.java:645)\n\tat org.testng.internal.Invoker.invokeTestMethod(Invoker.java:851)\n\tat org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1177)\n\tat org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:129)\n\tat org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:112)\n\tat org.testng.TestRunner.privateRun(TestRunner.java:756)\n\tat org.testng.TestRunner.run(TestRunner.java:610)\n\tat org.testng.SuiteRunner.runTest(SuiteRunner.java:387)\n\tat org.testng.SuiteRunner.runSequentially(SuiteRunner.java:382)\n\tat org.testng.SuiteRunner.privateRun(SuiteRunner.java:340)\n\tat org.testng.SuiteRunner.run(SuiteRunner.java:289)\n\tat org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52)\n\tat org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:86)\n\tat org.testng.TestNG.runSuitesSequentially(TestNG.java:1293)\n\tat org.testng.TestNG.runSuitesLocally(TestNG.java:1218)\n\tat org.testng.TestNG.runSuites(TestNG.java:1133)\n\tat org.testng.TestNG.run(TestNG.java:1104)\n\tat com.intellij.rt.testng.IDEARemoteTestNG.run(IDEARemoteTestNG.java:66)\n\tat com.intellij.rt.testng.RemoteTestNGStarter.main(RemoteTestNGStarter.java:109)\nCaused by: com.google.cloud.bigquery.BigQueryException: Exceeded rate limits: too many table update operations for this table. For more information, see https://cloud.google.com/bigquery/troubleshooting-errors\n\tat com.google.cloud.bigquery.spi.v2.HttpBigQueryRpc.translate(HttpBigQueryRpc.java:115)\n\tat com.google.cloud.bigquery.spi.v2.HttpBigQueryRpc.create(HttpBigQueryRpc.java:187)\n\tat com.google.cloud.bigquery.BigQueryImpl$2.call(BigQueryImpl.java:292)\n\tat com.google.cloud.bigquery.BigQueryImpl$2.call(BigQueryImpl.java:289)\n\tat com.google.api.gax.retrying.DirectRetryingExecutor.submit(DirectRetryingExecutor.java:105)\n\tat com.google.cloud.RetryHelper.run(RetryHelper.java:76)\n\tat com.google.cloud.RetryHelper.runWithRetries(RetryHelper.java:50)\n\tat com.google.cloud.bigquery.BigQueryImpl.create(BigQueryImpl.java:288)\n\tat io.trino.plugin.bigquery.BigQueryClient.createTable(BigQueryClient.java:208)\n\tat io.trino.plugin.bigquery.BigQueryMetadata.createTable(BigQueryMetadata.java:322)\n\tat io.trino.plugin.bigquery.BigQueryMetadata.createTable(BigQueryMetadata.java:299)\n\tat io.trino.metadata.MetadataManager.createTable(MetadataManager.java:675)\n\tat io.trino.execution.CreateTableTask.internalExecute(CreateTableTask.java:227)\n\tat io.trino.execution.CreateTableTask.execute(CreateTableTask.java:91)\n\tat io.trino.execution.CreateTableTask.execute(CreateTableTask.java:73)\n\tat io.trino.execution.DataDefinitionExecution.start(DataDefinitionExecution.java:167)\n\tat io.trino.execution.SqlQueryManager.createQuery(SqlQueryManager.java:237)\n\tat io.trino.dispatcher.LocalDispatchQuery.lambda$startExecution$7(LocalDispatchQuery.java:143)\n\tat io.trino.$gen.Trino_testversion____20210224_143345_3.run(Unknown Source)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\n\tat java.base/java.lang.Thread.run(Thread.java:834)\nCaused by: com.google.api.client.googleapis.json.GoogleJsonResponseException: 403 Forbidden\nPOST https://www.googleapis.com/bigquery/v2/projects/ivory-oarlock-268702/datasets/tpch/tables?prettyPrint=false\n{\n  \"code\" : 403,\n  \"errors\" : [ {\n    \"domain\" : \"usageLimits\",\n    \"message\" : \"Exceeded rate limits: too many table update operations for this table. For more information, see https://cloud.google.com/bigquery/troubleshooting-errors\",\n    \"reason\" : \"rateLimitExceeded\"\n  } ],\n  \"message\" : \"Exceeded rate limits: too many table update operations for this table. For more information, see https://cloud.google.com/bigquery/troubleshooting-errors\",\n  \"status\" : \"PERMISSION_DENIED\"\n}\n\tat com.google.api.client.googleapis.json.GoogleJsonResponseException.from(GoogleJsonResponseException.java:146)\n\tat com.google.api.client.googleapis.services.json.AbstractGoogleJsonClientRequest.newExceptionOnError(AbstractGoogleJsonClientRequest.java:118)\n\tat com.google.api.client.googleapis.services.json.AbstractGoogleJsonClientRequest.newExceptionOnError(AbstractGoogleJsonClientRequest.java:37)\n\tat com.google.api.client.googleapis.services.AbstractGoogleClientRequest$1.interceptResponse(AbstractGoogleClientRequest.java:428)\n\tat com.google.api.client.http.HttpRequest.execute(HttpRequest.java:1108)\n\tat com.google.api.client.googleapis.services.AbstractGoogleClientRequest.executeUnparsed(AbstractGoogleClientRequest.java:514)\n\tat com.google.api.client.googleapis.services.AbstractGoogleClientRequest.executeUnparsed(AbstractGoogleClientRequest.java:455)\n\tat com.google.api.client.googleapis.services.AbstractGoogleClientRequest.execute(AbstractGoogleClientRequest.java:565)\n\tat com.google.cloud.bigquery.spi.v2.HttpBigQueryRpc.create(HttpBigQueryRpc.java:185)\n\t... 20 more", "author": "ebyhr", "createdAt": "2021-02-24T14:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxMDA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjAxODIwOA==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r582018208", "bodyText": "@losipiuk Do you mean this provider contains unsupported types? Or we should add tests for unsupported types?\n\nI meant adding test for unsupported type. But this is optional. I do not think we do that for other connectors.\n\nIt seems if we use a same table name in this tests, we may get below error:\n\nWhat about using some deterministic table name generator (some_prefix_<tested_type>?)", "author": "losipiuk", "createdAt": "2021-02-24T14:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxMDA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxMjQ0Mw==", "url": "https://github.com/trinodb/trino/pull/3767#discussion_r581312443", "bodyText": "add test checking that CREATE TABLE fails if table already exists and CREATE TABLE IF NOT EXISTS works fine as a noop.", "author": "losipiuk", "createdAt": "2021-02-23T19:07:01Z", "path": "plugin/trino-bigquery/src/test/java/io/trino/plugin/bigquery/TestBigQueryIntegrationSmokeTest.java", "diffHunk": "@@ -61,6 +64,76 @@ public void testDescribeTable()\n         assertEquals(actualColumns, expectedColumns);\n     }\n \n+    @Test(dataProvider = \"createTableColumnTypes\")\n+    public void testCreateTableWithEveryType(String createType, String expectedType)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "515b5f9920cf8498b7e1fa74a3c8d95336fdc4b0", "url": "https://github.com/trinodb/trino/commit/515b5f9920cf8498b7e1fa74a3c8d95336fdc4b0", "message": "Add support for CREATE and DROP TABLE in BigQuery", "committedDate": "2021-02-28T11:22:56Z", "type": "commit"}, {"oid": "515b5f9920cf8498b7e1fa74a3c8d95336fdc4b0", "url": "https://github.com/trinodb/trino/commit/515b5f9920cf8498b7e1fa74a3c8d95336fdc4b0", "message": "Add support for CREATE and DROP TABLE in BigQuery", "committedDate": "2021-02-28T11:22:56Z", "type": "forcePushed"}]}