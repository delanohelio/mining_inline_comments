{"pr_number": 3735, "pr_title": "Add support for passthrough Elasticsearch queries", "pr_createdAt": "2020-05-14T17:29:57Z", "pr_url": "https://github.com/trinodb/trino/pull/3735", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4MzM2MA==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425483360", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (handle.getType().equals(QUERY)) {\n          \n          \n            \n                    if (handle.getType() == QUERY) {\n          \n      \n    \n    \n  \n\nOr perhaps a helper method like isPassthroughQuery() would aid readability, since this test shows up in a few places.", "author": "aalbu", "createdAt": "2020-05-14T23:23:52Z", "path": "presto-elasticsearch/src/main/java/io/prestosql/elasticsearch/ElasticsearchMetadata.java", "diffHunk": "@@ -115,37 +163,84 @@ public ElasticsearchTableHandle getTableHandle(ConnectorSession session, SchemaT\n     public ConnectorTableMetadata getTableMetadata(ConnectorSession session, ConnectorTableHandle table)\n     {\n         ElasticsearchTableHandle handle = (ElasticsearchTableHandle) table;\n+\n+        if (handle.getType().equals(QUERY)) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5MzE0MQ==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425493141", "bodyText": "Using pretty is going to make the response bigger.", "author": "aalbu", "createdAt": "2020-05-14T23:58:20Z", "path": "presto-elasticsearch/src/main/java/io/prestosql/elasticsearch/client/ElasticsearchClient.java", "diffHunk": "@@ -530,6 +532,36 @@ private JsonNode nullSafeNode(JsonNode jsonNode, String name)\n         return jsonNode.get(name);\n     }\n \n+    public String executeQuery(String index, String query)\n+    {\n+        String path = format(\"/%s/_search?pretty\", index);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNDAzMw==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425524033", "bodyText": "Only one byte per line :)\nIt makes it much easier to debug issues, so all things considered, it's not a big deal.", "author": "martint", "createdAt": "2020-05-15T01:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5MzE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUzMzIzNQ==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425533235", "bodyText": "Don't forget the spaces added for indentation.  I think the size difference can be considerable (I've compared responses of some searches I was playing with and I saw a factor of 2x).", "author": "aalbu", "createdAt": "2020-05-15T02:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5MzE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUzODg3NQ==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425538875", "bodyText": "Tthat's a good point. I'll change it.", "author": "martint", "createdAt": "2020-05-15T02:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5MzE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5OTk5MQ==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425499991", "bodyText": "It seems more expressive use the equivalent SQL query for expected: SELECT max(orderkey), sum(orderkey) FROM orders", "author": "aalbu", "createdAt": "2020-05-15T00:23:11Z", "path": "presto-elasticsearch/src/test/java/io/prestosql/elasticsearch/BaseElasticsearchSmokeTest.java", "diffHunk": "@@ -747,6 +749,27 @@ public void testMultiIndexAlias()\n                 \"SELECT (SELECT count(*) FROM region) + (SELECT count(*) FROM nation)\");\n     }\n \n+    @Test\n+    public void testPassthroughQuery()\n+    {\n+        @Language(\"JSON\")\n+        String query = \"{\\n\" +\n+                \"    \\\"size\\\": 0,\\n\" +\n+                \"    \\\"aggs\\\" : {\\n\" +\n+                \"        \\\"max_orderkey\\\" : { \\\"max\\\" : { \\\"field\\\" : \\\"orderkey\\\" } },\\n\" +\n+                \"        \\\"sum_orderkey\\\" : { \\\"sum\\\" : { \\\"field\\\" : \\\"orderkey\\\" } }\\n\" +\n+                \"    }\\n\" +\n+                \"}\";\n+\n+        assertQuery(\n+                format(\"WITH data(r) AS (\" +\n+                        \"   SELECT CAST(result AS ROW(aggregations ROW(max_orderkey ROW(value BIGINT), sum_orderkey ROW(value BIGINT)))) \" +\n+                        \"   FROM \\\"orders$query:%s\\\") \" +\n+                        \"SELECT r.aggregations.max_orderkey.value, r.aggregations.sum_orderkey.value \" +\n+                        \"FROM data\", BaseEncoding.base32().encode(query.getBytes(UTF_8))),\n+                \"VALUES (60000, 449872500)\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNDM0Mw==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425524343", "bodyText": "I know. The purpose of this is not to test that complex ES queries work, but that passthrough queries work. It doesn't matter what, as long as it does the full roundtrip.", "author": "martint", "createdAt": "2020-05-15T01:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ5OTk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUxOTQzNA==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425519434", "bodyText": "I was thinking about the relative advantages of using JSON vs VARCHAR for the column type.  JSON is more expressive (one might even argue correctness), but without knowing how a client might use the result, VARCHAR might be more pragmatic.  I think it's conceivable one might want to parse and process the results of an aggregation client side, so they might end up serializing the result and reading the resulting string.  The responses can get pretty big and the cost of parsing a big JSON document might not be insignificant.  On the other hand, if a client wanted to join the aggregation result with some other table, they'd only need to call json_parse(result).", "author": "aalbu", "createdAt": "2020-05-15T01:39:21Z", "path": "presto-elasticsearch/src/main/java/io/prestosql/elasticsearch/ElasticsearchMetadata.java", "diffHunk": "@@ -79,6 +95,16 @@ public ElasticsearchMetadata(TypeManager typeManager, ElasticsearchClient client\n         this.client = requireNonNull(client, \"client is null\");\n         requireNonNull(config, \"config is null\");\n         this.schemaName = config.getDefaultSchema();\n+\n+        Type jsonType = typeManager.getType(new TypeSignature(StandardTypes.JSON));\n+        queryResultColumnMetadata = ColumnMetadata.builder()\n+                .setName(\"result\")\n+                .setType(jsonType)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNTM1NQ==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425525355", "bodyText": "I started with VARCHAR and then ended up changing it to JSON. In practice, I expect almost all usages to try to do something with the result as a JSON object. Parsing the result client side is a very roundabout way of interacting with ES. You might as well talk to it directly.\nIf you need the text, just use json_format. It's actually free under the covers, as the internal representation of the JSON type is the json string.", "author": "martint", "createdAt": "2020-05-15T02:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUxOTQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMjY4Mg==", "url": "https://github.com/trinodb/trino/pull/3735#discussion_r425522682", "bodyText": "Perhaps a test for an invalid query?", "author": "aalbu", "createdAt": "2020-05-15T01:52:11Z", "path": "presto-elasticsearch/src/test/java/io/prestosql/elasticsearch/BaseElasticsearchSmokeTest.java", "diffHunk": "@@ -747,6 +749,27 @@ public void testMultiIndexAlias()\n                 \"SELECT (SELECT count(*) FROM region) + (SELECT count(*) FROM nation)\");\n     }\n \n+    @Test\n+    public void testPassthroughQuery()\n+    {\n+        @Language(\"JSON\")\n+        String query = \"{\\n\" +\n+                \"    \\\"size\\\": 0,\\n\" +\n+                \"    \\\"aggs\\\" : {\\n\" +\n+                \"        \\\"max_orderkey\\\" : { \\\"max\\\" : { \\\"field\\\" : \\\"orderkey\\\" } },\\n\" +\n+                \"        \\\"sum_orderkey\\\" : { \\\"sum\\\" : { \\\"field\\\" : \\\"orderkey\\\" } }\\n\" +\n+                \"    }\\n\" +\n+                \"}\";\n+\n+        assertQuery(\n+                format(\"WITH data(r) AS (\" +\n+                        \"   SELECT CAST(result AS ROW(aggregations ROW(max_orderkey ROW(value BIGINT), sum_orderkey ROW(value BIGINT)))) \" +\n+                        \"   FROM \\\"orders$query:%s\\\") \" +\n+                        \"SELECT r.aggregations.max_orderkey.value, r.aggregations.sum_orderkey.value \" +\n+                        \"FROM data\", BaseEncoding.base32().encode(query.getBytes(UTF_8))),\n+                \"VALUES (60000, 449872500)\");\n+    }\n+", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "dbd132c861c11ded7afc0b9d4333a73455450660", "url": "https://github.com/trinodb/trino/commit/dbd132c861c11ded7afc0b9d4333a73455450660", "message": "Add support for passthrough Elasticsearch queries\n\nThis allows running queries over the results of a raw Elasticsearch query.\nIt extends the syntax of the enhanced ES table names with the following:\n\n    SELECT * FROM es.default.\"<index>$query:<base32-encoded ES query>\"\n\nThe query is base32-encoded to avoid having to deal with escaping quotes and case\nsensitivity issues in table identifiers.\n\nThe result of these query tables is a table with a single row and a single column\nnamed \"result\" of type JSON.", "committedDate": "2020-05-15T18:55:56Z", "type": "commit"}, {"oid": "dbd132c861c11ded7afc0b9d4333a73455450660", "url": "https://github.com/trinodb/trino/commit/dbd132c861c11ded7afc0b9d4333a73455450660", "message": "Add support for passthrough Elasticsearch queries\n\nThis allows running queries over the results of a raw Elasticsearch query.\nIt extends the syntax of the enhanced ES table names with the following:\n\n    SELECT * FROM es.default.\"<index>$query:<base32-encoded ES query>\"\n\nThe query is base32-encoded to avoid having to deal with escaping quotes and case\nsensitivity issues in table identifiers.\n\nThe result of these query tables is a table with a single row and a single column\nnamed \"result\" of type JSON.", "committedDate": "2020-05-15T18:55:56Z", "type": "forcePushed"}]}