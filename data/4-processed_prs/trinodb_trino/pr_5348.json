{"pr_number": 5348, "pr_title": "Add dynamic filtering documentation", "pr_createdAt": "2020-09-29T18:13:53Z", "pr_url": "https://github.com/trinodb/trino/pull/5348", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQwNDQ2OA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497404468", "bodyText": "I think it's too technical. Maybe:\n.. by avoiding reading of data that would be filtered by join condition.", "author": "sopel39", "createdAt": "2020-09-30T10:26:38Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQwNTQ5MA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497405490", "bodyText": "It's too technical. Maybe:\nFor dynamic filtering -> When dynamic filtering is enabled, Presto will collect candidate values for join condition from processed dimension table (right join side).", "author": "sopel39", "createdAt": "2020-09-30T10:28:29Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyMzM5OA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497423398", "bodyText": "Change:\nare pushed into the table scan on the connected data source running locally on the same worker.\ninto\nare pushed into the local table scan (left join side) running locally on the same worker.", "author": "sopel39", "createdAt": "2020-09-30T11:03:49Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyMzk0Mg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497423942", "bodyText": "during enumeration of splits for a table scan by a connector\nto\nduring enumeration of table scan splits", "author": "sopel39", "createdAt": "2020-09-30T11:04:54Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyNDE1Nw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497424157", "bodyText": "skip loading partitions -> skip loading of partitions", "author": "sopel39", "createdAt": "2020-09-30T11:05:18Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyNDQyNw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497424427", "bodyText": "break into separate sentences:\nthe join criteria. This is known as dynamic partition pruning.", "author": "sopel39", "createdAt": "2020-09-30T11:05:49Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyNTU3Ng==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497425576", "bodyText": "Maybe\nSupport for dynamic filtering pushdown\n\nIt's not obvious that DF generation is independent of connectors.", "author": "sopel39", "createdAt": "2020-09-30T11:08:07Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyNjA2Mg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497426062", "bodyText": "This is redundant to previous point. I would remove it", "author": "sopel39", "createdAt": "2020-09-30T11:09:09Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyNjM3Nw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497426377", "bodyText": "Size of build side of join. -> Size of right (build) side of join.", "author": "sopel39", "createdAt": "2020-09-30T11:09:38Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQyNzIyMQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497427221", "bodyText": "extra space before .", "author": "sopel39", "createdAt": "2020-09-30T11:10:59Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQzMjM0OA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497432348", "bodyText": "Relationship between dynamicFiltersStats and dynamicFilterSplitsProcessed is not obvious. Reader can think that when dynamicFilterDomainStats has all domains, then table scan DF is ineffective. We could mention that dynamicFiltersStats reports stats about DFs that were pushed to coordinator, while dynamicFilterSplitsProcessed mentions node local DFs", "author": "sopel39", "createdAt": "2020-09-30T11:21:19Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, dynamic filtering stats can be found in\n+``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan can be\n+verified by looking at operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUxMDE0NA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497510144", "bodyText": "There can be a small delay in dynamic filters reaching the coordinator. But in current implementation, I think if node local DF is able to use a non-all DF, then the coordinator should also receive a non-all DF eventually. Could you please point out the scenario where node-local DF was effective but coordinator has all domain ?\nI will make the change to clarify that dynamicFiltersStats is recording stats for DF collected in coordinator.", "author": "raunaqmorarka", "createdAt": "2020-09-30T13:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQzMjM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1NjgzNA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497456834", "bodyText": "Move that section to Hive documentation (with reference to this doc).", "author": "sopel39", "createdAt": "2020-09-30T12:07:47Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, dynamic filtering stats can be found in\n+``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan can be\n+verified by looking at operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Delaying execution for dynamic filters", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1NjkwMw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497456903", "bodyText": "I would skip from build side and probe side and would just leave:\nIt can often be beneficial to wait for collection of dynamic filters before starting table scan.", "author": "sopel39", "createdAt": "2020-09-30T12:07:54Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, dynamic filtering stats can be found in\n+``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan can be\n+verified by looking at operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of dynamic filters\n+from build side to complete before executing the probe side table scan.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1ODU3NQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497458575", "bodyText": "Also for Hive this only works for partition pruning, so this could be:\ncollection of dynamic filters before enumerating table partitions", "author": "sopel39", "createdAt": "2020-09-30T12:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1NjkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUxODQzMw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497518433", "bodyText": "It indirectly works for node-local DF as well since by the time the dynamic filters reach the coordinator, they would be ready for use in local table scans too.", "author": "raunaqmorarka", "createdAt": "2020-09-30T13:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1NjkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1NzEwNg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497457106", "bodyText": "in query and CPU time", "author": "sopel39", "createdAt": "2020-09-30T12:08:19Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, dynamic filtering stats can be found in\n+``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan can be\n+verified by looking at operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of dynamic filters\n+from build side to complete before executing the probe side table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query runtime if dynamic filtering is able to eliminate a large amount", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1NzMzNQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497457335", "bodyText": "is able to reduce amount of scanned data\nRemove probe side", "author": "sopel39", "createdAt": "2020-09-30T12:08:44Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, dynamic filtering stats can be found in\n+``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan can be\n+verified by looking at operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of dynamic filters\n+from build side to complete before executing the probe side table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query runtime if dynamic filtering is able to eliminate a large amount\n+of unnecessary data from the probe side.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1NzgxMg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497457812", "bodyText": "remove probe side just keep For the Hive connector, table scan can be delayed...", "author": "sopel39", "createdAt": "2020-09-30T12:09:36Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, dynamic filtering stats can be found in\n+``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan can be\n+verified by looking at operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of dynamic filters\n+from build side to complete before executing the probe side table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query runtime if dynamic filtering is able to eliminate a large amount\n+of unnecessary data from the probe side.\n+For the Hive connector, probe side table scan can be delayed for a configured", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1OTAxNA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497459014", "bodyText": "using table statistics provided by connector", "author": "sopel39", "createdAt": "2020-09-30T12:11:45Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, dynamic filtering stats can be found in\n+``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan can be\n+verified by looking at operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of dynamic filters\n+from build side to complete before executing the probe side table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query runtime if dynamic filtering is able to eliminate a large amount\n+of unnecessary data from the probe side.\n+For the Hive connector, probe side table scan can be delayed for a configured\n+amount of time for the arrival of dynamic filters using the configuration property\n+``hive.dynamic-filtering-probe-blocking-timeout`` or the session property\n+``hive.dynamic_filtering_probe_blocking_timeout``.\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics from the metastore.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ1OTM2Nw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497459367", "bodyText": "Therefore, it is recommended to keep table statistics up to date and rely...\nMaybe mention that for selected connectors (e.g hive) stats can be collected via analyze command.", "author": "sopel39", "createdAt": "2020-09-30T12:12:27Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, dynamic filtering stats can be found in\n+``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan can be\n+verified by looking at operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of dynamic filters\n+from build side to complete before executing the probe side table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query runtime if dynamic filtering is able to eliminate a large amount\n+of unnecessary data from the probe side.\n+For the Hive connector, probe side table scan can be delayed for a configured\n+amount of time for the arrival of dynamic filters using the configuration property\n+``hive.dynamic-filtering-probe-blocking-timeout`` or the session property\n+``hive.dynamic_filtering_probe_blocking_timeout``.\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics from the metastore.\n+Therefore, it is recommended to generate table statistics and rely on the CBO to correctly", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ2MTIwMQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r497461201", "bodyText": "I wouldn't say significant, but rather may incur additional CPU overhead during query execution", "author": "sopel39", "createdAt": "2020-09-30T12:15:38Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,231 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding unnecessary processing of data from the probe side\n+which does not match the join criteria.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+For dynamic filtering, Presto collects values eligible for the join from the\n+build side tasks in worker nodes. In the case of broadcast joins, the runtime predicates\n+generated from this collection are pushed into the table scan on the connected data source\n+running locally on the same worker. Additionally, these runtime predicates are communicated\n+to the coordinator over the network so that dynamic filtering can also be performed\n+on the coordinator during enumeration of splits for a table scan by a connector.\n+For example, in the case of Hive connector, dynamic filters are used to skip loading\n+partitions which don't match the join criteria, this is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for dynamic filtering is specific to each connector and the relevant underlying\n+database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Connector support for delaying scheduling of probe side until dynamic filters are ready.\n+* Size of build side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan .\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, dynamic filtering stats can be found in\n+``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan can be\n+verified by looking at operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of dynamic filters\n+from build side to complete before executing the probe side table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query runtime if dynamic filtering is able to eliminate a large amount\n+of unnecessary data from the probe side.\n+For the Hive connector, probe side table scan can be delayed for a configured\n+amount of time for the arrival of dynamic filters using the configuration property\n+``hive.dynamic-filtering-probe-blocking-timeout`` or the session property\n+``hive.dynamic_filtering_probe_blocking_timeout``.\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics from the metastore.\n+Therefore, it is recommended to generate table statistics and rely on the CBO to correctly\n+choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side\n+for dynamic filtering incurs significant costs during query execution.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4NDA4NQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498484085", "bodyText": "Empty line after this to make new paragraph", "author": "mosabua", "createdAt": "2020-10-01T20:03:02Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4ODY1Nw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498488657", "bodyText": "Presto pushes", "author": "mosabua", "createdAt": "2020-10-01T20:13:11Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4ODkzNw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498488937", "bodyText": "``date_dim``, and it scans all data in the fact table", "author": "mosabua", "createdAt": "2020-10-01T20:13:48Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4OTE1OA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498489158", "bodyText": "The join operator ends up throwing away", "author": "mosabua", "createdAt": "2020-10-01T20:14:13Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4OTYwNQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498489605", "bodyText": "Presto collects candiate..", "author": "mosabua", "createdAt": "2020-10-01T20:15:14Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4OTg4Mw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498489883", "bodyText": "add empty line after to start new paragraph", "author": "mosabua", "createdAt": "2020-10-01T20:15:47Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5MDIxMw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498490213", "bodyText": "new paragraph start\nFor example, ....", "author": "mosabua", "createdAt": "2020-10-01T20:16:28Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5MDU3Mw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498490573", "bodyText": "Should we update the doc title to be called Dynamic filtering and dynamic partition pruning ?", "author": "mosabua", "createdAt": "2020-10-01T20:17:13Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5MDgyNw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498490827", "bodyText": "At least we should bold the term (use **)", "author": "mosabua", "createdAt": "2020-10-01T20:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5MDU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY2MTIxMg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498661212", "bodyText": "I've made \"dynamic partition pruning\" bold. I think it's ok for the title to be \"Dynamic filtering\" as partition pruning is just a special case of DF for Hive. We'll also eventually have dynamic bucket pruning for bucketed Hive tables.", "author": "raunaqmorarka", "createdAt": "2020-10-02T07:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5MDU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5NzExNg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498497116", "bodyText": "connector,", "author": "mosabua", "createdAt": "2020-10-01T20:31:10Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5NzM3Mg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498497372", "bodyText": "into the table scan", "author": "mosabua", "createdAt": "2020-10-01T20:31:44Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5NzQ2Nw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498497467", "bodyText": "example, the Hive connector", "author": "mosabua", "createdAt": "2020-10-01T20:31:59Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5Nzk2MQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498497961", "bodyText": "of the join", "author": "mosabua", "createdAt": "2020-10-01T20:33:05Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5ODMwMw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498498303", "bodyText": "Turn the sentence around ..\nYou can take a closer look at the ... to analyze if the planner..", "author": "mosabua", "createdAt": "2020-10-01T20:33:53Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5ODY1MA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498498650", "bodyText": "planner is successful ..", "author": "mosabua", "createdAt": "2020-10-01T20:34:35Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5OTYzOQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498499639", "bodyText": "Web UI\nAnd maybe even link to the docs for it", "author": "mosabua", "createdAt": "2020-10-01T20:36:49Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5OTg5NA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498499894", "bodyText": "is pushed down", "author": "mosabua", "createdAt": "2020-10-01T20:37:27Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwMDA2Mg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498500062", "bodyText": "The cost-based optimizer", "author": "mosabua", "createdAt": "2020-10-01T20:37:50Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics provided by connectors.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwMjgwMQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498502801", "bodyText": "Analysis and configuration", "author": "mosabua", "createdAt": "2020-10-01T20:44:08Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwNTE4Mw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498505183", "bodyText": "Empty line before paragraph", "author": "mosabua", "createdAt": "2020-10-01T20:49:12Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics provided by connectors.\n+Therefore, it is recommended to keep :doc:`table statistics </optimizer/statistics>`\n+up to date and rely on the CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side\n+for dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be configured\n+for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their equivalent\n+for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters`` is not enabled\n+can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their equivalent\n+for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overheads.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.\n+The limits for min-max filters collection are defined by the properties\n+based on ``range-row-limit-per-driver``.\n+\n+Data layout considerations\n+--------------------------", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwNTM2Mg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498505362", "bodyText": "For the Hive connector", "author": "mosabua", "createdAt": "2020-10-01T20:49:33Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics provided by connectors.\n+Therefore, it is recommended to keep :doc:`table statistics </optimizer/statistics>`\n+up to date and rely on the CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side\n+for dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be configured\n+for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their equivalent\n+for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters`` is not enabled\n+can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their equivalent\n+for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overheads.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.\n+The limits for min-max filters collection are defined by the properties\n+based on ``range-row-limit-per-driver``.\n+\n+Data layout considerations\n+--------------------------\n+Dynamic filtering is most effective when a connector stores data in a layout that can\n+be leveraged for efficient filtering at runtime.\n+For Hive connector, dynamic filter predicates are pushed into the ORC and Parquet readers", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxMjgyNw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498512827", "bodyText": "can we simplify or break up that last long sentence?", "author": "mosabua", "createdAt": "2020-10-01T21:05:23Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics provided by connectors.\n+Therefore, it is recommended to keep :doc:`table statistics </optimizer/statistics>`\n+up to date and rely on the CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side\n+for dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be configured\n+for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their equivalent\n+for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters`` is not enabled\n+can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their equivalent\n+for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overheads.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.\n+The limits for min-max filters collection are defined by the properties\n+based on ``range-row-limit-per-driver``.\n+\n+Data layout considerations\n+--------------------------\n+Dynamic filtering is most effective when a connector stores data in a layout that can\n+be leveraged for efficient filtering at runtime.\n+For Hive connector, dynamic filter predicates are pushed into the ORC and Parquet readers\n+on the worker nodes to perform stripe or row-group pruning and save on disk I/O.\n+Sorting files by the columns used in join criteria significantly improves the\n+effectiveness of stripe or row-group pruning. This is because sorting results in similar", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY2MTg4Mg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498661882", "bodyText": "Modified this a bit", "author": "raunaqmorarka", "createdAt": "2020-10-02T07:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxMjgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxMjk1MA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498512950", "bodyText": "empty line after", "author": "mosabua", "createdAt": "2020-10-01T21:05:37Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics provided by connectors.\n+Therefore, it is recommended to keep :doc:`table statistics </optimizer/statistics>`\n+up to date and rely on the CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side\n+for dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be configured\n+for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their equivalent\n+for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters`` is not enabled\n+can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their equivalent\n+for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overheads.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.\n+The limits for min-max filters collection are defined by the properties\n+based on ``range-row-limit-per-driver``.\n+\n+Data layout considerations\n+--------------------------\n+Dynamic filtering is most effective when a connector stores data in a layout that can\n+be leveraged for efficient filtering at runtime.\n+For Hive connector, dynamic filter predicates are pushed into the ORC and Parquet readers\n+on the worker nodes to perform stripe or row-group pruning and save on disk I/O.\n+Sorting files by the columns used in join criteria significantly improves the\n+effectiveness of stripe or row-group pruning. This is because sorting results in similar\n+data getting stored within the same stripe or row-group which greatly improves the\n+selectivity of the min/max indexes maintained at stripe or row-group level.\n+\n+Partitioned Hive tables stored in any data format benefit from the\n+dynamic partition pruning optimization for broadcast as well as partitioned joins.\n+\n+Limitations\n+-----------", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxMzE2NA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498513164", "bodyText": "I think we should remove that and add it to the connectors instead ..", "author": "mosabua", "createdAt": "2020-10-01T21:06:08Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics provided by connectors.\n+Therefore, it is recommended to keep :doc:`table statistics </optimizer/statistics>`\n+up to date and rely on the CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side\n+for dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be configured\n+for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their equivalent\n+for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters`` is not enabled\n+can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their equivalent\n+for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overheads.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.\n+The limits for min-max filters collection are defined by the properties\n+based on ``range-row-limit-per-driver``.\n+\n+Data layout considerations\n+--------------------------\n+Dynamic filtering is most effective when a connector stores data in a layout that can\n+be leveraged for efficient filtering at runtime.\n+For Hive connector, dynamic filter predicates are pushed into the ORC and Parquet readers\n+on the worker nodes to perform stripe or row-group pruning and save on disk I/O.\n+Sorting files by the columns used in join criteria significantly improves the\n+effectiveness of stripe or row-group pruning. This is because sorting results in similar\n+data getting stored within the same stripe or row-group which greatly improves the\n+selectivity of the min/max indexes maintained at stripe or row-group level.\n+\n+Partitioned Hive tables stored in any data format benefit from the\n+dynamic partition pruning optimization for broadcast as well as partitioned joins.\n+\n+Limitations\n+-----------\n+* Dynamic filtering is currently implemented only for Hive and Memory connectors", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY2Njc1Mw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498666753", "bodyText": "I've added links to the connector docs. I think it's good to have this point noted in one place here.", "author": "raunaqmorarka", "createdAt": "2020-10-02T07:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxMzE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxMzIzOQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498513239", "bodyText": "remove \"currently\"", "author": "mosabua", "createdAt": "2020-10-01T21:06:21Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,219 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto will push predicates for the dimension table to the\n+table scan on ``date_dim`` but it will scan all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator will end up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto will collect candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits. For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as dynamic partition pruning.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector\n+and the relevant underlying database or storage system.\n+\n+Analysis and Confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into table scan at runtime.\n+  For example, Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of join.\n+\n+To analyze if the planner is adding dynamic filters to a specific query's plan,\n+take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner was successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the web-ui.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter was pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table needs to be chosen as a join\u2019s build side.\n+Cost-based optimizer can automatically do this using table statistics provided by connectors.\n+Therefore, it is recommended to keep :doc:`table statistics </optimizer/statistics>`\n+up to date and rely on the CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side\n+for dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be configured\n+for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their equivalent\n+for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters`` is not enabled\n+can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their equivalent\n+for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overheads.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.\n+The limits for min-max filters collection are defined by the properties\n+based on ``range-row-limit-per-driver``.\n+\n+Data layout considerations\n+--------------------------\n+Dynamic filtering is most effective when a connector stores data in a layout that can\n+be leveraged for efficient filtering at runtime.\n+For Hive connector, dynamic filter predicates are pushed into the ORC and Parquet readers\n+on the worker nodes to perform stripe or row-group pruning and save on disk I/O.\n+Sorting files by the columns used in join criteria significantly improves the\n+effectiveness of stripe or row-group pruning. This is because sorting results in similar\n+data getting stored within the same stripe or row-group which greatly improves the\n+selectivity of the min/max indexes maintained at stripe or row-group level.\n+\n+Partitioned Hive tables stored in any data format benefit from the\n+dynamic partition pruning optimization for broadcast as well as partitioned joins.\n+\n+Limitations\n+-----------\n+* Dynamic filtering is currently implemented only for Hive and Memory connectors\n+* Push down of dynamic filters into table scan is currently limited to broadcast joins", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNDEwOA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498514108", "bodyText": "starting a table scan.", "author": "mosabua", "createdAt": "2020-10-01T21:08:18Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -526,6 +526,18 @@ You can also drop statistics for selected partitions only::\n \n     CALL system.drop_stats(schema_name, table_name, ARRAY[ARRAY['p2_value1', 'p2_value2']])\n \n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of\n+:doc:`dynamic filters </admin/dynamic-filtering>` before starting table scan.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNDIzNA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498514234", "bodyText": "time, if dynamic", "author": "mosabua", "createdAt": "2020-10-01T21:08:37Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -526,6 +526,18 @@ You can also drop statistics for selected partitions only::\n \n     CALL system.drop_stats(schema_name, table_name, ARRAY[ARRAY['p2_value1', 'p2_value2']])\n \n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of\n+:doc:`dynamic filters </admin/dynamic-filtering>` before starting table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query and CPU time if dynamic filtering is able to reduce amount of scanned data.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNDQxOQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498514419", "bodyText": "also new paragraph after this sentence", "author": "mosabua", "createdAt": "2020-10-01T21:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNDIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNDU5NA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498514594", "bodyText": ", the table scan\nor\n, a table scna", "author": "mosabua", "createdAt": "2020-10-01T21:09:29Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -526,6 +526,18 @@ You can also drop statistics for selected partitions only::\n \n     CALL system.drop_stats(schema_name, table_name, ARRAY[ARRAY['p2_value1', 'p2_value2']])\n \n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of\n+:doc:`dynamic filters </admin/dynamic-filtering>` before starting table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query and CPU time if dynamic filtering is able to reduce amount of scanned data.\n+For the Hive connector, table scan can be delayed for a configured amount of time", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNTE5NQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498515195", "bodyText": "I assume this is a catalog session property and actually just called dynamic_filtering_probe_blocking_timeout ...\nand hive is just the catalog name in this case .. we should clarify", "author": "mosabua", "createdAt": "2020-10-01T21:10:58Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -526,6 +526,18 @@ You can also drop statistics for selected partitions only::\n \n     CALL system.drop_stats(schema_name, table_name, ARRAY[ARRAY['p2_value1', 'p2_value2']])\n \n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of\n+:doc:`dynamic filters </admin/dynamic-filtering>` before starting table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query and CPU time if dynamic filtering is able to reduce amount of scanned data.\n+For the Hive connector, table scan can be delayed for a configured amount of time\n+for the arrival of dynamic filters using the configuration property\n+``hive.dynamic-filtering-probe-blocking-timeout`` or the session property", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY2NTcwOA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498665708", "bodyText": "modified this to make it clearer", "author": "raunaqmorarka", "createdAt": "2020-10-02T07:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNTE5NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2ODY2Mw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498868663", "bodyText": "join condition -> join conditions", "author": "sopel39", "createdAt": "2020-10-02T14:47:54Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,227 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2OTg4NQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498869885", "bodyText": "I wonder if we could just throw Fragment 0 away? WDYT: @mosabua ?", "author": "sopel39", "createdAt": "2020-10-02T14:49:46Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,227 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMDg2NQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499010865", "bodyText": "Anything in this snippet that is not crucial for describing what happens could (and probabky should) be replaced with ... or similar", "author": "mosabua", "createdAt": "2020-10-02T19:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2OTg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MzIxOQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499043219", "bodyText": "Replaced Fragment 0 with ...", "author": "raunaqmorarka", "createdAt": "2020-10-02T20:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2OTg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3MDIwMg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498870202", "bodyText": "Is it be possible to color relevant parts somehow (dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\" and dynamicFilterAssignments = {d_date_sk -> df_370})\n@mosabua  ?", "author": "sopel39", "createdAt": "2020-10-02T14:50:17Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,227 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMTE2OA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499011168", "bodyText": "unforunately you can not do that in code snippets .. but taking anything out that is a distraction is probably good", "author": "mosabua", "createdAt": "2020-10-02T19:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3MDIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3MzQwMw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498873403", "bodyText": "overheads -> overhead", "author": "sopel39", "createdAt": "2020-10-02T14:55:36Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,227 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the\n+:doc:`/admin/web-interface`.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter is pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table\n+needs to be chosen as a join\u2019s build side. The cost-based optimizer can automatically\n+do this using table statistics provided by connectors. Therefore, it is recommended\n+to keep :doc:`table statistics </optimizer/statistics>` up to date and rely on the\n+CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side for\n+dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3NDQzNQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498874435", "bodyText": "overheads -> overhead", "author": "sopel39", "createdAt": "2020-10-02T14:57:11Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,227 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the\n+:doc:`/admin/web-interface`.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter is pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table\n+needs to be chosen as a join\u2019s build side. The cost-based optimizer can automatically\n+do this using table statistics provided by connectors. Therefore, it is recommended\n+to keep :doc:`table statistics </optimizer/statistics>` up to date and rely on the\n+CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side for\n+dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be\n+configured for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their\n+equivalent for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters``\n+is not enabled can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their\n+equivalent for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overheads.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3NzY3NQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498877675", "bodyText": "please improve this sentence: Sorting files by the columns used in join criteria significantly improves the effectiveness of stripe or row-group pruning because sorting results in similar data getting stored within the same stripe or row-group\nIts too long and hard to understand", "author": "sopel39", "createdAt": "2020-10-02T15:02:29Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,227 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the\n+:doc:`/admin/web-interface`.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter is pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table\n+needs to be chosen as a join\u2019s build side. The cost-based optimizer can automatically\n+do this using table statistics provided by connectors. Therefore, it is recommended\n+to keep :doc:`table statistics </optimizer/statistics>` up to date and rely on the\n+CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side for\n+dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be\n+configured for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their\n+equivalent for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters``\n+is not enabled can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their\n+equivalent for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overheads.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.\n+The limits for min-max filters collection are defined by the properties\n+based on ``range-row-limit-per-driver``.\n+\n+Data layout considerations\n+--------------------------\n+\n+Dynamic filtering is most effective when a connector stores data in a layout that\n+can be leveraged for efficient filtering at runtime. For the Hive connector,\n+dynamic filter predicates are pushed into the ORC and Parquet readers on the\n+worker nodes to perform stripe or row-group pruning and save on disk I/O.\n+Sorting files by the columns used in join criteria significantly improves the", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwOTc4OA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498909788", "bodyText": "Tried to clarify this part more.", "author": "raunaqmorarka", "createdAt": "2020-10-02T15:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3NzY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NDg1Mw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499044853", "bodyText": "Note that I have moved the content in the section on Data layout considerations to the dynamic filtering related content in Hive connector doc as it fits better there.\ncc: @mosabua", "author": "raunaqmorarka", "createdAt": "2020-10-02T20:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3NzY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg4MTA2Ng==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498881066", "bodyText": "that's too vague. Does it mean pushdown on coordinator too? Make it specific that it's node local pushdown.", "author": "sopel39", "createdAt": "2020-10-02T15:08:03Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,227 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join condition and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the\n+:doc:`/admin/web-interface`.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter is pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table\n+needs to be chosen as a join\u2019s build side. The cost-based optimizer can automatically\n+do this using table statistics provided by connectors. Therefore, it is recommended\n+to keep :doc:`table statistics </optimizer/statistics>` up to date and rely on the\n+CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side for\n+dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overheads of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be\n+configured for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their\n+equivalent for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters``\n+is not enabled can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their\n+equivalent for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overheads.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.\n+The limits for min-max filters collection are defined by the properties\n+based on ``range-row-limit-per-driver``.\n+\n+Data layout considerations\n+--------------------------\n+\n+Dynamic filtering is most effective when a connector stores data in a layout that\n+can be leveraged for efficient filtering at runtime. For the Hive connector,\n+dynamic filter predicates are pushed into the ORC and Parquet readers on the\n+worker nodes to perform stripe or row-group pruning and save on disk I/O.\n+Sorting files by the columns used in join criteria significantly improves the\n+effectiveness of stripe or row-group pruning because sorting results in similar\n+data getting stored within the same stripe or row-group. This greatly improves the\n+selectivity of the min/max indexes maintained at stripe or row-group level.\n+\n+Partitioned Hive tables stored in any data format benefit from the\n+dynamic partition pruning optimization for broadcast as well as partitioned joins.\n+\n+Limitations\n+-----------\n+\n+* Dynamic filtering is currently implemented only for :doc:`/connector/hive` and :doc:`/connector/memory` connectors.\n+* Push down of dynamic filters into table scan is limited to broadcast joins.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwOTE1MQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498909151", "bodyText": "updated now", "author": "raunaqmorarka", "createdAt": "2020-10-02T15:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg4MTA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg4MjA0Nw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498882047", "bodyText": "Maybe\nFor the Hive connector, a table scan can be delayed (for a configured amount of time)\nuntil the collection of dynamic filters by using the configuration property ...", "author": "sopel39", "createdAt": "2020-10-02T15:09:42Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -526,6 +526,19 @@ You can also drop statistics for selected partitions only::\n \n     CALL system.drop_stats(schema_name, table_name, ARRAY[ARRAY['p2_value1', 'p2_value2']])\n \n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of\n+:doc:`dynamic filters </admin/dynamic-filtering>` before starting a table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query and CPU time, if dynamic filtering is able to reduce amount of scanned data.\n+\n+For the Hive connector, a table scan can be delayed for a configured amount", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NTQzNw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498995437", "bodyText": "should we update to\nDynamic filtering and dynamic partition pruning\n??", "author": "mosabua", "createdAt": "2020-10-02T18:52:27Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5OTcwMw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r498999703", "bodyText": "I think it's ok for the title to be \"Dynamic filtering\" as partition pruning is just a special case of DF for Hive. We'll also eventually have other types of dynamic filtering like dynamic bucket pruning for bucketed Hive tables and dynamic row filtering (compiled filters after table scan). So the umbrella term of dynamic filtering should be ok as the title.", "author": "raunaqmorarka", "createdAt": "2020-10-02T19:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NTQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3MTMwNw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499071307", "bodyText": "Sounds good. we can have separate subsections for things later .. for now this is good", "author": "mosabua", "createdAt": "2020-10-02T22:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwODE3MA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499008170", "bodyText": "not sure if we should format it across lines differently..\nSELECT count(*) \nFROM store_sales\nJOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\nWHERE d_following_holiday='Y' \nAND d_year = 2000;\n\nor so?", "author": "mosabua", "createdAt": "2020-10-02T19:21:40Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MzQ0Mw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499043443", "bodyText": "re-formatted", "author": "raunaqmorarka", "createdAt": "2020-10-02T20:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwODE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwODU0Mw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499008543", "bodyText": "of the join", "author": "mosabua", "createdAt": "2020-10-02T19:22:32Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAwODcwOQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499008709", "bodyText": "of the Hive connector", "author": "mosabua", "createdAt": "2020-10-02T19:22:53Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNDI0NA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499014244", "bodyText": "similar reformat to above maybe?", "author": "mosabua", "createdAt": "2020-10-02T19:36:06Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join conditions and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MjE4NA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499042184", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-10-02T20:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNDI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNDQxNA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499014414", "bodyText": "running the following statement::", "author": "mosabua", "createdAt": "2020-10-02T19:36:32Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join conditions and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNjQ2Nw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499016467", "bodyText": "on the size of", "author": "mosabua", "createdAt": "2020-10-02T19:41:25Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join conditions and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the\n+:doc:`/admin/web-interface`.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter is pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table\n+needs to be chosen as a join\u2019s build side. The cost-based optimizer can automatically\n+do this using table statistics provided by connectors. Therefore, it is recommended\n+to keep :doc:`table statistics </optimizer/statistics>` up to date and rely on the\n+CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side for\n+dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overhead of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNjY0Nw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499016647", "bodyText": "on the size of", "author": "mosabua", "createdAt": "2020-10-02T19:41:51Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join conditions and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the\n+:doc:`/admin/web-interface`.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter is pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table\n+needs to be chosen as a join\u2019s build side. The cost-based optimizer can automatically\n+do this using table statistics provided by connectors. Therefore, it is recommended\n+to keep :doc:`table statistics </optimizer/statistics>` up to date and rely on the\n+CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side for\n+dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overhead of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNjgwMQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499016801", "bodyText": "equivalents", "author": "mosabua", "createdAt": "2020-10-02T19:42:13Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join conditions and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the\n+:doc:`/admin/web-interface`.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter is pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table\n+needs to be chosen as a join\u2019s build side. The cost-based optimizer can automatically\n+do this using table statistics provided by connectors. Therefore, it is recommended\n+to keep :doc:`table statistics </optimizer/statistics>` up to date and rely on the\n+CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side for\n+dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overhead of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be\n+configured for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their\n+equivalent for partitioned join distribution type.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNzEwMA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499017100", "bodyText": "of the join", "author": "mosabua", "createdAt": "2020-10-02T19:43:00Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join conditions and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the\n+:doc:`/admin/web-interface`.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter is pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table\n+needs to be chosen as a join\u2019s build side. The cost-based optimizer can automatically\n+do this using table statistics provided by connectors. Therefore, it is recommended\n+to keep :doc:`table statistics </optimizer/statistics>` up to date and rely on the\n+CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side for\n+dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overhead of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be\n+configured for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their\n+equivalent for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters``\n+is not enabled can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their\n+equivalent for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overhead.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNzkwMw==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499017903", "bodyText": "Again.. I think we probably should have a small mention of this support in the actual connector docs and link back to this page\nAnd maybe remove from here.", "author": "mosabua", "createdAt": "2020-10-02T19:44:54Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -0,0 +1,228 @@\n+=================\n+Dynamic Filtering\n+=================\n+\n+Dynamic filtering optimizations significantly improve the performance of queries\n+with selective joins by avoiding reading of data that would be filtered by join condition.\n+\n+Consider the following query which captures a common pattern of a fact table ``store_sales``\n+joined with a filtered dimension table ``date_dim``:\n+\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+Without dynamic filtering, Presto pushes predicates for the dimension table to the\n+table scan on ``date_dim``, and it scans all the data in the fact table since there\n+are no filters on ``store_sales`` in the query. The join operator ends up throwing away\n+most of the probe-side rows as the join criteria is highly selective.\n+\n+When dynamic filtering is enabled, Presto collects candidate values for join condition\n+from the processed dimension table on the right side of join. In the case of broadcast joins,\n+the runtime predicates generated from this collection are pushed into the local table scan\n+on the left side of join running on the same worker.\n+\n+Additionally, these runtime predicates are communicated to the coordinator over the network\n+so that dynamic filtering can also be performed on the coordinator during enumeration of\n+table scan splits.\n+\n+For example, in the case of Hive connector, dynamic filters are used\n+to skip loading of partitions which don't match the join criteria.\n+This is known as **dynamic partition pruning**.\n+\n+The results of dynamic filtering optimization can include the following benefits:\n+\n+* improved overall query performance\n+* reduced network traffic between Presto and the data source\n+* reduced load on the remote data source\n+\n+Support for push down of dynamic filters is specific to each connector,\n+and the relevant underlying database or storage system.\n+\n+Analysis and confirmation\n+-------------------------\n+\n+Dynamic filtering depends on a number of factors:\n+\n+* Planner support for dynamic filtering for a given join operation in Presto.\n+  Currently inner joins with equality join conditions and semi-joins with IN conditions are supported.\n+* Connector support for utilizing dynamic filters pushed into the table scan at runtime.\n+  For example, the Hive connector can push dynamic filters into ORC and Parquet readers\n+  to perform stripe or row-group pruning.\n+* Connector support for utilizing dynamic filters at the splits enumeration stage.\n+* Size of right (build) side of the join.\n+\n+You can take a closer look at the :doc:`EXPLAIN plan </sql/explain>` of the query\n+to analyze if the planner is adding dynamic filters to a specific query's plan.\n+For example, the explain plan for the above query can be obtained by running::\n+\n+    EXPLAIN\n+    SELECT COUNT(*) FROM\n+    store_sales JOIN date_dim ON store_sales.ss_sold_date_sk = date_dim.d_date_sk\n+    WHERE d_following_holiday='Y' AND d_year = 2000;\n+\n+The explain plan for this query shows ``dynamicFilterAssignments`` in the\n+``InnerJoin`` node with dynamic filter ``df_370`` collected from build symbol ``d_date_sk``.\n+You can also see the ``dynamicFilter`` predicate as part of the Hive ``ScanFilterProject``\n+operator where ``df_370`` is associated with probe symbol ``ss_sold_date_sk``.\n+This shows you that the planner is successful in pushing dynamic filters\n+down to the connector in the query plan.\n+\n+.. code-block:: none\n+\n+    Fragment 0 [SINGLE]\n+        Output layout: [count]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Output[_col0]\n+        \u2502   Layout: [count:bigint]\n+        \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+        \u2502   _col0 := count\n+        \u2514\u2500 Aggregate(FINAL)\n+           \u2502   Layout: [count:bigint]\n+           \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+           \u2502   count := count(\"\"count_3\"\")\n+           \u2514\u2500 LocalExchange[SINGLE] ()\n+              \u2502   Layout: [count_3:bigint]\n+              \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n+              \u2514\u2500 RemoteSource[1]\n+                     Layout: [count_3:bigint]\n+\n+    Fragment 1 [SOURCE]\n+        Output layout: [count_3]\n+        Output partitioning: SINGLE []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        Aggregate(PARTIAL)\n+        \u2502   Layout: [count_3:bigint]\n+        \u2502   count_3 := count(*)\n+        \u2514\u2500 InnerJoin[(\"\"ss_sold_date_sk\"\" = \"\"d_date_sk\"\")][$hashvalue, $hashvalue_4]\n+           \u2502   Layout: []\n+           \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502   Distribution: REPLICATED\n+           \u2502   dynamicFilterAssignments = {d_date_sk -> df_370}\n+           \u251c\u2500 ScanFilterProject[table = hive:default:store_sales, grouped = false, filterPredicate = true, dynamicFilter = {df_370 -> \"\"ss_sold_date_sk\"\"}]\n+           \u2502      Layout: [ss_sold_date_sk:bigint, $hashvalue:bigint]\n+           \u2502      Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+           \u2502      $hashvalue := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"ss_sold_date_sk\"\"), 0))\n+           \u2502      ss_sold_date_sk := ss_sold_date_sk:bigint:REGULAR\n+           \u2514\u2500 LocalExchange[HASH][$hashvalue_4] (\"\"d_date_sk\"\")\n+              \u2502   Layout: [d_date_sk:bigint, $hashvalue_4:bigint]\n+              \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+              \u2514\u2500 RemoteSource[2]\n+                     Layout: [d_date_sk:bigint, $hashvalue_5:bigint]\n+\n+    Fragment 2 [SOURCE]\n+        Output layout: [d_date_sk, $hashvalue_6]\n+        Output partitioning: BROADCAST []\n+        Stage Execution Strategy: UNGROUPED_EXECUTION\n+        ScanFilterProject[table = hive:default:date_dim, grouped = false, filterPredicate = ((\"\"d_following_holiday\"\" = CAST('Y' AS char(1))) AND (\"\"d_year\"\" = 2000))]\n+            Layout: [d_date_sk:bigint, $hashvalue_6:bigint]\n+            Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}/{rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}\n+            $hashvalue_6 := combine_hash(bigint '0', COALESCE(\"\"$operator$hash_code\"\"(\"\"d_date_sk\"\"), 0))\n+            d_following_holiday := d_following_holiday:char(1):REGULAR\n+            d_date_sk := d_date_sk:bigint:REGULAR\n+            d_year := d_year:int:REGULAR\n+\n+\n+During execution of a query with dynamic filters, Presto populates statistics\n+about dynamic filters in the QueryInfo JSON available through the\n+:doc:`/admin/web-interface`.\n+In the ``queryStats`` section, statistics about dynamic filters collected\n+by the coordinator can be found in the ``dynamicFiltersStats`` structure.\n+\n+.. code-block:: none\n+\n+    \"dynamicFiltersStats\" : {\n+          \"dynamicFilterDomainStats\" : [ {\n+            \"dynamicFilterId\" : \"df_370\",\n+            \"simplifiedDomain\" : \"[ [[2451546, 2451905]] ]\",\n+            \"rangeCount\" : 3,\n+            \"discreteValuesCount\" : 0\n+          } ],\n+          \"lazyDynamicFilters\" : 1,\n+          \"replicatedDynamicFilters\" : 1,\n+          \"totalDynamicFilters\" : 1,\n+          \"dynamicFiltersCompleted\" : 1\n+    }\n+\n+Push down of dynamic filters into a table scan on the worker nodes can be\n+verified by looking at the operator statistics for that table scan.\n+``dynamicFilterSplitsProcessed`` records the number of splits\n+processed after a dynamic filter is pushed down to the table scan.\n+\n+.. code-block:: none\n+\n+    \"operatorType\" : \"ScanFilterAndProjectOperator\",\n+    \"totalDrivers\" : 1,\n+    \"addInputCalls\" : 762,\n+    \"addInputWall\" : \"0.00ns\",\n+    \"addInputCpu\" : \"0.00ns\",\n+    \"physicalInputDataSize\" : \"0B\",\n+    \"physicalInputPositions\" : 28800991,\n+    \"inputPositions\" : 28800991,\n+    \"dynamicFilterSplitsProcessed\" : 1,\n+\n+Dynamic filter collection thresholds\n+------------------------------------\n+\n+In order for dynamic filtering to work, the smaller dimension table\n+needs to be chosen as a join\u2019s build side. The cost-based optimizer can automatically\n+do this using table statistics provided by connectors. Therefore, it is recommended\n+to keep :doc:`table statistics </optimizer/statistics>` up to date and rely on the\n+CBO to correctly choose the smaller table on the build side of join.\n+\n+Collection of values of the join key columns from the build side for\n+dynamic filtering may incur additional CPU overhead during query execution.\n+Therefore, to limit the overhead of collecting dynamic filters\n+to the cases where the join operator is likely to be selective,\n+Presto defines thresholds on size of dynamic filters collected from build side tasks.\n+Collection of dynamic filters for joins with large build sides can be enabled\n+using the ``enable-large-dynamic-filters`` configuration property or the\n+``enable_large_dynamic_filters`` session property.\n+\n+When large dynamic filters are enabled, limits on size of dynamic filters can be\n+configured for each join distribution type using the configuration properties\n+``dynamic-filtering.large-broadcast.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-broadcast.max-size-per-driver`` and\n+``dynamic-filtering.large-broadcast.range-row-limit-per-driver`` and their\n+equivalent for partitioned join distribution type.\n+\n+Similarly, limits for dynamic filters when ``enable-large-dynamic-filters``\n+is not enabled can be configured using configuration properties like\n+``dynamic-filtering.large-partitioned.max-distinct-values-per-driver``,\n+``dynamic-filtering.large-partitioned.max-size-per-driver`` and\n+``dynamic-filtering.large-partitioned.range-row-limit-per-driver`` and their\n+equivalent for broadcast join distribution type.\n+\n+The properties based on ``max-distinct-values-per-driver`` and ``max-size-per-driver``\n+define thresholds for the size up to which dynamic filters are collected in a\n+distinct values data structure. When the build side exceeds these thresholds,\n+Presto switches to collecting min and max values per column to reduce overhead.\n+This min-max filter has much lower granularity than the distinct values filter.\n+However, it may still be beneficial in filtering some data from the probe side,\n+especially when a range of values is selected from the build side of join.\n+The limits for min-max filters collection are defined by the properties\n+based on ``range-row-limit-per-driver``.\n+\n+Data layout considerations\n+--------------------------\n+\n+Dynamic filtering is most effective when a connector stores data in a layout that\n+can be leveraged for efficient filtering at runtime. For the Hive connector,\n+dynamic filter predicates are pushed into the ORC and Parquet readers on the\n+worker nodes to perform stripe or row-group pruning and save on disk I/O.\n+Sorting the data within ORC or Parquet files by the columns used in join criteria\n+significantly improves the effectiveness of stripe or row-group pruning.\n+This is because grouping similar data within the same stripe or row-group\n+greatly improves the selectivity of the min/max indexes maintained at\n+stripe or row-group level.\n+\n+Partitioned Hive tables stored in any data format benefit from the\n+dynamic partition pruning optimization for broadcast as well as partitioned joins.\n+\n+Limitations\n+-----------\n+\n+* Dynamic filtering is currently implemented only for :doc:`/connector/hive` and :doc:`/connector/memory` connectors.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0MjkzOQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499042939", "bodyText": "I have added mention in memory connector docs and expanded the section in hive connector docs.\nBut I still think it is useful to mention the supported connectors here for easy reference.", "author": "raunaqmorarka", "createdAt": "2020-10-02T20:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNzkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA3MTM0OQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499071349", "bodyText": "great", "author": "mosabua", "createdAt": "2020-10-02T22:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxNzkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxODAwNg==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499018006", "bodyText": "for the collection", "author": "mosabua", "createdAt": "2020-10-02T19:45:13Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -526,6 +526,19 @@ You can also drop statistics for selected partitions only::\n \n     CALL system.drop_stats(schema_name, table_name, ARRAY[ARRAY['p2_value1', 'p2_value2']])\n \n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxODE3OA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499018178", "bodyText": "to reduce the amount", "author": "mosabua", "createdAt": "2020-10-02T19:45:40Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -526,6 +526,19 @@ You can also drop statistics for selected partitions only::\n \n     CALL system.drop_stats(schema_name, table_name, ARRAY[ARRAY['p2_value1', 'p2_value2']])\n \n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of\n+:doc:`dynamic filters </admin/dynamic-filtering>` before starting a table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query and CPU time, if dynamic filtering is able to reduce amount of scanned data.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxOTI0MQ==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499019241", "bodyText": "remove the () and have the content be part of the sentence directly.", "author": "mosabua", "createdAt": "2020-10-02T19:48:09Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -526,6 +526,19 @@ You can also drop statistics for selected partitions only::\n \n     CALL system.drop_stats(schema_name, table_name, ARRAY[ARRAY['p2_value1', 'p2_value2']])\n \n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of\n+:doc:`dynamic filters </admin/dynamic-filtering>` before starting a table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query and CPU time, if dynamic filtering is able to reduce amount of scanned data.\n+\n+For the Hive connector, a table scan can be delayed (for a configured amount of time)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxOTQ2NA==", "url": "https://github.com/trinodb/trino/pull/5348#discussion_r499019464", "bodyText": "in the catalog file or the catalog session property ..", "author": "mosabua", "createdAt": "2020-10-02T19:48:40Z", "path": "presto-docs/src/main/sphinx/connector/hive.rst", "diffHunk": "@@ -526,6 +526,19 @@ You can also drop statistics for selected partitions only::\n \n     CALL system.drop_stats(schema_name, table_name, ARRAY[ARRAY['p2_value1', 'p2_value2']])\n \n+Delaying execution for dynamic filters\n+---------------------------------------\n+\n+It can often be beneficial to wait for collection of\n+:doc:`dynamic filters </admin/dynamic-filtering>` before starting a table scan.\n+This extra wait time can potentially result in significant overall savings\n+in query and CPU time, if dynamic filtering is able to reduce amount of scanned data.\n+\n+For the Hive connector, a table scan can be delayed (for a configured amount of time)\n+until the collection of dynamic filters by using the configuration property\n+``hive.dynamic-filtering-probe-blocking-timeout`` or the session property", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "6e2f35967125a8d21e3c6e389545bb69588e597a", "url": "https://github.com/trinodb/trino/commit/6e2f35967125a8d21e3c6e389545bb69588e597a", "message": "Add dynamic filtering documentation", "committedDate": "2020-10-02T20:54:09Z", "type": "commit"}, {"oid": "6e2f35967125a8d21e3c6e389545bb69588e597a", "url": "https://github.com/trinodb/trino/commit/6e2f35967125a8d21e3c6e389545bb69588e597a", "message": "Add dynamic filtering documentation", "committedDate": "2020-10-02T20:54:09Z", "type": "forcePushed"}]}