{"pr_number": 5756, "pr_title": "Push DistinctLimit into TableScan", "pr_createdAt": "2020-10-30T16:14:19Z", "pr_url": "https://github.com/trinodb/trino/pull/5756", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4MjM1Nw==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r515882357", "bodyText": "Maybe PushDistinctLimitAsAggregationIntoTableScan", "author": "losipiuk", "createdAt": "2020-11-02T10:39:07Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isAllowPushdownIntoConnectors;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.PushAggregationIntoTableScan.pushAggregationIntoTableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.distinctLimit;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushDistinctLimitIntoTableScan", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIyMjkwNQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517222905", "bodyText": "No, i don't think so.", "author": "findepi", "createdAt": "2020-11-04T09:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4MjM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzNjQwNA==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r515936404", "bodyText": "rnn?", "author": "kokosing", "createdAt": "2020-11-02T12:25:36Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isAllowPushdownIntoConnectors;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.PushAggregationIntoTableScan.pushAggregationIntoTableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.distinctLimit;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushDistinctLimitIntoTableScan\n+        implements Rule<DistinctLimitNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<DistinctLimitNode> PATTERN =\n+            distinctLimit()\n+                    .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushDistinctLimitIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODE1MA==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r515938150", "bodyText": "I see:\n        assertThat(query(\"SELECT DISTINCT regionkey FROM nation LIMIT 5\")).isFullyPushedDown();\n\nThat means that LimitNode is pushed down in separate rule application. It is not obvious, please add a comment.", "author": "kokosing", "createdAt": "2020-11-02T12:29:32Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isAllowPushdownIntoConnectors;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.PushAggregationIntoTableScan.pushAggregationIntoTableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.distinctLimit;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushDistinctLimitIntoTableScan\n+        implements Rule<DistinctLimitNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<DistinctLimitNode> PATTERN =\n+            distinctLimit()\n+                    .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushDistinctLimitIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<DistinctLimitNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Session session)\n+    {\n+        return isAllowPushdownIntoConnectors(session);\n+    }\n+\n+    @Override\n+    public Result apply(DistinctLimitNode node, Captures captures, Context context)\n+    {\n+        Optional<PlanNode> result = pushAggregationIntoTableScan(\n+                metadata,\n+                context,\n+                captures.get(TABLE_SCAN),\n+                ImmutableMap.of(),\n+                node.getDistinctSymbols());\n+\n+        if (result.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        return Result.ofPlanNode(\n+                new LimitNode(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4ODQwMA==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r516988400", "bodyText": "We do no seem to have practice of adorning a rule with comments what other rules may or may not do with the plan output from the rule?", "author": "findepi", "createdAt": "2020-11-03T22:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODE1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwMDA4MQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517200081", "bodyText": "I see, but this is quite unintuitive that rule says that it is pushing distinct limit, while actually it pushes only distinct.", "author": "kokosing", "createdAt": "2020-11-04T09:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODE1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIyNDI0Nw==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517224247", "bodyText": "it's called after the plan node which it is attempting to push. Naming it differently would be even more unintuitive.\ni will add\n// The LimitNode retained here may be later pushed into TableScan as well by a different rule", "author": "findepi", "createdAt": "2020-11-04T09:57:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODE1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMDg2MQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517310861", "bodyText": "Thanks", "author": "kokosing", "createdAt": "2020-11-04T12:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODI4NQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r515938285", "bodyText": "Rule unit tests?", "author": "kokosing", "createdAt": "2020-11-02T12:29:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.DistinctLimitNode;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+\n+import java.util.Optional;\n+\n+import static io.prestosql.SystemSessionProperties.isAllowPushdownIntoConnectors;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.PushAggregationIntoTableScan.pushAggregationIntoTableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.distinctLimit;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushDistinctLimitIntoTableScan", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIyNjc1MQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517226751", "bodyText": "Table scan pushdowns are hard to test \"normally\".\nI wanted to copy tests from PushAggregationIntoTableScan (#3697) but can't find them (#5812). cc @martint\nLooking into it.", "author": "findepi", "createdAt": "2020-11-04T10:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODI4NQ=="}], "type": "inlineReview"}, {"oid": "937c4955b5de95f92dc0d4cbce17b3675bd80b56", "url": "https://github.com/trinodb/trino/commit/937c4955b5de95f92dc0d4cbce17b3675bd80b56", "message": "Replace @Test(expectedExceptions) with assertThatThrownBy", "committedDate": "2020-11-04T12:17:30Z", "type": "commit"}, {"oid": "30229d0f197bc93e3df80abc8c5aef574cf3981c", "url": "https://github.com/trinodb/trino/commit/30229d0f197bc93e3df80abc8c5aef574cf3981c", "message": "Move helper rule implementation to the test method\n\nThis way the test method is self-contained.", "committedDate": "2020-11-04T12:17:30Z", "type": "commit"}, {"oid": "ecd1a9805e97f2310897c0f415fdf91edc208861", "url": "https://github.com/trinodb/trino/commit/ecd1a9805e97f2310897c0f415fdf91edc208861", "message": "Add more RuleTester tests", "committedDate": "2020-11-04T12:17:30Z", "type": "commit"}, {"oid": "50e3fcc51c76064fe5c3f94167483609535ebb2c", "url": "https://github.com/trinodb/trino/commit/50e3fcc51c76064fe5c3f94167483609535ebb2c", "message": "Fix stats collection for plan printing in RuleAssert\n\nPreviously the stats collection would be bound to the session outside of\ntransaction, leading to \"Not in a transaction\" exceptions being logged.\n\n(The stats collection failures are suppressed by default.)", "committedDate": "2020-11-04T12:17:30Z", "type": "commit"}, {"oid": "5c776eb8da075e9c330880134ae9664da3c26fdd", "url": "https://github.com/trinodb/trino/commit/5c776eb8da075e9c330880134ae9664da3c26fdd", "message": "Improve code style", "committedDate": "2020-11-04T12:17:30Z", "type": "commit"}, {"oid": "583f01fe112706bba13c2e576a19067ab8b28a60", "url": "https://github.com/trinodb/trino/commit/583f01fe112706bba13c2e576a19067ab8b28a60", "message": "Extract method with PushAggregationIntoTableScan logic", "committedDate": "2020-11-04T12:17:30Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMwOTYxNQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517309615", "bodyText": "This is not much readable, please extract local variable, just before aggregationPushdownResult", "author": "kokosing", "createdAt": "2020-11-04T12:30:52Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -139,14 +135,18 @@ public Result apply(AggregationNode node, Captures captures, Context context)\n                 .collect(toImmutableList());\n \n         List<ColumnHandle> groupByColumns = groupingKeys.stream()\n-                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .map(tableScan.getAssignments()::get)\n                 .collect(toImmutableList());\n \n         Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n                 context.getSession(),\n                 tableScan.getTable(),\n                 aggregateFunctions,\n-                assignments,\n+                aggregateFunctions.isEmpty()\n+                        ? Map.of()\n+                        : tableScan.getAssignments()\n+                        .entrySet().stream()\n+                        .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue)),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1OTI0OA==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517359248", "bodyText": "I had this so initially, but the readability was similarly affected with variable or without.\nHowever, having a variable is flaky, if the content is conditional -- note that previously we used those assignments instead of tableScan.getAssignments and now it would not be correct.", "author": "findepi", "createdAt": "2020-11-04T13:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMwOTYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMDU3NQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517310575", "bodyText": "Abstain from passing assignments when no aggregate functions\n\nWhat is the benefit of that?\nI see a cost, of new corner case.\nMaybe you should pass Optional then? To make it explicit that it may or may not be given.", "author": "kokosing", "createdAt": "2020-11-04T12:32:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -121,10 +121,6 @@ public Result apply(AggregationNode node, Captures captures, Context context)\n             Map<Symbol, AggregationNode.Aggregation> aggregations,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NjQwOA==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517356408", "bodyText": "this is not \"CPU saving\", but rather making the call parameters more meaningful from connector's perspective\nassignments are useless, so why pass them?", "author": "findepi", "createdAt": "2020-11-04T13:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMDU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxMzI2OQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517413269", "bodyText": "I kinda agree with @kokosing here. I do not see a straight benefit of handling special case of empty aggregateFunctions here.\nMaybe we should just always filter the assignments map, so we only pass to applyAggregation those which are needed by any of the aggregations in list?", "author": "losipiuk", "createdAt": "2020-11-04T15:09:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMDU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0MjEzMw==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517442133", "bodyText": "I will drop the commit.", "author": "findepi", "createdAt": "2020-11-04T15:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMDU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMTAyOQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517311029", "bodyText": "\u2764\ufe0f", "author": "kokosing", "createdAt": "2020-11-04T12:33:33Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorFactory.ApplyAggregation;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.connector.MockConnectorTransactionHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.limit;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true) // shared mutable state\n+public class TestPushDistinctLimitIntoTableScan", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMzM3MQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517313371", "bodyText": "It is single threaded, no need to have atomic here", "author": "kokosing", "createdAt": "2020-11-04T12:37:54Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorFactory.ApplyAggregation;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.connector.MockConnectorTransactionHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.limit;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true) // shared mutable state\n+public class TestPushDistinctLimitIntoTableScan\n+        extends BaseRuleTest\n+{\n+    private static final CatalogName TEST_CATALOG = new CatalogName(\"test_push_dl_catalog\");\n+\n+    private PushDistinctLimitIntoTableScan rule;\n+\n+    private AtomicReference<ApplyAggregation> testApplyAggregation = new AtomicReference<>();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMzkxNQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517313915", "bodyText": "require non null applyAggregation? To make sure it is always set in test.", "author": "kokosing", "createdAt": "2020-11-04T12:39:02Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorFactory.ApplyAggregation;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.connector.MockConnectorTransactionHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.limit;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true) // shared mutable state\n+public class TestPushDistinctLimitIntoTableScan\n+        extends BaseRuleTest\n+{\n+    private static final CatalogName TEST_CATALOG = new CatalogName(\"test_push_dl_catalog\");\n+\n+    private PushDistinctLimitIntoTableScan rule;\n+\n+    private AtomicReference<ApplyAggregation> testApplyAggregation = new AtomicReference<>();\n+\n+    private TableHandle tableHandle;\n+\n+    @Override\n+    protected Optional<LocalQueryRunner> createLocalQueryRunner()\n+    {\n+        Session defaultSession = TestingSession.testSessionBuilder()\n+                .setCatalog(TEST_CATALOG.getCatalogName())\n+                .setSchema(\"tiny\")\n+                .build();\n+\n+        LocalQueryRunner queryRunner = LocalQueryRunner.create(defaultSession);\n+\n+        queryRunner.createCatalog(\n+                TEST_CATALOG.getCatalogName(),\n+                MockConnectorFactory.builder()\n+                        .withApplyAggregation(\n+                                (session, handle, aggregates, assignments, groupingSets) -> {\n+                                    ApplyAggregation applyAggregation = testApplyAggregation.get();\n+                                    if (applyAggregation != null) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1ODE0NQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517358145", "bodyText": "The test code ensures -- and must ensure that -- thru the way how assertions are written.", "author": "findepi", "createdAt": "2020-11-04T13:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxMzkxNQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517419615", "bodyText": "nit: doesNotFire is kinda misleading here. As rule is fired. Yet it returns empty() so it does nothing.", "author": "losipiuk", "createdAt": "2020-11-04T15:17:47Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushDistinctLimitIntoTableScan.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.connector.CatalogName;\n+import io.prestosql.connector.MockConnectorColumnHandle;\n+import io.prestosql.connector.MockConnectorFactory;\n+import io.prestosql.connector.MockConnectorFactory.ApplyAggregation;\n+import io.prestosql.connector.MockConnectorTableHandle;\n+import io.prestosql.connector.MockConnectorTransactionHandle;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.rule.test.BaseRuleTest;\n+import io.prestosql.testing.LocalQueryRunner;\n+import io.prestosql.testing.TestingSession;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.limit;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.project;\n+import static io.prestosql.sql.planner.assertions.PlanMatchPattern.tableScan;\n+import static java.util.stream.Collectors.toUnmodifiableList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@Test(singleThreaded = true) // shared mutable state\n+public class TestPushDistinctLimitIntoTableScan\n+        extends BaseRuleTest\n+{\n+    private static final CatalogName TEST_CATALOG = new CatalogName(\"test_push_dl_catalog\");\n+\n+    private PushDistinctLimitIntoTableScan rule;\n+    private TableHandle tableHandle;\n+\n+    private ApplyAggregation testApplyAggregation;\n+\n+    @Override\n+    protected Optional<LocalQueryRunner> createLocalQueryRunner()\n+    {\n+        Session defaultSession = TestingSession.testSessionBuilder()\n+                .setCatalog(TEST_CATALOG.getCatalogName())\n+                .setSchema(\"tiny\")\n+                .build();\n+\n+        LocalQueryRunner queryRunner = LocalQueryRunner.create(defaultSession);\n+\n+        queryRunner.createCatalog(\n+                TEST_CATALOG.getCatalogName(),\n+                MockConnectorFactory.builder()\n+                        .withApplyAggregation(\n+                                (session, handle, aggregates, assignments, groupingSets) -> {\n+                                    if (testApplyAggregation != null) {\n+                                        return testApplyAggregation.apply(session, handle, aggregates, assignments, groupingSets);\n+                                    }\n+                                    return Optional.empty();\n+                                })\n+                        .build(),\n+                Map.of());\n+\n+        return Optional.of(queryRunner);\n+    }\n+\n+    @BeforeClass\n+    public void init()\n+    {\n+        rule = new PushDistinctLimitIntoTableScan(tester().getMetadata());\n+\n+        tableHandle = new TableHandle(\n+                TEST_CATALOG,\n+                new MockConnectorTableHandle(new SchemaTableName(\"mock_schema\", \"mock_nation\")),\n+                MockConnectorTransactionHandle.INSTANCE,\n+                Optional.empty());\n+    }\n+\n+    @BeforeMethod\n+    public void reset()\n+    {\n+        testApplyAggregation = null;\n+    }\n+\n+    @Test\n+    public void testDoesNotFireIfNoTableScan()\n+    {\n+        tester().assertThat(rule)\n+                .on(p -> p.values(p.symbol(\"a\", BIGINT)))\n+                .doesNotFire();\n+    }\n+\n+    @Test\n+    public void testNoEffect()\n+    {\n+        AtomicInteger applyCallCounter = new AtomicInteger();\n+        testApplyAggregation = (session, handle, aggregates, assignments, groupingSets) -> {\n+            applyCallCounter.incrementAndGet();\n+            return Optional.empty();\n+        };\n+\n+        tester().assertThat(rule)\n+                .on(p -> {\n+                    Symbol regionkey = p.symbol(\"regionkey\");\n+                    return p.distinctLimit(10, List.of(regionkey),\n+                            p.tableScan(\n+                                    tableHandle,\n+                                    ImmutableList.of(regionkey),\n+                                    ImmutableMap.of(regionkey, new MockConnectorColumnHandle(\"regionkey\", BIGINT))));\n+                })\n+                .doesNotFire();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0Mjg2OQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517442869", "bodyText": "pre existing,", "author": "findepi", "createdAt": "2020-11-04T15:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU3MzkxMg==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517573912", "bodyText": "empty() so it does nothing.\n\nA rule returning empty() means \"it didn't fire\". Firing means that the rule resulted in some transformation of the plan.", "author": "martint", "createdAt": "2020-11-04T19:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4NTc5OA==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517585798", "bodyText": "Before we had patterns -- the meaning was obvious.\nWith patterns -- the naming is no longer obvious, and i see @losipiuk 's point.\nIf you remember that pattern is an optional thing and rule may or may not use it (kind of), it becomes clearer -- but there is no way to get this thinking from the code.\nI am OK with changing the method name if we can propose something better, but that would fall out of scope of this PR anyway.", "author": "findepi", "createdAt": "2020-11-04T19:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMDkyOA==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517610928", "bodyText": "Patterns or no patterns, it's the same. Some things cannot be represented by patterns and need to matched manually. The pattern is just a convenience mechanism, but it doesn't mean that if the pattern matches the rule \"fires\".\nI thing you're confusing \"fires\" with \"is invoked\".", "author": "martint", "createdAt": "2020-11-04T20:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMzU3OQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517613579", "bodyText": "In JMX stats for optimizer rules we use \"hits\" and \"misses\" counter. Fire does not mean hit.", "author": "kokosing", "createdAt": "2020-11-04T20:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY0OTc0MQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517649741", "bodyText": "Yes, fire means hit. Any time a rule returns non-empty, we tick the \"hits\" counter. Otherwise, we tick the \"misses\" counter. The \"invocations\" counter gets ticked in either case.", "author": "martint", "createdAt": "2020-11-04T21:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY1MTY0NQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r517651645", "bodyText": "I thing you're confusing \"fires\" with \"is invoked\".\n\ni am under impression in some contexts (not here), these are used interchangeably.\nPerhaps replacing  \"fires\" with \"applies\" would provide for more obvious terminology.", "author": "findepi", "createdAt": "2020-11-04T21:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkwMzU0Mw==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r519903543", "bodyText": "i am under impression in some contexts (not here), these are used interchangeably.\n\nCan you give an example? I'm not aware of any such cases.", "author": "martint", "createdAt": "2020-11-09T15:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyMDAxMQ==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r519920011", "bodyText": "I meant spoken \"dev english\", not the Presto code base.", "author": "findepi", "createdAt": "2020-11-09T15:55:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDg3MA==", "url": "https://github.com/trinodb/trino/pull/5756#discussion_r520094870", "bodyText": "Fire does not mean hit.\n\n\n\nYes, fire means hit\n\nSurely, I am not an english speaker. But if a bullet is fired (launched), it does mean it will hit the target. Hence \"fire\" is closer for me in the meaning to \"invocations\". But I get used to it the current Presto glossary.", "author": "kokosing", "createdAt": "2020-11-09T20:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTYxNQ=="}], "type": "inlineReview"}, {"oid": "d20cdc98caa9772ea400cc9bd6eacaadf96cc449", "url": "https://github.com/trinodb/trino/commit/d20cdc98caa9772ea400cc9bd6eacaadf96cc449", "message": "Push DistinctLimit into TableScan", "committedDate": "2020-11-04T15:50:33Z", "type": "commit"}, {"oid": "d20cdc98caa9772ea400cc9bd6eacaadf96cc449", "url": "https://github.com/trinodb/trino/commit/d20cdc98caa9772ea400cc9bd6eacaadf96cc449", "message": "Push DistinctLimit into TableScan", "committedDate": "2020-11-04T15:50:33Z", "type": "forcePushed"}]}