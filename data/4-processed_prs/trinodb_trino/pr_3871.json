{"pr_number": 3871, "pr_title": "Implement collection of min/max values in DynamicFilterSourceOperator", "pr_createdAt": "2020-05-28T10:00:34Z", "pr_url": "https://github.com/trinodb/trino/pull/3871", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1OTcwMw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r433759703", "bodyText": "nit: allocate only if minMaxValues is true?", "author": "rzeyde-varada", "createdAt": "2020-06-02T09:56:37Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -164,6 +179,9 @@ private DynamicFilterSourceOperator(\n                     String.format(\"DynamicFilterSourceOperator_%s_%d\", planNodeId, channelIndex),\n                     Optional.empty() /* maxBlockMemory */);\n         }\n+\n+        this.minValues = new Object[channels.size()];\n+        this.maxValues = new Object[channels.size()];", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MDgzNw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r433760837", "bodyText": "nit: you can pre-compute channels.get(channelIndex).type. isOrderable() for all channels in the constructor.", "author": "rzeyde-varada", "createdAt": "2020-06-02T09:58:35Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -184,7 +202,17 @@ public void addInput(Page page)\n         verify(!finished, \"DynamicFilterSourceOperator: addInput() may not be called after finish()\");\n         current = page;\n         if (valueSets == null) {\n-            return;  // the predicate became too large.\n+            // the predicate became too large, record only min/max values for each channel\n+            if (minMaxValues) {\n+                for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n+                    Block block = page.getBlock(channels.get(channelIndex).index);\n+                    Type type = channels.get(channelIndex).type;\n+                    if (type.isOrderable()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MjAyOA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r433762028", "bodyText": "The code seems quite similar to the one at addInput() method. Can it be refactored?", "author": "rzeyde-varada", "createdAt": "2020-06-02T10:00:43Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -208,13 +236,61 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large, convert to min/max per column for orderable types\n+        if (minMaxValues) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5NDYxNA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r433794614", "bodyText": "I guess that this loop can benefit from JIT compilation, especially for large blocks.\nIs it possible to see whether such optimization does take place during the micro-benchmarks?", "author": "rzeyde-varada", "createdAt": "2020-06-02T11:05:44Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -208,13 +236,61 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large, convert to min/max per column for orderable types\n+        if (minMaxValues) {\n+            for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n+                Type type = channels.get(channelIndex).type;\n+                if (type.isOrderable()) {\n+                    Block block = blockBuilders[channelIndex].build();\n+                    updateMinMaxValues(block, type, channelIndex);\n+                }\n+            }\n+        }\n         // Drop references to collected values.\n         valueSets = null;\n         blockBuilders = null;\n     }\n \n+    private void updateMinMaxValues(Block block, Type type, int channelIndex)\n+    {\n+        int minValuePosition = -1;\n+        int maxValuePosition = -1;\n+\n+        for (int position = 0; position < block.getPositionCount(); ++position) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5NDExMw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486994113", "bodyText": "You could potentially:\n\nmake updateMinMaxValues accept type parameter, e.g:\n\nprivate void updateMinMaxValues(Type type, Block block, int channelIndex)\n\nand then dispatch to that method:\nprivate void updateMinMaxValues(Block block, int channelIndex) {\n  Type type = channels.get(channelIndex).type;\n  if (type instanceof BigintType) {\n    updateMinMaxValues(type, block, channelIndex);\n  } else if (type instaneof IntType) {\n    updateMinMaxValues(type, block, channelIndex);\n  }\n}\n\nfor selected types.\nWe would need to benchmark if JIT actually does indeed inline separate branches of code (resulting method could be too large)\nAlternatively, we could obtain MethodHandle for updateMinMaxValues(Type type, Block block, int channelIndex) via https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandles.html#insertArguments-java.lang.invoke.MethodHandle-int-java.lang.Object...- with partially applied type argument.\nIn any case, this could be improvement after this PR and requires extending of benchmarks", "author": "sopel39", "createdAt": "2020-09-11T11:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5NDYxNA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1MTIwMQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486451201", "bodyText": "please change the code to:\nif (block.isNull(position)) {\n  continue;\n}", "author": "sopel39", "createdAt": "2020-09-10T15:50:54Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +241,64 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxValues) {\n+            // convert to min/max per column for orderable types\n+            for (Integer channelIndex : orderableChannels) {\n+                Block block = blockBuilders[channelIndex].build();\n+                updateMinMaxValues(block, channelIndex);\n+            }\n+        }\n+        else {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+        }\n         // Drop references to collected values.\n         valueSets = null;\n         blockBuilders = null;\n     }\n \n+    private void updateMinMaxValues(Block block, int channelIndex)\n+    {\n+        Type type = channels.get(channelIndex).type;\n+        int minValuePosition = -1;\n+        int maxValuePosition = -1;\n+\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            if (!block.isNull(position)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5OTE3OQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486599179", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-10T19:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1MTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1MjIxNQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486452215", "bodyText": "let's just keep it as Block[] that contain singletons", "author": "sopel39", "createdAt": "2020-09-10T15:52:21Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -129,34 +137,46 @@ public OperatorFactory duplicate()\n     private final Consumer<TupleDomain<DynamicFilterId>> dynamicPredicateConsumer;\n     private final int maxFilterPositionsCount;\n     private final long maxFilterSizeInBytes;\n+    private final boolean minMaxValues;\n \n     private final List<Channel> channels;\n+    private final List<Integer> orderableChannels;\n \n     // May be dropped if the predicate becomes too large.\n     @Nullable\n     private BlockBuilder[] blockBuilders;\n     @Nullable\n     private TypedSet[] valueSets;\n+    @Nullable\n+    private Object[] minValues;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg0OTc0NQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486849745", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-11T08:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1MjIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1NjQ4OA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486456488", "bodyText": "you can use else if here", "author": "sopel39", "createdAt": "2020-09-10T15:58:31Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +241,64 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxValues) {\n+            // convert to min/max per column for orderable types\n+            for (Integer channelIndex : orderableChannels) {\n+                Block block = blockBuilders[channelIndex].build();\n+                updateMinMaxValues(block, channelIndex);\n+            }\n+        }\n+        else {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+        }\n         // Drop references to collected values.\n         valueSets = null;\n         blockBuilders = null;\n     }\n \n+    private void updateMinMaxValues(Block block, int channelIndex)\n+    {\n+        Type type = channels.get(channelIndex).type;\n+        int minValuePosition = -1;\n+        int maxValuePosition = -1;\n+\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            if (!block.isNull(position)) {\n+                if (minValuePosition == -1) {\n+                    // First non-null value\n+                    minValuePosition = position;\n+                    maxValuePosition = position;\n+                }\n+                if (type.compareTo(block, position, block, minValuePosition) < 0) {\n+                    minValuePosition = position;\n+                }\n+                if (type.compareTo(block, position, block, maxValuePosition) > 0) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5OTMwMQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486599301", "bodyText": "changed", "author": "raunaqmorarka", "createdAt": "2020-09-10T19:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1NjQ4OA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMDk4NQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486620985", "bodyText": "@sopel39 This implementation can run into #4272\nTypeUtils#isFloatingPointNaN currently works on Object, so we would end up converting every position to an Object using readNativeValue if we try to add that check.\nI think we could either skip DOUBLE and REAL types from this optimization or we could look into adding boolean Block#isFloatingPointNaN(int position). WDYT ?", "author": "raunaqmorarka", "createdAt": "2020-09-10T20:41:18Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +239,67 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxValues) {\n+            // convert to min/max per column for orderable types\n+            for (Integer channelIndex : orderableChannels) {\n+                Block block = blockBuilders[channelIndex].build();\n+                updateMinMaxValues(block, channelIndex);\n+            }\n+        }\n+        else {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+        }\n         // Drop references to collected values.\n         valueSets = null;\n         blockBuilders = null;\n     }\n \n+    private void updateMinMaxValues(Block block, int channelIndex)\n+    {\n+        Type type = channels.get(channelIndex).type;\n+        int minValuePosition = -1;\n+        int maxValuePosition = -1;\n+\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            if (block.isNull(position)) {\n+                continue;\n+            }\n+            if (minValuePosition == -1) {\n+                // First non-null value\n+                minValuePosition = position;\n+                maxValuePosition = position;\n+            }\n+            else {\n+                if (type.compareTo(block, position, block, minValuePosition) < 0) {\n+                    minValuePosition = position;\n+                }\n+                else if (type.compareTo(block, position, block, maxValuePosition) > 0) {\n+                    maxValuePosition = position;\n+                }\n+            }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1MDc2Ng==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486850766", "bodyText": "For now I've skipped DOUBLE and REAL types", "author": "raunaqmorarka", "createdAt": "2020-09-11T08:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMDk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5NDkzMQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486994931", "bodyText": "It's not that simple as nested types (e.g row) could contain doubles too.\nLet's whitelist types for which min/max optimization works (e.g numeric types, timestamps, character strings,...)", "author": "sopel39", "createdAt": "2020-09-11T11:54:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMDk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4OTgyNA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487389824", "bodyText": "For nested types there is no failure in the query like in #4272\nWe are able to create TupleDomain out of an array of Double.NaN as isFloatingPointNaN does not look into nested types. So I think for nested types, this change probably doesn't make the situation any worse.", "author": "raunaqmorarka", "createdAt": "2020-09-12T09:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMDk4NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MjI4OA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486982288", "bodyText": "do we need to set it here? There is no corresponding test", "author": "sopel39", "createdAt": "2020-09-11T11:26:18Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -86,6 +87,7 @@ protected Session getSession()\n         return Session.builder(super.getSession())\n                 .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n                 .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .setSystemProperty(DYNAMIC_FILTERING_MIN_MAX_VALUES, \"true\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxNDIxNw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487014217", "bodyText": "This helps to test that the min/max optimization is not triggered for partitioned join in testJoinLargeBuildSideNoDynamicFiltering", "author": "raunaqmorarka", "createdAt": "2020-09-11T12:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MjI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MjQzMg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486982432", "bodyText": "mentioned it's for replicated joins only", "author": "sopel39", "createdAt": "2020-09-11T11:26:39Z", "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -548,6 +549,11 @@ public SystemSessionProperties(\n                         \"Experimental: maximum number of bytes to be collected for dynamic filtering per-driver\",\n                         featuresConfig.getDynamicFilteringMaxPerDriverSize(),\n                         false),\n+                booleanProperty(\n+                        DYNAMIC_FILTERING_MIN_MAX_VALUES,\n+                        \"Experimental: Collect min/max values for dynamic filtering when build side breaches max size or row count per driver thresholds\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4MDg1NQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487380855", "bodyText": "updated", "author": "raunaqmorarka", "createdAt": "2020-09-12T07:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MjQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MjgyMw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486982823", "bodyText": "rename to collectMinMaxValues", "author": "sopel39", "createdAt": "2020-09-11T11:27:28Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -129,34 +137,46 @@ public OperatorFactory duplicate()\n     private final Consumer<TupleDomain<DynamicFilterId>> dynamicPredicateConsumer;\n     private final int maxFilterPositionsCount;\n     private final long maxFilterSizeInBytes;\n+    private final boolean minMaxValues;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4MDg2MQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487380861", "bodyText": "renamed", "author": "raunaqmorarka", "createdAt": "2020-09-12T07:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MjgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NzY3NQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486987675", "bodyText": "nit: Ideally, this should make DOUBLE and REAL types not orderable, but that would break too much code.\nAlso, I don't think nested types work either given that they can contain double or real types inside. What would be the tuple domain if we hit NaN?\nI think we should whitelist selected types that work with this feature instead.", "author": "sopel39", "createdAt": "2020-09-11T11:38:19Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -129,34 +137,46 @@ public OperatorFactory duplicate()\n     private final Consumer<TupleDomain<DynamicFilterId>> dynamicPredicateConsumer;\n     private final int maxFilterPositionsCount;\n     private final long maxFilterSizeInBytes;\n+    private final boolean minMaxValues;\n \n     private final List<Channel> channels;\n+    private final List<Integer> minMaxChannels;\n \n     // May be dropped if the predicate becomes too large.\n     @Nullable\n     private BlockBuilder[] blockBuilders;\n     @Nullable\n     private TypedSet[] valueSets;\n \n+    private final Block[] minValues;\n+    private final Block[] maxValues;\n+\n     private DynamicFilterSourceOperator(\n             OperatorContext context,\n             Consumer<TupleDomain<DynamicFilterId>> dynamicPredicateConsumer,\n             List<Channel> channels,\n             PlanNodeId planNodeId,\n             int maxFilterPositionsCount,\n-            DataSize maxFilterSize)\n+            DataSize maxFilterSize,\n+            boolean minMaxValues)\n     {\n         this.context = requireNonNull(context, \"context is null\");\n         this.maxFilterPositionsCount = maxFilterPositionsCount;\n         this.maxFilterSizeInBytes = maxFilterSize.toBytes();\n+        this.minMaxValues = minMaxValues;\n \n         this.dynamicPredicateConsumer = requireNonNull(dynamicPredicateConsumer, \"dynamicPredicateConsumer is null\");\n         this.channels = requireNonNull(channels, \"channels is null\");\n \n         this.blockBuilders = new BlockBuilder[channels.size()];\n         this.valueSets = new TypedSet[channels.size()];\n+        ImmutableList.Builder<Integer> minMaxChannelsBuilder = ImmutableList.builder();\n         for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n             Type type = channels.get(channelIndex).type;\n+            // Skipping DOUBLE and REAL for minMaxValues to avoid dealing with NaN values\n+            if (type.isOrderable() && type != DOUBLE && type != REAL) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5NzE0MA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486997140", "bodyText": "check !minMaxChannels.isEmpty() instead here and in other places", "author": "sopel39", "createdAt": "2020-09-11T11:59:14Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -186,7 +210,14 @@ public void addInput(Page page)\n         verify(!finished, \"DynamicFilterSourceOperator: addInput() may not be called after finish()\");\n         current = page;\n         if (valueSets == null) {\n-            return;  // the predicate became too large.\n+            // the predicate became too large, record only min/max values for each channel\n+            if (minMaxValues) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4MDk4Nw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487380987", "bodyText": "changed to use collectMinMaxValues flag for populating minMaxChannels list, that avoids the need for this if check", "author": "raunaqmorarka", "createdAt": "2020-09-12T07:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5NzE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5NzU5MA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486997590", "bodyText": "call it just domain", "author": "sopel39", "createdAt": "2020-09-11T12:00:08Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -233,26 +318,47 @@ public void finish()\n             return;\n         }\n         finished = true;\n+        ImmutableMap.Builder<DynamicFilterId, Domain> domainsBuilder = new ImmutableMap.Builder<>();\n         if (valueSets == null) {\n-            return; // the predicate became too large.\n+            // the predicate became too large\n+            if (minMaxValues) {\n+                // create TupleDomain from min/max values\n+                for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n+                    Type type = channels.get(channelIndex).type;\n+                    Domain splitDomain;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5Nzk2Mw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486997963", "bodyText": "add a comment that collector was already notified with TupleDomain.all.", "author": "sopel39", "createdAt": "2020-09-11T12:00:57Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -233,26 +318,47 @@ public void finish()\n             return;\n         }\n         finished = true;\n+        ImmutableMap.Builder<DynamicFilterId, Domain> domainsBuilder = new ImmutableMap.Builder<>();\n         if (valueSets == null) {\n-            return; // the predicate became too large.\n+            // the predicate became too large\n+            if (minMaxValues) {\n+                // create TupleDomain from min/max values\n+                for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n+                    Type type = channels.get(channelIndex).type;\n+                    Domain splitDomain;\n+                    if (minValues[channelIndex] != null && maxValues[channelIndex] != null) {\n+                        Object min = readNativeValue(type, minValues[channelIndex], 0);\n+                        Object max = readNativeValue(type, maxValues[channelIndex], 0);\n+                        splitDomain = Domain.create(ValueSet.ofRanges(\n+                                Range.range(type, min, true, max, true)), false);\n+                    }\n+                    else {\n+                        splitDomain = Domain.all(type);\n+                    }\n+                    domainsBuilder.put(channels.get(channelIndex).filterId, splitDomain);\n+                }\n+            }\n+            else {\n+                return;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk5ODY0Mw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r486998643", "bodyText": "let's not make it experimental as DF is not experimental anymore", "author": "sopel39", "createdAt": "2020-09-11T12:02:28Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -796,6 +797,18 @@ public FeaturesConfig setDynamicFilteringRefreshInterval(Duration dynamicFilteri\n         return this;\n     }\n \n+    public boolean getDynamicFilteringMinMaxValues()\n+    {\n+        return dynamicFilteringMinMaxValues;\n+    }\n+\n+    @Config(\"experimental.dynamic-filtering-min-max-values\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMDI5Nw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487000297", "bodyText": "let's make maxPerDriverRowCount and maxPerDriverSize params of createOperatorFactory (with default override maybe), so that in case we increase limits in the future, the tests won't run longer", "author": "sopel39", "createdAt": "2020-09-11T12:06:04Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -103,7 +113,8 @@ private OperatorFactory createOperatorFactory(DynamicFilterSourceOperator.Channe\n                 this::consumePredicate,\n                 Arrays.stream(buildChannels).collect(toList()),\n                 getDynamicFilteringMaxPerDriverRowCount(TEST_SESSION),\n-                getDynamicFilteringMaxPerDriverSize(TEST_SESSION));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4MDY5NQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487380695", "bodyText": "Done", "author": "raunaqmorarka", "createdAt": "2020-09-12T07:31:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMDI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMTEwMw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487001103", "bodyText": "undo", "author": "sopel39", "createdAt": "2020-09-11T12:07:46Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -280,44 +362,77 @@ public void testCollectEmptyBuildSide()\n     public void testCollectTooMuchRows()\n     {\n         int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        Page largePage = new Page(createLongSequenceBlock(0, maxRowCount + 1),\n+                createLongSequenceBlock(maxRowCount + 1, 2 * (maxRowCount + 1)));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT), channel(1, BIGINT));\n         verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(BIGINT),\n+                ImmutableList.of(BIGINT, BIGINT),\n                 largePage);\n         operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                Range.range(BIGINT, 0L, true, (long) maxRowCount, true)), false),\n+                        new DynamicFilterId(\"1\"), Domain.create(ValueSet.ofRanges(\n+                                Range.range(BIGINT, maxRowCount + 1L, true, (2L * maxRowCount) + 1L, true)), false)))));\n     }\n \n     @Test\n     public void testCollectTooMuchBytesSingleColumn()\n     {\n         long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) maxByteSize + 1)));\n+        Page largePage = new Page(createStringsBlock(Collections.nCopies((int) maxByteSize + 1, \"A\")));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMTIzNQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487001235", "bodyText": "undo", "author": "sopel39", "createdAt": "2020-09-11T12:08:01Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -280,44 +362,77 @@ public void testCollectEmptyBuildSide()\n     public void testCollectTooMuchRows()\n     {\n         int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        Page largePage = new Page(createLongSequenceBlock(0, maxRowCount + 1),\n+                createLongSequenceBlock(maxRowCount + 1, 2 * (maxRowCount + 1)));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT), channel(1, BIGINT));\n         verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(BIGINT),\n+                ImmutableList.of(BIGINT, BIGINT),\n                 largePage);\n         operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                Range.range(BIGINT, 0L, true, (long) maxRowCount, true)), false),\n+                        new DynamicFilterId(\"1\"), Domain.create(ValueSet.ofRanges(\n+                                Range.range(BIGINT, maxRowCount + 1L, true, (2L * maxRowCount) + 1L, true)), false)))));\n     }\n \n     @Test\n     public void testCollectTooMuchBytesSingleColumn()\n     {\n         long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) maxByteSize + 1)));\n+        Page largePage = new Page(createStringsBlock(Collections.nCopies((int) maxByteSize + 1, \"A\")));\n \n         OperatorFactory operatorFactory = createOperatorFactory(channel(0, VARCHAR));\n         verifyPassthrough(createOperator(operatorFactory),\n                 ImmutableList.of(VARCHAR),\n                 largePage);\n         operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                Range.range(VARCHAR, utf8Slice(\"A\"), true, utf8Slice(\"A\"), true)), false)))));\n     }\n \n     @Test\n     public void testCollectTooMuchBytesMultipleColumns()\n     {\n         long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) (maxByteSize / 2) + 1)),\n-                createStringsBlock(\"B\".repeat((int) (maxByteSize / 2) + 1)));\n+        Page largePage = new Page(createStringsBlock(Collections.nCopies((int) (maxByteSize / 2) + 1, \"A\")),\n+                createStringsBlock(Collections.nCopies((int) (maxByteSize / 2) + 1, \"B\")));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMzA5OQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487003099", "bodyText": "nit: this should be separate commit", "author": "sopel39", "createdAt": "2020-09-11T12:11:44Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -226,7 +244,7 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n-    private void assertDynamicFiltering(String selectQuery, Session session, int expectedRowCount, Set<Integer> expectedOperatorRowsRead)\n+    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, Set<Integer> expectedOperatorRowsRead)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4MDc3NA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487380774", "bodyText": "Made separate commit", "author": "raunaqmorarka", "createdAt": "2020-09-12T07:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMzA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMzk2OQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487003969", "bodyText": "could we have a parametrized test method that we call with different input blocks, input types and expected result tuple domain?", "author": "sopel39", "createdAt": "2020-09-11T12:13:40Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -255,6 +266,77 @@ public void testCollectWithRealNaN()\n                         new DynamicFilterId(\"0\"), Domain.multipleValues(REAL, ImmutableList.of((long) floatToRawIntBits(42.0f)))))));\n     }\n \n+    @Test\n+    public void testCollectTooMuchRowsDouble()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4MDcxNQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487380715", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-12T07:31:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwMzk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwNDM2MA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487004360", "bodyText": "each arg in newline", "author": "sopel39", "createdAt": "2020-09-11T12:14:33Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -280,44 +362,77 @@ public void testCollectEmptyBuildSide()\n     public void testCollectTooMuchRows()\n     {\n         int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        Page largePage = new Page(createLongSequenceBlock(0, maxRowCount + 1),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwNDQ3MQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487004471", "bodyText": "why do we need another column?", "author": "sopel39", "createdAt": "2020-09-11T12:14:44Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -280,44 +362,77 @@ public void testCollectEmptyBuildSide()\n     public void testCollectTooMuchRows()\n     {\n         int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        Page largePage = new Page(createLongSequenceBlock(0, maxRowCount + 1),\n+                createLongSequenceBlock(maxRowCount + 1, 2 * (maxRowCount + 1)));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT), channel(1, BIGINT));\n         verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(BIGINT),\n+                ImmutableList.of(BIGINT, BIGINT),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3NDg4MA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487374880", "bodyText": "Multiple columns to verify that min/max of each column is being maintained as expected separately", "author": "raunaqmorarka", "createdAt": "2020-09-12T06:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwNDQ3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4MTExNA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487381114", "bodyText": "Separated into 2 tests testCollectTooMuchRowsSingleColumn and testCollectTooMuchRowsMultipleColumns now", "author": "raunaqmorarka", "createdAt": "2020-09-12T07:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwNDQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwNTkwOQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487005909", "bodyText": "please also add a test where there are too much rows, but collection of min/max is disabled", "author": "sopel39", "createdAt": "2020-09-11T12:17:40Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -255,6 +266,77 @@ public void testCollectWithRealNaN()\n                         new DynamicFilterId(\"0\"), Domain.multipleValues(REAL, ImmutableList.of((long) floatToRawIntBits(42.0f)))))));\n     }\n \n+    @Test\n+    public void testCollectTooMuchRowsDouble()\n+    {\n+        int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, DOUBLE));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                ImmutableList.of(DOUBLE),\n+                new Page(createDoubleSequenceBlock(0, maxRowCount + 1)),\n+                new Page(createDoubleRepeatBlock(Double.NaN, maxRowCount + 1)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsReal()\n+    {\n+        int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, REAL));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                ImmutableList.of(REAL),\n+                new Page(createSequenceBlockOfReal(0, maxRowCount + 1)),\n+                new Page(createBlockOfReals(Collections.nCopies(maxRowCount + 1, Float.NaN))));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsNonOrderable()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM4MDc1NQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487380755", "bodyText": "Added testCollectRowsNonOrderableWithoutMinMax", "author": "raunaqmorarka", "createdAt": "2020-09-12T07:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAwNTkwOQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3Mjc5OQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487772799", "bodyText": "Let's use value and positionCount instead", "author": "sopel39", "createdAt": "2020-09-14T09:24:17Z", "path": "presto-main/src/test/java/io/prestosql/block/BlockAssertions.java", "diffHunk": "@@ -561,6 +562,15 @@ public static Block createLongDecimalSequenceBlock(int start, int end, DecimalTy\n         return builder.build();\n     }\n \n+    public static Block createColorSequenceBlock(int start, int end)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjg3Nw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487902877", "bodyText": "With value and positionCount would we create a block of repeated values ? I wanted to create a block of all different values to easily exceed the current distinct values count threshold in tests, that's why I used start and end as parameter.", "author": "raunaqmorarka", "createdAt": "2020-09-14T13:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3Mjc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3MzU3MQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487773571", "bodyText": "put domainStats and Domain.create args in newlines", "author": "sopel39", "createdAt": "2020-09-14T09:25:28Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -190,7 +192,9 @@ public void testJoinLargeBuildSideNoDynamicFiltering()\n         assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n \n         DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n-        assertEquals(domainStats.getSimplifiedDomain(), Domain.all(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3NDA2Nw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487774067", "bodyText": "can we add support for DOUBLE and REAL by filtering NaN at the end of min/max collection?", "author": "sopel39", "createdAt": "2020-09-14T09:26:20Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -129,34 +137,48 @@ public OperatorFactory duplicate()\n     private final Consumer<TupleDomain<DynamicFilterId>> dynamicPredicateConsumer;\n     private final int maxFilterPositionsCount;\n     private final long maxFilterSizeInBytes;\n+    private int minMaxCollectionLimit;\n \n     private final List<Channel> channels;\n+    private final List<Integer> minMaxChannels;\n \n     // May be dropped if the predicate becomes too large.\n     @Nullable\n     private BlockBuilder[] blockBuilders;\n     @Nullable\n     private TypedSet[] valueSets;\n \n+    @Nullable\n+    private Block[] minValues;\n+    @Nullable\n+    private Block[] maxValues;\n+\n     private DynamicFilterSourceOperator(\n             OperatorContext context,\n             Consumer<TupleDomain<DynamicFilterId>> dynamicPredicateConsumer,\n             List<Channel> channels,\n             PlanNodeId planNodeId,\n             int maxFilterPositionsCount,\n-            DataSize maxFilterSize)\n+            DataSize maxFilterSize,\n+            int minMaxCollectionLimit)\n     {\n         this.context = requireNonNull(context, \"context is null\");\n         this.maxFilterPositionsCount = maxFilterPositionsCount;\n         this.maxFilterSizeInBytes = maxFilterSize.toBytes();\n+        this.minMaxCollectionLimit = minMaxCollectionLimit;\n \n         this.dynamicPredicateConsumer = requireNonNull(dynamicPredicateConsumer, \"dynamicPredicateConsumer is null\");\n         this.channels = requireNonNull(channels, \"channels is null\");\n \n         this.blockBuilders = new BlockBuilder[channels.size()];\n         this.valueSets = new TypedSet[channels.size()];\n+        ImmutableList.Builder<Integer> minMaxChannelsBuilder = ImmutableList.builder();\n         for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n             Type type = channels.get(channelIndex).type;\n+            // Skipping DOUBLE and REAL in collectMinMaxValues to avoid dealing with NaN values\n+            if (minMaxCollectionLimit > 0 && type.isOrderable() && type != DOUBLE && type != REAL) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3NzQ3Mg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487777472", "bodyText": "move just above minValues/maxValues", "author": "sopel39", "createdAt": "2020-09-14T09:32:13Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -129,34 +137,48 @@ public OperatorFactory duplicate()\n     private final Consumer<TupleDomain<DynamicFilterId>> dynamicPredicateConsumer;\n     private final int maxFilterPositionsCount;\n     private final long maxFilterSizeInBytes;\n+    private int minMaxCollectionLimit;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3ODM2Mg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487778362", "bodyText": "use continue. Then you can remove else", "author": "sopel39", "createdAt": "2020-09-14T09:33:51Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +242,80 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxChannels.isEmpty()) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+        }\n+        else {\n+            // convert to min/max per column for orderable types\n+            for (Integer channelIndex : minMaxChannels) {\n+                Block block = blockBuilders[channelIndex].build();\n+                updateMinMaxValues(block, channelIndex);\n+            }\n+        }\n         // Drop references to collected values.\n         valueSets = null;\n         blockBuilders = null;\n     }\n \n+    private void updateMinMaxValues(Block block, int channelIndex)\n+    {\n+        if (minValues == null || maxValues == null) {\n+            return;\n+        }\n+        Type type = channels.get(channelIndex).type;\n+        int minValuePosition = -1;\n+        int maxValuePosition = -1;\n+\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            if (block.isNull(position)) {\n+                continue;\n+            }\n+            if (minValuePosition == -1) {\n+                // First non-null value\n+                minValuePosition = position;\n+                maxValuePosition = position;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0Njc5OQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488046799", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3ODM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3ODY0Nw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487778647", "bodyText": "use return here. Then you can remove else below", "author": "sopel39", "createdAt": "2020-09-14T09:34:22Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +242,80 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxChannels.isEmpty()) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+        }\n+        else {\n+            // convert to min/max per column for orderable types\n+            for (Integer channelIndex : minMaxChannels) {\n+                Block block = blockBuilders[channelIndex].build();\n+                updateMinMaxValues(block, channelIndex);\n+            }\n+        }\n         // Drop references to collected values.\n         valueSets = null;\n         blockBuilders = null;\n     }\n \n+    private void updateMinMaxValues(Block block, int channelIndex)\n+    {\n+        if (minValues == null || maxValues == null) {\n+            return;\n+        }\n+        Type type = channels.get(channelIndex).type;\n+        int minValuePosition = -1;\n+        int maxValuePosition = -1;\n+\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            if (block.isNull(position)) {\n+                continue;\n+            }\n+            if (minValuePosition == -1) {\n+                // First non-null value\n+                minValuePosition = position;\n+                maxValuePosition = position;\n+            }\n+            else {\n+                if (type.compareTo(block, position, block, minValuePosition) < 0) {\n+                    minValuePosition = position;\n+                }\n+                else if (type.compareTo(block, position, block, maxValuePosition) > 0) {\n+                    maxValuePosition = position;\n+                }\n+            }\n+        }\n+\n+        minMaxCollectionLimit -= block.getPositionCount();\n+        if (minMaxCollectionLimit < 0) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+            // Drop references to collected values.\n+            minValues = null;\n+            maxValues = null;\n+            return;\n+        }\n+        if (minValuePosition != -1) {\n+            if (minValues[channelIndex] == null) {\n+                minValues[channelIndex] = block.getSingleValueBlock(minValuePosition);\n+                maxValues[channelIndex] = block.getSingleValueBlock(maxValuePosition);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3ODg4Ng==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487778886", "bodyText": "use\nif (minValuePosition == -1) {\n  return;\n}\n\nThen you can avoid else below", "author": "sopel39", "createdAt": "2020-09-14T09:34:47Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +242,80 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxChannels.isEmpty()) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+        }\n+        else {\n+            // convert to min/max per column for orderable types\n+            for (Integer channelIndex : minMaxChannels) {\n+                Block block = blockBuilders[channelIndex].build();\n+                updateMinMaxValues(block, channelIndex);\n+            }\n+        }\n         // Drop references to collected values.\n         valueSets = null;\n         blockBuilders = null;\n     }\n \n+    private void updateMinMaxValues(Block block, int channelIndex)\n+    {\n+        if (minValues == null || maxValues == null) {\n+            return;\n+        }\n+        Type type = channels.get(channelIndex).type;\n+        int minValuePosition = -1;\n+        int maxValuePosition = -1;\n+\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            if (block.isNull(position)) {\n+                continue;\n+            }\n+            if (minValuePosition == -1) {\n+                // First non-null value\n+                minValuePosition = position;\n+                maxValuePosition = position;\n+            }\n+            else {\n+                if (type.compareTo(block, position, block, minValuePosition) < 0) {\n+                    minValuePosition = position;\n+                }\n+                else if (type.compareTo(block, position, block, maxValuePosition) > 0) {\n+                    maxValuePosition = position;\n+                }\n+            }\n+        }\n+\n+        minMaxCollectionLimit -= block.getPositionCount();\n+        if (minMaxCollectionLimit < 0) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+            // Drop references to collected values.\n+            minValues = null;\n+            maxValues = null;\n+            return;\n+        }\n+        if (minValuePosition != -1) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MjA5OQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487782099", "bodyText": "what if minValues[channelIndex] is null? That would mean there were only nulls. You should return TupleDomain.none then", "author": "sopel39", "createdAt": "2020-09-14T09:40:17Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -233,26 +332,42 @@ public void finish()\n             return;\n         }\n         finished = true;\n+        ImmutableMap.Builder<DynamicFilterId, Domain> domainsBuilder = new ImmutableMap.Builder<>();\n         if (valueSets == null) {\n-            return; // the predicate became too large.\n+            // the predicate became too large\n+            if (minValues != null && maxValues != null) {\n+                // create TupleDomain from min/max values\n+                for (Integer channelIndex : minMaxChannels) {\n+                    Type type = channels.get(channelIndex).type;\n+                    Object min = readNativeValue(type, minValues[channelIndex], 0);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0OTQxMA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488049410", "bodyText": "Right, fixed this and added test", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MjA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MjQwNA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487782404", "bodyText": "return here, then you can avoid else below", "author": "sopel39", "createdAt": "2020-09-14T09:40:47Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -233,26 +332,42 @@ public void finish()\n             return;\n         }\n         finished = true;\n+        ImmutableMap.Builder<DynamicFilterId, Domain> domainsBuilder = new ImmutableMap.Builder<>();\n         if (valueSets == null) {\n-            return; // the predicate became too large.\n+            // the predicate became too large\n+            if (minValues != null && maxValues != null) {\n+                // create TupleDomain from min/max values\n+                for (Integer channelIndex : minMaxChannels) {\n+                    Type type = channels.get(channelIndex).type;\n+                    Object min = readNativeValue(type, minValues[channelIndex], 0);\n+                    Object max = readNativeValue(type, maxValues[channelIndex], 0);\n+                    Domain domain = Domain.create(ValueSet.ofRanges(\n+                            Range.range(type, min, true, max, true)), false);\n+                    domainsBuilder.put(channels.get(channelIndex).filterId, domain);\n+                }\n+                minValues = null;\n+                maxValues = null;\n+                dynamicPredicateConsumer.accept(TupleDomain.withColumnDomains(domainsBuilder.build()));\n+            }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0NzAyMA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488047020", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4Mjk0Mg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487782942", "bodyText": "rename to dynamic-filtering-min-max-limit-per-driver", "author": "sopel39", "createdAt": "2020-09-14T09:41:39Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -796,6 +797,19 @@ public FeaturesConfig setDynamicFilteringRefreshInterval(Duration dynamicFilteri\n         return this;\n     }\n \n+    public int getDynamicFilteringPerDriverMinMaxLimit()\n+    {\n+        return dynamicFilteringPerDriverMinMaxLimit;\n+    }\n+\n+    @Config(\"dynamic-filtering-per-driver-min-max-limit\")", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0OTUwMA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488049500", "bodyText": "renamed", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4Mjk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MzQwNA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487783404", "bodyText": "rename to dynamic_filtering_min_max_limit_per_driver", "author": "sopel39", "createdAt": "2020-09-14T09:42:31Z", "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -121,6 +121,7 @@\n     public static final String QUERY_MAX_TOTAL_MEMORY_PER_NODE = \"query_max_total_memory_per_node\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_ROW_COUNT = \"dynamic_filtering_max_per_driver_row_count\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_SIZE = \"dynamic_filtering_max_per_driver_size\";\n+    public static final String DYNAMIC_FILTERING_PER_DRIVER_MIN_MAX_LIMIT = \"dynamic_filtering_per_driver_min_max_limit\";", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0OTU3Ng==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488049576", "bodyText": "renamed", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MzQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NjU0Ng==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487786546", "bodyText": "make List<TupleDomain<DynamicFilterId>> expectedTupleDomains last argument here and in method above", "author": "sopel39", "createdAt": "2020-09-14T09:47:51Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -121,6 +143,28 @@ private Operator createOperator(OperatorFactory operatorFactory)\n         return new DynamicFilterSourceOperator.Channel(new DynamicFilterId(Integer.toString(index)), type, index);\n     }\n \n+    private void assertDynamicFilters(int maxFilterPositionsCount, List<TupleDomain<DynamicFilterId>> expectedTupleDomains, List<Type> types, Page... pages)\n+    {\n+        assertDynamicFilters(maxFilterPositionsCount, DataSize.of(10, KILOBYTE), 1_000_000, expectedTupleDomains, types, pages);\n+    }\n+\n+    private void assertDynamicFilters(\n+            int maxFilterPositionsCount,\n+            DataSize maxFilterSize,\n+            int minMaxCollectionLimit,\n+            List<TupleDomain<DynamicFilterId>> expectedTupleDomains,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NzExMg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487787112", "bodyText": "remove requireNonNull", "author": "sopel39", "createdAt": "2020-09-14T09:48:48Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -255,6 +299,79 @@ public void testCollectWithRealNaN()\n                         new DynamicFilterId(\"0\"), Domain.multipleValues(REAL, ImmutableList.of((long) floatToRawIntBits(42.0f)))))));\n     }\n \n+    @Test\n+    public void testCollectTooMuchRowsDouble()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(DOUBLE),\n+                new Page(createDoubleSequenceBlock(0, maxPositionsCount + 1)),\n+                new Page(createDoubleRepeatBlock(Double.NaN, maxPositionsCount + 1)));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsReal()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(REAL),\n+                new Page(createSequenceBlockOfReal(0, maxPositionsCount + 1)),\n+                new Page(createBlockOfReals(Collections.nCopies(maxPositionsCount + 1, Float.NaN))));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsNonOrderable()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(COLOR),\n+                new Page(createColorSequenceBlock(0, 2 * maxPositionsCount)));\n+    }\n+\n+    @Test\n+    public void testCollectRowsNonOrderable()\n+    {\n+        int maxPositionsCount = 100;\n+        Block block = createColorSequenceBlock(0, maxPositionsCount / 2);\n+        ImmutableList.Builder<Object> values = ImmutableList.builder();\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            values.add(requireNonNull(readNativeValue(COLOR, block, position)));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NzU4Nw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487787587", "bodyText": "remove requireNonNull", "author": "sopel39", "createdAt": "2020-09-14T09:49:35Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -255,6 +299,79 @@ public void testCollectWithRealNaN()\n                         new DynamicFilterId(\"0\"), Domain.multipleValues(REAL, ImmutableList.of((long) floatToRawIntBits(42.0f)))))));\n     }\n \n+    @Test\n+    public void testCollectTooMuchRowsDouble()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(DOUBLE),\n+                new Page(createDoubleSequenceBlock(0, maxPositionsCount + 1)),\n+                new Page(createDoubleRepeatBlock(Double.NaN, maxPositionsCount + 1)));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsReal()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(REAL),\n+                new Page(createSequenceBlockOfReal(0, maxPositionsCount + 1)),\n+                new Page(createBlockOfReals(Collections.nCopies(maxPositionsCount + 1, Float.NaN))));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsNonOrderable()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(COLOR),\n+                new Page(createColorSequenceBlock(0, 2 * maxPositionsCount)));\n+    }\n+\n+    @Test\n+    public void testCollectRowsNonOrderable()\n+    {\n+        int maxPositionsCount = 100;\n+        Block block = createColorSequenceBlock(0, maxPositionsCount / 2);\n+        ImmutableList.Builder<Object> values = ImmutableList.builder();\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            values.add(requireNonNull(readNativeValue(COLOR, block, position)));\n+        }\n+\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"),\n+                        Domain.create(ValueSet.copyOf(COLOR, values.build()), false)));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(expectedTupleDomain), ImmutableList.of(COLOR), new Page(block));\n+    }\n+\n+    @Test\n+    public void testCollectRowsNonOrderableWithoutMinMax()\n+    {\n+        int maxPositionsCount = 100;\n+        Block block = createColorSequenceBlock(0, maxPositionsCount / 2);\n+        ImmutableList.Builder<Object> values = ImmutableList.builder();\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            values.add(requireNonNull(readNativeValue(COLOR, block, position)));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4ODE0MA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487788140", "bodyText": "use maxPositionsCount + 1 for consistency", "author": "sopel39", "createdAt": "2020-09-14T09:50:26Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -255,6 +299,79 @@ public void testCollectWithRealNaN()\n                         new DynamicFilterId(\"0\"), Domain.multipleValues(REAL, ImmutableList.of((long) floatToRawIntBits(42.0f)))))));\n     }\n \n+    @Test\n+    public void testCollectTooMuchRowsDouble()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(DOUBLE),\n+                new Page(createDoubleSequenceBlock(0, maxPositionsCount + 1)),\n+                new Page(createDoubleRepeatBlock(Double.NaN, maxPositionsCount + 1)));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsReal()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(REAL),\n+                new Page(createSequenceBlockOfReal(0, maxPositionsCount + 1)),\n+                new Page(createBlockOfReals(Collections.nCopies(maxPositionsCount + 1, Float.NaN))));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsNonOrderable()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(COLOR),\n+                new Page(createColorSequenceBlock(0, 2 * maxPositionsCount)));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4ODUxNQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487788515", "bodyText": "I think we can remove this test case", "author": "sopel39", "createdAt": "2020-09-14T09:51:03Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -255,6 +299,79 @@ public void testCollectWithRealNaN()\n                         new DynamicFilterId(\"0\"), Domain.multipleValues(REAL, ImmutableList.of((long) floatToRawIntBits(42.0f)))))));\n     }\n \n+    @Test\n+    public void testCollectTooMuchRowsDouble()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(DOUBLE),\n+                new Page(createDoubleSequenceBlock(0, maxPositionsCount + 1)),\n+                new Page(createDoubleRepeatBlock(Double.NaN, maxPositionsCount + 1)));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsReal()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(REAL),\n+                new Page(createSequenceBlockOfReal(0, maxPositionsCount + 1)),\n+                new Page(createBlockOfReals(Collections.nCopies(maxPositionsCount + 1, Float.NaN))));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRowsNonOrderable()\n+    {\n+        int maxPositionsCount = 100;\n+        assertDynamicFilters(\n+                maxPositionsCount,\n+                ImmutableList.of(TupleDomain.all()),\n+                ImmutableList.of(COLOR),\n+                new Page(createColorSequenceBlock(0, 2 * maxPositionsCount)));\n+    }\n+\n+    @Test\n+    public void testCollectRowsNonOrderable()\n+    {\n+        int maxPositionsCount = 100;\n+        Block block = createColorSequenceBlock(0, maxPositionsCount / 2);\n+        ImmutableList.Builder<Object> values = ImmutableList.builder();\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            values.add(requireNonNull(readNativeValue(COLOR, block, position)));\n+        }\n+\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"),\n+                        Domain.create(ValueSet.copyOf(COLOR, values.build()), false)));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(expectedTupleDomain), ImmutableList.of(COLOR), new Page(block));\n+    }\n+\n+    @Test\n+    public void testCollectRowsNonOrderableWithoutMinMax()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0OTc2Mg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488049762", "bodyText": "removed", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4ODUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4OTk4NQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487789985", "bodyText": "I would call it testSingleColumnCollectMinMaxRangeWhenTooManyPositions", "author": "sopel39", "createdAt": "2020-09-14T09:53:33Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -277,63 +394,105 @@ public void testCollectEmptyBuildSide()\n     }\n \n     @Test\n-    public void testCollectTooMuchRows()\n+    public void testCollectTooMuchRowsSingleColumn()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5MDQxOA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487790418", "bodyText": "rename to testMultipleColumnsCollectMinMaxRangeWhenTooManyPositions", "author": "sopel39", "createdAt": "2020-09-14T09:54:15Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -277,63 +394,105 @@ public void testCollectEmptyBuildSide()\n     }\n \n     @Test\n-    public void testCollectTooMuchRows()\n+    public void testCollectTooMuchRowsSingleColumn()\n     {\n-        int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        int maxPositionsCount = 100;\n+        Page largePage = new Page(createLongSequenceBlock(0, maxPositionsCount + 1));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n-        verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(BIGINT),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                        range(BIGINT, 0L, true, (long) maxPositionsCount, true)), false)));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(expectedTupleDomain), ImmutableList.of(BIGINT), largePage);\n     }\n \n     @Test\n-    public void testCollectTooMuchBytesSingleColumn()\n+    public void testCollectTooMuchRowsMultipleColumns()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0ODU5Mw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488048593", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5MDQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5MTI4OQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487791289", "bodyText": "rename to testSingleColumnCollectMinMaxRangeWhenTooManyBytes", "author": "sopel39", "createdAt": "2020-09-14T09:55:30Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -277,63 +394,105 @@ public void testCollectEmptyBuildSide()\n     }\n \n     @Test\n-    public void testCollectTooMuchRows()\n+    public void testCollectTooMuchRowsSingleColumn()\n     {\n-        int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        int maxPositionsCount = 100;\n+        Page largePage = new Page(createLongSequenceBlock(0, maxPositionsCount + 1));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n-        verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(BIGINT),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                        range(BIGINT, 0L, true, (long) maxPositionsCount, true)), false)));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(expectedTupleDomain), ImmutableList.of(BIGINT), largePage);\n     }\n \n     @Test\n-    public void testCollectTooMuchBytesSingleColumn()\n+    public void testCollectTooMuchRowsMultipleColumns()\n     {\n-        long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) maxByteSize + 1)));\n+        int maxPositionsCount = 300;\n+        Page largePage = new Page(\n+                createLongSequenceBlock(0, 101),\n+                createColorSequenceBlock(100, 201),\n+                createLongSequenceBlock(200, 301));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, VARCHAR));\n-        verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(VARCHAR),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        List<TupleDomain<DynamicFilterId>> expectedTupleDomains = ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 0L, true, 100L, true)), false),\n+                        new DynamicFilterId(\"2\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 200L, true, 300L, true)), false))));\n+        assertDynamicFilters(maxPositionsCount, expectedTupleDomains, ImmutableList.of(BIGINT, COLOR, BIGINT), largePage);\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchBytesSingleColumn()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0ODM4OQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488048389", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5MTI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5MTkwMQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487791901", "bodyText": "rename to testMultipleColumnsCollectMinMaxRangeWhenTooManyBytes", "author": "sopel39", "createdAt": "2020-09-14T09:56:31Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -277,63 +394,105 @@ public void testCollectEmptyBuildSide()\n     }\n \n     @Test\n-    public void testCollectTooMuchRows()\n+    public void testCollectTooMuchRowsSingleColumn()\n     {\n-        int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        int maxPositionsCount = 100;\n+        Page largePage = new Page(createLongSequenceBlock(0, maxPositionsCount + 1));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n-        verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(BIGINT),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                        range(BIGINT, 0L, true, (long) maxPositionsCount, true)), false)));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(expectedTupleDomain), ImmutableList.of(BIGINT), largePage);\n     }\n \n     @Test\n-    public void testCollectTooMuchBytesSingleColumn()\n+    public void testCollectTooMuchRowsMultipleColumns()\n     {\n-        long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) maxByteSize + 1)));\n+        int maxPositionsCount = 300;\n+        Page largePage = new Page(\n+                createLongSequenceBlock(0, 101),\n+                createColorSequenceBlock(100, 201),\n+                createLongSequenceBlock(200, 301));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, VARCHAR));\n-        verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(VARCHAR),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        List<TupleDomain<DynamicFilterId>> expectedTupleDomains = ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 0L, true, 100L, true)), false),\n+                        new DynamicFilterId(\"2\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 200L, true, 300L, true)), false))));\n+        assertDynamicFilters(maxPositionsCount, expectedTupleDomains, ImmutableList.of(BIGINT, COLOR, BIGINT), largePage);\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchBytesSingleColumn()\n+    {\n+        DataSize maxSize = DataSize.of(10, KILOBYTE);\n+        long maxByteSize = maxSize.toBytes();\n+        String largeText = \"A\".repeat((int) maxByteSize + 1);\n+        Page largePage = new Page(createStringsBlock(largeText));\n+\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new DynamicFilterId(\"0\"),\n+                Domain.create(\n+                        ValueSet.ofRanges(range(VARCHAR, utf8Slice(largeText), true, utf8Slice(largeText), true)),\n+                        false)));\n+        assertDynamicFilters(100, maxSize, 100, ImmutableList.of(expectedTupleDomain), ImmutableList.of(VARCHAR), largePage);\n     }\n \n     @Test\n     public void testCollectTooMuchBytesMultipleColumns()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0ODE3MA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488048170", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5MTkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5MzM1Mw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r487793353", "bodyText": "add a test case for min/max when one of the columns has nulls only while the other one has values from 0 to maxPositionsCount+1", "author": "sopel39", "createdAt": "2020-09-14T09:58:52Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -277,63 +394,105 @@ public void testCollectEmptyBuildSide()\n     }\n \n     @Test\n-    public void testCollectTooMuchRows()\n+    public void testCollectTooMuchRowsSingleColumn()\n     {\n-        int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        int maxPositionsCount = 100;\n+        Page largePage = new Page(createLongSequenceBlock(0, maxPositionsCount + 1));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n-        verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(BIGINT),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                        range(BIGINT, 0L, true, (long) maxPositionsCount, true)), false)));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(expectedTupleDomain), ImmutableList.of(BIGINT), largePage);\n     }\n \n     @Test\n-    public void testCollectTooMuchBytesSingleColumn()\n+    public void testCollectTooMuchRowsMultipleColumns()\n     {\n-        long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) maxByteSize + 1)));\n+        int maxPositionsCount = 300;\n+        Page largePage = new Page(\n+                createLongSequenceBlock(0, 101),\n+                createColorSequenceBlock(100, 201),\n+                createLongSequenceBlock(200, 301));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, VARCHAR));\n-        verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(VARCHAR),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        List<TupleDomain<DynamicFilterId>> expectedTupleDomains = ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 0L, true, 100L, true)), false),\n+                        new DynamicFilterId(\"2\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 200L, true, 300L, true)), false))));\n+        assertDynamicFilters(maxPositionsCount, expectedTupleDomains, ImmutableList.of(BIGINT, COLOR, BIGINT), largePage);\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchBytesSingleColumn()\n+    {\n+        DataSize maxSize = DataSize.of(10, KILOBYTE);\n+        long maxByteSize = maxSize.toBytes();\n+        String largeText = \"A\".repeat((int) maxByteSize + 1);\n+        Page largePage = new Page(createStringsBlock(largeText));\n+\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new DynamicFilterId(\"0\"),\n+                Domain.create(\n+                        ValueSet.ofRanges(range(VARCHAR, utf8Slice(largeText), true, utf8Slice(largeText), true)),\n+                        false)));\n+        assertDynamicFilters(100, maxSize, 100, ImmutableList.of(expectedTupleDomain), ImmutableList.of(VARCHAR), largePage);\n     }\n \n     @Test\n     public void testCollectTooMuchBytesMultipleColumns()\n     {\n-        long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) (maxByteSize / 2) + 1)),\n-                createStringsBlock(\"B\".repeat((int) (maxByteSize / 2) + 1)));\n+        DataSize maxSize = DataSize.of(10, KILOBYTE);\n+        long maxByteSize = maxSize.toBytes();\n+        String largeTextA = \"A\".repeat((int) (maxByteSize / 2) + 1);\n+        String largeTextB = \"B\".repeat((int) (maxByteSize / 2) + 1);\n+        Page largePage = new Page(createStringsBlock(largeTextA), createStringsBlock(largeTextB));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, VARCHAR),\n-                channel(1, VARCHAR));\n-        verifyPassthrough(createOperator(operatorFactory),\n-                ImmutableList.of(VARCHAR, VARCHAR),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+        List<TupleDomain<DynamicFilterId>> expectedTupleDomains = ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                range(VARCHAR, utf8Slice(largeTextA), true, utf8Slice(largeTextA), true)), false),\n+                        new DynamicFilterId(\"1\"), Domain.create(ValueSet.ofRanges(\n+                                range(VARCHAR, utf8Slice(largeTextB), true, utf8Slice(largeTextB), true)), false))));\n+        assertDynamicFilters(100, maxSize, 100, expectedTupleDomains, ImmutableList.of(VARCHAR, VARCHAR), largePage);\n+    }\n+\n+    @Test\n+    public void testCollectMultipleLargePages()\n+    {\n+        int maxPositionsCount = 100;\n+        Page page1 = new Page(createLongSequenceBlock(maxPositionsCount / 2, maxPositionsCount + (maxPositionsCount / 2) + 1));\n+        Page page2 = new Page(createLongSequenceBlock(0, maxPositionsCount + 1));\n+        Page page3 = new Page(createLongSequenceBlock(maxPositionsCount, (2 * maxPositionsCount) + 1));\n+\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 0L, true, 2L * maxPositionsCount, true)), false)));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(expectedTupleDomain), ImmutableList.of(BIGINT), page1, page2, page3);\n     }\n \n     @Test\n     public void testCollectDeduplication()\n     {\n-        int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = new Page(createLongRepeatBlock(7, maxRowCount * 10)); // lots of zeros\n-        Page nullsPage = new Page(createLongsBlock(Arrays.asList(new Long[maxRowCount * 10]))); // lots of nulls\n+        int maxPositionsCount = 100;\n+        Page largePage = new Page(createLongRepeatBlock(7, maxPositionsCount * 10)); // lots of zeros\n+        Page nullsPage = new Page(createLongsBlock(Arrays.asList(new Long[maxPositionsCount * 10]))); // lots of nulls\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n-        verifyPassthrough(createOperator(operatorFactory),\n+        TupleDomain<DynamicFilterId> expectedTupleDomain = TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.of(BIGINT, 7L), false)));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(expectedTupleDomain), ImmutableList.of(BIGINT), largePage, nullsPage);\n+    }\n+\n+    @Test", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0NzcxNg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488047716", "bodyText": "Added testMultipleColumnsCollectMinMaxWithNulls", "author": "raunaqmorarka", "createdAt": "2020-09-14T16:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5MzM1Mw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU5OTkzNA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488599934", "bodyText": "I think it should be:\ndynamic_filtering_range_row_limit_per_driver", "author": "sopel39", "createdAt": "2020-09-15T11:43:44Z", "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -121,6 +121,7 @@\n     public static final String QUERY_MAX_TOTAL_MEMORY_PER_NODE = \"query_max_total_memory_per_node\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_ROW_COUNT = \"dynamic_filtering_max_per_driver_row_count\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_SIZE = \"dynamic_filtering_max_per_driver_size\";\n+    public static final String DYNAMIC_FILTERING_MIN_MAX_LIMIT_PER_DRIVER = \"dynamic_filtering_min_max_limit_per_driver\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwMzc0Mw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488603743", "bodyText": "add a comment: all block values are nulls", "author": "sopel39", "createdAt": "2020-09-15T11:50:16Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +243,80 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxChannels.isEmpty()) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+        }\n+        else {\n+            // convert to min/max per column for orderable types\n+            for (Integer channelIndex : minMaxChannels) {\n+                Block block = blockBuilders[channelIndex].build();\n+                updateMinMaxValues(block, channelIndex);\n+            }\n+        }\n         // Drop references to collected values.\n         valueSets = null;\n         blockBuilders = null;\n     }\n \n+    private void updateMinMaxValues(Block block, int channelIndex)\n+    {\n+        if (minValues == null || maxValues == null) {\n+            return;\n+        }\n+        Type type = channels.get(channelIndex).type;\n+        int minValuePosition = -1;\n+        int maxValuePosition = -1;\n+\n+        for (int position = 0; position < block.getPositionCount(); ++position) {\n+            if (block.isNull(position)) {\n+                continue;\n+            }\n+            if (minValuePosition == -1) {\n+                // First non-null value\n+                minValuePosition = position;\n+                maxValuePosition = position;\n+                continue;\n+            }\n+            if (type.compareTo(block, position, block, minValuePosition) < 0) {\n+                minValuePosition = position;\n+            }\n+            else if (type.compareTo(block, position, block, maxValuePosition) > 0) {\n+                maxValuePosition = position;\n+            }\n+        }\n+\n+        minMaxCollectionLimit -= block.getPositionCount();\n+        if (minMaxCollectionLimit < 0) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+            // Drop references to collected values.\n+            minValues = null;\n+            maxValues = null;\n+            return;\n+        }\n+        if (minValuePosition == -1) {\n+            return;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwNDU3NA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488604574", "bodyText": "add a comment when this happens, e.g: all values are null and short circuit here:\nif (minValues[channelIndex] == null) {\n  // all values were null\n  dynamicPredicateConsumer.accept(TupleDomain.none());\n  return;\n}", "author": "sopel39", "createdAt": "2020-09-15T11:51:38Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -233,11 +333,33 @@ public void finish()\n             return;\n         }\n         finished = true;\n+        ImmutableMap.Builder<DynamicFilterId, Domain> domainsBuilder = new ImmutableMap.Builder<>();\n         if (valueSets == null) {\n-            return; // the predicate became too large.\n+            // the predicate became too large\n+            if (minValues != null && maxValues != null) {\n+                // create TupleDomain from min/max values\n+                for (Integer channelIndex : minMaxChannels) {\n+                    Type type = channels.get(channelIndex).type;\n+                    Domain domain;\n+                    if (minValues[channelIndex] == null) {\n+                        domain = Domain.none(type);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwNzk3Nw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488607977", "bodyText": "add:\nif (minValues == null)\n  // there are too many rows to collect collect min/max range\n  return;\n}\n\nto avoid iterating over block array", "author": "sopel39", "createdAt": "2020-09-15T11:57:39Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -186,7 +214,12 @@ public void addInput(Page page)\n         verify(!finished, \"DynamicFilterSourceOperator: addInput() may not be called after finish()\");\n         current = page;\n         if (valueSets == null) {\n-            return;  // the predicate became too large.\n+            // the predicate became too large, record only min and max values for each orderable channel", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwODMzMQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488608331", "bodyText": "add check state\ncheckState(minValues != null && maxValues != null);", "author": "sopel39", "createdAt": "2020-09-15T11:58:14Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +243,80 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxChannels.isEmpty()) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+        }\n+        else {\n+            // convert to min/max per column for orderable types\n+            for (Integer channelIndex : minMaxChannels) {\n+                Block block = blockBuilders[channelIndex].build();\n+                updateMinMaxValues(block, channelIndex);\n+            }\n+        }\n         // Drop references to collected values.\n         valueSets = null;\n         blockBuilders = null;\n     }\n \n+    private void updateMinMaxValues(Block block, int channelIndex)\n+    {\n+        if (minValues == null || maxValues == null) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwODcwMw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488608703", "bodyText": "revers the condition:\nif (minValues == null) {\n  // there were too many rows to collect collect min/max range\n  return;\n}", "author": "sopel39", "createdAt": "2020-09-15T11:58:54Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -233,11 +333,33 @@ public void finish()\n             return;\n         }\n         finished = true;\n+        ImmutableMap.Builder<DynamicFilterId, Domain> domainsBuilder = new ImmutableMap.Builder<>();\n         if (valueSets == null) {\n-            return; // the predicate became too large.\n+            // the predicate became too large", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYxMDU2MA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488610560", "bodyText": "rename:\ndynamic-filtering-range-row-limit-per-driver", "author": "sopel39", "createdAt": "2020-09-15T12:02:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -796,6 +797,19 @@ public FeaturesConfig setDynamicFilteringRefreshInterval(Duration dynamicFilteri\n         return this;\n     }\n \n+    public int getDynamicFilteringMinMaxLimitPerDriver()\n+    {\n+        return dynamicFilteringMinMaxLimitPerDriver;\n+    }\n+\n+    @Config(\"dynamic-filtering-min-max-limit-per-driver\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYxMTk4Mg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488611982", "bodyText": "change expectedTupleDomains to TupleDomain.none()", "author": "sopel39", "createdAt": "2020-09-15T12:04:43Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -277,63 +381,146 @@ public void testCollectEmptyBuildSide()\n     }\n \n     @Test\n-    public void testCollectTooMuchRows()\n+    public void testSingleColumnCollectMinMaxRangeWhenTooManyPositions()\n     {\n-        int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        int maxPositionsCount = 100;\n+        Page largePage = new Page(createLongSequenceBlock(0, maxPositionsCount + 1));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n-        verifyPassthrough(createOperator(operatorFactory),\n+        assertDynamicFilters(\n+                maxPositionsCount,\n                 ImmutableList.of(BIGINT),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+                ImmutableList.of(largePage),\n+                ImmutableList.of(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"),\n+                        Domain.create(\n+                                ValueSet.ofRanges(range(BIGINT, 0L, true, (long) maxPositionsCount, true)),\n+                                false)))));\n     }\n \n     @Test\n-    public void testCollectTooMuchBytesSingleColumn()\n+    public void testMultipleColumnsCollectMinMaxRangeWhenTooManyPositions()\n     {\n-        long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) maxByteSize + 1)));\n+        int maxPositionsCount = 300;\n+        Page largePage = new Page(\n+                createLongSequenceBlock(0, 101),\n+                createColorSequenceBlock(100, 201),\n+                createLongSequenceBlock(200, 301));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, VARCHAR));\n-        verifyPassthrough(createOperator(operatorFactory),\n+        List<TupleDomain<DynamicFilterId>> expectedTupleDomains = ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 0L, true, 100L, true)), false),\n+                        new DynamicFilterId(\"2\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 200L, true, 300L, true)), false))));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(BIGINT, COLOR, BIGINT), ImmutableList.of(largePage), expectedTupleDomains);\n+    }\n+\n+    @Test\n+    public void testMultipleColumnsCollectMinMaxWithNulls()\n+    {\n+        int maxPositionsCount = 100;\n+        Page largePage = new Page(\n+                createLongsBlock(Collections.nCopies(100, null)),\n+                createLongSequenceBlock(200, 301));\n+\n+        List<TupleDomain<DynamicFilterId>> expectedTupleDomains = ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.none(BIGINT),\n+                        new DynamicFilterId(\"2\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 200L, true, 300L, true)), false))));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(BIGINT, BIGINT), ImmutableList.of(largePage), expectedTupleDomains);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYxNDM0Ng==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488614346", "bodyText": "could we simplify ranges, e.g:\n[0, maxPositionsCount],\n[maxPositionsCount + 1, 2 * maxPositionsCount],\n[2 *maxPositionsCount + 1, 3 * maxPositionsCount]\n\n?", "author": "sopel39", "createdAt": "2020-09-15T12:08:57Z", "path": "presto-main/src/test/java/io/prestosql/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -277,63 +381,146 @@ public void testCollectEmptyBuildSide()\n     }\n \n     @Test\n-    public void testCollectTooMuchRows()\n+    public void testSingleColumnCollectMinMaxRangeWhenTooManyPositions()\n     {\n-        int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n-        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+        int maxPositionsCount = 100;\n+        Page largePage = new Page(createLongSequenceBlock(0, maxPositionsCount + 1));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n-        verifyPassthrough(createOperator(operatorFactory),\n+        assertDynamicFilters(\n+                maxPositionsCount,\n                 ImmutableList.of(BIGINT),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+                ImmutableList.of(largePage),\n+                ImmutableList.of(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"),\n+                        Domain.create(\n+                                ValueSet.ofRanges(range(BIGINT, 0L, true, (long) maxPositionsCount, true)),\n+                                false)))));\n     }\n \n     @Test\n-    public void testCollectTooMuchBytesSingleColumn()\n+    public void testMultipleColumnsCollectMinMaxRangeWhenTooManyPositions()\n     {\n-        long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) maxByteSize + 1)));\n+        int maxPositionsCount = 300;\n+        Page largePage = new Page(\n+                createLongSequenceBlock(0, 101),\n+                createColorSequenceBlock(100, 201),\n+                createLongSequenceBlock(200, 301));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, VARCHAR));\n-        verifyPassthrough(createOperator(operatorFactory),\n+        List<TupleDomain<DynamicFilterId>> expectedTupleDomains = ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 0L, true, 100L, true)), false),\n+                        new DynamicFilterId(\"2\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 200L, true, 300L, true)), false))));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(BIGINT, COLOR, BIGINT), ImmutableList.of(largePage), expectedTupleDomains);\n+    }\n+\n+    @Test\n+    public void testMultipleColumnsCollectMinMaxWithNulls()\n+    {\n+        int maxPositionsCount = 100;\n+        Page largePage = new Page(\n+                createLongsBlock(Collections.nCopies(100, null)),\n+                createLongSequenceBlock(200, 301));\n+\n+        List<TupleDomain<DynamicFilterId>> expectedTupleDomains = ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.none(BIGINT),\n+                        new DynamicFilterId(\"2\"), Domain.create(ValueSet.ofRanges(\n+                                range(BIGINT, 200L, true, 300L, true)), false))));\n+        assertDynamicFilters(maxPositionsCount, ImmutableList.of(BIGINT, BIGINT), ImmutableList.of(largePage), expectedTupleDomains);\n+    }\n+\n+    @Test\n+    public void testSingleColumnCollectMinMaxRangeWhenTooManyBytes()\n+    {\n+        DataSize maxSize = DataSize.of(10, KILOBYTE);\n+        long maxByteSize = maxSize.toBytes();\n+        String largeText = \"A\".repeat((int) maxByteSize + 1);\n+        Page largePage = new Page(createStringsBlock(largeText));\n+\n+        assertDynamicFilters(\n+                100,\n+                maxSize,\n+                100,\n                 ImmutableList.of(VARCHAR),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+                ImmutableList.of(largePage),\n+                ImmutableList.of(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"),\n+                        Domain.create(\n+                                ValueSet.ofRanges(range(VARCHAR, utf8Slice(largeText), true, utf8Slice(largeText), true)),\n+                                false)))));\n     }\n \n     @Test\n-    public void testCollectTooMuchBytesMultipleColumns()\n+    public void testMultipleColumnsCollectMinMaxRangeWhenTooManyBytes()\n     {\n-        long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();\n-        Page largePage = new Page(createStringsBlock(\"A\".repeat((int) (maxByteSize / 2) + 1)),\n-                createStringsBlock(\"B\".repeat((int) (maxByteSize / 2) + 1)));\n+        DataSize maxSize = DataSize.of(10, KILOBYTE);\n+        long maxByteSize = maxSize.toBytes();\n+        String largeTextA = \"A\".repeat((int) (maxByteSize / 2) + 1);\n+        String largeTextB = \"B\".repeat((int) (maxByteSize / 2) + 1);\n+        Page largePage = new Page(createStringsBlock(largeTextA), createStringsBlock(largeTextB));\n \n-        OperatorFactory operatorFactory = createOperatorFactory(channel(0, VARCHAR),\n-                channel(1, VARCHAR));\n-        verifyPassthrough(createOperator(operatorFactory),\n+        List<TupleDomain<DynamicFilterId>> expectedTupleDomains = ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new DynamicFilterId(\"0\"), Domain.create(ValueSet.ofRanges(\n+                                range(VARCHAR, utf8Slice(largeTextA), true, utf8Slice(largeTextA), true)), false),\n+                        new DynamicFilterId(\"1\"), Domain.create(ValueSet.ofRanges(\n+                                range(VARCHAR, utf8Slice(largeTextB), true, utf8Slice(largeTextB), true)), false))));\n+        assertDynamicFilters(\n+                100,\n+                maxSize,\n+                100,\n                 ImmutableList.of(VARCHAR, VARCHAR),\n-                largePage);\n-        operatorFactory.noMoreOperators();\n-        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+                ImmutableList.of(largePage),\n+                expectedTupleDomains);\n+    }\n+\n+    @Test\n+    public void testCollectMultipleLargePages()\n+    {\n+        int maxPositionsCount = 100;\n+        Page page1 = new Page(createLongSequenceBlock(maxPositionsCount / 2, maxPositionsCount + (maxPositionsCount / 2) + 1));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyMjAwMw==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r488822003", "bodyText": "Simplified this to use numbers", "author": "raunaqmorarka", "createdAt": "2020-09-15T17:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYxNDM0Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyNjY2NQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r489426665", "bodyText": "upto which -> up to which", "author": "sopel39", "createdAt": "2020-09-16T13:14:24Z", "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -548,6 +549,11 @@ public SystemSessionProperties(\n                         \"Experimental: maximum number of bytes to be collected for dynamic filtering per-driver\",\n                         featuresConfig.getDynamicFilteringMaxPerDriverSize(),\n                         false),\n+                integerProperty(\n+                        DYNAMIC_FILTERING_RANGE_ROW_LIMIT_PER_DRIVER,\n+                        \"Maximum number of build-side rows per driver upto which min and max values will be collected for dynamic filtering\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyNjk3NQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r489426975", "bodyText": "dynamic_filtering_min_max_limit_per_driver -> dynamic_filtering_range_row_limit_per_driver`", "author": "sopel39", "createdAt": "2020-09-16T13:14:54Z", "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -121,6 +121,7 @@\n     public static final String QUERY_MAX_TOTAL_MEMORY_PER_NODE = \"query_max_total_memory_per_node\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_ROW_COUNT = \"dynamic_filtering_max_per_driver_row_count\";\n     public static final String DYNAMIC_FILTERING_MAX_PER_DRIVER_SIZE = \"dynamic_filtering_max_per_driver_size\";\n+    public static final String DYNAMIC_FILTERING_RANGE_ROW_LIMIT_PER_DRIVER = \"dynamic_filtering_min_max_limit_per_driver\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyOTgyMg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r489429822", "bodyText": "Just leave minValues == null as  in other places", "author": "sopel39", "createdAt": "2020-09-16T13:18:50Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -233,11 +346,34 @@ public void finish()\n             return;\n         }\n         finished = true;\n+        ImmutableMap.Builder<DynamicFilterId, Domain> domainsBuilder = new ImmutableMap.Builder<>();\n         if (valueSets == null) {\n-            return; // the predicate became too large.\n+            if (minValues == null || maxValues == null) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzMTQ5MA==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r489431490", "bodyText": "minValues = null;\n            maxValues = null;\n\nis missing.\nOkey, maybe let's just use:\ndomainsBuilder.put(channels.get(channelIndex).filterId, Domain.none(type));\ncontinue;", "author": "sopel39", "createdAt": "2020-09-16T13:21:10Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -233,11 +346,34 @@ public void finish()\n             return;\n         }\n         finished = true;\n+        ImmutableMap.Builder<DynamicFilterId, Domain> domainsBuilder = new ImmutableMap.Builder<>();\n         if (valueSets == null) {\n-            return; // the predicate became too large.\n+            if (minValues == null || maxValues == null) {\n+                // there were too many rows to collect collect min/max range\n+                // dynamicPredicateConsumer was notified with 'all' in handleTooLargePredicate if there are no orderable types,\n+                // else it was notified with 'all' in handleMinMaxCollectionLimitExceeded\n+                return;\n+            }\n+            // valueSets became too large, create TupleDomain from min/max values\n+            for (Integer channelIndex : minMaxChannels) {\n+                Type type = channels.get(channelIndex).type;\n+                if (minValues[channelIndex] == null) {\n+                    // all values were null\n+                    dynamicPredicateConsumer.accept(TupleDomain.none());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzMzMzMQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r489433331", "bodyText": "it looks like it might be flaky too, let's see", "author": "sopel39", "createdAt": "2020-09-16T13:23:49Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -103,14 +103,22 @@ public void testJoinDynamicFilteringNone()\n     }\n \n     @Test\n-    public void testJoinLargeBuildSideNoDynamicFiltering()\n+    public void testJoinLargeBuildSideDynamicFiltering()\n     {\n+        @Language(\"SQL\") String sql = \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey and orders.custkey BETWEEN 300 AND 700\";\n+        int expectedRowCount = 15793;\n         // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n         assertDynamicFiltering(\n-                \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey\",\n+                sql,\n                 withBroadcastJoin(),\n-                toIntExact(LINEITEM_COUNT),\n+                expectedRowCount,\n                 ImmutableSet.of(LINEITEM_COUNT, ORDERS_COUNT));\n+        // Probe-side is partially scanned because we extract min/max from large build-side for dynamic filtering", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "c862d11ff71adb777b0e648fdc06716555199ca3", "url": "https://github.com/trinodb/trino/commit/c862d11ff71adb777b0e648fdc06716555199ca3", "message": "Add SQL annotation to test method", "committedDate": "2020-09-16T15:38:52Z", "type": "commit"}, {"oid": "2e84ee064381d3007b49776e1ebab55385c75a98", "url": "https://github.com/trinodb/trino/commit/2e84ee064381d3007b49776e1ebab55385c75a98", "message": "Add createColorSequenceBlock in BlockAssertions", "committedDate": "2020-09-16T15:38:52Z", "type": "commit"}, {"oid": "32ce86b760180749672ea0b0df579756f02519be", "url": "https://github.com/trinodb/trino/commit/32ce86b760180749672ea0b0df579756f02519be", "message": "Implement collection of min/max values in DynamicFilterSourceOperator\n\nAdded a flag dynamic-filtering-range-row-limit-per-driver to allow collection of\nmin and max values for dynamic filtering upto a given per driver row count\nwhen build side exceeds dynamic-filtering-max-per-driver-row-count or\ndynamic-filtering-max-per-driver-size thresholds", "committedDate": "2020-09-16T15:40:24Z", "type": "commit"}, {"oid": "32ce86b760180749672ea0b0df579756f02519be", "url": "https://github.com/trinodb/trino/commit/32ce86b760180749672ea0b0df579756f02519be", "message": "Implement collection of min/max values in DynamicFilterSourceOperator\n\nAdded a flag dynamic-filtering-range-row-limit-per-driver to allow collection of\nmin and max values for dynamic filtering upto a given per driver row count\nwhen build side exceeds dynamic-filtering-max-per-driver-row-count or\ndynamic-filtering-max-per-driver-size thresholds", "committedDate": "2020-09-16T15:40:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzOTE3OQ==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r490139179", "bodyText": "put this at method begin", "author": "sopel39", "createdAt": "2020-09-17T10:29:42Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +252,84 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxChannels.isEmpty()) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());\n+        }\n+        else {\n+            if (minMaxCollectionLimit < 0) {\n+                handleMinMaxCollectionLimitExceeded();\n+            }\n+            else {\n+                // convert to min/max per column for orderable types\n+                for (Integer channelIndex : minMaxChannels) {\n+                    Block block = blockBuilders[channelIndex].build();\n+                    updateMinMaxValues(block, channelIndex);\n+                }\n+            }\n+        }\n         // Drop references to collected values.", "originalCommit": "32ce86b760180749672ea0b0df579756f02519be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzOTIzMg==", "url": "https://github.com/trinodb/trino/pull/3871#discussion_r490139232", "bodyText": "let's flatten this section:\n// Drop references to collected values.\nvalueSets = null;\nblockBuilders = null;\n\nif (minMaxChannels.isEmpty()) {\n  // allow all probe-side values to be read.\n  dynamicPredicateConsumer.accept(TupleDomain.all());\n  return;\n}\n\nif (minMaxCollectionLimit < 0) {\n  handleMinMaxCollectionLimitExceeded();\n  return;\n}\n\n// convert to min/max per column for orderable types\nfor (Integer channelIndex : minMaxChannels) {\n  Block block = blockBuilders[channelIndex].build();\n  updateMinMaxValues(block, channelIndex);\n}", "author": "sopel39", "createdAt": "2020-09-17T10:29:47Z", "path": "presto-main/src/main/java/io/prestosql/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -210,13 +252,84 @@ public void addInput(Page page)\n \n     private void handleTooLargePredicate()\n     {\n-        // The resulting predicate is too large, allow all probe-side values to be read.\n-        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // The resulting predicate is too large\n+        if (minMaxChannels.isEmpty()) {\n+            // allow all probe-side values to be read.\n+            dynamicPredicateConsumer.accept(TupleDomain.all());", "originalCommit": "32ce86b760180749672ea0b0df579756f02519be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}