{"pr_number": 3376, "pr_title": "Support filter push down in Big Query", "pr_createdAt": "2020-04-07T20:34:49Z", "pr_url": "https://github.com/trinodb/trino/pull/3376", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5MjA1MQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406992051", "bodyText": "Indentation is off", "author": "martint", "createdAt": "2020-04-11T00:25:05Z", "path": "presto-bigquery/pom.xml", "diffHunk": "@@ -14,25 +14,40 @@\n \n     <properties>\n         <air.main.basedir>${project.parent.basedir}</air.main.basedir>\n-        <dep.gax.version>1.49.1</dep.gax.version>\n-        <dep.google-auth-library.version>0.18.0</dep.google-auth-library.version>\n-        <dep.google-cloud-core.version>1.91.3</dep.google-cloud-core.version>\n     </properties>\n \n     <dependencyManagement>\n         <dependencies>\n             <dependency>\n-                <groupId>com.google.api.grpc</groupId>\n-                <artifactId>proto-google-common-protos</artifactId>\n-                <version>1.17.0</version>\n+                <groupId>com.google.cloud</groupId>\n+                    <artifactId>libraries-bom</artifactId>\n+                    <version>4.4.1</version>\n+                    <type>pom</type>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5MjIxNg==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406992216", "bodyText": "Remove the leading _ from the field name. We don't generally name fields and variables that way.", "author": "martint", "createdAt": "2020-04-11T00:26:27Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryColumnHandle.java", "diffHunk": "@@ -33,25 +33,53 @@\n public class BigQueryColumnHandle\n         implements ColumnHandle, BigQueryType.Adaptor\n {\n+    protected static final BigQueryColumnHandle _PARTITIONTIME = new BigQueryColumnHandle(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5MjQ5MQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406992491", "bodyText": "Did this method just move or something changed? Please pull the change to move it around into a separate commit so that it's easier to see what the logical changes associated with this commit are.", "author": "martint", "createdAt": "2020-04-11T00:28:28Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryConnectorModule.java", "diffHunk": "@@ -46,6 +46,22 @@ public static HeaderProvider createHeaderProvider(NodeManager nodeManager)\n         return FixedHeaderProvider.create(\"user-agent\", \"prestosql/\" + nodeManager.getCurrentNode().getVersion());\n     }\n \n+    // Note that at this point the config has been validated, which means that option 2 or option 3 will always be valid", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxMzIxNw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408313217", "bodyText": "Is this resolved?", "author": "martint", "createdAt": "2020-04-14T17:32:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5MjQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5Mjg0OQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406992849", "bodyText": "Are these changes related to supporting filter pushdown? If not, please pull them out into another commit to keep the unrelated logical changes separate.", "author": "martint", "createdAt": "2020-04-11T00:31:04Z", "path": "presto-bigquery/pom.xml", "diffHunk": "@@ -14,25 +14,40 @@\n \n     <properties>\n         <air.main.basedir>${project.parent.basedir}</air.main.basedir>\n-        <dep.gax.version>1.49.1</dep.gax.version>\n-        <dep.google-auth-library.version>0.18.0</dep.google-auth-library.version>\n-        <dep.google-cloud-core.version>1.91.3</dep.google-cloud-core.version>\n     </properties>\n \n     <dependencyManagement>\n         <dependencies>\n             <dependency>\n-                <groupId>com.google.api.grpc</groupId>\n-                <artifactId>proto-google-common-protos</artifactId>\n-                <version>1.17.0</version>\n+                <groupId>com.google.cloud</groupId>\n+                    <artifactId>libraries-bom</artifactId>\n+                    <version>4.4.1</version>\n+                    <type>pom</type>\n+                <scope>import</scope>\n             </dependency>\n \n             <dependency>\n-                <groupId>io.grpc</groupId>\n-                <artifactId>grpc-bom</artifactId>\n-                <version>1.24.1</version>\n-                <type>pom</type>\n-                <scope>import</scope>\n+                <groupId>com.google.errorprone</groupId>\n+                <artifactId>error_prone_annotations</artifactId>\n+                <version>2.3.4</version>\n+            </dependency>\n+\n+            <dependency>\n+                <groupId>com.google.guava</groupId>\n+                <artifactId>guava</artifactId>\n+                <version>28.2-jre</version>\n+            </dependency>\n+\n+            <dependency>\n+                <groupId>org.checkerframework</groupId>\n+                <artifactId>checker-qual</artifactId>\n+                <version>2.10.0</version>\n+            </dependency>\n+\n+            <dependency>\n+                <groupId>org.threeten</groupId>\n+                <artifactId>threetenbp</artifactId>\n+                <version>1.4.2</version>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5Mjk3OQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406992979", "bodyText": "This is part of the public interface of this class, so make it public.", "author": "martint", "createdAt": "2020-04-11T00:32:13Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI1MzY0Nw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r407253647", "bodyText": "Even for package protected class?", "author": "davidrabinowitz", "createdAt": "2020-04-12T21:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5Mjk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5MzAyMQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406993021", "bodyText": "This is part of the public interface of this class, so make it public.", "author": "martint", "createdAt": "2020-04-11T00:32:26Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI1MzYxMQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r407253611", "bodyText": "This class is package protected. I any case, the constructor was changed to private", "author": "davidrabinowitz", "createdAt": "2020-04-12T21:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5MzAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI1NjM1NA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r407256354", "bodyText": "Yes. Please see #3302 (comment)", "author": "martint", "createdAt": "2020-04-12T21:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5MzAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5MzI2NQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406993265", "bodyText": "We generally don't use final in local variables. Also, the variable is unnecessary. Just do return toConjuncts(columns)", "author": "martint", "createdAt": "2020-04-11T00:34:02Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(_PARTITIONDATE.getName(), _PARTITIONDATE.getName().toUpperCase())\n+                        .replace(_PARTITIONTIME.getName(), _PARTITIONTIME.getName().toUpperCase()));\n+    }\n+\n+    private String concat(List<String> clauses)\n+    {\n+        return clauses.isEmpty() ? null : clauses.stream().collect(joining(\" AND \"));\n+    }\n+\n+    private List<String> toConjuncts(Map<ColumnHandle, Domain> domains)\n+    {\n+        List<BigQueryColumnHandle> columns = domains.keySet().stream().map(BigQueryColumnHandle.class::cast).collect(toList());\n+        final List<String> conjuncts = toConjuncts(columns);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NDEwOA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406994108", "bodyText": "I'm not sure I understand what this is supposed to do. _PARTITIONDATE.getName() returns _PARTITIONDATE, so calling toUpperCase() is a no-op.\nRegardless, this is brittle. What if the name of the field appears in the middle of a value? The replacement should be done before the domain is converted into a string.", "author": "martint", "createdAt": "2020-04-11T00:39:56Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(_PARTITIONDATE.getName(), _PARTITIONDATE.getName().toUpperCase())\n+                        .replace(_PARTITIONTIME.getName(), _PARTITIONTIME.getName().toUpperCase()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI1Mzc5MQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r407253791", "bodyText": "I had issues with those two fields, as they are pseudo columns of insert time partitioned tables, and the fact that Presto change all the column names to lower case.", "author": "davidrabinowitz", "createdAt": "2020-04-12T21:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NDEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NDEyNQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406994125", "bodyText": "This can be final", "author": "martint", "createdAt": "2020-04-11T00:40:06Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NDI1Mw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406994253", "bodyText": "Remove this commented out code", "author": "martint", "createdAt": "2020-04-11T00:40:58Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(_PARTITIONDATE.getName(), _PARTITIONDATE.getName().toUpperCase())\n+                        .replace(_PARTITIONTIME.getName(), _PARTITIONTIME.getName().toUpperCase()));\n+    }\n+\n+    private String concat(List<String> clauses)\n+    {\n+        return clauses.isEmpty() ? null : clauses.stream().collect(joining(\" AND \"));\n+    }\n+\n+    private List<String> toConjuncts(Map<ColumnHandle, Domain> domains)\n+    {\n+        List<BigQueryColumnHandle> columns = domains.keySet().stream().map(BigQueryColumnHandle.class::cast).collect(toList());\n+        final List<String> conjuncts = toConjuncts(columns);\n+        return conjuncts;\n+    }\n+\n+    private List<String> toConjuncts(List<BigQueryColumnHandle> columns)\n+    {\n+        if (tupleDomain.isNone()) {\n+            return ImmutableList.of(\"FALSE\");\n+        }\n+        ImmutableList.Builder<String> clauses = ImmutableList.builder();\n+        for (BigQueryColumnHandle column : columns) {\n+            Domain domain = tupleDomain.getDomains().get().get(column);\n+            if (domain != null) {\n+                //domain = pushDownDomain(column, domain);\n+                clauses.add(toPredicate(column.getName(), domain, column));\n+            }\n+        }\n+        return clauses.build();\n+    }\n+\n+    private String toPredicate(String columnName, Domain domain, BigQueryColumnHandle column)\n+    {\n+        if (domain.getValues().isNone()) {\n+            return domain.isNullAllowed() ? quote(columnName) + \" IS NULL\" : \"FALSE\";\n+        }\n+\n+        if (domain.getValues().isAll()) {\n+            return domain.isNullAllowed() ? \"TRUE\" : quote(columnName) + \" IS NOT NULL\";\n+        }\n+\n+        List<String> disjuncts = new ArrayList<>();\n+        List<Object> singleValues = new ArrayList<>();\n+        for (Range range : domain.getValues().getRanges().getOrderedRanges()) {\n+            checkState(!range.isAll()); // Already checked\n+            if (range.isSingleValue()) {\n+                singleValues.add(range.getLow().getValue());\n+            }\n+            else {\n+                List<String> rangeConjuncts = new ArrayList<>();\n+                if (!range.getLow().isLowerUnbounded()) {\n+                    switch (range.getLow().getBound()) {\n+                        case ABOVE:\n+                            rangeConjuncts.add(toPredicate(columnName, \">\", range.getLow().getValue(), column));\n+                            break;\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \">=\", range.getLow().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            throw new IllegalArgumentException(\"Low marker should never use BELOW bound\");\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getLow().getBound());\n+                    }\n+                }\n+                if (!range.getHigh().isUpperUnbounded()) {\n+                    switch (range.getHigh().getBound()) {\n+                        case ABOVE:\n+                            throw new IllegalArgumentException(\"High marker should never use ABOVE bound\");\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<=\", range.getHigh().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<\", range.getHigh().getValue(), column));\n+                            break;\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getHigh().getBound());\n+                    }\n+                }\n+                // If rangeConjuncts is null, then the range was ALL, which should already have been checked for\n+                checkState(!rangeConjuncts.isEmpty());\n+                disjuncts.add(\"(\" + Joiner.on(\" AND \").join(rangeConjuncts) + \")\");\n+            }\n+        }\n+\n+        // Add back all of the possible single values either as an equality or an IN predicate\n+        if (singleValues.size() == 1) {\n+            disjuncts.add(toPredicate(columnName, \"=\", getOnlyElement(singleValues), column));\n+        }\n+        else if (singleValues.size() > 1) {\n+            String values = singleValues.stream()\n+                    .map(value -> column.getBigQueryType().convertToString(value))\n+                    .collect(joining(\",\"));\n+            disjuncts.add(quote(columnName) + \" IN (\" + values + \")\");\n+        }\n+\n+        // Add nullability disjuncts\n+        checkState(!disjuncts.isEmpty());\n+        if (domain.isNullAllowed()) {\n+            disjuncts.add(quote(columnName) + \" IS NULL\");\n+        }\n+\n+        return disjuncts.stream().collect(joining(\" OR \", \"(\", \")\"));\n+    }\n+\n+    private String toPredicate(String columnName, String operator, Object value, BigQueryColumnHandle column)\n+    {\n+        String valueAsString = column.getBigQueryType().convertToString(value);\n+        return quote(columnName) + \" \" + operator + \" \" + valueAsString;\n+    }\n+\n+    private String quote(String name)\n+    {\n+        return QUOTE + name.replace(QUOTE, ESCAPED_QUOTE) + QUOTE;\n+    }\n+\n+    private static class TypeAndValue\n+    {\n+        private final Type type;\n+        private final Object value;\n+\n+        public TypeAndValue(Type type, Object value)\n+        {\n+            this.type = requireNonNull(type, \"type is null\");\n+            this.value = requireNonNull(value, \"value is null\");\n+        }\n+\n+        public Type getType()\n+        {\n+            return type;\n+        }\n+\n+        public Object getValue()\n+        {\n+            return value;\n+        }\n+    }\n+\n+//    private static Domain pushDownDomain(BigQueryColumnHandle column, Domain domain)\n+//    {\n+//        return column.get())\n+//                .orElseThrow(() -> new IllegalStateException(format(\"Unsupported type %s with handle %s\", column.getColumnType(), column.getJdbcTypeHandle())))\n+//            .getPushdownConverter().apply(domain);\n+//    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NDI2OQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406994269", "bodyText": "This class is unused", "author": "martint", "createdAt": "2020-04-11T00:41:09Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(_PARTITIONDATE.getName(), _PARTITIONDATE.getName().toUpperCase())\n+                        .replace(_PARTITIONTIME.getName(), _PARTITIONTIME.getName().toUpperCase()));\n+    }\n+\n+    private String concat(List<String> clauses)\n+    {\n+        return clauses.isEmpty() ? null : clauses.stream().collect(joining(\" AND \"));\n+    }\n+\n+    private List<String> toConjuncts(Map<ColumnHandle, Domain> domains)\n+    {\n+        List<BigQueryColumnHandle> columns = domains.keySet().stream().map(BigQueryColumnHandle.class::cast).collect(toList());\n+        final List<String> conjuncts = toConjuncts(columns);\n+        return conjuncts;\n+    }\n+\n+    private List<String> toConjuncts(List<BigQueryColumnHandle> columns)\n+    {\n+        if (tupleDomain.isNone()) {\n+            return ImmutableList.of(\"FALSE\");\n+        }\n+        ImmutableList.Builder<String> clauses = ImmutableList.builder();\n+        for (BigQueryColumnHandle column : columns) {\n+            Domain domain = tupleDomain.getDomains().get().get(column);\n+            if (domain != null) {\n+                //domain = pushDownDomain(column, domain);\n+                clauses.add(toPredicate(column.getName(), domain, column));\n+            }\n+        }\n+        return clauses.build();\n+    }\n+\n+    private String toPredicate(String columnName, Domain domain, BigQueryColumnHandle column)\n+    {\n+        if (domain.getValues().isNone()) {\n+            return domain.isNullAllowed() ? quote(columnName) + \" IS NULL\" : \"FALSE\";\n+        }\n+\n+        if (domain.getValues().isAll()) {\n+            return domain.isNullAllowed() ? \"TRUE\" : quote(columnName) + \" IS NOT NULL\";\n+        }\n+\n+        List<String> disjuncts = new ArrayList<>();\n+        List<Object> singleValues = new ArrayList<>();\n+        for (Range range : domain.getValues().getRanges().getOrderedRanges()) {\n+            checkState(!range.isAll()); // Already checked\n+            if (range.isSingleValue()) {\n+                singleValues.add(range.getLow().getValue());\n+            }\n+            else {\n+                List<String> rangeConjuncts = new ArrayList<>();\n+                if (!range.getLow().isLowerUnbounded()) {\n+                    switch (range.getLow().getBound()) {\n+                        case ABOVE:\n+                            rangeConjuncts.add(toPredicate(columnName, \">\", range.getLow().getValue(), column));\n+                            break;\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \">=\", range.getLow().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            throw new IllegalArgumentException(\"Low marker should never use BELOW bound\");\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getLow().getBound());\n+                    }\n+                }\n+                if (!range.getHigh().isUpperUnbounded()) {\n+                    switch (range.getHigh().getBound()) {\n+                        case ABOVE:\n+                            throw new IllegalArgumentException(\"High marker should never use ABOVE bound\");\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<=\", range.getHigh().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<\", range.getHigh().getValue(), column));\n+                            break;\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getHigh().getBound());\n+                    }\n+                }\n+                // If rangeConjuncts is null, then the range was ALL, which should already have been checked for\n+                checkState(!rangeConjuncts.isEmpty());\n+                disjuncts.add(\"(\" + Joiner.on(\" AND \").join(rangeConjuncts) + \")\");\n+            }\n+        }\n+\n+        // Add back all of the possible single values either as an equality or an IN predicate\n+        if (singleValues.size() == 1) {\n+            disjuncts.add(toPredicate(columnName, \"=\", getOnlyElement(singleValues), column));\n+        }\n+        else if (singleValues.size() > 1) {\n+            String values = singleValues.stream()\n+                    .map(value -> column.getBigQueryType().convertToString(value))\n+                    .collect(joining(\",\"));\n+            disjuncts.add(quote(columnName) + \" IN (\" + values + \")\");\n+        }\n+\n+        // Add nullability disjuncts\n+        checkState(!disjuncts.isEmpty());\n+        if (domain.isNullAllowed()) {\n+            disjuncts.add(quote(columnName) + \" IS NULL\");\n+        }\n+\n+        return disjuncts.stream().collect(joining(\" OR \", \"(\", \")\"));\n+    }\n+\n+    private String toPredicate(String columnName, String operator, Object value, BigQueryColumnHandle column)\n+    {\n+        String valueAsString = column.getBigQueryType().convertToString(value);\n+        return quote(columnName) + \" \" + operator + \" \" + valueAsString;\n+    }\n+\n+    private String quote(String name)\n+    {\n+        return QUOTE + name.replace(QUOTE, ESCAPED_QUOTE) + QUOTE;\n+    }\n+\n+    private static class TypeAndValue", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NDY2Mg==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406994662", "bodyText": "Based on how this class is used, I don't think it should be instantiable. There's no benefit from having instances or holding state internally. Instead of:\nOptional<String> filter = new BigQueryFilterQueryBuilder(constraint).buildFilter();\nI would change it so that the caller does:\nOptional<String> filter = BigQueryFilterQueryBuilder.buildFilter(constraint);", "author": "martint", "createdAt": "2020-04-11T00:43:55Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI1MzUzNg==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r407253536", "bodyText": "Having an helper object actually helps the implementation in my perspective, but I've changed the interface", "author": "davidrabinowitz", "createdAt": "2020-04-12T21:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NDY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NTA5Mw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406995093", "bodyText": "If this method returns null, it will cause a NullPointerException in the buildFilter method due to:\n.map(this::concat)\n.map(filter -> filter.replace(...))\n\nIf an empty list of clauses is an invalid condition, just add a checkArgument call that verifies that and reports a proper error.", "author": "martint", "createdAt": "2020-04-11T00:47:15Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(_PARTITIONDATE.getName(), _PARTITIONDATE.getName().toUpperCase())\n+                        .replace(_PARTITIONTIME.getName(), _PARTITIONTIME.getName().toUpperCase()));\n+    }\n+\n+    private String concat(List<String> clauses)\n+    {\n+        return clauses.isEmpty() ? null : clauses.stream().collect(joining(\" AND \"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NzE1NA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406997154", "bodyText": "Instead of\nclauses.stream().collect(joining(\" AND \"))\ndo\nString.join(\" AND \", clauses)", "author": "martint", "createdAt": "2020-04-11T01:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI1NDU0NA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r407254544", "bodyText": "Can you please have a second look? Optional.map() returns Optional.empty() if the mapper function returns a null value, not Optional.of(null).", "author": "davidrabinowitz", "createdAt": "2020-04-12T21:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI1NjY2Mw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r407256663", "bodyText": "Yes, you're right!", "author": "martint", "createdAt": "2020-04-12T21:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NTE0Mw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406995143", "bodyText": "Remove commented out code", "author": "martint", "createdAt": "2020-04-11T00:47:38Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(_PARTITIONDATE.getName(), _PARTITIONDATE.getName().toUpperCase())\n+                        .replace(_PARTITIONTIME.getName(), _PARTITIONTIME.getName().toUpperCase()));\n+    }\n+\n+    private String concat(List<String> clauses)\n+    {\n+        return clauses.isEmpty() ? null : clauses.stream().collect(joining(\" AND \"));\n+    }\n+\n+    private List<String> toConjuncts(Map<ColumnHandle, Domain> domains)\n+    {\n+        List<BigQueryColumnHandle> columns = domains.keySet().stream().map(BigQueryColumnHandle.class::cast).collect(toList());\n+        final List<String> conjuncts = toConjuncts(columns);\n+        return conjuncts;\n+    }\n+\n+    private List<String> toConjuncts(List<BigQueryColumnHandle> columns)\n+    {\n+        if (tupleDomain.isNone()) {\n+            return ImmutableList.of(\"FALSE\");\n+        }\n+        ImmutableList.Builder<String> clauses = ImmutableList.builder();\n+        for (BigQueryColumnHandle column : columns) {\n+            Domain domain = tupleDomain.getDomains().get().get(column);\n+            if (domain != null) {\n+                //domain = pushDownDomain(column, domain);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NjkwNA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406996904", "bodyText": "Use concat() to join the conjuncts?", "author": "martint", "createdAt": "2020-04-11T01:00:47Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(_PARTITIONDATE.getName(), _PARTITIONDATE.getName().toUpperCase())\n+                        .replace(_PARTITIONTIME.getName(), _PARTITIONTIME.getName().toUpperCase()));\n+    }\n+\n+    private String concat(List<String> clauses)\n+    {\n+        return clauses.isEmpty() ? null : clauses.stream().collect(joining(\" AND \"));\n+    }\n+\n+    private List<String> toConjuncts(Map<ColumnHandle, Domain> domains)\n+    {\n+        List<BigQueryColumnHandle> columns = domains.keySet().stream().map(BigQueryColumnHandle.class::cast).collect(toList());\n+        final List<String> conjuncts = toConjuncts(columns);\n+        return conjuncts;\n+    }\n+\n+    private List<String> toConjuncts(List<BigQueryColumnHandle> columns)\n+    {\n+        if (tupleDomain.isNone()) {\n+            return ImmutableList.of(\"FALSE\");\n+        }\n+        ImmutableList.Builder<String> clauses = ImmutableList.builder();\n+        for (BigQueryColumnHandle column : columns) {\n+            Domain domain = tupleDomain.getDomains().get().get(column);\n+            if (domain != null) {\n+                //domain = pushDownDomain(column, domain);\n+                clauses.add(toPredicate(column.getName(), domain, column));\n+            }\n+        }\n+        return clauses.build();\n+    }\n+\n+    private String toPredicate(String columnName, Domain domain, BigQueryColumnHandle column)\n+    {\n+        if (domain.getValues().isNone()) {\n+            return domain.isNullAllowed() ? quote(columnName) + \" IS NULL\" : \"FALSE\";\n+        }\n+\n+        if (domain.getValues().isAll()) {\n+            return domain.isNullAllowed() ? \"TRUE\" : quote(columnName) + \" IS NOT NULL\";\n+        }\n+\n+        List<String> disjuncts = new ArrayList<>();\n+        List<Object> singleValues = new ArrayList<>();\n+        for (Range range : domain.getValues().getRanges().getOrderedRanges()) {\n+            checkState(!range.isAll()); // Already checked\n+            if (range.isSingleValue()) {\n+                singleValues.add(range.getLow().getValue());\n+            }\n+            else {\n+                List<String> rangeConjuncts = new ArrayList<>();\n+                if (!range.getLow().isLowerUnbounded()) {\n+                    switch (range.getLow().getBound()) {\n+                        case ABOVE:\n+                            rangeConjuncts.add(toPredicate(columnName, \">\", range.getLow().getValue(), column));\n+                            break;\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \">=\", range.getLow().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            throw new IllegalArgumentException(\"Low marker should never use BELOW bound\");\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getLow().getBound());\n+                    }\n+                }\n+                if (!range.getHigh().isUpperUnbounded()) {\n+                    switch (range.getHigh().getBound()) {\n+                        case ABOVE:\n+                            throw new IllegalArgumentException(\"High marker should never use ABOVE bound\");\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<=\", range.getHigh().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<\", range.getHigh().getValue(), column));\n+                            break;\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getHigh().getBound());\n+                    }\n+                }\n+                // If rangeConjuncts is null, then the range was ALL, which should already have been checked for\n+                checkState(!rangeConjuncts.isEmpty());\n+                disjuncts.add(\"(\" + Joiner.on(\" AND \").join(rangeConjuncts) + \")\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NzMyOQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406997329", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .map(value -> column.getBigQueryType().convertToString(value))\n          \n          \n            \n                                .map(column.getBigQueryType()::convertToString)", "author": "martint", "createdAt": "2020-04-11T01:04:40Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(_PARTITIONDATE.getName(), _PARTITIONDATE.getName().toUpperCase())\n+                        .replace(_PARTITIONTIME.getName(), _PARTITIONTIME.getName().toUpperCase()));\n+    }\n+\n+    private String concat(List<String> clauses)\n+    {\n+        return clauses.isEmpty() ? null : clauses.stream().collect(joining(\" AND \"));\n+    }\n+\n+    private List<String> toConjuncts(Map<ColumnHandle, Domain> domains)\n+    {\n+        List<BigQueryColumnHandle> columns = domains.keySet().stream().map(BigQueryColumnHandle.class::cast).collect(toList());\n+        final List<String> conjuncts = toConjuncts(columns);\n+        return conjuncts;\n+    }\n+\n+    private List<String> toConjuncts(List<BigQueryColumnHandle> columns)\n+    {\n+        if (tupleDomain.isNone()) {\n+            return ImmutableList.of(\"FALSE\");\n+        }\n+        ImmutableList.Builder<String> clauses = ImmutableList.builder();\n+        for (BigQueryColumnHandle column : columns) {\n+            Domain domain = tupleDomain.getDomains().get().get(column);\n+            if (domain != null) {\n+                //domain = pushDownDomain(column, domain);\n+                clauses.add(toPredicate(column.getName(), domain, column));\n+            }\n+        }\n+        return clauses.build();\n+    }\n+\n+    private String toPredicate(String columnName, Domain domain, BigQueryColumnHandle column)\n+    {\n+        if (domain.getValues().isNone()) {\n+            return domain.isNullAllowed() ? quote(columnName) + \" IS NULL\" : \"FALSE\";\n+        }\n+\n+        if (domain.getValues().isAll()) {\n+            return domain.isNullAllowed() ? \"TRUE\" : quote(columnName) + \" IS NOT NULL\";\n+        }\n+\n+        List<String> disjuncts = new ArrayList<>();\n+        List<Object> singleValues = new ArrayList<>();\n+        for (Range range : domain.getValues().getRanges().getOrderedRanges()) {\n+            checkState(!range.isAll()); // Already checked\n+            if (range.isSingleValue()) {\n+                singleValues.add(range.getLow().getValue());\n+            }\n+            else {\n+                List<String> rangeConjuncts = new ArrayList<>();\n+                if (!range.getLow().isLowerUnbounded()) {\n+                    switch (range.getLow().getBound()) {\n+                        case ABOVE:\n+                            rangeConjuncts.add(toPredicate(columnName, \">\", range.getLow().getValue(), column));\n+                            break;\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \">=\", range.getLow().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            throw new IllegalArgumentException(\"Low marker should never use BELOW bound\");\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getLow().getBound());\n+                    }\n+                }\n+                if (!range.getHigh().isUpperUnbounded()) {\n+                    switch (range.getHigh().getBound()) {\n+                        case ABOVE:\n+                            throw new IllegalArgumentException(\"High marker should never use ABOVE bound\");\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<=\", range.getHigh().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<\", range.getHigh().getValue(), column));\n+                            break;\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getHigh().getBound());\n+                    }\n+                }\n+                // If rangeConjuncts is null, then the range was ALL, which should already have been checked for\n+                checkState(!rangeConjuncts.isEmpty());\n+                disjuncts.add(\"(\" + Joiner.on(\" AND \").join(rangeConjuncts) + \")\");\n+            }\n+        }\n+\n+        // Add back all of the possible single values either as an equality or an IN predicate\n+        if (singleValues.size() == 1) {\n+            disjuncts.add(toPredicate(columnName, \"=\", getOnlyElement(singleValues), column));\n+        }\n+        else if (singleValues.size() > 1) {\n+            String values = singleValues.stream()\n+                    .map(value -> column.getBigQueryType().convertToString(value))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NzUyNA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406997524", "bodyText": "Maybe:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return disjuncts.stream().collect(joining(\" OR \", \"(\", \")\"));\n          \n          \n            \n                    return \"(\" + String.join(\" OR \", disjuncts) + \")\";", "author": "martint", "createdAt": "2020-04-11T01:06:36Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle._PARTITIONTIME;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private TupleDomain<ColumnHandle> tupleDomain;\n+\n+    BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(_PARTITIONDATE.getName(), _PARTITIONDATE.getName().toUpperCase())\n+                        .replace(_PARTITIONTIME.getName(), _PARTITIONTIME.getName().toUpperCase()));\n+    }\n+\n+    private String concat(List<String> clauses)\n+    {\n+        return clauses.isEmpty() ? null : clauses.stream().collect(joining(\" AND \"));\n+    }\n+\n+    private List<String> toConjuncts(Map<ColumnHandle, Domain> domains)\n+    {\n+        List<BigQueryColumnHandle> columns = domains.keySet().stream().map(BigQueryColumnHandle.class::cast).collect(toList());\n+        final List<String> conjuncts = toConjuncts(columns);\n+        return conjuncts;\n+    }\n+\n+    private List<String> toConjuncts(List<BigQueryColumnHandle> columns)\n+    {\n+        if (tupleDomain.isNone()) {\n+            return ImmutableList.of(\"FALSE\");\n+        }\n+        ImmutableList.Builder<String> clauses = ImmutableList.builder();\n+        for (BigQueryColumnHandle column : columns) {\n+            Domain domain = tupleDomain.getDomains().get().get(column);\n+            if (domain != null) {\n+                //domain = pushDownDomain(column, domain);\n+                clauses.add(toPredicate(column.getName(), domain, column));\n+            }\n+        }\n+        return clauses.build();\n+    }\n+\n+    private String toPredicate(String columnName, Domain domain, BigQueryColumnHandle column)\n+    {\n+        if (domain.getValues().isNone()) {\n+            return domain.isNullAllowed() ? quote(columnName) + \" IS NULL\" : \"FALSE\";\n+        }\n+\n+        if (domain.getValues().isAll()) {\n+            return domain.isNullAllowed() ? \"TRUE\" : quote(columnName) + \" IS NOT NULL\";\n+        }\n+\n+        List<String> disjuncts = new ArrayList<>();\n+        List<Object> singleValues = new ArrayList<>();\n+        for (Range range : domain.getValues().getRanges().getOrderedRanges()) {\n+            checkState(!range.isAll()); // Already checked\n+            if (range.isSingleValue()) {\n+                singleValues.add(range.getLow().getValue());\n+            }\n+            else {\n+                List<String> rangeConjuncts = new ArrayList<>();\n+                if (!range.getLow().isLowerUnbounded()) {\n+                    switch (range.getLow().getBound()) {\n+                        case ABOVE:\n+                            rangeConjuncts.add(toPredicate(columnName, \">\", range.getLow().getValue(), column));\n+                            break;\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \">=\", range.getLow().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            throw new IllegalArgumentException(\"Low marker should never use BELOW bound\");\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getLow().getBound());\n+                    }\n+                }\n+                if (!range.getHigh().isUpperUnbounded()) {\n+                    switch (range.getHigh().getBound()) {\n+                        case ABOVE:\n+                            throw new IllegalArgumentException(\"High marker should never use ABOVE bound\");\n+                        case EXACTLY:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<=\", range.getHigh().getValue(), column));\n+                            break;\n+                        case BELOW:\n+                            rangeConjuncts.add(toPredicate(columnName, \"<\", range.getHigh().getValue(), column));\n+                            break;\n+                        default:\n+                            throw new AssertionError(\"Unhandled bound: \" + range.getHigh().getBound());\n+                    }\n+                }\n+                // If rangeConjuncts is null, then the range was ALL, which should already have been checked for\n+                checkState(!rangeConjuncts.isEmpty());\n+                disjuncts.add(\"(\" + Joiner.on(\" AND \").join(rangeConjuncts) + \")\");\n+            }\n+        }\n+\n+        // Add back all of the possible single values either as an equality or an IN predicate\n+        if (singleValues.size() == 1) {\n+            disjuncts.add(toPredicate(columnName, \"=\", getOnlyElement(singleValues), column));\n+        }\n+        else if (singleValues.size() > 1) {\n+            String values = singleValues.stream()\n+                    .map(value -> column.getBigQueryType().convertToString(value))\n+                    .collect(joining(\",\"));\n+            disjuncts.add(quote(columnName) + \" IN (\" + values + \")\");\n+        }\n+\n+        // Add nullability disjuncts\n+        checkState(!disjuncts.isEmpty());\n+        if (domain.isNullAllowed()) {\n+            disjuncts.add(quote(columnName) + \" IS NULL\");\n+        }\n+\n+        return disjuncts.stream().collect(joining(\" OR \", \"(\", \")\"));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5NzY4Ng==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406997686", "bodyText": "Remove this", "author": "martint", "createdAt": "2020-04-11T01:08:02Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryMetadata.java", "diffHunk": "@@ -138,6 +146,7 @@ private TableInfo getBigQueryTable(SchemaTableName tableName)\n \n     public ConnectorTableMetadata getTableMetadata(ConnectorSession session, SchemaTableName schemaTableName)\n     {\n+        log.debug(\"getTableMetadata(session=%s, schemaTableName=%s)\", session, schemaTableName);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5Nzc4MQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406997781", "bodyText": "Is this related to filter pushdown? If not, pull it out into a separate commit.", "author": "martint", "createdAt": "2020-04-11T01:08:39Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryMetadata.java", "diffHunk": "@@ -151,24 +160,57 @@ public ConnectorTableMetadata getTableMetadata(ConnectorSession session, Connect\n         log.debug(\"getTableMetadata(session=%s, tableHandle=%s)\", session, tableHandle);\n         TableInfo table = bigQueryClient.getTable(((BigQueryTableHandle) tableHandle).getTableId());\n         SchemaTableName schemaTableName = new SchemaTableName(table.getTableId().getDataset(), table.getTableId().getTable());\n-        Schema schema = table.getDefinition().getSchema();\n-        List<ColumnMetadata> columns = schema == null ?\n-                ImmutableList.of() :\n-                schema.getFields().stream()\n-                        .map(Conversions::toColumnMetadata)\n-                        .collect(toImmutableList());\n-        return new ConnectorTableMetadata(schemaTableName, columns);\n+        List<ColumnMetadata> columns = getTableColumns(table).stream()\n+                .map(BigQueryColumnHandle::getColumnMetadata)\n+                .collect(toList());\n+        ImmutableMap.Builder<String, Object> properties = ImmutableMap.builder();\n+        TableDefinition tableDefinition = table.getDefinition();\n+        if (tableDefinition instanceof StandardTableDefinition) {\n+            StandardTableDefinition standardTableDefinition = (StandardTableDefinition) tableDefinition;\n+            if (standardTableDefinition.getClustering() != null) {\n+                properties.put(\"clustering\", standardTableDefinition.getClustering().getFields());\n+            }\n+            if (standardTableDefinition.getRangePartitioning() != null) {\n+                properties.put(\"range_partitioning\", standardTableDefinition.getRangePartitioning().getField());\n+            }\n+            TimePartitioning timePartitioning = standardTableDefinition.getTimePartitioning();\n+            if (timePartitioning != null) {\n+                if (timePartitioning.getField() != null) {\n+                    properties.put(\"time_partitioning\", timePartitioning.getField());\n+                }\n+                else {\n+                    properties.put(\"time_partitioning\", _PARTITIONTIME.getName());\n+                }\n+            }\n+        }\n+        Optional<String> comment = Optional.ofNullable(table.getDescription());\n+        return new ConnectorTableMetadata(schemaTableName, columns, properties.build(), comment);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk5ODE5Mw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r406998193", "bodyText": "Formatting:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<String> filteredSelectedFields = selectedFields.stream().filter(BigQueryUtil::validColumnName).collect(toList());\n          \n          \n            \n                    List<String> filteredSelectedFields = selectedFields.stream()\n          \n          \n            \n                            .filter(BigQueryUtil::validColumnName)\n          \n          \n            \n                            .collect(toList());", "author": "martint", "createdAt": "2020-04-11T01:12:20Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/ReadSessionCreator.java", "diffHunk": "@@ -73,9 +75,11 @@ public ReadSessionCreator(\n \n         TableInfo actualTable = getActualTable(tableDetails, selectedFields, new String[] {});\n \n+        List<String> filteredSelectedFields = selectedFields.stream().filter(BigQueryUtil::validColumnName).collect(toList());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwMTM3Nw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408301377", "bodyText": "Remove commented out code", "author": "martint", "createdAt": "2020-04-14T17:13:34Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/ReadRowsHelper.java", "diffHunk": "@@ -73,4 +49,59 @@ public ReadRowsHelper(BigQueryStorageClient client, ReadRowsRequest.Builder requ\n                 .call(readRowsRequest.build())\n                 .iterator();\n     }\n+\n+    // Ported from https://github.com/GoogleCloudDataproc/spark-bigquery-connector/pull/150\n+    static class ReadRowsIterator\n+            implements Iterator<ReadRowsResponse>\n+    {\n+        ReadRowsHelper helper;\n+        Storage.StreamPosition.Builder readPosition;\n+        Iterator<ReadRowsResponse> serverResponses;\n+        long readRowsCount;\n+        int retries;\n+\n+        public ReadRowsIterator(\n+                ReadRowsHelper helper,\n+                Storage.StreamPosition.Builder readPosition,\n+                Iterator<ReadRowsResponse> serverResponses)\n+        {\n+            this.helper = helper;\n+            this.readPosition = readPosition;\n+            this.serverResponses = serverResponses;\n+        }\n+\n+        @Override\n+        public boolean hasNext()\n+        {\n+            return serverResponses.hasNext();\n+        }\n+\n+        @Override\n+        public ReadRowsResponse next()\n+        {\n+            do {\n+                try {\n+                    ReadRowsResponse response = serverResponses.next();\n+                    readRowsCount += response.getRowCount();\n+                    //logDebug(s\"read ${response.getSerializedSize} bytes\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwMzYwMg==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408303602", "bodyText": "This can be private", "author": "martint", "createdAt": "2020-04-14T17:17:06Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/ReadRowsHelper.java", "diffHunk": "@@ -73,4 +49,59 @@ public ReadRowsHelper(BigQueryStorageClient client, ReadRowsRequest.Builder requ\n                 .call(readRowsRequest.build())\n                 .iterator();\n     }\n+\n+    // Ported from https://github.com/GoogleCloudDataproc/spark-bigquery-connector/pull/150\n+    static class ReadRowsIterator", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwNDgwNQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408304805", "bodyText": "These can be private final", "author": "martint", "createdAt": "2020-04-14T17:18:57Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/ReadRowsHelper.java", "diffHunk": "@@ -73,4 +49,59 @@ public ReadRowsHelper(BigQueryStorageClient client, ReadRowsRequest.Builder requ\n                 .call(readRowsRequest.build())\n                 .iterator();\n     }\n+\n+    // Ported from https://github.com/GoogleCloudDataproc/spark-bigquery-connector/pull/150\n+    static class ReadRowsIterator\n+            implements Iterator<ReadRowsResponse>\n+    {\n+        ReadRowsHelper helper;\n+        Storage.StreamPosition.Builder readPosition;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwNDg5Mw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408304893", "bodyText": "These can be private", "author": "martint", "createdAt": "2020-04-14T17:19:05Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/ReadRowsHelper.java", "diffHunk": "@@ -73,4 +49,59 @@ public ReadRowsHelper(BigQueryStorageClient client, ReadRowsRequest.Builder requ\n                 .call(readRowsRequest.build())\n                 .iterator();\n     }\n+\n+    // Ported from https://github.com/GoogleCloudDataproc/spark-bigquery-connector/pull/150\n+    static class ReadRowsIterator\n+            implements Iterator<ReadRowsResponse>\n+    {\n+        ReadRowsHelper helper;\n+        Storage.StreamPosition.Builder readPosition;\n+        Iterator<ReadRowsResponse> serverResponses;\n+        long readRowsCount;\n+        int retries;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxMjY5OA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408312698", "bodyText": "Change the commit message to \"Improve readRows performance\"\nAlso, explain in the commit message improves performance. I see a refactoring, but I can't figure out what's the difference between the two versions that will improve performance.", "author": "martint", "createdAt": "2020-04-14T17:31:32Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/ReadRowsHelper.java", "diffHunk": "@@ -14,12 +14,12 @@\n package io.prestosql.plugin.bigquery;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMzU1NQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408513555", "bodyText": "@martint This change is a port from the spark connector - instead of reading the entire stream as Avro and them converting it to Presto pages, the read from the server is done in a lazy fashion using the new Iterator. We have seen performance improvement especially when reading part of the data (for example when using LIMIT)", "author": "davidrabinowitz", "createdAt": "2020-04-15T00:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxMjY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTk5NA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408515994", "bodyText": "Got it. Please add that explanation to the commit message", "author": "martint", "createdAt": "2020-04-15T00:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxMjY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNjg4Nw==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408516887", "bodyText": "Just did...", "author": "davidrabinowitz", "createdAt": "2020-04-15T00:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxMjY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNDgwNg==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408314806", "bodyText": "Annotate this with @VisibleForTesting", "author": "martint", "createdAt": "2020-04-14T17:34:54Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryColumnHandle.java", "diffHunk": "@@ -33,25 +33,53 @@\n public class BigQueryColumnHandle\n         implements ColumnHandle, BigQueryType.Adaptor\n {\n+    protected static final BigQueryColumnHandle PARTITIONTIME = new BigQueryColumnHandle(\n+            \"_PARTITIONTIME\",\n+            BigQueryType.TIMESTAMP,\n+            Field.Mode.NULLABLE,\n+            ImmutableList.of(),\n+            \"Partition column\",\n+            true);\n+    protected static final BigQueryColumnHandle PARTITIONDATE = new BigQueryColumnHandle(\n+            \"_PARTITIONDATE\",\n+            BigQueryType.DATE,\n+            Field.Mode.NULLABLE,\n+            ImmutableList.of(),\n+            \"Partition column\",\n+            true);\n+\n     private final String name;\n     private final BigQueryType bigQueryType;\n     private final Field.Mode mode;\n     private final List<BigQueryColumnHandle> subColumns;\n     private final String description;\n+    private final boolean hidden;\n \n     @JsonCreator\n     public BigQueryColumnHandle(\n             @JsonProperty(\"name\") String name,\n             @JsonProperty(\"bigQueryType\") BigQueryType bigQueryType,\n             @JsonProperty(\"mode\") Field.Mode mode,\n             @JsonProperty(\"subColumns\") List<BigQueryColumnHandle> subColumns,\n-            @JsonProperty(\"description\") String description)\n+            @JsonProperty(\"description\") String description,\n+            @JsonProperty(\"hidden\") boolean hidden)\n     {\n         this.name = requireNonNull(name, \"column name cannot be null\");\n         this.bigQueryType = requireNonNull(bigQueryType, () -> format(\"column type cannot be null for column [%s]\", name));\n         this.mode = requireNonNull(mode, \"Field mode cannot be null\");\n         this.subColumns = ImmutableList.copyOf(requireNonNull(subColumns, \"subColumns is null\"));\n         this.description = description;\n+        this.hidden = hidden;\n+    }\n+\n+    BigQueryColumnHandle(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNjc0NA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408316744", "bodyText": "I still don't understand how this is anything other than a no-op in its current form.", "author": "martint", "createdAt": "2020-04-14T17:38:13Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryFilterQueryBuilder.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.bigquery;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.TupleDomain;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle.PARTITIONDATE;\n+import static io.prestosql.plugin.bigquery.BigQueryColumnHandle.PARTITIONTIME;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+\n+class BigQueryFilterQueryBuilder\n+{\n+    private static final String QUOTE = \"`\";\n+    private static final String ESCAPED_QUOTE = \"``\";\n+    private final TupleDomain<ColumnHandle> tupleDomain;\n+\n+    public static Optional<String> buildFilter(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        return new BigQueryFilterQueryBuilder(tupleDomain).buildFilter();\n+    }\n+\n+    private BigQueryFilterQueryBuilder(TupleDomain<ColumnHandle> tupleDomain)\n+    {\n+        this.tupleDomain = tupleDomain;\n+    }\n+\n+    private Optional<String> buildFilter()\n+    {\n+        Optional<Map<ColumnHandle, Domain>> domains = tupleDomain.getDomains();\n+        return domains.map(this::toConjuncts)\n+                .map(this::concat)\n+                .map(filter -> filter\n+                        .replace(PARTITIONDATE.getName(), PARTITIONDATE.getName())\n+                        .replace(PARTITIONTIME.getName(), PARTITIONTIME.getName()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNzM5OA==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408317398", "bodyText": "Don't abbreviate variable name. Rename it to value", "author": "martint", "createdAt": "2020-04-14T17:39:13Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryType.java", "diffHunk": "@@ -133,6 +148,77 @@ static long toPrestoTimestamp(String datetime)\n         return toLocalDateTime(datetime).atZone(systemDefault()).toInstant().toEpochMilli();\n     }\n \n+    static String simpleToStringConverter(Object value)\n+    {\n+        return String.valueOf(value);\n+    }\n+\n+    static String dateToStringConverter(Object value)\n+    {\n+        LocalDate date = LocalDate.ofEpochDay(((Long) value).longValue());\n+        return quote(date.toString());\n+    }\n+\n+    static String datetimeToStringConverter(Object value)\n+    {\n+        return formatTimestamp(((Long) value).longValue(), systemDefault());\n+    }\n+\n+    static String timeToStringConverter(Object value)\n+    {\n+        long longValue = ((Long) value).longValue();\n+        long millisUtc = DateTimeEncoding.unpackMillisUtc(longValue);\n+        ZoneId zoneId = ZoneId.of(DateTimeEncoding.unpackZoneKey(longValue).getId());\n+        LocalTime time = toZonedDateTime(millisUtc, zoneId).toLocalTime();\n+        return quote(time.toString());\n+    }\n+\n+    static String timestampToStringConverter(Object value)\n+    {\n+        long longValue = ((Long) value).longValue();\n+        long millisUtc = DateTimeEncoding.unpackMillisUtc(longValue);\n+        ZoneId zoneId = ZoneId.of(DateTimeEncoding.unpackZoneKey(longValue).getId());\n+        return formatTimestamp(millisUtc, zoneId);\n+    }\n+\n+    private static String formatTimestamp(long millisUtc, ZoneId zoneId)\n+    {\n+        return DATETIME_FORMATTER.format(toZonedDateTime(millisUtc, zoneId));\n+    }\n+\n+    private static ZonedDateTime toZonedDateTime(long millisUtc, ZoneId zoneId)\n+    {\n+        return ZonedDateTime.ofInstant(Instant.ofEpochMilli(millisUtc), zoneId);\n+    }\n+\n+    static String stringToStringConverter(Object value)\n+    {\n+        Slice slice = (Slice) value;\n+        return quote(new String(slice.getBytes(), UTF_8));\n+    }\n+\n+    static String numericToStringConverter(Object value)\n+    {\n+        Slice slice = (Slice) value;\n+        return Decimals.toString(slice, NUMERIC_DATA_TYPE_SCALE);\n+    }\n+\n+    static String bytesToStringConverter(Object value)\n+    {\n+        Slice slice = (Slice) value;\n+        return format(\"FROM_BASE64('%s')\", Base64.getEncoder().encodeToString(slice.getBytes()));\n+    }\n+\n+    private static String quote(String s)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODA4NQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408318085", "bodyText": "This is not used", "author": "martint", "createdAt": "2020-04-14T17:40:23Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryUtil.java", "diffHunk": "@@ -51,4 +56,14 @@ static BigQueryException convertToBigQueryException(BigQueryError error)\n     {\n         return new BigQueryException(UNKNOWN_CODE, error.getMessage(), error);\n     }\n+\n+    static <T> Function<T, T> identity()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODYxMQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408318611", "bodyText": "Make it private. Also, use Set as the declared type.", "author": "martint", "createdAt": "2020-04-14T17:41:16Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryUtil.java", "diffHunk": "@@ -29,6 +31,9 @@\n             \"Connection closed with unknown cause\",\n             \"Received unexpected EOS on DATA frame from server\");\n \n+    static final ImmutableSet<String> INVALID_COLUMN_NAMES = ImmutableSet.<String>builder()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODk3MQ==", "url": "https://github.com/trinodb/trino/pull/3376#discussion_r408318971", "bodyText": "public", "author": "martint", "createdAt": "2020-04-14T17:41:45Z", "path": "presto-bigquery/src/main/java/io/prestosql/plugin/bigquery/BigQueryUtil.java", "diffHunk": "@@ -51,4 +56,14 @@ static BigQueryException convertToBigQueryException(BigQueryError error)\n     {\n         return new BigQueryException(UNKNOWN_CODE, error.getMessage(), error);\n     }\n+\n+    static <T> Function<T, T> identity()\n+    {\n+        return t -> t;\n+    }\n+\n+    static boolean validColumnName(String columnName)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "d9e0648cf39d1cdeca29f32f3813578a15e815da", "url": "https://github.com/trinodb/trino/commit/d9e0648cf39d1cdeca29f32f3813578a15e815da", "message": "Add support for filter pushdown to BigQuery", "committedDate": "2020-04-22T14:48:20Z", "type": "commit"}, {"oid": "4c3b0fd9c40eb7be911ec6b98deca9874f4de393", "url": "https://github.com/trinodb/trino/commit/4c3b0fd9c40eb7be911ec6b98deca9874f4de393", "message": "Improve readRows performance\n\nThis change is a port from the spark connector - instead of reading the entire stream\nas Avro and them converting it to Presto pages, the read from the server is done in a\nlazy fashion using the new Iterator. We have seen performance improvement especially\nwhen reading part of the data (for example when using LIMIT)", "committedDate": "2020-04-22T14:48:20Z", "type": "commit"}, {"oid": "4c3b0fd9c40eb7be911ec6b98deca9874f4de393", "url": "https://github.com/trinodb/trino/commit/4c3b0fd9c40eb7be911ec6b98deca9874f4de393", "message": "Improve readRows performance\n\nThis change is a port from the spark connector - instead of reading the entire stream\nas Avro and them converting it to Presto pages, the read from the server is done in a\nlazy fashion using the new Iterator. We have seen performance improvement especially\nwhen reading part of the data (for example when using LIMIT)", "committedDate": "2020-04-22T14:48:20Z", "type": "forcePushed"}]}