{"pr_number": 4144, "pr_title": "Support enforcement of NOT NULL column declarations", "pr_createdAt": "2020-06-22T14:10:02Z", "pr_url": "https://github.com/trinodb/trino/pull/4144", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0MzM4MQ==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443843381", "bodyText": "plan.getFieldMappings() is guaranteed to match the order of columns in plan.getScope().getRelationType() (i.e., the output \"shape\" of the query).\nThe planner is not the right place to match ColumnMetadata to fields, as there is no correspondence between those fields and the order in which the fields appear in the plan.\nFor instance, given a table t (a BIGINT, b BIGINT), the following query will see the fields in a different order: INSERT INTO t(b, a) VALUES (1, 10)\nThis should be handled during analysis. The analyzer should record which fields ordinals are supposed to be not null. Take a look at Analysis.JoinUsingAnalysis and callers for an example of how you might record that.", "author": "martint", "createdAt": "2020-06-22T21:44:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -448,6 +453,18 @@ else if (isUsePreferredWritePartitioning(session)) {\n             }\n         }\n \n+        // TODO: Is this too fragile?  Other places we depend on the correspondence between order\n+        //  of non-hidden columns and order of symbols, but it feels a little grotty.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg3NDQ4Nw==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443874487", "bodyText": "Ok, I'll look there.", "author": "djsstarburst", "createdAt": "2020-06-22T23:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0MzM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1NTIyMQ==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443955221", "bodyText": "@martint The two callers of this method in this class fetch the columns names from table metadata. Are they wrong as well?", "author": "electrum", "createdAt": "2020-06-23T04:32:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0MzM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk3MzA5MA==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443973090", "bodyText": "For CREATE TABLE AS ... it kind of works out because the metadata is derived from the CREATE TABLE statement. For INSERT INTO, it works because it creates a projection to match the layout of the table metadata. Unfortunately, it relies on projectNode.getOutputSymbols(), which is not guaranteed to come out in the desired order -- it just happens to work today.", "author": "martint", "createdAt": "2020-06-23T05:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0MzM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwODU5NA==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r445108594", "bodyText": "@martint, I believe I've addressed your concern in the latest force push of the commit.  The code no longer expects channel order to match column order, and I added a unit test that exercises your INSERT INTO t(b, a) example", "author": "djsstarburst", "createdAt": "2020-06-24T19:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0MzM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0OTQ0Mw==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443949443", "bodyText": "For SQL formatting, add spaces before opening parenthesis: VALUES (2)", "author": "electrum", "createdAt": "2020-06-23T04:07:18Z", "path": "presto-iceberg/src/test/java/io/prestosql/plugin/iceberg/TestIcebergSmoke.java", "diffHunk": "@@ -324,6 +324,16 @@ public void testSchemaEvolution()\n         testWithAllFileFormats(this::testSchemaEvolution);\n     }\n \n+    @Test\n+    public void testInsertIntoNotNullColumn()\n+    {\n+        assertUpdate(\"CREATE TABLE test_not_null_table (c1 INTEGER, c2 INTEGER NOT NULL)\");\n+        assertUpdate(\"INSERT INTO test_not_null_table (c2) VALUES(2)\", 1);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwODczNQ==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r445108735", "bodyText": "Done in the latest force push.", "author": "djsstarburst", "createdAt": "2020-06-24T19:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0OTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MDg1NA==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443950854", "bodyText": "We should do this inside the check for not-null channels, since this is logically an optimization of checking the block for nulls. For nullable channels, we don't need to look at this.", "author": "electrum", "createdAt": "2020-06-23T04:13:23Z", "path": "presto-main/src/main/java/io/prestosql/operator/TableWriterOperator.java", "diffHunk": "@@ -227,7 +236,14 @@ public void addInput(Page page)\n \n         Block[] blocks = new Block[columnChannels.size()];\n         for (int outputChannel = 0; outputChannel < columnChannels.size(); outputChannel++) {\n-            blocks[outputChannel] = page.getBlock(columnChannels.get(outputChannel));\n+            Block block = page.getBlock(columnChannels.get(outputChannel));\n+            if (block.mayHaveNull()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwODgzMg==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r445108832", "bodyText": "Done in the latest force push.", "author": "djsstarburst", "createdAt": "2020-06-24T19:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MDg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MDg2Nw==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443950867", "bodyText": "Doing a map lookup for every channel could have a non-trivial cost, especially since we have to box the channel integer key. I think it would be better to use a List<String> with null values for the nullable columns, making the lookup basically free.", "author": "electrum", "createdAt": "2020-06-23T04:13:28Z", "path": "presto-main/src/main/java/io/prestosql/operator/TableWriterOperator.java", "diffHunk": "@@ -227,7 +236,14 @@ public void addInput(Page page)\n \n         Block[] blocks = new Block[columnChannels.size()];\n         for (int outputChannel = 0; outputChannel < columnChannels.size(); outputChannel++) {\n-            blocks[outputChannel] = page.getBlock(columnChannels.get(outputChannel));\n+            Block block = page.getBlock(columnChannels.get(outputChannel));\n+            if (block.mayHaveNull()) {\n+                String columnName = notNullChannelColumnNames.get(outputChannel);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMDU4NQ==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r445110585", "bodyText": "Done in the latest force push.  However, nulls are illegal in ImmutableLists, so in TestTableWriterOperation I had to create an ArrayList.\nI thought of creating Optionals, but the main cost of Map lookup is cacheline bounces, and adding Optionals will also result in cacheline bounces.", "author": "djsstarburst", "createdAt": "2020-06-24T19:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MDg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MTY4Mw==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443951683", "bodyText": "The block check logically fits better here\nif (!block.mayHaveNull()) {\n    return;\n}", "author": "electrum", "createdAt": "2020-06-23T04:16:50Z", "path": "presto-main/src/main/java/io/prestosql/operator/TableWriterOperator.java", "diffHunk": "@@ -243,6 +259,15 @@ public void addInput(Page page)\n         updateWrittenBytes();\n     }\n \n+    private void verifyBlockHasNoNulls(Block block, String columnName)\n+    {\n+        for (int position = 0; position < block.getPositionCount(); position++) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMDQ5Ng==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r445110496", "bodyText": "Done in the latest force push.", "author": "djsstarburst", "createdAt": "2020-06-24T19:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MTY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MzU0Mg==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r443953542", "bodyText": "You can use toImmutableMap() from ImmutableMap. Also, I think this could simplify with a map call:\nMap<Integer, String> notNullChannelColumnNames = node.getColumns().stream()\n        .filter(symbol -> node.getNotNullColumnSymbols().contains(symbol))\n        .map(source::symbolToChannel)\n        .collect(toImmutableMap(identity(), node.getColumnNames()::get));", "author": "electrum", "createdAt": "2020-06-23T04:25:10Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2334,12 +2334,17 @@ public PhysicalOperation visitTableWriter(TableWriterNode node, LocalExecutionPl\n                     .map(source::symbolToChannel)\n                     .collect(toImmutableList());\n \n+            Map<Integer, String> notNullChannelColumnNames = node.getColumns().stream()\n+                    .filter(symbol -> node.getNotNullColumnSymbols().contains(symbol))\n+                    .collect(Collectors.toMap(source::symbolToChannel, s -> node.getColumnNames().get(source.symbolToChannel(s))));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMTA2Nw==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r445111067", "bodyText": "The ImmutableMap is no more, but I'll remember the tip.", "author": "djsstarburst", "createdAt": "2020-06-24T19:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MzU0Mg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMjkzNA==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r445722934", "bodyText": "Why use symbols here? Seems like it would be easier to have this be the column names", "author": "electrum", "createdAt": "2020-06-25T17:31:08Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/TableWriterNode.java", "diffHunk": "@@ -61,6 +64,7 @@ public TableWriterNode(\n             @JsonProperty(\"fragmentSymbol\") Symbol fragmentSymbol,\n             @JsonProperty(\"columns\") List<Symbol> columns,\n             @JsonProperty(\"columnNames\") List<String> columnNames,\n+            @JsonProperty(\"notNullColumnSymbols\") Set<Symbol> notNullColumnSymbols,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4MjUwMg==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r446482502", "bodyText": "I'd just do this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(column -> requireNonNull(columnToSymbolMap.get(column.getName()), \"columnToSymbolMap is missing column \" + column.getName()))\n          \n          \n            \n                            .collect(Collectors.toSet());\n          \n          \n            \n                            .map(columnToSymbolMap::get)\n          \n          \n            \n                            .collect(toImmutableSet());\n          \n      \n    \n    \n  \n\nIt's more concise, and the immutable set will catch any nulls that might result from the lookup (which is a bug somewhere in the implementation, anyway)", "author": "martint", "createdAt": "2020-06-27T04:20:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LogicalPlanner.java", "diffHunk": "@@ -448,11 +453,16 @@ else if (isUsePreferredWritePartitioning(session)) {\n             }\n         }\n \n-        if (!statisticsMetadata.isEmpty()) {\n-            verify(columnNames.size() == symbols.size(), \"columnNames.size() != symbols.size(): %s and %s\", columnNames, symbols);\n-            Map<String, Symbol> columnToSymbolMap = zip(columnNames.stream(), symbols.stream(), SimpleImmutableEntry::new)\n-                    .collect(toImmutableMap(Entry::getKey, Entry::getValue));\n+        verify(columnNames.size() == symbols.size(), \"columnNames.size() != symbols.size(): %s and %s\", columnNames, symbols);\n+        Map<String, Symbol> columnToSymbolMap = zip(columnNames.stream(), symbols.stream(), SimpleImmutableEntry::new)\n+                .collect(toImmutableMap(Entry::getKey, Entry::getValue));\n+\n+        Set<Symbol> notNullColumnSymbols = columnMetadataList.stream()\n+                .filter(column -> !column.isNullable())\n+                .map(column -> requireNonNull(columnToSymbolMap.get(column.getName()), \"columnToSymbolMap is missing column \" + column.getName()))\n+                .collect(Collectors.toSet());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4MzkzMg==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r446483932", "bodyText": "Indeed, that's much nicer; changed as you suggested by a forced comment.  Thanks very much for looking!", "author": "djsstarburst", "createdAt": "2020-06-27T04:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4OTQzMQ==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r446489431", "bodyText": "It looks like this caused some tests to start failing with NullPointerException", "author": "electrum", "createdAt": "2020-06-27T05:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4OTc2NA==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r446489764", "bodyText": "Oh, yeah, sorry, I missed the following in my suggestion above:\n.map(ColumnMetadata::getName)", "author": "martint", "createdAt": "2020-06-27T05:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUzMTQxMg==", "url": "https://github.com/trinodb/trino/pull/4144#discussion_r446531412", "bodyText": "Doh, I should have looked more closely rather than blindly applying change.  I need to be more careful pushing changes at an hour when I'm no longer sentient ;)\nIt's fixed now in the latest forced push.", "author": "djsstarburst", "createdAt": "2020-06-27T14:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4MjUwMg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "0674742fcfa59e9a21ab4aeadd7131a76dd6a735", "url": "https://github.com/trinodb/trino/commit/0674742fcfa59e9a21ab4aeadd7131a76dd6a735", "message": "Support enforcement of NOT NULL column declarations\n\nThis commit enforces NOT NULL column declarations on write\nin the Presto engine, so it applies to all connectors.  The\nexisting Postgres and Mysql tests named testInsertIntoNotNullColumn\nwere changed to check for the new error message, and a new test\nwith the same name was added to TestIcebergSmoke.\n\nOne possible concern with this commit is that the error message\nissued by the Presto engine when writing a null to a NOT NULL\ncolumn is a different message than the Connector might issue\nif no value was supplied for the NOT NULL column.  I think this\nis ok, because the error messages supplied by the Connectors are\ncompletely specific to the Connector.", "committedDate": "2020-06-27T14:17:03Z", "type": "commit"}, {"oid": "0674742fcfa59e9a21ab4aeadd7131a76dd6a735", "url": "https://github.com/trinodb/trino/commit/0674742fcfa59e9a21ab4aeadd7131a76dd6a735", "message": "Support enforcement of NOT NULL column declarations\n\nThis commit enforces NOT NULL column declarations on write\nin the Presto engine, so it applies to all connectors.  The\nexisting Postgres and Mysql tests named testInsertIntoNotNullColumn\nwere changed to check for the new error message, and a new test\nwith the same name was added to TestIcebergSmoke.\n\nOne possible concern with this commit is that the error message\nissued by the Presto engine when writing a null to a NOT NULL\ncolumn is a different message than the Connector might issue\nif no value was supplied for the NOT NULL column.  I think this\nis ok, because the error messages supplied by the Connectors are\ncompletely specific to the Connector.", "committedDate": "2020-06-27T14:17:03Z", "type": "forcePushed"}]}