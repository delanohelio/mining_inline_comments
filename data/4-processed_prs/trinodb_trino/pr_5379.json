{"pr_number": 5379, "pr_title": " Validate user objects for HiveProcedures", "pr_createdAt": "2020-10-01T14:28:24Z", "pr_url": "https://github.com/trinodb/trino/pull/5379", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgzMTc0Mw==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r500831743", "bodyText": "This is not enough. Access to a table can be controlled on system level access control.\nActually I think we need to pass something that represents top AccessControl. Then we need different security context too.\n@electrum Any thoughts?", "author": "kokosing", "createdAt": "2020-10-07T08:30:25Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/procedure/CreateEmptyPartitionProcedure.java", "diffHunk": "@@ -70,14 +73,16 @@\n     private final HiveMetastoreClosure metastore;\n     private final LocationService locationService;\n     private final JsonCodec<PartitionUpdate> partitionUpdateJsonCodec;\n+    private final ConnectorAccessControl accessControl;\n \n     @Inject\n-    public CreateEmptyPartitionProcedure(TransactionalMetadataFactory hiveMetadataFactory, HiveMetastore metastore, LocationService locationService, JsonCodec<PartitionUpdate> partitionUpdateCodec)\n+    public CreateEmptyPartitionProcedure(TransactionalMetadataFactory hiveMetadataFactory, HiveMetastore metastore, LocationService locationService, JsonCodec<PartitionUpdate> partitionUpdateCodec, ConnectorAccessControl accessControl)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMxMjA5Ng==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r501312096", "bodyText": "Yes, @Praveen2112 is changing this so that procedure calls are injected with a ConnectorAccessControl facade that does the connector and system access checks.", "author": "electrum", "createdAt": "2020-10-07T21:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgzMTc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUzOTg5NA==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r501539894", "bodyText": "Nice trick.", "author": "kokosing", "createdAt": "2020-10-08T08:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgzMTc0Mw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE5ODczNg==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r503198736", "bodyText": "Let's not make it generic so it could be used in other places too. Like system tables.", "author": "kokosing", "createdAt": "2020-10-12T10:29:22Z", "path": "presto-main/src/main/java/io/prestosql/security/ConnectorAccessControlForProcedures.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.Iterables.getFirst;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ConnectorAccessControlForProcedures", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5MDk1OQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514390959", "bodyText": "For an internal class, the initial name doesn't matter, as we can always rename it. But we could start with a generic name like InjectedConnectorAccessControl.", "author": "electrum", "createdAt": "2020-10-29T16:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE5ODczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE5OTA0NA==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r503199044", "bodyText": "we should also inject ConnectorSecurityContext so it could be used instead of null. It could be artificial but user should the one passed by us when checking the access.", "author": "kokosing", "createdAt": "2020-10-12T10:30:01Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/procedure/SyncPartitionMetadataProcedure.java", "diffHunk": "@@ -71,6 +72,7 @@\n             SyncPartitionMetadataProcedure.class,\n             \"syncPartitionMetadata\",\n             ConnectorSession.class,\n+            ConnectorAccessControl.class,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA4NzgzMA==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r504087830", "bodyText": "We discussed this offline and null seems cleaner than passing a fake security context that won't be used. ConnectorSecurityContext is a concrete class and doesn't have all the information needed by the access control. Passing null is the same as passing back the same one, but is more clear it won't be used, and is less code on both sides.", "author": "electrum", "createdAt": "2020-10-13T16:22:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE5OTA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5Mjc1NQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r504492755", "bodyText": "I see. I completely understand the issue from Presto developer perspective.\nHowever, from Presto user (author of custom Presto plugin) it sounds weird. That in this particular case they should pass null for not @Nullable or Optional parameter. I bet most of them would ask us how to get ConnectorSecurityContext to call ConnectorAccessControl in such context. On the other hand bets that someone would have this case are low.\nSince we already have custom implementation of ConnectorAccessControl, why not to have a new entity that would be similar to ConnectorAccessControl but without ConnectorSecurityContext parameter. Kind of a SPI view of AccessControl. Notice that it does not have to be fully featured view on AccessControl. We could start with few methods.", "author": "kokosing", "createdAt": "2020-10-14T08:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE5OTA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MzQyMg==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r504493422", "bodyText": "This is my point of view. I am not going to block anything here because of that.\nDisregarding which side we take this is still great improvement.", "author": "kokosing", "createdAt": "2020-10-14T08:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE5OTA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4NzMyMQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514387321", "bodyText": "We had also discussed having a custom access control interface (that was my original proposal), but @dain though that was overkill when ConnectorAccessControl is usable. Maybe he can explain more.", "author": "electrum", "createdAt": "2020-10-29T16:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE5OTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE5OTU2OA==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r503199568", "bodyText": "Please write some unit tests to at least verify that all methods are implemented.", "author": "kokosing", "createdAt": "2020-10-12T10:31:01Z", "path": "presto-main/src/main/java/io/prestosql/security/ConnectorAccessControlForProcedures.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.Iterables.getFirst;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ConnectorAccessControlForProcedures", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMzU1NA==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r511913554", "bodyText": "extract a method for new CatalogSchemaName(catalogName, schemaName)?", "author": "kokosing", "createdAt": "2020-10-26T12:12:10Z", "path": "presto-main/src/main/java/io/prestosql/security/ConnectorAccessControlForProcedures.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.Iterables.getFirst;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ConnectorAccessControlForProcedures\n+        implements ConnectorAccessControl\n+{\n+    private final AccessControl accessControl;\n+    private final SecurityContext securityContext;\n+    private final String catalogName;\n+    private final Function<SchemaTableName, QualifiedObjectName> qualifiedObjectNameProvider;\n+\n+    public ConnectorAccessControlForProcedures(AccessControl accessControl, SecurityContext securityContext, String catalogName)\n+    {\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.securityContext = requireNonNull(securityContext, \"securityContext is null\");\n+        this.catalogName = requireNonNull(catalogName, \"catalogName is null\");\n+        qualifiedObjectNameProvider = convertFromSchemaTableName(catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanCreateSchema(securityContext, new CatalogSchemaName(catalogName, schemaName));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNDEwMQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r511914101", "bodyText": "Can we have simple method instead of function field?", "author": "kokosing", "createdAt": "2020-10-26T12:13:16Z", "path": "presto-main/src/main/java/io/prestosql/security/ConnectorAccessControlForProcedures.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.Iterables.getFirst;\n+import static io.prestosql.metadata.QualifiedObjectName.convertFromSchemaTableName;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ConnectorAccessControlForProcedures\n+        implements ConnectorAccessControl\n+{\n+    private final AccessControl accessControl;\n+    private final SecurityContext securityContext;\n+    private final String catalogName;\n+    private final Function<SchemaTableName, QualifiedObjectName> qualifiedObjectNameProvider;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNDk1NQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r511914955", "bodyText": "you can add system access control to builder IIRC", "author": "kokosing", "createdAt": "2020-10-26T12:14:55Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveIntegrationSmokeTest.java", "diffHunk": "@@ -174,13 +182,15 @@ public TestHiveIntegrationSmokeTest()\n     protected QueryRunner createQueryRunner()\n             throws Exception\n     {\n-        return HiveQueryRunner.builder()\n+        QueryRunner queryRunner = HiveQueryRunner.builder()\n                 .setHiveProperties(ImmutableMap.of(\n                         \"hive.allow-register-partition-procedure\", \"true\",\n                         // Reduce writer sort buffer size to ensure SortingFileWriter gets used\n                         \"hive.writer-sort-buffer-size\", \"1MB\"))\n                 .setInitialTables(ImmutableList.of(CUSTOMER, NATION, ORDERS, REGION))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNjA3NA==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r511916074", "bodyText": "Do we need this additional system access control at all? You have each tests doubled while I think the only one that is using privilege() is enough here. What am I missing?", "author": "kokosing", "createdAt": "2020-10-26T12:16:58Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveIntegrationSmokeTest.java", "diffHunk": "@@ -7269,4 +7318,26 @@ private Session withTimestampPrecision(Session session, String precision)\n                 .setCatalogSessionProperty(catalog, \"timestamp_precision\", precision)\n                 .build();\n     }\n+\n+    private static class TestSystemAccessControl", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNzA2Mw==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r511917063", "bodyText": "This is misleading. It was denied to register a partition not to insert.", "author": "kokosing", "createdAt": "2020-10-26T12:18:58Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveIntegrationSmokeTest.java", "diffHunk": "@@ -2144,12 +2164,31 @@ public void testUnregisterRegisterPartition()\n \n         String firstPartition = new Path((String) paths.get(0).getField(0)).getParent().toString();\n \n+        assertAccessDenied(\n+                format(\"CALL system.unregister_partition('%s', '%s', ARRAY['part'], ARRAY['first'])\", TPCH_SCHEMA, tableName),\n+                format(\"Cannot delete from table hive.tpch.%s\", tableName),\n+                privilege(tableName, DELETE_TABLE));\n+\n+        assertAccessDenied(\n+                Session.builder(getSession()).setIdentity(ofUser(DENIED_USER)).build(),\n+                format(\"CALL system.unregister_partition('%s', '%s', ARRAY['part'], ARRAY['first'])\", TPCH_SCHEMA, tableName),\n+                format(\"Cannot delete from table hive.tpch.%s\", tableName));\n+\n         assertQueryFails(format(\"CALL system.unregister_partition('%s', '%s', ARRAY['part'], ARRAY['empty'])\", TPCH_SCHEMA, tableName), \"Partition 'part=empty' does not exist\");\n         assertUpdate(format(\"CALL system.unregister_partition('%s', '%s', ARRAY['part'], ARRAY['first'])\", TPCH_SCHEMA, tableName));\n \n         assertQuery(getSession(), format(\"SELECT count(*) FROM \\\"%s$partitions\\\"\", tableName), \"SELECT 2\");\n         assertQuery(getSession(), \"SELECT count(*) FROM \" + tableName, \"SELECT 2\");\n \n+        assertAccessDenied(\n+                format(\"CALL system.register_partition('%s', '%s', ARRAY['part'], ARRAY['first'])\", TPCH_SCHEMA, tableName),\n+                format(\"Cannot insert into table hive.tpch.%s\", tableName),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNjg3OQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r513516879", "bodyText": "I would name it as AccessControlConnectorAdapter", "author": "kokosing", "createdAt": "2020-10-28T15:01:32Z", "path": "presto-main/src/main/java/io/prestosql/security/ConnectorAccessControlForProcedures.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.Iterables.getFirst;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ConnectorAccessControlForProcedures", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNzMxNg==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r513517316", "bodyText": "checkArgument(context == null, \"context should be null\"); Here and elsewhere", "author": "kokosing", "createdAt": "2020-10-28T15:02:07Z", "path": "presto-main/src/main/java/io/prestosql/security/ConnectorAccessControlForProcedures.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.Iterables.getFirst;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ConnectorAccessControlForProcedures\n+        implements ConnectorAccessControl\n+{\n+    private final AccessControl accessControl;\n+    private final SecurityContext securityContext;\n+    private final String catalogName;\n+\n+    public ConnectorAccessControlForProcedures(AccessControl accessControl, SecurityContext securityContext, String catalogName)\n+    {\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.securityContext = requireNonNull(securityContext, \"securityContext is null\");\n+        this.catalogName = requireNonNull(catalogName, \"catalogName is null\");\n+    }\n+\n+    @Override\n+    public void checkCanCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanDropSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanDropSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameSchema(ConnectorSecurityContext context, String schemaName, String newSchemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanRenameSchema(securityContext, getCatalogSchemaName(schemaName), newSchemaName);\n+    }\n+\n+    @Override\n+    public void checkCanSetSchemaAuthorization(ConnectorSecurityContext context, String schemaName, PrestoPrincipal principal)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanSetSchemaAuthorization(securityContext, getCatalogSchemaName(schemaName), principal);\n+    }\n+\n+    @Override\n+    public void checkCanShowSchemas(ConnectorSecurityContext context)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowSchemas(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public Set<String> filterSchemas(ConnectorSecurityContext context, Set<String> schemaNames)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxODA0OQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r513518049", "bodyText": "Can we also use io.prestosql.spi.testing.InterfaceTestUtils#assertProperForwardingMethodsAreCalled(java.lang.Class<I>, java.util.function.Function<I,C>)?\nOr do something similar?", "author": "kokosing", "createdAt": "2020-10-28T15:03:01Z", "path": "presto-main/src/test/java/io/prestosql/security/TestConnectorAccessControlForProcedures.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.spi.testing.InterfaceTestUtils.assertAllMethodsOverridden;\n+\n+public class TestConnectorAccessControlForProcedures\n+{\n+    @Test\n+    public void testEverythingImplemented()\n+    {\n+        assertAllMethodsOverridden(ConnectorAccessControl.class, ConnectorAccessControlForProcedures.class);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxOTU1NQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r513519555", "bodyText": "Create separate procedure for your new test, otherwise it is hard to tell why testExecuteNoPermission passes", "author": "kokosing", "createdAt": "2020-10-28T15:04:51Z", "path": "presto-main/src/test/java/io/prestosql/execution/TestCallTask.java", "diffHunk": "@@ -157,8 +186,12 @@ private Session testSession(TransactionManager transactionManager)\n                 .build();\n     }\n \n-    public static void testingMethod()\n+    public static class TestingProcedure", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMDEyMQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r513520121", "bodyText": "There is plenty of code copied from testExecuteNoPermission can you please somehow unify that?", "author": "kokosing", "createdAt": "2020-10-28T15:05:31Z", "path": "presto-main/src/test/java/io/prestosql/execution/TestCallTask.java", "diffHunk": "@@ -107,6 +115,27 @@ public void testExecuteNoPermission()\n         assertThat(invoked).isFalse();\n     }\n \n+    @Test\n+    public void testExecuteNoPermissionOnInsert()\n+    {\n+        TransactionManager transactionManager = createTransactionManager();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyNTAzOA==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r513525038", "bodyText": "I am not sure if it is a good check that is called here. You don't delete data, you modify metadata. In io.prestosql.sql.analyzer.StatementAnalyzer.Visitor#visitAnalyze we check privilege for insert which is also weird.\nI think we should have dedicated method for modifying statistics.\n@electrum Any thoughts?", "author": "kokosing", "createdAt": "2020-10-28T15:11:36Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/procedure/DropStatsProcedure.java", "diffHunk": "@@ -86,20 +89,27 @@ public Procedure get()\n                 DROP_STATS.bindTo(this));\n     }\n \n-    public void dropStats(ConnectorSession session, String schema, String table, List<?> partitionValues)\n+    public void dropStats(ConnectorSession session, ConnectorAccessControl accessControl, String schema, String table, List<?> partitionValues)\n     {\n         try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(getClass().getClassLoader())) {\n-            doDropStats(session, schema, table, partitionValues);\n+            doDropStats(session, accessControl, schema, table, partitionValues);\n         }\n     }\n \n-    private void doDropStats(ConnectorSession session, String schema, String table, List<?> partitionValues)\n+    private void doDropStats(ConnectorSession session, ConnectorAccessControl accessControl, String schema, String table, List<?> partitionValues)\n     {\n         TransactionalMetadata hiveMetadata = hiveMetadataFactory.create();\n         HiveTableHandle handle = (HiveTableHandle) hiveMetadata.getTableHandle(session, new SchemaTableName(schema, table));\n         if (handle == null) {\n             throw new PrestoException(INVALID_PROCEDURE_ARGUMENT, format(\"Table '%s' does not exist\", new SchemaTableName(schema, table)));\n         }\n+\n+        try {\n+            accessControl.checkCanDeleteFromTable(null, new SchemaTableName(schema, table));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4OTA3OQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514389079", "bodyText": "Having a dedicated check for statistics makes sense, given that we have explicit checks for other operations, and statistics modification is part of the SPI for ANALYZE.", "author": "electrum", "createdAt": "2020-10-29T16:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyNTAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg2NjI4Ng==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r570866286", "bodyText": "It adds additional api call for implementors of security checks. I think  we should defer adding a dedicated check until we have a use-case at hand, which may be never.", "author": "findepi", "createdAt": "2021-02-05T10:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyNTAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5NTg2Ng==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514395866", "bodyText": "We can do this as two filters, which makes it a bit easier to read and modify later\n.filter(type -> !ConnectorSession.class.isAssignableFrom(type))\n.filter(type -> !ConnectorAccessControl.class.isAssignableFrom(type))", "author": "electrum", "createdAt": "2020-10-29T16:27:14Z", "path": "presto-main/src/main/java/io/prestosql/metadata/ProcedureRegistry.java", "diffHunk": "@@ -88,7 +89,7 @@ public Procedure resolve(CatalogName catalogName, SchemaTableName name)\n     private void validateProcedure(Procedure procedure)\n     {\n         List<Class<?>> parameters = procedure.getMethodHandle().type().parameterList().stream()\n-                .filter(type -> !ConnectorSession.class.isAssignableFrom(type))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5NjczNQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514396735", "bodyText": "I would say \"must\" rather than \"should\" since this is a requirement (and \"should\" implies a recommendation)", "author": "electrum", "createdAt": "2020-10-29T16:28:27Z", "path": "presto-main/src/main/java/io/prestosql/security/ConnectorAccessControlForProcedures.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.Iterables.getFirst;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ConnectorAccessControlForProcedures\n+        implements ConnectorAccessControl\n+{\n+    private final AccessControl accessControl;\n+    private final SecurityContext securityContext;\n+    private final String catalogName;\n+\n+    public ConnectorAccessControlForProcedures(AccessControl accessControl, SecurityContext securityContext, String catalogName)\n+    {\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.securityContext = requireNonNull(securityContext, \"securityContext is null\");\n+        this.catalogName = requireNonNull(catalogName, \"catalogName is null\");\n+    }\n+\n+    @Override\n+    public void checkCanCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwMDc3OQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514400779", "bodyText": "We should probably throw IllegalStateException here if there are multiple filters, since picking the first one would be discarding the other row filters. Ideally, the engine should probably analyze and combine them into a single expression, but we don't need to worry about this now.", "author": "electrum", "createdAt": "2020-10-29T16:33:57Z", "path": "presto-main/src/main/java/io/prestosql/security/ConnectorAccessControlForProcedures.java", "diffHunk": "@@ -0,0 +1,354 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.collect.Iterables.getFirst;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ConnectorAccessControlForProcedures\n+        implements ConnectorAccessControl\n+{\n+    private final AccessControl accessControl;\n+    private final SecurityContext securityContext;\n+    private final String catalogName;\n+\n+    public ConnectorAccessControlForProcedures(AccessControl accessControl, SecurityContext securityContext, String catalogName)\n+    {\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.securityContext = requireNonNull(securityContext, \"securityContext is null\");\n+        this.catalogName = requireNonNull(catalogName, \"catalogName is null\");\n+    }\n+\n+    @Override\n+    public void checkCanCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanDropSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanDropSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameSchema(ConnectorSecurityContext context, String schemaName, String newSchemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanRenameSchema(securityContext, getCatalogSchemaName(schemaName), newSchemaName);\n+    }\n+\n+    @Override\n+    public void checkCanSetSchemaAuthorization(ConnectorSecurityContext context, String schemaName, PrestoPrincipal principal)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanSetSchemaAuthorization(securityContext, getCatalogSchemaName(schemaName), principal);\n+    }\n+\n+    @Override\n+    public void checkCanShowSchemas(ConnectorSecurityContext context)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowSchemas(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public Set<String> filterSchemas(ConnectorSecurityContext context, Set<String> schemaNames)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        return accessControl.filterSchemas(securityContext, catalogName, schemaNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanDropTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameTable(ConnectorSecurityContext context, SchemaTableName tableName, SchemaTableName newTableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanRenameTable(securityContext, getQualifiedObjectName(tableName), getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetTableComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanSetTableComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetColumnComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanSetColumnComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanShowTables(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowTables(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public Set<SchemaTableName> filterTables(ConnectorSecurityContext context, Set<SchemaTableName> tableNames)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        return accessControl.filterTables(securityContext, catalogName, tableNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowColumns(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName));\n+    }\n+\n+    @Override\n+    public List<ColumnMetadata> filterColumns(ConnectorSecurityContext context, SchemaTableName tableName, List<ColumnMetadata> columns)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        return accessControl.filterColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName), columns);\n+    }\n+\n+    @Override\n+    public void checkCanAddColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanAddColumns(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanDropColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanRenameColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanInsertIntoTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanInsertIntoTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDeleteFromTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanDeleteFromTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanCreateView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameView(ConnectorSecurityContext context, SchemaTableName viewName, SchemaTableName newViewName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanRenameView(securityContext, getQualifiedObjectName(viewName), getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanDropView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanDropView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateViewWithSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanCreateViewWithSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanSetCatalogSessionProperty(ConnectorSecurityContext context, String propertyName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanSetCatalogSessionProperty(securityContext, propertyName, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal grantee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanGrantTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), grantee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal revokee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanRevokeTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), revokee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanCreateRole(ConnectorSecurityContext context, String role, Optional<PrestoPrincipal> grantor)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanCreateRole(securityContext, role, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanDropRole(ConnectorSecurityContext context, String role)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanDropRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanGrantRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanRevokeRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanSetRole(ConnectorSecurityContext context, String role, String catalogName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanSetRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleAuthorizationDescriptors(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowRoleAuthorizationDescriptors(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowCurrentRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowCurrentRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleGrants(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanShowRoleGrants(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanExecuteProcedure(ConnectorSecurityContext context, SchemaRoutineName procedure)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        accessControl.checkCanExecuteProcedure(securityContext, new QualifiedObjectName(catalogName, procedure.getSchemaName(), procedure.getRoutineName()));\n+    }\n+\n+    @Override\n+    public Optional<ViewExpression> getRowFilter(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"connectorSecurityContext should be null\");\n+        return Optional.ofNullable(getFirst(accessControl.getRowFilters(securityContext, getQualifiedObjectName(tableName)), null));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwMjA4MQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514402081", "bodyText": "Use two filters. See comment above.", "author": "electrum", "createdAt": "2020-10-29T16:35:37Z", "path": "presto-spi/src/main/java/io/prestosql/spi/procedure/Procedure.java", "diffHunk": "@@ -57,7 +58,7 @@ public Procedure(String schema, String name, List<Argument> arguments, MethodHan\n         checkArgument(methodHandle.type().returnType() == void.class, \"Method must return void\");\n \n         long parameterCount = methodHandle.type().parameterList().stream()\n-                .filter(type -> !ConnectorSession.class.isAssignableFrom(type))\n+                .filter(type -> !(ConnectorSession.class.isAssignableFrom(type) || ConnectorAccessControl.class.isAssignableFrom(type)))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwMjgwMA==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514402800", "bodyText": "Use SchemaTableName to format the error message, as above. Maybe extract a variable for the existing new SchemaTableName(...)", "author": "electrum", "createdAt": "2020-10-29T16:36:42Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/procedure/CreateEmptyPartitionProcedure.java", "diffHunk": "@@ -94,21 +97,28 @@ public Procedure get()\n                 CREATE_EMPTY_PARTITION.bindTo(this));\n     }\n \n-    public void createEmptyPartition(ConnectorSession session, String schema, String table, List<String> partitionColumnNames, List<String> partitionValues)\n+    public void createEmptyPartition(ConnectorSession session, ConnectorAccessControl accessControl, String schema, String table, List<String> partitionColumnNames, List<String> partitionValues)\n     {\n         try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(getClass().getClassLoader())) {\n-            doCreateEmptyPartition(session, schema, table, partitionColumnNames, partitionValues);\n+            doCreateEmptyPartition(session, accessControl, schema, table, partitionColumnNames, partitionValues);\n         }\n     }\n \n-    private void doCreateEmptyPartition(ConnectorSession session, String schemaName, String tableName, List<String> partitionColumnNames, List<String> partitionValues)\n+    private void doCreateEmptyPartition(ConnectorSession session, ConnectorAccessControl accessControl, String schemaName, String tableName, List<String> partitionColumnNames, List<String> partitionValues)\n     {\n         TransactionalMetadata hiveMetadata = hiveMetadataFactory.create();\n         HiveTableHandle tableHandle = (HiveTableHandle) hiveMetadata.getTableHandle(session, new SchemaTableName(schemaName, tableName));\n         if (tableHandle == null) {\n             throw new PrestoException(INVALID_PROCEDURE_ARGUMENT, format(\"Table '%s' does not exist\", new SchemaTableName(schemaName, tableName)));\n         }\n \n+        try {\n+            accessControl.checkCanInsertIntoTable(null, new SchemaTableName(schemaName, tableName));\n+        }\n+        catch (AccessDeniedException exception) {\n+            throw new AccessDeniedException(format(\"Cannot create an empty partition for table %s.%s\", schemaName, tableName));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwMzU0Ng==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514403546", "bodyText": "Actually, let's not wrap the error message here. The original message \"cannot insert into table\" is reasonable, and the stack trace might provide useful information. Same goes for the others.", "author": "electrum", "createdAt": "2020-10-29T16:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwMjgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwMzkzNw==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r514403937", "bodyText": "Same comment. The original error message will be good if we have an explicit access check for statistics.", "author": "electrum", "createdAt": "2020-10-29T16:38:25Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/procedure/DropStatsProcedure.java", "diffHunk": "@@ -86,20 +89,27 @@ public Procedure get()\n                 DROP_STATS.bindTo(this));\n     }\n \n-    public void dropStats(ConnectorSession session, String schema, String table, List<?> partitionValues)\n+    public void dropStats(ConnectorSession session, ConnectorAccessControl accessControl, String schema, String table, List<?> partitionValues)\n     {\n         try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(getClass().getClassLoader())) {\n-            doDropStats(session, schema, table, partitionValues);\n+            doDropStats(session, accessControl, schema, table, partitionValues);\n         }\n     }\n \n-    private void doDropStats(ConnectorSession session, String schema, String table, List<?> partitionValues)\n+    private void doDropStats(ConnectorSession session, ConnectorAccessControl accessControl, String schema, String table, List<?> partitionValues)\n     {\n         TransactionalMetadata hiveMetadata = hiveMetadataFactory.create();\n         HiveTableHandle handle = (HiveTableHandle) hiveMetadata.getTableHandle(session, new SchemaTableName(schema, table));\n         if (handle == null) {\n             throw new PrestoException(INVALID_PROCEDURE_ARGUMENT, format(\"Table '%s' does not exist\", new SchemaTableName(schema, table)));\n         }\n+\n+        try {\n+            accessControl.checkCanDeleteFromTable(null, new SchemaTableName(schema, table));\n+        }\n+        catch (AccessDeniedException exception) {\n+            throw new AccessDeniedException(format(\"Cannot drop stats for table %s.%s\", schema, table));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NjgxOA==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r517176818", "bodyText": "I think it can be supported when accessControl returns Optional.empty()", "author": "kokosing", "createdAt": "2020-11-04T08:40:56Z", "path": "presto-main/src/main/java/io/prestosql/security/InjectedConnectorAccessControl.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class InjectedConnectorAccessControl\n+        implements ConnectorAccessControl\n+{\n+    private final AccessControl accessControl;\n+    private final SecurityContext securityContext;\n+    private final String catalogName;\n+\n+    public InjectedConnectorAccessControl(AccessControl accessControl, SecurityContext securityContext, String catalogName)\n+    {\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.securityContext = requireNonNull(securityContext, \"securityContext is null\");\n+        this.catalogName = requireNonNull(catalogName, \"catalogName is null\");\n+    }\n+\n+    @Override\n+    public void checkCanCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanDropSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameSchema(ConnectorSecurityContext context, String schemaName, String newSchemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameSchema(securityContext, getCatalogSchemaName(schemaName), newSchemaName);\n+    }\n+\n+    @Override\n+    public void checkCanSetSchemaAuthorization(ConnectorSecurityContext context, String schemaName, PrestoPrincipal principal)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetSchemaAuthorization(securityContext, getCatalogSchemaName(schemaName), principal);\n+    }\n+\n+    @Override\n+    public void checkCanShowSchemas(ConnectorSecurityContext context)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowSchemas(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public Set<String> filterSchemas(ConnectorSecurityContext context, Set<String> schemaNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterSchemas(securityContext, catalogName, schemaNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameTable(ConnectorSecurityContext context, SchemaTableName tableName, SchemaTableName newTableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameTable(securityContext, getQualifiedObjectName(tableName), getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetTableComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetTableComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetColumnComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetColumnComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanShowTables(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowTables(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public Set<SchemaTableName> filterTables(ConnectorSecurityContext context, Set<SchemaTableName> tableNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterTables(securityContext, catalogName, tableNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowColumns(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName));\n+    }\n+\n+    @Override\n+    public List<ColumnMetadata> filterColumns(ConnectorSecurityContext context, SchemaTableName tableName, List<ColumnMetadata> columns)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName), columns);\n+    }\n+\n+    @Override\n+    public void checkCanAddColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanAddColumns(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanInsertIntoTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanInsertIntoTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDeleteFromTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDeleteFromTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameView(ConnectorSecurityContext context, SchemaTableName viewName, SchemaTableName newViewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameView(securityContext, getQualifiedObjectName(viewName), getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanDropView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateViewWithSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateViewWithSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanSetCatalogSessionProperty(ConnectorSecurityContext context, String propertyName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetCatalogSessionProperty(securityContext, propertyName, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantSchemaPrivilege(ConnectorSecurityContext context, Privilege privilege, String schemaName, PrestoPrincipal grantee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantSchemaPrivilege(securityContext, privilege, getCatalogSchemaName(schemaName), grantee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeSchemaPrivilege(ConnectorSecurityContext context, Privilege privilege, String schemaName, PrestoPrincipal revokee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeSchemaPrivilege(securityContext, privilege, getCatalogSchemaName(schemaName), revokee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanGrantTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal grantee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), grantee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal revokee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), revokee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanCreateRole(ConnectorSecurityContext context, String role, Optional<PrestoPrincipal> grantor)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateRole(securityContext, role, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanDropRole(ConnectorSecurityContext context, String role)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanSetRole(ConnectorSecurityContext context, String role, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleAuthorizationDescriptors(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoleAuthorizationDescriptors(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowCurrentRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCurrentRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleGrants(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoleGrants(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanExecuteProcedure(ConnectorSecurityContext context, SchemaRoutineName procedure)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanExecuteProcedure(securityContext, new QualifiedObjectName(catalogName, procedure.getSchemaName(), procedure.getRoutineName()));\n+    }\n+\n+    @Override\n+    public Optional<ViewExpression> getRowFilter(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        throw new IllegalStateException(\"Not yet supported\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQyMjUyNg==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r517422526", "bodyText": "When accessControl returns a emptyList it can be Optional.empty()", "author": "Praveen2112", "createdAt": "2020-11-04T15:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NjgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3Njg1NQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r517176855", "bodyText": "I think it can be supported when accessControl returns Optional.empty()", "author": "kokosing", "createdAt": "2020-11-04T08:41:00Z", "path": "presto-main/src/main/java/io/prestosql/security/InjectedConnectorAccessControl.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class InjectedConnectorAccessControl\n+        implements ConnectorAccessControl\n+{\n+    private final AccessControl accessControl;\n+    private final SecurityContext securityContext;\n+    private final String catalogName;\n+\n+    public InjectedConnectorAccessControl(AccessControl accessControl, SecurityContext securityContext, String catalogName)\n+    {\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.securityContext = requireNonNull(securityContext, \"securityContext is null\");\n+        this.catalogName = requireNonNull(catalogName, \"catalogName is null\");\n+    }\n+\n+    @Override\n+    public void checkCanCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanDropSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameSchema(ConnectorSecurityContext context, String schemaName, String newSchemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameSchema(securityContext, getCatalogSchemaName(schemaName), newSchemaName);\n+    }\n+\n+    @Override\n+    public void checkCanSetSchemaAuthorization(ConnectorSecurityContext context, String schemaName, PrestoPrincipal principal)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetSchemaAuthorization(securityContext, getCatalogSchemaName(schemaName), principal);\n+    }\n+\n+    @Override\n+    public void checkCanShowSchemas(ConnectorSecurityContext context)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowSchemas(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public Set<String> filterSchemas(ConnectorSecurityContext context, Set<String> schemaNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterSchemas(securityContext, catalogName, schemaNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameTable(ConnectorSecurityContext context, SchemaTableName tableName, SchemaTableName newTableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameTable(securityContext, getQualifiedObjectName(tableName), getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetTableComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetTableComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetColumnComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetColumnComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanShowTables(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowTables(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public Set<SchemaTableName> filterTables(ConnectorSecurityContext context, Set<SchemaTableName> tableNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterTables(securityContext, catalogName, tableNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowColumns(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName));\n+    }\n+\n+    @Override\n+    public List<ColumnMetadata> filterColumns(ConnectorSecurityContext context, SchemaTableName tableName, List<ColumnMetadata> columns)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName), columns);\n+    }\n+\n+    @Override\n+    public void checkCanAddColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanAddColumns(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanInsertIntoTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanInsertIntoTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDeleteFromTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDeleteFromTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameView(ConnectorSecurityContext context, SchemaTableName viewName, SchemaTableName newViewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameView(securityContext, getQualifiedObjectName(viewName), getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanDropView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateViewWithSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateViewWithSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanSetCatalogSessionProperty(ConnectorSecurityContext context, String propertyName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetCatalogSessionProperty(securityContext, propertyName, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantSchemaPrivilege(ConnectorSecurityContext context, Privilege privilege, String schemaName, PrestoPrincipal grantee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantSchemaPrivilege(securityContext, privilege, getCatalogSchemaName(schemaName), grantee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeSchemaPrivilege(ConnectorSecurityContext context, Privilege privilege, String schemaName, PrestoPrincipal revokee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeSchemaPrivilege(securityContext, privilege, getCatalogSchemaName(schemaName), revokee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanGrantTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal grantee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), grantee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal revokee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), revokee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanCreateRole(ConnectorSecurityContext context, String role, Optional<PrestoPrincipal> grantor)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateRole(securityContext, role, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanDropRole(ConnectorSecurityContext context, String role)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanSetRole(ConnectorSecurityContext context, String role, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleAuthorizationDescriptors(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoleAuthorizationDescriptors(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowCurrentRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCurrentRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleGrants(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoleGrants(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanExecuteProcedure(ConnectorSecurityContext context, SchemaRoutineName procedure)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanExecuteProcedure(securityContext, new QualifiedObjectName(catalogName, procedure.getSchemaName(), procedure.getRoutineName()));\n+    }\n+\n+    @Override\n+    public Optional<ViewExpression> getRowFilter(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        throw new IllegalStateException(\"Not yet supported\");\n+    }\n+\n+    @Override\n+    public Optional<ViewExpression> getColumnMask(ConnectorSecurityContext context, SchemaTableName tableName, String columnName, Type type)\n+    {\n+        throw new IllegalStateException(\"Not yet supported\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQyMjYwOQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r517422609", "bodyText": "When accessControl returns a emptyList it can be Optional.empty()", "author": "Praveen2112", "createdAt": "2020-11-04T15:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3Njg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNTgzMg==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r525535832", "bodyText": "throw new PrestoException(NOT_SUPPORTED, \"Row filtering not supported\");", "author": "electrum", "createdAt": "2020-11-17T21:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3Njg1NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "553aaceb856159602f29c1840956693776be7bd5", "url": "https://github.com/trinodb/trino/commit/553aaceb856159602f29c1840956693776be7bd5", "message": "Validate user objects for HiveProcedures", "committedDate": "2020-11-05T07:25:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDYwNzk0Mw==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r524607943", "bodyText": "This check is actually reversed (as is the existing one for ConnectorSession). It would succeed if the parameter type is a subclass of ConnectorAccessControl, which would cause an error when the method is invoked (since the instance would not match).\nI think this should be switched to equality, since we wouldn't want to inject or instance for any superclass either (in this case only Object).\nWe should also fix the ConnectorSession check, but that can be a separate PR (or feel free to throw another commit on this PR).", "author": "electrum", "createdAt": "2020-11-16T21:31:23Z", "path": "presto-main/src/main/java/io/prestosql/execution/CallTask.java", "diffHunk": "@@ -169,6 +171,9 @@ else if (i < procedure.getArguments().size()) {\n             if (ConnectorSession.class.isAssignableFrom(type)) {\n                 arguments.add(session.toConnectorSession(catalogName));\n             }\n+            else if (ConnectorAccessControl.class.isAssignableFrom(type)) {", "originalCommit": "6cfd6d936bda879e92e3eeb6990bdfaee9d375f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMzMxNw==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r525533317", "bodyText": "Same comment as above about isAssignableFrom", "author": "electrum", "createdAt": "2020-11-17T21:23:23Z", "path": "presto-main/src/main/java/io/prestosql/metadata/ProcedureRegistry.java", "diffHunk": "@@ -86,6 +87,7 @@ private void validateProcedure(Procedure procedure)\n     {\n         List<Class<?>> parameters = procedure.getMethodHandle().type().parameterList().stream()\n                 .filter(type -> !ConnectorSession.class.isAssignableFrom(type))\n+                .filter(type -> !ConnectorAccessControl.class.isAssignableFrom(type))", "originalCommit": "6cfd6d936bda879e92e3eeb6990bdfaee9d375f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNTc4NQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r525535785", "bodyText": "Let's change this to\nthrow new PrestoException(NOT_SUPPORTED, \"Row filtering not supported\");", "author": "electrum", "createdAt": "2020-11-17T21:27:50Z", "path": "presto-main/src/main/java/io/prestosql/security/InjectedConnectorAccessControl.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.security;\n+\n+import io.prestosql.metadata.QualifiedObjectName;\n+import io.prestosql.spi.connector.CatalogSchemaName;\n+import io.prestosql.spi.connector.CatalogSchemaTableName;\n+import io.prestosql.spi.connector.ColumnMetadata;\n+import io.prestosql.spi.connector.ConnectorAccessControl;\n+import io.prestosql.spi.connector.ConnectorSecurityContext;\n+import io.prestosql.spi.connector.SchemaRoutineName;\n+import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.security.PrestoPrincipal;\n+import io.prestosql.spi.security.Privilege;\n+import io.prestosql.spi.security.ViewExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class InjectedConnectorAccessControl\n+        implements ConnectorAccessControl\n+{\n+    private final AccessControl accessControl;\n+    private final SecurityContext securityContext;\n+    private final String catalogName;\n+\n+    public InjectedConnectorAccessControl(AccessControl accessControl, SecurityContext securityContext, String catalogName)\n+    {\n+        this.accessControl = requireNonNull(accessControl, \"accessControl is null\");\n+        this.securityContext = requireNonNull(securityContext, \"securityContext is null\");\n+        this.catalogName = requireNonNull(catalogName, \"catalogName is null\");\n+    }\n+\n+    @Override\n+    public void checkCanCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanDropSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameSchema(ConnectorSecurityContext context, String schemaName, String newSchemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameSchema(securityContext, getCatalogSchemaName(schemaName), newSchemaName);\n+    }\n+\n+    @Override\n+    public void checkCanSetSchemaAuthorization(ConnectorSecurityContext context, String schemaName, PrestoPrincipal principal)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetSchemaAuthorization(securityContext, getCatalogSchemaName(schemaName), principal);\n+    }\n+\n+    @Override\n+    public void checkCanShowSchemas(ConnectorSecurityContext context)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowSchemas(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public Set<String> filterSchemas(ConnectorSecurityContext context, Set<String> schemaNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterSchemas(securityContext, catalogName, schemaNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateSchema(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCreateSchema(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public void checkCanShowCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameTable(ConnectorSecurityContext context, SchemaTableName tableName, SchemaTableName newTableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameTable(securityContext, getQualifiedObjectName(tableName), getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetTableComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetTableComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetColumnComment(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetColumnComment(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanShowTables(ConnectorSecurityContext context, String schemaName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowTables(securityContext, getCatalogSchemaName(schemaName));\n+    }\n+\n+    @Override\n+    public Set<SchemaTableName> filterTables(ConnectorSecurityContext context, Set<SchemaTableName> tableNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterTables(securityContext, catalogName, tableNames);\n+    }\n+\n+    @Override\n+    public void checkCanShowColumns(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName));\n+    }\n+\n+    @Override\n+    public List<ColumnMetadata> filterColumns(ConnectorSecurityContext context, SchemaTableName tableName, List<ColumnMetadata> columns)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        return accessControl.filterColumns(securityContext, new CatalogSchemaTableName(catalogName, tableName), columns);\n+    }\n+\n+    @Override\n+    public void checkCanAddColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanAddColumns(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDropColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSetTableAuthorization(ConnectorSecurityContext context, SchemaTableName tableName, PrestoPrincipal principal)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetTableAuthorization(securityContext, getQualifiedObjectName(tableName), principal);\n+    }\n+\n+    @Override\n+    public void checkCanRenameColumn(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameColumn(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanInsertIntoTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanInsertIntoTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanDeleteFromTable(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDeleteFromTable(securityContext, getQualifiedObjectName(tableName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanRenameView(ConnectorSecurityContext context, SchemaTableName viewName, SchemaTableName newViewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRenameView(securityContext, getQualifiedObjectName(viewName), getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanDropView(ConnectorSecurityContext context, SchemaTableName viewName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropView(securityContext, getQualifiedObjectName(viewName));\n+    }\n+\n+    @Override\n+    public void checkCanCreateViewWithSelectFromColumns(ConnectorSecurityContext context, SchemaTableName tableName, Set<String> columnNames)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateViewWithSelectFromColumns(securityContext, getQualifiedObjectName(tableName), columnNames);\n+    }\n+\n+    @Override\n+    public void checkCanSetCatalogSessionProperty(ConnectorSecurityContext context, String propertyName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetCatalogSessionProperty(securityContext, propertyName, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantSchemaPrivilege(ConnectorSecurityContext context, Privilege privilege, String schemaName, PrestoPrincipal grantee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantSchemaPrivilege(securityContext, privilege, getCatalogSchemaName(schemaName), grantee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeSchemaPrivilege(ConnectorSecurityContext context, Privilege privilege, String schemaName, PrestoPrincipal revokee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeSchemaPrivilege(securityContext, privilege, getCatalogSchemaName(schemaName), revokee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanGrantTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal grantee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), grantee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeTablePrivilege(ConnectorSecurityContext context, Privilege privilege, SchemaTableName tableName, PrestoPrincipal revokee, boolean grantOption)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeTablePrivilege(securityContext, privilege, getQualifiedObjectName(tableName), revokee, grantOption);\n+    }\n+\n+    @Override\n+    public void checkCanCreateRole(ConnectorSecurityContext context, String role, Optional<PrestoPrincipal> grantor)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanCreateRole(securityContext, role, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanDropRole(ConnectorSecurityContext context, String role)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanDropRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanGrantRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanGrantRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanRevokeRoles(ConnectorSecurityContext context, Set<String> roles, Set<PrestoPrincipal> grantees, boolean adminOption, Optional<PrestoPrincipal> grantor, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanRevokeRoles(securityContext, roles, grantees, adminOption, grantor, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanSetRole(ConnectorSecurityContext context, String role, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanSetRole(securityContext, role, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleAuthorizationDescriptors(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoleAuthorizationDescriptors(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowCurrentRoles(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowCurrentRoles(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanShowRoleGrants(ConnectorSecurityContext context, String catalogName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanShowRoleGrants(securityContext, catalogName);\n+    }\n+\n+    @Override\n+    public void checkCanExecuteProcedure(ConnectorSecurityContext context, SchemaRoutineName procedure)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        accessControl.checkCanExecuteProcedure(securityContext, new QualifiedObjectName(catalogName, procedure.getSchemaName(), procedure.getRoutineName()));\n+    }\n+\n+    @Override\n+    public Optional<ViewExpression> getRowFilter(ConnectorSecurityContext context, SchemaTableName tableName)\n+    {\n+        checkArgument(context == null, \"context must be null\");\n+        if (accessControl.getRowFilters(securityContext, new QualifiedObjectName(catalogName, tableName.getSchemaName(), tableName.getTableName())).isEmpty()) {\n+            return Optional.empty();\n+        }\n+        throw new IllegalStateException(\"Not yet supported\");", "originalCommit": "6cfd6d936bda879e92e3eeb6990bdfaee9d375f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNjMzMQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r525536331", "bodyText": "Same comment about isAssignableFrom", "author": "electrum", "createdAt": "2020-11-17T21:28:53Z", "path": "presto-spi/src/main/java/io/prestosql/spi/procedure/Procedure.java", "diffHunk": "@@ -58,6 +59,7 @@ public Procedure(String schema, String name, List<Argument> arguments, MethodHan\n \n         long parameterCount = methodHandle.type().parameterList().stream()\n                 .filter(type -> !ConnectorSession.class.isAssignableFrom(type))\n+                .filter(type -> !ConnectorAccessControl.class.isAssignableFrom(type))", "originalCommit": "6cfd6d936bda879e92e3eeb6990bdfaee9d375f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNzkxMQ==", "url": "https://github.com/trinodb/trino/pull/5379#discussion_r525537911", "bodyText": "Let's make this checkCanInsertIntoTable to match ANALYZE, since we're not deleting data. This would mean a user who has insert permission can drop stats and then run analyze.\nFrom the connector's point of view, analyze actually overwrites (i.e. deletes) the existing statistics, so drop stats can be thought of as a limited form of analyze.\nSeparately, we should probably add a new permission for analyze.", "author": "electrum", "createdAt": "2020-11-17T21:31:37Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/procedure/DropStatsProcedure.java", "diffHunk": "@@ -87,20 +89,23 @@ public Procedure get()\n                 DROP_STATS.bindTo(this));\n     }\n \n-    public void dropStats(ConnectorSession session, String schema, String table, List<?> partitionValues)\n+    public void dropStats(ConnectorSession session, ConnectorAccessControl accessControl, String schema, String table, List<?> partitionValues)\n     {\n         try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(getClass().getClassLoader())) {\n-            doDropStats(session, schema, table, partitionValues);\n+            doDropStats(session, accessControl, schema, table, partitionValues);\n         }\n     }\n \n-    private void doDropStats(ConnectorSession session, String schema, String table, List<?> partitionValues)\n+    private void doDropStats(ConnectorSession session, ConnectorAccessControl accessControl, String schema, String table, List<?> partitionValues)\n     {\n         TransactionalMetadata hiveMetadata = hiveMetadataFactory.create();\n         HiveTableHandle handle = (HiveTableHandle) hiveMetadata.getTableHandle(session, new SchemaTableName(schema, table));\n         if (handle == null) {\n             throw new PrestoException(INVALID_PROCEDURE_ARGUMENT, format(\"Table '%s' does not exist\", new SchemaTableName(schema, table)));\n         }\n+\n+        accessControl.checkCanDeleteFromTable(null, new SchemaTableName(schema, table));", "originalCommit": "553aaceb856159602f29c1840956693776be7bd5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "de158e23ea00e96088fc9a25254b888bc3d58c9d", "url": "https://github.com/trinodb/trino/commit/de158e23ea00e96088fc9a25254b888bc3d58c9d", "message": "Minor cleanup in checks involving ConnectorSession for Procedure", "committedDate": "2020-11-19T06:05:45Z", "type": "commit"}, {"oid": "e946b87c0072289996f1c3a487dadca537b58e9b", "url": "https://github.com/trinodb/trino/commit/e946b87c0072289996f1c3a487dadca537b58e9b", "message": "Inject ConnectorAccessControl for Procedures", "committedDate": "2020-11-19T06:05:46Z", "type": "commit"}, {"oid": "497062d0f445ef5f72d3f5afd7df322fcfe6abdf", "url": "https://github.com/trinodb/trino/commit/497062d0f445ef5f72d3f5afd7df322fcfe6abdf", "message": "Validate user objects for HiveProcedures", "committedDate": "2020-11-19T06:05:46Z", "type": "commit"}, {"oid": "497062d0f445ef5f72d3f5afd7df322fcfe6abdf", "url": "https://github.com/trinodb/trino/commit/497062d0f445ef5f72d3f5afd7df322fcfe6abdf", "message": "Validate user objects for HiveProcedures", "committedDate": "2020-11-19T06:05:46Z", "type": "forcePushed"}]}