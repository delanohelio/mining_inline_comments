{"pr_number": 4991, "pr_title": "Support lazy dynamic filtering in hive connector", "pr_createdAt": "2020-08-26T19:37:26Z", "pr_url": "https://github.com/trinodb/trino/pull/4991", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwNjQzNA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482106434", "bodyText": "add long startTime and timeout after dynamicFilteringProbeBlockingTimeoutMillis - startTime?", "author": "sopel39", "createdAt": "2020-09-02T14:19:43Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +234,12 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                if (dynamicFilteringProbeBlockingTimeoutMillis.get() > 0 && !dynamicFilter.isComplete()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcxMDAxNA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482710014", "bodyText": "Changed to use a StopWatch", "author": "raunaqmorarka", "createdAt": "2020-09-03T05:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwNjQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwNjY5NA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482106694", "bodyText": "I think this one can be removed", "author": "sopel39", "createdAt": "2020-09-02T14:20:01Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +234,12 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                if (dynamicFilteringProbeBlockingTimeoutMillis.get() > 0 && !dynamicFilter.isComplete()) {\n+                    future = toListenableFuture(dynamicFilter.isBlocked()\n+                            .orTimeout(dynamicFilteringProbeBlockingTimeoutMillis.get(), MILLISECONDS));\n+                    addExceptionCallback(future, () -> dynamicFilteringProbeBlockingTimeoutMillis.set(0));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwODU1Mg==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482108552", "bodyText": "make this final long dynamicFilteringProbeBlockingTimeoutMillis", "author": "sopel39", "createdAt": "2020-09-02T14:22:31Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -129,7 +133,8 @@\n \n     private final Table table;\n     private final TupleDomain<? extends ColumnHandle> compactEffectivePredicate;\n-    private final Supplier<TupleDomain<ColumnHandle>> dynamicFilterSupplier;\n+    private final DynamicFilter dynamicFilter;\n+    private final AtomicLong dynamicFilteringProbeBlockingTimeoutMillis;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwOTc3OA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482109778", "bodyText": "Add io.prestosql.plugin.hive.HiveQueryRunner.Builder#withTpchPartitionedTables()", "author": "sopel39", "createdAt": "2020-09-02T14:24:07Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -269,6 +281,60 @@ private static void copyTableBucketed(QueryRunner queryRunner, QualifiedObjectNa\n         log.info(\"Imported %s rows for %s in %s\", rows, table.getObjectName(), nanosSince(start).convertToMostSuccinctTimeUnit());\n     }\n \n+    public static Session createPartitionedSession(Optional<SelectedRole> role)\n+    {\n+        return testSessionBuilder()\n+                .setIdentity(Identity.forUser(\"hive\")\n+                        .withRoles(role.map(selectedRole -> ImmutableMap.of(\"hive\", selectedRole))\n+                                .orElse(ImmutableMap.of()))\n+                        .build())\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    public static void copyTpchTablesPartitioned(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcxMDE5NA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482710194", "bodyText": "Done", "author": "raunaqmorarka", "createdAt": "2020-09-03T05:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwOTc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMDczOQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482120739", "bodyText": "please partition by shiptdate which is more natural", "author": "sopel39", "createdAt": "2020-09-02T14:37:45Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -269,6 +281,60 @@ private static void copyTableBucketed(QueryRunner queryRunner, QualifiedObjectNa\n         log.info(\"Imported %s rows for %s in %s\", rows, table.getObjectName(), nanosSince(start).convertToMostSuccinctTimeUnit());\n     }\n \n+    public static Session createPartitionedSession(Optional<SelectedRole> role)\n+    {\n+        return testSessionBuilder()\n+                .setIdentity(Identity.forUser(\"hive\")\n+                        .withRoles(role.map(selectedRole -> ImmutableMap.of(\"hive\", selectedRole))\n+                                .orElse(ImmutableMap.of()))\n+                        .build())\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    public static void copyTpchTablesPartitioned(\n+            QueryRunner queryRunner,\n+            String sourceCatalog,\n+            String sourceSchema,\n+            Session session,\n+            Iterable<TpchTable<?>> tables)\n+    {\n+        log.info(\"Loading data from %s.%s...\", sourceCatalog, sourceSchema);\n+        long startTime = System.nanoTime();\n+        for (TpchTable<?> table : tables) {\n+            copyTablePartitioned(queryRunner, new QualifiedObjectName(sourceCatalog, sourceSchema, table.getTableName().toLowerCase(ENGLISH)), session);\n+        }\n+        log.info(\"Loading from %s.%s complete in %s\", sourceCatalog, sourceSchema, nanosSince(startTime).toString(SECONDS));\n+    }\n+\n+    private static void copyTablePartitioned(QueryRunner queryRunner, QualifiedObjectName table, Session session)\n+    {\n+        long start = System.nanoTime();\n+        log.info(\"Running import for %s\", table.getObjectName());\n+        @Language(\"SQL\") String sql;\n+        switch (table.getObjectName()) {\n+            case \"orders\":\n+            case \"part\":\n+            case \"partsupp\":\n+            case \"supplier\":\n+            case \"nation\":\n+            case \"region\":\n+                sql = format(\"CREATE TABLE %s AS SELECT * FROM %s\", table.getObjectName(), table);\n+                break;\n+            case \"lineitem\":\n+                sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['suppkey']) AS SELECT orderkey, partkey, linenumber, quantity, extendedprice, discount, tax, returnflag, linestatus, shipdate, commitdate, receiptdate, shipinstruct, shipmode, comment, suppkey FROM %s\", table.getObjectName(), table);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyNDI2MQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482724261", "bodyText": "Partitioning on shiptdate gives ~2.5K partitions which makes the test setup very slow (triggers major GC a lot on my laptop). Partitioning suppkey gives 100 partitions which works well for testing.", "author": "raunaqmorarka", "createdAt": "2020-09-03T06:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMDczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNDE5Mg==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483514192", "bodyText": "Ok. Since this is for just single test, Let's just create appropriate tables in test itself instead of using artificial keys", "author": "sopel39", "createdAt": "2020-09-04T09:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMDczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NzEwNg==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483597106", "bodyText": "Done", "author": "raunaqmorarka", "createdAt": "2020-09-04T12:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMDczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNDc3Mw==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482124773", "bodyText": "let's avoid artificial partitioning.", "author": "sopel39", "createdAt": "2020-09-02T14:43:08Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -269,6 +281,60 @@ private static void copyTableBucketed(QueryRunner queryRunner, QualifiedObjectNa\n         log.info(\"Imported %s rows for %s in %s\", rows, table.getObjectName(), nanosSince(start).convertToMostSuccinctTimeUnit());\n     }\n \n+    public static Session createPartitionedSession(Optional<SelectedRole> role)\n+    {\n+        return testSessionBuilder()\n+                .setIdentity(Identity.forUser(\"hive\")\n+                        .withRoles(role.map(selectedRole -> ImmutableMap.of(\"hive\", selectedRole))\n+                                .orElse(ImmutableMap.of()))\n+                        .build())\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    public static void copyTpchTablesPartitioned(\n+            QueryRunner queryRunner,\n+            String sourceCatalog,\n+            String sourceSchema,\n+            Session session,\n+            Iterable<TpchTable<?>> tables)\n+    {\n+        log.info(\"Loading data from %s.%s...\", sourceCatalog, sourceSchema);\n+        long startTime = System.nanoTime();\n+        for (TpchTable<?> table : tables) {\n+            copyTablePartitioned(queryRunner, new QualifiedObjectName(sourceCatalog, sourceSchema, table.getTableName().toLowerCase(ENGLISH)), session);\n+        }\n+        log.info(\"Loading from %s.%s complete in %s\", sourceCatalog, sourceSchema, nanosSince(startTime).toString(SECONDS));\n+    }\n+\n+    private static void copyTablePartitioned(QueryRunner queryRunner, QualifiedObjectName table, Session session)\n+    {\n+        long start = System.nanoTime();\n+        log.info(\"Running import for %s\", table.getObjectName());\n+        @Language(\"SQL\") String sql;\n+        switch (table.getObjectName()) {\n+            case \"orders\":\n+            case \"part\":\n+            case \"partsupp\":\n+            case \"supplier\":\n+            case \"nation\":\n+            case \"region\":\n+                sql = format(\"CREATE TABLE %s AS SELECT * FROM %s\", table.getObjectName(), table);\n+                break;\n+            case \"lineitem\":\n+                sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['suppkey']) AS SELECT orderkey, partkey, linenumber, quantity, extendedprice, discount, tax, returnflag, linestatus, shipdate, commitdate, receiptdate, shipinstruct, shipmode, comment, suppkey FROM %s\", table.getObjectName(), table);\n+                break;\n+            case \"customer\":\n+                sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['nationkey', 'mktsegment']) AS SELECT custkey, name, address, phone, acctbal, comment, nationkey, mktsegment FROM %s\", table.getObjectName(), table);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcxMDI3NQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482710275", "bodyText": "Removed this", "author": "raunaqmorarka", "createdAt": "2020-09-03T05:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNDc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNTY2NA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482125664", "bodyText": "could we add a test for getDiscreteValuesCount too? I think you can use row_type for this (I don't think row types are orderable).", "author": "sopel39", "createdAt": "2020-09-02T14:44:18Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.HIVE_PARTITIONED_CATALOG;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.TPCH_PARTITIONED_SCHEMA;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.TPCH_SCHEMA;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.copyTpchTablesPartitioned;\n+import static io.prestosql.plugin.hive.HiveQueryRunner.createPartitionedSession;\n+import static io.prestosql.plugin.tpch.TpchMetadata.TINY_SCHEMA_NAME;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"10s\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        copyTpchTablesPartitioned(getQueryRunner(), TPCH_SCHEMA, TINY_SCHEMA_NAME, createPartitionedSession(Optional.empty()), getTables());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .setCatalog(HIVE_PARTITIONED_CATALOG)\n+                .setSchema(TPCH_PARTITIONED_SCHEMA)\n+                .build();\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM lineitem JOIN supplier ON lineitem.suppkey = supplier.suppkey\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(\n+                range(INTEGER, 1L, true, 100L, true)), false)\n+                .toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                        \"lineitem JOIN tpch.tiny.supplier ON lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), TPCH_PARTITIONED_SCHEMA + \":lineitem\");\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 2L);\n+\n+        List<DynamicFilterDomainStats> domainStats = dynamicFiltersStats.getDynamicFilterDomainStats();\n+        assertEquals(domainStats.size(), 2L);\n+        domainStats.forEach(stats -> {\n+            assertGreaterThanOrEqual(stats.getRangeCount(), 1);\n+            assertEquals(stats.getDiscreteValuesCount(), 0);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MjgxNQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r482742815", "bodyText": "RowType is orderable as long as the fields within are themselves orderable. I think we can use ColorType.\nFor testing getDiscreteValuesCount specifically, would it be ok we add a test in TestDynamicFilterService instead (maybe separate PR) ? It will be much easier to do it there.", "author": "raunaqmorarka", "createdAt": "2020-09-03T06:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNTYwMw==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483515603", "bodyText": "would it be ok we add a test in TestDynamicFilterService instead (maybe separate PR)\n\nYes, that works too", "author": "sopel39", "createdAt": "2020-09-04T09:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyNTY2NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwODA2NA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483508064", "bodyText": "I don't think it's needed. We short-circut on all predicate.", "author": "sopel39", "createdAt": "2020-09-04T09:40:13Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,17 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*\n+                 * Block until one of below conditions is met:\n+                 * Arrival of first non \"all\" filter", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYwMzUzMA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483603530", "bodyText": "Didn't follow this completely, my intent is to unblock the probe side scheduling as soon as we have a useful (not all) filter available from DynamicFilter without waiting for full completion. The future from isBlocked can complete multiple times with an all before giving a not all filter, so I used the condition !dynamicFilter.isComplete() && dynamicFilter.getCurrentPredicate().isAll() before blocking on the future from dynamicFilter.isBlocked()", "author": "raunaqmorarka", "createdAt": "2020-09-04T13:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwODA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwODIxNw==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483508217", "bodyText": "put each condition in bulletpoints", "author": "sopel39", "createdAt": "2020-09-04T09:40:33Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,17 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*\n+                 * Block until one of below conditions is met:\n+                 * Arrival of first non \"all\" filter", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NzIxNw==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483597217", "bodyText": "Done", "author": "raunaqmorarka", "createdAt": "2020-09-04T12:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUwODIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMTE3OQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483511179", "bodyText": "does orTimeout(timeLeft, MILLISECONDS) cancel delegate future?\nThis is a bug in Presto. Futures returned in DynamicFilter are not resilient against cancellation. Could you fix it?\nWe probably should wrap these in MoreFutures#unmodifiableFuture(java.util.concurrent.CompletableFuture<V>, boolean) in Presto main", "author": "sopel39", "createdAt": "2020-09-04T09:46:17Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,17 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*\n+                 * Block until one of below conditions is met:\n+                 * Arrival of first non \"all\" filter\n+                 * Completion of DynamicFilter\n+                 * Timeout after waiting for the configured time\n+                 */\n+                long timeLeft = dynamicFilteringProbeBlockingTimeoutMillis - stopwatch.elapsed(MILLISECONDS);\n+                if (timeLeft > 0 && !dynamicFilter.isComplete() && dynamicFilter.getCurrentPredicate().isAll()) {\n+                    future = toListenableFuture(dynamicFilter.isBlocked().orTimeout(timeLeft, MILLISECONDS));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3Mjg0NQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483572845", "bodyText": "orTimeout completes the underlying future exceptionally\nE.g.:\nCompletableFuture future = dynamicFilter.isBlocked();\nassertFalse(future.isDone());\nfuture.orTimeout(1, TimeUnit.MILLISECONDS);\nThread.sleep(1000);\nassertFalse(future.isCancelled());\nassertTrue(future.isCompletedExceptionally());\nassertTrue(future.isDone());\nassertFalse(dynamicFilter.isBlocked().isDone());\n\nIf we outright cancel the future returned by dynamicFilter.isBlocked() then the cancellation propagates into DynamicFilterService and prevents setting of lazyDynamicFilters in addDynamicFilters.\nCompletableFuture future = dynamicFilter.isBlocked();\nassertFalse(future.isDone());\nfuture.cancel(false);\nassertTrue(future.isCancelled());\nassertTrue(dynamicFilter.isBlocked().isDone());\n\nI'll make the change to warp the future in unmodifiableFuture", "author": "raunaqmorarka", "createdAt": "2020-09-04T12:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMTE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYwMzc0Mg==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483603742", "bodyText": "Added a commit for wrapping in unmodifiableFuture", "author": "raunaqmorarka", "createdAt": "2020-09-04T13:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMTE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzQwMA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483513400", "bodyText": "move .map to separate line", "author": "sopel39", "createdAt": "2020-09-04T09:50:34Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/HiveQueryRunner.java", "diffHunk": "@@ -269,6 +284,58 @@ private static void copyTableBucketed(QueryRunner queryRunner, QualifiedObjectNa\n         log.info(\"Imported %s rows for %s in %s\", rows, table.getObjectName(), nanosSince(start).convertToMostSuccinctTimeUnit());\n     }\n \n+    public static Session createPartitionedSession(Optional<SelectedRole> role)\n+    {\n+        return testSessionBuilder()\n+                .setIdentity(Identity.forUser(\"hive\")\n+                        .withRoles(role.map(selectedRole -> ImmutableMap.of(\"hive\", selectedRole))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NzM5Mw==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483597393", "bodyText": "Reverted these changes", "author": "raunaqmorarka", "createdAt": "2020-09-04T12:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNTIxMA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483515210", "bodyText": "nit: this should go to separate commit", "author": "sopel39", "createdAt": "2020-09-04T09:54:03Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDistributedJoinQueries.java", "diffHunk": "@@ -77,30 +69,4 @@ public void testJoinWithEmptyBuildSide()\n         assertEquals(probeStats.getInputPositions(), 0L);\n         assertEquals(probeStats.getDynamicFilterSplitsProcessed(), probeStats.getTotalDrivers());\n     }\n-\n-    private OperatorStats searchScanFilterAndProjectOperatorStats(QueryId queryId, String tableName)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NTg1MA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r483595850", "bodyText": "Done", "author": "raunaqmorarka", "createdAt": "2020-09-04T12:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNTIxMA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODM1MA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484458350", "bodyText": "commit message is too long", "author": "sopel39", "createdAt": "2020-09-07T14:15:33Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDistributedJoinQueries.java", "diffHunk": "@@ -13,17 +13,9 @@\n  */", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MTM4NQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484761385", "bodyText": "shortened", "author": "raunaqmorarka", "createdAt": "2020-09-08T08:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODk0Ng==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484458946", "bodyText": "please add a test. Please also update io.prestosql.sql.planner.LocalDynamicFiltersCollector.TableSpecificDynamicFilter#isBlocked + test", "author": "sopel39", "createdAt": "2020-09-07T14:16:41Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -217,7 +218,7 @@ public DynamicFilter createDynamicFilter(QueryId queryId, List<DynamicFilters.De\n                     return NOT_BLOCKED;\n                 }\n \n-                return toCompletableFuture(whenAnyComplete(undoneFutures));\n+                return unmodifiableFuture(toCompletableFuture(whenAnyComplete(undoneFutures)));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MTYyMQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484761621", "bodyText": "Done in #5099", "author": "raunaqmorarka", "createdAt": "2020-09-08T08:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1OTAxMQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484459011", "bodyText": "you could make separate PR for this fix", "author": "sopel39", "createdAt": "2020-09-07T14:16:50Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -67,6 +67,7 @@\n import static com.google.common.collect.ImmutableSet.toImmutableSet;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MDgwMA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484760800", "bodyText": "Raised #5099", "author": "raunaqmorarka", "createdAt": "2020-09-08T08:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1OTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1OTUzMA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484459530", "bodyText": "all filter should trigger DF completion (and filter unblock). Remove this condition", "author": "sopel39", "createdAt": "2020-09-07T14:17:55Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,17 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*\n+                 * Block until one of below conditions is met:\n+                 *  1. Arrival of first non \"all\" filter", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MTc5Ng==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484761796", "bodyText": "Removed comment", "author": "raunaqmorarka", "createdAt": "2020-09-08T08:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1OTUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MTAzNg==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484461036", "bodyText": "make it sleep for 1H", "author": "sopel39", "createdAt": "2020-09-07T14:20:42Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestBackgroundHiveSplitLoader.java", "diffHunk": "@@ -343,6 +346,45 @@ public void testNoHangIfPartitionIsOffline()\n         assertThrows(RuntimeException.class, hiveSplitSource::isFinished);\n     }\n \n+    @Test(timeOut = 6_000)\n+    public void testIncompleteDynamicFilterTimeout()\n+            throws Exception\n+    {\n+        BackgroundHiveSplitLoader backgroundHiveSplitLoader = backgroundHiveSplitLoader(\n+                new DynamicFilter() {\n+                    @Override\n+                    public CompletableFuture<?> isBlocked()\n+                    {\n+                        return CompletableFuture.runAsync(() -> {\n+                            try {\n+                                TimeUnit.SECONDS.sleep(30);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MTg4Mg==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484761882", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-08T08:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MTAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MTE3NA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484461174", "bodyText": "increase timeout to 30s to reduce chance for flakyness", "author": "sopel39", "createdAt": "2020-09-07T14:20:57Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestBackgroundHiveSplitLoader.java", "diffHunk": "@@ -343,6 +346,45 @@ public void testNoHangIfPartitionIsOffline()\n         assertThrows(RuntimeException.class, hiveSplitSource::isFinished);\n     }\n \n+    @Test(timeOut = 6_000)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MTk2NA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484761964", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-08T08:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MTE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MTg3MA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484461870", "bodyText": "increase timeout for 1h to reduce risk of test flakyness", "author": "sopel39", "createdAt": "2020-09-07T14:22:18Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"10s\"))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MjA1Mw==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484762053", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-08T08:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MTg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MzM0Mw==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484463343", "bodyText": "question: is it a consistent same scanned row count every time?", "author": "sopel39", "createdAt": "2020-09-07T14:25:11Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"10s\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2MzU0MQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484763541", "bodyText": "Yes, we use text storage format and partitioned joins so the only pruning here should come from DF and it should be consistent due to the probe blocking logic. I've updated it to assert for specific row count now.", "author": "raunaqmorarka", "createdAt": "2020-09-08T09:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MzM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MzYxOA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484463618", "bodyText": "extract countRows(\"lineitem\") as static final to avoid extra queries in test", "author": "sopel39", "createdAt": "2020-09-07T14:25:45Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThan;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"10s\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(\n+                range(INTEGER, 1L, true, 100L, true)), false)\n+                .toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                        \"partitioned_lineitem JOIN tpch.tiny.supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertLessThan(probeStats.getInputPositions(), countRows(\"lineitem\"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc2NDYzNA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484764634", "bodyText": "Replaced with a constant value now", "author": "raunaqmorarka", "createdAt": "2020-09-08T09:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2MzYxOA=="}], "type": "inlineReview"}, {"oid": "f9a67d14be9ee6faf3d5b475fd7e7027a987d5f5", "url": "https://github.com/trinodb/trino/commit/f9a67d14be9ee6faf3d5b475fd7e7027a987d5f5", "message": "Move searchScanFilterAndProjectOperatorStats", "committedDate": "2020-09-08T07:55:51Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4OTk4Mg==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484789982", "bodyText": "nit: I think in methods we use:\n// comment\n//  second line\n\nstyle of comments.", "author": "sopel39", "createdAt": "2020-09-08T09:44:09Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,16 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                /*", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NTg1OA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484885858", "bodyText": "changed the style", "author": "raunaqmorarka", "createdAt": "2020-09-08T12:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc4OTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5MTg3Mw==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484791873", "bodyText": "Could you extend io.prestosql.plugin.hive.TestBackgroundHiveSplitLoader#backgroundHiveSplitLoader(io.prestosql.plugin.hive.HdfsEnvironment, io.prestosql.spi.predicate.TupleDomain<io.prestosql.plugin.hive.HiveColumnHandle>, java.util.Optional<io.prestosql.plugin.hive.util.HiveBucketing.HiveBucketFilter>, io.prestosql.plugin.hive.metastore.Table, java.util.Optional<io.prestosql.plugin.hive.HiveBucketHandle>, java.util.Optional<org.apache.hadoop.hive.common.ValidWriteIdList>) version of backgroundHiveSplitLoader with dynamic filter parameters and add an override that does provide default values for these?", "author": "sopel39", "createdAt": "2020-09-08T09:47:08Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestBackgroundHiveSplitLoader.java", "diffHunk": "@@ -703,6 +746,36 @@ private static void createOrcAcidFile(File file)\n         return splits.build();\n     }\n \n+    private static BackgroundHiveSplitLoader backgroundHiveSplitLoader(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NTQ1OQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484885459", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-08T12:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5MTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5MzM0MA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484793340", "bodyText": "please do something similar as io.prestosql.plugin.memory.TestMemorySmoke#LINEITEM_COUNT for total count of lineitem rows.", "author": "sopel39", "createdAt": "2020-09-08T09:49:38Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThanOrEqual;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"1h\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (format = 'TEXTFILE', partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertEquals(probeStats.getInputPositions(), 615);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), countRows(\"lineitem\"));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NTcwMg==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484885702", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-08T12:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5MzM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5NDE4OQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484794189", "bodyText": "please add a test case where build side is too large, see: io.prestosql.plugin.memory.TestMemorySmoke#testJoinLargeBuildSideNoDynamicFiltering", "author": "sopel39", "createdAt": "2020-09-08T09:51:04Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.testing.Assertions.assertLessThanOrEqual;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"1h\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (format = 'TEXTFILE', partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertEquals(probeStats.getInputPositions(), 615);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), countRows(\"lineitem\"));\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(\n+                range(INTEGER, 1L, true, 100L, true)), false)\n+                .toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                        \"partitioned_lineitem JOIN tpch.tiny.supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN tpch.tiny.partsupp ON t.suppkey = partsupp.suppkey AND partsupp.suppkey IN (2, 3)\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertLessThanOrEqual(probeStats.getInputPositions(), 615L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 2L);\n+\n+        List<DynamicFilterDomainStats> domainStats = dynamicFiltersStats.getDynamicFilterDomainStats();\n+        assertEquals(domainStats.size(), 2L);\n+        domainStats.forEach(stats -> {\n+            assertGreaterThanOrEqual(stats.getRangeCount(), 1);\n+            assertEquals(stats.getDiscreteValuesCount(), 0);\n+        });\n+    }\n+\n+    private DynamicFiltersStats getDynamicFilteringStats(QueryId queryId)\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        return runner.getCoordinator()\n+                .getQueryManager()\n+                .getFullQueryInfo(queryId)\n+                .getQueryStats()\n+                .getDynamicFiltersStats();\n+    }\n+\n+    private long countRows(String tableName)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NTU4MA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484885580", "bodyText": "Added", "author": "raunaqmorarka", "createdAt": "2020-09-08T12:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5NDE4OQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4ODQ5Ng==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484888496", "bodyText": "@sopel39 FYI I tweaked this test a bit to assert on completion of only one filter. I was seeing some flakiness without this because the probe side gets unblocked after receiving one filter and the query can sometimes finish before DynamicFilterService is able to collect the 2nd filter. If I set experimental.dynamic-filtering-refresh-interval to a very low value like 20ms then the flakiness goes away.", "author": "raunaqmorarka", "createdAt": "2020-09-08T12:48:33Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.log.Logger;\n+import io.prestosql.Session;\n+import io.prestosql.operator.OperatorStats;\n+import io.prestosql.spi.QueryId;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.testing.AbstractTestQueryFramework;\n+import io.prestosql.testing.DistributedQueryRunner;\n+import io.prestosql.testing.MaterializedResult;\n+import io.prestosql.testing.QueryRunner;\n+import io.prestosql.testing.ResultWithQueryId;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.airlift.testing.Assertions.assertBetweenInclusive;\n+import static io.airlift.testing.Assertions.assertGreaterThan;\n+import static io.airlift.testing.Assertions.assertGreaterThanOrEqual;\n+import static io.airlift.units.Duration.nanosSince;\n+import static io.prestosql.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static io.prestosql.SystemSessionProperties.JOIN_REORDERING_STRATEGY;\n+import static io.prestosql.server.DynamicFilterService.DynamicFilterDomainStats;\n+import static io.prestosql.server.DynamicFilterService.DynamicFiltersStats;\n+import static io.prestosql.spi.predicate.Domain.none;\n+import static io.prestosql.spi.predicate.Domain.singleValue;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinDistributionType.PARTITIONED;\n+import static io.prestosql.sql.analyzer.FeaturesConfig.JoinReorderingStrategy.NONE;\n+import static io.prestosql.tpch.TpchTable.getTables;\n+import static java.lang.String.format;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestHiveDynamicPartitionPruning\n+        extends AbstractTestQueryFramework\n+{\n+    private static final Logger log = Logger.get(TestHiveDynamicPartitionPruning.class);\n+    private static final String PARTITIONED_LINEITEM = \"partitioned_lineitem\";\n+    private static final long LINEITEM_COUNT = 60175;\n+\n+    @Override\n+    protected QueryRunner createQueryRunner()\n+            throws Exception\n+    {\n+        return HiveQueryRunner.builder()\n+                .setInitialTables(getTables())\n+                .setHiveProperties(ImmutableMap.of(\"hive.dynamic-filtering-probe-blocking-timeout\", \"1h\"))\n+                .build();\n+    }\n+\n+    @BeforeClass\n+    @Override\n+    public void init()\n+            throws Exception\n+    {\n+        super.init();\n+        // setup partitioned fact table for dynamic partition pruning\n+        @Language(\"SQL\") String sql = format(\"CREATE TABLE %s WITH (format = 'TEXTFILE', partitioned_by=array['suppkey']) AS \" +\n+                \"SELECT orderkey, partkey, linenumber, suppkey FROM %s\", PARTITIONED_LINEITEM, \"tpch.tiny.lineitem\");\n+        long start = System.nanoTime();\n+        long rows = (Long) getQueryRunner().execute(sql).getMaterializedRows().get(0).getField(0);\n+        log.info(\"Imported %s rows for %s in %s\", rows, PARTITIONED_LINEITEM, nanosSince(start).convertToMostSuccinctTimeUnit());\n+    }\n+\n+    @Override\n+    protected Session getSession()\n+    {\n+        return Session.builder(super.getSession())\n+                .setSystemProperty(JOIN_REORDERING_STRATEGY, NONE.name())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, PARTITIONED.name()) // Avoid node local DF\n+                .build();\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithEmptyBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name = 'abc'\");\n+        assertEquals(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        assertEquals(probeStats.getInputPositions(), 0L);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), none(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 0);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey \" +\n+                        \"AND supplier.name = 'Supplier#000000001'\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertEquals(probeStats.getInputPositions(), 615);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), singleValue(INTEGER, 1L).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithNonSelectiveBuildSide()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN supplier ON partitioned_lineitem.suppkey = supplier.suppkey\");\n+        assertEquals(result.getResult().getRowCount(), LINEITEM_COUNT);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned\n+        assertEquals(probeStats.getInputPositions(), LINEITEM_COUNT);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.create(ValueSet.ofRanges(\n+                range(INTEGER, 1L, true, 100L, true)), false)\n+                .toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinLargeBuildSideNoDynamicFiltering()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM partitioned_lineitem JOIN orders ON partitioned_lineitem.orderkey = orders.orderkey\");\n+        assertEquals(result.getResult().getRowCount(), LINEITEM_COUNT);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is fully scanned because the build-side is too large for dynamic filtering:\n+        assertEquals(probeStats.getInputPositions(), LINEITEM_COUNT);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 1L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n+\n+        DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n+        assertEquals(domainStats.getSimplifiedDomain(), Domain.all(INTEGER).toString(getSession().toConnectorSession()));\n+        assertEquals(domainStats.getDiscreteValuesCount(), 0);\n+        assertEquals(domainStats.getRangeCount(), 1);\n+    }\n+\n+    @Test(timeOut = 30_000)\n+    public void testJoinWithMultipleDynamicFiltersOnProbe()\n+    {\n+        DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n+        // supplier names Supplier#000000001 and Supplier#000000002 match suppkey 1 and 2\n+        ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(\n+                getSession(),\n+                \"SELECT * FROM (\" +\n+                        \"SELECT supplier.suppkey FROM \" +\n+                        \"partitioned_lineitem JOIN tpch.tiny.supplier ON partitioned_lineitem.suppkey = supplier.suppkey AND supplier.name IN ('Supplier#000000001', 'Supplier#000000002')\" +\n+                        \") t JOIN supplier ON t.suppkey = supplier.suppkey AND supplier.suppkey IN (2, 3)\");\n+        assertGreaterThan(result.getResult().getRowCount(), 0);\n+\n+        OperatorStats probeStats = searchScanFilterAndProjectOperatorStats(result.getQueryId(), \"tpch:\" + PARTITIONED_LINEITEM);\n+        // Probe-side is partially scanned\n+        assertBetweenInclusive(probeStats.getInputPositions(), 558L, LINEITEM_COUNT - 1);\n+        assertEquals(probeStats.getDynamicFilterSplitsProcessed(), 0L);\n+\n+        DynamicFiltersStats dynamicFiltersStats = getDynamicFilteringStats(result.getQueryId());\n+        assertEquals(dynamicFiltersStats.getTotalDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getLazyDynamicFilters(), 2L);\n+        assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n+        assertBetweenInclusive(dynamicFiltersStats.getDynamicFiltersCompleted(), 1, 2);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkxNTM3MQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484915371", "bodyText": "After changing to wait on full DF, the above tweak is no longer needed", "author": "raunaqmorarka", "createdAt": "2020-09-08T13:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4ODQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg5MTkxMA==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484891910", "bodyText": "please remove dynamicFilter.getCurrentPredicate().isAll() predicate from if", "author": "sopel39", "createdAt": "2020-09-08T12:53:57Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/BackgroundHiveSplitLoader.java", "diffHunk": "@@ -227,6 +236,14 @@ public TaskStatus process()\n                     return TaskStatus.finished();\n                 }\n                 ListenableFuture<?> future;\n+                // Block until one of below conditions is met:\n+                // 1. Completion of DynamicFilter\n+                // 2. Timeout after waiting for the configured time\n+                long timeLeft = dynamicFilteringProbeBlockingTimeoutMillis - stopwatch.elapsed(MILLISECONDS);\n+                if (timeLeft > 0 && !dynamicFilter.isComplete() && dynamicFilter.getCurrentPredicate().isAll()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkxNDAxNQ==", "url": "https://github.com/trinodb/trino/pull/4991#discussion_r484914015", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-09-08T13:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg5MTkxMA=="}], "type": "inlineReview"}, {"oid": "b001728df0e045fb18b4b877da9f184b875e3333", "url": "https://github.com/trinodb/trino/commit/b001728df0e045fb18b4b877da9f184b875e3333", "message": "Support lazy dynamic filtering in hive connector", "committedDate": "2020-09-08T13:23:51Z", "type": "commit"}, {"oid": "b001728df0e045fb18b4b877da9f184b875e3333", "url": "https://github.com/trinodb/trino/commit/b001728df0e045fb18b4b877da9f184b875e3333", "message": "Support lazy dynamic filtering in hive connector", "committedDate": "2020-09-08T13:23:51Z", "type": "forcePushed"}]}