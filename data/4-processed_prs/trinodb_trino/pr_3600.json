{"pr_number": 3600, "pr_title": "Revamp TranslationMap and planner", "pr_createdAt": "2020-05-02T16:34:45Z", "pr_url": "https://github.com/trinodb/trino/pull/3600", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MzkwMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r424683901", "bodyText": "You could use isAtLeastScalar().", "author": "kasiafi", "createdAt": "2020-05-13T19:36:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/RemoveRedundantExists.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.ApplyNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.ExistsPredicate;\n+\n+import static io.prestosql.sql.planner.optimizations.QueryCardinalityUtil.isAtLeast;\n+import static io.prestosql.sql.planner.plan.Patterns.applyNode;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * Given:\n+ *\n+ * <pre>\n+ * - Apply [X.*, e = EXISTS (true)]\n+ *   - X\n+ *   - S with cardinality >= 1\n+ * </pre>\n+ *\n+ * Produces:\n+ *\n+ * <pre>\n+ * - Project [X.*, e = true]\n+ *   - X\n+ * </pre>\n+ */\n+public class RemoveRedundantExists\n+        implements Rule<ApplyNode>\n+{\n+    private static final Pattern<ApplyNode> PATTERN = applyNode()\n+            .matching(node -> node.getSubqueryAssignments()\n+                    .getExpressions().stream()\n+                    .allMatch(expression -> expression instanceof ExistsPredicate && ((ExistsPredicate) expression).getSubquery().equals(TRUE_LITERAL)));\n+\n+    @Override\n+    public Pattern<ApplyNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(ApplyNode node, Captures captures, Context context)\n+    {\n+        if (!isAtLeast(node.getSubquery(), context.getLookup(), 1)) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4NDUyMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r424684523", "bodyText": "Also the case of empty subquery could be captured and projected to e = false.", "author": "kasiafi", "createdAt": "2020-05-13T19:37:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/RemoveRedundantExists.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.ApplyNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.ExistsPredicate;\n+\n+import static io.prestosql.sql.planner.optimizations.QueryCardinalityUtil.isAtLeast;\n+import static io.prestosql.sql.planner.plan.Patterns.applyNode;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * Given:\n+ *\n+ * <pre>\n+ * - Apply [X.*, e = EXISTS (true)]\n+ *   - X\n+ *   - S with cardinality >= 1\n+ * </pre>\n+ *\n+ * Produces:\n+ *\n+ * <pre>\n+ * - Project [X.*, e = true]\n+ *   - X\n+ * </pre>\n+ */\n+public class RemoveRedundantExists\n+        implements Rule<ApplyNode>\n+{\n+    private static final Pattern<ApplyNode> PATTERN = applyNode()\n+            .matching(node -> node.getSubqueryAssignments()\n+                    .getExpressions().stream()\n+                    .allMatch(expression -> expression instanceof ExistsPredicate && ((ExistsPredicate) expression).getSubquery().equals(TRUE_LITERAL)));\n+\n+    @Override\n+    public Pattern<ApplyNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(ApplyNode node, Captures captures, Context context)\n+    {\n+        if (!isAtLeast(node.getSubquery(), context.getLookup(), 1)) {\n+            return Result.empty();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4OTMzMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r424689333", "bodyText": "Unit test?", "author": "kasiafi", "createdAt": "2020-05-13T19:46:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/RemoveRedundantExists.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.ApplyNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.ExistsPredicate;\n+\n+import static io.prestosql.sql.planner.optimizations.QueryCardinalityUtil.isAtLeast;\n+import static io.prestosql.sql.planner.plan.Patterns.applyNode;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * Given:\n+ *\n+ * <pre>\n+ * - Apply [X.*, e = EXISTS (true)]\n+ *   - X\n+ *   - S with cardinality >= 1\n+ * </pre>\n+ *\n+ * Produces:\n+ *\n+ * <pre>\n+ * - Project [X.*, e = true]\n+ *   - X\n+ * </pre>\n+ */\n+public class RemoveRedundantExists", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5OTUxOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r424699519", "bodyText": "Removing this piece is not only a cleanup. It has the status of a fix, as NaN wasn't handled correctly here. That could be mentioned in commit message.", "author": "kasiafi", "createdAt": "2020-05-13T20:05:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/ExpressionUtils.java", "diffHunk": "@@ -330,21 +327,6 @@ else if (!seen.contains(expression)) {\n         return result.build();\n     }\n \n-    public static Expression normalize(Expression expression)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE3NjgxOA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443176818", "bodyText": "Good catch! I pulled it out as a separate PR: #4120", "author": "martint", "createdAt": "2020-06-21T03:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5OTUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxODk2Mw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r424718963", "bodyText": "Repeated call to withOnlyVisibleFields() is redundant.", "author": "kasiafi", "createdAt": "2020-05-13T20:42:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1396,7 +1392,7 @@ protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n             }\n \n             Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n-            RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n+            RelationType firstDescriptor = childrenTypes.get(0).withOnlyVisibleFields();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1MTY1NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r424751654", "bodyText": "Please add more tests to show the scope of this change:\n\nnot only in-predicates, but also quantified comparisons benefit from being planned on top of the appropriate source plan:\nSELECT * FROM (VALUES 1, 2, NULL) t(x) RIGHT JOIN (VALUES 1, 3, NULL) u(x) ON u.x > ALL (VALUES 1) failed but now it works\nouter join + mixed left and right references still fails:\nSELECT * FROM (VALUES 1, 2, NULL) t(x) RIGHT JOIN (VALUES 1, 3, NULL) u(x) ON t.x + u.x > ALL (VALUES 1)\ninner join is unaffected by this change and works with mixed references:\nSELECT * FROM (VALUES 1, 2, NULL) t(x) JOIN (VALUES 1, 3, NULL) u(x) ON t.x + u.x > ALL (VALUES 1)", "author": "kasiafi", "createdAt": "2020-05-13T21:50:34Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestJoin.java", "diffHunk": "@@ -50,4 +50,40 @@ public void testCrossJoinEliminationWithOuterJoin()\n                         \"JOIN d ON d.id = a.id\",\n                 \"VALUES 1\");\n     }\n+\n+    @Test\n+    public void testInPredicateInJoinCriteria()\n+    {\n+        assertions.assertQuery(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) JOIN (VALUES 1, 3, NULL) u(x) ON t.x IN (VALUES 1)\",\n+                \"VALUES (1, 1), (1, 3), (1, NULL)\");\n+\n+        assertions.assertQuery(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) LEFT JOIN (VALUES 1, 3, NULL) u(x) ON t.x IN (VALUES 1)\",\n+                \"VALUES (1, 1), (1, 3), (1, NULL), (2, NULL), (NULL, NULL)\");\n+\n+        assertions.assertQuery(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) RIGHT JOIN (VALUES 1, 3, NULL) u(x) ON t.x IN (VALUES 1)\",\n+                \"VALUES (1, 1), (1, 3), (1, NULL)\");\n+\n+        assertions.assertQuery(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) FULL JOIN (VALUES 1, 3, NULL) u(x) ON t.x IN (VALUES 1)\",\n+                \"VALUES (1, 1), (1, 3), (1, NULL), (2, NULL), (NULL, NULL)\");\n+\n+        assertions.assertQuery(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) JOIN (VALUES 1, 3, NULL) u(x) ON u.x IN (VALUES 1)\",\n+                \"VALUES (1, 1), (2, 1), (NULL, 1)\");\n+\n+        assertions.assertQuery(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) LEFT JOIN (VALUES 1, 3, NULL) u(x) ON u.x IN (VALUES 1)\",\n+                \"VALUES (1, 1), (2, 1), (NULL, 1)\");\n+\n+        assertions.assertQuery(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) RIGHT JOIN (VALUES 1, 3, NULL) u(x) ON u.x IN (VALUES 1)\",\n+                \"VALUES (1, 1), (2, 1), (NULL, 1), (NULL, 3), (NULL, NULL)\");\n+\n+        assertions.assertQuery(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) FULL JOIN (VALUES 1, 3, NULL) u(x) ON u.x IN (VALUES 1)\",\n+                \"VALUES (1, 1), (2, 1), (NULL, 1), (NULL, 3), (NULL, NULL)\");\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM2ODg3OA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r425368878", "bodyText": "We perform similar check in ValidateDependenciesChecker. Do we need it in constructor, too?\nThe two mentioned checks are not the same though: in ValidateDependenciesChecker, dependencies are checked for grouping sets symbols mapped by the groupingColumns map. Here, for the map values.\nI think we can simplify the check in ValidateDependenciesChecker the way you did it here.\nAs a missing link, we need a check here in GroupIdNode constructor to make sure that the groupingColumns map is consistent with groupingSets. i.e. that the map keyset is equal to grouping symbols set.\ngroupingSets.stream()\n    .flatMap(Collection::stream)\n    .collect(toImmutableSet)\n    .equals(groupingColumns.keySet())", "author": "kasiafi", "createdAt": "2020-05-14T19:08:10Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/plan/GroupIdNode.java", "diffHunk": "@@ -67,6 +67,9 @@ public GroupIdNode(\n         this.aggregationArguments = ImmutableList.copyOf(aggregationArguments);\n         this.groupIdSymbol = requireNonNull(groupIdSymbol);\n \n+        checkArgument(source.getOutputSymbols().containsAll(groupingColumns.values()));\n+        checkArgument(source.getOutputSymbols().containsAll(aggregationArguments));\n+", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwMDc3OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426200779", "bodyText": "I prefer checks in the nodes. It's easier to spot the error where it happens instead of trying to infer what might have caused it after the plane has gone through several transformations. The checkers at the end are good for verifying non-local properties of the plan.", "author": "martint", "createdAt": "2020-05-16T23:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM2ODg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MDI1NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443370254", "bodyText": "ValidateDependenciesChecker is last resort check. The best would be to not have ValidateDependenciesChecker at all and verify everything along the way.", "author": "kokosing", "createdAt": "2020-06-22T07:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM2ODg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3MzAyOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r425373029", "bodyText": "What is the difference between this case and the following?", "author": "kasiafi", "createdAt": "2020-05-14T19:16:18Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -239,6 +239,18 @@ public void testAllFieldsDereferenceOnSubquery()\n     @Test\n     public void testAllFieldsDereferenceFromNonDeterministic()\n     {\n+        assertPlan(\"SELECT (x, x).* FROM (SELECT rand()) T(x)\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU4OTA5OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r425589099", "bodyText": "No difference :) Probably a left-over from some experiment I was doing.", "author": "martint", "createdAt": "2020-05-15T06:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3MzAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3NDI2Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r425374266", "bodyText": "Uppercase t or lowercase other.", "author": "kasiafi", "createdAt": "2020-05-14T19:18:41Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -250,6 +262,28 @@ public void testAllFieldsDereferenceFromNonDeterministic()\n                                         project(\n                                                 ImmutableMap.of(\"rand\", expression(\"rand()\")),\n                                                 values())))));\n+\n+        assertPlan(\"SELECT (rand(), rand()).* FROM (VALUES 1) T(x)\",\n+                any(\n+                        project(\n+                                ImmutableMap.of(\n+                                        \"output_1\", expression(\"CAST(r AS ROW(f0 double,f1 double)).f0\"),\n+                                        \"output_2\", expression(\"CAST(r AS ROW(f0 double,f1 double)).f1\")),\n+                                project(\n+                                        ImmutableMap.of(\"r\", expression(\"ROW(rand(), rand())\")),\n+                                        values()))));\n+\n+        assertPlan(\"SELECT (rand(), rand()).* FROM (VALUES 1, 2) t(x) ORDER BY 1\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNDY5MA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r425424690", "bodyText": "new line", "author": "kasiafi", "createdAt": "2020-05-14T20:55:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -520,9 +501,9 @@ public void registerTable(\n             QualifiedObjectName name,\n             List<ViewExpression> filters,\n             Map<Field, List<ViewExpression>> columnMasks,\n-            String authorization)\n+            String authorization, Scope accessControlScope)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MDMyOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426190329", "bodyText": "typo in message", "author": "kasiafi", "createdAt": "2020-05-16T20:53:27Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        this.analysis = requireNonNull(analysis, \"comparator is null\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MDM0Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426190342", "bodyText": "Why is the scope replaced? Is it connected with resolving complex join filter expressions?", "author": "kasiafi", "createdAt": "2020-05-16T20:53:40Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -309,15 +316,17 @@ protected RelationPlan visitJoin(Join node, Void context)\n             return planJoinUsing(node, leftPlan, rightPlan);\n         }\n \n-        PlanBuilder leftPlanBuilder = initializePlanBuilder(leftPlan);\n-        PlanBuilder rightPlanBuilder = initializePlanBuilder(rightPlan);\n-\n         // NOTE: symbols must be in the same order as the outputDescriptor\n         List<Symbol> outputSymbols = ImmutableList.<Symbol>builder()\n                 .addAll(leftPlan.getFieldMappings())\n                 .addAll(rightPlan.getFieldMappings())\n                 .build();\n \n+        PlanBuilder leftPlanBuilder = newPlanBuilder(leftPlan, analysis, lambdaDeclarationToSymbolMap)\n+                .withScope(analysis.getScope(node), outputSymbols);\n+        PlanBuilder rightPlanBuilder = newPlanBuilder(rightPlan, analysis, lambdaDeclarationToSymbolMap)\n+                .withScope(analysis.getScope(node), outputSymbols);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzMTc0OA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443331748", "bodyText": "It's because of a quirk in how joins are analyzed and planned. The join expressions are analyzed and resolved against the output scope of the join, so we have to plan then with respect to that scope. I have some ideas on how to clean that up later.", "author": "martint", "createdAt": "2020-06-22T05:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MDM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Nzk5NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426197995", "bodyText": "I would rewrite it as:\n                // case 1. no equality when corresponding column references refer to fields from different level scopes\n                if (leftScope.hasOuterParent(rightScope) || rightScope.hasOuterParent(leftScope)) {\n                    return false;\n                }\n\n                // case 2. both column references were resolved within the original scope:\n                // we cannot rely on syntactical comparison and must take into account local scope hierarchy\n                // (nested local scopes defined by FROM and SELECT clauses)\n                if (isLocalScope(leftScope)) {\n                    return leftField.getFieldId().equals(rightField.getFieldId());\n                }\n\n                // case 3. both column references were resolved within the same outer scope\n                // case 4. column references were resolved within the same or different subquery scopes\n                // syntactical comparison is sufficient\n                return leftExpression.equals(rightExpression);", "author": "kasiafi", "createdAt": "2020-05-16T22:50:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        this.analysis = requireNonNull(analysis, \"comparator is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(Analysis analysis, Scope scope, T node)\n+    {\n+        return new ScopeAware<T>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash(node);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(scope.isLocalScope(other.scope) || other.scope.isLocalScope(scope), \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                if (leftScope != rightScope) {\n+                    if (leftScope.hasOuterParent(scope) && rightScope.hasOuterParent(scope)) {\n+                        // They are local to subqueries, but come from different subqueries\n+                        // The specific fields they reference don't matter as long as everything else is syntactically equal in the subquery\n+                        // TODO: eventually, equality should be based on tracing references to tables/views/CTEs\n+                        return leftExpression.equals(rightExpression);\n+                    }\n+                }\n+\n+                if (isLocalScope(leftScope)) { // pick any, both are equal\n+                    // fields come from the same scope as the original expression, so compare by field id\n+                    return leftField.getFieldId().equals(rightField.getFieldId());\n+                }\n+\n+                // Otherwise, they are either:\n+                // 1. local to the subquery\n+                // 2. from a scope that is a parent to the original scope (we verify that the top-level expressions\n+                //    being compared come from the same local scope)\n+                //\n+                // In the first case, the specific fields they reference don't matter as long as everything else is syntactically equal.\n+                // In the second case, the fields must necessarily be the same if they are syntactically equal.\n+                return leftExpression.equals(rightExpression);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwMDYzOA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426200638", "bodyText": "I think it's simpler than that:\nif (isLocalScope(leftScope) || isLocalScope(rightScope)) {\n    return leftField.getFieldId().equals(rightField.getFieldId());\n}\n\nreturn leftExpression.equals(rightExpression);\nThe \"case 1\" in your example is just a short-circuit, but not necessary for correctness.", "author": "martint", "createdAt": "2020-05-16T23:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Nzk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0NDYzMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426244632", "bodyText": "This is correct, but not in the most obvious way.\nIf we check that either scope is local and then compare fieldIds, we get\n\nlocal-scope-hierarchy-aware comparison in case both fields were local\nfalse in case the other field was not local\n\nWith this assumption, the if-condition could be simply isLocalScope(leftScope)as well.\nI think we could write it differently just for the sake of clarity.\nAnd I can see two options here, depending of what the idea is behind choosing the comparison strategy (syntax vs by-fieldId)\n\n\nidea 1: apply syntactical comparison whenever possible and compare fieldIds only within local scope\n==> the if-condition would be isLocalScope(leftScope) && isLocalScope(rightScope)\n\n\nidea 2: compare by fieldId whenever possible and apply syntactical comparison only for fields local to subqueries. Such strategy would be easy to justify like this:\n\"fieldId is how we normally identify fields. However, with subqueries we want to take advantage if they are identical and that's why we change strategy to syntactical comparison (only for fields local to subqueries)\"\nin this case the code would look like:\n\n\nif (leftScope.hasOuterParent(scope) && rightScope.hasOuterParent(scope)) {\n      return leftExpression.equals(rightExpression);\n      }\nreturn leftField.getFieldId().equals(rightField.getFieldId());\n\nnote: if this approach is chosen, ScopeAware.hash() needs update.", "author": "kasiafi", "createdAt": "2020-05-17T10:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Nzk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0NTI3Nw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426245277", "bodyText": "Rename leftScope -> leftFieldScope, rightScope -> rightFieldScope.\nThis will help keep clear distinction between the \"original\" scope of the analysed Nodes and the resolved scopes of particular fields.", "author": "kasiafi", "createdAt": "2020-05-17T10:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Nzk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc1ODU4Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443758582", "bodyText": "Unfortunately, the latter approach doesn't work. The problem is the following. Given this scope structure:\nFROM     <=== SubQuery 1\n  ^\n  |\n  |\nORDER BY <=== SubQuery 2\n\nWhere ===> are outer scope relations and ---> are local scope relations, when comparing an expression in SubQuery1 scope with the key scope as ORDER BY scope,ORDER BY scope is NOT an outer parent of Subquery 1 scope in the scope tree, but SubQuery 1 is a child of the composite \"local\" scope made up of FROM and ORDER BY. hasOuterParent would need check if any of the local scopes in the outer parent scope is a parent. To make this work, we'd need to change how the scope hierarchy is represented. I plan to do a cleanup of that later, but for now, I'll have to leave this code as is.", "author": "martint", "createdAt": "2020-06-22T18:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Nzk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0NzkxMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426247912", "bodyText": "Renaming the argument lambdaDeclarationToSymbolMap could be extracted to a separate commit.\nMaybe the field lambdaDeclarationToSymbolMap could be renamed accordingly?", "author": "kasiafi", "createdAt": "2020-05-17T11:06:38Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/TranslationMap.java", "diffHunk": "@@ -47,181 +54,162 @@\n class TranslationMap\n {\n     // all expressions are rewritten in terms of fields declared by this relation plan\n-    private final RelationPlan rewriteBase;\n+    private final Scope scope;\n     private final Analysis analysis;\n     private final Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaDeclarationToSymbolMap;\n+    private final Optional<TranslationMap> outerContext;\n \n     // current mappings of underlying field -> symbol for translating direct field references\n     private final Symbol[] fieldSymbols;\n \n     // current mappings of sub-expressions -> symbol\n-    private final Map<Expression, Symbol> expressionToSymbols = new HashMap<>();\n-    private final Map<Expression, Expression> expressionToExpressions = new HashMap<>();\n+    private final Map<ScopeAware<Expression>, Symbol> astToSymbols;\n \n-    public TranslationMap(RelationPlan rewriteBase, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaDeclarationToSymbolMap)\n+    public TranslationMap(Optional<TranslationMap> outerContext, Scope scope, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaArguments, List<Symbol> fieldSymbols)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0OTEzOA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426249138", "bodyText": "please refactor the public method so that the argument T node is in the first place", "author": "kasiafi", "createdAt": "2020-05-17T11:19:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        this.analysis = requireNonNull(analysis, \"comparator is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(Analysis analysis, Scope scope, T node)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MDMzMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426250333", "bodyText": "rename to getSymbolForColumn or something in that manner to reflect more precisely what this method does", "author": "kasiafi", "createdAt": "2020-05-17T11:31:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/TranslationMap.java", "diffHunk": "@@ -272,35 +261,57 @@ public Expression rewriteLambdaExpression(LambdaExpression node, Void context, E\n             @Override\n             public Expression rewriteParameter(Parameter node, Void context, ExpressionTreeRewriter<Void> treeRewriter)\n             {\n+                Optional<Expression> mapped = tryGetMapping(node);\n+                if (mapped.isPresent()) {\n+                    return coerceIfNecessary(node, mapped.get());\n+                }\n+\n                 checkState(analysis.getParameters().size() > node.getPosition(), \"Too few parameter values\");\n                 return coerceIfNecessary(node, treeRewriter.rewrite(analysis.getParameters().get(NodeRef.of(node)), null));\n             }\n \n             private Expression coerceIfNecessary(Expression original, Expression rewritten)\n             {\n-                Type coercion = analysis.getCoercion(original);\n-                if (coercion != null) {\n-                    rewritten = new Cast(\n-                            rewritten,\n-                            toSqlType(coercion),\n-                            false,\n-                            analysis.isTypeOnlyCoercion(original));\n+                // Don't add a coercion for the top-level expression\n+                if (original == expression) {\n+                    return rewritten;\n                 }\n-                return rewritten;\n+\n+                return QueryPlanner.coerceIfNecessary(analysis, original, rewritten);\n             }\n         }, expression, null);\n     }\n \n-    private Optional<Symbol> getSymbol(RelationPlan plan, Expression expression)\n+    private Optional<Expression> tryGetMapping(Expression expression)\n+    {\n+        return Optional.ofNullable(astToSymbols.get(scopeAwareKey(analysis, scope, expression)))\n+                .map(Symbol::toSymbolReference);\n+    }\n+\n+    private Optional<Symbol> getSymbol(Expression expression)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MDc4NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426250785", "bodyText": "You could comment more explicitly why not add coercion on top level: \"whether to coerce the top-level expression depends on the caller of rewrite()\".", "author": "kasiafi", "createdAt": "2020-05-17T11:36:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/TranslationMap.java", "diffHunk": "@@ -272,35 +261,57 @@ public Expression rewriteLambdaExpression(LambdaExpression node, Void context, E\n             @Override\n             public Expression rewriteParameter(Parameter node, Void context, ExpressionTreeRewriter<Void> treeRewriter)\n             {\n+                Optional<Expression> mapped = tryGetMapping(node);\n+                if (mapped.isPresent()) {\n+                    return coerceIfNecessary(node, mapped.get());\n+                }\n+\n                 checkState(analysis.getParameters().size() > node.getPosition(), \"Too few parameter values\");\n                 return coerceIfNecessary(node, treeRewriter.rewrite(analysis.getParameters().get(NodeRef.of(node)), null));\n             }\n \n             private Expression coerceIfNecessary(Expression original, Expression rewritten)\n             {\n-                Type coercion = analysis.getCoercion(original);\n-                if (coercion != null) {\n-                    rewritten = new Cast(\n-                            rewritten,\n-                            toSqlType(coercion),\n-                            false,\n-                            analysis.isTypeOnlyCoercion(original));\n+                // Don't add a coercion for the top-level expression", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1Mjc0Nw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426252747", "bodyText": "How about FunctionCalls? Shouldn't it be verified that the function is ast? (i.e. that it hasn't got information about the resolved function yet)", "author": "kasiafi", "createdAt": "2020-05-17T11:57:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/TranslationMap.java", "diffHunk": "@@ -272,35 +261,57 @@ public Expression rewriteLambdaExpression(LambdaExpression node, Void context, E\n             @Override\n             public Expression rewriteParameter(Parameter node, Void context, ExpressionTreeRewriter<Void> treeRewriter)\n             {\n+                Optional<Expression> mapped = tryGetMapping(node);\n+                if (mapped.isPresent()) {\n+                    return coerceIfNecessary(node, mapped.get());\n+                }\n+\n                 checkState(analysis.getParameters().size() > node.getPosition(), \"Too few parameter values\");\n                 return coerceIfNecessary(node, treeRewriter.rewrite(analysis.getParameters().get(NodeRef.of(node)), null));\n             }\n \n             private Expression coerceIfNecessary(Expression original, Expression rewritten)\n             {\n-                Type coercion = analysis.getCoercion(original);\n-                if (coercion != null) {\n-                    rewritten = new Cast(\n-                            rewritten,\n-                            toSqlType(coercion),\n-                            false,\n-                            analysis.isTypeOnlyCoercion(original));\n+                // Don't add a coercion for the top-level expression\n+                if (original == expression) {\n+                    return rewritten;\n                 }\n-                return rewritten;\n+\n+                return QueryPlanner.coerceIfNecessary(analysis, original, rewritten);\n             }\n         }, expression, null);\n     }\n \n-    private Optional<Symbol> getSymbol(RelationPlan plan, Expression expression)\n+    private Optional<Expression> tryGetMapping(Expression expression)\n+    {\n+        return Optional.ofNullable(astToSymbols.get(scopeAwareKey(analysis, scope, expression)))\n+                .map(Symbol::toSymbolReference);\n+    }\n+\n+    private Optional<Symbol> getSymbol(Expression expression)\n     {\n         if (!analysis.isColumnReference(expression)) {\n             // Expression can be a reference to lambda argument (or DereferenceExpression based on lambda argument reference).\n             // In such case, the expression might still be resolvable with plan.getScope() but we should not resolve it.\n             return Optional.empty();\n         }\n-        return plan.getScope()\n-                .tryResolveField(expression)\n-                .filter(ResolvedField::isLocal)\n-                .map(field -> requireNonNull(plan.getFieldMappings().get(field.getHierarchyFieldIndex())));\n+\n+        ResolvedField field = analysis.getColumnReferenceFields().get(NodeRef.of(expression));\n+\n+        if (scope.isLocalScope(field.getScope())) {\n+            return Optional.of(fieldSymbols[field.getHierarchyFieldIndex()]);\n+        }\n+\n+        return Optional.of(Symbol.from(outerContext.get().rewrite(expression)));\n+    }\n+\n+    private static void verifyAstExpression(Expression astExpression)\n+    {\n+        verify(AstUtils.preOrder(astExpression).noneMatch(SymbolReference.class::isInstance));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MzQ2NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426253465", "bodyText": "I think this verify deserves a comment, either here or at the declaration of astToSymbols field.\nIt should say that TranslationMap only holds mappings for purely-ast expressions.\nAnd some explanation what those are, e.g. what are the ast-land references to columns as opposed to IR-land SymbolReference.\nUsing TranslationMap with non-ast expressions fails, either when trying to add mappings or at call to canTranslate() or rewrite().", "author": "kasiafi", "createdAt": "2020-05-17T12:05:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/TranslationMap.java", "diffHunk": "@@ -47,181 +54,162 @@\n class TranslationMap\n {\n     // all expressions are rewritten in terms of fields declared by this relation plan\n-    private final RelationPlan rewriteBase;\n+    private final Scope scope;\n     private final Analysis analysis;\n     private final Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaDeclarationToSymbolMap;\n+    private final Optional<TranslationMap> outerContext;\n \n     // current mappings of underlying field -> symbol for translating direct field references\n     private final Symbol[] fieldSymbols;\n \n     // current mappings of sub-expressions -> symbol\n-    private final Map<Expression, Symbol> expressionToSymbols = new HashMap<>();\n-    private final Map<Expression, Expression> expressionToExpressions = new HashMap<>();\n+    private final Map<ScopeAware<Expression>, Symbol> astToSymbols;\n \n-    public TranslationMap(RelationPlan rewriteBase, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaDeclarationToSymbolMap)\n+    public TranslationMap(Optional<TranslationMap> outerContext, Scope scope, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaArguments, List<Symbol> fieldSymbols)\n     {\n-        this.rewriteBase = requireNonNull(rewriteBase, \"rewriteBase is null\");\n-        this.analysis = requireNonNull(analysis, \"analysis is null\");\n-        this.lambdaDeclarationToSymbolMap = requireNonNull(lambdaDeclarationToSymbolMap, \"lambdaDeclarationToSymbolMap is null\");\n-\n-        fieldSymbols = new Symbol[rewriteBase.getFieldMappings().size()];\n-    }\n-\n-    public RelationPlan getRelationPlan()\n-    {\n-        return rewriteBase;\n+        this(outerContext, scope, analysis, lambdaArguments, fieldSymbols.toArray(new Symbol[0]).clone(), ImmutableMap.of());\n     }\n \n-    public Analysis getAnalysis()\n+    public TranslationMap(Optional<TranslationMap> outerContext, Scope scope, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaArguments, List<Symbol> fieldSymbols, Map<ScopeAware<Expression>, Symbol> astToSymbols)\n     {\n-        return analysis;\n+        this(outerContext, scope, analysis, lambdaArguments, fieldSymbols.toArray(new Symbol[0]), astToSymbols);\n     }\n \n-    public Map<NodeRef<LambdaArgumentDeclaration>, Symbol> getLambdaDeclarationToSymbolMap()\n+    public TranslationMap(Optional<TranslationMap> outerContext, Scope scope, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaArguments, Symbol[] fieldSymbols, Map<ScopeAware<Expression>, Symbol> astToSymbols)\n     {\n-        return lambdaDeclarationToSymbolMap;\n-    }\n+        this.outerContext = requireNonNull(outerContext, \"outerContext is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.lambdaDeclarationToSymbolMap = requireNonNull(lambdaArguments, \"lambdaArguments is null\");\n \n-    public void setFieldMappings(List<Symbol> symbols)\n-    {\n-        checkArgument(symbols.size() == fieldSymbols.length, \"size of symbols list (%s) doesn't match number of expected fields (%s)\", symbols.size(), fieldSymbols.length);\n+        requireNonNull(fieldSymbols, \"fieldSymbols is null\");\n+        this.fieldSymbols = fieldSymbols.clone();\n \n-        for (int i = 0; i < symbols.size(); i++) {\n-            this.fieldSymbols[i] = symbols.get(i);\n-        }\n-    }\n+        requireNonNull(astToSymbols, \"astToSymbols is null\");\n+        this.astToSymbols = ImmutableMap.copyOf(astToSymbols);\n \n-    public void copyMappingsFrom(TranslationMap other)\n-    {\n-        checkArgument(other.fieldSymbols.length == fieldSymbols.length,\n-                \"number of fields in other (%s) doesn't match number of expected fields (%s)\",\n-                other.fieldSymbols.length,\n+        checkArgument(scope.getLocalScopeFieldCount() == fieldSymbols.length,\n+                \"scope: %s, fields mappings: %s\",\n+                scope.getRelationType().getAllFieldCount(),\n                 fieldSymbols.length);\n \n-        expressionToSymbols.putAll(other.expressionToSymbols);\n-        expressionToExpressions.putAll(other.expressionToExpressions);\n-        System.arraycopy(other.fieldSymbols, 0, fieldSymbols, 0, other.fieldSymbols.length);\n+        astToSymbols.keySet().stream()\n+            .map(ScopeAware::getNode)\n+            .forEach(TranslationMap::verifyAstExpression);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNTE0MA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443335140", "bodyText": "Ok, I'll add a comment in the class Javadocs", "author": "martint", "createdAt": "2020-06-22T06:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MzQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg0MTQ0Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426841446", "bodyText": "checkNotNull(symbol)\nsame could be added in rewriteLambdaExpression()", "author": "kasiafi", "createdAt": "2020-05-18T19:16:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/TranslationMap.java", "diffHunk": "@@ -47,181 +54,162 @@\n class TranslationMap\n {\n     // all expressions are rewritten in terms of fields declared by this relation plan\n-    private final RelationPlan rewriteBase;\n+    private final Scope scope;\n     private final Analysis analysis;\n     private final Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaDeclarationToSymbolMap;\n+    private final Optional<TranslationMap> outerContext;\n \n     // current mappings of underlying field -> symbol for translating direct field references\n     private final Symbol[] fieldSymbols;\n \n     // current mappings of sub-expressions -> symbol\n-    private final Map<Expression, Symbol> expressionToSymbols = new HashMap<>();\n-    private final Map<Expression, Expression> expressionToExpressions = new HashMap<>();\n+    private final Map<ScopeAware<Expression>, Symbol> astToSymbols;\n \n-    public TranslationMap(RelationPlan rewriteBase, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaDeclarationToSymbolMap)\n+    public TranslationMap(Optional<TranslationMap> outerContext, Scope scope, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaArguments, List<Symbol> fieldSymbols)\n     {\n-        this.rewriteBase = requireNonNull(rewriteBase, \"rewriteBase is null\");\n-        this.analysis = requireNonNull(analysis, \"analysis is null\");\n-        this.lambdaDeclarationToSymbolMap = requireNonNull(lambdaDeclarationToSymbolMap, \"lambdaDeclarationToSymbolMap is null\");\n-\n-        fieldSymbols = new Symbol[rewriteBase.getFieldMappings().size()];\n-    }\n-\n-    public RelationPlan getRelationPlan()\n-    {\n-        return rewriteBase;\n+        this(outerContext, scope, analysis, lambdaArguments, fieldSymbols.toArray(new Symbol[0]).clone(), ImmutableMap.of());\n     }\n \n-    public Analysis getAnalysis()\n+    public TranslationMap(Optional<TranslationMap> outerContext, Scope scope, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaArguments, List<Symbol> fieldSymbols, Map<ScopeAware<Expression>, Symbol> astToSymbols)\n     {\n-        return analysis;\n+        this(outerContext, scope, analysis, lambdaArguments, fieldSymbols.toArray(new Symbol[0]), astToSymbols);\n     }\n \n-    public Map<NodeRef<LambdaArgumentDeclaration>, Symbol> getLambdaDeclarationToSymbolMap()\n+    public TranslationMap(Optional<TranslationMap> outerContext, Scope scope, Analysis analysis, Map<NodeRef<LambdaArgumentDeclaration>, Symbol> lambdaArguments, Symbol[] fieldSymbols, Map<ScopeAware<Expression>, Symbol> astToSymbols)\n     {\n-        return lambdaDeclarationToSymbolMap;\n-    }\n+        this.outerContext = requireNonNull(outerContext, \"outerContext is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.lambdaDeclarationToSymbolMap = requireNonNull(lambdaArguments, \"lambdaArguments is null\");\n \n-    public void setFieldMappings(List<Symbol> symbols)\n-    {\n-        checkArgument(symbols.size() == fieldSymbols.length, \"size of symbols list (%s) doesn't match number of expected fields (%s)\", symbols.size(), fieldSymbols.length);\n+        requireNonNull(fieldSymbols, \"fieldSymbols is null\");\n+        this.fieldSymbols = fieldSymbols.clone();\n \n-        for (int i = 0; i < symbols.size(); i++) {\n-            this.fieldSymbols[i] = symbols.get(i);\n-        }\n-    }\n+        requireNonNull(astToSymbols, \"astToSymbols is null\");\n+        this.astToSymbols = ImmutableMap.copyOf(astToSymbols);\n \n-    public void copyMappingsFrom(TranslationMap other)\n-    {\n-        checkArgument(other.fieldSymbols.length == fieldSymbols.length,\n-                \"number of fields in other (%s) doesn't match number of expected fields (%s)\",\n-                other.fieldSymbols.length,\n+        checkArgument(scope.getLocalScopeFieldCount() == fieldSymbols.length,\n+                \"scope: %s, fields mappings: %s\",\n+                scope.getRelationType().getAllFieldCount(),\n                 fieldSymbols.length);\n \n-        expressionToSymbols.putAll(other.expressionToSymbols);\n-        expressionToExpressions.putAll(other.expressionToExpressions);\n-        System.arraycopy(other.fieldSymbols, 0, fieldSymbols, 0, other.fieldSymbols.length);\n+        astToSymbols.keySet().stream()\n+            .map(ScopeAware::getNode)\n+            .forEach(TranslationMap::verifyAstExpression);\n     }\n \n-    public void putExpressionMappingsFrom(TranslationMap other)\n+    public TranslationMap withScope(Scope scope, List<Symbol> fields)\n     {\n-        expressionToSymbols.putAll(other.expressionToSymbols);\n-        expressionToExpressions.putAll(other.expressionToExpressions);\n+        return new TranslationMap(outerContext, scope, analysis, lambdaDeclarationToSymbolMap, fields.toArray(new Symbol[0]), astToSymbols);\n     }\n \n-    public Expression rewrite(Expression expression)\n+    public TranslationMap withNewMappings(Map<Expression, Symbol> mappings, List<Symbol> fields)\n     {\n-        // first, translate names from sql-land references to plan symbols\n-        Expression mapped = translateNamesToSymbols(expression);\n-\n-        // then rewrite subexpressions in terms of the current mappings\n-        return ExpressionTreeRewriter.rewriteWith(new ExpressionRewriter<Void>()\n-        {\n-            @Override\n-            protected Expression rewriteExpression(Expression node, Void context, ExpressionTreeRewriter<Void> treeRewriter)\n-            {\n-                if (expressionToSymbols.containsKey(node)) {\n-                    return expressionToSymbols.get(node).toSymbolReference();\n-                }\n+        Map<ScopeAware<Expression>, Symbol> newMappings = mappings.entrySet().stream()\n+                .collect(toImmutableMap(entry -> scopeAwareKey(analysis, scope, entry.getKey()), Map.Entry::getValue));\n \n-                Expression translated = expressionToExpressions.getOrDefault(node, node);\n-                return treeRewriter.defaultRewrite(translated, context);\n-            }\n-        }, mapped);\n+        return new TranslationMap(outerContext, scope, analysis, lambdaDeclarationToSymbolMap, fields, newMappings);\n     }\n \n-    public void put(Expression expression, Symbol symbol)\n+    public TranslationMap withAdditionalMappings(Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        if (expression instanceof FieldReference) {\n-            int fieldIndex = ((FieldReference) expression).getFieldIndex();\n-            fieldSymbols[fieldIndex] = symbol;\n-            expressionToSymbols.put(rewriteBase.getSymbol(fieldIndex).toSymbolReference(), symbol);\n-            return;\n-        }\n+        Map<ScopeAware<Expression>, Symbol> newMappings = new HashMap<>();\n+        newMappings.putAll(this.astToSymbols);\n+        newMappings.putAll(mappings);\n \n-        Expression translated = translateNamesToSymbols(expression);\n-        expressionToSymbols.put(translated, symbol);\n+        return new TranslationMap(outerContext, scope, analysis, lambdaDeclarationToSymbolMap, fieldSymbols, newMappings);\n+    }\n \n-        // also update the field mappings if this expression is a field reference\n-        rewriteBase.getScope().tryResolveField(expression)\n-                .filter(ResolvedField::isLocal)\n-                .ifPresent(field -> fieldSymbols[field.getHierarchyFieldIndex()] = symbol);\n+    public List<Symbol> getFieldSymbols()\n+    {\n+        return Collections.unmodifiableList(Arrays.asList(fieldSymbols));\n     }\n \n-    public boolean containsSymbol(Expression expression)\n+    public Map<ScopeAware<Expression>, Symbol> getMappings()\n     {\n-        if (expression instanceof FieldReference) {\n-            int field = ((FieldReference) expression).getFieldIndex();\n-            return fieldSymbols[field] != null;\n-        }\n+        return astToSymbols;\n+    }\n \n-        Expression translated = translateNamesToSymbols(expression);\n-        return expressionToSymbols.containsKey(translated);\n+    public Analysis getAnalysis()\n+    {\n+        return analysis;\n     }\n \n-    public Symbol get(Expression expression)\n+    public boolean canTranslate(Expression expression)\n     {\n-        if (expression instanceof FieldReference) {\n-            int field = ((FieldReference) expression).getFieldIndex();\n-            checkArgument(fieldSymbols[field] != null, \"No mapping for field: %s\", field);\n-            return fieldSymbols[field];\n+        verifyAstExpression(expression);\n+\n+        if (astToSymbols.containsKey(scopeAwareKey(analysis, scope, expression)) || expression instanceof FieldReference) {\n+            return true;\n         }\n \n-        Expression translated = translateNamesToSymbols(expression);\n-        if (!expressionToSymbols.containsKey(translated)) {\n-            checkArgument(expressionToExpressions.containsKey(translated), \"No mapping for expression: %s\", expression);\n-            return get(expressionToExpressions.get(translated));\n+        if (analysis.isColumnReference(expression)) {\n+            ResolvedField field = analysis.getColumnReferenceFields().get(NodeRef.of(expression));\n+            return scope.isLocalScope(field.getScope());\n         }\n \n-        return expressionToSymbols.get(translated);\n+        return false;\n     }\n \n-    public void put(Expression expression, Expression rewritten)\n+    public Expression rewrite(Expression expression)\n     {\n-        expressionToExpressions.put(translateNamesToSymbols(expression), rewritten);\n-    }\n+        verifyAstExpression(expression);\n \n-    private Expression translateNamesToSymbols(Expression expression)\n-    {\n         return ExpressionTreeRewriter.rewriteWith(new ExpressionRewriter<Void>()\n         {\n             @Override\n             protected Expression rewriteExpression(Expression node, Void context, ExpressionTreeRewriter<Void> treeRewriter)\n             {\n+                Optional<Expression> mapped = tryGetMapping(node);\n+                if (mapped.isPresent()) {\n+                    return coerceIfNecessary(node, mapped.get());\n+                }\n+\n                 Expression rewrittenExpression = treeRewriter.defaultRewrite(node, context);\n                 return coerceIfNecessary(node, rewrittenExpression);\n             }\n \n             @Override\n             public Expression rewriteFieldReference(FieldReference node, Void context, ExpressionTreeRewriter<Void> treeRewriter)\n             {\n-                Symbol symbol = rewriteBase.getSymbol(node.getFieldIndex());\n-                checkState(symbol != null, \"No symbol mapping for node '%s' (%s)\", node, node.getFieldIndex());\n-                return symbol.toSymbolReference();\n+                Optional<Expression> mapped = tryGetMapping(node);\n+                if (mapped.isPresent()) {\n+                    return coerceIfNecessary(node, mapped.get());\n+                }\n+\n+                return getSymbol(node)\n+                        .map(Symbol::toSymbolReference)\n+                        .orElseThrow(() -> new IllegalStateException(format(\"No symbol mapping for node '%s' (%s)\", node, node.getFieldIndex())));\n             }\n \n             @Override\n             public Expression rewriteIdentifier(Identifier node, Void context, ExpressionTreeRewriter<Void> treeRewriter)\n             {\n+                Optional<Expression> mapped = tryGetMapping(node);\n+                if (mapped.isPresent()) {\n+                    return coerceIfNecessary(node, mapped.get());\n+                }\n+\n                 LambdaArgumentDeclaration referencedLambdaArgumentDeclaration = analysis.getLambdaArgumentReference(node);\n                 if (referencedLambdaArgumentDeclaration != null) {\n                     Symbol symbol = lambdaDeclarationToSymbolMap.get(NodeRef.of(referencedLambdaArgumentDeclaration));\n                     return coerceIfNecessary(node, symbol.toSymbolReference());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNTY4Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443335682", "bodyText": "That's unrelated to this PR. We can do it as a separate change.", "author": "martint", "createdAt": "2020-06-22T06:12:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg0MTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkwMDM2OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426900369", "bodyText": "handleSubqueries() could be skipped, since outputs are all FieldReferences.", "author": "kasiafi", "createdAt": "2020-05-18T21:22:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -136,35 +146,28 @@ public RelationPlan plan(Query query)\n         builder = handleSubqueries(builder, query, orderBy);\n \n         List<SelectExpression> selectExpressions = analysis.getSelectExpressions(query);\n-        List<Expression> expressions = selectExpressions.stream()\n+        List<Expression> outputs = selectExpressions.stream()\n                 .map(SelectExpression::getExpression)\n                 .collect(toImmutableList());\n-        List<Expression> outputs = expressions;\n-        builder = handleSubqueries(builder, query, expressions);\n-        builder = project(builder, Iterables.concat(orderBy, expressions));\n-\n-        if (hasExpressionsToUnfold(selectExpressions)) {\n-            List<Expression> outputExpressions = outputExpressions(selectExpressions);\n-            builder = project(builder, Iterables.concat(orderBy, outputExpressions));\n-            outputs = toSymbolReferences(computeOutputs(builder, outputExpressions));\n-        }\n+        builder = handleSubqueries(builder, query, outputs);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkwMTIzNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426901237", "bodyText": "This forwarding method is redundant.\nThere is handleSubqueries(PlanBuilder, Collection<Expression>, Node) method in SubqueryPlanner", "author": "kasiafi", "createdAt": "2020-05-18T21:24:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -876,32 +662,86 @@ private PlanBuilder window(PlanBuilder subPlan, List<FunctionCall> windowFunctio\n                             Optional.empty(),\n                             ImmutableSet.of(),\n                             0));\n+        }\n+\n+        return subPlan;\n+    }\n+\n+    /**\n+     * Creates a projection with any additional coercions by identity of the provided expressions.\n+     *\n+     * @return the new subplan and a mapping of each expression to the symbol representing the coercion or an existing symbol if a coercion wasn't needed\n+     */\n+    public static PlanAndMappings coerce(PlanBuilder subPlan, List<Expression> expressions, Analysis analysis, PlanNodeIdAllocator idAllocator, SymbolAllocator symbolAllocator, TypeCoercion typeCoercion)\n+    {\n+        Assignments.Builder assignments = Assignments.builder();\n+        assignments.putIdentities(subPlan.getRoot().getOutputSymbols());\n+\n+        ImmutableMap.Builder<NodeRef<Expression>, Symbol> mappings = ImmutableMap.builder();\n+        for (Expression expression : expressions) {\n+            Type coercion = analysis.getCoercion(expression);\n+\n+            if (coercion != null) {\n+                Type type = analysis.getType(expression);\n+                Symbol symbol = symbolAllocator.newSymbol(expression, firstNonNull(coercion, type));\n+\n+                assignments.put(symbol, new Cast(\n+                        subPlan.rewrite(expression),\n+                        toSqlType(coercion),\n+                        false,\n+                        typeCoercion.isTypeOnlyCoercion(type, coercion)));\n \n-            if (needCoercion) {\n-                subPlan = explicitCoercionSymbols(subPlan, sourceSymbols, ImmutableList.of(windowFunction));\n+                mappings.put(NodeRef.of(expression), symbol);\n+            }\n+            else {\n+                mappings.put(NodeRef.of(expression), subPlan.translate(expression));\n             }\n         }\n \n-        return subPlan;\n+        subPlan = subPlan.withNewRoot(\n+                new ProjectNode(\n+                        idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        assignments.build()));\n+\n+        return new PlanAndMappings(subPlan, mappings.build());\n+    }\n+\n+    public static Expression coerceIfNecessary(Analysis analysis, Expression original, Expression rewritten)\n+    {\n+        Type coercion = analysis.getCoercion(original);\n+        if (coercion == null) {\n+            return rewritten;\n+        }\n+\n+        return new Cast(\n+                rewritten,\n+                toSqlType(coercion),\n+                false,\n+                analysis.isTypeOnlyCoercion(original));\n     }\n \n     private PlanBuilder handleSubqueries(PlanBuilder subPlan, Node node, Iterable<Expression> inputs)\n     {\n         for (Expression input : inputs) {\n-            subPlan = subqueryPlanner.handleSubqueries(subPlan, subPlan.rewrite(input), node);\n+            subPlan = subqueryPlanner.handleSubqueries(subPlan, input, node);\n         }\n         return subPlan;\n     }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxNjI5OA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r426916298", "bodyText": "To me, the comments would be more helpful in this form:\nList<Expression> outputs = outputExpressions(selectExpressions);\n        if (node.getOrderBy().isPresent()) {\n            // ORDER BY requires outputs of SELECT to be visible.\n            // For queries with aggregation, it also requires grouping keys and translated aggregations.\n            if (analysis.isAggregation(node)) {\n                // Add projections for aggregations required by ORDER BY. After this step, grouping keys and translated aggregations are visible.\n                List<Expression> orderByAggregates = analysis.getOrderByAggregates(node.getOrderBy().get());\n                builder = builder.appendProjections(orderByAggregates, symbolAllocator, idAllocator);\n            }", "author": "kasiafi", "createdAt": "2020-05-18T22:00:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -176,64 +179,55 @@ public RelationPlan plan(QuerySpecification node)\n         List<Expression> expressions = selectExpressions.stream()\n                 .map(SelectExpression::getExpression)\n                 .collect(toImmutableList());\n-        List<Expression> outputs = expressions;\n         builder = handleSubqueries(builder, node, expressions);\n-        List<Expression> outputExpressions = outputExpressions(selectExpressions);\n \n-        if (node.getOrderBy().isPresent()) {\n-            if (!analysis.isAggregation(node)) {\n-                // ORDER BY requires both output and source fields to be visible if there are no aggregations\n-                builder = project(builder, Iterables.concat(expressions, toSymbolReferences(fromRelationPlan.getFieldMappings())));\n-                outputs = toSymbolReferences(computeOutputs(builder, expressions));\n-\n-                if (hasExpressionsToUnfold(selectExpressions)) {\n-                    builder = project(builder, Iterables.concat(outputExpressions, toSymbolReferences(fromRelationPlan.getFieldMappings())));\n-                    outputs = toSymbolReferences(computeOutputs(builder, outputExpressions));\n-                }\n+        if (hasExpressionsToUnfold(selectExpressions)) {\n+            // pre-project the folded expressions to preserve any non-deterministic semantics of functions that might be referenced\n+            builder = builder.appendProjections(expressions, symbolAllocator, idAllocator);\n+        }\n \n-                builder = planBuilderFor(builder, analysis.getScope(node.getOrderBy().get()));\n-            }\n-            else {\n+        List<Expression> outputs = outputExpressions(selectExpressions);\n+        if (node.getOrderBy().isPresent()) {\n+            if (analysis.isAggregation(node)) {\n                 // ORDER BY requires output fields, groups and translated aggregations to be visible for queries with aggregation\n                 List<Expression> orderByAggregates = analysis.getOrderByAggregates(node.getOrderBy().get());\n-                builder = project(builder, Iterables.concat(expressions, orderByAggregates));\n-                outputs = toSymbolReferences(computeOutputs(builder, expressions));\n+                builder = builder.appendProjections(orderByAggregates, symbolAllocator, idAllocator);\n+            }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU3MzA2OA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r427573068", "bodyText": "It seems that columns and fields and descriptor are unused. The only effect of this code is adding symbols in SymbolAllocator. However, it might be redundant as they are not accessed.\nThis is prior to this PR.", "author": "kasiafi", "createdAt": "2020-05-19T20:15:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -273,10 +267,10 @@ public DeleteNode plan(Delete node)\n         }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NjAyNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r427596027", "bodyText": "renaming could be extracted to a separate commit.", "author": "kasiafi", "createdAt": "2020-05-19T20:58:39Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -460,15 +333,12 @@ private PlanBuilder aggregate(PlanBuilder subPlan, QuerySpecification node)\n             return subPlan;\n         }\n \n-        // 1. Pre-project all scalar inputs (arguments and non-trivial group by expressions)\n-        Set<Expression> groupByExpressions = ImmutableSet.copyOf(analysis.getGroupByExpressions(node));\n-\n-        ImmutableList.Builder<Expression> arguments = ImmutableList.builder();\n+        ImmutableList.Builder<Expression> inputBuilder = ImmutableList.builder();\n         analysis.getAggregates(node).stream()\n                 .map(FunctionCall::getArguments)\n                 .flatMap(List::stream)\n-                .filter(exp -> !(exp instanceof LambdaExpression)) // lambda expression is generated at execution time\n-                .forEach(arguments::add);\n+                .filter(expression -> !(expression instanceof LambdaExpression)) // lambda expression is generated at execution time\n+                .forEach(inputBuilder::add);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMDkwNQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r427600905", "bodyText": "firstNonNull(coercion, type) -> coercion", "author": "kasiafi", "createdAt": "2020-05-19T21:08:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -869,32 +662,86 @@ private PlanBuilder window(PlanBuilder subPlan, List<FunctionCall> windowFunctio\n                             Optional.empty(),\n                             ImmutableSet.of(),\n                             0));\n+        }\n+\n+        return subPlan;\n+    }\n+\n+    /**\n+     * Creates a projection with any additional coercions by identity of the provided expressions.\n+     *\n+     * @return the new subplan and a mapping of each expression to the symbol representing the coercion or an existing symbol if a coercion wasn't needed\n+     */\n+    public static PlanAndMappings coerce(PlanBuilder subPlan, List<Expression> expressions, Analysis analysis, PlanNodeIdAllocator idAllocator, SymbolAllocator symbolAllocator, TypeCoercion typeCoercion)\n+    {\n+        Assignments.Builder assignments = Assignments.builder();\n+        assignments.putIdentities(subPlan.getRoot().getOutputSymbols());\n+\n+        ImmutableMap.Builder<NodeRef<Expression>, Symbol> mappings = ImmutableMap.builder();\n+        for (Expression expression : expressions) {\n+            Type coercion = analysis.getCoercion(expression);\n+\n+            if (coercion != null) {\n+                Type type = analysis.getType(expression);\n+                Symbol symbol = symbolAllocator.newSymbol(expression, firstNonNull(coercion, type));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMzM0OA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r427623348", "bodyText": "Instead of Map, this could be List<AggregationAssignment>. Map keys are certainly unique. They are also not referenced.", "author": "kasiafi", "createdAt": "2020-05-19T21:55:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -477,130 +347,68 @@ private PlanBuilder aggregate(PlanBuilder subPlan, QuerySpecification node)\n                 .map(OrderBy::getSortItems)\n                 .flatMap(List::stream)\n                 .map(SortItem::getSortKey)\n-                .forEach(arguments::add);\n+                .forEach(inputBuilder::add);\n \n         // filter expressions need to be projected first\n         analysis.getAggregates(node).stream()\n                 .map(FunctionCall::getFilter)\n                 .filter(Optional::isPresent)\n                 .map(Optional::get)\n-                .forEach(arguments::add);\n-\n-        Iterable<Expression> inputs = Iterables.concat(groupByExpressions, arguments.build());\n-        subPlan = handleSubqueries(subPlan, node, inputs);\n-\n-        if (!Iterables.isEmpty(inputs)) { // avoid an empty projection if the only aggregation is COUNT (which has no arguments)\n-            subPlan = project(subPlan, inputs);\n-        }\n-\n-        // 2. Aggregate\n-\n-        // 2.a. Rewrite aggregate arguments\n-        TranslationMap argumentTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n-\n-        ImmutableList.Builder<Symbol> aggregationArgumentsBuilder = ImmutableList.builder();\n-        for (Expression argument : arguments.build()) {\n-            Symbol symbol = subPlan.translate(argument);\n-            argumentTranslations.put(argument, symbol);\n-            aggregationArgumentsBuilder.add(symbol);\n-        }\n-        List<Symbol> aggregationArguments = aggregationArgumentsBuilder.build();\n-\n-        // 2.b. Rewrite grouping columns\n-        TranslationMap groupingTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n-        Map<Symbol, Symbol> groupingSetMappings = new LinkedHashMap<>();\n-\n-        for (Expression expression : groupByExpressions) {\n-            Symbol input = subPlan.translate(expression);\n-            Symbol output = symbolAllocator.newSymbol(expression, analysis.getTypeWithCoercions(expression), \"gid\");\n-            groupingTranslations.put(expression, output);\n-            groupingSetMappings.put(output, input);\n-        }\n-\n-        // This tracks the grouping sets before complex expressions are considered (see comments below)\n-        // It's also used to compute the descriptors needed to implement grouping()\n-        List<Set<FieldId>> columnOnlyGroupingSets = ImmutableList.of(ImmutableSet.of());\n-        List<List<Symbol>> groupingSets = ImmutableList.of(ImmutableList.of());\n-\n-        if (node.getGroupBy().isPresent()) {\n-            // For the purpose of \"distinct\", we need to canonicalize column references that may have varying\n-            // syntactic forms (e.g., \"t.a\" vs \"a\"). Thus we need to enumerate grouping sets based on the underlying\n-            // fieldId associated with each column reference expression.\n-\n-            // The catch is that simple group-by expressions can be arbitrary expressions (this is a departure from the SQL specification).\n-            // But, they don't affect the number of grouping sets or the behavior of \"distinct\" . We can compute all the candidate\n-            // grouping sets in terms of fieldId, dedup as appropriate and then cross-join them with the complex expressions.\n-            Analysis.GroupingSetAnalysis groupingSetAnalysis = analysis.getGroupingSets(node);\n-            columnOnlyGroupingSets = enumerateGroupingSets(groupingSetAnalysis);\n-\n-            if (node.getGroupBy().get().isDistinct()) {\n-                columnOnlyGroupingSets = columnOnlyGroupingSets.stream()\n-                        .distinct()\n-                        .collect(toImmutableList());\n-            }\n-\n-            // add in the complex expressions an turn materialize the grouping sets in terms of plan columns\n-            ImmutableList.Builder<List<Symbol>> groupingSetBuilder = ImmutableList.builder();\n-            for (Set<FieldId> groupingSet : columnOnlyGroupingSets) {\n-                ImmutableList.Builder<Symbol> columns = ImmutableList.builder();\n-                groupingSetAnalysis.getComplexExpressions().stream()\n-                        .map(groupingTranslations::get)\n-                        .forEach(columns::add);\n-\n-                groupingSet.stream()\n-                        .map(field -> groupingTranslations.get(new FieldReference(field.getFieldIndex())))\n-                        .forEach(columns::add);\n-\n-                groupingSetBuilder.add(columns.build());\n-            }\n+                .forEach(inputBuilder::add);\n \n-            groupingSets = groupingSetBuilder.build();\n-        }\n+        GroupingSetAnalysis groupingSetAnalysis = analysis.getGroupingSets(node);\n+        inputBuilder.addAll(groupingSetAnalysis.getComplexExpressions());\n \n-        // 2.c. Generate GroupIdNode (multiple grouping sets) or ProjectNode (single grouping set)\n-        Optional<Symbol> groupIdSymbol = Optional.empty();\n-        if (groupingSets.size() > 1) {\n-            groupIdSymbol = Optional.of(symbolAllocator.newSymbol(\"groupId\", BIGINT));\n-            GroupIdNode groupId = new GroupIdNode(idAllocator.getNextId(), subPlan.getRoot(), groupingSets, groupingSetMappings, aggregationArguments, groupIdSymbol.get());\n-            subPlan = new PlanBuilder(groupingTranslations, groupId);\n-        }\n-        else {\n-            Assignments.Builder assignments = Assignments.builder();\n-            aggregationArguments.forEach(assignments::putIdentity);\n-            groupingSetMappings.forEach((key, value) -> assignments.put(key, value.toSymbolReference()));\n+        List<Expression> inputs = inputBuilder.build();\n+        subPlan = handleSubqueries(subPlan, node, inputs);\n+        subPlan = subPlan.appendProjections(inputs, symbolAllocator, idAllocator);\n \n-            ProjectNode project = new ProjectNode(idAllocator.getNextId(), subPlan.getRoot(), assignments.build());\n-            subPlan = new PlanBuilder(groupingTranslations, project);\n-        }\n+        // Add projection to coerce inputs to their site-specific types.\n+        // This is important because the same lexical expression may need to be coerced\n+        // in different ways if it's referenced by multiple arguments to the window function.\n+        // For example, given v::integer,\n+        //    avg(v) OVER (ORDER BY v)\n+        // Needs to be rewritten as\n+        //    avg(CAST(v AS double)) OVER (ORDER BY v)\n+        PlanAndMappings coercions = coerce(subPlan, inputs, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = coercions.getSubPlan();\n \n-        TranslationMap aggregationTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n-        aggregationTranslations.copyMappingsFrom(groupingTranslations);\n+        GroupingSetsPlan groupingSets = planGroupingSets(subPlan, node, groupingSetAnalysis);\n \n-        // 2.d. Rewrite aggregates\n-        ImmutableMap.Builder<Symbol, Aggregation> aggregationsBuilder = ImmutableMap.builder();\n-        boolean needPostProjectionCoercion = false;\n-        for (FunctionCall aggregate : analysis.getAggregates(node)) {\n-            Expression rewritten = argumentTranslations.rewrite(aggregate);\n-            Symbol newSymbol = symbolAllocator.newSymbol(rewritten, analysis.getType(aggregate));\n+        subPlan = planAggregation(groupingSets.getSubPlan(), groupingSets.getGroupingSets(), groupingSets.getGroupIdSymbol(), analysis.getAggregates(node), coercions::get);\n \n-            // TODO: this is a hack, because we apply coercions to the output of expressions, rather than the arguments to expressions.\n-            // Therefore we can end up with this implicit cast, and have to move it into a post-projection\n-            if (rewritten instanceof Cast) {\n-                rewritten = ((Cast) rewritten).getExpression();\n-                needPostProjectionCoercion = true;\n-            }\n-            aggregationTranslations.put(aggregate, newSymbol);\n+        return planGroupingOperations(subPlan, node, groupingSets.getGroupIdSymbol(), groupingSets.getColumnOnlyGroupingSets());\n+    }\n \n-            FunctionCall functionCall = (FunctionCall) rewritten;\n-            aggregationsBuilder.put(newSymbol, new Aggregation(\n-                    analysis.getResolvedFunction(aggregate),\n-                    functionCall.getArguments(),\n-                    functionCall.isDistinct(),\n-                    functionCall.getFilter().map(Symbol::from),\n-                    functionCall.getOrderBy().map(OrderingScheme::fromOrderBy),\n-                    Optional.empty()));\n-        }\n-        Map<Symbol, Aggregation> aggregations = aggregationsBuilder.build();\n+    private PlanBuilder planAggregation(PlanBuilder subPlan, List<List<Symbol>> groupingSets, Optional<Symbol> groupIdSymbol, List<FunctionCall> aggregates, Function<Expression, Symbol> coercions)\n+    {\n+        ImmutableMap.Builder<NodeRef<Expression>, AggregationAssignment> aggregateMappingBuilder = ImmutableMap.builder();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2NDk4OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443264989", "bodyText": "Yeah, that's a left-over from some other approach I was trying out.", "author": "martint", "createdAt": "2020-06-21T23:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyMzM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNTE2MA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r427625160", "bodyText": "import could be in separate commit", "author": "kasiafi", "createdAt": "2020-05-19T21:59:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -629,24 +439,38 @@ private PlanBuilder aggregate(PlanBuilder subPlan, QuerySpecification node)\n                 Optional.empty(),\n                 groupIdSymbol);\n \n-        subPlan = new PlanBuilder(aggregationTranslations, aggregationNode);\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(aggregateMappings.values().stream()\n+                                .collect(toImmutableMap(assignment -> scopeAwareKey(analysis, subPlan.getScope(), assignment.getAstExpression()), AggregationAssignment::getSymbol))),\n+                aggregationNode);\n+    }\n \n-        // 3. Post-projection\n-        // Add back the implicit casts that we removed in 2.a\n-        // TODO: this is a hack, we should change type coercions to coerce the inputs to functions/operators instead of coercing the output\n-        if (needPostProjectionCoercion) {\n-            ImmutableList.Builder<Expression> alreadyCoerced = ImmutableList.builder();\n-            alreadyCoerced.addAll(groupByExpressions);\n-            groupIdSymbol.map(Symbol::toSymbolReference).ifPresent(alreadyCoerced::add);\n+    private <T extends Expression> List<T> scopeAwareDistinct(PlanBuilder subPlan, List<T> expressions)\n+    {\n+        return expressions.stream()\n+                .map(function -> scopeAwareKey(analysis, subPlan.getScope(), function))\n+                .distinct()\n+                .map(ScopeAware::getNode)\n+                .collect(toImmutableList());\n+    }\n \n-            subPlan = explicitCoercionFields(subPlan, alreadyCoerced.build(), analysis.getAggregates(node));\n+    private OrderingScheme translateOrderingScheme(List<SortItem> items, Function<Expression, Symbol> coercions)\n+    {\n+        List<Symbol> symbols = items.stream()\n+                .map(SortItem::getSortKey)\n+                .map(coercions::apply)\n+                .collect(toImmutableList());\n+\n+        ImmutableMap.Builder<Symbol, SortOrder> orders = ImmutableMap.builder();\n+        for (int i = 0; i < symbols.size(); i++) {\n+            orders.put(symbols.get(i), OrderingScheme.sortItemToSortOrder(items.get(i)));\n         }\n \n-        // 4. Project and re-write all grouping functions\n-        return handleGroupingOperations(subPlan, node, groupIdSymbol, columnOnlyGroupingSets);\n+        return new OrderingScheme(symbols, orders.build());\n     }\n \n-    private List<Set<FieldId>> enumerateGroupingSets(Analysis.GroupingSetAnalysis groupingSetAnalysis)\n+    private List<Set<FieldId>> enumerateGroupingSets(GroupingSetAnalysis groupingSetAnalysis)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxNjcyNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r428216727", "bodyText": "relationPlan doesn't have to be declared before if.", "author": "kasiafi", "createdAt": "2020-05-20T18:21:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -301,60 +295,25 @@ public DeleteNode plan(Delete node)\n \n     private PlanBuilder planQueryBody(Query query)\n     {\n-        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, session)\n+        RelationPlan relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session)\n                 .process(query.getQueryBody(), null);\n \n-        return planBuilderFor(relationPlan);\n+        return newPlanBuilder(relationPlan, analysis, lambdaDeclarationToSymbolMap);\n     }\n \n     private PlanBuilder planFrom(QuerySpecification node)\n     {\n         RelationPlan relationPlan;\n \n         if (node.getFrom().isPresent()) {\n-            relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, session)\n+            relationPlan = new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, outerContext, session)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNDc3Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r428904772", "bodyText": "nice how the new field mappings fields has nulls for all the fields that fall out of scope (non-grouping fields)", "author": "kasiafi", "createdAt": "2020-05-21T20:46:13Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -978,17 +818,200 @@ private PlanBuilder limit(PlanBuilder subPlan, Optional<Node> limit, Optional<Or\n         return subPlan;\n     }\n \n-    private static List<Expression> toSymbolReferences(List<Symbol> symbols)\n+    public GroupingSetsPlan planGroupingSets(PlanBuilder subPlan, QuerySpecification node, GroupingSetAnalysis groupingSetAnalysis)\n     {\n-        return symbols.stream()\n-                .map(Symbol::toSymbolReference)\n+        Map<Symbol, Symbol> groupingSetMappings = new LinkedHashMap<>();\n+\n+        // Compute a set of artificial columns that will contain the values of the original columns\n+        // filtered by whether the column is included in the grouping set\n+        // This will become the basis for the scope for any column references\n+        Symbol[] fields = new Symbol[subPlan.getTranslations().getFieldSymbols().size()];\n+        for (FieldId field : groupingSetAnalysis.getAllFields()) {\n+            Symbol input = subPlan.getTranslations().getFieldSymbols().get(field.getFieldIndex());\n+            Symbol output = symbolAllocator.newSymbol(input, \"gid\");\n+            fields[field.getFieldIndex()] = output;\n+            groupingSetMappings.put(output, input);\n+        }\n+\n+        ImmutableMap.Builder<Expression, Symbol> expressionsBuilder = ImmutableMap.builder();\n+        for (Expression expression : groupingSetAnalysis.getComplexExpressions()) {\n+            Symbol input = subPlan.translate(expression);\n+            Symbol output = symbolAllocator.newSymbol(expression, analysis.getType(expression), \"gid\");\n+            expressionsBuilder.put(expression, output);\n+            groupingSetMappings.put(output, input);\n+        }\n+        Map<Expression, Symbol> complexExpressions = expressionsBuilder.build();\n+\n+        // For the purpose of \"distinct\", we need to canonicalize column references that may have varying\n+        // syntactic forms (e.g., \"t.a\" vs \"a\"). Thus we need to enumerate grouping sets based on the underlying\n+        // fieldId associated with each column reference expression.\n+\n+        // The catch is that simple group-by expressions can be arbitrary expressions (this is a departure from the SQL specification).\n+        // But, they don't affect the number of grouping sets or the behavior of \"distinct\" . We can compute all the candidate\n+        // grouping sets in terms of fieldId, dedup as appropriate and then cross-join them with the complex expressions.\n+\n+        // This tracks the grouping sets before complex expressions are considered.\n+        // It's also used to compute the descriptors needed to implement grouping()\n+        List<Set<FieldId>> columnOnlyGroupingSets = enumerateGroupingSets(groupingSetAnalysis);\n+        if (node.getGroupBy().isPresent() && node.getGroupBy().get().isDistinct()) {\n+            columnOnlyGroupingSets = columnOnlyGroupingSets.stream()\n+                    .distinct()\n+                    .collect(toImmutableList());\n+        }\n+\n+        // translate from FieldIds to Symbols\n+        List<List<Symbol>> sets = columnOnlyGroupingSets.stream()\n+                .map(set -> set.stream()\n+                        .map(FieldId::getFieldIndex)\n+                        .map(index -> fields[index])\n+                        .collect(toImmutableList()))\n+                .collect(toImmutableList());\n+\n+        // combine (cartesian product) with complex expressions\n+        List<List<Symbol>> groupingSets = sets.stream()\n+                .map(set -> ImmutableList.<Symbol>builder()\n+                        .addAll(set)\n+                        .addAll(complexExpressions.values())\n+                        .build())\n                 .collect(toImmutableList());\n+\n+        // Generate GroupIdNode (multiple grouping sets) or ProjectNode (single grouping set)\n+        PlanNode groupId;\n+        Optional<Symbol> groupIdSymbol = Optional.empty();\n+        if (groupingSets.size() > 1) {\n+            groupIdSymbol = Optional.of(symbolAllocator.newSymbol(\"groupId\", BIGINT));\n+            groupId = new GroupIdNode(\n+                    idAllocator.getNextId(),\n+                    subPlan.getRoot(),\n+                    groupingSets,\n+                    groupingSetMappings,\n+                    subPlan.getRoot().getOutputSymbols(),\n+                    groupIdSymbol.get());\n+        }\n+        else {\n+            Assignments.Builder assignments = Assignments.builder();\n+            assignments.putIdentities(subPlan.getRoot().getOutputSymbols());\n+            groupingSetMappings.forEach((key, value) -> assignments.put(key, value.toSymbolReference()));\n+\n+            groupId = new ProjectNode(idAllocator.getNextId(), subPlan.getRoot(), assignments.build());\n+        }\n+\n+        subPlan = new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withNewMappings(complexExpressions, Arrays.asList(fields)),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjYyNg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r428906626", "bodyText": "Could you move this method above the planAggregation() method?", "author": "kasiafi", "createdAt": "2020-05-21T20:49:55Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -978,17 +818,200 @@ private PlanBuilder limit(PlanBuilder subPlan, Optional<Node> limit, Optional<Or\n         return subPlan;\n     }\n \n-    private static List<Expression> toSymbolReferences(List<Symbol> symbols)\n+    public GroupingSetsPlan planGroupingSets(PlanBuilder subPlan, QuerySpecification node, GroupingSetAnalysis groupingSetAnalysis)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzNTU3Nw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r428935577", "bodyText": "If we want to ensure that all arguments to grouping() match the grouping columns, we should compare their relationId with the expected relationId. Currently, it is only checked that they all come from the same relation.\nInstead of comparing to the first argument's relationId, we could have the \"expectedRelationId\" passed by the caller.", "author": "kasiafi", "createdAt": "2020-05-21T21:50:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/GroupingOperationRewriter.java", "diffHunk": "@@ -53,12 +54,13 @@ public static Expression rewriteGroupingOperation(GroupingOperation expression,\n         else {\n             checkState(groupIdSymbol.isPresent(), \"groupId symbol is missing\");\n \n-            RelationId relationId = columnReferenceFields.get(NodeRef.of(expression.getGroupingColumns().get(0))).getRelationId();\n+            RelationId relationId = columnReferenceFields.get(NodeRef.of(expression.getGroupingColumns().get(0))).getFieldId().getRelationId();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2NTk3MQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443265971", "bodyText": "At this point, all the validations have been done. Any checks should occur in the analyzer.", "author": "martint", "createdAt": "2020-06-21T23:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzNTU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MjI0Mw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r428942243", "bodyText": "this is not related to this change, but as a refactor\n.filter(Optional::isPresent)\n.map(Optional::get)\n.map(OrderBy::getSortItems)\n\ncould be replaced with .map(NodeUtils::getSortItemsFromOrderBy)", "author": "kasiafi", "createdAt": "2020-05-21T22:06:53Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -484,130 +347,68 @@ private PlanBuilder aggregate(PlanBuilder subPlan, QuerySpecification node)\n                 .map(OrderBy::getSortItems)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxMjg3OA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429412878", "bodyText": "Change this comment to match aggregations, not window functions.", "author": "kasiafi", "createdAt": "2020-05-22T19:08:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -484,130 +347,68 @@ private PlanBuilder aggregate(PlanBuilder subPlan, QuerySpecification node)\n                 .map(OrderBy::getSortItems)\n                 .flatMap(List::stream)\n                 .map(SortItem::getSortKey)\n-                .forEach(arguments::add);\n+                .forEach(inputBuilder::add);\n \n         // filter expressions need to be projected first\n         analysis.getAggregates(node).stream()\n                 .map(FunctionCall::getFilter)\n                 .filter(Optional::isPresent)\n                 .map(Optional::get)\n-                .forEach(arguments::add);\n-\n-        Iterable<Expression> inputs = Iterables.concat(groupByExpressions, arguments.build());\n-        subPlan = handleSubqueries(subPlan, node, inputs);\n-\n-        if (!Iterables.isEmpty(inputs)) { // avoid an empty projection if the only aggregation is COUNT (which has no arguments)\n-            subPlan = project(subPlan, inputs);\n-        }\n-\n-        // 2. Aggregate\n-\n-        // 2.a. Rewrite aggregate arguments\n-        TranslationMap argumentTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n-\n-        ImmutableList.Builder<Symbol> aggregationArgumentsBuilder = ImmutableList.builder();\n-        for (Expression argument : arguments.build()) {\n-            Symbol symbol = subPlan.translate(argument);\n-            argumentTranslations.put(argument, symbol);\n-            aggregationArgumentsBuilder.add(symbol);\n-        }\n-        List<Symbol> aggregationArguments = aggregationArgumentsBuilder.build();\n-\n-        // 2.b. Rewrite grouping columns\n-        TranslationMap groupingTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n-        Map<Symbol, Symbol> groupingSetMappings = new LinkedHashMap<>();\n-\n-        for (Expression expression : groupByExpressions) {\n-            Symbol input = subPlan.translate(expression);\n-            Symbol output = symbolAllocator.newSymbol(expression, analysis.getTypeWithCoercions(expression), \"gid\");\n-            groupingTranslations.put(expression, output);\n-            groupingSetMappings.put(output, input);\n-        }\n-\n-        // This tracks the grouping sets before complex expressions are considered (see comments below)\n-        // It's also used to compute the descriptors needed to implement grouping()\n-        List<Set<FieldId>> columnOnlyGroupingSets = ImmutableList.of(ImmutableSet.of());\n-        List<List<Symbol>> groupingSets = ImmutableList.of(ImmutableList.of());\n-\n-        if (node.getGroupBy().isPresent()) {\n-            // For the purpose of \"distinct\", we need to canonicalize column references that may have varying\n-            // syntactic forms (e.g., \"t.a\" vs \"a\"). Thus we need to enumerate grouping sets based on the underlying\n-            // fieldId associated with each column reference expression.\n-\n-            // The catch is that simple group-by expressions can be arbitrary expressions (this is a departure from the SQL specification).\n-            // But, they don't affect the number of grouping sets or the behavior of \"distinct\" . We can compute all the candidate\n-            // grouping sets in terms of fieldId, dedup as appropriate and then cross-join them with the complex expressions.\n-            Analysis.GroupingSetAnalysis groupingSetAnalysis = analysis.getGroupingSets(node);\n-            columnOnlyGroupingSets = enumerateGroupingSets(groupingSetAnalysis);\n-\n-            if (node.getGroupBy().get().isDistinct()) {\n-                columnOnlyGroupingSets = columnOnlyGroupingSets.stream()\n-                        .distinct()\n-                        .collect(toImmutableList());\n-            }\n+                .forEach(inputBuilder::add);\n \n-            // add in the complex expressions an turn materialize the grouping sets in terms of plan columns\n-            ImmutableList.Builder<List<Symbol>> groupingSetBuilder = ImmutableList.builder();\n-            for (Set<FieldId> groupingSet : columnOnlyGroupingSets) {\n-                ImmutableList.Builder<Symbol> columns = ImmutableList.builder();\n-                groupingSetAnalysis.getComplexExpressions().stream()\n-                        .map(groupingTranslations::get)\n-                        .forEach(columns::add);\n+        GroupingSetAnalysis groupingSetAnalysis = analysis.getGroupingSets(node);\n+        inputBuilder.addAll(groupingSetAnalysis.getComplexExpressions());\n \n-                groupingSet.stream()\n-                        .map(field -> groupingTranslations.get(new FieldReference(field.getFieldIndex())))\n-                        .forEach(columns::add);\n+        List<Expression> inputs = inputBuilder.build();\n+        subPlan = handleSubqueries(subPlan, node, inputs);\n+        subPlan = subPlan.appendProjections(inputs, symbolAllocator, idAllocator);\n \n-                groupingSetBuilder.add(columns.build());\n-            }\n+        // Add projection to coerce inputs to their site-specific types.\n+        // This is important because the same lexical expression may need to be coerced\n+        // in different ways if it's referenced by multiple arguments to the window function.\n+        // For example, given v::integer,\n+        //    avg(v) OVER (ORDER BY v)\n+        // Needs to be rewritten as\n+        //    avg(CAST(v AS double)) OVER (ORDER BY v)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxNzkxMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429417912", "bodyText": "why not? It doesn't belong to the change, just curious.", "author": "kasiafi", "createdAt": "2020-05-22T19:20:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -751,112 +553,94 @@ private PlanBuilder window(PlanBuilder subPlan, List<FunctionCall> windowFunctio\n             return subPlan;\n         }\n \n-        for (FunctionCall windowFunction : windowFunctions) {\n+        for (FunctionCall windowFunction : scopeAwareDistinct(subPlan, windowFunctions)) {\n             Window window = windowFunction.getWindow().get();\n \n             // Extract frame\n             WindowFrame.Type frameType = WindowFrame.Type.RANGE;\n             FrameBound.Type frameStartType = FrameBound.Type.UNBOUNDED_PRECEDING;\n             FrameBound.Type frameEndType = FrameBound.Type.CURRENT_ROW;\n-            Expression frameStart = null;\n-            Expression frameEnd = null;\n+            Optional<Expression> frameStart = Optional.empty();\n+            Optional<Expression> frameEnd = Optional.empty();\n \n             if (window.getFrame().isPresent()) {\n                 WindowFrame frame = window.getFrame().get();\n                 frameType = frame.getType();\n \n                 frameStartType = frame.getStart().getType();\n-                frameStart = frame.getStart().getValue().orElse(null);\n+                frameStart = frame.getStart().getValue();\n \n                 if (frame.getEnd().isPresent()) {\n                     frameEndType = frame.getEnd().get().getType();\n-                    frameEnd = frame.getEnd().get().getValue().orElse(null);\n+                    frameEnd = frame.getEnd().get().getValue();\n                 }\n             }\n \n             // Pre-project inputs\n-            ImmutableList.Builder<Expression> inputs = ImmutableList.<Expression>builder()\n+            ImmutableList.Builder<Expression> inputsBuilder = ImmutableList.<Expression>builder()\n                     .addAll(windowFunction.getArguments())\n                     .addAll(window.getPartitionBy())\n                     .addAll(getSortItemsFromOrderBy(window.getOrderBy()).stream()\n                             .map(SortItem::getSortKey)\n                             .iterator());\n \n-            if (frameStart != null) {\n-                inputs.add(frameStart);\n-            }\n-            if (frameEnd != null) {\n-                inputs.add(frameEnd);\n-            }\n+            frameStart.ifPresent(inputsBuilder::add);\n+            frameEnd.ifPresent(inputsBuilder::add);\n \n-            subPlan = subPlan.appendProjections(inputs.build(), symbolAllocator, idAllocator);\n+            List<Expression> inputs = inputsBuilder.build();\n+\n+            subPlan = subPlan.appendProjections(inputs, symbolAllocator, idAllocator);\n+\n+            // Add projection to coerce inputs to their site-specific types.\n+            // This is important because the same lexical expression may need to be coerced\n+            // in different ways if it's referenced by multiple arguments to the window function.\n+            // For example, given v::integer,\n+            //    avg(v) OVER (ORDER BY v)\n+            // Needs to be rewritten as\n+            //    avg(CAST(v AS double)) OVER (ORDER BY v)\n+            PlanAndMappings coercions = coerce(subPlan, inputs, analysis, idAllocator, symbolAllocator, typeCoercion);\n+            subPlan = coercions.getSubPlan();\n \n             // Rewrite PARTITION BY in terms of pre-projected inputs\n             ImmutableList.Builder<Symbol> partitionBySymbols = ImmutableList.builder();\n             for (Expression expression : window.getPartitionBy()) {\n-                partitionBySymbols.add(subPlan.translate(expression));\n+                partitionBySymbols.add(coercions.get(expression));\n             }\n \n             // Rewrite ORDER BY in terms of pre-projected inputs\n             LinkedHashMap<Symbol, SortOrder> orderings = new LinkedHashMap<>();\n             for (SortItem item : getSortItemsFromOrderBy(window.getOrderBy())) {\n-                Symbol symbol = subPlan.translate(item.getSortKey());\n+                Symbol symbol = coercions.get(item.getSortKey());\n                 // don't override existing keys, i.e. when \"ORDER BY a ASC, a DESC\" is specified", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2Njc2Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443266762", "bodyText": "If you do something like: SELECT ... FROM ... ORDER BY a ASC, a DESC, the second instance (i.e., a DESC) is irrelevant, as all the values of a within each ordering group for the first term (i.e., a ASC) are the same. In this code, we only track one ordering scheme for each column, so we need to consider the first one as the \"winner\" and ignore all the other ones.", "author": "martint", "createdAt": "2020-06-21T23:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxNzkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0NTA1NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429445054", "bodyText": "a few comments regarding how a window function is processed\n\nwindowFunction's filter is not supported as well as ORDER BY. However, ORDER BY is processed here, and filter is omitted. Otherwise, it should be rewritten. What's the right strategy? Filter should be at least mentioned in a comment.\nit seems that it is redundant to: rewrite PARTITION BY, rewrite ORDER BY, rewrite frame bounds. Instead, we could call substitute(windowFunction, child -> coercions.tryGet(child)... earlier. Then we could base on the rewritten FunctionCall to build all the necessary fields for the constructed WindowNode.\nInline the substitute() method.", "author": "kasiafi", "createdAt": "2020-05-22T20:46:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -751,112 +553,94 @@ private PlanBuilder window(PlanBuilder subPlan, List<FunctionCall> windowFunctio\n             return subPlan;\n         }\n \n-        for (FunctionCall windowFunction : windowFunctions) {\n+        for (FunctionCall windowFunction : scopeAwareDistinct(subPlan, windowFunctions)) {\n             Window window = windowFunction.getWindow().get();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1MjE1NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443252154", "bodyText": "Filters are not legal for window functions. I'll add a check to verify they are not present.", "author": "martint", "createdAt": "2020-06-21T20:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0NTA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1ODgwMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443258803", "bodyText": "I tried to keep this code as untouched as possible, but I agree it can be cleaned up a bit. I'll change how the function is planned -- in particular, relying on the rewrite and then extract the pieces that matter is not ideal. In the future (once we split AST from IR), there may not be a \"FunctionCall\" representation for window functions.", "author": "martint", "createdAt": "2020-06-21T21:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0NTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MzEwNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429453107", "bodyText": "move getter to other getters (not that they are in one place).", "author": "kasiafi", "createdAt": "2020-05-22T21:12:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanBuilder.java", "diffHunk": "@@ -87,26 +100,37 @@ public TranslationMap getTranslations()\n \n     public PlanBuilder appendProjections(Iterable<Expression> expressions, SymbolAllocator symbolAllocator, PlanNodeIdAllocator idAllocator)\n     {\n-        TranslationMap translations = copyTranslations();\n+        return appendProjections(expressions, symbolAllocator, idAllocator, TranslationMap::rewrite, TranslationMap::canTranslate);\n+    }\n \n+    public <T extends Expression> PlanBuilder appendProjections(\n+            Iterable<T> expressions,\n+            SymbolAllocator symbolAllocator,\n+            PlanNodeIdAllocator idAllocator,\n+            BiFunction<TranslationMap, T, Expression> rewriter,\n+            BiPredicate<TranslationMap, T> alreadyHasTranslation)\n+    {\n         Assignments.Builder projections = Assignments.builder();\n \n         // add an identity projection for underlying plan\n-        for (Symbol symbol : getRoot().getOutputSymbols()) {\n-            projections.put(symbol, symbol.toSymbolReference());\n+        projections.putIdentities(root.getOutputSymbols());\n+\n+        Map<ScopeAware<Expression>, Symbol> mappings = new HashMap<>();\n+        for (T expression : expressions) {\n+            if (!mappings.containsKey(scopeAwareKey(getAnalysis(), translations.getScope(), expression)) && !alreadyHasTranslation.test(translations, expression)) {\n+                Symbol symbol = symbolAllocator.newSymbol(expression, getAnalysis().getType(expression));\n+                projections.put(symbol, rewriter.apply(translations, expression));\n+                mappings.put(scopeAwareKey(getAnalysis(), translations.getScope(), expression), symbol);\n+            }\n         }\n \n-        ImmutableMap.Builder<Symbol, Expression> newTranslations = ImmutableMap.builder();\n-        for (Expression expression : expressions) {\n-            Symbol symbol = symbolAllocator.newSymbol(expression, getAnalysis().getTypeWithCoercions(expression));\n-            projections.put(symbol, translations.rewrite(expression));\n-            newTranslations.put(symbol, expression);\n-        }\n-        // Now append the new translations into the TranslationMap\n-        for (Map.Entry<Symbol, Expression> entry : newTranslations.build().entrySet()) {\n-            translations.put(entry.getValue(), entry.getKey());\n-        }\n+        return new PlanBuilder(\n+                getTranslations().withAdditionalMappings(mappings),\n+                new ProjectNode(idAllocator.getNextId(), root, projections.build()));\n+    }\n \n-        return new PlanBuilder(translations, new ProjectNode(idAllocator.getNextId(), getRoot(), projections.build()));\n+    public Scope getScope()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MzM5OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429453399", "bodyText": "either use getters or fields for both analysis and scope", "author": "kasiafi", "createdAt": "2020-05-22T21:13:17Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanBuilder.java", "diffHunk": "@@ -87,26 +100,37 @@ public TranslationMap getTranslations()\n \n     public PlanBuilder appendProjections(Iterable<Expression> expressions, SymbolAllocator symbolAllocator, PlanNodeIdAllocator idAllocator)\n     {\n-        TranslationMap translations = copyTranslations();\n+        return appendProjections(expressions, symbolAllocator, idAllocator, TranslationMap::rewrite, TranslationMap::canTranslate);\n+    }\n \n+    public <T extends Expression> PlanBuilder appendProjections(\n+            Iterable<T> expressions,\n+            SymbolAllocator symbolAllocator,\n+            PlanNodeIdAllocator idAllocator,\n+            BiFunction<TranslationMap, T, Expression> rewriter,\n+            BiPredicate<TranslationMap, T> alreadyHasTranslation)\n+    {\n         Assignments.Builder projections = Assignments.builder();\n \n         // add an identity projection for underlying plan\n-        for (Symbol symbol : getRoot().getOutputSymbols()) {\n-            projections.put(symbol, symbol.toSymbolReference());\n+        projections.putIdentities(root.getOutputSymbols());\n+\n+        Map<ScopeAware<Expression>, Symbol> mappings = new HashMap<>();\n+        for (T expression : expressions) {\n+            if (!mappings.containsKey(scopeAwareKey(getAnalysis(), translations.getScope(), expression)) && !alreadyHasTranslation.test(translations, expression)) {\n+                Symbol symbol = symbolAllocator.newSymbol(expression, getAnalysis().getType(expression));\n+                projections.put(symbol, rewriter.apply(translations, expression));\n+                mappings.put(scopeAwareKey(getAnalysis(), translations.getScope(), expression), symbol);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1MTEyNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429551127", "bodyText": "the newly-constructed Scope hasn't got outer parent. It seems to be OK, since outer scope is never accessed via this field. Instead, the outer scope might be accessed via outerContext.\nMaybe add a comment to explain which field is responsible for keeping the scope hierarchy, and which is not.", "author": "kasiafi", "createdAt": "2020-05-23T14:32:28Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -855,7 +861,7 @@ private RelationPlan addCoercions(RelationPlan plan, Type[] targetColumnTypes)\n                     oldField.isAliased());\n         }\n         ProjectNode projectNode = new ProjectNode(idAllocator.getNextId(), plan.getRoot(), assignments.build());\n-        return new RelationPlan(projectNode, Scope.builder().withRelationType(RelationId.anonymous(), new RelationType(newFields)).build(), newSymbols.build());\n+        return new RelationPlan(projectNode, Scope.builder().withRelationType(RelationId.anonymous(), new RelationType(newFields)).build(), newSymbols.build(), outerContext);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2Nzk5NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443267995", "bodyText": "Yup. There's still some cleanup that needs to be done at some point. This mixes two concerns: tracking the scope needed to resolution and tracking the relation type.", "author": "martint", "createdAt": "2020-06-21T23:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1MTEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1Mjc0NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429552744", "bodyText": "planBuilder.getTranslations().rewrite(mask) -> planBuilder.rewrite(mask)", "author": "kasiafi", "createdAt": "2020-05-23T14:53:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/RelationPlanner.java", "diffHunk": "@@ -227,7 +238,7 @@ private RelationPlan addColumnMasks(Table table, RelationPlan plan)\n                 for (Symbol symbol : plan.getRoot().getOutputSymbols()) {\n                     assignments.put(symbol, symbol.toSymbolReference());\n                 }\n-                assignments.put(plan.getFieldMappings().get(i), translations.rewrite(mask));\n+                assignments.put(plan.getFieldMappings().get(i), coerceIfNecessary(analysis, mask, planBuilder.getTranslations().rewrite(mask)));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1OTc3NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429559774", "bodyText": "why not handleSubqueries(inputs)?", "author": "kasiafi", "createdAt": "2020-05-23T16:29:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -744,112 +553,94 @@ private PlanBuilder window(PlanBuilder subPlan, List<FunctionCall> windowFunctio\n             return subPlan;\n         }\n \n-        for (FunctionCall windowFunction : windowFunctions) {\n+        for (FunctionCall windowFunction : scopeAwareDistinct(subPlan, windowFunctions)) {\n             Window window = windowFunction.getWindow().get();\n \n             // Extract frame\n             WindowFrame.Type frameType = WindowFrame.Type.RANGE;\n             FrameBound.Type frameStartType = FrameBound.Type.UNBOUNDED_PRECEDING;\n             FrameBound.Type frameEndType = FrameBound.Type.CURRENT_ROW;\n-            Expression frameStart = null;\n-            Expression frameEnd = null;\n+            Optional<Expression> frameStart = Optional.empty();\n+            Optional<Expression> frameEnd = Optional.empty();\n \n             if (window.getFrame().isPresent()) {\n                 WindowFrame frame = window.getFrame().get();\n                 frameType = frame.getType();\n \n                 frameStartType = frame.getStart().getType();\n-                frameStart = frame.getStart().getValue().orElse(null);\n+                frameStart = frame.getStart().getValue();\n \n                 if (frame.getEnd().isPresent()) {\n                     frameEndType = frame.getEnd().get().getType();\n-                    frameEnd = frame.getEnd().get().getValue().orElse(null);\n+                    frameEnd = frame.getEnd().get().getValue();\n                 }\n             }\n \n             // Pre-project inputs\n-            ImmutableList.Builder<Expression> inputs = ImmutableList.<Expression>builder()\n+            ImmutableList.Builder<Expression> inputsBuilder = ImmutableList.<Expression>builder()\n                     .addAll(windowFunction.getArguments())\n                     .addAll(window.getPartitionBy())\n                     .addAll(getSortItemsFromOrderBy(window.getOrderBy()).stream()\n                             .map(SortItem::getSortKey)\n                             .iterator());\n \n-            if (frameStart != null) {\n-                inputs.add(frameStart);\n-            }\n-            if (frameEnd != null) {\n-                inputs.add(frameEnd);\n-            }\n+            frameStart.ifPresent(inputsBuilder::add);\n+            frameEnd.ifPresent(inputsBuilder::add);\n \n-            subPlan = subPlan.appendProjections(inputs.build(), symbolAllocator, idAllocator);\n+            List<Expression> inputs = inputsBuilder.build();\n+\n+            subPlan = subPlan.appendProjections(inputs, symbolAllocator, idAllocator);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2OTE2OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443269169", "bodyText": "Nice catch. Indeed, this fails: #4127", "author": "martint", "createdAt": "2020-06-21T23:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1OTc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3ODg5OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429578899", "bodyText": "new line", "author": "kasiafi", "createdAt": "2020-05-23T21:15:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n+                new ApplyNode(idAllocator.getNextId(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYyMjcwMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429622701", "bodyText": "Subqueries are only recorded for: Join, Query, QuerySpecification, and for row filter expressions and column mask expressions. If handleSubqueries() is called with the argument node of any other type, nothing happens.\nWould it make sense to record subqueries from Delete.where under reference to Delete node? If they were recorded, they would be handled in this line.", "author": "kasiafi", "createdAt": "2020-05-24T10:39:39Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -356,102 +322,9 @@ private PlanBuilder filter(PlanBuilder subPlan, Expression predicate, Node node)\n             return subPlan;\n         }\n \n-        // rewrite expressions which contain already handled subqueries\n-        Expression rewrittenBeforeSubqueries = subPlan.rewrite(predicate);\n-        subPlan = subqueryPlanner.handleSubqueries(subPlan, rewrittenBeforeSubqueries, node);\n-        Expression rewrittenAfterSubqueries = subPlan.rewrite(predicate);\n-\n-        return subPlan.withNewRoot(new FilterNode(idAllocator.getNextId(), subPlan.getRoot(), rewrittenAfterSubqueries));\n-    }\n-\n-    private PlanBuilder project(PlanBuilder subPlan, Iterable<Expression> expressions)\n-    {\n-        TranslationMap outputTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n-\n-        Assignments.Builder projections = Assignments.builder();\n-        for (Expression expression : expressions) {\n-            if (expression instanceof SymbolReference) {\n-                Symbol symbol = Symbol.from(expression);\n-                projections.put(symbol, expression);\n-                outputTranslations.put(expression, symbol);\n-                continue;\n-            }\n-\n-            Symbol symbol = symbolAllocator.newSymbol(expression, analysis.getTypeWithCoercions(expression));\n-            projections.put(symbol, subPlan.rewrite(expression));\n-            outputTranslations.put(expression, symbol);\n-        }\n-\n-        return new PlanBuilder(outputTranslations, new ProjectNode(\n-                idAllocator.getNextId(),\n-                subPlan.getRoot(),\n-                projections.build()));\n-    }\n-\n-    private Map<Symbol, Expression> coerce(Iterable<? extends Expression> expressions, PlanBuilder subPlan, TranslationMap translations)\n-    {\n-        ImmutableMap.Builder<Symbol, Expression> projections = ImmutableMap.builder();\n+        subPlan = subqueryPlanner.handleSubqueries(subPlan, predicate, node);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3MjEyMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443272123", "bodyText": "Yes, although that would be almost useless for a delete. Due to implementation limitations, deletes need to occur in a node-local context (i.e., the scan and the delete action need to be in the same task). Adding a subquery will almost certainly result in some form of distributed execution.", "author": "martint", "createdAt": "2020-06-22T00:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYyMjcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYyNTY4OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429625689", "bodyText": "Maybe add a comment that this plans subquery with subPlan's translationMap as outer context / correlation.", "author": "kasiafi", "createdAt": "2020-05-24T11:18:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYyNTk5NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429625994", "bodyText": "Maybe add a comment to clarify that subPlan's translations weren't affected by coerce. In other words -- that the exposed symbol for value is \"uncoerced\".", "author": "kasiafi", "createdAt": "2020-05-24T11:22:03Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NjgyNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443276827", "bodyText": "I think that clarification only matters in the context of how translations are done today. In the new world order, call site specific coercions don't play a role, so it might be more confusing to clarify something that should not even be a consideration.", "author": "martint", "createdAt": "2020-06-22T01:06:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYyNTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYzODY0NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429638645", "bodyText": "new line", "author": "kasiafi", "createdAt": "2020-05-24T13:48:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(output, new InPredicate(\n+                                subplanCoercions.get(value).toSymbolReference(),\n+                                subqueryCoercions.get(subquery).toSymbolReference())),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        originalExpression));\n     }\n \n-    private PlanBuilder appendScalarSubqueryApplyNode(PlanBuilder subPlan, SubqueryExpression scalarSubquery)\n+    private PlanBuilder planScalarSubquery(PlanBuilder subPlan, List<SubqueryExpression> cluster)\n     {\n-        if (subPlan.canTranslate(scalarSubquery)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        List<Expression> coercions = coercionsFor(scalarSubquery);\n-\n-        SubqueryExpression uncoercedScalarSubquery = uncoercedSubquery(scalarSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedScalarSubquery);\n-        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n-        subqueryPlan = subqueryPlan.appendProjections(coercions, symbolAllocator, idAllocator);\n+        // Plan one of the predicates from the cluster\n+        SubqueryExpression scalarSubquery = cluster.get(0);\n \n-        Symbol uncoercedScalarSubquerySymbol = subqueryPlan.translate(uncoercedScalarSubquery);\n-        subPlan.getTranslations().put(uncoercedScalarSubquery, uncoercedScalarSubquerySymbol);\n+        RelationPlan relationPlan = planSubquery(scalarSubquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n-        for (Expression coercion : coercions) {\n-            Symbol coercionSymbol = subqueryPlan.translate(coercion);\n-            subPlan.getTranslations().put(coercion, coercionSymbol);\n-        }\n+        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n \n-        // The subquery's EnforceSingleRowNode always produces a row, so the join is effectively INNER\n-        return appendCorrelatedJoin(subPlan, subqueryPlan, scalarSubquery.getQuery(), CorrelatedJoinNode.Type.INNER, TRUE_LITERAL);\n+        return appendCorrelatedJoin(\n+                subPlan,\n+                subqueryPlan,\n+                scalarSubquery.getQuery(),\n+                CorrelatedJoinNode.Type.INNER,\n+                TRUE_LITERAL,\n+                mapAll(cluster, subPlan.getScope(), getOnlyElement(relationPlan.getFieldMappings())));\n     }\n \n-    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition)\n+    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition, Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        PlanNode subqueryNode = subqueryPlan.getRoot();\n-        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n-        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n-\n         return new PlanBuilder(\n-                subPlan.copyTranslations(),\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mappings),\n                 new CorrelatedJoinNode(\n                         idAllocator.getNextId(),\n                         subPlan.getRoot(),\n-                        subqueryNode,\n-                        ImmutableList.copyOf(SymbolsExtractor.extractUnique(correlation.values())),\n+                        subqueryPlan.getRoot(),\n+                        subPlan.getRoot().getOutputSymbols(),\n                         type,\n                         filterCondition,\n                         query));\n     }\n \n-    private PlanBuilder appendExistsSubqueryApplyNodes(PlanBuilder builder, Set<ExistsPredicate> existsPredicates)\n+    private PlanBuilder planExists(PlanBuilder subPlan, List<ExistsPredicate> cluster)\n     {\n-        for (ExistsPredicate existsPredicate : existsPredicates) {\n-            builder = appendExistSubqueryApplyNode(builder, existsPredicate);\n-        }\n-        return builder;\n-    }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-    /**\n-     * Exists is modeled as:\n-     * <pre>\n-     *     - Project($0 > 0)\n-     *       - Aggregation(COUNT(*))\n-     *         - Limit(1)\n-     *           -- subquery\n-     * </pre>\n-     */\n-    private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPredicate existsPredicate)\n-    {\n-        if (subPlan.canTranslate(existsPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        // Plan one of the predicates from the cluster\n+        ExistsPredicate existsPredicate = cluster.get(0);\n \n-        PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n+        Expression subquery = existsPredicate.getSubquery();\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n         Symbol exists = symbolAllocator.newSymbol(\"exists\", BOOLEAN);\n-        subPlan.getTranslations().put(existsPredicate, exists);\n-        ExistsPredicate rewrittenExistsPredicate = new ExistsPredicate(TRUE_LITERAL);\n-        return appendApplyNode(\n-                subPlan,\n-                existsPredicate.getSubquery(),\n-                subqueryPlan.getRoot(),\n-                Assignments.of(exists, rewrittenExistsPredicate));\n+\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), exists)),\n+                new ApplyNode(idAllocator.getNextId(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYzOTY5OA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429639698", "bodyText": "this PlanBuilder is only used to provide the root PlanNode to the constructor of ApplyNode (no coerce in this case). Instead, the root might be taken right from relationPlan.\nIt would be equally clear if relationPlan was renamed to subqueryRelationPlan.", "author": "kasiafi", "createdAt": "2020-05-24T13:59:38Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(output, new InPredicate(\n+                                subplanCoercions.get(value).toSymbolReference(),\n+                                subqueryCoercions.get(subquery).toSymbolReference())),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        originalExpression));\n     }\n \n-    private PlanBuilder appendScalarSubqueryApplyNode(PlanBuilder subPlan, SubqueryExpression scalarSubquery)\n+    private PlanBuilder planScalarSubquery(PlanBuilder subPlan, List<SubqueryExpression> cluster)\n     {\n-        if (subPlan.canTranslate(scalarSubquery)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        List<Expression> coercions = coercionsFor(scalarSubquery);\n-\n-        SubqueryExpression uncoercedScalarSubquery = uncoercedSubquery(scalarSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedScalarSubquery);\n-        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n-        subqueryPlan = subqueryPlan.appendProjections(coercions, symbolAllocator, idAllocator);\n+        // Plan one of the predicates from the cluster\n+        SubqueryExpression scalarSubquery = cluster.get(0);\n \n-        Symbol uncoercedScalarSubquerySymbol = subqueryPlan.translate(uncoercedScalarSubquery);\n-        subPlan.getTranslations().put(uncoercedScalarSubquery, uncoercedScalarSubquerySymbol);\n+        RelationPlan relationPlan = planSubquery(scalarSubquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n-        for (Expression coercion : coercions) {\n-            Symbol coercionSymbol = subqueryPlan.translate(coercion);\n-            subPlan.getTranslations().put(coercion, coercionSymbol);\n-        }\n+        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n \n-        // The subquery's EnforceSingleRowNode always produces a row, so the join is effectively INNER\n-        return appendCorrelatedJoin(subPlan, subqueryPlan, scalarSubquery.getQuery(), CorrelatedJoinNode.Type.INNER, TRUE_LITERAL);\n+        return appendCorrelatedJoin(\n+                subPlan,\n+                subqueryPlan,\n+                scalarSubquery.getQuery(),\n+                CorrelatedJoinNode.Type.INNER,\n+                TRUE_LITERAL,\n+                mapAll(cluster, subPlan.getScope(), getOnlyElement(relationPlan.getFieldMappings())));\n     }\n \n-    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition)\n+    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition, Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        PlanNode subqueryNode = subqueryPlan.getRoot();\n-        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n-        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n-\n         return new PlanBuilder(\n-                subPlan.copyTranslations(),\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mappings),\n                 new CorrelatedJoinNode(\n                         idAllocator.getNextId(),\n                         subPlan.getRoot(),\n-                        subqueryNode,\n-                        ImmutableList.copyOf(SymbolsExtractor.extractUnique(correlation.values())),\n+                        subqueryPlan.getRoot(),\n+                        subPlan.getRoot().getOutputSymbols(),\n                         type,\n                         filterCondition,\n                         query));\n     }\n \n-    private PlanBuilder appendExistsSubqueryApplyNodes(PlanBuilder builder, Set<ExistsPredicate> existsPredicates)\n+    private PlanBuilder planExists(PlanBuilder subPlan, List<ExistsPredicate> cluster)\n     {\n-        for (ExistsPredicate existsPredicate : existsPredicates) {\n-            builder = appendExistSubqueryApplyNode(builder, existsPredicate);\n-        }\n-        return builder;\n-    }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-    /**\n-     * Exists is modeled as:\n-     * <pre>\n-     *     - Project($0 > 0)\n-     *       - Aggregation(COUNT(*))\n-     *         - Limit(1)\n-     *           -- subquery\n-     * </pre>\n-     */\n-    private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPredicate existsPredicate)\n-    {\n-        if (subPlan.canTranslate(existsPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        // Plan one of the predicates from the cluster\n+        ExistsPredicate existsPredicate = cluster.get(0);\n \n-        PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n+        Expression subquery = existsPredicate.getSubquery();\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0MTA4MQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429641081", "bodyText": "why not mapAll(cluster)?", "author": "kasiafi", "createdAt": "2020-05-24T14:13:57Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(output, new InPredicate(\n+                                subplanCoercions.get(value).toSymbolReference(),\n+                                subqueryCoercions.get(subquery).toSymbolReference())),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        originalExpression));\n     }\n \n-    private PlanBuilder appendScalarSubqueryApplyNode(PlanBuilder subPlan, SubqueryExpression scalarSubquery)\n+    private PlanBuilder planScalarSubquery(PlanBuilder subPlan, List<SubqueryExpression> cluster)\n     {\n-        if (subPlan.canTranslate(scalarSubquery)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        List<Expression> coercions = coercionsFor(scalarSubquery);\n-\n-        SubqueryExpression uncoercedScalarSubquery = uncoercedSubquery(scalarSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedScalarSubquery);\n-        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n-        subqueryPlan = subqueryPlan.appendProjections(coercions, symbolAllocator, idAllocator);\n+        // Plan one of the predicates from the cluster\n+        SubqueryExpression scalarSubquery = cluster.get(0);\n \n-        Symbol uncoercedScalarSubquerySymbol = subqueryPlan.translate(uncoercedScalarSubquery);\n-        subPlan.getTranslations().put(uncoercedScalarSubquery, uncoercedScalarSubquerySymbol);\n+        RelationPlan relationPlan = planSubquery(scalarSubquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n-        for (Expression coercion : coercions) {\n-            Symbol coercionSymbol = subqueryPlan.translate(coercion);\n-            subPlan.getTranslations().put(coercion, coercionSymbol);\n-        }\n+        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n \n-        // The subquery's EnforceSingleRowNode always produces a row, so the join is effectively INNER\n-        return appendCorrelatedJoin(subPlan, subqueryPlan, scalarSubquery.getQuery(), CorrelatedJoinNode.Type.INNER, TRUE_LITERAL);\n+        return appendCorrelatedJoin(\n+                subPlan,\n+                subqueryPlan,\n+                scalarSubquery.getQuery(),\n+                CorrelatedJoinNode.Type.INNER,\n+                TRUE_LITERAL,\n+                mapAll(cluster, subPlan.getScope(), getOnlyElement(relationPlan.getFieldMappings())));\n     }\n \n-    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition)\n+    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition, Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        PlanNode subqueryNode = subqueryPlan.getRoot();\n-        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n-        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n-\n         return new PlanBuilder(\n-                subPlan.copyTranslations(),\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mappings),\n                 new CorrelatedJoinNode(\n                         idAllocator.getNextId(),\n                         subPlan.getRoot(),\n-                        subqueryNode,\n-                        ImmutableList.copyOf(SymbolsExtractor.extractUnique(correlation.values())),\n+                        subqueryPlan.getRoot(),\n+                        subPlan.getRoot().getOutputSymbols(),\n                         type,\n                         filterCondition,\n                         query));\n     }\n \n-    private PlanBuilder appendExistsSubqueryApplyNodes(PlanBuilder builder, Set<ExistsPredicate> existsPredicates)\n+    private PlanBuilder planExists(PlanBuilder subPlan, List<ExistsPredicate> cluster)\n     {\n-        for (ExistsPredicate existsPredicate : existsPredicates) {\n-            builder = appendExistSubqueryApplyNode(builder, existsPredicate);\n-        }\n-        return builder;\n-    }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-    /**\n-     * Exists is modeled as:\n-     * <pre>\n-     *     - Project($0 > 0)\n-     *       - Aggregation(COUNT(*))\n-     *         - Limit(1)\n-     *           -- subquery\n-     * </pre>\n-     */\n-    private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPredicate existsPredicate)\n-    {\n-        if (subPlan.canTranslate(existsPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        // Plan one of the predicates from the cluster\n+        ExistsPredicate existsPredicate = cluster.get(0);\n \n-        PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n+        Expression subquery = existsPredicate.getSubquery();\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n         Symbol exists = symbolAllocator.newSymbol(\"exists\", BOOLEAN);\n-        subPlan.getTranslations().put(existsPredicate, exists);\n-        ExistsPredicate rewrittenExistsPredicate = new ExistsPredicate(TRUE_LITERAL);\n-        return appendApplyNode(\n-                subPlan,\n-                existsPredicate.getSubquery(),\n-                subqueryPlan.getRoot(),\n-                Assignments.of(exists, rewrittenExistsPredicate));\n+\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), exists)),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(exists, new ExistsPredicate(TRUE_LITERAL)),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        subquery));\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNodes(PlanBuilder subPlan, Set<QuantifiedComparisonExpression> quantifiedComparisons, Node node)\n+    private RelationPlan planSubquery(Expression subquery, TranslationMap outerContext)\n     {\n-        for (QuantifiedComparisonExpression quantifiedComparison : quantifiedComparisons) {\n-            subPlan = appendQuantifiedComparisonApplyNode(subPlan, quantifiedComparison, node);\n-        }\n-        return subPlan;\n+        return new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, Optional.of(outerContext), session)\n+                .process(subquery, null);\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNode(PlanBuilder subPlan, QuantifiedComparisonExpression quantifiedComparison, Node node)\n+    private PlanBuilder planQuantifiedComparison(PlanBuilder subPlan, List<QuantifiedComparisonExpression> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(quantifiedComparison)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n-        switch (quantifiedComparison.getOperator()) {\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n+\n+        // Plan one of the predicates from the cluster\n+        QuantifiedComparisonExpression quantifiedComparison = cluster.get(0);\n+\n+        ComparisonExpression.Operator operator = quantifiedComparison.getOperator();\n+        Quantifier quantifier = quantifiedComparison.getQuantifier();\n+        Expression value = quantifiedComparison.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) quantifiedComparison.getSubquery();\n+\n+        subPlan = handleSubqueries(subPlan, value, node);\n+\n+        Symbol output = symbolAllocator.newSymbol(quantifiedComparison, BOOLEAN);\n+\n+        switch (operator) {\n             case EQUAL:\n-                switch (quantifiedComparison.getQuantifier()) {\n+                switch (quantifier) {\n                     case ALL:\n-                        return planQuantifiedApplyNode(subPlan, quantifiedComparison);\n+                        subPlan = planQuantifiedComparison(subPlan, operator, quantifier, value, subquery, output);\n+                        return new PlanBuilder(\n+                                subPlan.getTranslations()\n+                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),\n+                                subPlan.getRoot());\n                     case ANY:\n                     case SOME:\n                         // A = ANY B <=> A IN B\n-                        InPredicate inPredicate = new InPredicate(quantifiedComparison.getValue(), quantifiedComparison.getSubquery());\n-                        subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.translate(inPredicate));\n-                        return subPlan;\n+                        subPlan = planInPredicate(subPlan, value, subquery, output, quantifiedComparison);\n+\n+                        return new PlanBuilder(\n+                                subPlan.getTranslations()\n+                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0MjY3Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429642672", "bodyText": "Could we add mappings for the whole cluster instead of single expression?", "author": "kasiafi", "createdAt": "2020-05-24T14:31:40Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(output, new InPredicate(\n+                                subplanCoercions.get(value).toSymbolReference(),\n+                                subqueryCoercions.get(subquery).toSymbolReference())),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        originalExpression));\n     }\n \n-    private PlanBuilder appendScalarSubqueryApplyNode(PlanBuilder subPlan, SubqueryExpression scalarSubquery)\n+    private PlanBuilder planScalarSubquery(PlanBuilder subPlan, List<SubqueryExpression> cluster)\n     {\n-        if (subPlan.canTranslate(scalarSubquery)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        List<Expression> coercions = coercionsFor(scalarSubquery);\n-\n-        SubqueryExpression uncoercedScalarSubquery = uncoercedSubquery(scalarSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedScalarSubquery);\n-        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n-        subqueryPlan = subqueryPlan.appendProjections(coercions, symbolAllocator, idAllocator);\n+        // Plan one of the predicates from the cluster\n+        SubqueryExpression scalarSubquery = cluster.get(0);\n \n-        Symbol uncoercedScalarSubquerySymbol = subqueryPlan.translate(uncoercedScalarSubquery);\n-        subPlan.getTranslations().put(uncoercedScalarSubquery, uncoercedScalarSubquerySymbol);\n+        RelationPlan relationPlan = planSubquery(scalarSubquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n-        for (Expression coercion : coercions) {\n-            Symbol coercionSymbol = subqueryPlan.translate(coercion);\n-            subPlan.getTranslations().put(coercion, coercionSymbol);\n-        }\n+        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n \n-        // The subquery's EnforceSingleRowNode always produces a row, so the join is effectively INNER\n-        return appendCorrelatedJoin(subPlan, subqueryPlan, scalarSubquery.getQuery(), CorrelatedJoinNode.Type.INNER, TRUE_LITERAL);\n+        return appendCorrelatedJoin(\n+                subPlan,\n+                subqueryPlan,\n+                scalarSubquery.getQuery(),\n+                CorrelatedJoinNode.Type.INNER,\n+                TRUE_LITERAL,\n+                mapAll(cluster, subPlan.getScope(), getOnlyElement(relationPlan.getFieldMappings())));\n     }\n \n-    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition)\n+    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition, Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        PlanNode subqueryNode = subqueryPlan.getRoot();\n-        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n-        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n-\n         return new PlanBuilder(\n-                subPlan.copyTranslations(),\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mappings),\n                 new CorrelatedJoinNode(\n                         idAllocator.getNextId(),\n                         subPlan.getRoot(),\n-                        subqueryNode,\n-                        ImmutableList.copyOf(SymbolsExtractor.extractUnique(correlation.values())),\n+                        subqueryPlan.getRoot(),\n+                        subPlan.getRoot().getOutputSymbols(),\n                         type,\n                         filterCondition,\n                         query));\n     }\n \n-    private PlanBuilder appendExistsSubqueryApplyNodes(PlanBuilder builder, Set<ExistsPredicate> existsPredicates)\n+    private PlanBuilder planExists(PlanBuilder subPlan, List<ExistsPredicate> cluster)\n     {\n-        for (ExistsPredicate existsPredicate : existsPredicates) {\n-            builder = appendExistSubqueryApplyNode(builder, existsPredicate);\n-        }\n-        return builder;\n-    }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-    /**\n-     * Exists is modeled as:\n-     * <pre>\n-     *     - Project($0 > 0)\n-     *       - Aggregation(COUNT(*))\n-     *         - Limit(1)\n-     *           -- subquery\n-     * </pre>\n-     */\n-    private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPredicate existsPredicate)\n-    {\n-        if (subPlan.canTranslate(existsPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        // Plan one of the predicates from the cluster\n+        ExistsPredicate existsPredicate = cluster.get(0);\n \n-        PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n+        Expression subquery = existsPredicate.getSubquery();\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n         Symbol exists = symbolAllocator.newSymbol(\"exists\", BOOLEAN);\n-        subPlan.getTranslations().put(existsPredicate, exists);\n-        ExistsPredicate rewrittenExistsPredicate = new ExistsPredicate(TRUE_LITERAL);\n-        return appendApplyNode(\n-                subPlan,\n-                existsPredicate.getSubquery(),\n-                subqueryPlan.getRoot(),\n-                Assignments.of(exists, rewrittenExistsPredicate));\n+\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), exists)),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(exists, new ExistsPredicate(TRUE_LITERAL)),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        subquery));\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNodes(PlanBuilder subPlan, Set<QuantifiedComparisonExpression> quantifiedComparisons, Node node)\n+    private RelationPlan planSubquery(Expression subquery, TranslationMap outerContext)\n     {\n-        for (QuantifiedComparisonExpression quantifiedComparison : quantifiedComparisons) {\n-            subPlan = appendQuantifiedComparisonApplyNode(subPlan, quantifiedComparison, node);\n-        }\n-        return subPlan;\n+        return new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, Optional.of(outerContext), session)\n+                .process(subquery, null);\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNode(PlanBuilder subPlan, QuantifiedComparisonExpression quantifiedComparison, Node node)\n+    private PlanBuilder planQuantifiedComparison(PlanBuilder subPlan, List<QuantifiedComparisonExpression> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(quantifiedComparison)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n-        switch (quantifiedComparison.getOperator()) {\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n+\n+        // Plan one of the predicates from the cluster\n+        QuantifiedComparisonExpression quantifiedComparison = cluster.get(0);\n+\n+        ComparisonExpression.Operator operator = quantifiedComparison.getOperator();\n+        Quantifier quantifier = quantifiedComparison.getQuantifier();\n+        Expression value = quantifiedComparison.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) quantifiedComparison.getSubquery();\n+\n+        subPlan = handleSubqueries(subPlan, value, node);\n+\n+        Symbol output = symbolAllocator.newSymbol(quantifiedComparison, BOOLEAN);\n+\n+        switch (operator) {\n             case EQUAL:\n-                switch (quantifiedComparison.getQuantifier()) {\n+                switch (quantifier) {\n                     case ALL:\n-                        return planQuantifiedApplyNode(subPlan, quantifiedComparison);\n+                        subPlan = planQuantifiedComparison(subPlan, operator, quantifier, value, subquery, output);\n+                        return new PlanBuilder(\n+                                subPlan.getTranslations()\n+                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),\n+                                subPlan.getRoot());\n                     case ANY:\n                     case SOME:\n                         // A = ANY B <=> A IN B\n-                        InPredicate inPredicate = new InPredicate(quantifiedComparison.getValue(), quantifiedComparison.getSubquery());\n-                        subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.translate(inPredicate));\n-                        return subPlan;\n+                        subPlan = planInPredicate(subPlan, value, subquery, output, quantifiedComparison);\n+\n+                        return new PlanBuilder(\n+                                subPlan.getTranslations()\n+                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),\n+                                subPlan.getRoot());\n                 }\n                 break;\n \n             case NOT_EQUAL:\n-                switch (quantifiedComparison.getQuantifier()) {\n-                    case ALL:\n-                        // A <> ALL B <=> !(A IN B) <=> !(A = ANY B)\n-                        QuantifiedComparisonExpression rewrittenAny = new QuantifiedComparisonExpression(\n-                                EQUAL,\n-                                Quantifier.ANY,\n-                                quantifiedComparison.getValue(),\n-                                quantifiedComparison.getSubquery());\n-                        Expression notAny = new NotExpression(rewrittenAny);\n-                        // \"A <> ALL B\" is equivalent to \"NOT (A = ANY B)\" so add a rewrite for the initial quantifiedComparison to notAny\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.getTranslations().rewrite(notAny));\n-                        // now plan \"A = ANY B\" part by calling ourselves for rewrittenAny\n-                        return appendQuantifiedComparisonApplyNode(subPlan, rewrittenAny, node);\n+                switch (quantifier) {\n+                    case ALL: {\n+                        // A <> ALL B <=> !(A IN B)\n+                        subPlan = planInPredicate(subPlan, value, subquery, output, quantifiedComparison);\n+                        return addNegation(subPlan, quantifiedComparison, output);\n+                    }\n                     case ANY:\n-                    case SOME:\n+                    case SOME: {\n                         // A <> ANY B <=> min B <> max B || A <> min B <=> !(min B = max B && A = min B) <=> !(A = ALL B)\n-                        QuantifiedComparisonExpression rewrittenAll = new QuantifiedComparisonExpression(\n-                                EQUAL,\n-                                QuantifiedComparisonExpression.Quantifier.ALL,\n-                                quantifiedComparison.getValue(),\n-                                quantifiedComparison.getSubquery());\n-                        Expression notAll = new NotExpression(rewrittenAll);\n                         // \"A <> ANY B\" is equivalent to \"NOT (A = ALL B)\" so add a rewrite for the initial quantifiedComparison to notAll\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.getTranslations().rewrite(notAll));\n-                        // now plan \"A = ALL B\" part by calling ourselves for rewrittenAll\n-                        return appendQuantifiedComparisonApplyNode(subPlan, rewrittenAll, node);\n+                        subPlan = planQuantifiedComparison(subPlan, EQUAL, Quantifier.ALL, value, subquery, output);\n+                        return addNegation(subPlan, quantifiedComparison, output);\n+                    }\n                 }\n                 break;\n \n             case LESS_THAN:\n             case LESS_THAN_OR_EQUAL:\n             case GREATER_THAN:\n             case GREATER_THAN_OR_EQUAL:\n-                return planQuantifiedApplyNode(subPlan, quantifiedComparison);\n+                subPlan = planQuantifiedComparison(subPlan, operator, quantifier, value, subquery, output);\n+                return new PlanBuilder(\n+                        subPlan.getTranslations()\n+                                .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),\n+                        subPlan.getRoot());\n         }\n         // all cases are checked, so this exception should never be thrown\n         throw new IllegalArgumentException(\n-                format(\"Unexpected quantified comparison: '%s %s'\", quantifiedComparison.getOperator().getValue(), quantifiedComparison.getQuantifier()));\n-    }\n-\n-    private PlanBuilder planQuantifiedApplyNode(PlanBuilder subPlan, QuantifiedComparisonExpression quantifiedComparison)\n-    {\n-        subPlan = subPlan.appendProjections(ImmutableList.of(quantifiedComparison.getValue()), symbolAllocator, idAllocator);\n-\n-        checkState(quantifiedComparison.getSubquery() instanceof SubqueryExpression);\n-        SubqueryExpression quantifiedSubquery = (SubqueryExpression) quantifiedComparison.getSubquery();\n-\n-        SubqueryExpression uncoercedQuantifiedSubquery = uncoercedSubquery(quantifiedSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedQuantifiedSubquery);\n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(quantifiedSubquery), symbolAllocator, idAllocator);\n-\n-        QuantifiedComparisonExpression coercedQuantifiedComparison = new QuantifiedComparisonExpression(\n-                quantifiedComparison.getOperator(),\n-                quantifiedComparison.getQuantifier(),\n-                subPlan.translate(quantifiedComparison.getValue()).toSymbolReference(),\n-                subqueryPlan.translate(quantifiedSubquery).toSymbolReference());\n-\n-        Symbol coercedQuantifiedComparisonSymbol = symbolAllocator.newSymbol(coercedQuantifiedComparison, BOOLEAN);\n-        subPlan.getTranslations().put(quantifiedComparison, coercedQuantifiedComparisonSymbol);\n-\n-        return appendApplyNode(\n-                subPlan,\n-                quantifiedComparison.getSubquery(),\n-                subqueryPlan.getRoot(),\n-                Assignments.of(coercedQuantifiedComparisonSymbol, coercedQuantifiedComparison));\n-    }\n-\n-    private static boolean isAggregationWithEmptyGroupBy(PlanNode planNode)\n-    {\n-        return searchFrom(planNode)\n-                .recurseOnlyWhen(MorePredicates.isInstanceOfAny(ProjectNode.class))\n-                .where(AggregationNode.class::isInstance)\n-                .findFirst()\n-                .map(AggregationNode.class::cast)\n-                .map(aggregation -> aggregation.getGroupingKeys().isEmpty())\n-                .orElse(false);\n+                format(\"Unexpected quantified comparison: '%s %s'\", operator.getValue(), quantifier));\n     }\n \n     /**\n-     * Implicit coercions are added when mapping an expression to symbol in {@link TranslationMap}. Coercions\n-     * for expression are obtained from {@link Analysis} by identity comparison. Create a copy of subquery\n-     * in order to get a subquery expression that does not have any coercion assigned to it {@link Analysis}.\n+     * Adds a negation of the given input and remaps the provided expression to the negated expression\n      */\n-    private SubqueryExpression uncoercedSubquery(SubqueryExpression subquery)\n+    private PlanBuilder addNegation(PlanBuilder subPlan, Expression expression, Symbol input)\n     {\n-        return new SubqueryExpression(subquery.getQuery());\n-    }\n+        Symbol output = symbolAllocator.newSymbol(\"not\", BOOLEAN);\n \n-    private List<Expression> coercionsFor(Expression expression)\n-    {\n-        return analysis.getCoercions().keySet().stream()\n-                .map(NodeRef::getNode)\n-                .filter(coercionExpression -> coercionExpression.equals(expression))\n-                .collect(toImmutableList());\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), expression), output)),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NDgxMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429644811", "bodyText": "new line", "author": "kasiafi", "createdAt": "2020-05-24T14:53:17Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(output, new InPredicate(\n+                                subplanCoercions.get(value).toSymbolReference(),\n+                                subqueryCoercions.get(subquery).toSymbolReference())),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        originalExpression));\n     }\n \n-    private PlanBuilder appendScalarSubqueryApplyNode(PlanBuilder subPlan, SubqueryExpression scalarSubquery)\n+    private PlanBuilder planScalarSubquery(PlanBuilder subPlan, List<SubqueryExpression> cluster)\n     {\n-        if (subPlan.canTranslate(scalarSubquery)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        List<Expression> coercions = coercionsFor(scalarSubquery);\n-\n-        SubqueryExpression uncoercedScalarSubquery = uncoercedSubquery(scalarSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedScalarSubquery);\n-        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n-        subqueryPlan = subqueryPlan.appendProjections(coercions, symbolAllocator, idAllocator);\n+        // Plan one of the predicates from the cluster\n+        SubqueryExpression scalarSubquery = cluster.get(0);\n \n-        Symbol uncoercedScalarSubquerySymbol = subqueryPlan.translate(uncoercedScalarSubquery);\n-        subPlan.getTranslations().put(uncoercedScalarSubquery, uncoercedScalarSubquerySymbol);\n+        RelationPlan relationPlan = planSubquery(scalarSubquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n-        for (Expression coercion : coercions) {\n-            Symbol coercionSymbol = subqueryPlan.translate(coercion);\n-            subPlan.getTranslations().put(coercion, coercionSymbol);\n-        }\n+        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n \n-        // The subquery's EnforceSingleRowNode always produces a row, so the join is effectively INNER\n-        return appendCorrelatedJoin(subPlan, subqueryPlan, scalarSubquery.getQuery(), CorrelatedJoinNode.Type.INNER, TRUE_LITERAL);\n+        return appendCorrelatedJoin(\n+                subPlan,\n+                subqueryPlan,\n+                scalarSubquery.getQuery(),\n+                CorrelatedJoinNode.Type.INNER,\n+                TRUE_LITERAL,\n+                mapAll(cluster, subPlan.getScope(), getOnlyElement(relationPlan.getFieldMappings())));\n     }\n \n-    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition)\n+    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition, Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        PlanNode subqueryNode = subqueryPlan.getRoot();\n-        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n-        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n-\n         return new PlanBuilder(\n-                subPlan.copyTranslations(),\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mappings),\n                 new CorrelatedJoinNode(\n                         idAllocator.getNextId(),\n                         subPlan.getRoot(),\n-                        subqueryNode,\n-                        ImmutableList.copyOf(SymbolsExtractor.extractUnique(correlation.values())),\n+                        subqueryPlan.getRoot(),\n+                        subPlan.getRoot().getOutputSymbols(),\n                         type,\n                         filterCondition,\n                         query));\n     }\n \n-    private PlanBuilder appendExistsSubqueryApplyNodes(PlanBuilder builder, Set<ExistsPredicate> existsPredicates)\n+    private PlanBuilder planExists(PlanBuilder subPlan, List<ExistsPredicate> cluster)\n     {\n-        for (ExistsPredicate existsPredicate : existsPredicates) {\n-            builder = appendExistSubqueryApplyNode(builder, existsPredicate);\n-        }\n-        return builder;\n-    }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-    /**\n-     * Exists is modeled as:\n-     * <pre>\n-     *     - Project($0 > 0)\n-     *       - Aggregation(COUNT(*))\n-     *         - Limit(1)\n-     *           -- subquery\n-     * </pre>\n-     */\n-    private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPredicate existsPredicate)\n-    {\n-        if (subPlan.canTranslate(existsPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        // Plan one of the predicates from the cluster\n+        ExistsPredicate existsPredicate = cluster.get(0);\n \n-        PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n+        Expression subquery = existsPredicate.getSubquery();\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n         Symbol exists = symbolAllocator.newSymbol(\"exists\", BOOLEAN);\n-        subPlan.getTranslations().put(existsPredicate, exists);\n-        ExistsPredicate rewrittenExistsPredicate = new ExistsPredicate(TRUE_LITERAL);\n-        return appendApplyNode(\n-                subPlan,\n-                existsPredicate.getSubquery(),\n-                subqueryPlan.getRoot(),\n-                Assignments.of(exists, rewrittenExistsPredicate));\n+\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), exists)),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(exists, new ExistsPredicate(TRUE_LITERAL)),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        subquery));\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNodes(PlanBuilder subPlan, Set<QuantifiedComparisonExpression> quantifiedComparisons, Node node)\n+    private RelationPlan planSubquery(Expression subquery, TranslationMap outerContext)\n     {\n-        for (QuantifiedComparisonExpression quantifiedComparison : quantifiedComparisons) {\n-            subPlan = appendQuantifiedComparisonApplyNode(subPlan, quantifiedComparison, node);\n-        }\n-        return subPlan;\n+        return new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, Optional.of(outerContext), session)\n+                .process(subquery, null);\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNode(PlanBuilder subPlan, QuantifiedComparisonExpression quantifiedComparison, Node node)\n+    private PlanBuilder planQuantifiedComparison(PlanBuilder subPlan, List<QuantifiedComparisonExpression> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(quantifiedComparison)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n-        switch (quantifiedComparison.getOperator()) {\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n+\n+        // Plan one of the predicates from the cluster\n+        QuantifiedComparisonExpression quantifiedComparison = cluster.get(0);\n+\n+        ComparisonExpression.Operator operator = quantifiedComparison.getOperator();\n+        Quantifier quantifier = quantifiedComparison.getQuantifier();\n+        Expression value = quantifiedComparison.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) quantifiedComparison.getSubquery();\n+\n+        subPlan = handleSubqueries(subPlan, value, node);\n+\n+        Symbol output = symbolAllocator.newSymbol(quantifiedComparison, BOOLEAN);\n+\n+        switch (operator) {\n             case EQUAL:\n-                switch (quantifiedComparison.getQuantifier()) {\n+                switch (quantifier) {\n                     case ALL:\n-                        return planQuantifiedApplyNode(subPlan, quantifiedComparison);\n+                        subPlan = planQuantifiedComparison(subPlan, operator, quantifier, value, subquery, output);\n+                        return new PlanBuilder(\n+                                subPlan.getTranslations()\n+                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),\n+                                subPlan.getRoot());\n                     case ANY:\n                     case SOME:\n                         // A = ANY B <=> A IN B\n-                        InPredicate inPredicate = new InPredicate(quantifiedComparison.getValue(), quantifiedComparison.getSubquery());\n-                        subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.translate(inPredicate));\n-                        return subPlan;\n+                        subPlan = planInPredicate(subPlan, value, subquery, output, quantifiedComparison);\n+\n+                        return new PlanBuilder(\n+                                subPlan.getTranslations()\n+                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),\n+                                subPlan.getRoot());\n                 }\n                 break;\n \n             case NOT_EQUAL:\n-                switch (quantifiedComparison.getQuantifier()) {\n-                    case ALL:\n-                        // A <> ALL B <=> !(A IN B) <=> !(A = ANY B)\n-                        QuantifiedComparisonExpression rewrittenAny = new QuantifiedComparisonExpression(\n-                                EQUAL,\n-                                Quantifier.ANY,\n-                                quantifiedComparison.getValue(),\n-                                quantifiedComparison.getSubquery());\n-                        Expression notAny = new NotExpression(rewrittenAny);\n-                        // \"A <> ALL B\" is equivalent to \"NOT (A = ANY B)\" so add a rewrite for the initial quantifiedComparison to notAny\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.getTranslations().rewrite(notAny));\n-                        // now plan \"A = ANY B\" part by calling ourselves for rewrittenAny\n-                        return appendQuantifiedComparisonApplyNode(subPlan, rewrittenAny, node);\n+                switch (quantifier) {\n+                    case ALL: {\n+                        // A <> ALL B <=> !(A IN B)\n+                        subPlan = planInPredicate(subPlan, value, subquery, output, quantifiedComparison);\n+                        return addNegation(subPlan, quantifiedComparison, output);\n+                    }\n                     case ANY:\n-                    case SOME:\n+                    case SOME: {\n                         // A <> ANY B <=> min B <> max B || A <> min B <=> !(min B = max B && A = min B) <=> !(A = ALL B)\n-                        QuantifiedComparisonExpression rewrittenAll = new QuantifiedComparisonExpression(\n-                                EQUAL,\n-                                QuantifiedComparisonExpression.Quantifier.ALL,\n-                                quantifiedComparison.getValue(),\n-                                quantifiedComparison.getSubquery());\n-                        Expression notAll = new NotExpression(rewrittenAll);\n                         // \"A <> ANY B\" is equivalent to \"NOT (A = ALL B)\" so add a rewrite for the initial quantifiedComparison to notAll\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.getTranslations().rewrite(notAll));\n-                        // now plan \"A = ALL B\" part by calling ourselves for rewrittenAll\n-                        return appendQuantifiedComparisonApplyNode(subPlan, rewrittenAll, node);\n+                        subPlan = planQuantifiedComparison(subPlan, EQUAL, Quantifier.ALL, value, subquery, output);\n+                        return addNegation(subPlan, quantifiedComparison, output);\n+                    }\n                 }\n                 break;\n \n             case LESS_THAN:\n             case LESS_THAN_OR_EQUAL:\n             case GREATER_THAN:\n             case GREATER_THAN_OR_EQUAL:\n-                return planQuantifiedApplyNode(subPlan, quantifiedComparison);\n+                subPlan = planQuantifiedComparison(subPlan, operator, quantifier, value, subquery, output);\n+                return new PlanBuilder(\n+                        subPlan.getTranslations()\n+                                .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),\n+                        subPlan.getRoot());\n         }\n         // all cases are checked, so this exception should never be thrown\n         throw new IllegalArgumentException(\n-                format(\"Unexpected quantified comparison: '%s %s'\", quantifiedComparison.getOperator().getValue(), quantifiedComparison.getQuantifier()));\n-    }\n-\n-    private PlanBuilder planQuantifiedApplyNode(PlanBuilder subPlan, QuantifiedComparisonExpression quantifiedComparison)\n-    {\n-        subPlan = subPlan.appendProjections(ImmutableList.of(quantifiedComparison.getValue()), symbolAllocator, idAllocator);\n-\n-        checkState(quantifiedComparison.getSubquery() instanceof SubqueryExpression);\n-        SubqueryExpression quantifiedSubquery = (SubqueryExpression) quantifiedComparison.getSubquery();\n-\n-        SubqueryExpression uncoercedQuantifiedSubquery = uncoercedSubquery(quantifiedSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedQuantifiedSubquery);\n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(quantifiedSubquery), symbolAllocator, idAllocator);\n-\n-        QuantifiedComparisonExpression coercedQuantifiedComparison = new QuantifiedComparisonExpression(\n-                quantifiedComparison.getOperator(),\n-                quantifiedComparison.getQuantifier(),\n-                subPlan.translate(quantifiedComparison.getValue()).toSymbolReference(),\n-                subqueryPlan.translate(quantifiedSubquery).toSymbolReference());\n-\n-        Symbol coercedQuantifiedComparisonSymbol = symbolAllocator.newSymbol(coercedQuantifiedComparison, BOOLEAN);\n-        subPlan.getTranslations().put(quantifiedComparison, coercedQuantifiedComparisonSymbol);\n-\n-        return appendApplyNode(\n-                subPlan,\n-                quantifiedComparison.getSubquery(),\n-                subqueryPlan.getRoot(),\n-                Assignments.of(coercedQuantifiedComparisonSymbol, coercedQuantifiedComparison));\n-    }\n-\n-    private static boolean isAggregationWithEmptyGroupBy(PlanNode planNode)\n-    {\n-        return searchFrom(planNode)\n-                .recurseOnlyWhen(MorePredicates.isInstanceOfAny(ProjectNode.class))\n-                .where(AggregationNode.class::isInstance)\n-                .findFirst()\n-                .map(AggregationNode.class::cast)\n-                .map(aggregation -> aggregation.getGroupingKeys().isEmpty())\n-                .orElse(false);\n+                format(\"Unexpected quantified comparison: '%s %s'\", operator.getValue(), quantifier));\n     }\n \n     /**\n-     * Implicit coercions are added when mapping an expression to symbol in {@link TranslationMap}. Coercions\n-     * for expression are obtained from {@link Analysis} by identity comparison. Create a copy of subquery\n-     * in order to get a subquery expression that does not have any coercion assigned to it {@link Analysis}.\n+     * Adds a negation of the given input and remaps the provided expression to the negated expression\n      */\n-    private SubqueryExpression uncoercedSubquery(SubqueryExpression subquery)\n+    private PlanBuilder addNegation(PlanBuilder subPlan, Expression expression, Symbol input)\n     {\n-        return new SubqueryExpression(subquery.getQuery());\n-    }\n+        Symbol output = symbolAllocator.newSymbol(\"not\", BOOLEAN);\n \n-    private List<Expression> coercionsFor(Expression expression)\n-    {\n-        return analysis.getCoercions().keySet().stream()\n-                .map(NodeRef::getNode)\n-                .filter(coercionExpression -> coercionExpression.equals(expression))\n-                .collect(toImmutableList());\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), expression), output)),\n+                new ProjectNode(\n+                        idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        Assignments.builder()\n+                                .putIdentities(subPlan.getRoot().getOutputSymbols())\n+                                .put(output, new NotExpression(input.toSymbolReference()))\n+                                .build()));\n     }\n \n-    private PlanBuilder appendApplyNode(\n-            PlanBuilder subPlan,\n-            Node subquery,\n-            PlanNode subqueryNode,\n-            Assignments subqueryAssignments)\n+    private PlanBuilder planQuantifiedComparison(PlanBuilder subPlan, ComparisonExpression.Operator operator, Quantifier quantifier, Expression value, Expression subquery, Symbol assignment)\n     {\n-        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n+\n         subPlan = subPlan.appendProjections(\n-                correlation.keySet().stream().map(NodeRef::getNode).collect(toImmutableSet()),\n+                ImmutableList.of(value),\n                 symbolAllocator,\n                 idAllocator);\n-        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n \n-        TranslationMap translations = subPlan.copyTranslations();\n-        PlanNode root = subPlan.getRoot();\n-        return new PlanBuilder(translations,\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n+\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n                 new ApplyNode(idAllocator.getNextId(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NTAxMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429645012", "bodyText": "why not mapAll(cluster)?", "author": "kasiafi", "createdAt": "2020-05-24T14:55:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(output, new InPredicate(\n+                                subplanCoercions.get(value).toSymbolReference(),\n+                                subqueryCoercions.get(subquery).toSymbolReference())),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        originalExpression));\n     }\n \n-    private PlanBuilder appendScalarSubqueryApplyNode(PlanBuilder subPlan, SubqueryExpression scalarSubquery)\n+    private PlanBuilder planScalarSubquery(PlanBuilder subPlan, List<SubqueryExpression> cluster)\n     {\n-        if (subPlan.canTranslate(scalarSubquery)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        List<Expression> coercions = coercionsFor(scalarSubquery);\n-\n-        SubqueryExpression uncoercedScalarSubquery = uncoercedSubquery(scalarSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedScalarSubquery);\n-        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n-        subqueryPlan = subqueryPlan.appendProjections(coercions, symbolAllocator, idAllocator);\n+        // Plan one of the predicates from the cluster\n+        SubqueryExpression scalarSubquery = cluster.get(0);\n \n-        Symbol uncoercedScalarSubquerySymbol = subqueryPlan.translate(uncoercedScalarSubquery);\n-        subPlan.getTranslations().put(uncoercedScalarSubquery, uncoercedScalarSubquerySymbol);\n+        RelationPlan relationPlan = planSubquery(scalarSubquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n-        for (Expression coercion : coercions) {\n-            Symbol coercionSymbol = subqueryPlan.translate(coercion);\n-            subPlan.getTranslations().put(coercion, coercionSymbol);\n-        }\n+        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n \n-        // The subquery's EnforceSingleRowNode always produces a row, so the join is effectively INNER\n-        return appendCorrelatedJoin(subPlan, subqueryPlan, scalarSubquery.getQuery(), CorrelatedJoinNode.Type.INNER, TRUE_LITERAL);\n+        return appendCorrelatedJoin(\n+                subPlan,\n+                subqueryPlan,\n+                scalarSubquery.getQuery(),\n+                CorrelatedJoinNode.Type.INNER,\n+                TRUE_LITERAL,\n+                mapAll(cluster, subPlan.getScope(), getOnlyElement(relationPlan.getFieldMappings())));\n     }\n \n-    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition)\n+    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition, Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        PlanNode subqueryNode = subqueryPlan.getRoot();\n-        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n-        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n-\n         return new PlanBuilder(\n-                subPlan.copyTranslations(),\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mappings),\n                 new CorrelatedJoinNode(\n                         idAllocator.getNextId(),\n                         subPlan.getRoot(),\n-                        subqueryNode,\n-                        ImmutableList.copyOf(SymbolsExtractor.extractUnique(correlation.values())),\n+                        subqueryPlan.getRoot(),\n+                        subPlan.getRoot().getOutputSymbols(),\n                         type,\n                         filterCondition,\n                         query));\n     }\n \n-    private PlanBuilder appendExistsSubqueryApplyNodes(PlanBuilder builder, Set<ExistsPredicate> existsPredicates)\n+    private PlanBuilder planExists(PlanBuilder subPlan, List<ExistsPredicate> cluster)\n     {\n-        for (ExistsPredicate existsPredicate : existsPredicates) {\n-            builder = appendExistSubqueryApplyNode(builder, existsPredicate);\n-        }\n-        return builder;\n-    }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-    /**\n-     * Exists is modeled as:\n-     * <pre>\n-     *     - Project($0 > 0)\n-     *       - Aggregation(COUNT(*))\n-     *         - Limit(1)\n-     *           -- subquery\n-     * </pre>\n-     */\n-    private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPredicate existsPredicate)\n-    {\n-        if (subPlan.canTranslate(existsPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        // Plan one of the predicates from the cluster\n+        ExistsPredicate existsPredicate = cluster.get(0);\n \n-        PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n+        Expression subquery = existsPredicate.getSubquery();\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n         Symbol exists = symbolAllocator.newSymbol(\"exists\", BOOLEAN);\n-        subPlan.getTranslations().put(existsPredicate, exists);\n-        ExistsPredicate rewrittenExistsPredicate = new ExistsPredicate(TRUE_LITERAL);\n-        return appendApplyNode(\n-                subPlan,\n-                existsPredicate.getSubquery(),\n-                subqueryPlan.getRoot(),\n-                Assignments.of(exists, rewrittenExistsPredicate));\n+\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), exists)),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(exists, new ExistsPredicate(TRUE_LITERAL)),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        subquery));\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNodes(PlanBuilder subPlan, Set<QuantifiedComparisonExpression> quantifiedComparisons, Node node)\n+    private RelationPlan planSubquery(Expression subquery, TranslationMap outerContext)\n     {\n-        for (QuantifiedComparisonExpression quantifiedComparison : quantifiedComparisons) {\n-            subPlan = appendQuantifiedComparisonApplyNode(subPlan, quantifiedComparison, node);\n-        }\n-        return subPlan;\n+        return new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, Optional.of(outerContext), session)\n+                .process(subquery, null);\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNode(PlanBuilder subPlan, QuantifiedComparisonExpression quantifiedComparison, Node node)\n+    private PlanBuilder planQuantifiedComparison(PlanBuilder subPlan, List<QuantifiedComparisonExpression> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(quantifiedComparison)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n-        switch (quantifiedComparison.getOperator()) {\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n+\n+        // Plan one of the predicates from the cluster\n+        QuantifiedComparisonExpression quantifiedComparison = cluster.get(0);\n+\n+        ComparisonExpression.Operator operator = quantifiedComparison.getOperator();\n+        Quantifier quantifier = quantifiedComparison.getQuantifier();\n+        Expression value = quantifiedComparison.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) quantifiedComparison.getSubquery();\n+\n+        subPlan = handleSubqueries(subPlan, value, node);\n+\n+        Symbol output = symbolAllocator.newSymbol(quantifiedComparison, BOOLEAN);\n+\n+        switch (operator) {\n             case EQUAL:\n-                switch (quantifiedComparison.getQuantifier()) {\n+                switch (quantifier) {\n                     case ALL:\n-                        return planQuantifiedApplyNode(subPlan, quantifiedComparison);\n+                        subPlan = planQuantifiedComparison(subPlan, operator, quantifier, value, subquery, output);\n+                        return new PlanBuilder(\n+                                subPlan.getTranslations()\n+                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0NTA4Nw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429645087", "bodyText": "why not mapAll(cluster)?", "author": "kasiafi", "createdAt": "2020-05-24T14:56:16Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(output, new InPredicate(\n+                                subplanCoercions.get(value).toSymbolReference(),\n+                                subqueryCoercions.get(subquery).toSymbolReference())),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        originalExpression));\n     }\n \n-    private PlanBuilder appendScalarSubqueryApplyNode(PlanBuilder subPlan, SubqueryExpression scalarSubquery)\n+    private PlanBuilder planScalarSubquery(PlanBuilder subPlan, List<SubqueryExpression> cluster)\n     {\n-        if (subPlan.canTranslate(scalarSubquery)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        List<Expression> coercions = coercionsFor(scalarSubquery);\n-\n-        SubqueryExpression uncoercedScalarSubquery = uncoercedSubquery(scalarSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedScalarSubquery);\n-        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n-        subqueryPlan = subqueryPlan.appendProjections(coercions, symbolAllocator, idAllocator);\n+        // Plan one of the predicates from the cluster\n+        SubqueryExpression scalarSubquery = cluster.get(0);\n \n-        Symbol uncoercedScalarSubquerySymbol = subqueryPlan.translate(uncoercedScalarSubquery);\n-        subPlan.getTranslations().put(uncoercedScalarSubquery, uncoercedScalarSubquerySymbol);\n+        RelationPlan relationPlan = planSubquery(scalarSubquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n-        for (Expression coercion : coercions) {\n-            Symbol coercionSymbol = subqueryPlan.translate(coercion);\n-            subPlan.getTranslations().put(coercion, coercionSymbol);\n-        }\n+        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n \n-        // The subquery's EnforceSingleRowNode always produces a row, so the join is effectively INNER\n-        return appendCorrelatedJoin(subPlan, subqueryPlan, scalarSubquery.getQuery(), CorrelatedJoinNode.Type.INNER, TRUE_LITERAL);\n+        return appendCorrelatedJoin(\n+                subPlan,\n+                subqueryPlan,\n+                scalarSubquery.getQuery(),\n+                CorrelatedJoinNode.Type.INNER,\n+                TRUE_LITERAL,\n+                mapAll(cluster, subPlan.getScope(), getOnlyElement(relationPlan.getFieldMappings())));\n     }\n \n-    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition)\n+    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition, Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        PlanNode subqueryNode = subqueryPlan.getRoot();\n-        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n-        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n-\n         return new PlanBuilder(\n-                subPlan.copyTranslations(),\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mappings),\n                 new CorrelatedJoinNode(\n                         idAllocator.getNextId(),\n                         subPlan.getRoot(),\n-                        subqueryNode,\n-                        ImmutableList.copyOf(SymbolsExtractor.extractUnique(correlation.values())),\n+                        subqueryPlan.getRoot(),\n+                        subPlan.getRoot().getOutputSymbols(),\n                         type,\n                         filterCondition,\n                         query));\n     }\n \n-    private PlanBuilder appendExistsSubqueryApplyNodes(PlanBuilder builder, Set<ExistsPredicate> existsPredicates)\n+    private PlanBuilder planExists(PlanBuilder subPlan, List<ExistsPredicate> cluster)\n     {\n-        for (ExistsPredicate existsPredicate : existsPredicates) {\n-            builder = appendExistSubqueryApplyNode(builder, existsPredicate);\n-        }\n-        return builder;\n-    }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-    /**\n-     * Exists is modeled as:\n-     * <pre>\n-     *     - Project($0 > 0)\n-     *       - Aggregation(COUNT(*))\n-     *         - Limit(1)\n-     *           -- subquery\n-     * </pre>\n-     */\n-    private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPredicate existsPredicate)\n-    {\n-        if (subPlan.canTranslate(existsPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        // Plan one of the predicates from the cluster\n+        ExistsPredicate existsPredicate = cluster.get(0);\n \n-        PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n+        Expression subquery = existsPredicate.getSubquery();\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n         Symbol exists = symbolAllocator.newSymbol(\"exists\", BOOLEAN);\n-        subPlan.getTranslations().put(existsPredicate, exists);\n-        ExistsPredicate rewrittenExistsPredicate = new ExistsPredicate(TRUE_LITERAL);\n-        return appendApplyNode(\n-                subPlan,\n-                existsPredicate.getSubquery(),\n-                subqueryPlan.getRoot(),\n-                Assignments.of(exists, rewrittenExistsPredicate));\n+\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), exists)),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(exists, new ExistsPredicate(TRUE_LITERAL)),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        subquery));\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNodes(PlanBuilder subPlan, Set<QuantifiedComparisonExpression> quantifiedComparisons, Node node)\n+    private RelationPlan planSubquery(Expression subquery, TranslationMap outerContext)\n     {\n-        for (QuantifiedComparisonExpression quantifiedComparison : quantifiedComparisons) {\n-            subPlan = appendQuantifiedComparisonApplyNode(subPlan, quantifiedComparison, node);\n-        }\n-        return subPlan;\n+        return new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, Optional.of(outerContext), session)\n+                .process(subquery, null);\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNode(PlanBuilder subPlan, QuantifiedComparisonExpression quantifiedComparison, Node node)\n+    private PlanBuilder planQuantifiedComparison(PlanBuilder subPlan, List<QuantifiedComparisonExpression> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(quantifiedComparison)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n-        switch (quantifiedComparison.getOperator()) {\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n+\n+        // Plan one of the predicates from the cluster\n+        QuantifiedComparisonExpression quantifiedComparison = cluster.get(0);\n+\n+        ComparisonExpression.Operator operator = quantifiedComparison.getOperator();\n+        Quantifier quantifier = quantifiedComparison.getQuantifier();\n+        Expression value = quantifiedComparison.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) quantifiedComparison.getSubquery();\n+\n+        subPlan = handleSubqueries(subPlan, value, node);\n+\n+        Symbol output = symbolAllocator.newSymbol(quantifiedComparison, BOOLEAN);\n+\n+        switch (operator) {\n             case EQUAL:\n-                switch (quantifiedComparison.getQuantifier()) {\n+                switch (quantifier) {\n                     case ALL:\n-                        return planQuantifiedApplyNode(subPlan, quantifiedComparison);\n+                        subPlan = planQuantifiedComparison(subPlan, operator, quantifier, value, subquery, output);\n+                        return new PlanBuilder(\n+                                subPlan.getTranslations()\n+                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),\n+                                subPlan.getRoot());\n                     case ANY:\n                     case SOME:\n                         // A = ANY B <=> A IN B\n-                        InPredicate inPredicate = new InPredicate(quantifiedComparison.getValue(), quantifiedComparison.getSubquery());\n-                        subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.translate(inPredicate));\n-                        return subPlan;\n+                        subPlan = planInPredicate(subPlan, value, subquery, output, quantifiedComparison);\n+\n+                        return new PlanBuilder(\n+                                subPlan.getTranslations()\n+                                        .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),\n+                                subPlan.getRoot());\n                 }\n                 break;\n \n             case NOT_EQUAL:\n-                switch (quantifiedComparison.getQuantifier()) {\n-                    case ALL:\n-                        // A <> ALL B <=> !(A IN B) <=> !(A = ANY B)\n-                        QuantifiedComparisonExpression rewrittenAny = new QuantifiedComparisonExpression(\n-                                EQUAL,\n-                                Quantifier.ANY,\n-                                quantifiedComparison.getValue(),\n-                                quantifiedComparison.getSubquery());\n-                        Expression notAny = new NotExpression(rewrittenAny);\n-                        // \"A <> ALL B\" is equivalent to \"NOT (A = ANY B)\" so add a rewrite for the initial quantifiedComparison to notAny\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.getTranslations().rewrite(notAny));\n-                        // now plan \"A = ANY B\" part by calling ourselves for rewrittenAny\n-                        return appendQuantifiedComparisonApplyNode(subPlan, rewrittenAny, node);\n+                switch (quantifier) {\n+                    case ALL: {\n+                        // A <> ALL B <=> !(A IN B)\n+                        subPlan = planInPredicate(subPlan, value, subquery, output, quantifiedComparison);\n+                        return addNegation(subPlan, quantifiedComparison, output);\n+                    }\n                     case ANY:\n-                    case SOME:\n+                    case SOME: {\n                         // A <> ANY B <=> min B <> max B || A <> min B <=> !(min B = max B && A = min B) <=> !(A = ALL B)\n-                        QuantifiedComparisonExpression rewrittenAll = new QuantifiedComparisonExpression(\n-                                EQUAL,\n-                                QuantifiedComparisonExpression.Quantifier.ALL,\n-                                quantifiedComparison.getValue(),\n-                                quantifiedComparison.getSubquery());\n-                        Expression notAll = new NotExpression(rewrittenAll);\n                         // \"A <> ANY B\" is equivalent to \"NOT (A = ALL B)\" so add a rewrite for the initial quantifiedComparison to notAll\n-                        subPlan.getTranslations().put(quantifiedComparison, subPlan.getTranslations().rewrite(notAll));\n-                        // now plan \"A = ALL B\" part by calling ourselves for rewrittenAll\n-                        return appendQuantifiedComparisonApplyNode(subPlan, rewrittenAll, node);\n+                        subPlan = planQuantifiedComparison(subPlan, EQUAL, Quantifier.ALL, value, subquery, output);\n+                        return addNegation(subPlan, quantifiedComparison, output);\n+                    }\n                 }\n                 break;\n \n             case LESS_THAN:\n             case LESS_THAN_OR_EQUAL:\n             case GREATER_THAN:\n             case GREATER_THAN_OR_EQUAL:\n-                return planQuantifiedApplyNode(subPlan, quantifiedComparison);\n+                subPlan = planQuantifiedComparison(subPlan, operator, quantifier, value, subquery, output);\n+                return new PlanBuilder(\n+                        subPlan.getTranslations()\n+                                .withAdditionalMappings(ImmutableMap.of(scopeAwareKey(analysis, subPlan.getScope(), quantifiedComparison), output)),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1MzkxOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429653919", "bodyText": "Why are name and columnNames not compared?\nFor AliasedRelation, they are.", "author": "kasiafi", "createdAt": "2020-05-24T16:38:40Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/WithQuery.java", "diffHunk": "@@ -105,4 +105,10 @@ public boolean equals(Object obj)\n                 Objects.equals(query, o.query) &&\n                 Objects.equals(columnNames, o.columnNames);\n     }\n+\n+    @Override\n+    public boolean shallowEquals(Node other)\n+    {\n+        return sameClass(this, other);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1NjI1Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429656252", "bodyText": "Shallow state includes: type, withTimeZone and precision.", "author": "kasiafi", "createdAt": "2020-05-24T17:09:09Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/DateTimeDataType.java", "diffHunk": "@@ -93,4 +93,10 @@ public int hashCode()\n     {\n         return Objects.hash(type, withTimeZone, precision);\n     }\n+\n+    @Override\n+    public boolean shallowEquals(Node other)\n+    {\n+        return sameClass(this, other);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTQzNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429665437", "bodyText": "the field List<List<Expression>> sets is neither compared in shallowEquals() nor are the expressions returned in getChildren().\nI think that the number and sizes of the nested lists should be compared in shallowEquals.\nIn getChildren() a concatenated list should be returned.", "author": "kasiafi", "createdAt": "2020-05-24T19:02:45Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/GroupingSets.java", "diffHunk": "@@ -99,4 +99,10 @@ public String toString()\n                 .add(\"sets\", sets)\n                 .toString();\n     }\n+\n+    @Override\n+    public boolean shallowEquals(Node other)\n+    {\n+        return sameClass(this, other);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTkyNQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429665925", "bodyText": "compare fields from and to", "author": "kasiafi", "createdAt": "2020-05-24T19:09:47Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/IntervalDayTimeDataType.java", "diffHunk": "@@ -90,4 +90,10 @@ public int hashCode()\n     {\n         return Objects.hash(from, to);\n     }\n+\n+    @Override\n+    public boolean shallowEquals(Node other)\n+    {\n+        return sameClass(this, other);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NjU2OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429666569", "bodyText": "nullTreatment is an Optional, compare by equals.", "author": "kasiafi", "createdAt": "2020-05-24T19:18:29Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/FunctionCall.java", "diffHunk": "@@ -152,4 +152,18 @@ public int hashCode()\n     {\n         IGNORE, RESPECT\n     }\n+\n+    @Override\n+    public boolean shallowEquals(Node other)\n+    {\n+        if (!sameClass(this, other)) {\n+            return false;\n+        }\n+\n+        FunctionCall otherFunction = (FunctionCall) other;\n+\n+        return name.equals(otherFunction.name) &&\n+                distinct == otherFunction.distinct &&\n+                nullTreatment == otherFunction.nullTreatment;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2Njk1Mw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r429666953", "bodyText": "Why is delimited not considered?", "author": "kasiafi", "createdAt": "2020-05-24T19:24:22Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/Identifier.java", "diffHunk": "@@ -97,4 +97,15 @@ public int hashCode()\n     {\n         return value.hashCode();\n     }\n+\n+    @Override\n+    public boolean shallowEquals(Node other)\n+    {\n+        if (!sameClass(this, other)) {\n+            return false;\n+        }\n+\n+        Identifier that = (Identifier) other;\n+        return Objects.equals(value, that.value);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NzAxOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r430067019", "bodyText": "There are two ValuesNodes because there are two different VALUES. Not because of coercions, like the comment suggests.", "author": "kasiafi", "createdAt": "2020-05-25T20:27:51Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -480,13 +480,22 @@ public void testSameScalarSubqueryIsAppliedOnlyOnce()\n         // three subqueries with two duplicates (coerced to two different types), only two scalar joins should be in plan\n         assertEquals(\n                 countOfMatchingNodes(\n-                        plan(\"SELECT * FROM orders WHERE CAST(orderkey AS INTEGER) = (SELECT 1) AND custkey = (SELECT 2) AND CAST(custkey as REAL) != (SELECT 1)\"),\n+                        plan(\"SELECT * \" +\n+                                \"FROM orders \" +\n+                                \"WHERE CAST(orderkey AS INTEGER) = (VALUES rand()) \" +\n+                                \"AND custkey = (VALUES rand() + 1) \" +\n+                                \"AND CAST(custkey as REAL) != (VALUES rand())\"),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMwNTk2MA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443305960", "bodyText": "Well, the old code had two instances of syntactically equivalent SELECT 1. The new code has something similar with VALUES rand(), but there's a bug. Because rand() is non-deterministic, we can't dedup syntactically.\nThe bug exists on master, too, so I'm going to leave it alone and fix it later.", "author": "martint", "createdAt": "2020-06-22T03:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NzAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MTc0Nw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r430071747", "bodyText": "Why not plan it simple -- i.e. plan the quantified comparison exactly as it is, and leave transformations to Optimizer rules?", "author": "kasiafi", "createdAt": "2020-05-25T20:52:07Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        subPlan = handleSubqueries(subPlan, inPredicate.getValue(), node);\n+        // Plan one of the predicates from the cluster\n+        InPredicate predicate = cluster.get(0);\n \n-        subPlan = subPlan.appendProjections(ImmutableList.of(inPredicate.getValue()), symbolAllocator, idAllocator);\n+        Expression value = predicate.getValue();\n+        SubqueryExpression subquery = (SubqueryExpression) predicate.getValueList();\n+        Symbol output = symbolAllocator.newSymbol(predicate, BOOLEAN);\n \n-        checkState(inPredicate.getValueList() instanceof SubqueryExpression);\n-        SubqueryExpression valueListSubquery = (SubqueryExpression) inPredicate.getValueList();\n-        SubqueryExpression uncoercedValueListSubquery = uncoercedSubquery(valueListSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedValueListSubquery);\n+        subPlan = handleSubqueries(subPlan, value, node);\n+        subPlan = planInPredicate(subPlan, value, subquery, output, predicate);\n \n-        subqueryPlan = subqueryPlan.appendProjections(ImmutableList.of(valueListSubquery), symbolAllocator, idAllocator);\n-        SymbolReference valueList = subqueryPlan.translate(valueListSubquery).toSymbolReference();\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), output)),\n+                subPlan.getRoot());\n+    }\n+\n+    /**\n+     * Plans a correlated subquery for value IN (subQuery)\n+     *\n+     * @param originalExpression the original expression from which the IN predicate was derived. Used for subsequent translations.\n+     */\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, Expression value, SubqueryExpression subquery, Symbol output, Expression originalExpression)\n+    {\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap,\n+                ImmutableMap.of(scopeAwareKey(analysis, relationPlan.getScope(), subquery), Iterables.getOnlyElement(relationPlan.getFieldMappings())));\n \n-        Symbol rewrittenValue = subPlan.translate(inPredicate.getValue());\n-        InPredicate inPredicateSubqueryExpression = new InPredicate(rewrittenValue.toSymbolReference(), valueList);\n-        Symbol inPredicateSubquerySymbol = symbolAllocator.newSymbol(inPredicateSubqueryExpression, BOOLEAN);\n+        QueryPlanner.PlanAndMappings subqueryCoercions = coerce(subqueryPlan, ImmutableList.of(subquery), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subqueryPlan = subqueryCoercions.getSubPlan();\n \n-        subPlan.getTranslations().put(inPredicate, inPredicateSubquerySymbol);\n+        subPlan = subPlan.appendProjections(\n+                ImmutableList.of(value),\n+                symbolAllocator,\n+                idAllocator);\n \n-        return appendApplyNode(subPlan, inPredicate, subqueryPlan.getRoot(), Assignments.of(inPredicateSubquerySymbol, inPredicateSubqueryExpression));\n-    }\n+        QueryPlanner.PlanAndMappings subplanCoercions = coerce(subPlan, ImmutableList.of(value), analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = subplanCoercions.getSubPlan();\n \n-    private PlanBuilder appendScalarSubqueryCorrelatedJoins(PlanBuilder builder, Set<SubqueryExpression> scalarSubqueries)\n-    {\n-        for (SubqueryExpression scalarSubquery : scalarSubqueries) {\n-            builder = appendScalarSubqueryApplyNode(builder, scalarSubquery);\n-        }\n-        return builder;\n+        return new PlanBuilder(\n+                subPlan.getTranslations(),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(output, new InPredicate(\n+                                subplanCoercions.get(value).toSymbolReference(),\n+                                subqueryCoercions.get(subquery).toSymbolReference())),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        originalExpression));\n     }\n \n-    private PlanBuilder appendScalarSubqueryApplyNode(PlanBuilder subPlan, SubqueryExpression scalarSubquery)\n+    private PlanBuilder planScalarSubquery(PlanBuilder subPlan, List<SubqueryExpression> cluster)\n     {\n-        if (subPlan.canTranslate(scalarSubquery)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-        List<Expression> coercions = coercionsFor(scalarSubquery);\n-\n-        SubqueryExpression uncoercedScalarSubquery = uncoercedSubquery(scalarSubquery);\n-        PlanBuilder subqueryPlan = createPlanBuilder(uncoercedScalarSubquery);\n-        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n-        subqueryPlan = subqueryPlan.appendProjections(coercions, symbolAllocator, idAllocator);\n+        // Plan one of the predicates from the cluster\n+        SubqueryExpression scalarSubquery = cluster.get(0);\n \n-        Symbol uncoercedScalarSubquerySymbol = subqueryPlan.translate(uncoercedScalarSubquery);\n-        subPlan.getTranslations().put(uncoercedScalarSubquery, uncoercedScalarSubquerySymbol);\n+        RelationPlan relationPlan = planSubquery(scalarSubquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n-        for (Expression coercion : coercions) {\n-            Symbol coercionSymbol = subqueryPlan.translate(coercion);\n-            subPlan.getTranslations().put(coercion, coercionSymbol);\n-        }\n+        subqueryPlan = subqueryPlan.withNewRoot(new EnforceSingleRowNode(idAllocator.getNextId(), subqueryPlan.getRoot()));\n \n-        // The subquery's EnforceSingleRowNode always produces a row, so the join is effectively INNER\n-        return appendCorrelatedJoin(subPlan, subqueryPlan, scalarSubquery.getQuery(), CorrelatedJoinNode.Type.INNER, TRUE_LITERAL);\n+        return appendCorrelatedJoin(\n+                subPlan,\n+                subqueryPlan,\n+                scalarSubquery.getQuery(),\n+                CorrelatedJoinNode.Type.INNER,\n+                TRUE_LITERAL,\n+                mapAll(cluster, subPlan.getScope(), getOnlyElement(relationPlan.getFieldMappings())));\n     }\n \n-    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition)\n+    public PlanBuilder appendCorrelatedJoin(PlanBuilder subPlan, PlanBuilder subqueryPlan, Query query, CorrelatedJoinNode.Type type, Expression filterCondition, Map<ScopeAware<Expression>, Symbol> mappings)\n     {\n-        PlanNode subqueryNode = subqueryPlan.getRoot();\n-        Map<NodeRef<Expression>, Expression> correlation = extractCorrelation(subPlan, subqueryNode);\n-        subqueryNode = replaceExpressionsWithSymbols(subqueryNode, correlation);\n-\n         return new PlanBuilder(\n-                subPlan.copyTranslations(),\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mappings),\n                 new CorrelatedJoinNode(\n                         idAllocator.getNextId(),\n                         subPlan.getRoot(),\n-                        subqueryNode,\n-                        ImmutableList.copyOf(SymbolsExtractor.extractUnique(correlation.values())),\n+                        subqueryPlan.getRoot(),\n+                        subPlan.getRoot().getOutputSymbols(),\n                         type,\n                         filterCondition,\n                         query));\n     }\n \n-    private PlanBuilder appendExistsSubqueryApplyNodes(PlanBuilder builder, Set<ExistsPredicate> existsPredicates)\n+    private PlanBuilder planExists(PlanBuilder subPlan, List<ExistsPredicate> cluster)\n     {\n-        for (ExistsPredicate existsPredicate : existsPredicates) {\n-            builder = appendExistSubqueryApplyNode(builder, existsPredicate);\n-        }\n-        return builder;\n-    }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");\n \n-    /**\n-     * Exists is modeled as:\n-     * <pre>\n-     *     - Project($0 > 0)\n-     *       - Aggregation(COUNT(*))\n-     *         - Limit(1)\n-     *           -- subquery\n-     * </pre>\n-     */\n-    private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPredicate existsPredicate)\n-    {\n-        if (subPlan.canTranslate(existsPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        // Plan one of the predicates from the cluster\n+        ExistsPredicate existsPredicate = cluster.get(0);\n \n-        PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n+        Expression subquery = existsPredicate.getSubquery();\n+        RelationPlan relationPlan = planSubquery(subquery, subPlan.getTranslations());\n+        PlanBuilder subqueryPlan = newPlanBuilder(\n+                relationPlan,\n+                analysis,\n+                lambdaDeclarationToSymbolMap);\n \n         Symbol exists = symbolAllocator.newSymbol(\"exists\", BOOLEAN);\n-        subPlan.getTranslations().put(existsPredicate, exists);\n-        ExistsPredicate rewrittenExistsPredicate = new ExistsPredicate(TRUE_LITERAL);\n-        return appendApplyNode(\n-                subPlan,\n-                existsPredicate.getSubquery(),\n-                subqueryPlan.getRoot(),\n-                Assignments.of(exists, rewrittenExistsPredicate));\n+\n+        return new PlanBuilder(\n+                subPlan.getTranslations()\n+                        .withAdditionalMappings(mapAll(cluster, subPlan.getScope(), exists)),\n+                new ApplyNode(idAllocator.getNextId(),\n+                        subPlan.getRoot(),\n+                        subqueryPlan.getRoot(),\n+                        Assignments.of(exists, new ExistsPredicate(TRUE_LITERAL)),\n+                        subPlan.getRoot().getOutputSymbols(),\n+                        subquery));\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNodes(PlanBuilder subPlan, Set<QuantifiedComparisonExpression> quantifiedComparisons, Node node)\n+    private RelationPlan planSubquery(Expression subquery, TranslationMap outerContext)\n     {\n-        for (QuantifiedComparisonExpression quantifiedComparison : quantifiedComparisons) {\n-            subPlan = appendQuantifiedComparisonApplyNode(subPlan, quantifiedComparison, node);\n-        }\n-        return subPlan;\n+        return new RelationPlanner(analysis, symbolAllocator, idAllocator, lambdaDeclarationToSymbolMap, metadata, Optional.of(outerContext), session)\n+                .process(subquery, null);\n     }\n \n-    private PlanBuilder appendQuantifiedComparisonApplyNode(PlanBuilder subPlan, QuantifiedComparisonExpression quantifiedComparison, Node node)\n+    private PlanBuilder planQuantifiedComparison(PlanBuilder subPlan, List<QuantifiedComparisonExpression> cluster, Node node)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI3NzMzOA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443277338", "bodyText": "Yes, eventually we should do that. I didn't want to take this on just yet.", "author": "martint", "createdAt": "2020-06-22T01:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MTc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NTAwNQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r430075005", "bodyText": "There are tests in TestLogicalPlanner for duplicate scalar subqueries, duplicate in-predicates and duplicate quantified comparisons. Do we have a test for duplicate EXISTS? Do we have a test for nested subqueries?", "author": "kasiafi", "createdAt": "2020-05-25T21:08:40Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,318 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyMDY2MQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443320661", "bodyText": "I'll add one", "author": "martint", "createdAt": "2020-06-22T05:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NTcwNA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r430075704", "bodyText": "Did you find any case where correlation list wasn't properly pruned?", "author": "kasiafi", "createdAt": "2020-05-25T21:12:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/ValidateDependenciesChecker.java", "diffHunk": "@@ -672,10 +671,6 @@ public Void visitCorrelatedJoin(CorrelatedJoinNode node, Set<Symbol> boundSymbol\n                     node.getInput().getOutputSymbols(),\n                     node.getCorrelation(),\n                     \"Correlated JOIN input must provide all the necessary correlation symbols for subquery\");\n-            checkDependencies(\n-                    SymbolsExtractor.extractUnique(node.getSubquery()),\n-                    node.getCorrelation(),\n-                    \"not all correlated JOIN correlation symbols are used in subquery\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyMjE5NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443322195", "bodyText": "No, but this is being called to validate intermediate plans, which may not have symbols pruned yet.", "author": "martint", "createdAt": "2020-06-22T05:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDQwNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r430580407", "bodyText": "This method name no longer matches: no scope is computed or assigned.\nAlso, remove the comment about creating scope.\nThis method could be inlined, and the comment at the call site also needs correction.\nIf I understand correctly, instead of creating a scope, we verify in AggregationAnalyzer that all references in orderBy are legal. So the comment might say what the limitations are and how we assert them.\nQuestion: what is the issue with\n// Don't add aggregate complex expressions that contains references to output column because the names would clash in TranslationMap during planning.", "author": "kasiafi", "createdAt": "2020-05-26T17:21:48Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2059,7 +2065,7 @@ private Scope computeAndAssignOrderByScope(OrderBy node, Scope sourceScope, Scop\n             return orderByScope;\n         }\n \n-        private void computeAndAssignOrderByScopeWithAggregation(OrderBy node, Scope sourceScope, Scope outputScope, List<FunctionCall> aggregations, List<Expression> groupByExpressions, List<GroupingOperation> groupingOperations)\n+        private void computeAndAssignOrderByScopeWithAggregation(OrderBy node, Scope outputScope, List<FunctionCall> aggregations, List<Expression> groupByExpressions, List<GroupingOperation> groupingOperations)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNTU3OA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443325578", "bodyText": "That's legacy. I'll clean it up", "author": "martint", "createdAt": "2020-06-22T05:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyNTUzMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r430625532", "bodyText": "Refactor to create empty GroupingSetsAnalysis once.", "author": "kasiafi", "createdAt": "2020-05-26T18:37:14Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1972,17 +1978,17 @@ else if (groupingElement instanceof GroupingSets) {\n                     }\n                 }\n \n-                analysis.setGroupByExpressions(node, expressions);\n-                analysis.setGroupingSets(node, new Analysis.GroupingSetAnalysis(cubes.build(), rollups.build(), sets.build(), complexExpressions.build()));\n+                GroupingSetAnalysis groupingSets = new GroupingSetAnalysis(expressions, cubes.build(), rollups.build(), sets.build(), complexExpressions.build());\n+                analysis.setGroupingSets(node, groupingSets);\n \n-                return expressions;\n+                return groupingSets;\n             }\n \n             if (hasAggregates(node) || node.getHaving().isPresent()) {\n-                analysis.setGroupByExpressions(node, ImmutableList.of());\n+                analysis.setGroupingSets(node, new GroupingSetAnalysis(ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of()));\n             }\n \n-            return ImmutableList.of();\n+            return new GroupingSetAnalysis(ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of(), ImmutableList.of());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2NjYxOA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443366618", "bodyText": "Are there any more usages of isAggregationWithEmptyGroupBy?", "author": "kokosing", "createdAt": "2020-06-22T07:31:11Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -261,22 +261,13 @@ private PlanBuilder appendExistSubqueryApplyNode(PlanBuilder subPlan, ExistsPred\n \n         PlanBuilder subqueryPlan = createPlanBuilder(existsPredicate.getSubquery());\n \n-        PlanNode subqueryPlanRoot = subqueryPlan.getRoot();\n-        if (isAggregationWithEmptyGroupBy(subqueryPlanRoot)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc2MjU2NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443762565", "bodyText": "No, that's why I removed the method, too.", "author": "martint", "createdAt": "2020-06-22T18:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2NjYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2NzQ3NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443367474", "bodyText": "isAggregationWithEmptyGroupBy was different. It was checking if subquery is EXISTS(SELECT agg(x) FROM t) which translates to true, but SELECT agg(x) FROM t does not translate to true.", "author": "kokosing", "createdAt": "2020-06-22T07:33:08Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/RemoveRedundantExists.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.optimizations.QueryCardinalityUtil;\n+import io.prestosql.sql.planner.plan.ApplyNode;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.ExistsPredicate;\n+import io.prestosql.sql.tree.Expression;\n+\n+import static io.prestosql.sql.planner.plan.Patterns.applyNode;\n+import static io.prestosql.sql.tree.BooleanLiteral.FALSE_LITERAL;\n+import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+\n+/**\n+ * Given:\n+ *\n+ * <pre>\n+ * - Apply [X.*, e = EXISTS (true)]\n+ *   - X\n+ *   - S with cardinality >= 1\n+ * </pre>\n+ *\n+ * Produces:\n+ *\n+ * <pre>\n+ * - Project [X.*, e = true]\n+ *   - X\n+ * </pre>\n+ *\n+ * Given:\n+ *\n+ * <pre>\n+ * - Apply [X.*, e = EXISTS (true)]\n+ *   - X\n+ *   - S with cardinality = 0\n+ * </pre>\n+ *\n+ * Produces:\n+ *\n+ * <pre>\n+ * - Project [X.*, e = false]\n+ *   - X\n+ * </pre>\n+ */\n+public class RemoveRedundantExists\n+        implements Rule<ApplyNode>\n+{\n+    private static final Pattern<ApplyNode> PATTERN = applyNode()\n+            .matching(node -> node.getSubqueryAssignments()\n+                    .getExpressions().stream()\n+                    .allMatch(expression -> expression instanceof ExistsPredicate && ((ExistsPredicate) expression).getSubquery().equals(TRUE_LITERAL)));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc2NzQ0Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443767446", "bodyText": "The TRUE in the assignment is a synthetic value that replaces the original subquery, but it's otherwise meaningless.\nA query like:\nSELECT EXISTS(SELECT agg(x) FROM t) FROM u\n\ngets planned as:\n- Apply\n    $0 = EXISTS (true)\n  - Table(u)\n  - Agg(x)\n    - Table(t)", "author": "martint", "createdAt": "2020-06-22T19:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2NzQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2OTQ5Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443369496", "bodyText": "What if IN contains correlated subquery? Can you please test that (with symbols from left and right relations)?", "author": "kokosing", "createdAt": "2020-06-22T07:37:22Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestJoin.java", "diffHunk": "@@ -52,4 +53,54 @@ public void testCrossJoinEliminationWithOuterJoin()\n                         \"JOIN d ON d.id = a.id\"))\n                 .matches(\"VALUES 1\");\n     }\n+\n+    @Test\n+    public void testInPredicateInJoinCriteria()\n+    {\n+        assertThat(assertions.query(\"SELECT * FROM (VALUES 1, 2, NULL) t(x) JOIN (VALUES 1, 3, NULL) u(x) ON t.x IN (VALUES 1)\"))\n+                .matches(\"VALUES (1, 1), (1, 3), (1, NULL)\");\n+\n+        assertThat(assertions.query(\"SELECT * FROM (VALUES 1, 2, NULL) t(x) LEFT JOIN (VALUES 1, 3, NULL) u(x) ON t.x IN (VALUES 1)\"))\n+                .matches(\"VALUES (1, 1), (1, 3), (1, NULL), (2, NULL), (NULL, NULL)\");\n+\n+        assertThat(assertions.query(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) RIGHT JOIN (VALUES 1, 3, NULL) u(x) ON t.x IN (VALUES 1)\"))\n+                .matches(\"VALUES (1, 1), (1, 3), (1, NULL)\");\n+\n+        assertThat(assertions.query(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) FULL JOIN (VALUES 1, 3, NULL) u(x) ON t.x IN (VALUES 1)\"))\n+                .matches(\"VALUES (1, 1), (1, 3), (1, NULL), (2, NULL), (NULL, NULL)\");\n+\n+        assertThat(assertions.query(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) JOIN (VALUES 1, 3, NULL) u(x) ON u.x IN (VALUES 1)\"))\n+                .matches(\"VALUES (1, 1), (2, 1), (NULL, 1)\");\n+\n+        assertThat(assertions.query(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) LEFT JOIN (VALUES 1, 3, NULL) u(x) ON u.x IN (VALUES 1)\"))\n+                .matches(\"VALUES (1, 1), (2, 1), (NULL, 1)\");\n+\n+        assertThat(assertions.query(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) RIGHT JOIN (VALUES 1, 3, NULL) u(x) ON u.x IN (VALUES 1)\"))\n+                .matches(\"VALUES (1, 1), (2, 1), (NULL, 1), (NULL, 3), (NULL, NULL)\");\n+\n+        assertThat(assertions.query(\n+                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) FULL JOIN (VALUES 1, 3, NULL) u(x) ON u.x IN (VALUES 1)\"))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc3MDQzNg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443770436", "bodyText": "That's not supported. It fails with an error saying that the reference is not allowed in that context: https://github.com/prestosql/presto/blob/master/presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java#L1501. I'll add some tests.", "author": "martint", "createdAt": "2020-06-22T19:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2OTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM3MjAyMA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r443372020", "bodyText": "We need to run benchmarks on this pull requests.", "author": "kokosing", "createdAt": "2020-06-22T07:42:27Z", "path": "presto-benchto-benchmarks/src/test/resources/sql/presto/tpcds/q01.plan.txt", "diffHunk": "@@ -22,14 +22,14 @@ local exchange (GATHER, SINGLE, [])\n                                         scan store", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyMTE5Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r444721192", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Compare with another node by considering internal state excluding any Node returned by getChildren()\n          \n          \n            \n                 * Compare with another node by considering internal state excluding children state", "author": "kokosing", "createdAt": "2020-06-24T08:12:44Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/Node.java", "diffHunk": "@@ -51,4 +51,21 @@ protected Node(Optional<NodeLocation> location)\n \n     @Override\n     public abstract String toString();\n+\n+    /**\n+     * Compare with another node by considering internal state excluding any Node returned by getChildren()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk2MzQzOA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r445963438", "bodyText": "That's more ambiguous. Some nodes currently have other nodes that could be considered \"children\" (e.g., instances of Identifier) but are not returned by getChildren(). In that case, they are considered \"internal state\"", "author": "martint", "createdAt": "2020-06-26T04:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyMTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyMTQyNA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r444721424", "bodyText": "I would extract introduction of this method to separate commit. It is a bit difficult to navigate in this pull request with so many files changed.", "author": "kokosing", "createdAt": "2020-06-24T08:13:10Z", "path": "presto-parser/src/main/java/io/prestosql/sql/tree/Node.java", "diffHunk": "@@ -51,4 +51,21 @@ protected Node(Optional<NodeLocation> location)\n \n     @Override\n     public abstract String toString();\n+\n+    /**\n+     * Compare with another node by considering internal state excluding any Node returned by getChildren()\n+     */\n+    public boolean shallowEquals(Node other)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NjUxMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r444946512", "bodyText": "I can do that for the purpose of review, but this is part of ScopeAware and belongs in this commit. That infrastructure only starts being used in this commit. If I pull it out, it becomes \"dead\" code with nothing that exercises or tests it.", "author": "martint", "createdAt": "2020-06-24T14:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyMTQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyMjUwMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r444722501", "bodyText": "Separate commit? Also I would change bleh to something more reasonable.", "author": "kokosing", "createdAt": "2020-06-24T08:15:00Z", "path": "presto-testing/src/main/java/io/prestosql/testing/AbstractTestQueries.java", "diffHunk": "@@ -1169,7 +1169,7 @@ public void testCorrelatedNonAggregationScalarSubqueries()\n \n         // multiple subquery output projections\n         assertQueryFails(\n-                \"SELECT name FROM nation n WHERE 'AFRICA' = (SELECT 'bleh' FROM region WHERE regionkey > n.regionkey)\",\n+                \"SELECT name FROM nation n WHERE 'bleh' = (SELECT 'bleh' FROM region WHERE regionkey > n.regionkey)\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0MzkzMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r444943932", "bodyText": "The thing is, there's nothing inherently wrong with the test, but with this change, the engine becomes \"smarter\" and can prove the equality can never be true, so the query stops failing. So, IMO, it's better to keep it as part of this change so it's clear the effect is related.", "author": "martint", "createdAt": "2020-06-24T14:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyMjUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyNTEzMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r444725132", "bodyText": "nice!", "author": "kokosing", "createdAt": "2020-06-24T08:19:46Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestSelectAll.java", "diffHunk": "@@ -190,7 +190,7 @@ public void testSelectAllFromOuterScopeTable()\n         // limit in subquery\n         assertions.assertQuery(\"SELECT (SELECT t.* FROM (VALUES 0) LIMIT 1) FROM (VALUES 1, 2) t(a)\", \"VALUES 1, 2\");\n         assertions.assertQuery(\"SELECT (SELECT t.* FROM (VALUES 0) LIMIT 5) FROM (VALUES 1, 2) t(a)\", \"VALUES 1, 2\");\n-        assertions.assertFails(\"SELECT (SELECT t.* FROM (VALUES 0) LIMIT 0) FROM (VALUES 1, 2) t(a)\", UNSUPPORTED_DECORRELATION_MESSAGE);\n+        assertions.assertQuery(\"SELECT (SELECT t.* FROM (VALUES 0) LIMIT 0) FROM (VALUES 1, 2) t(a)\", \"VALUES CAST(NULL AS INTEGER), CAST(NULL AS INTEGER)\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyNTQ1MQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r444725451", "bodyText": "do you know what kind of projection it was?", "author": "kokosing", "createdAt": "2020-06-24T08:20:21Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/optimizations/TestReorderWindows.java", "diffHunk": "@@ -247,12 +248,11 @@ public void testNotReorderAcrossNonPartitionFilter()\n                         window(windowMatcherBuilder -> windowMatcherBuilder\n                                         .specification(windowA)\n                                         .addFunction(functionCall(\"avg\", commonFrame, ImmutableList.of(QUANTITY_ALIAS))),\n-                                project(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0MjMxNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r444942317", "bodyText": "It was a column pruning projection. The final plans end up being the same before and after this change, but note that this test only exercises a subset of the rules.", "author": "martint", "createdAt": "2020-06-24T14:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcyNTQ1MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "2706fc40d5a4e0cf88f69ad27d8e4044271adfe0", "url": "https://github.com/trinodb/trino/commit/2706fc40d5a4e0cf88f69ad27d8e4044271adfe0", "message": "Simplify expression", "committedDate": "2020-06-27T01:33:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1OTkwMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447559902", "bodyText": "it would be nice to have concat accepts more arguments", "author": "kokosing", "createdAt": "2020-06-30T09:53:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -1027,6 +1028,18 @@ public GroupingSetAnalysis(\n         {\n             return complexExpressions;\n         }\n+\n+        public Set<FieldId> getAllFields()\n+        {\n+            return Stream.concat(", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg3MzIxMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448873211", "bodyText": "You can use https://guava.dev/releases/23.0/api/docs/com/google/common/collect/Streams.html#concat-java.util.stream.Stream...- instead", "author": "sopel39", "createdAt": "2020-07-02T09:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1OTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2MzU5NA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447563594", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // TODO: this should properly be multiset(row(...))\n          \n          \n            \n                        // TODO: this should be multiset(row(...))\n          \n      \n    \n    \n  \n\n?\nWouldn't be more proper for io.prestosql.sql.tree.ExistsPredicate to store io.prestosql.sql.tree.Query instead of Expression? Is it legal to have EXISTS (1)", "author": "kokosing", "createdAt": "2020-06-30T09:58:48Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1280,8 +1278,24 @@ else if (previousNode instanceof QuantifiedComparisonExpression) {\n         protected Type visitExists(ExistsPredicate node, StackableAstVisitorContext<Context> context)\n         {\n             StatementAnalyzer analyzer = statementAnalyzerFactory.apply(node);\n-            Scope subqueryScope = Scope.builder().withParent(context.getContext().getScope()).build();\n-            analyzer.analyze(node.getSubquery(), subqueryScope);\n+            Scope subqueryScope = Scope.builder()\n+                    .withParent(context.getContext().getScope())\n+                    .build();\n+\n+            List<RowType.Field> fields = analyzer.analyze(node.getSubquery(), subqueryScope)\n+                    .getRelationType()\n+                    .getAllFields().stream()\n+                    .map(field -> {\n+                        if (field.getName().isPresent()) {\n+                            return RowType.field(field.getName().get(), field.getType());\n+                        }\n+\n+                        return RowType.field(field.getType());\n+                    })\n+                    .collect(toImmutableList());\n+\n+            // TODO: this should properly be multiset(row(...))", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY5NDE0Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447694146", "bodyText": "I agree. Unfortunately, the AST doesn\u2019t allow for such structure. That\u2019s why subqueries were modeled that way.\nOnce this PR is in, we can start splitting AST from IR and have more flexibility to evolve the IR to fit the needs of the planner and optimizer", "author": "martint", "createdAt": "2020-06-30T13:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2MzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU2NzQwMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447567403", "bodyText": "separate commit?", "author": "kokosing", "createdAt": "2020-06-30T10:05:20Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1622,7 +1636,11 @@ public static ExpressionAnalysis analyzeExpressions(\n         Analysis analysis = new Analysis(null, parameters, isDescribe);\n         ExpressionAnalyzer analyzer = create(analysis, session, metadata, sqlParser, accessControl, types, warningCollector);\n         for (Expression expression : expressions) {\n-            analyzer.analyze(expression, Scope.builder().withRelationType(RelationId.anonymous(), new RelationType()).build());", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MzM3MQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447593371", "bodyText": "extract variable selectExpressions", "author": "kokosing", "createdAt": "2020-06-30T10:52:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1322,22 +1321,20 @@ protected Scope visitQuerySpecification(QuerySpecification node, Optional<Scope>\n                 }\n             }\n \n-            List<Expression> sourceExpressions = new ArrayList<>(outputExpressions);\n+            List<Expression> sourceExpressions = new ArrayList<>(analysis.getSelectExpressions(node).stream().map(SelectExpression::getExpression).collect(Collectors.toList()));", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MzgzNA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447593834", "bodyText": "seperate commit?", "author": "kokosing", "createdAt": "2020-06-30T10:53:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1601,8 +1598,10 @@ protected Scope visitValues(Values node, Optional<Scope> scope)\n         {\n             checkState(node.getRows().size() >= 1);\n \n+            Scope valuesScope = createScope(scope);\n+\n             List<List<Type>> rowTypes = node.getRows().stream()\n-                    .map(row -> analyzeExpression(row, createScope(scope)).getType(row))\n+                    .map(row -> analyzeExpression(row, valuesScope).getType(row))", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NjUwNQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447596505", "bodyText": "private", "author": "kokosing", "createdAt": "2020-06-30T10:58:44Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/QueryPlanner.java", "diffHunk": "@@ -466,130 +331,154 @@ private PlanBuilder aggregate(PlanBuilder subPlan, QuerySpecification node)\n                 .map(OrderBy::getSortItems)\n                 .flatMap(List::stream)\n                 .map(SortItem::getSortKey)\n-                .forEach(arguments::add);\n+                .forEach(inputBuilder::add);\n \n         // filter expressions need to be projected first\n         analysis.getAggregates(node).stream()\n                 .map(FunctionCall::getFilter)\n                 .filter(Optional::isPresent)\n                 .map(Optional::get)\n-                .forEach(arguments::add);\n+                .forEach(inputBuilder::add);\n \n-        Iterable<Expression> inputs = Iterables.concat(groupByExpressions, arguments.build());\n-        subPlan = handleSubqueries(subPlan, node, inputs);\n+        GroupingSetAnalysis groupingSetAnalysis = analysis.getGroupingSets(node);\n+        inputBuilder.addAll(groupingSetAnalysis.getComplexExpressions());\n \n-        if (!Iterables.isEmpty(inputs)) { // avoid an empty projection if the only aggregation is COUNT (which has no arguments)\n-            subPlan = project(subPlan, inputs);\n-        }\n+        List<Expression> inputs = inputBuilder.build();\n+        subPlan = subqueryPlanner.handleSubqueries(subPlan, inputs, node);\n+        subPlan = subPlan.appendProjections(inputs, symbolAllocator, idAllocator);\n \n-        // 2. Aggregate\n+        // Add projection to coerce inputs to their site-specific types.\n+        // This is important because the same lexical expression may need to be coerced\n+        // in different ways if it's referenced by multiple arguments to the window function.\n+        // For example, given v::integer,\n+        //    avg(v)\n+        // Needs to be rewritten as\n+        //    avg(CAST(v AS double))\n+        PlanAndMappings coercions = coerce(subPlan, inputs, analysis, idAllocator, symbolAllocator, typeCoercion);\n+        subPlan = coercions.getSubPlan();\n \n-        // 2.a. Rewrite aggregate arguments\n-        TranslationMap argumentTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n+        GroupingSetsPlan groupingSets = planGroupingSets(subPlan, node, groupingSetAnalysis);\n \n-        ImmutableList.Builder<Symbol> aggregationArgumentsBuilder = ImmutableList.builder();\n-        for (Expression argument : arguments.build()) {\n-            Symbol symbol = subPlan.translate(argument);\n-            argumentTranslations.put(argument, symbol);\n-            aggregationArgumentsBuilder.add(symbol);\n-        }\n-        List<Symbol> aggregationArguments = aggregationArgumentsBuilder.build();\n+        subPlan = planAggregation(groupingSets.getSubPlan(), groupingSets.getGroupingSets(), groupingSets.getGroupIdSymbol(), analysis.getAggregates(node), coercions::get);\n \n-        // 2.b. Rewrite grouping columns\n-        TranslationMap groupingTranslations = new TranslationMap(subPlan.getRelationPlan(), analysis, lambdaDeclarationToSymbolMap);\n+        return planGroupingOperations(subPlan, node, groupingSets.getGroupIdSymbol(), groupingSets.getColumnOnlyGroupingSets());\n+    }\n+\n+    public GroupingSetsPlan planGroupingSets(PlanBuilder subPlan, QuerySpecification node, GroupingSetAnalysis groupingSetAnalysis)", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDcwOA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447600708", "bodyText": "I think it makes a sense to extract Cluster class", "author": "kokosing", "createdAt": "2020-06-30T11:07:32Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SubqueryPlanner.java", "diffHunk": "@@ -108,482 +111,316 @@ public PlanBuilder handleSubqueries(PlanBuilder builder, Collection<Expression>\n \n     public PlanBuilder handleSubqueries(PlanBuilder builder, Expression expression, Node node)\n     {\n-        builder = appendInPredicateApplyNodes(builder, collectInPredicateSubqueries(expression, node), node);\n-        builder = appendScalarSubqueryCorrelatedJoins(builder, collectScalarSubqueries(expression, node));\n-        builder = appendExistsSubqueryApplyNodes(builder, collectExistsSubqueries(expression, node));\n-        builder = appendQuantifiedComparisonApplyNodes(builder, collectQuantifiedComparisonSubqueries(expression, node), node);\n+        for (List<InPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getInPredicateSubqueries(node)))) {\n+            builder = planInPredicate(builder, cluster, node);\n+        }\n+        for (List<SubqueryExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getScalarSubqueries(node)))) {\n+            builder = planScalarSubquery(builder, cluster);\n+        }\n+        for (List<ExistsPredicate> cluster : cluster(selectSubqueries(builder, expression, analysis.getExistsSubqueries(node)))) {\n+            builder = planExists(builder, cluster);\n+        }\n+        for (List<QuantifiedComparisonExpression> cluster : cluster(selectSubqueries(builder, expression, analysis.getQuantifiedComparisonSubqueries(node)))) {\n+            builder = planQuantifiedComparison(builder, cluster, node);\n+        }\n+\n         return builder;\n     }\n \n-    public Set<InPredicate> collectInPredicateSubqueries(Expression expression, Node node)\n+    /**\n+     * Find subqueries from the candidate set that are children of the given parent\n+     * and that have not already been handled in the subplan\n+     */\n+    private <T extends Expression> List<T> selectSubqueries(PlanBuilder subPlan, Expression parent, List<T> candidates)\n     {\n-        return analysis.getInPredicateSubqueries(node)\n-                .stream()\n-                .filter(inPredicate -> nodeContains(expression, inPredicate.getValueList()))\n-                .collect(toImmutableSet());\n-    }\n+        SuccessorsFunction<Node> recurse = expression -> {\n+            if (expression instanceof Expression &&\n+                    !analysis.isColumnReference((Expression) expression) && // no point in following dereference chains\n+                    !subPlan.canTranslate((Expression) expression)) { // don't consider subqueries under parts of the expression that have already been handled\n+                return expression.getChildren();\n+            }\n \n-    public Set<SubqueryExpression> collectScalarSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getScalarSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+            return ImmutableList.of();\n+        };\n \n-    public Set<ExistsPredicate> collectExistsSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getExistsSubqueries(node)\n-                .stream()\n-                .filter(subquery -> nodeContains(expression, subquery))\n-                .collect(toImmutableSet());\n-    }\n+        Iterable<Node> allSubExpressions = Traverser.forTree(recurse).depthFirstPreOrder(parent);\n \n-    public Set<QuantifiedComparisonExpression> collectQuantifiedComparisonSubqueries(Expression expression, Node node)\n-    {\n-        return analysis.getQuantifiedComparisonSubqueries(node)\n+        return candidates\n                 .stream()\n-                .filter(quantifiedComparison -> nodeContains(expression, quantifiedComparison.getSubquery()))\n-                .collect(toImmutableSet());\n+                .filter(candidate -> stream(allSubExpressions).anyMatch(child -> child == candidate))\n+                .filter(candidate -> !subPlan.canTranslate(candidate))\n+                .collect(toImmutableList());\n     }\n \n-    private PlanBuilder appendInPredicateApplyNodes(PlanBuilder subPlan, Set<InPredicate> inPredicates, Node node)\n+    /**\n+     * Group expressions into clusters such that all entries in a cluster are #equals to each other\n+     */\n+    private <T extends Expression> Collection<List<T>> cluster(List<T> expressions)\n     {\n-        for (InPredicate inPredicate : inPredicates) {\n-            subPlan = appendInPredicateApplyNode(subPlan, inPredicate, node);\n+        Map<T, List<T>> sets = new LinkedHashMap<>();\n+\n+        for (T expression : expressions) {\n+            sets.computeIfAbsent(expression, key -> new ArrayList<>())\n+                    .add(expression);\n         }\n-        return subPlan;\n+\n+        return sets.values();\n     }\n \n-    private PlanBuilder appendInPredicateApplyNode(PlanBuilder subPlan, InPredicate inPredicate, Node node)\n+    private PlanBuilder planInPredicate(PlanBuilder subPlan, List<InPredicate> cluster, Node node)\n     {\n-        if (subPlan.canTranslate(inPredicate)) {\n-            // given subquery is already appended\n-            return subPlan;\n-        }\n+        checkArgument(ImmutableSet.copyOf(cluster).size() == 1, \"Cluster contains expressions that don't equal each other\");", "originalCommit": "d46b1610af40d6ee001a02f5eb5c652e665f35c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDMzOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r447830339", "bodyText": "What's the benefit? A \"cluster\" is just a list of expressions, so that would be just a wrapper over a list.", "author": "martint", "createdAt": "2020-06-30T16:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE4NTQzMA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448185430", "bodyText": "A \"cluster\" is just a list of expressions\n\nIt is just an implementation of collection of equal elements. Having this abstraction you wouldn't need to call such checks.\nAlso do you actually need this list? Maybe you could have an representative element and count of copies?", "author": "kokosing", "createdAt": "2020-07-01T07:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDcwOA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU5MjEyMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448592121", "bodyText": "it's not being reused in this commit anywhere", "author": "sopel39", "createdAt": "2020-07-01T20:13:11Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1601,8 +1601,10 @@ protected Scope visitValues(Values node, Optional<Scope> scope)\n         {\n             checkState(node.getRows().size() >= 1);\n \n+            Scope valuesScope = createScope(scope);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3MTMxMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449071311", "bodyText": "I removed this in a recent version of the commit", "author": "martint", "createdAt": "2020-07-02T15:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU5MjEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg3MTQxNQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448871415", "bodyText": "What is an access control scope? Could you add a comment? Similarly, what is authorization?", "author": "sopel39", "createdAt": "2020-07-02T09:27:32Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Analysis.java", "diffHunk": "@@ -1177,14 +1190,22 @@ public int hashCode()\n         private final List<ViewExpression> filters;\n         private final Map<Field, List<ViewExpression>> columnMasks;\n         private final String authorization;\n-\n-        public TableEntry(Optional<TableHandle> handle, QualifiedObjectName name, List<ViewExpression> filters, Map<Field, List<ViewExpression>> columnMasks, String authorization)\n+        private final Scope accessControlScope;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3MjUxMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449072513", "bodyText": "It's the synthetic scope and authorization identifier used for analyzing column masks and row filters.", "author": "martint", "createdAt": "2020-07-02T15:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg3MTQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg3NzY0Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448877646", "bodyText": "does it mean that previously subquery didn't have a type at all?", "author": "sopel39", "createdAt": "2020-07-02T09:38:13Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1280,8 +1278,24 @@ else if (previousNode instanceof QuantifiedComparisonExpression) {\n         protected Type visitExists(ExistsPredicate node, StackableAstVisitorContext<Context> context)\n         {\n             StatementAnalyzer analyzer = statementAnalyzerFactory.apply(node);\n-            Scope subqueryScope = Scope.builder().withParent(context.getContext().getScope()).build();\n-            analyzer.analyze(node.getSubquery(), subqueryScope);\n+            Scope subqueryScope = Scope.builder()\n+                    .withParent(context.getContext().getScope())\n+                    .build();\n+\n+            List<RowType.Field> fields = analyzer.analyze(node.getSubquery(), subqueryScope)\n+                    .getRelationType()\n+                    .getAllFields().stream()\n+                    .map(field -> {\n+                        if (field.getName().isPresent()) {\n+                            return RowType.field(field.getName().get(), field.getType());\n+                        }\n+\n+                        return RowType.field(field.getType());\n+                    })\n+                    .collect(toImmutableList());\n+\n+            // TODO: this should be multiset(row(...))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NDgxNA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449074814", "bodyText": "No, it means that we're assigning a type row(...) to the subquery, but in reality, a subquery produces a collection of rows. It's something we need to fix in the IR and type system once we start decoupling AST from IR.", "author": "martint", "createdAt": "2020-07-02T15:15:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg3NzY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MDQyNg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448880426", "bodyText": "What about QuantifiedComparisonExpression? Shouldn't we do similar analysis there?\nWhat about SubqueryExpression?\nMaybe analysis of subquery should be a separate method?", "author": "sopel39", "createdAt": "2020-07-02T09:42:56Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -1280,8 +1278,24 @@ else if (previousNode instanceof QuantifiedComparisonExpression) {\n         protected Type visitExists(ExistsPredicate node, StackableAstVisitorContext<Context> context)\n         {\n             StatementAnalyzer analyzer = statementAnalyzerFactory.apply(node);\n-            Scope subqueryScope = Scope.builder().withParent(context.getContext().getScope()).build();\n-            analyzer.analyze(node.getSubquery(), subqueryScope);\n+            Scope subqueryScope = Scope.builder()\n+                    .withParent(context.getContext().getScope())\n+                    .build();\n+\n+            List<RowType.Field> fields = analyzer.analyze(node.getSubquery(), subqueryScope)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3OTAxNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449079017", "bodyText": "That's already handled for QuantifiedComparison and other expressions that support scalar subqueries (in visitSubqueryExpression). The difference is that this one produces full rows, while the others produce a single value. I agree that we could clean that up a bit, but it requires another refactoring of visitSubqueryExpression that's unrelated to this change.", "author": "martint", "createdAt": "2020-07-02T15:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4MDQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4NzQ1MA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448887450", "bodyText": "Does it mean we will do this recursion for every field? Can it impact planning time for complex plans?", "author": "sopel39", "createdAt": "2020-07-02T09:55:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Scope.java", "diffHunk": "@@ -207,29 +223,46 @@ public ResolvedField resolveField(Expression expression, QualifiedName name)\n \n     public Optional<ResolvedField> tryResolveField(Expression node, QualifiedName name)\n     {\n-        return resolveField(node, name, 0, true);\n+        return resolveField(node, name, true);\n     }\n \n-    private Optional<ResolvedField> resolveField(Expression node, QualifiedName name, int fieldIndexOffset, boolean local)\n+    private Optional<ResolvedField> resolveField(Expression node, QualifiedName name, boolean local)\n     {\n         List<Field> matches = relation.resolveFields(name);\n         if (matches.size() > 1) {\n             throw ambiguousAttributeException(node, name);\n         }\n         else if (matches.size() == 1) {\n-            return Optional.of(asResolvedField(getOnlyElement(matches), fieldIndexOffset, local));\n+            int parentFieldCount = getLocalParent()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4MDk3Mw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449080973", "bodyText": "Yes, but that's a trivial recursion -- there are typically not that many local scopes, and the operation is trivial (just follow a couple of links and a compute a sum).\nIn any case, I have some other plans for later to get rid of the need for hierarchical field index offset, as that abstraction is not really necessary after this revamp.", "author": "martint", "createdAt": "2020-07-02T15:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg4NzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4ODc4MQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448988781", "bodyText": "Previously fieldIndexOffset param of asResolvedField was computed top-down. Now it's the opposite, doesn't that break anything?", "author": "sopel39", "createdAt": "2020-07-02T13:08:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Scope.java", "diffHunk": "@@ -207,29 +223,46 @@ public ResolvedField resolveField(Expression expression, QualifiedName name)\n \n     public Optional<ResolvedField> tryResolveField(Expression node, QualifiedName name)\n     {\n-        return resolveField(node, name, 0, true);\n+        return resolveField(node, name, true);\n     }\n \n-    private Optional<ResolvedField> resolveField(Expression node, QualifiedName name, int fieldIndexOffset, boolean local)\n+    private Optional<ResolvedField> resolveField(Expression node, QualifiedName name, boolean local)\n     {\n         List<Field> matches = relation.resolveFields(name);\n         if (matches.size() > 1) {\n             throw ambiguousAttributeException(node, name);\n         }\n         else if (matches.size() == 1) {\n-            return Optional.of(asResolvedField(getOnlyElement(matches), fieldIndexOffset, local));\n+            int parentFieldCount = getLocalParent()\n+                    .map(Scope::getLocalScopeFieldCount)\n+                    .orElse(0);\n+\n+            Field field = getOnlyElement(matches);\n+            return Optional.of(asResolvedField(field, parentFieldCount, local));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4MTcxMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449081711", "bodyText": "No, it doesn't. I adjusted all the places that need that info.\nIn fact, it needs to be computed that way to have stable indexes as we switch from local scope to local scope while we plan the SELECT clause, the ORDER BY clause, etc.", "author": "martint", "createdAt": "2020-07-02T15:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4ODc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5MzMyOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448993329", "bodyText": "That comment seems to be valid regarding fields visibility. Consider changing it instead of fully removing", "author": "sopel39", "createdAt": "2020-07-02T13:15:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -1322,22 +1321,23 @@ protected Scope visitQuerySpecification(QuerySpecification node, Optional<Scope>\n                 }\n             }\n \n-            List<Expression> sourceExpressions = new ArrayList<>(outputExpressions);\n+            List<Expression> sourceExpressions = new ArrayList<>();\n+            analysis.getSelectExpressions(node).stream()\n+                    .map(SelectExpression::getExpression)\n+                    .forEach(sourceExpressions::add);\n             node.getHaving().ifPresent(sourceExpressions::add);\n \n             analyzeGroupingOperations(node, sourceExpressions, orderByExpressions);\n-            analyzeAggregations(node, sourceScope, orderByScope, groupByExpressions, sourceExpressions, orderByExpressions);\n+            analyzeAggregations(node, sourceScope, orderByScope, groupByAnalysis, sourceExpressions, orderByExpressions);\n             analyzeWindowFunctions(node, outputExpressions, orderByExpressions);\n \n             if (analysis.isAggregation(node) && node.getOrderBy().isPresent()) {\n-                // Create a different scope for ORDER BY expressions when aggregation is present.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDMwNg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449274306", "bodyText": "Not sure what I would write instead. This comment is about scope management, which is not needed anymore. We only record the aggregate expressions to be able to project them before adding the SortNode, similar to how we plan aggregations in a SELECT clause.", "author": "martint", "createdAt": "2020-07-02T21:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5MzMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NDg5MQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448994891", "bodyText": "this is nice!", "author": "sopel39", "createdAt": "2020-07-02T13:18:08Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2061,50 +2064,6 @@ private Scope computeAndAssignOrderByScope(OrderBy node, Scope sourceScope, Scop\n             return orderByScope;\n         }\n \n-        private void computeAndAssignOrderByScopeWithAggregation(OrderBy node, Scope sourceScope, Scope outputScope, List<FunctionCall> aggregations, List<Expression> groupByExpressions, List<GroupingOperation> groupingOperations)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NTI4NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r448995285", "bodyText": "We still need scope for planning (in TranslationMap). Why this extra scope for ORDER BY + AGGREGATES is not needed anymore?", "author": "sopel39", "createdAt": "2020-07-02T13:18:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/StatementAnalyzer.java", "diffHunk": "@@ -2061,50 +2064,6 @@ private Scope computeAndAssignOrderByScope(OrderBy node, Scope sourceScope, Scop\n             return orderByScope;\n         }\n \n-        private void computeAndAssignOrderByScopeWithAggregation(OrderBy node, Scope sourceScope, Scope outputScope, List<FunctionCall> aggregations, List<Expression> groupByExpressions, List<GroupingOperation> groupingOperations)\n-        {\n-            // This scope is only used for planning. When aggregation is present then", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDkwMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449274903", "bodyText": "There is one scope associated with the FROM clause and one with the SELECT clause. The references in ORDER BY expressions resolve against either of those (possibly mixed). There's no need to an artificial scope for aggregates.", "author": "martint", "createdAt": "2020-07-02T21:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwNTEzNQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449005135", "bodyText": "What does it mean that expression already has translation. Is this to avoid aliasing of symbols?\nLooking at the method above. !alreadyHasTranslation.test(translations, expression) means that translationMap.canTranslate(expression) == false. In such case we do translationMap.rewrite(expression). So if translationMap cannot translate, then it can rewrite?\nCould you add a comment to this if?", "author": "sopel39", "createdAt": "2020-07-02T13:34:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanBuilder.java", "diffHunk": "@@ -85,28 +93,39 @@ public TranslationMap getTranslations()\n         return translations;\n     }\n \n+    public Scope getScope()\n+    {\n+        return translations.getScope();\n+    }\n+\n     public PlanBuilder appendProjections(Iterable<Expression> expressions, SymbolAllocator symbolAllocator, PlanNodeIdAllocator idAllocator)\n     {\n-        TranslationMap translations = copyTranslations();\n+        return appendProjections(expressions, symbolAllocator, idAllocator, TranslationMap::rewrite, TranslationMap::canTranslate);\n+    }\n \n+    public <T extends Expression> PlanBuilder appendProjections(\n+            Iterable<T> expressions,\n+            SymbolAllocator symbolAllocator,\n+            PlanNodeIdAllocator idAllocator,\n+            BiFunction<TranslationMap, T, Expression> rewriter,\n+            BiPredicate<TranslationMap, T> alreadyHasTranslation)\n+    {\n         Assignments.Builder projections = Assignments.builder();\n \n         // add an identity projection for underlying plan\n-        for (Symbol symbol : getRoot().getOutputSymbols()) {\n-            projections.put(symbol, symbol.toSymbolReference());\n-        }\n-\n-        ImmutableMap.Builder<Symbol, Expression> newTranslations = ImmutableMap.builder();\n-        for (Expression expression : expressions) {\n-            Symbol symbol = symbolAllocator.newSymbol(expression, getAnalysis().getTypeWithCoercions(expression));\n-            projections.put(symbol, translations.rewrite(expression));\n-            newTranslations.put(symbol, expression);\n-        }\n-        // Now append the new translations into the TranslationMap\n-        for (Map.Entry<Symbol, Expression> entry : newTranslations.build().entrySet()) {\n-            translations.put(entry.getValue(), entry.getKey());\n+        projections.putIdentities(root.getOutputSymbols());\n+\n+        Map<ScopeAware<Expression>, Symbol> mappings = new HashMap<>();\n+        for (T expression : expressions) {\n+            if (!mappings.containsKey(scopeAwareKey(expression, translations.getAnalysis(), translations.getScope())) && !alreadyHasTranslation.test(translations, expression)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NTcwMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449275701", "bodyText": "canTranslate means that it has a mapping for the whole expression (e.g., because the expression appears multiple times). If it can't translate, we rewrite the expression (that converts all references to symbols, inserts coercions, etc), and add it to the translation map", "author": "martint", "createdAt": "2020-07-02T21:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwNTEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxMTk5Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449011996", "bodyText": "Some javadoc about the purpose of ScopeAware would be great", "author": "sopel39", "createdAt": "2020-07-02T13:44:19Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxNzY5NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449017695", "bodyText": "Is this if necessary? If both leftField and rightField are equal that should make left and right equal unconditionally, no? They reference same field from same table (by identity).\nCould it be simplified to:\nleftField.getFieldId().equals(rightField.getFieldId()) || leftExpression.equals(rightExpression)\n\nTo put it in a different way:\nHow two expressions that are column references where leftField.getFieldId().equals(rightField.getFieldId()) would not be equal?", "author": "sopel39", "createdAt": "2020-07-02T13:52:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<T>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash(node);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(scope.isLocalScope(other.scope) || other.scope.isLocalScope(scope), \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                if (isLocalScope(leftScope) || isLocalScope(rightScope)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Njc1Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449186752", "bodyText": "Consider the following query:\nSELECT -x AS x \nFROM (VALUES 1) t(x)\nORDER BY x\n\nthe x in the SELECT clause refers to t.x. The x in the ORDER BY clause refers to AS x. They have different field ids, but they can't be considered equal from syntax alone.", "author": "martint", "createdAt": "2020-07-02T18:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxNzY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIzMzMyNg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449233326", "bodyText": "Ok, so you probably could change the condition to\n// column references must have same syntax\nif (!leftExpression.equals(rightExpression) {\n  return false;\n}\n\n// column references must be within local scope or reference to outer scope\nreturn leftField.getFieldId().equals(rightField.getFieldId())\n  || (!isLocalScope(leftScope) && !isLocalScope(rightScope));\n\nit seems more natural and it also seems to be easier to fix hash below with such flow.", "author": "sopel39", "createdAt": "2020-07-02T19:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxNzY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI1OTM2Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449259362", "bodyText": "That's not equivalent. We need to be able to resolve references that don't have the same syntax to the same field. For instance:\nSELECT (SELECT t.x), (SELECT x) FROM (VALUES 1) t(x)\n\nBoth subqueries are equivalent because x and t.x reference the same column from t, even though they have different syntax.", "author": "martint", "createdAt": "2020-07-02T20:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAxNzY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMDExOQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449020119", "bodyText": "How would two expressions that are column references where !leftField.getFieldId().equals(rightField.getFieldId()) be equal?", "author": "sopel39", "createdAt": "2020-07-02T13:55:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<T>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash(node);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(scope.isLocalScope(other.scope) || other.scope.isLocalScope(scope), \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                if (isLocalScope(leftScope) || isLocalScope(rightScope)) {\n+                    // At least one of the fields comes from the same scope as the original expression, so compare by field id\n+                    return leftField.getFieldId().equals(rightField.getFieldId());\n+                }\n+\n+                // Otherwise, they are either:\n+                // 1. Local to a subquery. In this case, the specific fields they reference don't matter as long as everything else is syntactically equal.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NzA1Nw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449187057", "bodyText": "Answered above", "author": "martint", "createdAt": "2020-07-02T18:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMDExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MDQ2MA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449050460", "bodyText": "it makes sense to precalculate the hash since it will be expensive to compute that hash every time", "author": "sopel39", "createdAt": "2020-07-02T14:39:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<T>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash(node);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(scope.isLocalScope(other.scope) || other.scope.isLocalScope(scope), \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                if (isLocalScope(leftScope) || isLocalScope(rightScope)) {\n+                    // At least one of the fields comes from the same scope as the original expression, so compare by field id\n+                    return leftField.getFieldId().equals(rightField.getFieldId());\n+                }\n+\n+                // Otherwise, they are either:\n+                // 1. Local to a subquery. In this case, the specific fields they reference don't matter as long as everything else is syntactically equal.\n+                // 2. From a scope that is a parent to the base scope. In this case, the fields must necessarily be the same if they are syntactically equal.\n+                return leftExpression.equals(rightExpression);\n+            }\n+        }\n+\n+        if (!left.shallowEquals(right)) {\n+            return false;\n+        }\n+\n+        List<? extends Node> leftChildren = left.getChildren();\n+        List<? extends Node> rightChildren = right.getChildren();\n+\n+        if (leftChildren.size() != rightChildren.size()) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < leftChildren.size(); i++) {\n+            if (!equal(leftChildren.get(i), rightChildren.get(i))) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    private int hash(Node node)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MzUxMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449053513", "bodyText": "This doesn't seem to produce correct result compared to equal: if (isLocalScope(leftScope) || isLocalScope(rightScope)) {\nWhen isLocalScope(rightScope) == true and if (isLocalScope(leftScope) == false then we would use leftField.getFieldId().equals(rightField.getFieldId()); for comparison. Yet here we would use expression.hashCode();", "author": "sopel39", "createdAt": "2020-07-02T14:43:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<T>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash(node);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(scope.isLocalScope(other.scope) || other.scope.isLocalScope(scope), \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                if (isLocalScope(leftScope) || isLocalScope(rightScope)) {\n+                    // At least one of the fields comes from the same scope as the original expression, so compare by field id\n+                    return leftField.getFieldId().equals(rightField.getFieldId());\n+                }\n+\n+                // Otherwise, they are either:\n+                // 1. Local to a subquery. In this case, the specific fields they reference don't matter as long as everything else is syntactically equal.\n+                // 2. From a scope that is a parent to the base scope. In this case, the fields must necessarily be the same if they are syntactically equal.\n+                return leftExpression.equals(rightExpression);\n+            }\n+        }\n+\n+        if (!left.shallowEquals(right)) {\n+            return false;\n+        }\n+\n+        List<? extends Node> leftChildren = left.getChildren();\n+        List<? extends Node> rightChildren = right.getChildren();\n+\n+        if (leftChildren.size() != rightChildren.size()) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < leftChildren.size(); i++) {\n+            if (!equal(leftChildren.get(i), rightChildren.get(i))) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    private int hash(Node node)\n+    {\n+        if (node instanceof Expression) {\n+            Expression expression = (Expression) node;\n+            if (analysis.isColumnReference(expression)) {\n+                ResolvedField field = analysis.getResolvedField(expression);\n+\n+                Scope resolvedScope = field.getScope();\n+                if (isLocalScope(resolvedScope)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyMjQzMQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449222431", "bodyText": "You're right. Let me think about how to fix that.", "author": "martint", "createdAt": "2020-07-02T19:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MzUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NDA2OQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449054069", "bodyText": "this could be:\nint result = node.hashCode()\n\nto reduce collisions", "author": "sopel39", "createdAt": "2020-07-02T14:44:20Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<T>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash(node);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(scope.isLocalScope(other.scope) || other.scope.isLocalScope(scope), \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                if (isLocalScope(leftScope) || isLocalScope(rightScope)) {\n+                    // At least one of the fields comes from the same scope as the original expression, so compare by field id\n+                    return leftField.getFieldId().equals(rightField.getFieldId());\n+                }\n+\n+                // Otherwise, they are either:\n+                // 1. Local to a subquery. In this case, the specific fields they reference don't matter as long as everything else is syntactically equal.\n+                // 2. From a scope that is a parent to the base scope. In this case, the fields must necessarily be the same if they are syntactically equal.\n+                return leftExpression.equals(rightExpression);\n+            }\n+        }\n+\n+        if (!left.shallowEquals(right)) {\n+            return false;\n+        }\n+\n+        List<? extends Node> leftChildren = left.getChildren();\n+        List<? extends Node> rightChildren = right.getChildren();\n+\n+        if (leftChildren.size() != rightChildren.size()) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < leftChildren.size(); i++) {\n+            if (!equal(leftChildren.get(i), rightChildren.get(i))) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    private int hash(Node node)\n+    {\n+        if (node instanceof Expression) {\n+            Expression expression = (Expression) node;\n+            if (analysis.isColumnReference(expression)) {\n+                ResolvedField field = analysis.getResolvedField(expression);\n+\n+                Scope resolvedScope = field.getScope();\n+                if (isLocalScope(resolvedScope)) {\n+                    return field.getFieldId().hashCode();\n+                }\n+\n+                return expression.hashCode();\n+            }\n+        }\n+\n+        List<? extends Node> children = node.getChildren();\n+\n+        if (children.isEmpty()) {\n+            return node.hashCode();\n+        }\n+\n+        int result = 1;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNTY4MA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449115680", "bodyText": "No, because node.hashCode is implemented recursively and we specifically don't want to consider children in the computation except via the call to hash(...) below. Note that the leaves will use node.hashCode(), so collisions for subtrees are going to be rare.", "author": "martint", "createdAt": "2020-07-02T15:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NDA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExOTAxNA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449119014", "bodyText": "nit: You could use node.getClass().hashCode() instead", "author": "sopel39", "createdAt": "2020-07-02T16:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NDA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1NjkxNg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449056916", "bodyText": "nit: each arg in newline", "author": "sopel39", "createdAt": "2020-07-02T14:48:34Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/optimizations/TestMergeWindows.java", "diffHunk": "@@ -202,8 +202,9 @@ public void testIdenticalWindowSpecificationsABcpA()\n                                 window(windowMatcherBuilder -> windowMatcherBuilder\n                                                 .specification(specificationB)\n                                                 .addFunction(functionCall(\"nth_value\", COMMON_FRAME, ImmutableList.of(QUANTITY_ALIAS, \"ONE\"))),\n-                                        project(ImmutableMap.of(\"ONE\", expression(\"CAST(1 AS bigint)\")),\n-                                                LINEITEM_TABLESCAN_DOQSS)))));\n+                                        project(ImmutableMap.of(\"ONE\", expression(\"CAST(expr AS bigint)\")),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExODE5OA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449118198", "bodyText": "consider adding comment:\ncalculate shallow hash since node doesn't have any children\n\nfor reader to understand the difference", "author": "sopel39", "createdAt": "2020-07-02T16:00:14Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.scope = requireNonNull(scope, \"scope is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<T>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash(node);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(scope.isLocalScope(other.scope) || other.scope.isLocalScope(scope), \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                if (isLocalScope(leftScope) || isLocalScope(rightScope)) {\n+                    // At least one of the fields comes from the same scope as the original expression, so compare by field id\n+                    return leftField.getFieldId().equals(rightField.getFieldId());\n+                }\n+\n+                // Otherwise, they are either:\n+                // 1. Local to a subquery. In this case, the specific fields they reference don't matter as long as everything else is syntactically equal.\n+                // 2. From a scope that is a parent to the base scope. In this case, the fields must necessarily be the same if they are syntactically equal.\n+                return leftExpression.equals(rightExpression);\n+            }\n+        }\n+\n+        if (!left.shallowEquals(right)) {\n+            return false;\n+        }\n+\n+        List<? extends Node> leftChildren = left.getChildren();\n+        List<? extends Node> rightChildren = right.getChildren();\n+\n+        if (leftChildren.size() != rightChildren.size()) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < leftChildren.size(); i++) {\n+            if (!equal(leftChildren.get(i), rightChildren.get(i))) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    private int hash(Node node)\n+    {\n+        if (node instanceof Expression) {\n+            Expression expression = (Expression) node;\n+            if (analysis.isColumnReference(expression)) {\n+                ResolvedField field = analysis.getResolvedField(expression);\n+\n+                Scope resolvedScope = field.getScope();\n+                if (isLocalScope(resolvedScope)) {\n+                    return field.getFieldId().hashCode();\n+                }\n+\n+                return expression.hashCode();\n+            }\n+        }\n+\n+        List<? extends Node> children = node.getChildren();\n+\n+        if (children.isEmpty()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUzNzUwMA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449537500", "bodyText": "rename to queryBoundaryScope or boundaryScope", "author": "sopel39", "createdAt": "2020-07-03T11:37:16Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A wrapper for Expressions that can be used as a key in maps and sets.\n+ *\n+ * Expressions are considered equal if they are structurally equal and column references refer to the same logical fields.\n+ *\n+ * For example, given\n+ *\n+ * <pre>SELECT t.a, a FROM (VALUES 1) t(a)</pre>\n+ *\n+ * \"t.a\" and \"a\" are considered equal because they reference the same field of \"t\"\n+ *\n+ * Limitation: the expressions in the following query are currently not considered equal to each other, even though they refer to the same field from the same table or\n+ * named query \"t\". This is because we currently don't assign identity to table references. (TODO: implement this)\n+ *\n+ * <pre>SELECT (SELECT t.a FROM t), (SELECT a FROM t)</pre>\n+ */\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUzODM3Mg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449538372", "bodyText": "move to Scope?", "author": "sopel39", "createdAt": "2020-07-03T11:39:28Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A wrapper for Expressions that can be used as a key in maps and sets.\n+ *\n+ * Expressions are considered equal if they are structurally equal and column references refer to the same logical fields.\n+ *\n+ * For example, given\n+ *\n+ * <pre>SELECT t.a, a FROM (VALUES 1) t(a)</pre>\n+ *\n+ * \"t.a\" and \"a\" are considered equal because they reference the same field of \"t\"\n+ *\n+ * Limitation: the expressions in the following query are currently not considered equal to each other, even though they refer to the same field from the same table or\n+ * named query \"t\". This is because we currently don't assign identity to table references. (TODO: implement this)\n+ *\n+ * <pre>SELECT (SELECT t.a FROM t), (SELECT a FROM t)</pre>\n+ */\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+    private final int hash;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        requireNonNull(scope, \"scope is null\");\n+\n+        this.scope = findQueryBoundaryScope(scope);\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+        this.hash = hash(node);\n+    }\n+\n+    private static Scope findQueryBoundaryScope(Scope scope)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0NTEzMw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449545133", "bodyText": "It would be great to have some test coverage for these edge cases. I'm not sure how feasible writing tests for ScopeAware would be. However, tests would show practical examples of same expressions", "author": "sopel39", "createdAt": "2020-07-03T11:56:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A wrapper for Expressions that can be used as a key in maps and sets.\n+ *\n+ * Expressions are considered equal if they are structurally equal and column references refer to the same logical fields.\n+ *\n+ * For example, given\n+ *\n+ * <pre>SELECT t.a, a FROM (VALUES 1) t(a)</pre>\n+ *\n+ * \"t.a\" and \"a\" are considered equal because they reference the same field of \"t\"\n+ *\n+ * Limitation: the expressions in the following query are currently not considered equal to each other, even though they refer to the same field from the same table or\n+ * named query \"t\". This is because we currently don't assign identity to table references. (TODO: implement this)\n+ *\n+ * <pre>SELECT (SELECT t.a FROM t), (SELECT a FROM t)</pre>\n+ */\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+    private final int hash;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        requireNonNull(scope, \"scope is null\");\n+\n+        this.scope = findQueryBoundaryScope(scope);\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+        this.hash = hash(node);\n+    }\n+\n+    private static Scope findQueryBoundaryScope(Scope scope)\n+    {\n+        Optional<Scope> parent = scope.getLocalParent();\n+        while (parent.isPresent()) {\n+            scope = parent.get();\n+            parent = scope.getLocalParent();\n+        }\n+        return scope;\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(this.scope == other.scope, \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                // For subqueries of the query associated with the current expression, compare by syntax", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0NTk5Ng==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449545996", "bodyText": "this still doesn't work.\nLet's suppose resolvedScope.hasOuterParent(scope) == true, then we return expression.hashCode() here.\nHowever, let's suppose that in comparison:\nrightScope.hasOuterParent(scope) == false\n\nthen we compare by leftField.getFieldId().equals(rightField.getFieldId()); which could return true (e.g t.x vs x).\nHowever, hashes would not be equal.", "author": "sopel39", "createdAt": "2020-07-03T11:58:45Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A wrapper for Expressions that can be used as a key in maps and sets.\n+ *\n+ * Expressions are considered equal if they are structurally equal and column references refer to the same logical fields.\n+ *\n+ * For example, given\n+ *\n+ * <pre>SELECT t.a, a FROM (VALUES 1) t(a)</pre>\n+ *\n+ * \"t.a\" and \"a\" are considered equal because they reference the same field of \"t\"\n+ *\n+ * Limitation: the expressions in the following query are currently not considered equal to each other, even though they refer to the same field from the same table or\n+ * named query \"t\". This is because we currently don't assign identity to table references. (TODO: implement this)\n+ *\n+ * <pre>SELECT (SELECT t.a FROM t), (SELECT a FROM t)</pre>\n+ */\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope scope;\n+    private final T node;\n+    private final int hash;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        requireNonNull(scope, \"scope is null\");\n+\n+        this.scope = findQueryBoundaryScope(scope);\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+        this.hash = hash(node);\n+    }\n+\n+    private static Scope findQueryBoundaryScope(Scope scope)\n+    {\n+        Optional<Scope> parent = scope.getLocalParent();\n+        while (parent.isPresent()) {\n+            scope = parent.get();\n+            parent = scope.getLocalParent();\n+        }\n+        return scope;\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(this.scope == other.scope, \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                // For subqueries of the query associated with the current expression, compare by syntax\n+                if (leftScope.hasOuterParent(scope) && rightScope.hasOuterParent(scope)) {\n+                    return leftExpression.equals(rightExpression);\n+                }\n+\n+                // Otherwise, for references that come from the current query scope or an outer scope of the current\n+                // expression, compare by resolved field\n+                return leftField.getFieldId().equals(rightField.getFieldId());\n+            }\n+        }\n+\n+        if (!left.shallowEquals(right)) {\n+            return false;\n+        }\n+\n+        List<? extends Node> leftChildren = left.getChildren();\n+        List<? extends Node> rightChildren = right.getChildren();\n+\n+        if (leftChildren.size() != rightChildren.size()) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < leftChildren.size(); i++) {\n+            if (!equal(leftChildren.get(i), rightChildren.get(i))) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    private int hash(Node node)\n+    {\n+        if (node instanceof Expression) {\n+            Expression expression = (Expression) node;\n+            if (analysis.isColumnReference(expression)) {\n+                ResolvedField field = analysis.getResolvedField(expression);\n+\n+                Scope resolvedScope = field.getScope();\n+                if (resolvedScope.hasOuterParent(scope)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1Mzk2MA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449653960", "bodyText": "Indeed, described in isolation, it has that issue. But remember that ScopeAware requires that the expressions being compared be in the same \"query scope\" (i.e., the \"root\" scopes need to be local to each other). So, consider the following cases:\n\nIf the expressions are simple expressions with no subqueries, all field references will have hasOuterParent(scope) == false, to this trivially works.\nIf the expressions contain subqueries, the non-nested part has to be equal per the item above. The subqueries need to be structurally similar (nodes need to be shallowly equal) before recursing, so if both expressions recurse into the subquery scope at the same time.\n\nThis is not very obvious, and I almost forgot about it. I even had a discussion with Kasia about it a few weeks ago. I'll add a comment to explain so we don't forget in the future.", "author": "martint", "createdAt": "2020-07-03T16:32:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU0NTk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcxMjI3NQ==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449712275", "bodyText": "comment does not match code. Should be left.hasOuterParent(queryScope) ...", "author": "sopel39", "createdAt": "2020-07-03T22:15:31Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A wrapper for Expressions that can be used as a key in maps and sets.\n+ *\n+ * Expressions are considered equal if they are structurally equal and column references refer to the same logical fields.\n+ *\n+ * For example, given\n+ *\n+ * <pre>SELECT t.a, a FROM (VALUES 1) t(a)</pre>\n+ *\n+ * \"t.a\" and \"a\" are considered equal because they reference the same field of \"t\"\n+ *\n+ * Limitation: the expressions in the following query are currently not considered equal to each other, even though they refer to the same field from the same table or\n+ * named query \"t\". This is because we currently don't assign identity to table references. (TODO: implement this)\n+ *\n+ * <pre>SELECT (SELECT t.a FROM t), (SELECT a FROM t)</pre>\n+ */\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope queryScope;\n+    private final T node;\n+    private final int hash;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        requireNonNull(scope, \"scope is null\");\n+\n+        this.queryScope = scope.findQueryBoundaryScope();\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+        this.hash = hash(node);\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(this.queryScope == other.queryScope, \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                // For subqueries of the query associated with the current expression, compare by syntax\n+                // Note: it'd appear that hash() and equal() are inconsistent with each other in the case that:\n+                //    * left.hasOuterParent() == true and right.hasOuterParent() == false", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcxMjUzMg==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449712532", "bodyText": "maybe this method should be called getQueryBoundaryScope to have consistent naming with other methods here?", "author": "sopel39", "createdAt": "2020-07-03T22:17:45Z", "path": "presto-main/src/main/java/io/prestosql/sql/analyzer/Scope.java", "diffHunk": "@@ -73,6 +73,17 @@ private Scope(\n         this.namedQueries = ImmutableMap.copyOf(requireNonNull(namedQueries, \"namedQueries is null\"));\n     }\n \n+    public Scope findQueryBoundaryScope()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcxMzQ1Nw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449713457", "bodyText": "consider adding check state:\ncheckState(leftScope.hasOuterParent(queryScope) == rightScope.hasOuterParent(queryScope))\n\nit should hold according to the comment", "author": "sopel39", "createdAt": "2020-07-03T22:26:38Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/ScopeAware.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import io.prestosql.sql.analyzer.Analysis;\n+import io.prestosql.sql.analyzer.ResolvedField;\n+import io.prestosql.sql.analyzer.Scope;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.Node;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A wrapper for Expressions that can be used as a key in maps and sets.\n+ *\n+ * Expressions are considered equal if they are structurally equal and column references refer to the same logical fields.\n+ *\n+ * For example, given\n+ *\n+ * <pre>SELECT t.a, a FROM (VALUES 1) t(a)</pre>\n+ *\n+ * \"t.a\" and \"a\" are considered equal because they reference the same field of \"t\"\n+ *\n+ * Limitation: the expressions in the following query are currently not considered equal to each other, even though they refer to the same field from the same table or\n+ * named query \"t\". This is because we currently don't assign identity to table references. (TODO: implement this)\n+ *\n+ * <pre>SELECT (SELECT t.a FROM t), (SELECT a FROM t)</pre>\n+ */\n+public class ScopeAware<T extends Node>\n+{\n+    private final Analysis analysis;\n+    private final Scope queryScope;\n+    private final T node;\n+    private final int hash;\n+\n+    private ScopeAware(Analysis analysis, Scope scope, T node)\n+    {\n+        requireNonNull(scope, \"scope is null\");\n+\n+        this.queryScope = scope.findQueryBoundaryScope();\n+        this.analysis = requireNonNull(analysis, \"analysis is null\");\n+        this.node = requireNonNull(node, \"node is null\");\n+        this.hash = hash(node);\n+    }\n+\n+    public static <T extends Node> ScopeAware<T> scopeAwareKey(T node, Analysis analysis, Scope scope)\n+    {\n+        return new ScopeAware<>(analysis, scope, node);\n+    }\n+\n+    public T getNode()\n+    {\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return hash;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        ScopeAware<T> other = (ScopeAware<T>) o;\n+        checkArgument(this.queryScope == other.queryScope, \"Expressions must be in the same local scope\");\n+\n+        return equal(node, other.node);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"ScopeAware(\" + node + \")\";\n+    }\n+\n+    private boolean equal(Node left, Node right)\n+    {\n+        if (left instanceof Expression && right instanceof Expression) {\n+            Expression leftExpression = (Expression) left;\n+            Expression rightExpression = (Expression) right;\n+            if (analysis.isColumnReference(leftExpression) && analysis.isColumnReference(rightExpression)) {\n+                ResolvedField leftField = analysis.getResolvedField(leftExpression);\n+                ResolvedField rightField = analysis.getResolvedField(rightExpression);\n+\n+                Scope leftScope = leftField.getScope();\n+                Scope rightScope = rightField.getScope();\n+\n+                // For subqueries of the query associated with the current expression, compare by syntax\n+                // Note: it'd appear that hash() and equal() are inconsistent with each other in the case that:\n+                //    * left.hasOuterParent() == true and right.hasOuterParent() == false\n+                //    * leftField.getFieldId().equals(rightField.getFieldId()) == true\n+                // Both fields would seem to have different hashes but be equal to each other.\n+                // However, this cannot happen because we *require* that both expressions being compared by\n+                // rooted in the same \"query scope\" (i.e., sub-scopes that are local to each other) -- see ScopeAwareKey.equals().\n+                // If both fields have the same field id, by definition they will produce the same result for hasOuterParent().", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcxNDA1MA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449714050", "bodyText": "Consider changing it to:\n  * Keeps mappings of fields and AST expressions to symbols in the current plan within query boundary.", "author": "sopel39", "createdAt": "2020-07-03T22:32:28Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/TranslationMap.java", "diffHunk": "@@ -30,198 +30,191 @@\n import io.prestosql.sql.tree.LambdaExpression;\n import io.prestosql.sql.tree.NodeRef;\n import io.prestosql.sql.tree.Parameter;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.sql.util.AstUtils;\n \n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n-import static io.prestosql.sql.analyzer.TypeSignatureTranslator.toSqlType;\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.sql.planner.ScopeAware.scopeAwareKey;\n+import static java.lang.String.format;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Keeps track of fields and expressions and their mapping to symbols in the current plan\n+ * Keeps mappings of fields and AST expressions to symbols in the current plan.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcxNDUxNw==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r449714517", "bodyText": "where is this specialized method used (apart from projection above)?", "author": "sopel39", "createdAt": "2020-07-03T22:37:14Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanBuilder.java", "diffHunk": "@@ -85,28 +93,40 @@ public TranslationMap getTranslations()\n         return translations;\n     }\n \n+    public Scope getScope()\n+    {\n+        return translations.getScope();\n+    }\n+\n     public PlanBuilder appendProjections(Iterable<Expression> expressions, SymbolAllocator symbolAllocator, PlanNodeIdAllocator idAllocator)\n     {\n-        TranslationMap translations = copyTranslations();\n+        return appendProjections(expressions, symbolAllocator, idAllocator, TranslationMap::rewrite, TranslationMap::canTranslate);\n+    }\n \n+    public <T extends Expression> PlanBuilder appendProjections(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyMTQwNA==", "url": "https://github.com/trinodb/trino/pull/3600#discussion_r451621404", "bodyText": "In planGroupingOperations", "author": "martint", "createdAt": "2020-07-08T15:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcxNDUxNw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "0021100712c13f47721667c40b13d9e41fa162a7", "url": "https://github.com/trinodb/trino/commit/0021100712c13f47721667c40b13d9e41fa162a7", "message": "Reuse scope when analyzing VALUEs expressions", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "edb4b8b12a01d4b5ecad3395b87bc92daa829902", "url": "https://github.com/trinodb/trino/commit/edb4b8b12a01d4b5ecad3395b87bc92daa829902", "message": "Revamp query planner\n\nNow there's a clean separation between expression in AST-land vs IR-land. Expressions\nare no longer rewritten over and over, which complicated maintaining that separation.\n\nTranslationMap is now responsible for Translating expressions from AST-land into IR-land by:\n* Inserting implicit coercions for intermediate expressions\n* Translating FunctionCalls to IR FunctionCalls (i.e., with information about the resolved function)\n* Rewriting sub-expressions based of a mapping of expressions in the current query scope that\n  have already been translated and the symbol from the tip of the current plan that contains their\n  value.\n* Tracking how fields in the current local scope (the FROM, SELECT, etc scopes) map to symbols\n  in the tip of the current plan.\n\nPreviously, the planning of subqueries went through these steps:\n* Plan the subquery. If any references originate from the outer scope, TranslationMap\n  leaves the Identifiers or references untouched. As a result, the temporary\n  subquery plan contains nodes from AST-land.\n* Collect any Identifiers from the temporary subplan and attemt to translate them against the\n  current scope. Any identifiers that are not local to the current scope are left untouched. Since\n  this also implies the current scope is with a subquery, the process repeats as the recursion\n  unwinds.\n* Stitch in the subplan via an Apply or CorrelatedJoin node.\n\nOne of the problems with this approach is that the intermediate temporary plans are invalid, as they\ncontain AST-land expressions. In the new implementation the TranslationMaps form a hierarchy mimicking\nquery scopes. Whenever an identifier cannot be resolved from a local scope, TranslationMap delegates to\nits parent.\n\nMany of the operation are now based on comparing expresions with awareness of what scopes identifiers\nbind to. Two expressions expressions that come from the same query scope are considered equal if all\ntheir references to columns in the query scope are the same.\n\nAs an example, in the following query:\n\n    SELECT f(k) as k\n    FROM (VALUES 1) t(k)\n    ORDER BY k\n\neven though the \"k\" in \"f(k)\" is syntactically equal to the \"k\"\nin the ORDER BY clause, they reference different fields. The former\ncomes from the scope associated with the FROM clause, while the\nlatter comes from the scope associated with the SELECT clause.", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "1676ddc4600dd6e29b8b431e66fca551959dc2bf", "url": "https://github.com/trinodb/trino/commit/1676ddc4600dd6e29b8b431e66fca551959dc2bf", "message": "Simplify argument and field name\n\nlambdaDeclarationToSymbolMap is too verbose and doesn't provide any\nadditional information that the type of the variable doesn't convey.", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "02947c40f0a965c4d380b414c4a1450bdf42548a", "url": "https://github.com/trinodb/trino/commit/02947c40f0a965c4d380b414c4a1450bdf42548a", "message": "Simplify expression", "committedDate": "2020-07-08T16:49:25Z", "type": "commit"}, {"oid": "b6ce459fa25e55290588c3472c258361fe0cc96c", "url": "https://github.com/trinodb/trino/commit/b6ce459fa25e55290588c3472c258361fe0cc96c", "message": "Improve formatting", "committedDate": "2020-07-08T16:49:26Z", "type": "commit"}, {"oid": "b6ce459fa25e55290588c3472c258361fe0cc96c", "url": "https://github.com/trinodb/trino/commit/b6ce459fa25e55290588c3472c258361fe0cc96c", "message": "Improve formatting", "committedDate": "2020-07-08T16:49:26Z", "type": "forcePushed"}]}