{"pr_number": 6167, "pr_title": "Make CachingJdbcClient caches session-aware and fix caches invalidation", "pr_createdAt": "2020-12-01T12:52:39Z", "pr_url": "https://github.com/trinodb/trino/pull/6167", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzI1MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533393251", "bodyText": "This is something we wanted to avoid, to modify SPI for this.", "author": "kokosing", "createdAt": "2020-12-01T13:07:25Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorSession.java", "diffHunk": "@@ -51,4 +52,6 @@ default long getStartTime()\n     Instant getStart();\n \n     <T> T getProperty(String name, Class<T> type);\n+\n+    Set<String> getPropertiesNames();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQwMDk3MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533400971", "bodyText": "Do you have an idea how to inject Session properties to CachingJdbcClient ?", "author": "wendigo", "createdAt": "2020-12-01T13:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxNzQ4OQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533417489", "bodyText": "In the same way they are provided to JdbcConnector, with Set<SessionPropertiesProvider> sessionProperties", "author": "kokosing", "createdAt": "2020-12-01T13:45:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzQ1Ng==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533393456", "bodyText": "It has to be done for all caches, not only columns.", "author": "kokosing", "createdAt": "2020-12-01T13:07:49Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -106,8 +108,8 @@ public boolean schemaExists(ConnectorSession session, String schema)\n         if (tableHandle.getColumns().isPresent()) {\n             return tableHandle.getColumns().get();\n         }\n-        ColumnsCacheKey key = new ColumnsCacheKey(JdbcIdentity.from(session), tableHandle.getSchemaTableName());\n-        return get(columnsCache, key, () -> delegate.getColumns(session, tableHandle));\n+\n+        return get(columnsCache, ColumnsCacheKey.forSessionAndTable(session, tableHandle.getSchemaTableName()), () -> delegate.getColumns(session, tableHandle));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIxNjY3NQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535216675", "bodyText": "It has to be done for all caches, not only columns.\n\n@kokosing do you have a usecase in mind?", "author": "findepi", "createdAt": "2020-12-03T13:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM5MzQ1Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUzMTcyMA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533531720", "bodyText": "Please do not inline key as this approach makes this line do one thing more (build key) in addition to 2 already existing: Get and Load, but which we cannot split.", "author": "ssheikin", "createdAt": "2020-12-01T16:06:09Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -106,8 +116,8 @@ public boolean schemaExists(ConnectorSession session, String schema)\n         if (tableHandle.getColumns().isPresent()) {\n             return tableHandle.getColumns().get();\n         }\n-        ColumnsCacheKey key = new ColumnsCacheKey(JdbcIdentity.from(session), tableHandle.getSchemaTableName());\n-        return get(columnsCache, key, () -> delegate.getColumns(session, tableHandle));\n+\n+        return get(columnsCache, buildColumnsCacheKey(session, tableHandle.getSchemaTableName()), () -> delegate.getColumns(session, tableHandle));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUzNDQyOQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533534429", "bodyText": "Why protected?\nWhat about other build...CacheKey?", "author": "ssheikin", "createdAt": "2020-12-01T16:09:34Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +357,77 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    protected ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUzNjMxMg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533536312", "bodyText": "nit: cacheKey -> key", "author": "ssheikin", "createdAt": "2020-12-01T16:11:59Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +357,77 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    protected ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(session, table);\n+        invalidateTableCache(session, table);\n+    }\n+\n+    private void invalidateTableCache(ConnectorSession session, SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, cacheKey -> cacheKey.schemaName.equals(Optional.of(table.getSchemaName())));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU0NjEyNw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533546127", "bodyText": "maybe inline .map with next line?", "author": "ssheikin", "createdAt": "2020-12-01T16:24:41Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +357,77 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    protected ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(session, table);\n+        invalidateTableCache(session, table);\n+    }\n+\n+    private void invalidateTableCache(ConnectorSession session, SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, cacheKey -> cacheKey.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, cacheKey -> cacheKey.tableName.equals(table));\n     }\n \n     private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(columnsCache, cacheKey -> cacheKey.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .map(property -> Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU5MzM1MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533593350", "bodyText": "It will become less readable", "author": "wendigo", "createdAt": "2020-12-01T17:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU0NjEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1MDcwOA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533550708", "bodyText": "do you really need copyOf?", "author": "ssheikin", "createdAt": "2020-12-01T16:30:50Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +357,77 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    protected ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(session, table);\n+        invalidateTableCache(session, table);\n+    }\n+\n+    private void invalidateTableCache(ConnectorSession session, SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, cacheKey -> cacheKey.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, cacheKey -> cacheKey.tableName.equals(table));\n     }\n \n     private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(columnsCache, cacheKey -> cacheKey.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .map(property -> Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n     }\n \n-    private static final class ColumnsCacheKey\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = ImmutableMap.copyOf(cache.asMap()).keySet().stream()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4ODMxNw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533588317", "bodyText": "Nope. Just being defensive here.", "author": "wendigo", "createdAt": "2020-12-01T17:22:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1MDcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU5MTY0MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533591641", "bodyText": "Could you please remove it? You don't expect 'changes from outside' and everything is under your control.", "author": "ssheikin", "createdAt": "2020-12-01T17:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1MDcwOA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3NTg0NA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533575844", "bodyText": "cachingJdbcClient could not be shared between tests. Please extract it to @BeforeMethod.", "author": "ssheikin", "createdAt": "2020-12-01T17:04:57Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -44,7 +47,7 @@\n     private JdbcClient jdbcClient;\n     private String schema;\n \n-    @BeforeMethod\n+    @BeforeClass", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4ODUwMg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533588502", "bodyText": "Why not?", "author": "wendigo", "createdAt": "2020-12-01T17:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3NTg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU5MzUzNw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533593537", "bodyText": "Ok, I see, It can, but I think it's does not worth to reuse stateful object under test between different methods. wdyt?", "author": "ssheikin", "createdAt": "2020-12-01T17:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3NTg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4NDU0Ng==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533584546", "bodyText": "containsExactlyInAnyOrder", "author": "ssheikin", "createdAt": "2020-12-01T17:17:30Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +108,85 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        JdbcColumnHandle otherColumn = addColumn(cachingJdbcClient, tableHandle, \"other_column\");\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn, otherColumn);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4NTQ3Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533585477", "bodyText": "dropTable(phantomTable);", "author": "ssheikin", "createdAt": "2020-12-01T17:18:57Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +108,85 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4NTk2Mw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533585963", "bodyText": "dropTable(phantomTable);", "author": "ssheikin", "createdAt": "2020-12-01T17:19:38Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +108,85 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        JdbcColumnHandle otherColumn = addColumn(cachingJdbcClient, tableHandle, \"other_column\");\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn, otherColumn);\n+\n+        cachingJdbcClient.dropColumn(SESSION, tableHandle, phantomColumn);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(otherColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4NjA4MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533586081", "bodyText": "dropTable(phantomTable);", "author": "ssheikin", "createdAt": "2020-12-01T17:19:49Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +108,85 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        JdbcColumnHandle otherColumn = addColumn(cachingJdbcClient, tableHandle, \"other_column\");\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn, otherColumn);\n+\n+        cachingJdbcClient.dropColumn(SESSION, tableHandle, phantomColumn);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(otherColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnRename()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.renameColumn(SESSION, tableHandle, phantomColumn, \"new_column_name\");\n+\n+        JdbcColumnHandle newColumnHandle = JdbcColumnHandle.builderFrom(phantomColumn)\n+                .setColumnName(\"NEW_COLUMN_NAME\")\n+                .build();\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(newColumnHandle);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU5NDk0Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533594947", "bodyText": "Won't work here. If I don't drop table via cachingJdbcClient then cache won't be invalidated", "author": "wendigo", "createdAt": "2020-12-01T17:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4NjA4MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533654531", "bodyText": "I was thinking to avoid to even bind CachingJdbcClient in guice, so there would be no question about the way the cache is used in such case. However, I think that might be ok. All I would like to see to to write a unit test where two threads are using disabled CachingJdbcClient and none is waiting for the other.\nPlease either separate that to different commit or mention this in the commit message.", "author": "kokosing", "createdAt": "2020-12-01T19:07:30Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -59,20 +66,31 @@\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;\n+    private final List<PropertyMetadata> sessionPropertiesProviders;\n \n     @Inject\n-    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config)\n+    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config, Set<SessionPropertiesProvider> sessionPropertiesProviders)\n     {\n-        this(delegate, config.getMetadataCacheTtl(), config.isCacheMissing());\n+        this(delegate, sessionPropertiesProviders, config.getMetadataCacheTtl(), config.isCacheMissing());\n     }\n \n-    public CachingJdbcClient(JdbcClient delegate, Duration metadataCachingTtl, boolean cacheMissing)\n+    public CachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> sessionPropertiesProviders, Duration metadataCachingTtl, boolean cacheMissing)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n+        this.sessionPropertiesProviders = requireNonNull(sessionPropertiesProviders, \"sessionPropertiesProviders is null\").stream()\n+            .flatMap(provider -> provider.getSessionProperties().stream())\n+            .collect(toImmutableList());\n+\n         this.cacheMissing = cacheMissing;\n \n         CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder()\n                 .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS);\n+\n+        if (metadataCachingTtl.equals(succinctNanos(0L))) {\n+            // Disables the cache entirely\n+            cacheBuilder.maximumSize(0);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMDg5Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r534000897", "bodyText": "I am concerned about the overhead of Caching client when caching is not enabled (iteration over session properties and stuff).\nI think would be much better to \"unbind\" this on Guice level. (Should go as a seapate commit.:)", "author": "findepi", "createdAt": "2020-12-02T09:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA2NzM4NA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r534067384", "bodyText": "I'm not because I've measured it and it adds the overhead of around 25 nanoseconds (since we are iterating only over catalog properties and retrieving session property is just taking it from a map and decoding (which is basically casting to a given type)", "author": "wendigo", "createdAt": "2020-12-02T10:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MjE3NQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535962175", "bodyText": "It is not only about overhead, but also about correctness. In case there is a bug in caching we don't have a kill switch as we always do \"caching\". However this could go as a separate PR (or postponed until the moment we learn it is an issue).", "author": "kokosing", "createdAt": "2020-12-04T09:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjAyODIyMQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536028221", "bodyText": "I've tested that cache can be disabled entirely (there is always a load)", "author": "wendigo", "createdAt": "2020-12-04T11:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMzM2NQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536113365", "bodyText": "What about two concurrent load for the same key? Is this synchronized?", "author": "kokosing", "createdAt": "2020-12-04T13:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MDUzOQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536140539", "bodyText": "The concurrent hash map implementation built by CacheBuilder. I don't see a reason to test for concurrency here (it should be covered in Guava).", "author": "wendigo", "createdAt": "2020-12-04T14:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NDUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NjY4MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533656680", "bodyText": "new TableHandleCacheKey(session, schemaTableName)? Same for others. Or TableHandleCacheKey.create(session, schemaTableName)", "author": "kokosing", "createdAt": "2020-12-01T19:11:23Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -182,7 +201,7 @@ public boolean isLimitGuaranteed(ConnectorSession session)\n     @Override\n     public Optional<JdbcTableHandle> getTableHandle(ConnectorSession session, SchemaTableName schemaTableName)\n     {\n-        TableHandleCacheKey key = new TableHandleCacheKey(JdbcIdentity.from(session), schemaTableName);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczMjc0Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533732747", "bodyText": "Latter is not possible (I'd need to pass Set)", "author": "wendigo", "createdAt": "2020-12-01T21:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NjY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1Njk3Mw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533656973", "bodyText": "undo rename?", "author": "kokosing", "createdAt": "2020-12-01T19:11:54Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -96,8 +114,8 @@ public boolean schemaExists(ConnectorSession session, String schema)\n     @Override\n     public List<SchemaTableName> getTableNames(ConnectorSession session, Optional<String> schema)\n     {\n-        TableNamesCacheKey key = new TableNamesCacheKey(JdbcIdentity.from(session), schema);\n-        return get(tableNamesCache, key, () -> delegate.getTableNames(session, schema));\n+        TableNamesCacheKey cacheKey = buildTableNamesCacheKey(session, schema);\n+        return get(tableNamesCache, cacheKey, () -> delegate.getTableNames(session, schema));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1ODMwMg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533658302", "bodyText": "what when key.schemaName.isEmpty()? How that can happen?", "author": "kokosing", "createdAt": "2020-12-01T19:14:21Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +366,82 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n+    {\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n+    }\n+\n+    private void invalidateTableCache(SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczMjQ3NA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533732474", "bodyText": "nothing will be invalidated", "author": "wendigo", "createdAt": "2020-12-01T21:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1ODMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1OTY3Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533659677", "bodyText": "use io.prestosql.testing.sql.TestTable#randomTableSuffix", "author": "kokosing", "createdAt": "2020-12-01T19:16:44Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -166,15 +262,25 @@ private JdbcTableHandle getAnyTable(String schema)\n \n     private JdbcColumnHandle addColumn(JdbcTableHandle tableHandle)\n     {\n-        ColumnMetadata columnMetadata = new ColumnMetadata(\"phantom_column\", INTEGER);\n-        jdbcClient.addColumn(SESSION, tableHandle, columnMetadata);\n+        return addColumn(jdbcClient, tableHandle, \"phantom_colum\");\n+    }\n+\n+    private JdbcColumnHandle addColumn(JdbcClient client, JdbcTableHandle tableHandle, String columnName)\n+    {\n+        ColumnMetadata columnMetadata = new ColumnMetadata(columnName, INTEGER);\n+        client.addColumn(SESSION, tableHandle, columnMetadata);\n         return jdbcClient.getColumns(SESSION, tableHandle)\n                 .stream()\n                 .filter(jdbcColumnHandle -> jdbcColumnHandle.getColumnMetadata().equals(columnMetadata))\n                 .findAny()\n                 .orElseThrow();\n     }\n \n+    private static String randomTableName()\n+    {\n+        return \"phantom_table_\" + UUID.randomUUID().toString().replace(\"-\", \"\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2MTcxNw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533661717", "bodyText": "createCachingJdbcClient(CACHE_MISSING, CACHE_ENABLED)? Does it make sense to have cache with cache missing enabled and entire cache disabled? Maybe you could have 3 dedicated methods instead of true, true paremeters? Or instead of cachingEnabled you can pass FOREVER or NEVER. Also we are missing tests for refreshes (REFRESH_AFTER_100_MS).", "author": "kokosing", "createdAt": "2020-12-01T19:20:09Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -49,14 +53,18 @@ public void setUp()\n             throws Exception\n     {\n         database = new TestingDatabase();\n-        cachingJdbcClient = createCachingJdbcClient(true);\n+        cachingJdbcClient = createCachingJdbcClient(true, true);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NDQ3MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533664470", "bodyText": "Can you please have two sessions (two users) cache table for both users and then when table is dropped in Presto both caches got invalidated. Also you can have third user to verify that other table do not get invalidated (optional).\nSame goes to other tests like that.", "author": "kokosing", "createdAt": "2020-12-01T19:24:41Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +127,84 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2NjM4OQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533666389", "bodyText": "Can you please add tests for drop and create for table and schema.", "author": "kokosing", "createdAt": "2020-12-01T19:27:56Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -105,10 +127,84 @@ public void testTableHandleCached()\n         assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEqualTo(cachedTable);\n     }\n \n+    @Test\n+    public void shouldInvalidateTableCachesOnTableDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.dropTable(SESSION, tableHandle);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnDrop()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .isInstanceOf(TableNotFoundException.class);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        JdbcColumnHandle otherColumn = addColumn(cachingJdbcClient, tableHandle, \"other_column\");\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactlyInAnyOrder(phantomColumn, otherColumn);\n+\n+        cachingJdbcClient.dropColumn(SESSION, tableHandle, phantomColumn);\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(otherColumn);\n+\n+        dropTable(phantomTable);\n+    }\n+\n+    @Test\n+    public void shouldInvalidateTableCachesOnColumnRename()\n+    {\n+        SchemaTableName phantomTable = new SchemaTableName(schema, randomTableName());\n+        assertThat(cachingJdbcClient.getTableHandle(SESSION, phantomTable)).isEmpty();\n+\n+        createTable(phantomTable);\n+        JdbcTableHandle tableHandle = jdbcClient.getTableHandle(SESSION, phantomTable).orElseThrow();\n+        JdbcColumnHandle phantomColumn = addColumn(tableHandle);\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(phantomColumn);\n+\n+        cachingJdbcClient.renameColumn(SESSION, tableHandle, phantomColumn, \"new_column_name\");\n+\n+        JdbcColumnHandle newColumnHandle = JdbcColumnHandle.builderFrom(phantomColumn)\n+                .setColumnName(\"NEW_COLUMN_NAME\")\n+                .build();\n+\n+        assertThat(cachingJdbcClient.getColumns(SESSION, tableHandle))\n+                .containsExactly(newColumnHandle);\n+\n+        dropTable(phantomTable);\n+    }", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2Nzc0NQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533667745", "bodyText": "Actually, I don't know why why are invalidating here.", "author": "kokosing", "createdAt": "2020-12-01T19:30:11Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -212,14 +231,14 @@ public JdbcOutputTableHandle beginInsertTable(ConnectorSession session, JdbcTabl\n     public void finishInsertTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.finishInsertTable(session, handle);\n-        invalidateTablesCaches();\n+        invalidateTablesCaches(toTableHandle(handle));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczMTQ1Ng==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533731456", "bodyText": "Idk either. I'll remove that.", "author": "wendigo", "createdAt": "2020-12-01T21:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2Nzc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2OTU2Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533669567", "bodyText": "You also need to handle session properties for schemaNamesCache and tableNamesCache.", "author": "kokosing", "createdAt": "2020-12-01T19:33:17Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -59,20 +66,31 @@\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczMTM0Mw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533731343", "bodyText": "I do.", "author": "wendigo", "createdAt": "2020-12-01T21:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY2OTU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5OTU3MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533699571", "bodyText": "Can it be private?", "author": "ssheikin", "createdAt": "2020-12-01T20:26:22Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +366,82 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n+    {\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n+    }\n+\n+    private void invalidateTableCache(SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        return sessionPropertiesProviders.stream()\n+                .map(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private static Map.Entry<String, Object> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        return Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType()));\n     }\n \n-    private static final class ColumnsCacheKey\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = ImmutableMap.copyOf(cache.asMap()).keySet().stream()\n+                .filter(filterFunction)\n+                .collect(toImmutableSet());\n+\n+        cache.invalidateAll(cacheKeys);\n+    }\n+\n+    private static SchemaTableName toTableHandle(JdbcOutputTableHandle handle)\n+    {\n+        return new SchemaTableName(handle.getSchemaName(), handle.getTableName());\n+    }\n+\n+    static final class ColumnsCacheKey", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwMTUyMg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533701522", "bodyText": "#6167 (comment)", "author": "ssheikin", "createdAt": "2020-12-01T20:29:54Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,39 +366,82 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private ColumnsCacheKey buildColumnsCacheKey(ConnectorSession session, SchemaTableName tableName)\n+    {\n+        return new ColumnsCacheKey(JdbcIdentity.from(session), getSessionProperties(session), tableName);\n+    }\n+\n+    private TableHandleCacheKey buildTableHandleCacheKey(ConnectorSession session, SchemaTableName schemaTableName)\n+    {\n+        return new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);\n+    }\n+\n+    private TableNamesCacheKey buildTableNamesCacheKey(ConnectorSession session, Optional<String> schema)\n+    {\n+        return new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n+    {\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n+    }\n+\n+    private void invalidateTableCache(SchemaTableName table)\n+    {\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        return sessionPropertiesProviders.stream()\n+                .map(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private static Map.Entry<String, Object> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        return Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType()));\n     }\n \n-    private static final class ColumnsCacheKey\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = ImmutableMap.copyOf(cache.asMap()).keySet().stream()\n+                .filter(filterFunction)\n+                .collect(toImmutableSet());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzAwNg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533987006", "bodyText": "this should be metadataCachingTtl.toMillis() == 0, since cache is configured with 1 ms precision\nextract common variable to emphasize this must be the same thing", "author": "findepi", "createdAt": "2020-12-02T08:42:53Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -55,24 +62,35 @@\n     private final JdbcClient delegate;\n     private final boolean cacheMissing;\n \n-    private final Cache<JdbcIdentity, Set<String>> schemaNamesCache;\n+    private final Cache<SchemaNamesCacheKey, Set<String>> schemaNamesCache;\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;\n+    private final List<PropertyMetadata> sessionPropertiesProviders;\n \n     @Inject\n-    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config)\n+    public CachingJdbcClient(@StatsCollecting JdbcClient delegate, BaseJdbcConfig config, Set<SessionPropertiesProvider> sessionPropertiesProviders)\n     {\n-        this(delegate, config.getMetadataCacheTtl(), config.isCacheMissing());\n+        this(delegate, sessionPropertiesProviders, config.getMetadataCacheTtl(), config.isCacheMissing());\n     }\n \n-    public CachingJdbcClient(JdbcClient delegate, Duration metadataCachingTtl, boolean cacheMissing)\n+    public CachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> sessionPropertiesProviders, Duration metadataCachingTtl, boolean cacheMissing)\n     {\n         this.delegate = requireNonNull(delegate, \"delegate is null\");\n+        this.sessionPropertiesProviders = requireNonNull(sessionPropertiesProviders, \"sessionPropertiesProviders is null\").stream()\n+            .flatMap(provider -> provider.getSessionProperties().stream())\n+            .collect(toImmutableList());\n+\n         this.cacheMissing = cacheMissing;\n \n         CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder()\n                 .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS);\n+\n+        if (metadataCachingTtl.equals(succinctNanos(0L))) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA3MDkzMw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535070933", "bodyText": "I see this marked resolved, but i do not see this resolved", "author": "findepi", "createdAt": "2020-12-03T10:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE3NjczOQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535176739", "bodyText": "I haven't pushed yet. Sorry", "author": "wendigo", "createdAt": "2020-12-03T12:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzU5MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533987591", "bodyText": "This seems redundant. I think we can skip session props here for now.", "author": "findepi", "createdAt": "2020-12-02T08:43:53Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -89,14 +107,14 @@ public boolean schemaExists(ConnectorSession session, String schema)\n     @Override\n     public Set<String> getSchemaNames(ConnectorSession session)\n     {\n-        JdbcIdentity key = JdbcIdentity.from(session);\n+        SchemaNamesCacheKey key = new SchemaNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session));\n         return get(schemaNamesCache, key, () -> delegate.getSchemaNames(session));\n     }\n \n     @Override\n     public List<SchemaTableName> getTableNames(ConnectorSession session, Optional<String> schema)\n     {\n-        TableNamesCacheKey key = new TableNamesCacheKey(JdbcIdentity.from(session), schema);\n+        TableNamesCacheKey key = new TableNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schema);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDEyMzk0Mg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r534123942", "bodyText": "This was raised by @kokosing so I've added this for consistency", "author": "wendigo", "createdAt": "2020-12-02T12:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA3MjExNA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535072114", "bodyText": "@kokosing this seems redundant", "author": "findepi", "createdAt": "2020-12-03T10:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzY2NQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533987665", "bodyText": "This seems redundant. I think we can skip session props here for now.", "author": "findepi", "createdAt": "2020-12-02T08:44:01Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -89,14 +107,14 @@ public boolean schemaExists(ConnectorSession session, String schema)\n     @Override\n     public Set<String> getSchemaNames(ConnectorSession session)\n     {\n-        JdbcIdentity key = JdbcIdentity.from(session);\n+        SchemaNamesCacheKey key = new SchemaNamesCacheKey(JdbcIdentity.from(session), getSessionProperties(session));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA2NzY0Mg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r534067642", "bodyText": "This was raised by @kokosing so I've added this for consistency", "author": "wendigo", "createdAt": "2020-12-02T10:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA3MTk0OQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535071949", "bodyText": "@kokosing this seems redundant", "author": "findepi", "createdAt": "2020-12-03T10:31:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk2MTE3Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535961177", "bodyText": "I don't want to uncover this in few months, that this was implemented only for certain places.\nI don't want to remember about this corner case.\nI don't know all custom connectors that are out there.\n\nAssuming  eb3fc50#r534067384, we should not be worried. Notice that we cache only operations that could take much longer.", "author": "kokosing", "createdAt": "2020-12-04T09:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4NzY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4ODI3OA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533988278", "bodyText": "I believe this is redundant, but we should do 00d7b7b instead\n(\"Add safeguards in table handles cache in JDBC\")", "author": "findepi", "createdAt": "2020-12-02T08:45:02Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -182,7 +201,7 @@ public boolean isLimitGuaranteed(ConnectorSession session)\n     @Override\n     public Optional<JdbcTableHandle> getTableHandle(ConnectorSession session, SchemaTableName schemaTableName)\n     {\n-        TableHandleCacheKey key = new TableHandleCacheKey(JdbcIdentity.from(session), schemaTableName);\n+        TableHandleCacheKey key = new TableHandleCacheKey(JdbcIdentity.from(session), getSessionProperties(session), schemaTableName);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTExMg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533989112", "bodyText": "This should be separate commit, as this does not \"fix cache invalidation\" -- the invalidation here was correct.\nIn fact, I think this is an unnecessary complexity and i would rather not have this change.\n(same for other table/schema level invalidations)", "author": "findepi", "createdAt": "2020-12-02T08:46:16Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -199,7 +218,7 @@ public boolean isLimitGuaranteed(ConnectorSession session)\n     public void commitCreateTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.commitCreateTable(session, handle);\n-        invalidateTablesCaches();\n+        invalidateTablesCaches(toTableHandle(handle));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTc0MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533989740", "bodyText": "Can session property have a null value?", "author": "findepi", "createdAt": "2020-12-02T08:47:20Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA2ODg4OA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r534068888", "bodyText": "it turns out that yes - in Oracle connector. I've fixed that.", "author": "wendigo", "createdAt": "2020-12-02T10:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0NzcyOA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536147728", "bodyText": "@wendigo if null is possible then toImmutableMap will fail. Will you fix it?", "author": "ssheikin", "createdAt": "2020-12-04T14:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMwOTk2Mg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536309962", "bodyText": "It is fixed, already. See NULL_MARKER", "author": "kokosing", "createdAt": "2020-12-04T18:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0NTA2MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536345060", "bodyText": "I've added a singleton object that marks that value is null", "author": "wendigo", "createdAt": "2020-12-04T19:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTk0OA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533989948", "bodyText": "Why?", "author": "findepi", "createdAt": "2020-12-02T08:47:39Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Stream<Map.Entry<String, Object>> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        try {\n+            return Stream.of(Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())));\n+        }\n+        catch (PrestoException ignored) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA2OTQ5MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r534069490", "bodyText": "That's a good question. Some of the set up methods in tests throws with \"Unrecognized session property\" when copying from TPCH to target catalog.", "author": "wendigo", "createdAt": "2020-12-02T10:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA3NzIyMg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535077222", "bodyText": "This sounds like a bug and can mask other bugs. What was the exact failure?", "author": "findepi", "createdAt": "2020-12-03T10:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk4OTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MDA0MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533990040", "bodyText": "Just make this return Object", "author": "findepi", "createdAt": "2020-12-02T08:47:50Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Stream<Map.Entry<String, Object>> getSessionProperty(ConnectorSession session, PropertyMetadata property)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA3MzcyOA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535073728", "bodyText": "I see this marked resolved, but i do not see this resolved. Did you want to reply here why not doing this?", "author": "findepi", "createdAt": "2020-12-03T10:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MDA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE3NzE5MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r535177191", "bodyText": "Not pushed yet", "author": "wendigo", "createdAt": "2020-12-03T12:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MDA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MDY1OQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533990659", "bodyText": "revert \"protected\", the class is final", "author": "findepi", "createdAt": "2020-12-02T08:48:50Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Stream<Map.Entry<String, Object>> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        try {\n+            return Stream.of(Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())));\n+        }\n+        catch (PrestoException ignored) {\n+            return Stream.empty();\n+        }\n+    }\n+\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = cache.asMap().keySet().stream()\n+                .filter(filterFunction)\n+                .collect(toImmutableSet());\n+\n+        cache.invalidateAll(cacheKeys);\n+    }\n+\n+    private static SchemaTableName toTableHandle(JdbcOutputTableHandle handle)\n+    {\n+        return new SchemaTableName(handle.getSchemaName(), handle.getTableName());\n     }\n \n     private static final class ColumnsCacheKey\n     {\n         private final JdbcIdentity identity;\n+        private final Map<String, Object> sessionProperties;\n         private final SchemaTableName table;\n \n-        private ColumnsCacheKey(JdbcIdentity identity, SchemaTableName table)\n+        protected ColumnsCacheKey(JdbcIdentity identity, Map<String, Object> sessionProperties, SchemaTableName table)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MDg2Mw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533990863", "bodyText": "make defensive copy to ensure class immutability\n(same for others)", "author": "findepi", "createdAt": "2020-12-02T08:49:08Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -351,34 +370,67 @@ private void invalidateSchemasCache()\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTablesCaches(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateColumnsCache(table);\n+        invalidateTableCache(table);\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateTableCache(SchemaTableName table)\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(table.getSchemaName())));\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(table));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n+    }\n+\n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionPropertiesProviders.stream()\n+                .flatMap(property -> getSessionProperty(session, property))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Stream<Map.Entry<String, Object>> getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        try {\n+            return Stream.of(Map.entry(property.getName(), session.getProperty(property.getName(), property.getJavaType())));\n+        }\n+        catch (PrestoException ignored) {\n+            return Stream.empty();\n+        }\n+    }\n+\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)\n+    {\n+        Set<T> cacheKeys = cache.asMap().keySet().stream()\n+                .filter(filterFunction)\n+                .collect(toImmutableSet());\n+\n+        cache.invalidateAll(cacheKeys);\n+    }\n+\n+    private static SchemaTableName toTableHandle(JdbcOutputTableHandle handle)\n+    {\n+        return new SchemaTableName(handle.getSchemaName(), handle.getTableName());\n     }\n \n     private static final class ColumnsCacheKey\n     {\n         private final JdbcIdentity identity;\n+        private final Map<String, Object> sessionProperties;\n         private final SchemaTableName table;\n \n-        private ColumnsCacheKey(JdbcIdentity identity, SchemaTableName table)\n+        protected ColumnsCacheKey(JdbcIdentity identity, Map<String, Object> sessionProperties, SchemaTableName table)\n         {\n             this.identity = requireNonNull(identity, \"identity is null\");\n+            this.sessionProperties = requireNonNull(sessionProperties, \"sessionProperties is null\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5MjI2NA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533992264", "bodyText": "i believe JDBC connectors do not support transactions, so \"transaction\" is actually per query cache.\nAs such, there is no way to change session properties during a transaction, so you can avoid overheader and pass empty set here (with appropriate explanatory comment in the code)", "author": "findepi", "createdAt": "2020-12-02T08:51:23Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/TransactionCachingJdbcClient.java", "diffHunk": "@@ -31,9 +32,9 @@\n {\n     private final Cache<TableStatisticsCacheKey, TableStatistics> statisticsCache;\n \n-    public TransactionCachingJdbcClient(JdbcClient delegate, Duration cachingTtl)\n+    public TransactionCachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> sessionPropertiesProviders, Duration cachingTtl)\n     {\n-        super(delegate, cachingTtl, true);\n+        super(delegate, sessionPropertiesProviders, cachingTtl, true);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzk5Mjc0Mg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r533992742", "bodyText": "ZERO", "author": "findepi", "createdAt": "2020-12-02T08:52:12Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -15,48 +15,72 @@\n \n import com.google.common.collect.ImmutableSet;\n import io.airlift.units.Duration;\n+import io.prestosql.plugin.jdbc.jmx.JdbcApiStats;\n+import io.prestosql.plugin.jdbc.jmx.JdbcClientStats;\n+import io.prestosql.plugin.jdbc.jmx.StatisticsAwareJdbcClient;\n import io.prestosql.spi.connector.ColumnMetadata;\n import io.prestosql.spi.connector.ConnectorSession;\n import io.prestosql.spi.connector.ConnectorTableMetadata;\n import io.prestosql.spi.connector.SchemaTableName;\n+import io.prestosql.spi.connector.TableNotFoundException;\n import org.testng.annotations.AfterMethod;\n import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.Test;\n \n import java.lang.reflect.Method;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.function.Function;\n \n import static io.prestosql.spi.testing.InterfaceTestUtils.assertAllMethodsOverridden;\n import static io.prestosql.spi.type.IntegerType.INTEGER;\n import static io.prestosql.testing.TestingConnectorSession.SESSION;\n+import static io.prestosql.testing.sql.TestTable.randomTableSuffix;\n import static java.util.Collections.emptyList;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n @Test(singleThreaded = true)\n public class TestCachingJdbcClient\n {\n     private static final Duration FOREVER = Duration.succinctDuration(1, DAYS);\n+    private static final Duration NEVER = Duration.succinctDuration(0, DAYS);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwNjI2Mg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536106262", "bodyText": "This field is not used in this commit, so I would squash this commit with the commit that uses that.", "author": "kokosing", "createdAt": "2020-12-04T13:40:00Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -59,16 +61,21 @@\n     private final Cache<TableNamesCacheKey, List<SchemaTableName>> tableNamesCache;\n     private final Cache<TableHandleCacheKey, Optional<JdbcTableHandle>> tableHandleCache;\n     private final Cache<ColumnsCacheKey, List<JdbcColumnHandle>> columnsCache;\n+    private final List<PropertyMetadata<?>> sessionProperties;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEwODEzNg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536108136", "bodyText": "comment is not needed", "author": "kokosing", "createdAt": "2020-12-04T13:42:59Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -365,19 +390,30 @@ private void invalidateTablesCaches()\n         tableNamesCache.invalidateAll();\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    private void invalidateColumnsCache(SchemaTableName table)\n+    {\n+        // Invalidate all caches independently of session", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMDI3OQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536110279", "bodyText": "Maybe you can add a method JdbcOutputTableHandle#getSchemaTableName()", "author": "kokosing", "createdAt": "2020-12-04T13:46:28Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -401,9 +402,15 @@ private void invalidateColumnsCache(SchemaTableName table)\n         Set<T> cacheKeys = cache.asMap().keySet().stream()\n                 .filter(filterFunction)\n                 .collect(toImmutableSet());\n+\n         cache.invalidateAll(cacheKeys);\n     }\n \n+    private static SchemaTableName toJdbcTableHandle(JdbcOutputTableHandle handle)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMDg0NA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536110844", "bodyText": "I would squash that with the commit that is using this.", "author": "kokosing", "createdAt": "2020-12-04T13:47:21Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -397,6 +401,12 @@ private void invalidateColumnsCache(SchemaTableName table)\n         invalidateCache(columnsCache, key -> key.table.equals(table));\n     }\n \n+    @VisibleForTesting\n+    CacheStats getColumnsCacheStats()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMTc5MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536111791", "bodyText": "Is there a case where miss != load?", "author": "kokosing", "createdAt": "2020-12-04T13:48:54Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +166,93 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 0, 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 2, 0, 2);\n+\n+        // Drop first column and invalidate cache for all sessions\n+        cachingJdbcClient.dropColumn(firstSession, table, phantomColumn);\n+        assertThat(jdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+\n+        // Load columns into cache in both sessions scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Read columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+    }\n+\n+    @Test\n+    public void testColumnsCacheInvalidationOnTableDrop()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle firstTable = createTable(new SchemaTableName(schema, \"first_table\"));\n+        JdbcTableHandle secondTable = createTable(new SchemaTableName(schema, \"second_table\"));\n+\n+        JdbcColumnHandle firstColumn = addColumn(firstTable, \"first_column\");\n+        JdbcColumnHandle secondColumn = addColumn(secondTable, \"second_column\");\n+\n+        // Load columns for both tables into cache and assert cache loads (sessions x tables)\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Load columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+\n+        // Drop columns and caches for first table\n+        cachingJdbcClient.dropTable(secondSession, firstTable);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(firstSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(secondSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 6, 2, 6);\n+\n+        // Check if second table is still cached\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 6, 4, 6);\n+\n+        cachingJdbcClient.dropTable(secondSession, secondTable);\n+    }\n+\n+    private void assertCacheLoadsHitsAndMisses(CacheStats stats, int expectedLoad, int expectedHit, int expectedMiss)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjEzMzQzMQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536133431", "bodyText": "Not. Would you like me to add that?", "author": "wendigo", "createdAt": "2020-12-04T14:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMwNjc1Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536306757", "bodyText": "I was thinking about removing one of these parameters.", "author": "kokosing", "createdAt": "2020-12-04T18:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1Nzc1MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r540357751", "bodyText": "@wendigo why didn't you want to remove one of those parameters?", "author": "ssheikin", "createdAt": "2020-12-10T17:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMTc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjExMjczMQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536112731", "bodyText": "test also rename and column add (it could be in the same test)", "author": "kokosing", "createdAt": "2020-12-04T13:50:21Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +166,93 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 0, 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 2, 0, 2);\n+\n+        // Drop first column and invalidate cache for all sessions\n+        cachingJdbcClient.dropColumn(firstSession, table, phantomColumn);\n+        assertThat(jdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+\n+        // Load columns into cache in both sessions scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Read columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+    }\n+\n+    @Test\n+    public void testColumnsCacheInvalidationOnTableDrop()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle firstTable = createTable(new SchemaTableName(schema, \"first_table\"));\n+        JdbcTableHandle secondTable = createTable(new SchemaTableName(schema, \"second_table\"));\n+\n+        JdbcColumnHandle firstColumn = addColumn(firstTable, \"first_column\");\n+        JdbcColumnHandle secondColumn = addColumn(secondTable, \"second_column\");\n+\n+        // Load columns for both tables into cache and assert cache loads (sessions x tables)\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Load columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+\n+        // Drop columns and caches for first table", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMjE5MQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536312191", "bodyText": "no comment is needed", "author": "kokosing", "createdAt": "2020-12-04T18:58:55Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -212,7 +212,9 @@ public boolean isLimitGuaranteed(ConnectorSession session)\n     public void commitCreateTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.commitCreateTable(session, handle);\n-        invalidateTablesCaches();\n+\n+        // Invalidate cache for table as it could be cached as missing", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMjQxMg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536312412", "bodyText": "I don't see a value in these comments.", "author": "kokosing", "createdAt": "2020-12-04T18:59:21Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -313,14 +314,19 @@ public void renameColumn(ConnectorSession session, JdbcTableHandle handle, JdbcC\n     public void renameTable(ConnectorSession session, JdbcTableHandle handle, SchemaTableName newTableName)\n     {\n         delegate.renameTable(session, handle, newTableName);\n-        invalidateTablesCaches();\n+\n+        // Remove cache for old table name\n+        invalidateTableCaches(handle.getSchemaTableName());\n+\n+        // We need to remove cache for newTableName as it could be cached as missing", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0NTQ0OQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536345449", "bodyText": "Okay. I'll drop that", "author": "wendigo", "createdAt": "2020-12-04T19:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMjg1NQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536312855", "bodyText": "This one line could go as separate commit. It is easy to not notice this, in this commit. It is logically different change at least to me. WDYT?", "author": "kokosing", "createdAt": "2020-12-04T19:00:07Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -225,14 +227,13 @@ public JdbcOutputTableHandle beginInsertTable(ConnectorSession session, JdbcTabl\n     public void finishInsertTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.finishInsertTable(session, handle);\n-        invalidateTablesCaches();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0NTM1Mg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r536345352", "bodyText": "Sure. I'll extract this", "author": "wendigo", "createdAt": "2020-12-04T19:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxMjg1NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMzODIzNQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537338235", "bodyText": "nit: maybe oneliner with Optional.of().orElse()?", "author": "ssheikin", "createdAt": "2020-12-07T09:05:37Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,6 +359,25 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionProperties.stream()\n+                .map(property -> Map.entry(property.getName(), getSessionProperty(session, property)))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Object getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        Object value = session.getProperty(property.getName(), property.getJavaType());\n+\n+        // Map.entry doesn't allow null keys and values\n+        if (value == null) {\n+            value = NULL_MARKER;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzMzOTQ4Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537339487", "bodyText": "nit: it always used as NULL_PROPERTY", "author": "ssheikin", "createdAt": "2020-12-07T09:07:36Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -47,28 +50,38 @@\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Throwables.throwIfInstanceOf;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n import static java.util.Objects.requireNonNull;\n \n public class CachingJdbcClient\n         implements JdbcClient\n {\n+    private static final Object NULL_MARKER = new Object();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM0NDA4NQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537344085", "bodyText": "nit: static import", "author": "ssheikin", "createdAt": "2020-12-07T09:14:43Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -85,7 +87,9 @@ public CachingJdbcClient(JdbcClient delegate, Set<SessionPropertiesProvider> ses\n         this.cacheMissing = cacheMissing;\n \n         CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder()\n-                .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS);\n+                .expireAfterWrite(metadataCachingTtl.toMillis(), TimeUnit.MILLISECONDS)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5MjM3Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537392377", "bodyText": "I didn't change that line so I'll leave it here.", "author": "wendigo", "createdAt": "2020-12-07T10:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM0NDA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NDUwMA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537354500", "bodyText": "testColumnsCachedPerSession ?", "author": "ssheikin", "createdAt": "2020-12-07T09:30:00Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +170,100 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NTYzOA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537355638", "bodyText": "maybe add check here that something is cached before invalidation?", "author": "ssheikin", "createdAt": "2020-12-07T09:31:43Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +170,100 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 0, 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 2, 0, 2);\n+\n+        // Drop first column and invalidate cache for all sessions", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5Mzc3OA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537393778", "bodyText": "Done", "author": "wendigo", "createdAt": "2020-12-07T10:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM1NTYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM2MTgwMQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537361801", "bodyText": "please consider extracting variables Loads, Hits, Misses and only incrementing here\nassertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), loads, hits += 2, misses);\nso no need to search for previous state and one can concentrate only on state change.", "author": "ssheikin", "createdAt": "2020-12-07T09:40:36Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -150,8 +170,100 @@ public void testColumnsCached()\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column into cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 1, 1);\n+\n+        // Read column from cache\n+        assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 2, 1);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedBySession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 1, 0, 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 2, 0, 2);\n+\n+        // Drop first column and invalidate cache for all sessions\n+        cachingJdbcClient.dropColumn(firstSession, table, phantomColumn);\n+        assertThat(jdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+\n+        // Load columns into cache in both sessions scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Read columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+    }\n+\n+    @Test\n+    public void testColumnsCacheInvalidationOnTableDrop()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle firstTable = createTable(new SchemaTableName(schema, \"first_table\"));\n+        JdbcTableHandle secondTable = createTable(new SchemaTableName(schema, \"second_table\"));\n+\n+        JdbcColumnHandle firstColumn = addColumn(firstTable, \"first_column\");\n+        JdbcColumnHandle secondColumn = addColumn(secondTable, \"second_column\");\n+\n+        // Load columns for both tables into cache and assert cache loads (sessions x tables)\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 0, 4);\n+\n+        // Load columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 4, 2, 4);\n+\n+        // Rename column\n+        cachingJdbcClient.renameColumn(firstSession, firstTable, firstColumn, \"another_column\");\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable))\n+                .doesNotContain(firstColumn)\n+                .containsAll(jdbcClient.getColumns(SESSION, firstTable));\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 5, 2, 5);\n+\n+        // Drop columns and caches for first table\n+        cachingJdbcClient.dropTable(secondSession, firstTable);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(firstSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertThatThrownBy(() -> cachingJdbcClient.getColumns(secondSession, firstTable)).isInstanceOf(TableNotFoundException.class);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 7, 2, 7);\n+\n+        // Check if second table is still cached\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), 7, 4, 7);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM5MDE4OA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537390188", "bodyText": "These values are so small that I don't see values in using variables here", "author": "wendigo", "createdAt": "2020-12-07T10:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM2MTgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQwMzA4Nw==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537403087", "bodyText": "After a short consideration, I gave it a shot and it looks better. Thanks!", "author": "wendigo", "createdAt": "2020-12-07T10:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM2MTgwMQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzMjY2MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537432660", "bodyText": "0 -> expectedHit", "author": "ssheikin", "createdAt": "2020-12-07T11:28:25Z", "path": "presto-base-jdbc/src/test/java/io/prestosql/plugin/jdbc/TestCachingJdbcClient.java", "diffHunk": "@@ -145,13 +174,149 @@ private void dropTable(SchemaTableName phantomTable)\n     public void testColumnsCached()\n     {\n         JdbcTableHandle table = getAnyTable(schema);\n-\n         JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        int expectedLoad = 0, expectedHit = 0, expectedMiss = 0;\n+\n+        // Read column into cache\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 1, expectedHit, expectedMiss += 1);\n+\n         jdbcClient.dropColumn(SESSION, table, phantomColumn);\n \n+        // Load column from cache\n         assertThat(jdbcClient.getColumns(SESSION, table)).doesNotContain(phantomColumn);\n         assertThat(cachingJdbcClient.getColumns(SESSION, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad, expectedHit += 1, expectedMiss);\n+    }\n+\n+    @Test\n+    public void testColumnsCachedPerSession()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle table = getAnyTable(schema);\n+        JdbcColumnHandle phantomColumn = addColumn(table);\n+\n+        int expectedLoad = 0, expectedHit = 0, expectedMiss = 0;\n+\n+        // Load columns in first session scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 1, expectedHit, expectedMiss += 1);\n+\n+        // Load columns in second session scope\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 1, expectedHit, expectedMiss += 1);\n+\n+        // Check that columns are cached\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).contains(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad, expectedHit += 1, expectedMiss);\n+\n+        // Drop first column and invalidate cache for all sessions\n+        cachingJdbcClient.dropColumn(firstSession, table, phantomColumn);\n+        assertThat(jdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+\n+        // Load columns into cache in both sessions scope\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 2, expectedHit, expectedMiss += 2);\n+\n+        // Read columns from cache\n+        assertThat(cachingJdbcClient.getColumns(firstSession, table)).doesNotContain(phantomColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, table)).doesNotContain(phantomColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad, expectedHit + 2, expectedMiss);\n+    }\n+\n+    @Test\n+    public void testColumnsCacheInvalidationOnTableDrop()\n+    {\n+        ConnectorSession firstSession = createSession(\"first\");\n+        ConnectorSession secondSession = createSession(\"second\");\n+        JdbcTableHandle firstTable = createTable(new SchemaTableName(schema, \"first_table\"));\n+        JdbcTableHandle secondTable = createTable(new SchemaTableName(schema, \"second_table\"));\n+\n+        JdbcColumnHandle firstColumn = addColumn(firstTable, \"first_column\");\n+        JdbcColumnHandle secondColumn = addColumn(secondTable, \"second_column\");\n+\n+        int expectedLoad = 0, expectedHit = 0, expectedMiss = 0;\n+\n+        // Load columns for both tables into cache and assert cache loads (sessions x tables)\n+        assertThat(cachingJdbcClient.getColumns(firstSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(firstSession, secondTable)).contains(secondColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, firstTable)).contains(firstColumn);\n+        assertThat(cachingJdbcClient.getColumns(secondSession, secondTable)).contains(secondColumn);\n+        assertCacheLoadsHitsAndMisses(cachingJdbcClient.getColumnsCacheStats(), expectedLoad += 4, 0, expectedMiss += 4);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNDg4Mg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537434882", "bodyText": "com.google.common.base.MoreObjects#firstNonNull", "author": "findepi", "createdAt": "2020-12-07T11:31:59Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,6 +359,19 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionProperties.stream()\n+                .map(property -> Map.entry(property.getName(), getSessionProperty(session, property)))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Object getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        return Optional.ofNullable(session.getProperty(property.getName(), property.getJavaType()))\n+                .orElse(NULL_MARKER);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNTIyNg==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537435226", "bodyText": "Document why in a code comment", "author": "findepi", "createdAt": "2020-12-07T11:32:28Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/TransactionCachingJdbcClient.java", "diffHunk": "@@ -33,7 +34,7 @@\n \n     public TransactionCachingJdbcClient(JdbcClient delegate, Duration cachingTtl)\n     {\n-        super(delegate, cachingTtl, true);\n+        super(delegate, Set.of(), cachingTtl, true);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNjA2OA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537436068", "bodyText": "Inline. or make helper method in the cache class.\nOnce this method is added here, it will be much more expensive to remove it from here.", "author": "findepi", "createdAt": "2020-12-07T11:33:59Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/JdbcOutputTableHandle.java", "diffHunk": "@@ -110,6 +111,11 @@ public String getTemporaryTableName()\n         return temporaryTableName;\n     }\n \n+    public SchemaTableName getSchemaTableName()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0OTIzNA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537449234", "bodyText": "@kokosing asked me to add this method here (was static before). I'm confused here.", "author": "wendigo", "createdAt": "2020-12-07T11:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNjA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNjY3MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537436670", "bodyText": "Drop the change. The insert may change the state of the table, including its obvervable metadata.", "author": "findepi", "createdAt": "2020-12-07T11:35:00Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -225,7 +225,6 @@ public JdbcOutputTableHandle beginInsertTable(ConnectorSession session, JdbcTabl\n     public void finishInsertTable(ConnectorSession session, JdbcOutputTableHandle handle)\n     {\n         delegate.finishInsertTable(session, handle);\n-        invalidateTableCaches(handle.getSchemaTableName());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzOTA1Ng==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r537439056", "bodyText": "Could you please share a simple example?", "author": "ssheikin", "createdAt": "2020-12-07T11:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNjY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI2ODc2MA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r539268760", "bodyText": "Please extract this to separate pull request, so we can discuss this independently.", "author": "kokosing", "createdAt": "2020-12-09T12:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQzNjY3MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "1f07289404d04132fb43da0af40087cf349e5f85", "url": "https://github.com/trinodb/trino/commit/1f07289404d04132fb43da0af40087cf349e5f85", "message": "Make session properties part of ColumnsCacheKey", "committedDate": "2020-12-09T12:36:42Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "1076951f7fd5d632268ece0925e3a2449a30111d", "url": "https://github.com/trinodb/trino/commit/1076951f7fd5d632268ece0925e3a2449a30111d", "message": "Invalidate caches for given SchemaTableName only", "committedDate": "2020-12-09T13:59:06Z", "type": "commit"}, {"oid": "efcacb03347deeb828cfc20ec429284f561eed24", "url": "https://github.com/trinodb/trino/commit/efcacb03347deeb828cfc20ec429284f561eed24", "message": "Verify that columns are loaded and cached", "committedDate": "2020-12-09T13:59:06Z", "type": "commit"}, {"oid": "e0dba7073e9ee6de27c62064e6f9e5306c641a99", "url": "https://github.com/trinodb/trino/commit/e0dba7073e9ee6de27c62064e6f9e5306c641a99", "message": "Disable cache entirely when ttl is 0ms", "committedDate": "2020-12-09T13:59:07Z", "type": "commit"}, {"oid": "e0dba7073e9ee6de27c62064e6f9e5306c641a99", "url": "https://github.com/trinodb/trino/commit/e0dba7073e9ee6de27c62064e6f9e5306c641a99", "message": "Disable cache entirely when ttl is 0ms", "committedDate": "2020-12-09T13:59:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MTM3NA==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r540351374", "bodyText": "PropertyMetadata<?>", "author": "ssheikin", "createdAt": "2020-12-10T17:18:25Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,31 +371,60 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionProperties.stream()\n+                .map(property -> Map.entry(property.getName(), getSessionProperty(session, property)))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Object getSessionProperty(ConnectorSession session, PropertyMetadata property)", "originalCommit": "e0dba7073e9ee6de27c62064e6f9e5306c641a99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MTkxOQ==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r540351919", "bodyText": "import java.util.function.Predicate;", "author": "ssheikin", "createdAt": "2020-12-10T17:19:13Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -13,8 +13,12 @@\n  */\n package io.prestosql.plugin.jdbc;\n \n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Predicate;", "originalCommit": "e0dba7073e9ee6de27c62064e6f9e5306c641a99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1NTQ1Ng==", "url": "https://github.com/trinodb/trino/pull/6167#discussion_r540355456", "bodyText": "Key is not @nullable. Please change com.google.common.base.Predicate -> java.util.function.Predicate", "author": "ssheikin", "createdAt": "2020-12-10T17:24:03Z", "path": "presto-base-jdbc/src/main/java/io/prestosql/plugin/jdbc/CachingJdbcClient.java", "diffHunk": "@@ -346,31 +371,60 @@ public String quoted(RemoteTableName remoteTableName)\n         return delegate.getTableScanRedirection(session, tableHandle);\n     }\n \n+    private Map<String, Object> getSessionProperties(ConnectorSession session)\n+    {\n+        return sessionProperties.stream()\n+                .map(property -> Map.entry(property.getName(), getSessionProperty(session, property)))\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Object getSessionProperty(ConnectorSession session, PropertyMetadata property)\n+    {\n+        return firstNonNull(session.getProperty(property.getName(), property.getJavaType()), NULL_MARKER);\n+    }\n+\n     private void invalidateSchemasCache()\n     {\n         schemaNamesCache.invalidateAll();\n     }\n \n-    private void invalidateTablesCaches()\n+    private void invalidateTableCaches(SchemaTableName schemaTableName)\n+    {\n+        invalidateColumnsCache(schemaTableName);\n+        invalidateCache(tableHandleCache, key -> key.tableName.equals(schemaTableName));\n+        invalidateCache(tableNamesCache, key -> key.schemaName.equals(Optional.of(schemaTableName.getSchemaName())));\n+    }\n+\n+    private void invalidateColumnsCache(SchemaTableName table)\n     {\n-        columnsCache.invalidateAll();\n-        tableHandleCache.invalidateAll();\n-        tableNamesCache.invalidateAll();\n+        invalidateCache(columnsCache, key -> key.table.equals(table));\n     }\n \n-    private void invalidateColumnsCache(ConnectorSession session, SchemaTableName table)\n+    @VisibleForTesting\n+    CacheStats getColumnsCacheStats()\n     {\n-        columnsCache.invalidate(new ColumnsCacheKey(JdbcIdentity.from(session), table));\n+        return columnsCache.stats();\n+    }\n+\n+    private static <T, V> void invalidateCache(Cache<T, V> cache, Predicate<T> filterFunction)", "originalCommit": "e0dba7073e9ee6de27c62064e6f9e5306c641a99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}