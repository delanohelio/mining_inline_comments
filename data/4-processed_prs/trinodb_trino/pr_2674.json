{"pr_number": 2674, "pr_title": "Allow dynamic filtering with comparison operators", "pr_createdAt": "2020-01-29T22:43:08Z", "pr_url": "https://github.com/trinodb/trino/pull/2674", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDg3MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436214870", "bodyText": "Avoid abbreviations.", "author": "martint", "createdAt": "2020-06-06T00:25:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -97,12 +104,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n+\n+        Expression opExpression = arguments.get(1);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTU3Ng==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349576", "bodyText": "Fixed.", "author": "rzeyde-varada", "createdAt": "2020-06-07T10:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDk2OQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436214969", "bodyText": "Avoid abbreviations: op -> operator", "author": "martint", "createdAt": "2020-06-06T00:26:25Z", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -187,35 +210,35 @@ private Function() {}\n \n         @TypeParameter(\"T\")\n         @SqlType(BOOLEAN)\n-        public static boolean dynamicFilter(@SqlType(VARCHAR) Slice id, @SqlType(\"T\") Block input)\n+        public static boolean dynamicFilter(@SqlType(\"T\") Block input, @SqlType(VARCHAR) Slice op, @SqlType(VARCHAR) Slice id)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTU4MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349580", "bodyText": "Fixed.", "author": "rzeyde-varada", "createdAt": "2020-06-07T10:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTMwNg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436215306", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        createDynamicFilter(buildSource, node, context, partitionCount).ifPresent(\n          \n          \n            \n                                filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));\n          \n          \n            \n                        createDynamicFilter(buildSource, node, context, partitionCount)\n          \n          \n            \n                            .ifPresent(filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));", "author": "martint", "createdAt": "2020-06-06T00:29:17Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -1812,14 +1812,19 @@ private PhysicalOperation createNestedLoopJoin(JoinNode node, LocalExecutionPlan\n                     node.getId(),\n                     nestedLoopJoinBridgeManager);\n \n-            checkArgument(buildContext.getDriverInstanceCount().orElse(1) == 1, \"Expected local execution to not be parallel\");\n+            int partitionCount = buildContext.getDriverInstanceCount().orElse(1);\n+            checkArgument(partitionCount == 1, \"Expected local execution to not be parallel\");\n+\n+            ImmutableList.Builder<OperatorFactory> factoriesBuilder = ImmutableList.builder();\n+            factoriesBuilder.addAll(buildSource.getOperatorFactories());\n+            createDynamicFilter(buildSource, node, context, partitionCount).ifPresent(\n+                    filter -> factoriesBuilder.add(createDynamicFilterSourceOperatorFactory(filter, node, buildSource, buildContext)));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTYwMA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349600", "bodyText": "Fixed.", "author": "rzeyde-varada", "createdAt": "2020-06-07T10:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTQzNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436215437", "bodyText": "Remove final", "author": "martint", "createdAt": "2020-06-06T00:30:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -470,13 +480,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {\n-                    ComparisonExpression equality = (ComparisonExpression) conjunct;\n-\n-                    boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(equality.getLeft()));\n-                    Expression leftExpression = (alignedComparison) ? equality.getLeft() : equality.getRight();\n-                    Expression rightExpression = (alignedComparison) ? equality.getRight() : equality.getLeft();\n+                final boolean isComparison = joinComparisonExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTYwOQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349609", "bodyText": "Fixed.", "author": "rzeyde-varada", "createdAt": "2020-06-07T10:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTcyOA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436215728", "bodyText": "Remove final", "author": "martint", "createdAt": "2020-06-06T00:32:36Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -470,13 +480,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {\n-                    ComparisonExpression equality = (ComparisonExpression) conjunct;\n-\n-                    boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(equality.getLeft()));\n-                    Expression leftExpression = (alignedComparison) ? equality.getLeft() : equality.getRight();\n-                    Expression rightExpression = (alignedComparison) ? equality.getRight() : equality.getLeft();\n+                final boolean isComparison = joinComparisonExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols());\n+                if (!isComparison) {\n+                    joinFilterBuilder.add(conjunct);\n+                    continue;\n+                }\n+                ComparisonExpression comparison = (ComparisonExpression) conjunct;\n+                final boolean isEquality = comparison.getOperator() == ComparisonExpression.Operator.EQUAL;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM0OTYyNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r436349627", "bodyText": "Fixed.", "author": "rzeyde-varada", "createdAt": "2020-06-07T10:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTcyOA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjczMTUxMQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492731511", "bodyText": "nit: opString -> operatorExpressionString", "author": "raunaqmorarka", "createdAt": "2020-09-22T13:26:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -99,12 +107,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n \n-        Expression firstArgument = arguments.get(0);\n-        checkArgument(firstArgument instanceof StringLiteral, \"firstArgument is expected to be an instance of StringLiteral: %s\", firstArgument.getClass().getSimpleName());\n-        String id = ((StringLiteral) firstArgument).getValue();\n-        return Optional.of(new Descriptor(new DynamicFilterId(id), arguments.get(1)));\n+        Expression operatorExpression = arguments.get(1);\n+        checkArgument(operatorExpression instanceof StringLiteral, \"op is expected to be an instance of StringLiteral: %s\", operatorExpression.getClass().getSimpleName());\n+        String opString = ((StringLiteral) operatorExpression).getValue();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjczMjg2Nw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492732867", "bodyText": "nit: op -> operatorExpression", "author": "raunaqmorarka", "createdAt": "2020-09-22T13:28:08Z", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -99,12 +107,19 @@ public static boolean isDynamicFilter(Expression expression)\n         }\n \n         List<Expression> arguments = functionCall.getArguments();\n-        checkArgument(arguments.size() == 2, \"invalid arguments count: %s\", arguments.size());\n+        checkArgument(arguments.size() == 3, \"invalid arguments count: %s\", arguments.size());\n+\n+        Expression probeSymbol = arguments.get(0);\n \n-        Expression firstArgument = arguments.get(0);\n-        checkArgument(firstArgument instanceof StringLiteral, \"firstArgument is expected to be an instance of StringLiteral: %s\", firstArgument.getClass().getSimpleName());\n-        String id = ((StringLiteral) firstArgument).getValue();\n-        return Optional.of(new Descriptor(new DynamicFilterId(id), arguments.get(1)));\n+        Expression operatorExpression = arguments.get(1);\n+        checkArgument(operatorExpression instanceof StringLiteral, \"op is expected to be an instance of StringLiteral: %s\", operatorExpression.getClass().getSimpleName());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc0MTg0MQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492741841", "bodyText": "Could this be toImmutableListMultimap  instead ? Are duplicate Descriptor possible here ?", "author": "raunaqmorarka", "createdAt": "2020-09-22T13:40:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ3NzM0Ng==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r493477346", "bodyText": "IIUC, it may only happen if the same DF function appears twice in the filter expression:\nhttps://github.com/prestosql/presto/blob/8c6901c0c94593c9e5f1d65ea471697248f44dc0/presto-main/src/main/java/io/prestosql/sql/planner/LocalExecutionPlanner.java#L1370\nI think that this should not happen - so I changed the code to use toImmutableListMultimap.", "author": "rzeyde-varada", "createdAt": "2020-09-23T11:29:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc0MTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1MDY1MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492750650", "bodyText": "Can we ever reach here for a non-orderable type or does the planner disallow queries which contain comparison operator on a non-orderable type ?", "author": "raunaqmorarka", "createdAt": "2020-09-22T13:51:20Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ2NDcyMA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r493464720", "bodyText": "IIUC, it should fail during the analysis phase - I tested the following:\nCREATE TABLE t0 (k0 color, v0 real);\nCREATE TABLE t1 (k1 color, v1 real);\nSELECT v0, v1 FROM t0, t1 WHERE k0 < k1;\nAnd it failed with:\nCaused by: io.prestosql.spi.PrestoException: line 1:37: Cannot apply operator: color < color\n\tat io.prestosql.sql.analyzer.SemanticExceptions.semanticException(SemanticExceptions.java:48)\n\tat io.prestosql.sql.analyzer.SemanticExceptions.semanticException(SemanticExceptions.java:43)\n\tat io.prestosql.sql.analyzer.ExpressionAnalyzer$Visitor.getOperator(ExpressionAnalyzer.java:1479)", "author": "rzeyde-varada", "createdAt": "2020-09-23T11:15:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1MDY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NDI4OQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492754289", "bodyText": "Do we need to get an ordered range here or can we use  domain.getValues().getRanges().getSpan() , then get low or high value from that ?", "author": "raunaqmorarka", "createdAt": "2020-09-22T13:55:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NzgzMw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492757833", "bodyText": "I think these functions could be moved to Range.java", "author": "raunaqmorarka", "createdAt": "2020-09-22T14:00:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NTE0Ng==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r493455146", "bodyText": "Refactored according to #2674 (comment).", "author": "rzeyde-varada", "createdAt": "2020-09-23T11:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1NzgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1ODQxNA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492758414", "bodyText": "This could move to Domain.java", "author": "raunaqmorarka", "createdAt": "2020-09-22T14:00:47Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ1NDQ1Nw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r493454457", "bodyText": "I agree, but then ComparisonExpression.Operator needs to be exposed to presto-spi (which contains Domain.java) - so I will leave it here for now.", "author": "rzeyde-varada", "createdAt": "2020-09-23T11:03:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1ODQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxMjQ4Ng==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495712486", "bodyText": "Could we move it into ExpressionUtils then ? I think we'll want to use this function eventually from DynamicFilterService as well, so it'll be good to pull it out of this class.", "author": "raunaqmorarka", "createdAt": "2020-09-28T06:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1ODQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzExNDQ5Mg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507114492", "bodyText": "I moved it to DynamicFilters.Descriptor#applyComparison... is it OK?", "author": "rzeyde-varada", "createdAt": "2020-10-18T11:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc1ODQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2MzAxNg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492763016", "bodyText": "Could we simply return domain ?", "author": "raunaqmorarka", "createdAt": "2020-09-22T14:06:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2NjYzNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492766637", "bodyText": "Could use Marker.above", "author": "raunaqmorarka", "createdAt": "2020-09-22T14:11:19Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)\n+    {\n+        return new Range(\n+                Marker.lowerUnbounded(high.getType()),\n+                new Marker(high.getType(), high.getValueBlock(), Marker.Bound.BELOW));\n+    }\n+\n+    private static Range lessThanOrEqualRange(Marker high)\n+    {\n+        return new Range(Marker.lowerUnbounded(high.getType()), high);\n+    }\n+\n+    private static Range greaterThanRange(Marker low)\n+    {\n+        return new Range(\n+                new Marker(low.getType(), low.getValueBlock(), Marker.Bound.ABOVE),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2NzA0Nw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492767047", "bodyText": "Could use Marker.below", "author": "raunaqmorarka", "createdAt": "2020-09-22T14:11:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)\n+    {\n+        return new Range(\n+                Marker.lowerUnbounded(high.getType()),\n+                new Marker(high.getType(), high.getValueBlock(), Marker.Bound.BELOW));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjc2ODIyNQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r492768225", "bodyText": "Could we use Marker#getValue to get Object and then just reuse the existing functions in Range.java ?", "author": "raunaqmorarka", "createdAt": "2020-09-22T14:13:19Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -79,33 +84,91 @@ public void collectDynamicFilterDomains(Map<DynamicFilterId, Domain> dynamicFilt\n     // Called during TableScan planning (no need to be synchronized as local planning is single threaded)\n     public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbol, ColumnHandle> columnsMap)\n     {\n-        Multimap<DynamicFilterId, Symbol> symbolsMap = descriptors.stream()\n-                .collect(toImmutableSetMultimap(Descriptor::getId, descriptor -> Symbol.from(descriptor.getInput())));\n+        Multimap<DynamicFilterId, Descriptor> descriptorMap = descriptors.stream()\n+                .collect(toImmutableSetMultimap(Descriptor::getId, Function.identity()));\n \n         // Iterate over dynamic filters that are collected (correspond to one of the futures), and required for filtering (correspond to one of the descriptors).\n         // It is possible that some dynamic filters are collected in a different stage - and will not available here.\n         // It is also possible that not all local dynamic filters are needed for this specific table scan.\n-        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = symbolsMap.keySet().stream()\n+        List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures = descriptorMap.keySet().stream()\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, ComparisonExpression.Operator> operatorsMap = descriptorMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    descriptor -> {\n+                                        Symbol probeSymbol = Symbol.from(descriptor.getInput());\n+                                        return requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol));\n+                                    },\n+                                    Descriptor::getOperator));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    operatorsMap.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> applyComparison(entry.getValue(), domain)))),\n                             directExecutor());\n                 })\n                 .collect(toImmutableList());\n         return new TableSpecificDynamicFilter(predicateFutures);\n     }\n \n+    private static Domain applyComparison(ComparisonExpression.Operator operator, Domain domain)\n+    {\n+        switch (operator) {\n+            case EQUAL:\n+                return Domain.create(domain.getValues(), false);\n+            case LESS_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case LESS_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = lessThanOrEqualRange(ranges.get(ranges.size() - 1).getHigh());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            case GREATER_THAN_OR_EQUAL: {\n+                List<Range> ranges = domain.getValues().getRanges().getOrderedRanges();\n+                Range result = greaterThanOrEqualRange(ranges.get(0).getLow());\n+                return Domain.create(ValueSet.ofRanges(result), false);\n+            }\n+            default:\n+                throw new IllegalArgumentException(\"Unsupported dynamic filtering comparison operator: \" + operator);\n+        }\n+    }\n+\n+    private static Range lessThanRange(Marker high)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxMzMyNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495713327", "bodyText": "nit: rename to dynamicFilteringSupportedExpressions", "author": "raunaqmorarka", "createdAt": "2020-09-28T06:26:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -99,6 +103,13 @@\n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> supportedComparisonOperators = ImmutableSet.of(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495714060", "bodyText": "Could you paste an example of what the explain output looks like after this change ?", "author": "raunaqmorarka", "createdAt": "2020-09-28T06:28:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -820,14 +820,14 @@ private Void visitScanFilterAndProjectInfo(\n         private String printDynamicFilters(Collection<DynamicFilters.Descriptor> filters)\n         {\n             return filters.stream()\n-                    .map(filter -> filter.getId() + \" -> \" + filter.getInput())\n+                    .map(filter -> filter.getInput() + \" \" + filter.getOperator().getValue() + \" #\" + filter.getId())", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUxNjY3NQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r497516675", "bodyText": "EXPLAIN SELECT l.comment FROM  lineitem l, part p \n  WHERE p.partkey > l.partkey AND p.comment = 'onic deposits'\nresults in:\nFragment 0 [SINGLE]\n    Output layout: [comment]\n    Output partitioning: SINGLE []\n    Stage Execution Strategy: UNGROUPED_EXECUTION\n    Output[comment]\n    \u2502   Layout: [comment:varchar(44)]\n    \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n    \u2514\u2500 RemoteSource[1]\n           Layout: [comment:varchar(44)]\n\nFragment 1 [SOURCE]\n    Output layout: [comment]\n\n    Output partitioning: SINGLE []\n    Stage Execution Strategy: UNGROUPED_EXECUTION\n    FilterProject[filterPredicate = (\"partkey\" < \"partkey_0\")]\n    \u2502   Layout: [comment:varchar(44)]\n    \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}/{rows: ? (?), cpu: ?, memory: ?, network: ?}\n    \u2514\u2500 CrossJoin\n       \u2502   Layout: [partkey:bigint, comment:varchar(44), partkey_0:bigint]\n       \u2502   Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?}\n       \u2502   Distribution: REPLICATED\n       \u2502   dynamicFilterAssignments = {partkey_0 -> #df_350}\n       \u251c\u2500 ScanFilter[table = memory:2, grouped = false, filterPredicate = true, dynamicFilter = {\"partkey\" < #df_350}]\n       \u2502      Layout: [partkey:bigint, comment:varchar(44)]\n       \u2502      Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: 0B}/{rows: ? (?), cpu: ?, memory: 0B, network: 0B}\n       \u2502      partkey := 1\n       \u2502      comment := 15\n       \u2514\u2500 LocalExchange[SINGLE] ()\n          \u2502   Layout: [partkey_0:bigint]\n          \u2502   Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: ?}\n          \u2514\u2500 RemoteSource[2]\n                 Layout: [partkey_0:bigint]\n\nFragment 2 [SOURCE]\n    Output layout: [partkey_0]\n    Output partitioning: BROADCAST []\n    Stage Execution Strategy: UNGROUPED_EXECUTION\n    ScanFilterProject[table = memory:3, grouped = false, filterPredicate = (\"comment_1\" = CAST('onic deposits' AS varchar(23)))]\n        Layout: [partkey_0:bigint]\n        Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: 0B}/{rows: ? (?), cpu: ?, memory: 0B, network: 0B}/{rows: ? (?), cpu: ?, memory: 0B, network: 0B}\n        comment_1 := 8\n        partkey_0 := 0", "author": "rzeyde-varada", "createdAt": "2020-09-30T13:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MjIzMg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507682232", "bodyText": "this requires doc update", "author": "sopel39", "createdAt": "2020-10-19T11:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4ODQ1MQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r508588451", "bodyText": "Updated presto-docs/src/main/sphinx/admin/dynamic-filtering.rst.", "author": "rzeyde-varada", "createdAt": "2020-10-20T15:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNDA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNTAzNg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495715036", "bodyText": "You should be able to match for dynamic filter as well using something like ImmutableMap.of(\"O_COMMENT\", \"L_COMMENT\")", "author": "raunaqmorarka", "createdAt": "2020-09-28T06:31:24Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -94,6 +94,37 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNTc5MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495715790", "bodyText": "Is CAST missing in the query ?", "author": "raunaqmorarka", "createdAt": "2020-09-28T06:33:33Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -94,6 +94,37 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM orders o, lineitem l WHERE o.comment < l.comment\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUwODA3MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r497508070", "bodyText": "I think that it is added (implicitly) since l.comment and o.comment have different sizes.", "author": "rzeyde-varada", "createdAt": "2020-09-30T13:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNTc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNjQ4NA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495716484", "bodyText": "We could add the parameter to match dynamic filters as well here", "author": "raunaqmorarka", "createdAt": "2020-09-28T06:35:21Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,7 +298,9 @@ public void testDistinctLimitOverInequalityJoin()\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                                 join(INNER, ImmutableList.of(), Optional.empty(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNjYyMQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495716621", "bodyText": "Same as above", "author": "raunaqmorarka", "createdAt": "2020-09-28T06:35:47Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -341,7 +343,9 @@ public void testInnerInequalityJoinNoEquiJoinConjuncts()\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                 join(INNER, ImmutableList.of(), Optional.empty(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcxNjgyMg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r495716822", "bodyText": "Same as above", "author": "raunaqmorarka", "createdAt": "2020-09-28T06:36:18Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -369,7 +373,9 @@ public void testLeftConvertedToInnerInequalityJoinNoEquiJoinConjuncts()\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                 join(INNER, ImmutableList.of(), Optional.empty(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNjUxNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505636517", "bodyText": "We should have support for ineq joins in DynamicFilterService too. If it's added in next commit, lets remove this one.", "author": "sopel39", "createdAt": "2020-10-15T15:28:27Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -420,7 +420,12 @@ private void collectDynamicFilters(StageId stageId, Optional<Set<DynamicFilterId\n     private static Set<DynamicFilterId> getDynamicFiltersProducedInPlanNode(PlanNode planNode)\n     {\n         if (planNode instanceof JoinNode) {\n-            return ((JoinNode) planNode).getDynamicFilters().keySet();\n+            JoinNode joinNode = (JoinNode) planNode;\n+            if (joinNode.isCrossJoin()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA5MDUxOQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507090519", "bodyText": "Added DynamicFilterService support.", "author": "rzeyde-varada", "createdAt": "2020-10-18T10:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNjUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzc4Nw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505637787", "bodyText": "why we need this?", "author": "sopel39", "createdAt": "2020-10-15T15:30:09Z", "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -594,7 +594,7 @@ private static PlanFragment createPlan(DynamicFilterId dynamicFilterId, Partitio\n                         INNER,\n                         filterNode,\n                         remote,\n-                        ImmutableList.of(),\n+                        ImmutableList.of(new JoinNode.EquiJoinClause(symbol, buildSymbol)),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA4OTY1MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507089650", "bodyText": "Removed.", "author": "rzeyde-varada", "createdAt": "2020-10-18T10:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzkwNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505637907", "bodyText": "why we need this?", "author": "sopel39", "createdAt": "2020-10-15T15:30:19Z", "path": "presto-main/src/test/java/io/prestosql/execution/scheduler/TestSourcePartitionedScheduler.java", "diffHunk": "@@ -571,7 +571,7 @@ private static StageExecutionPlan createPlan(ConnectorSplitSource splitSource)\n                         INNER,\n                         filterNode,\n                         remote,\n-                        ImmutableList.of(),\n+                        ImmutableList.of(new JoinNode.EquiJoinClause(symbol, buildSymbol)),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA4OTYzMg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507089632", "bodyText": "Removed.", "author": "rzeyde-varada", "createdAt": "2020-10-18T10:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNzkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MDkzMA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505640930", "bodyText": "please add support to DynamicFilterService too", "author": "sopel39", "createdAt": "2020-10-15T15:34:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -20,8 +20,11 @@\n import io.prestosql.spi.connector.ColumnHandle;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA5MDYxNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507090617", "bodyText": "Added DynamicFilterService support.", "author": "rzeyde-varada", "createdAt": "2020-10-18T10:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MDkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzExMzQxMg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507113412", "bodyText": "Just to be sure - I had to add the following line to support cross-joins:\nhttps://github.com/prestosql/presto/blob/6323d03a2ed123a77f5e62415f5d3b8a7c7c7552/presto-main/src/main/java/io/prestosql/operator/JoinUtils.java#L71\nIs it OK?", "author": "rzeyde-varada", "createdAt": "2020-10-18T11:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MDkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MTkxNQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r505641915", "bodyText": "static import EQUAL", "author": "sopel39", "createdAt": "2020-10-15T15:35:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -46,21 +47,28 @@\n {\n     private DynamicFilters() {}\n \n-    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, SymbolReference input)\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, SymbolReference input, ComparisonExpression.Operator operator)\n     {\n-        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input);\n+        return createDynamicFilterExpression(metadata, id, inputType, (Expression) input, operator);\n     }\n \n     @VisibleForTesting\n-    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input)\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input, ComparisonExpression.Operator operator)\n     {\n         return new FunctionCallBuilder(metadata)\n                 .setName(QualifiedName.of(Function.NAME))\n-                .addArgument(VarcharType.VARCHAR, new StringLiteral(id.toString()))\n                 .addArgument(inputType, input)\n+                .addArgument(VarcharType.VARCHAR, new StringLiteral(operator.toString()))\n+                .addArgument(VarcharType.VARCHAR, new StringLiteral(id.toString()))\n                 .build();\n     }\n \n+    @VisibleForTesting\n+    public static Expression createDynamicFilterExpression(Metadata metadata, DynamicFilterId id, Type inputType, Expression input)\n+    {\n+        return createDynamicFilterExpression(metadata, id, inputType, input, ComparisonExpression.Operator.EQUAL);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA5MDU2Mg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507090562", "bodyText": "Fixed.", "author": "rzeyde-varada", "createdAt": "2020-10-18T10:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MTkxNQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYwNzg5NA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507607894", "bodyText": "Add a comment that it's used in cross join case", "author": "sopel39", "createdAt": "2020-10-19T09:36:07Z", "path": "presto-main/src/main/java/io/prestosql/operator/JoinUtils.java", "diffHunk": "@@ -67,7 +67,8 @@ public static boolean isBuildSideReplicated(PlanNode node)\n             return PlanNodeSearcher.searchFrom(((JoinNode) node).getRight())\n                     .recurseOnlyWhen(\n                             MorePredicates.<PlanNode>isInstanceOfAny(ProjectNode.class)\n-                                    .or(JoinUtils::isLocalRepartitionExchange))\n+                                    .or(JoinUtils::isLocalRepartitionExchange)\n+                                    .or(JoinUtils::isLocalGatherExchange))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3Njg3NA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507676874", "bodyText": "static static import (if possible)", "author": "sopel39", "createdAt": "2020-10-19T11:37:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -100,6 +103,13 @@\n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> dynamicFilteringSupportedExpressions = ImmutableSet.of(\n+            ComparisonExpression.Operator.EQUAL,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NzAxNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507677017", "bodyText": "rename to:\nDYNAMIC_FILTERING_SUPPORTED_EXPRESSIONS", "author": "sopel39", "createdAt": "2020-10-19T11:37:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -100,6 +103,13 @@\n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> dynamicFilteringSupportedExpressions = ImmutableSet.of(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MDkwNg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507680906", "bodyText": "please pass newJoinFilter instead", "author": "sopel39", "createdAt": "2020-10-19T11:45:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -501,21 +518,30 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n                         rightProjections.put(rightSymbol, rightExpression);\n                     }\n \n-                    equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+                    ComparisonExpression filter = new ComparisonExpression(operator, leftSymbol.toSymbolReference(), rightSymbol.toSymbolReference());\n+                    dynamicFilteringClauses.add(filter);\n+                    if (isEquality) {\n+                        equiJoinClauses.add(new JoinNode.EquiJoinClause(leftSymbol, rightSymbol));\n+                    }\n+                    else {\n+                        joinFilterBuilder.add(filter);\n+                    }\n                 }\n                 else {\n+                    // Inequality join predicate && dynamic filtering is disabled.\n                     joinFilterBuilder.add(conjunct);\n                 }\n             }\n \n-            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, equiJoinClauses, session, idAllocator);\n+            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, dynamicFilteringClauses.build(), session, idAllocator);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4NzIyMQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r508587221", "bodyText": "I think that newJoinFilter would contain only the inequality predicates - but createDynamicFilters needs also the equi-join predicates. For example, consider the following query:\nSELECT * FROM L, R WHERE L.x = R.x AND L.y < R.y;\nIn this case, createDynamicFilters needs L.x = R.x AND L.y < R.y but newJoinFilter will contain only L.y < R.y, IIUC.", "author": "rzeyde-varada", "createdAt": "2020-10-20T15:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MDkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEwNDQ4MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r509104480", "bodyText": "Added both equiJoinClauses and newJoinFilter.", "author": "rzeyde-varada", "createdAt": "2020-10-21T08:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MDkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MTE2NA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507681164", "bodyText": "let's encapsulate non-equi DF code in createDynamicFilters method. Then these code changes are not needed", "author": "sopel39", "createdAt": "2020-10-19T11:45:39Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -483,13 +493,20 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             // Create new projections for the new join clauses\n             List<JoinNode.EquiJoinClause> equiJoinClauses = new ArrayList<>();\n             ImmutableList.Builder<Expression> joinFilterBuilder = ImmutableList.builder();\n+            ImmutableList.Builder<ComparisonExpression> dynamicFilteringClauses = ImmutableList.builder();\n             for (Expression conjunct : extractConjuncts(newJoinPredicate)) {\n-                if (joinEqualityExpression(conjunct, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols())) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEwNDEwOQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r509104109", "bodyText": "Sounds good - I've changed createDynamicFilters signature to accept both equiJoinClauses and joinFilterBuilder.build().", "author": "rzeyde-varada", "createdAt": "2020-10-21T08:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MTE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4Mjc5MQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507682791", "bodyText": "Please extend matcher so that we can match ineq type too", "author": "sopel39", "createdAt": "2020-10-19T11:48:45Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -142,6 +142,38 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey < l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY < L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableMap.of(\"O_ORDERKEY\", \"L_ORDERKEY\"),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4NzgzNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r508587837", "bodyText": "Added DynamicFilterPattern to match inequality DFs.", "author": "rzeyde-varada", "createdAt": "2020-10-20T15:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4Mjc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY4MzIzMA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r507683230", "bodyText": "add a test case with non cross join too", "author": "sopel39", "createdAt": "2020-10-19T11:49:32Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -142,6 +142,38 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwMjYwMg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512002602", "bodyText": "* Planner support for dynamic filtering for a given join operation in Presto.\n  Currently inner and right joins with equality join conditions and semi-joins with IN conditions are supported.\n\nthis section needs to be updated", "author": "sopel39", "createdAt": "2020-10-26T14:28:46Z", "path": "presto-docs/src/main/sphinx/admin/dynamic-filtering.rst", "diffHunk": "@@ -87,7 +87,7 @@ down to the connector in the query plan.\n            \u2502   Estimates: {rows: 0 (0B), cpu: 0, memory: 0B, network: 0B}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNjQ2Nw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512006467", "bodyText": "please extract span to separate variable before switch", "author": "sopel39", "createdAt": "2020-10-26T14:33:31Z", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -197,8 +232,42 @@ public String toString()\n             return toStringHelper(this)\n                     .add(\"id\", id)\n                     .add(\"input\", input)\n+                    .add(\"operator\", operator)\n                     .toString();\n         }\n+\n+        public Domain applyComparison(Domain domain)\n+        {\n+            if (domain.isNone() || domain.isAll()) {\n+                return domain;\n+            }\n+            switch (operator) {\n+                case EQUAL:\n+                    return domain;\n+                case LESS_THAN: {\n+                    Range span = domain.getValues().getRanges().getSpan();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMTE5Mg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512021192", "bodyText": "static import DynamicFilterPattern", "author": "sopel39", "createdAt": "2020-10-26T14:51:43Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyMzE2OA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512023168", "bodyText": "use that pattern in other added tests too", "author": "sopel39", "createdAt": "2020-10-26T14:54:12Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey = l.orderkey AND o.totalprice < l.extendedprice\",\n+                anyTree(join(\n+                        INNER,\n+                        ImmutableList.of(equiJoinClause(\"O_ORDERKEY\", \"L_ORDERKEY\")),\n+                        Optional.of(\"O_TOTALPRICE < L_EXTENDEDPRICE\"),\n+                        Optional.of(ImmutableList.of(\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", EQUAL, \"L_ORDERKEY\"),\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_TOTALPRICE\", LESS_THAN, \"L_EXTENDEDPRICE\"))),\n+                        Optional.empty(),\n+                        Optional.empty(),\n+                        project(\n+                                filter(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNDA4Mw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512024083", "bodyText": "this case is uniteresting. Cast on probe side (not build) is what we want to test", "author": "sopel39", "createdAt": "2020-10-26T14:55:22Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -135,12 +143,66 @@ public void testEmptyJoinCriteria()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(),\n-                                ImmutableMap.of(),\n+                                ImmutableList.of(),\n                                 tableScan(\"orders\"),\n                                 exchange(\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey = l.orderkey AND o.totalprice < l.extendedprice\",\n+                anyTree(join(\n+                        INNER,\n+                        ImmutableList.of(equiJoinClause(\"O_ORDERKEY\", \"L_ORDERKEY\")),\n+                        Optional.of(\"O_TOTALPRICE < L_EXTENDEDPRICE\"),\n+                        Optional.of(ImmutableList.of(\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", EQUAL, \"L_ORDERKEY\"),\n+                                new PlanMatchPattern.DynamicFilterPattern(\"O_TOTALPRICE\", LESS_THAN, \"L_EXTENDEDPRICE\"))),\n+                        Optional.empty(),\n+                        Optional.empty(),\n+                        project(\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\", \"O_TOTALPRICE\", \"totalprice\")))),\n+                        exchange(\n+                                project(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\", \"L_EXTENDEDPRICE\", \"extendedprice\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM orders o, lineitem l WHERE o.comment < l.comment\",\n+                anyTree(filter(\"O_COMMENT < EXPR\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                node(\n+                                        FilterNode.class,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_COMMENT\", \"comment\"))),\n+                                exchange(\n+                                        project(ImmutableMap.of(\"EXPR\", expression(\"CAST(L_COMMENT AS varchar(79))\")),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4NjIwOA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r513386208", "bodyText": "This test can be useful to make sure we don't add projections to the plan, following #2674 (comment) and #2674 (comment). WDYT?", "author": "rzeyde-varada", "createdAt": "2020-10-28T11:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNDA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNTIyNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512025227", "bodyText": "please keep previous simplified method too", "author": "sopel39", "createdAt": "2020-10-26T14:56:44Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern\n+    {\n+        private final SymbolAlias probe;\n+        private final ComparisonExpression.Operator operator;\n+        private final SymbolAlias build;\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+            this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+        }\n+\n+        public ComparisonExpression getComparisonExpression(SymbolAliases aliases)\n+        {\n+            return new ComparisonExpression(\n+                    operator,\n+                    probe.toSymbol(aliases).toSymbolReference(),\n+                    build.toSymbol(aliases).toSymbolReference());\n+        }\n+    }\n+\n+    public static DynamicFilterPattern equiDynamicFilter(String probeAlias, String buildAlias)\n+    {\n+        return new DynamicFilterPattern(probeAlias, ComparisonExpression.Operator.EQUAL, buildAlias);\n+    }\n+\n     public static PlanMatchPattern join(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNTk1OA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512025958", "bodyText": "move class below usage (above GroupingSetDescriptor)", "author": "sopel39", "createdAt": "2020-10-26T14:57:42Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzMzMxMQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512033311", "bodyText": "make it package private", "author": "sopel39", "createdAt": "2020-10-26T15:06:49Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern\n+    {\n+        private final SymbolAlias probe;\n+        private final ComparisonExpression.Operator operator;\n+        private final SymbolAlias build;\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+            this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+        }\n+\n+        public ComparisonExpression getComparisonExpression(SymbolAliases aliases)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNDczMw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512034733", "bodyText": "please keep previous join constructor too, this would prevent all these (unrelated) changes", "author": "sopel39", "createdAt": "2020-10-26T15:08:37Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -347,7 +415,7 @@ public void testNestedDynamicFiltersRemoval()\n                         join(\n                                 INNER,\n                                 ImmutableList.of(equiJoinClause(\"ORDERS_CK\", \"ORDERS_CK6\")),\n-                                ImmutableMap.of(\"ORDERS_CK\", \"ORDERS_CK6\"),\n+                                ImmutableList.of(equiDynamicFilter(\"ORDERS_CK\", \"ORDERS_CK6\")),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNTAyOQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512035029", "bodyText": "static import GREATER_THAN and others", "author": "sopel39", "createdAt": "2020-10-26T15:09:01Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -182,6 +185,44 @@ public void testMultipleProbeColumns()\n         assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(column1, domain, column2, domain)));\n     }\n \n+    @Test\n+    public void testMultipleComparisons()\n+    {\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector(metadata, typeOperators, session);\n+        DynamicFilterId filterId = new DynamicFilterId(\"filter\");\n+        collector.register(ImmutableSet.of(filterId));\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+\n+        // Same build-side column being compared to multiple probe-side columns.\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"symbol1\", BIGINT);\n+        Symbol symbol2 = symbolAllocator.newSymbol(\"symbol2\", BIGINT);\n+        ColumnHandle column1 = new TestingColumnHandle(\"column1\");\n+        ColumnHandle column2 = new TestingColumnHandle(\"column2\");\n+        DynamicFilter filter = collector.createDynamicFilter(\n+                ImmutableList.of(\n+                        new DynamicFilters.Descriptor(filterId, symbol1.toSymbolReference(), Operator.GREATER_THAN),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzOTk3NA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512039974", "bodyText": "static import DynamicFilterPattern", "author": "sopel39", "createdAt": "2020-10-26T15:15:12Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,8 +300,16 @@ public void testDistinctLimitOverInequalityJoin()\n                         node(DistinctLimitNode.class,\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                                join(INNER,\n+                                                        ImmutableList.of(),\n+                                                        Optional.empty(),\n+                                                        Optional.of(ImmutableList.of(\n+                                                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MTA2OA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512041068", "bodyText": "nit: static import EQUAL", "author": "sopel39", "createdAt": "2020-10-26T15:16:39Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -462,10 +463,37 @@ public static PlanMatchPattern join(\n         return join(joinType, expectedEquiCriteria, expectedFilter, Optional.empty(), expectedDistributionType, expectedSpillable, left, right);\n     }\n \n+    public static class DynamicFilterPattern\n+    {\n+        private final SymbolAlias probe;\n+        private final ComparisonExpression.Operator operator;\n+        private final SymbolAlias build;\n+\n+        public DynamicFilterPattern(String probeAlias, ComparisonExpression.Operator operator, String buildAlias)\n+        {\n+            this.probe = new SymbolAlias(requireNonNull(probeAlias, \"probeAlias is null\"));\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+            this.build = new SymbolAlias(requireNonNull(buildAlias, \"buildAlias is null\"));\n+        }\n+\n+        public ComparisonExpression getComparisonExpression(SymbolAliases aliases)\n+        {\n+            return new ComparisonExpression(\n+                    operator,\n+                    probe.toSymbol(aliases).toSymbolReference(),\n+                    build.toSymbol(aliases).toSymbolReference());\n+        }\n+    }\n+\n+    public static DynamicFilterPattern equiDynamicFilter(String probeAlias, String buildAlias)\n+    {\n+        return new DynamicFilterPattern(probeAlias, ComparisonExpression.Operator.EQUAL, buildAlias);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MTU5NA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512041594", "bodyText": "I think you can use join without these two Optional.empty() args", "author": "sopel39", "createdAt": "2020-10-26T15:17:22Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,8 +300,16 @@ public void testDistinctLimitOverInequalityJoin()\n                         node(DistinctLimitNode.class,\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                                join(INNER,\n+                                                        ImmutableList.of(),\n+                                                        Optional.empty(),\n+                                                        Optional.of(ImmutableList.of(\n+                                                                new PlanMatchPattern.DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                                        Optional.empty(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MjMwNw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512042307", "bodyText": "keep node(FilterNode.class, in same line, e.g:\nnode(FilterNode.class,\n  tableScal(\"orders\")\n...\n\nwe decided to use this schema for plan matching as it's easier to read.", "author": "sopel39", "createdAt": "2020-10-26T15:18:15Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -370,7 +392,9 @@ public void testLeftConvertedToInnerInequalityJoinNoEquiJoinConjuncts()\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n                                 join(INNER, ImmutableList.of(), Optional.empty(),\n-                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                        node(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MzkyMw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512043923", "bodyText": "keep this simplified method too", "author": "sopel39", "createdAt": "2020-10-26T15:20:11Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -1133,12 +1218,12 @@ private Object nullInputEvaluator(Collection<Symbol> nullSymbols, Expression exp\n                     .optimize(symbol -> nullSymbols.contains(symbol) ? null : symbol.toSymbolReference());\n         }\n \n-        private boolean joinEqualityExpression(Expression expression, Collection<Symbol> leftSymbols, Collection<Symbol> rightSymbols)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NTYzMA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512045630", "bodyText": "getJoinFilterClauses is not needed. We should always add joinFilterBuilder.build() expressions (regardless of DF).", "author": "sopel39", "createdAt": "2020-10-26T15:22:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -524,7 +540,7 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n                 rightSource = context.rewrite(node.getRight(), rightPredicate);\n             }\n \n-            Optional<Expression> newJoinFilter = Optional.of(combineConjuncts(metadata, joinFilterBuilder.build()));\n+            Optional<Expression> newJoinFilter = Optional.of(combineConjuncts(metadata, dynamicFiltersResult.getJoinFilterClauses()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NjM3OA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512046378", "bodyText": "rename to DYNAMIC_FILTERING_SUPPORTED_COMPARISONS", "author": "sopel39", "createdAt": "2020-10-26T15:23:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -95,11 +99,23 @@\n import static io.prestosql.sql.planner.plan.JoinNode.Type.LEFT;\n import static io.prestosql.sql.planner.plan.JoinNode.Type.RIGHT;\n import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.EQUAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.GREATER_THAN;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.GREATER_THAN_OR_EQUAL;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN_OR_EQUAL;\n import static java.util.Objects.requireNonNull;\n \n public class PredicatePushDown\n         implements PlanOptimizer\n {\n+    private static final Set<ComparisonExpression.Operator> DYNAMIC_FILTERING_SUPPORTED_OPERATORS = ImmutableSet.of(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NzI1Mg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512047252", "bodyText": "static import extractUnique", "author": "sopel39", "createdAt": "2020-10-26T15:24:28Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDc1NQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512054755", "bodyText": "ok, so this actually adds new symbols... but DF won't work for l1 + 10 anyway, so we can only support cases where left side consist of single symbol", "author": "sopel39", "createdAt": "2020-10-26T15:33:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));\n+                        Expression leftExpression = (alignedComparison) ? comparison.getLeft() : comparison.getRight();\n+                        Expression rightExpression = (alignedComparison) ? comparison.getRight() : comparison.getLeft();\n+                        ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+\n+                        Symbol leftSymbol = symbolForExpression(leftExpression);\n+                        if (!node.getLeft().getOutputSymbols().contains(leftSymbol)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4NDc5Mg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r513384792", "bodyText": "Sounds good, fixed the code to support only single symbol case.", "author": "rzeyde-varada", "createdAt": "2020-10-28T11:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MjM0NQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r512062345", "bodyText": "so this actually can affect join performance when DF are not effective, e.g a new symbol l2=l1+10 might be send over the network and stored in build side (even though l1 is already send). I would rather avoid that. Let's assume that right side is single symbol. We could also add a support in DynamicFilterSourceOperator for basic expressions, e.g l1+10 later", "author": "sopel39", "createdAt": "2020-10-26T15:43:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -579,42 +595,101 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Assignments.Builder leftProjections,\n+                Assignments.Builder rightProjections,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n-                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n-            }\n+                return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of(), joinFilterClauses, false);\n+            }\n+\n+            AtomicBoolean newProjectionAdded = new AtomicBoolean(false);\n+            ImmutableList.Builder<ComparisonExpression> comparisonClausesBuilder = ImmutableList.builder();\n+            equiJoinClauses\n+                    .stream()\n+                    .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference()))\n+                    .forEach(comparisonClausesBuilder::add);\n+            joinFilterClauses = joinFilterClauses.stream()\n+                    .map(clause -> {\n+                        if (!isJoinComparison(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_OPERATORS)) {\n+                            return clause;\n+                        }\n+                        ComparisonExpression comparison = (ComparisonExpression) clause;\n+                        boolean alignedComparison = node.getLeft().getOutputSymbols().containsAll(SymbolsExtractor.extractUnique(comparison.getLeft()));\n+                        Expression leftExpression = (alignedComparison) ? comparison.getLeft() : comparison.getRight();\n+                        Expression rightExpression = (alignedComparison) ? comparison.getRight() : comparison.getLeft();\n+                        ComparisonExpression.Operator operator = alignedComparison ? comparison.getOperator() : comparison.getOperator().flip();\n+\n+                        Symbol leftSymbol = symbolForExpression(leftExpression);\n+                        if (!node.getLeft().getOutputSymbols().contains(leftSymbol)) {\n+                            leftProjections.put(leftSymbol, leftExpression);\n+                            newProjectionAdded.set(true);\n+                        }\n+\n+                        Symbol rightSymbol = symbolForExpression(rightExpression);\n+                        if (!node.getRight().getOutputSymbols().contains(rightSymbol)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4NDk2MQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r513384961", "bodyText": "Sounds good, fixed the code to support only single symbol case.", "author": "rzeyde-varada", "createdAt": "2020-10-28T11:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MjM0NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "c90421ad83858768e9a899599329620e8f3b9081", "url": "https://github.com/trinodb/trino/commit/c90421ad83858768e9a899599329620e8f3b9081", "message": "Use static import for SymbolsExtractor.extractUnique", "committedDate": "2020-10-28T20:02:21Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI3Njc2NQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r514276765", "bodyText": "use toImmutableSet", "author": "sopel39", "createdAt": "2020-10-29T13:55:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +597,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n+            List<ComparisonExpression> clauses = Streams.concat(\n+                    equiJoinClauses\n+                            .stream()\n+                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                    joinFilterClauses.stream()\n+                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))\n+                            .map(ComparisonExpression.class::cast)\n+                            .filter(comparison -> comparison.getLeft() instanceof SymbolReference && comparison.getRight() instanceof SymbolReference)\n+                            .map(comparison -> {\n+                                Symbol leftSymbol = Symbol.from(comparison.getLeft());\n+                                Symbol rightSymbol = Symbol.from(comparison.getRight());\n+                                boolean alignedComparison = node.getLeft().getOutputSymbols().contains(leftSymbol);\n+                                return new ComparisonExpression(\n+                                        alignedComparison ? comparison.getOperator() : comparison.getOperator().flip(),\n+                                        (alignedComparison ? leftSymbol : rightSymbol).toSymbolReference(),\n+                                        (alignedComparison ? rightSymbol : leftSymbol).toSymbolReference());\n+                            }))\n+                    .collect(toImmutableList());\n+\n             // New equiJoinClauses could potentially not contain symbols used in current dynamic filters.\n             // Since we use PredicatePushdown to push dynamic filters themselves,\n             // instead of separate ApplyDynamicFilters rule we derive dynamic filters within PredicatePushdown itself.\n             // Even if equiJoinClauses.equals(node.getCriteria), current dynamic filters may not match equiJoinClauses\n-            ImmutableMap.Builder<DynamicFilterId, Symbol> dynamicFiltersBuilder = ImmutableMap.builder();\n-            ImmutableList.Builder<Expression> predicatesBuilder = ImmutableList.builder();\n-            // reuse existing dynamic filters to make planning more stable\n-            Map<Symbol, DynamicFilterId> buildSymbolToDynamicFilter = new HashMap<>(node.getDynamicFilters().entrySet().stream()\n-                    .collect(toImmutableMap(Map.Entry::getValue, Map.Entry::getKey)));\n-            for (JoinNode.EquiJoinClause clause : equiJoinClauses) {\n-                Symbol probeSymbol = clause.getLeft();\n-                Symbol buildSymbol = clause.getRight();\n-                DynamicFilterId id = buildSymbolToDynamicFilter.computeIfAbsent(\n+\n+            // Collect build symbols:\n+            Set<Symbol> buildSymbols = clauses.stream()\n+                    .map(ComparisonExpression::getRight)\n+                    .map(Symbol::from)\n+                    .collect(Collectors.toSet());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI4MTQyNg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r514281426", "bodyText": "make a defensive copy of buildSymbolToDynamicFilter in DynamicFiltersResult", "author": "sopel39", "createdAt": "2020-10-29T14:01:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +597,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n+            List<ComparisonExpression> clauses = Streams.concat(\n+                    equiJoinClauses\n+                            .stream()\n+                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                    joinFilterClauses.stream()\n+                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))\n+                            .map(ComparisonExpression.class::cast)\n+                            .filter(comparison -> comparison.getLeft() instanceof SymbolReference && comparison.getRight() instanceof SymbolReference)\n+                            .map(comparison -> {\n+                                Symbol leftSymbol = Symbol.from(comparison.getLeft());\n+                                Symbol rightSymbol = Symbol.from(comparison.getRight());\n+                                boolean alignedComparison = node.getLeft().getOutputSymbols().contains(leftSymbol);\n+                                return new ComparisonExpression(\n+                                        alignedComparison ? comparison.getOperator() : comparison.getOperator().flip(),\n+                                        (alignedComparison ? leftSymbol : rightSymbol).toSymbolReference(),\n+                                        (alignedComparison ? rightSymbol : leftSymbol).toSymbolReference());\n+                            }))\n+                    .collect(toImmutableList());\n+\n             // New equiJoinClauses could potentially not contain symbols used in current dynamic filters.\n             // Since we use PredicatePushdown to push dynamic filters themselves,\n             // instead of separate ApplyDynamicFilters rule we derive dynamic filters within PredicatePushdown itself.\n             // Even if equiJoinClauses.equals(node.getCriteria), current dynamic filters may not match equiJoinClauses\n-            ImmutableMap.Builder<DynamicFilterId, Symbol> dynamicFiltersBuilder = ImmutableMap.builder();\n-            ImmutableList.Builder<Expression> predicatesBuilder = ImmutableList.builder();\n-            // reuse existing dynamic filters to make planning more stable\n-            Map<Symbol, DynamicFilterId> buildSymbolToDynamicFilter = new HashMap<>(node.getDynamicFilters().entrySet().stream()\n-                    .collect(toImmutableMap(Map.Entry::getValue, Map.Entry::getKey)));\n-            for (JoinNode.EquiJoinClause clause : equiJoinClauses) {\n-                Symbol probeSymbol = clause.getLeft();\n-                Symbol buildSymbol = clause.getRight();\n-                DynamicFilterId id = buildSymbolToDynamicFilter.computeIfAbsent(\n+\n+            // Collect build symbols:\n+            Set<Symbol> buildSymbols = clauses.stream()\n+                    .map(ComparisonExpression::getRight)\n+                    .map(Symbol::from)\n+                    .collect(Collectors.toSet());\n+\n+            // Allocate new dynamic filter IDs for for each build symbol:\n+            BiMap<Symbol, DynamicFilterId> buildSymbolToDynamicFilter = HashBiMap.create(node.getDynamicFilters()).inverse();\n+            for (Symbol buildSymbol : buildSymbols) {\n+                buildSymbolToDynamicFilter.computeIfAbsent(\n                         buildSymbol,\n                         key -> new DynamicFilterId(\"df_\" + idAllocator.getNextId().toString()));\n-                predicatesBuilder.add(createDynamicFilterExpression(metadata, id, symbolAllocator.getTypes().get(probeSymbol), probeSymbol.toSymbolReference()));\n-                dynamicFiltersBuilder.put(id, buildSymbol);\n             }\n-            return new DynamicFiltersResult(dynamicFiltersBuilder.build(), predicatesBuilder.build());\n+\n+            // Multiple probe symbols may depend on a single build symbol / dynamic filter ID:\n+            List<Expression> predicates = clauses\n+                    .stream()\n+                    .map(clause -> {\n+                        Symbol probeSymbol = Symbol.from(clause.getLeft());\n+                        Symbol buildSymbol = Symbol.from(clause.getRight());\n+                        Type type = symbolAllocator.getTypes().get(probeSymbol);\n+                        DynamicFilterId id = requireNonNull(buildSymbolToDynamicFilter.get(buildSymbol), () -> \"missing dynamic filter for symbol \" + buildSymbol);\n+                        return createDynamicFilterExpression(metadata, id, type, probeSymbol.toSymbolReference(), clause.getOperator());\n+                    })\n+                    .collect(toImmutableList());\n+            // Return a mapping from build symbols to corresponding dynamic filter IDs:\n+            return new DynamicFiltersResult(buildSymbolToDynamicFilter.inverse(), predicates);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2NTE1MQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r514565151", "bodyText": "please also add support for between predicate (+ tests), you can rewrite between into two comparisons", "author": "sopel39", "createdAt": "2020-10-29T21:03:16Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +598,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(\n+                JoinNode node,\n+                List<JoinNode.EquiJoinClause> equiJoinClauses,\n+                List<Expression> joinFilterClauses,\n+                Session session, PlanNodeIdAllocator idAllocator)\n         {\n             if ((node.getType() != INNER && node.getType() != RIGHT) || !isEnableDynamicFiltering(session) || !dynamicFiltering) {\n                 return new DynamicFiltersResult(ImmutableMap.of(), ImmutableList.of());\n             }\n \n+            List<ComparisonExpression> clauses = Streams.concat(\n+                    equiJoinClauses\n+                            .stream()\n+                            .map(clause -> new ComparisonExpression(EQUAL, clause.getLeft().toSymbolReference(), clause.getRight().toSymbolReference())),\n+                    joinFilterClauses.stream()\n+                            .filter(clause -> joinComparisonExpression(clause, node.getLeft().getOutputSymbols(), node.getRight().getOutputSymbols(), DYNAMIC_FILTERING_SUPPORTED_COMPARISONS))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAwOTM0OQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515009349", "bodyText": "please add two TODOs and corresponding issues in Prestosql:\n\ncollect min/max ranges for ineqaulity dynamic filters\nsupport for complex inequalities, e.g left < right + 10", "author": "sopel39", "createdAt": "2020-10-30T10:44:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -580,31 +598,67 @@ public PlanNode visitJoin(JoinNode node, RewriteContext<Expression> context)\n             return output;\n         }\n \n-        private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.EquiJoinClause> equiJoinClauses, Session session, PlanNodeIdAllocator idAllocator)\n+        private DynamicFiltersResult createDynamicFilters(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxMzYzOQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515913639", "bodyText": "add links to the issues in code", "author": "sopel39", "createdAt": "2020-11-02T11:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAwOTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxMDU1Mw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515010553", "bodyText": "actually, this seems redundant to testInnerInequalityJoinWithEquiJoinConjuncts. Please remove this one, sorry", "author": "sopel39", "createdAt": "2020-10-30T10:47:17Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -141,6 +148,66 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testEquiJoinInequalityDF()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxMzYyMA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515013620", "bodyText": "please use just one column handle. Let's make sure that range gets clamped.", "author": "sopel39", "createdAt": "2020-10-30T10:53:36Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -182,6 +186,44 @@ public void testMultipleProbeColumns()\n         assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(column1, domain, column2, domain)));\n     }\n \n+    @Test\n+    public void testMultipleComparisons()\n+    {\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector(metadata, typeOperators, session);\n+        DynamicFilterId filterId = new DynamicFilterId(\"filter\");\n+        collector.register(ImmutableSet.of(filterId));\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+\n+        // Same build-side column being compared to multiple probe-side columns.\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"symbol1\", BIGINT);\n+        Symbol symbol2 = symbolAllocator.newSymbol(\"symbol2\", BIGINT);\n+        ColumnHandle column1 = new TestingColumnHandle(\"column1\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxMzc3OQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515013779", "bodyText": "Please use filter(TRUE_PREDICATE here and in other cases.", "author": "sopel39", "createdAt": "2020-10-30T10:53:57Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -298,8 +301,11 @@ public void testDistinctLimitOverInequalityJoin()\n                         node(DistinctLimitNode.class,\n                                 anyTree(\n                                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                                join(INNER,\n+                                                        ImmutableList.of(),\n+                                                        ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\")),\n+                                                        node(FilterNode.class,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNDIxOA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515014218", "bodyText": "can we use pattern without these two empty params?", "author": "sopel39", "createdAt": "2020-10-30T10:54:45Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -341,8 +347,14 @@ public void testInnerInequalityJoinNoEquiJoinConjuncts()\n         assertPlan(\"SELECT 1 FROM orders o JOIN lineitem l ON o.orderkey < l.orderkey\",\n                 anyTree(\n                         filter(\"O_ORDERKEY < L_ORDERKEY\",\n-                                join(INNER, ImmutableList.of(), Optional.empty(),\n-                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\")),\n+                                join(INNER,\n+                                        ImmutableList.of(),\n+                                        Optional.empty(),\n+                                        Optional.of(ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                        Optional.empty(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNDQ3MQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515014471", "bodyText": "match filter here too", "author": "sopel39", "createdAt": "2020-10-30T10:55:15Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -355,6 +367,11 @@ public void testInnerInequalityJoinWithEquiJoinConjuncts()\n                                 join(INNER,\n                                         ImmutableList.of(equiJoinClause(\"O_SHIPPRIORITY\", \"L_LINENUMBER\")),\n                                         Optional.of(\"O_ORDERKEY < L_ORDERKEY\"),\n+                                        Optional.of(ImmutableList.of(\n+                                                new DynamicFilterPattern(\"O_SHIPPRIORITY\", EQUAL, \"L_LINENUMBER\"),\n+                                                new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                        Optional.empty(),\n+                                        Optional.empty(),\n                                         anyTree(tableScan(\"orders\", ImmutableMap.of(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNTM0MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515015340", "bodyText": "remove // FIXUP", "author": "sopel39", "createdAt": "2020-10-30T10:56:59Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/JoinMatcher.java", "diffHunk": "@@ -173,8 +178,7 @@ public String toString()\n                 .add(\"equiCriteria\", equiCriteria)\n                 .add(\"filter\", filter.orElse(null))\n                 .add(\"distributionType\", distributionType)\n-                .add(\"dynamicFilter\", expectedDynamicFilterAliases.map(aliases -> aliases.values().stream()\n-                        .collect(toImmutableMap(rightSymbol -> rightSymbol.toString() + \"_alias\", SymbolAlias::toString))))\n+                .add(\"dynamicFilter\", expectedDynamicFilter)  // FIXUP", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515016648", "bodyText": "Why does orders.orderkey + 1 work? There is orderkey + 1 expression here, so it shouldn't work", "author": "sopel39", "createdAt": "2020-10-30T10:59:45Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwODA4MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515208080", "bodyText": "IIUC, it worked since the optimizer replaced orderkey + 1 with an expr symbol by adding a projection.\nI will rewrite the tests to use single symbols in the comparison expressions.", "author": "rzeyde-varada", "createdAt": "2020-10-30T16:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxMjMwMA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515212300", "bodyText": "IIUC, it worked since the optimizer replaced orderkey + 1\n\nWhy it replaced it with expr?\n\nI will rewrite the tests to use single symbols in the comparison expressions.\n\nWe should test both types of comparisons to document current behavior.", "author": "sopel39", "createdAt": "2020-10-30T16:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUyMzE5OQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515523199", "bodyText": "It seems that current master behaves this way (i.e. adds a projection for cross-join build-side expression) - reproduced with master...rzeyde-varada:repro-cross-join-projection:\n    @Test\n    public void testAddProjectForComplexBuildExpression()\n    {\n        assertPlan(\"SELECT 1 FROM lineitem JOIN orders ON lineitem.orderkey < orders.orderkey + 1\",\n                anyTree(\n                        filter(\"L_ORDERKEY < EXPR\",\n                                join(INNER, ImmutableList.of(), Optional.empty(),\n                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")),\n                                        exchange(project(\n                                                ImmutableMap.of(\"EXPR\", expression(\"O_ORDERKEY + BIGINT '1'\")),\n                                                tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))))))));\n    }", "author": "rzeyde-varada", "createdAt": "2020-10-31T18:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU5NDU3NA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515594574", "bodyText": "IIUC, the initial plan (before the optimization) seems to contain the projection - so it seems that running the optimizers doesn't remove it:\nOutput[_col0]\n\u2502   Layout: [expr_3:integer]\n\u2502   _col0 := expr_3\n\u2514\u2500 Project[]\n   \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint, expr_3:integer]\n   \u2514\u2500 Project[]\n      \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint, expr_3:integer]\n      \u2514\u2500 Project[]\n         \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint, expr_3:integer]\n         \u2514\u2500 FilterProject[filterPredicate = (\"orderkey\" < \"expr\")]\n            \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint, expr_3:integer]\n            \u2502   expr_3 := 1\n            \u2514\u2500 CrossJoin\n               \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint, orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint]\n               \u251c\u2500 Project[]\n               \u2502  \u2502   Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint]\n               \u2502  \u2514\u2500 ScanProject[table = local:lineitem:sf0.01]\n               \u2502         Layout: [orderkey:bigint, partkey:bigint, suppkey:bigint, linenumber:integer, quantity:double, extendedprice:double, discount:double, tax:double, returnflag:varchar(1), linestatus:varchar(1), shipdate:date, commitdate:date, receiptdate:date, shipinstruct:varchar(25), shipmode:varchar(10), comment:varchar(44), row_number:bigint]\n               \u2502         orderkey := tpch:orderkey\n               \u2502         partkey := tpch:partkey\n               \u2502         suppkey := tpch:suppkey\n               \u2502         linenumber := tpch:linenumber\n               \u2502         quantity := tpch:quantity\n               \u2502         extendedprice := tpch:extendedprice\n               \u2502         discount := tpch:discount\n               \u2502         tax := tpch:tax\n               \u2502         returnflag := tpch:returnflag\n               \u2502         linestatus := tpch:linestatus\n               \u2502         shipdate := tpch:shipdate\n               \u2502         commitdate := tpch:commitdate\n               \u2502         receiptdate := tpch:receiptdate\n               \u2502         shipinstruct := tpch:shipinstruct\n               \u2502         shipmode := tpch:shipmode\n               \u2502         comment := tpch:comment\n               \u2502         row_number := tpch:row_number\n               \u2514\u2500 Project[]\n                  \u2502   Layout: [orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint]\n                  \u2514\u2500 ScanProject[table = local:orders:sf0.01]\n                         Layout: [orderkey_0:bigint, custkey:bigint, orderstatus:varchar(1), totalprice:double, orderdate:date, orderpriority:varchar(15), clerk:varchar(15), shippriority:integer, comment_1:varchar(79), row_number_2:bigint, expr:bigint]\n                         expr := (\"orderkey_0\" + CAST(1 AS bigint))\n                         orderkey_0 := tpch:orderkey\n                         custkey := tpch:custkey\n                         orderstatus := tpch:orderstatus\n                             :: [[F], [O], [P]]\n                         totalprice := tpch:totalprice\n                         orderdate := tpch:orderdate\n                         orderpriority := tpch:orderpriority\n                         clerk := tpch:clerk\n                         shippriority := tpch:shippriority\n                         comment_1 := tpch:comment\n                         row_number_2 := tpch:row_number\n\n(printed via bc72a40)", "author": "rzeyde-varada", "createdAt": "2020-11-01T09:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU5NTAzOA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515595038", "bodyText": "BTW, it seems that the same happens when the complex expression is on the probe-side of the join, i.e.:\nSELECT lineitem.orderkey, orders.orderkey \nFROM lineitem JOIN orders \nON lineitem.orderkey + 1 < orders.orderkey + 1\nThe resulting plan is:\nOutput[orderkey, orderkey]\n\u2502   Layout: [orderkey:bigint, orderkey_0:bigint]\n\u2502   orderkey := orderkey_0\n\u2514\u2500 FilterProject[filterPredicate = (\"expr\" < \"expr_3\")]\n   \u2502   Layout: [orderkey:bigint, orderkey_0:bigint]\n   \u2514\u2500 CrossJoin\n      \u2502   Layout: [orderkey:bigint, expr:bigint, orderkey_0:bigint, expr_3:bigint]\n      \u251c\u2500 ScanProject[table = local:lineitem:sf0.01]\n      \u2502      Layout: [orderkey:bigint, expr:bigint]\n      \u2502      expr := (\"orderkey\" + BIGINT '1')\n      \u2502      orderkey := tpch:orderkey\n      \u2514\u2500 LocalExchange[SINGLE] ()\n         \u2502   Layout: [orderkey_0:bigint, expr_3:bigint]\n         \u2514\u2500 ScanProject[table = local:orders:sf0.01]\n                Layout: [orderkey_0:bigint, expr_3:bigint]\n                expr_3 := (\"orderkey_0\" + BIGINT '1')\n                orderkey_0 := tpch:orderkey\n                tpch:orderstatus\n                    :: [[F], [O], [P]]", "author": "rzeyde-varada", "createdAt": "2020-11-01T09:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyODAxMg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515928012", "bodyText": "I've created #5777", "author": "sopel39", "createdAt": "2020-11-02T12:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNjY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNzEzNg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515017136", "bodyText": "Could we choose range (or remove comment predicate) so that number of results is less than 6 when clamped (too show that both comparisons are effective)\nlineitem.orderkey <= orders.orderkey alone ensures 6 rows", "author": "sopel39", "createdAt": "2020-10-30T11:00:43Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +263,81 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        // \"<\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey < orders.orderkey + 1 AND \" +\n+                            \"orders.comment = 'nstructions sleep furiously among '\",\n+                    withBroadcastJoin(),\n+                    6,\n+                    ImmutableSet.of(6, ORDERS_COUNT));\n+        }\n+        // \"<=\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey <= orders.orderkey AND \" +\n+                            \"orders.comment = 'nstructions sleep furiously among '\",\n+                    withBroadcastJoin(),\n+                    6,\n+                    ImmutableSet.of(6, ORDERS_COUNT));\n+        }\n+        // \"<=\" and \">\" pushdown\n+        {\n+            assertDynamicFiltering(\n+                    \"SELECT * FROM lineitem JOIN orders ON \" +\n+                            \"lineitem.orderkey <= orders.orderkey AND \" +\n+                            \"lineitem.orderkey > orders.orderkey - 1 AND \" +", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwODQ2NQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515208465", "bodyText": "I will rewrite the tests to verify this scenario.", "author": "rzeyde-varada", "createdAt": "2020-10-30T16:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAxNzEzNg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNDQ0Mw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515914443", "bodyText": "nit: reverse sides in O_COMMENT < CAST(L_COMMENT AS varchar(79)) to match join order", "author": "sopel39", "createdAt": "2020-11-02T11:39:13Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -141,6 +148,44 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test\n+    public void testCrossJoinInequalityDF()\n+    {\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE o.orderkey > l.orderkey\",\n+                anyTree(filter(\"O_ORDERKEY > L_ORDERKEY\",\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(),\n+                                ImmutableList.of(new DynamicFilterPattern(\"O_ORDERKEY\", GREATER_THAN, \"L_ORDERKEY\")),\n+                                filter(\n+                                        TRUE_LITERAL,\n+                                        tableScan(\"orders\", ImmutableMap.of(\"O_ORDERKEY\", \"orderkey\"))),\n+                                exchange(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"L_ORDERKEY\", \"orderkey\")))))));\n+    }\n+\n+    @Test\n+    public void testCrossJoinInequalityNoDFWithCast()\n+    {\n+        assertPlan(\"SELECT o.comment, l.comment FROM lineitem l, orders o WHERE o.comment < l.comment\",\n+                anyTree(filter(\"O_COMMENT < CAST(L_COMMENT AS varchar(79))\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTEwNA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515915104", "bodyText": "let's use pattern with Optional.empty() here", "author": "sopel39", "createdAt": "2020-11-02T11:40:35Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -355,9 +365,16 @@ public void testInnerInequalityJoinWithEquiJoinConjuncts()\n                                 join(INNER,\n                                         ImmutableList.of(equiJoinClause(\"O_SHIPPRIORITY\", \"L_LINENUMBER\")),\n                                         Optional.of(\"O_ORDERKEY < L_ORDERKEY\"),\n-                                        anyTree(tableScan(\"orders\", ImmutableMap.of(\n-                                                \"O_SHIPPRIORITY\", \"shippriority\",\n-                                                \"O_ORDERKEY\", \"orderkey\"))),\n+                                        Optional.of(ImmutableList.of(\n+                                                new DynamicFilterPattern(\"O_SHIPPRIORITY\", EQUAL, \"L_LINENUMBER\"),\n+                                                new DynamicFilterPattern(\"O_ORDERKEY\", LESS_THAN, \"L_ORDERKEY\"))),\n+                                        Optional.empty(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxNTU4Nw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515915587", "bodyText": "add a test case for between here too", "author": "sopel39", "createdAt": "2020-11-02T11:41:30Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -141,6 +148,44 @@ public void testEmptyJoinCriteria()\n                                         tableScan(\"lineitem\")))));\n     }\n \n+    @Test", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkyOTM1MQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r515929351", "bodyText": "please add a test cases:\nSELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax + 1\nSELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax +1\nSELECT * FROM probe JOIN build WHERE >= vmin AND v <= vmax + 1\nSELECT * FROM probe WHERE v <= (SELECT max(vmax) FROM build)", "author": "sopel39", "createdAt": "2020-11-02T12:09:57Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,36 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU0MzI3OA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516543278", "bodyText": "static import", "author": "sopel39", "createdAt": "2020-11-03T09:55:10Z", "path": "presto-main/src/main/java/io/prestosql/sql/DynamicFilters.java", "diffHunk": "@@ -154,11 +176,18 @@ public ExtractResult(List<Expression> staticConjuncts, List<Descriptor> dynamicC\n     {\n         private final DynamicFilterId id;\n         private final Expression input;\n+        private final ComparisonExpression.Operator operator;\n \n-        public Descriptor(DynamicFilterId id, Expression input)\n+        public Descriptor(DynamicFilterId id, Expression input, ComparisonExpression.Operator operator)\n         {\n             this.id = requireNonNull(id, \"id is null\");\n             this.input = requireNonNull(input, \"input is null\");\n+            this.operator = requireNonNull(operator, \"operator is null\");\n+        }\n+\n+        public Descriptor(DynamicFilterId id, Expression input)\n+        {\n+            this(id, input, ComparisonExpression.Operator.EQUAL);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3Mzk4NQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516573985", "bodyText": "From the test I don't know if vmax + 1 filtered anything or not (that's why I suggested vmin + 1). Please change the test so that upper boundary also filters data.", "author": "sopel39", "createdAt": "2020-11-03T10:44:48Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,40 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax + 1\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYyMzgyNQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516623825", "bodyText": "Good catch, thanks!\nI've added more tests at testCrossJoinDynamicFiltering to reproduce #5777 and #5755 better.", "author": "rzeyde-varada", "createdAt": "2020-11-03T12:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjU3Mzk4NQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjA5NQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516772095", "bodyText": "why ImmutableSet.of(1) has one element here?", "author": "sopel39", "createdAt": "2020-11-03T15:53:54Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,61 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTk3OQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516909979", "bodyText": "You're right, it's better to use ImmutableList.of(1, 1) here.", "author": "rzeyde-varada", "createdAt": "2020-11-03T19:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjU0MQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516772541", "bodyText": "Make assertDynamicFiltering accept ImmutableList", "author": "sopel39", "createdAt": "2020-11-03T15:54:28Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -307,7 +363,7 @@ private Session withPartitionedJoin()\n         QueryStats stats = runner.getCoordinator().getQueryManager().getFullQueryInfo(queryId).getQueryStats();\n         return stats.getOperatorSummaries()\n                 .stream()\n-                .filter(summary -> summary.getOperatorType().equals(\"ScanFilterAndProjectOperator\"))\n+                .filter(summary -> summary.getOperatorType().contains(\"Scan\"))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTc5Nw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516909797", "bodyText": "Sounds good, updated the code at 37bcdca.", "author": "rzeyde-varada", "createdAt": "2020-11-03T19:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3MjU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3NDQ2MA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516774460", "bodyText": "why set has one element?", "author": "sopel39", "createdAt": "2020-11-03T15:56:58Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -263,6 +264,61 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                 ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n+    @Test\n+    public void testCrossJoinDynamicFiltering()\n+    {\n+        assertUpdate(\"CREATE TABLE probe (k VARCHAR, v INTEGER)\");\n+        assertUpdate(\"CREATE TABLE build (vmin INTEGER, vmax INTEGER)\");\n+        assertUpdate(\"INSERT INTO probe VALUES ('a', 0), ('b', 1), ('c', 2), ('d', 3)\", 4);\n+        assertUpdate(\"INSERT INTO build VALUES (1, 2)\", 1);\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v <= vmax\", withBroadcastJoin(), 3, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v < vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v < vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v <= vmax\", withBroadcastJoin(), 1, ImmutableSet.of(1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND v < vmax\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v > vmin AND vmax < 0\", withBroadcastJoin(), 0, ImmutableSet.of(0, 1));\n+\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin AND vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v >= vmin AND v <= vmax\", withBroadcastJoin(), 2, ImmutableSet.of(2, 1));\n+\n+        // TODO: support complex inequality join clauses: https://github.com/prestosql/presto/issues/5755\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin AND vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin + 1 AND vmax\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v BETWEEN vmin + 1 AND vmax - 1\", withBroadcastJoin(), 0, ImmutableSet.of(4, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin AND vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin + 1 AND vmax\", withBroadcastJoin(), 1, ImmutableSet.of(3, 1));\n+        assertDynamicFiltering(\"SELECT * FROM probe, build WHERE v BETWEEN vmin + 1 AND vmax - 1\", withBroadcastJoin(), 0, ImmutableSet.of(4, 1));\n+\n+        // TODO: make sure it works after https://github.com/prestosql/presto/issues/5777 is fixed\n+        assertDynamicFiltering(\"SELECT * FROM probe JOIN build ON v >= vmin AND v <= vmax - 1\", withBroadcastJoin(), 1, ImmutableSet.of(1));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMDAzNg==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r516910036", "bodyText": "You're right, it's better to use ImmutableList.of(1, 1) here.", "author": "rzeyde-varada", "createdAt": "2020-11-03T19:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc3NDQ2MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0Nzc2OQ==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517247769", "bodyText": "why no order? Why not to compare lists directly?", "author": "sopel39", "createdAt": "2020-11-04T10:35:20Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -260,16 +260,16 @@ public void testSemiJoinDynamicFilteringBlockProbeSide()\n                         \"WHERE t.partkey IN (SELECT p.partkey FROM part p WHERE p.comment = 'onic deposits')\",\n                 withBroadcastJoinNonReordering(),\n                 1,\n-                ImmutableSet.of(1, ORDERS_COUNT, PART_COUNT));\n+                ImmutableList.of(1, ORDERS_COUNT, PART_COUNT));\n     }\n \n-    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, Set<Integer> expectedOperatorRowsRead)\n+    private void assertDynamicFiltering(@Language(\"SQL\") String selectQuery, Session session, int expectedRowCount, List<Integer> expectedOperatorRowsRead)\n     {\n         DistributedQueryRunner runner = (DistributedQueryRunner) getQueryRunner();\n         ResultWithQueryId<MaterializedResult> result = runner.executeWithQueryId(session, selectQuery);\n \n         assertEquals(result.getResult().getRowCount(), expectedRowCount);\n-        assertEquals(getOperatorRowsRead(runner, result.getQueryId()), expectedOperatorRowsRead);\n+        assertEqualsNoOrder(getOperatorRowsRead(runner, result.getQueryId()).toArray(), expectedOperatorRowsRead.toArray());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3Mjc3Mw==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517372773", "bodyText": "Sounds good - fixed in 83c7b70a85.", "author": "rzeyde-varada", "createdAt": "2020-11-04T14:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0Nzc2OQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzczNA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517417734", "bodyText": "nit: we probably could use vararg here", "author": "sopel39", "createdAt": "2020-11-04T15:15:13Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -106,7 +105,7 @@ public void testJoinDynamicFilteringNone()\n                 \"SELECT * FROM lineitem JOIN orders ON lineitem.orderkey = orders.orderkey AND orders.totalprice < 0\",\n                 withBroadcastJoin(),\n                 0,\n-                ImmutableSet.of(0, ORDERS_COUNT));\n+                ImmutableList.of(0, ORDERS_COUNT));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2NTA1OA==", "url": "https://github.com/trinodb/trino/pull/2674#discussion_r517465058", "bodyText": "Sounds good, changed assertDynamicFiltering to accept int... expectedOperatorRowsRead.", "author": "rzeyde-varada", "createdAt": "2020-11-04T16:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNzczNA=="}], "type": "inlineReview"}, {"oid": "7f4c676f43a4e2e6feacb4a208922aa3e9f3d3db", "url": "https://github.com/trinodb/trino/commit/7f4c676f43a4e2e6feacb4a208922aa3e9f3d3db", "message": "Improve matching of read rows in TestMemorySmoke", "committedDate": "2020-11-04T16:12:52Z", "type": "commit"}, {"oid": "7aa4b22b40f8665e104f7b53dd64e19e831d0f86", "url": "https://github.com/trinodb/trino/commit/7aa4b22b40f8665e104f7b53dd64e19e831d0f86", "message": "Allow dynamic filtering with comparison operators", "committedDate": "2020-11-04T16:12:53Z", "type": "commit"}, {"oid": "7aa4b22b40f8665e104f7b53dd64e19e831d0f86", "url": "https://github.com/trinodb/trino/commit/7aa4b22b40f8665e104f7b53dd64e19e831d0f86", "message": "Allow dynamic filtering with comparison operators", "committedDate": "2020-11-04T16:12:53Z", "type": "forcePushed"}]}