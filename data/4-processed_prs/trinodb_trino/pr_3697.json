{"pr_number": 3697, "pr_title": "SPI and engine changes for aggregation pushdown", "pr_createdAt": "2020-05-11T17:03:02Z", "pr_url": "https://github.com/trinodb/trino/pull/3697", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NTc4OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r423995788", "bodyText": "I don't think we need a global toggle for this. Connectors can choose whether to support aggregation pushdown by not implementing the new API (or doing it selectively, possibly based on a connector-specific setting)", "author": "martint", "createdAt": "2020-05-12T19:56:17Z", "path": "presto-main/src/main/java/io/prestosql/SystemSessionProperties.java", "diffHunk": "@@ -564,7 +565,12 @@ public SystemSessionProperties(\n                         COST_ESTIMATION_WORKER_COUNT,\n                         \"Set the estimate count of workers while planning\",\n                         null,\n-                        true));\n+                        true),\n+                booleanProperty(\n+                        ENABLE_AGG_PUSHDOWN,\n+                        \"Enable aggregate pushdown\",\n+                        featuresConfig.isEnableAggPushdown(),\n+                        false));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NjcxNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096717", "bodyText": "Removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NTc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NzY5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r423997699", "bodyText": "Remove these since there are no details.", "author": "martint", "createdAt": "2020-05-12T19:59:45Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:\n+     *\n+     * <pre>\n+     * handle = TH1\n+     * assignments = [\n+     *     v0 = CH0 (synthetic column for agg_fn1(a))\n+     *     v1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     v2 = CH3 (for column c)\n+     * ]\n+     * </pre>\n+     * @param session\n+     * @param handle\n+     * @param aggregates\n+     * @param assignments\n+     * @param groupBy\n+     * @return", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzM3Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097372", "bodyText": "removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5NzY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5ODQwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r423998408", "bodyText": "Why is groupBy a list of lists? For grouping sets?", "author": "martint", "createdAt": "2020-05-12T20:00:57Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:\n+     *\n+     * <pre>\n+     * handle = TH1\n+     * assignments = [\n+     *     v0 = CH0 (synthetic column for agg_fn1(a))\n+     *     v1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     v2 = CH3 (for column c)\n+     * ]\n+     * </pre>\n+     * @param session\n+     * @param handle\n+     * @param aggregates\n+     * @param assignments\n+     * @param groupBy\n+     * @return\n+     */\n+    default Optional<AggregatePushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session, ConnectorTableHandle handle, List<AggregateFunction> aggregates,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzM4MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097381", "bodyText": "yes. let me know if you think we should remove that right now and add it when we do review for grouping sets rule.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk5ODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MzkzMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424073933", "bodyText": "Ordering of the sorting clauses matters, so this should be a list of tuples containing an expression and a sort order.", "author": "martint", "createdAt": "2020-05-12T22:39:31Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Nzg2OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097868", "bodyText": "I was using sortBy to preserve the ordering and sortOrder to lookup the actual order. I like just having a list of tuples so I have updated the code with a single list of entries.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MzkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NDEyMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424074122", "bodyText": "Rename to functionName", "author": "martint", "createdAt": "2020-05-12T22:39:56Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Nzc3MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097770", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NDEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424079928", "bodyText": "This shouldn't be here. The applyAggregation call should return a list of ConnectorExpression in the same order as the provided list of aggregations. With that, it can know which aggregation corresponds to which output. It should also return a list of Assignments similar to applyProjection. The idea is that given the following:\nAggregation\n        f1 := count(x)\n        f2 := count(x)\n    TableScan(TH0)\n            x = CH0\n\napplyAggregation would be called with:\ntable = TH0\naggregates = [count(x), count(x)]\nassignments = { x = CH0 }\ngroupBy = {}\n\nand would return:\ntable = TH0'\nprojections = [y, y]\nassignments = { y = CH0' }\n\nIt also allows for more sophisticated scenarios. For instance, given the following plan and a connector that can only compute sum(column):\nAggregation\n        f1 := sum(x)\n        f2 := sum(x+y)\n    TableScan(TH0)\n            x = CH0\n            y = CH1\n\nit could return:\ntable = TH1\nprojections = [a, a + b]\nassignments = { a = CH0', b = CH1' }\n\nwhere CH0' would be mapped internally to sum(CH0) and CH1' to sum(CH1) by decomposing sum(CH0 + CH1) into sum(CH0) + sum(CH1)", "author": "martint", "createdAt": "2020-05-12T22:56:14Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMDY1OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424430659", "bodyText": "The applyAggregation call should return a list of ConnectorExpression in the same order as the provided list of aggregations.\n\nAnd would group-bys go? At the end?\n(BTW My preference is with key-ing things in a Map, as it tends to be easier to troubleshoot and harder to get wrong, but i know we already do ordinals in applyProject)", "author": "findepi", "createdAt": "2020-05-13T13:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MzIxMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424463211", "bodyText": "GroupBys don\u2019t need to go anywhere. The new projections are for the aggregation functions. The group by columns can\u2019t be projected into something else.\nThe problem with using a map is that there\u2019s nothing to key on. The name of the assignment on the engine side is meaningless to the API. You\u2019d end up having to come up with a synthetic mapping, so you might as well use 1,2,3,...", "author": "martint", "createdAt": "2020-05-13T14:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2OTA5OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424469098", "bodyText": "GroupBys don\u2019t need to go anywhere. The new projections are for the aggregation functions. The group by columns can\u2019t be projected into something else.\n\nHow will the agg be pushed down in the case of query like:\nSELECT c, count(*)\nFROM t\nGROUP BY c\n\n?", "author": "findepi", "createdAt": "2020-05-13T14:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNzM5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424507395", "bodyText": "Given\nProject(c, x)\n    Aggregation (x = count(*), group by (c) )\n        Scan(TH0)\n           c = CH0\n\napplyAggregation would be called with:\ntable = TH0\naggregates = [count(*)]\ngroupBy = { {CH0} }\n\nwhich would return:\ntable = TH1\nprojections = [x]\nassignments = {x = CH1}\n\nAnd would result in the following plan:\nProject(c, x)\n    Scan(TH1)\n        c = CH0\n        x = CH1\n\nwhere CH1 is a new column associated with count(*). I think the question you're asking is how is it that CH0 is still there. The semantics of applyAggregation (which should be documented in the javadoc for the API) are that the columns in groupBy should be preserved in the newly produced \"virtual table\", with additional columns for the aggregates.\nFor completeness, if the query was:\nSELECT count(*)\nFROM t\nGROUP BY c\n\nThe plan would get transformed from:\nProject(x)\n    Aggregation (x = count(*), group by (c) )\n        Scan(TH0)\n           c = CH0\n\ninto:\nProject(x)\n    Scan(TH1)\n        c = CH0\n        x = CH1\n\nand then column pruning would kick in and turn it into:\nScan(TH1)\n    x = CH1", "author": "martint", "createdAt": "2020-05-13T14:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MTM5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r425071399", "bodyText": "I think the question you're asking is how is it that CH0 is still there. The semantics of applyAggregation (which should be documented in the javadoc for the API) are that the columns in groupBy should be preserved in the newly produced \"virtual table\", with additional columns for the aggregates.\n\nI am not convinced this is a natural choice, and may be limiting in practice.\nImagine a connector where Table Handle TH0 is just a pointer to memory location containing the data (eg a cache)\nIn this example, applyAggregation would force the cache to be populated with the aggregate calculated, resulting in TH1.\nNow, Column Handle CH0 \"coming from\" TH0 may be totally inadequate within TH1.\nIMO, it would be not only more flexible, but also cleaner from API perspective, to expect we return completely new set of column handles.\nOr, more precisely, leave the column handle reuse decision totally up to the connector. (If column handle is just a name, i will reuse, if it is more pointer-ish, i cannot).", "author": "findepi", "createdAt": "2020-05-14T11:40:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4MjA0Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r425482046", "bodyText": "I think that case is a little far-fetched and wouldn't work in many other scenarios even today. For instance column and table handles are reused across splits. Abstraction-wise, they've always been meant to represent \"a logical reference to a table or column\", and in this case, the virtual table must have the columns that were used for grouping available. Splits are where things become a little more physical. Also, note that limit, sample and filter pushdown don't do this. I see you point, though -- let me think about it a bit more.", "author": "martint", "createdAt": "2020-05-14T23:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Nzc2Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097766", "bodyText": "I have updated the PR with Martin's suggestions. As per my understanding apart from adding the projections to AggregationPushdownResult this also means instead of returning a TableScan the rule will now have to return\nProject TableScan \nSpecially to support the future use case of sum(x+y) -> being converted by the connector to sum(x) + sum(y)\nEven though ProjectionApplicationResult and AggregationPushdownResult are identical I have still kept them as separate classes so as to allow them to evolve independently without requiring SPI changes across the board. Let me know if you would rather have a single class.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NTI3NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432665274", "bodyText": "@findepi and I had an offline conversation and came to the conclusion that we'll need allow the connector to remap the column handles used for the group by keys to new column handles. This will be important for connectors that want to rewrite an aggregation to be served by a pre-materialized table. In that case, the table handle it returns could point directly at that table, and the column handles will need to be proper column handles for that table.\nSo, in summary, we'll need a mapping from old column handle to new column handle for the group by keys in the AggregationApplicationResult class, such as Map<ColumnHandle, ColumnHandle>.", "author": "martint", "createdAt": "2020-05-29T18:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MDE5Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424080196", "bodyText": "Rename to AggregationPushdownResult", "author": "martint", "createdAt": "2020-05-12T22:57:02Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregatePushdownResult.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregatePushdownResult<T>", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzE3NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097175", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MDE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MTI5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424081295", "bodyText": "Let's move Assignment to the top-level and use it here.", "author": "martint", "createdAt": "2020-05-12T22:59:52Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregatePushdownResult.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregatePushdownResult<T>\n+{\n+    private final T handle;\n+    private final List<ProjectionApplicationResult.Assignment> assignments;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzE4Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097183", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MTI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MjMzMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424082333", "bodyText": "Masks are not needed -- they are used as a way to \"implement\" filters and distinct. However, we should have a field for the filter, even if we don't initially support them. That way, connectors will have to explicitly opt out from handling them and it will be easier to introduce support later without changing semantics.", "author": "martint", "createdAt": "2020-05-12T23:03:02Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzkwMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097902", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MjMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MzgyNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424083826", "bodyText": "Let's add another class to represent this. We should eventually retrofit the one in spi.block to use the new one.", "author": "martint", "createdAt": "2020-05-12T23:07:31Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzQ2NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097464", "bodyText": "done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MzgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwNjEzNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r448306137", "bodyText": "We should eventually retrofit the one in spi.block to use the new one.\n\n@martint what did you mean here?", "author": "findepi", "createdAt": "2020-07-01T11:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MzgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDIzMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424084231", "bodyText": "This package is about function implementations. Move this class to the package containing the other pushdown-related classes (ApplyProjectionResult, ApplyAggregationResult, etc).", "author": "martint", "createdAt": "2020-05-12T23:08:29Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzQzOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097438", "bodyText": "done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDQ2MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424084461", "bodyText": "No need to a \"rule set\". This is just a single rule, so remove the wrapper layer.", "author": "martint", "createdAt": "2020-05-12T23:09:16Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Njg3MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096871", "bodyText": "Was working on the grouping set which should only have a different pattern and a different way to extract group by columns. removed for now.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDU3Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424084577", "bodyText": "Rename to PATTERN", "author": "martint", "createdAt": "2020-05-12T23:09:36Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDk4Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424084987", "bodyText": "Also, format as:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n          \n            \n                private static final Pattern<AggregationNode> PATTERN = aggregation()\n          \n          \n            \n                        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "author": "martint", "createdAt": "2020-05-12T23:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Njg4Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096882", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NTU3Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424085572", "bodyText": "This class hierarchy is unnecessary. There's only one implementation. Also, in general, it's better to use composition than inheritance to reuse behavior.", "author": "martint", "createdAt": "2020-05-12T23:12:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Njg5Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096897", "bodyText": "I was working on the GroupingSet rule as well and the only different should be the Capture Pattern and how we extract group by columns.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NTU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NTc2OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424085769", "bodyText": "This comment seems out of date.", "author": "martint", "createdAt": "2020-05-12T23:13:04Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NjkxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096913", "bodyText": "Removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NTc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjEyNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424086126", "bodyText": "Don't abbreviate variable names. In this case, I'd just call it result for brevity.", "author": "martint", "createdAt": "2020-05-12T23:14:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Njk2NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096964", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjMxMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424086310", "bodyText": "Use interface type for collection: List<AggregateFunction>. Also, don't abbreviate names: toAggregateFunction would be better.", "author": "martint", "createdAt": "2020-05-12T23:14:56Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),\n+                            handle,\n+                            newScanOutputs.build(),\n+                            newScanAssignments.build()));\n+        }\n+    }\n+\n+    private ImmutableList<AggregateFunction> toAggFunction(Map<Symbol, AggregationNode.Aggregation> aggregations)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzA5MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097091", "bodyText": "that was my bad, should have noticed the type difference. name changed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjYwMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424086602", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String aggFunctionName = signature.getName();\n          \n          \n            \n                        String name = signature.getName();", "author": "martint", "createdAt": "2020-05-12T23:15:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),\n+                            handle,\n+                            newScanOutputs.build(),\n+                            newScanAssignments.build()));\n+        }\n+    }\n+\n+    private ImmutableList<AggregateFunction> toAggFunction(Map<Symbol, AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (Map.Entry<Symbol, AggregationNode.Aggregation> entry : aggregations.entrySet()) {\n+            AggregationNode.Aggregation aggregation = entry.getValue();\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = typeManager.getType(signature.getReturnType());\n+            String aggFunctionName = signature.getName();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzExMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097113", "bodyText": "done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4ODY0OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424088649", "bodyText": "This constructor is unnecessary at this point. Let's rely one the one below until it becomes clear that we need it.", "author": "martint", "createdAt": "2020-05-12T23:22:33Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.\n+\n+    public AggregateFunction(String projectionName, String name, List<ConnectorExpression> inputs, Type outputType)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzkwNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097906", "bodyText": "Removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4ODY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4ODk5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424088994", "bodyText": "Move outputType before inputs. That way, if we ever have to add other constructors, it's easier to support varargs for the inputs if needed and keep things consistent.", "author": "martint", "createdAt": "2020-05-12T23:23:41Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.\n+\n+    public AggregateFunction(String projectionName, String name, List<ConnectorExpression> inputs, Type outputType)\n+    {\n+        this(projectionName, name, inputs, outputType, Optional.empty(), Optional.empty(), false);\n+    }\n+\n+    public AggregateFunction(String projectionName, String aggregateFunctionName, List<ConnectorExpression> inputs, Type outputType, Optional<List<ConnectorExpression>> sortBy, Optional<Map<ConnectorExpression, SortOrder>> sortOrder, boolean isDistinct)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzkwOQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097909", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4ODk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDk2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424090960", "bodyText": "InternalTypeManager is not meant to be used by anything other that the metadata APIs. use Metadata.getType() in the calls below, instead.", "author": "martint", "createdAt": "2020-05-12T23:29:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Njg5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096890", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxODk5MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424418991", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n          \n          \n            \n                 * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times\n          \n      \n    \n    \n  \n\n-- connector cannot assume a method will be called multiple times (it may or may not)", "author": "findepi", "createdAt": "2020-05-13T13:03:02Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzE5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097195", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxODk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxOTMwMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424419301", "bodyText": "Optional.empty() -> {@code or {@link it", "author": "findepi", "createdAt": "2020-05-13T13:03:30Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzIwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097200", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxOTMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxOTY0Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424419643", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n          \n          \n            \n                 * If the method returns a result, the list of assignments in the result will replace the existing assignments given", "author": "findepi", "createdAt": "2020-05-13T13:04:02Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzIxMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097212", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxOTY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMDgxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424420813", "bodyText": "I understand the \"given\" part. It seems it's OK to return partial assignemnts (they will just be ignored).\n(I think it's ok to drop this part of the sentence)", "author": "findepi", "createdAt": "2020-05-13T13:05:52Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzIxNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097217", "bodyText": "Dropped and modified it now that we don't want to really support this behavior.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMDgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMjIwMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424422201", "bodyText": "what does v2 mean here?", "author": "findepi", "createdAt": "2020-05-13T13:07:50Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzI3MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097270", "bodyText": "those are just variable names, I could make it explicit and I tried to do that by adding {@link Variable} at some places in javadoc.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMjIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMjc3Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424422777", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 *  - aggregate\n          \n          \n            \n                 *  - aggregation", "author": "findepi", "createdAt": "2020-05-13T13:08:43Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzI0NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097245", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMjc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMzMwMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424423303", "bodyText": "i have a warning on this line in IDE, so:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The optimizer would call {@link #applyAggregation} with the following arguments:\n          \n          \n            \n                 * The optimizer would call this method with the following arguments:", "author": "findepi", "createdAt": "2020-05-13T13:09:31Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzI3NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097274", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:29:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMzMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNTM0NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424425345", "bodyText": "aggregates is list, so not sure how this example translates to actual objects\nHowever, I think actually aggregates could be a Map, with io.prestosql.spi.function.AggregateFunction#projectionName removed, replaced with a Map key.\n(same would apply to pre-existing io.prestosql.spi.connector.ProjectionApplicationResult.Assignment.. @martint ?)", "author": "findepi", "createdAt": "2020-05-13T13:12:34Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzI5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097299", "bodyText": "Example updated with the new changes that Martin proposed so it now just requires connector to return List<ConnectorExpression> in the same order as aggregates passed to it so I no longer have io.prestosql.spi.function.AggregateFunction#projectionName", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNTM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNTczMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424425731", "bodyText": "The example should also mention assignments", "author": "findepi", "createdAt": "2020-05-13T13:13:06Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzMxMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097312", "bodyText": "added.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNjAwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424426008", "bodyText": "wrap agg_fn1(...) in {@code", "author": "findepi", "createdAt": "2020-05-13T13:13:28Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzMxOQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097319", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNjAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyODI5Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424428297", "bodyText": "Does the list ordering matter?\nwhere does v2 come from? (groupBy contains column handles only, so we didn't pass \"v2\" in)", "author": "findepi", "createdAt": "2020-05-13T13:16:38Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:\n+     *\n+     * <pre>\n+     * handle = TH1\n+     * assignments = [\n+     *     v0 = CH0 (synthetic column for agg_fn1(a))\n+     *     v1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     v2 = CH3 (for column c)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzM2Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097363", "bodyText": "The java doc is updated so now the variable name is in the returned result's projections, earlier it was just same as whatever was in the outputSymbols of aggregateNode.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyODI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyODYyMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424428621", "bodyText": "nit: put each arg on separate line", "author": "findepi", "createdAt": "2020-05-13T13:17:07Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +832,66 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method to be called multiple times\n+     * during the optimization of a given query.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return Optional.empty() if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignment in the result will replace the existing assignments given\n+     * all the aggregations have a corresponding assignment.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregate\n+     *          v0 = agg_fn1(a)\n+     *          v1 = agg_fn2(b, 2)\n+     *          v2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call {@link #applyAggregation} with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [v0 = agg_fn1 (input=[a]), v1= agg_fn2(input=[b,2])]\n+     * group_by=[c]\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle agg_fn1(...) and agg_fn2(...), it would return:\n+     *\n+     * <pre>\n+     * handle = TH1\n+     * assignments = [\n+     *     v0 = CH0 (synthetic column for agg_fn1(a))\n+     *     v1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     v2 = CH3 (for column c)\n+     * ]\n+     * </pre>\n+     * @param session\n+     * @param handle\n+     * @param aggregates\n+     * @param assignments\n+     * @param groupBy\n+     * @return\n+     */\n+    default Optional<AggregatePushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session, ConnectorTableHandle handle, List<AggregateFunction> aggregates,\n+            Map<String, ColumnHandle> assignments, Optional<List<List<ColumnHandle>>> groupBy)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzQyOQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097429", "bodyText": "done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyODYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMjIzMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424432231", "bodyText": "Do we need Optional here? Empty sortBy list seems to express no sorting (= sorting on a constant) equally well.", "author": "findepi", "createdAt": "2020-05-13T13:22:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Nzg5Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097896", "bodyText": "Removed optional.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:33:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMjIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMzE2Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424433166", "bodyText": "Make sure to reword (or remove) before the PR is merged.", "author": "findepi", "createdAt": "2020-05-13T13:23:17Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzQ4Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097486", "bodyText": "removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzMzE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNDMxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424434313", "bodyText": "nit: put each arg on separate line", "author": "findepi", "createdAt": "2020-05-13T13:24:47Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.\n+\n+    public AggregateFunction(String projectionName, String name, List<ConnectorExpression> inputs, Type outputType)\n+    {\n+        this(projectionName, name, inputs, outputType, Optional.empty(), Optional.empty(), false);\n+    }\n+\n+    public AggregateFunction(String projectionName, String aggregateFunctionName, List<ConnectorExpression> inputs, Type outputType, Optional<List<ConnectorExpression>> sortBy, Optional<Map<ConnectorExpression, SortOrder>> sortOrder, boolean isDistinct)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzkxNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097916", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNDMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNTA0MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424435040", "bodyText": "Make defensive copies fo Lists and Maps (eg unmodifiableList(new ArrayList<>(...)))", "author": "findepi", "createdAt": "2020-05-13T13:25:47Z", "path": "presto-spi/src/main/java/io/prestosql/spi/function/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.function;\n+\n+import io.prestosql.spi.block.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    // Ideally we would want this to actually be a reference to something like AggregationImplementation or aggregationFunction registry so connectors\n+    // can get a one to one mapping from presto's supported aggregate function rather than relying on the name, args and output types.\n+    // Something to check with Martin what he thinks is the best course here, for now just exposing the fields that the connector can use to derive if\n+    // this is an agg function it can handle and information they need to push it down.\n+    private final String projectionName; // may be call it assignmentId? the purpose for this is to uniquely identify an agg but we are just using the projected expression's output symbol as the name here\n+    private final String aggregateFunctionName;\n+    private final List<ConnectorExpression> inputs;\n+    private final Type outputType;\n+    private final Optional<List<ConnectorExpression>> sortBy;\n+    private final Optional<Map<ConnectorExpression, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    // TODO It is unclear if filtering and mask from the aggregate needs to be forwarded to connectors so skipping them for now.\n+\n+    public AggregateFunction(String projectionName, String name, List<ConnectorExpression> inputs, Type outputType)\n+    {\n+        this(projectionName, name, inputs, outputType, Optional.empty(), Optional.empty(), false);\n+    }\n+\n+    public AggregateFunction(String projectionName, String aggregateFunctionName, List<ConnectorExpression> inputs, Type outputType, Optional<List<ConnectorExpression>> sortBy, Optional<Map<ConnectorExpression, SortOrder>> sortOrder, boolean isDistinct)\n+    {\n+        this.projectionName = requireNonNull(projectionName, \"projectionName is null\");\n+        this.aggregateFunctionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.inputs = requireNonNull(inputs, \"inputs is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.sortBy = requireNonNull(sortBy, \"sortBy is null\");\n+        this.sortOrder = requireNonNull(sortOrder, \"sortOrder is null\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzkyNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097925", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNTA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNTgyMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424435822", "bodyText": "Here we need to verify the return data is sane & safe.\nSee #3324", "author": "findepi", "createdAt": "2020-05-13T13:26:51Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1102,26 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregatePushdownResult<TableHandle>> applyAggregation(Session session, TableHandle table, List<AggregateFunction> aggregates, Map<String, ColumnHandle> assignments, Optional<List<List<ColumnHandle>>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregates, assignments, groupBy)\n+                .map(result -> new AggregatePushdownResult<>(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NjczMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096731", "bodyText": "Added. Given the results are identical I extracted a common verification method.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNTgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNjQ3OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424436479", "bodyText": "put each arg on separate line", "author": "findepi", "createdAt": "2020-05-13T13:27:44Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1102,26 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregatePushdownResult<TableHandle>> applyAggregation(Session session, TableHandle table, List<AggregateFunction> aggregates, Map<String, ColumnHandle> assignments, Optional<List<List<ColumnHandle>>> groupBy)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NjcyNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096725", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQzNjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MDU3Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424460572", "bodyText": "connectorTableHandleAggregatePushdownResult -> aggregationPushdownResult", "author": "findepi", "createdAt": "2020-05-13T13:59:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NjkyNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096925", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MDU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MTE1MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424461150", "bodyText": "If this is always present, do we need Optional?", "author": "findepi", "createdAt": "2020-05-13T14:00:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Njk1Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426096952", "bodyText": "It is not always present and in those cases I generally just prefer Optional , for now I have just removed all instances of Optional and converted to List.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MTE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MjIwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424462200", "bodyText": "I don't see how we could do partial pushdown. Replace TODO comment with something objective, but implying a change in the future (a change may or may not happen)\nAlso, isn't it an error condition (throw)?", "author": "findepi", "createdAt": "2020-05-13T14:01:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzA0Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097047", "bodyText": "I wasn't considering this as an error condition as I wanted to let the connector return a partial set and let the rule just ignore it for now and whenever we figure out how to do partial aggregations we could remove the checks from here. I have removed the comment and the verify method now throws the exception.\nI had some ideas about how partial aggs (when connector can support a sub set of aggregate functions completely and not when connectors are returning partially aggregated results) would work at least in some of the cases but overall design needs more thinking.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MjgxMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424462812", "bodyText": "nit: collect(toList()) -> collect(toImmutableList())\n(here & in other places)\n-- we prefer Guava immutable collections", "author": "findepi", "createdAt": "2020-05-13T14:02:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),\n+                            handle,\n+                            newScanOutputs.build(),\n+                            newScanAssignments.build()));\n+        }\n+    }\n+\n+    private ImmutableList<AggregateFunction> toAggFunction(Map<Symbol, AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (Map.Entry<Symbol, AggregationNode.Aggregation> entry : aggregations.entrySet()) {\n+            AggregationNode.Aggregation aggregation = entry.getValue();\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = typeManager.getType(signature.getReturnType());\n+            String aggFunctionName = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)\n+                    .collect(toList());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzEyNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097126", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MjgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MzA2OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424463069", "bodyText": "I don't understand this comment.", "author": "findepi", "createdAt": "2020-05-13T14:03:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),\n+                            handle,\n+                            newScanOutputs.build(),\n+                            newScanAssignments.build()));\n+        }\n+    }\n+\n+    private ImmutableList<AggregateFunction> toAggFunction(Map<Symbol, AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (Map.Entry<Symbol, AggregationNode.Aggregation> entry : aggregations.entrySet()) {\n+            AggregationNode.Aggregation aggregation = entry.getValue();\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = typeManager.getType(signature.getReturnType());\n+            String aggFunctionName = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)\n+                    .collect(toList());\n+            // We could just reject calling down to connector's pushdown if the argument symbol is not already present in table scan's assignment.\n+            if (arguments.size() != symbols.size()) {\n+                return ImmutableList.of();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzE1Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097157", "bodyText": "This was basically to indicate that if a connector only returned a subset of aggregates we would just not pushdown anything, given we no don't want to support that the verify method would throw an exception now and the comment is removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2MzA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2NTIyNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r424465225", "bodyText": "@sopel39 if we reuse original TS id, will the EXPLAIN ANALYZE report (potentially incorrect) pre-CBO stats for this new TS?", "author": "findepi", "createdAt": "2020-05-13T14:05:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregatesIntoTableScanRuleSet.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import io.prestosql.Session;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregatePushdownResult;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.ProjectionApplicationResult;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.function.AggregateFunction;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeManager;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+import io.prestosql.type.InternalTypeManager;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.SystemSessionProperties.isEnableAggPushdown;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PushAggregatesIntoTableScanRuleSet\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> AGG_WITHOUT_PROJECTION = aggregation().with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private TypeManager typeManager;\n+    private final Metadata metadata;\n+\n+    public PushAggregatesIntoTableScanRuleSet(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+        this.typeManager = new InternalTypeManager(metadata);\n+    }\n+\n+    public Set<Rule<AggregationNode>> getRules()\n+    {\n+        return ImmutableSet.of(new PushAggregationToTableScanWithNoProjection());\n+    }\n+\n+    private class PushAggregationToTableScanWithNoProjection\n+            extends BasePushAggregationToTableScan\n+    {\n+        @Override\n+        public Pattern<AggregationNode> getPattern()\n+        {\n+            return AGG_WITHOUT_PROJECTION;\n+        }\n+    }\n+\n+    private abstract class BasePushAggregationToTableScan\n+            implements Rule<AggregationNode>\n+    {\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isEnableAggPushdown(session);\n+        }\n+\n+        @Override\n+        public Result apply(AggregationNode node, Captures captures, Context context)\n+        {\n+            TableScanNode tableScan = captures.get(TABLE_SCAN);\n+            Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                    .entrySet().stream()\n+                    .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+            Map<Symbol, AggregationNode.Aggregation> aggregations = node.getAggregations();\n+\n+            ImmutableList<AggregateFunction> aggregateFunctions = toAggFunction(aggregations);\n+\n+            if (aggregateFunctions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+            if (groupingSets.getGroupingSetCount() > 1) {\n+                // Let the PushAggregationToTableScanWithGroupingSets rule handle this.\n+                return Result.empty();\n+            }\n+\n+            List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                    .map(assignments::get)\n+                    .collect(toList());\n+\n+            Optional<AggregatePushdownResult<TableHandle>> connectorTableHandleAggregatePushdownResult = metadata.applyAggregation(context.getSession(),\n+                    tableScan.getTable(),\n+                    aggregateFunctions,\n+                    assignments,\n+                    Optional.of(ImmutableList.of(groupByColumns)));\n+\n+            if (!connectorTableHandleAggregatePushdownResult.isPresent()) {\n+                return Result.empty();\n+            }\n+\n+            AggregatePushdownResult<TableHandle> aggPushdownResult = connectorTableHandleAggregatePushdownResult.get();\n+\n+            TableHandle handle = aggPushdownResult.getHandle();\n+            ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+            ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+            Map<String, ProjectionApplicationResult.Assignment> nameToAssignment = aggPushdownResult.getAssignments().stream()\n+                    .collect(Collectors.toMap(ProjectionApplicationResult.Assignment::getVariable, Function.identity()));\n+            for (Symbol aggOutputSymbol : node.getOutputSymbols()) {\n+                ProjectionApplicationResult.Assignment assignment = nameToAssignment.get(aggOutputSymbol.getName());\n+\n+                if (assignment == null) {\n+                    //TODO We pushdown all or nothing for V1 but we need to extend this in future.\n+                    return Result.empty();\n+                }\n+                newScanOutputs.add(aggOutputSymbol);\n+                newScanAssignments.put(aggOutputSymbol, assignment.getColumn());\n+            }\n+\n+            return Result.ofPlanNode(\n+                    TableScanNode.newInstance(\n+                            tableScan.getId(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NzA3Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r426097072", "bodyText": "I have assigned a new id for now, I wasn't sure what are the implications of changing it but saw the other rules (projection pushdown) reusing it so was just following that pattern.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-16T00:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2NTIyNQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "url": "https://github.com/trinodb/trino/commit/5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "message": "SPI changes to support nonpartial and complete aggregate pushdown to connectors.\nThe commit also includes the top level optimizer rule", "committedDate": "2020-05-18T21:37:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTM2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428459360", "bodyText": "Place the first argument on the next line", "author": "martint", "createdAt": "2020-05-21T05:54:55Z", "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -352,6 +354,12 @@\n \n     Optional<TableHandle> applySample(Session session, TableHandle table, SampleType sampleType, double sampleRatio);\n \n+    Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDI2Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130262", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTI5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428461299", "bodyText": "Rename to AggregationApplicationResult for consistency with ProjectionApplicationResult", "author": "martint", "createdAt": "2020-05-21T06:01:32Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDIxMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130212", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzA4MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463081", "bodyText": "Format as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(\n          \n          \n            \n                                    result -> {\n          \n          \n            \n                            .map(result -> {", "author": "martint", "createdAt": "2020-05-21T06:07:51Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE4OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130188", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzU2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463560", "bodyText": "Format as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });\n          \n          \n            \n                            .findAny()\n          \n          \n            \n                            .ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "author": "martint", "createdAt": "2020-05-21T06:09:39Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {\n+                            verifyProjection(table, result.getProjections(), result.getAssignments(), aggregations.size());\n+\n+                            return new AggregationPushdownResult<>(\n+                                    new TableHandle(catalogName, result.getHandle(), table.getTransaction(), Optional.empty()),\n+                                    result.getProjections(),\n+                                    result.getAssignments());\n+                        });\n+    }\n+\n+    private void verifyProjection(TableHandle table, List<ConnectorExpression> projections, List<Assignment> assignments, int expectedProjectionSize)\n+    {\n+        projections.forEach(projection -> requireNonNull(projection, \"one of the projections is null\"));\n+        assignments.forEach(assignment -> requireNonNull(assignment, \"one of the assignments is null\"));\n+\n+        verify(\n+                expectedProjectionSize == projections.size(),\n+                \"ConnectorMetadata returned invalid number of projections: %s instead of %s for %s\",\n+                projections.size(),\n+                expectedProjectionSize,\n+                table);\n+\n+        Set<String> assignedVariables = assignments.stream()\n+                .map(Assignment::getVariable)\n+                .collect(toImmutableSet());\n+        projections.stream()\n+                .flatMap(connectorExpression -> ConnectorExpressions.extractVariables(connectorExpression).stream())\n+                .map(Variable::getName)\n+                .filter(variableName -> !assignedVariables.contains(variableName))\n+                .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130165", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDI5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464294", "bodyText": "Put the first argument on the next line", "author": "martint", "createdAt": "2020-05-21T06:12:12Z", "path": "presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java", "diffHunk": "@@ -447,6 +449,16 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n         return Optional.empty();\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE0Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130143", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDM4Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464387", "bodyText": "First argument on the next line", "author": "martint", "createdAt": "2020-05-21T06:12:30Z", "path": "presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java", "diffHunk": "@@ -687,6 +689,18 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n         }\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDEyMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130121", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTQ0Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428465443", "bodyText": "It's not a great idea to piggyback on Map.Entry to represent a sort item. For one, it doesn't clearly convey what the key and value represent. Let's create a dedicated class named SortItem.", "author": "martint", "createdAt": "2020-05-21T06:15:51Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDEwNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130104", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NjIwNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428466207", "bodyText": "requireNonNull", "author": "martint", "createdAt": "2020-05-21T06:18:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n+        this.filter = filter;", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA4OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130089", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NjIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NzA1MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428467051", "bodyText": "Move the requireNonNull for the arguments outside of the call. Having them inline muddles the code and makes it harder to read. Also, use List.copyOf():\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n          \n          \n            \n                    this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n          \n          \n            \n                    requireNonNull(inputs, \"inputs is null\");\n          \n          \n            \n                    requireNonNull(sortOrder, \"sortOrder is null\")\n          \n          \n            \n                    \n          \n          \n            \n                    this.inputs = List.copyOf(inputs);\n          \n          \n            \n                    this.sortOrder = List.copyOf(inputs);", "author": "martint", "createdAt": "2020-05-21T06:20:53Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA1OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130058", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NzA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2ODA5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428468099", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n          \n          \n            \n                    this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));\n          \n          \n            \n                    requireNonNull(projections, \"projections is null\");\n          \n          \n            \n                    requireNonNull(assignments, \"assignment is null\");\n          \n          \n            \n                    this.projections = List.copyOf(projections);\n          \n          \n            \n                    this.assignments = List.copyOf(assignments);", "author": "martint", "createdAt": "2020-05-21T06:24:07Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>\n+{\n+    private final T handle;\n+    private final List<ConnectorExpression> projections;\n+    private final List<Assignment> assignments;\n+\n+    public AggregationPushdownResult(T handle, List<ConnectorExpression> projections, List<Assignment> assignments)\n+    {\n+        this.handle = requireNonNull(handle, \"handle is null\");\n+        this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n+        this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA0OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130048", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2ODA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjMzOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906338", "bodyText": "We generally place the .stream() call next to the previous one as it's immaterial to understanding what the transformation does:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .entrySet()\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .entrySet().stream()", "author": "martint", "createdAt": "2020-05-21T20:49:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDAzMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130031", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n          \n          \n            \n                            .stream()\n          \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations.stream()", "author": "martint", "createdAt": "2020-05-21T20:49:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwODUwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428908508", "bodyText": "If you change toAggregateFunction to process a single aggregation, you can rewrite this as:\nList<AggregateFunction> aggregateFunctions = aggregations.stream()\n        .map(Entry::getValue)\n        .map(this::toAggregateFunction)\n        .collect(toImmutableList());\nAlso, since some aggregations are not candidates to be pushed down (e.g., if they contain lambda expressions), add a check before that bails out early if the condition doesn't hold, although it'd be it'd be better to add this condition to the pattern:\n    private static final Pattern<AggregationNode> PATTERN = aggregation()\n            .matching(PushAggregationIntoTableScan::allArgumentsAreSimpleReferences) // skip arguments that are, for instance, lambda expressions\n            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n\n    private static boolean allArgumentsAreSimpleReferences(AggregationNode node)\n    {\n        return node.getAggregations()\n                .values().stream()\n                .flatMap(aggregation -> aggregation.getArguments().stream())\n                .allMatch(SymbolReference.class::isInstance)\n    }", "author": "martint", "createdAt": "2020-05-21T20:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTk4Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129983", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMjg4MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428912880", "bodyText": "Add this to the pattern:\nprivate static final Pattern<AggregationNode> PATTERN = aggregation()\n        .matching(node -> node.getGroupingSets().getGroupingSetCount() == 1)\n        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "author": "martint", "createdAt": "2020-05-21T21:02:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTk1OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129958", "bodyText": "Changed the pattern to capture this and no masks.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMjg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxODczNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428918734", "bodyText": "These variables are used only once. Inline them where they are referenced.", "author": "martint", "createdAt": "2020-05-21T21:15:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTY1Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129656", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxODczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTEzMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919130", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "author": "martint", "createdAt": "2020-05-21T21:16:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTYzMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129632", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTcxMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919710", "bodyText": "This can only be a SymbolReference, so it'd be more appropriate to do:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .map(SymbolsExtractor::extractUnique)\n          \n          \n            \n                                .flatMap(Collection::stream)\n          \n          \n            \n                                .map(Symbol::from)", "author": "martint", "createdAt": "2020-05-21T21:17:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTU4NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129585", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTg0Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919842", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "author": "martint", "createdAt": "2020-05-21T21:18:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)\n+                    .collect(toImmutableList());\n+\n+            if (arguments.size() != symbols.size()) {\n+                return ImmutableList.of();\n+            }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTUwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129500", "bodyText": "removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428922849", "bodyText": "Once you apply all the suggestions above and below, this method can simplify to:\nprivate AggregateFunction toAggregateFunction(AggregationNode.Aggregation aggregation)\n{\n    Signature signature = aggregation.getResolvedFunction().getSignature();\n\n    ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n    for (int i = 0; i < aggregation.getArguments().size(); i++) {\n        SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n        arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n    }\n\n    Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n    Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n            orderings.getOrderBy().stream()\n                    .map(orderBy -> new AbstractMap.SimpleEntry<>(\n                            orderBy.getName(),\n                            SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n                    .collect(toImmutableList()));\n\n    return new AggregateFunction(\n            signature.getName(),\n            metadata.getType(signature.getReturnType()),\n            arguments.build(),\n            sortBy.orElse(ImmutableList.of()),\n            aggregation.isDistinct(),\n            aggregation.getFilter().map(Symbol::getName));\n}", "author": "martint", "createdAt": "2020-05-21T21:24:03Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTAwNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899005", "bodyText": "what about aggregation.getMask()? we should verify aggregation.getMask() is not present (yet).", "author": "findepi", "createdAt": "2020-05-25T12:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTQyNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129424", "bodyText": "Done, added check for masks in pattern.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNDI5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428924290", "bodyText": "This is incorrect. The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.", "author": "martint", "createdAt": "2020-05-21T21:26:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTM2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129365", "bodyText": "comment removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNDI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NDk5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429864990", "bodyText": "6d9d47e", "author": "findepi", "createdAt": "2020-05-25T10:37:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODczMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128731", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NDk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NjMzNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429866335", "bodyText": "Why not ImmutableList.of(groupByColumns) always?\n[ [] ] would correctly describe the fact that there is 1 grouping set and that it is a global aggregation.", "author": "findepi", "createdAt": "2020-05-25T10:41:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODcwOQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128709", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NjMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MDUxNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429870514", "bodyText": "i think #3697 (comment) is still waiting for final resolution. @martint ?\n(nit: if this stays, would be good to avoid \"unioned\" as intellij spellchecker highlights this)", "author": "findepi", "createdAt": "2020-05-25T10:51:58Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODY3OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128679", "bodyText": "unioned removed. I have assumed @martint 's last comment is what we want the API to do and changed both the contract and docs to reflect that. Let me know if there is a gap in my understanding vs what is expected.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MDUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTA5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "author": "findepi", "createdAt": "2020-05-25T10:53:23Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODA2Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128062", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTQ5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n          \n          \n            \n                 *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n          \n      \n    \n    \n  \n\notherwise you would need to use &lt; &gt;", "author": "findepi", "createdAt": "2020-05-25T10:54:24Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODA0MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128041", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTkwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * group_by=[{@link ColumnHandle} CH2]\n          \n          \n            \n                 * group_by=[[{@link ColumnHandle} CH2]]\n          \n      \n    \n    \n  \n\n(it's list of lists)", "author": "findepi", "createdAt": "2020-05-25T10:55:33Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjA5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872099", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * assignments = {a = CH0, b=CH1, c=CH2}\n          \n          \n            \n                 * assignments = {a = CH0, b = CH1, c = CH2}", "author": "findepi", "createdAt": "2020-05-25T10:56:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjgzNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872834", "bodyText": "c assignments seems redundant, as there is no c variable", "author": "findepi", "createdAt": "2020-05-25T10:57:50Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mjk5Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872996", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *  - aggregation\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = group_by c\n          \n          \n            \n                 *  - aggregation (GROUP BY c)\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = c", "author": "findepi", "createdAt": "2020-05-25T10:58:15Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzM3Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873373", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "author": "findepi", "createdAt": "2020-05-25T10:59:19Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzY1Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873653", "bodyText": "i like the way you wrote this!\njust consider adding an indent (here and following).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 * handle = TH1\n          \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 *     handle = TH1", "author": "findepi", "createdAt": "2020-05-25T11:00:01Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mzk3MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873970", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n          \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>", "author": "findepi", "createdAt": "2020-05-25T11:00:51Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDIxNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874217", "bodyText": "CH0, CH1, and CH2 are already used above", "author": "findepi", "createdAt": "2020-05-25T11:01:31Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDQxNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874415", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n          \n          \n            \n                 * if the connector only knows how to handle {@code agg_fn1}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.", "author": "findepi", "createdAt": "2020-05-25T11:02:03Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDc2OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874769", "bodyText": "Should we call this groupingSets? @martint ?", "author": "findepi", "createdAt": "2020-05-25T11:03:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     */\n+    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+            ConnectorSession session,\n+            ConnectorTableHandle handle,\n+            List<AggregateFunction> aggregates,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NTY5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429875695", "bodyText": "isDistinct is primitive, so\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n          \n          \n            \n                    this.isDistinct = isDistinct;", "author": "findepi", "createdAt": "2020-05-25T11:05:33Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NTY5Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429885693", "bodyText": "Moving out Assignment as a top level class touches a lot of files, that are otherwise unrelated to the change.\nCan you please extract this to a preparatory commit?", "author": "findepi", "createdAt": "2020-05-25T11:31:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -91,7 +92,7 @@ public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n             handle = result.get().getHandle();\n \n             Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n-                    .collect(toImmutableMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));\n+                    .collect(toImmutableMap(Assignment::getVariable, Assignment::getColumn));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4Nzg2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429887865", "bodyText": "Why?\nIf you remove this, the rule would be applicable also for queries like\nSELECT DISTINCT regionkey FROM tpch.tiny.nation;", "author": "findepi", "createdAt": "2020-05-25T11:36:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429891044", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern<AggregationNode> PATTERN = aggregation()\n          \n          \n            \n                        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n          \n            \n                    private static final Pattern<AggregationNode> PATTERN =\n          \n          \n            \n                        aggregation()\n          \n          \n            \n                                .with(step().equalTo(SINGLE))\n          \n          \n            \n                                .matching(node -> node.getGroupingSetCount() == 1)\n          \n          \n            \n                                .matching(node -> node.getGroupIdSymbol().isEmpty())\n          \n          \n            \n                                .matching(node -> node.getHashSymbol().isEmpty())\n          \n          \n            \n                                .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n      \n    \n    \n  \n\n\na few additional checks\nif you move aggregation() to new line, this fill be formatted better", "author": "findepi", "createdAt": "2020-05-25T11:44:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTM5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899390", "bodyText": "plus additional conditions\n\n@martint 's all agg args are symbols condition\nagg mask is not present\nanything else?", "author": "findepi", "createdAt": "2020-05-25T12:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MjcxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429892713", "bodyText": "what does \"partial project\" mean here? (can this be  newProjections?)", "author": "findepi", "createdAt": "2020-05-25T11:49:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODAxNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128015", "bodyText": "renamed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MjcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MzEzMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429893130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    groupingSets.getGroupingKeys().stream()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n          \n            \n                    groupingSets.getGroupingKeys()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n      \n    \n    \n  \n\n-- use Collection#forEach without going thru Stream", "author": "findepi", "createdAt": "2020-05-25T11:50:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzcxNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127716", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MzEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NDk0Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429894946", "bodyText": "add verify(aggregationOutputSymbols.size() == newPartialProjections.size()); just before this line as this is where you depend on this\nno need for good exc msg, since it's in fact already validated in MetadataManager, so it's more for documenting assumptions/dependencies of the code here", "author": "findepi", "createdAt": "2020-05-25T11:54:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzcwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127700", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NDk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429896486", "bodyText": "Optional<Variable>", "author": "findepi", "createdAt": "2020-05-25T11:58:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzY4Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127682", "bodyText": "Not sure about this, Why would this need to be a variable given the filter on the agg side is just a Symbol?", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NTI5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432385294", "bodyText": "Symbols (engine things) are mapped to Variables in ConnectorExpression.\nUsing Variable here would give semantics to this field -- connector would know it needs to check assignments to know which column handle this is.", "author": "findepi", "createdAt": "2020-05-29T10:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMTYwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r434531600", "bodyText": "BTW why isn't filter a Optional<ConnectorExpression> (or ConnectorExpression without Optional,  using new Constant(true, BOOLEAN) instead of empty).\n@Parth-Brahmbhatt  @martint did you discuss this bit already?", "author": "findepi", "createdAt": "2020-06-03T12:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NTM5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r436055394", "bodyText": "We haven't discussed this, originally I did not have mask or filter as I couldn't quite understand how those were used. I will figure out how to get the corresponding connector expression from the symbol and update the PR today.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-05T17:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NDUxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r436144513", "bodyText": "we haven't discussed this, I originally had no filters or masks as I did not completely understand what masks are for. @martint asked to add the filter in this PR in the first pass so the connectors have to explicitly decide to not handle them. For the current rule given it will only be matched when agg is followed by scan node the only possible place to look for filter symbol is tablescan assignment so I think it makes sense to just map it to Variable for now. I can't think of a scenario where we match this rule and it has a filter but the symbol is not in tablescan assignment so I have not added a check for that If you think we should add a defensive check I can add a condition.\nI personally prefer Optional so I have kept it as is, let me know if you would like me to remove Optional.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-05T20:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNzM4NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r437307385", "bodyText": "Apparently  aggregateFunctions.size() == aggregations.size(), so you don't need the && part.", "author": "findepi", "createdAt": "2020-06-09T10:29:53Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -119,7 +120,7 @@ public Result apply(AggregationNode node, Captures captures, Context context)\n                 .map(Entry::getKey)\n                 .collect(toImmutableList());\n \n-        if (aggregateFunctions.isEmpty()) {\n+        if (aggregateFunctions.isEmpty() && !aggregations.isEmpty()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MDg2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r437770860", "bodyText": "I forgot that I no longer return empty list when an aggregate can not be transformed as we already check for only simple symbol references. This check makes no sense any more.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-09T23:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNzM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNzcyOQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r437307729", "bodyText": "update indent of the following lines", "author": "findepi", "createdAt": "2020-06-09T10:30:33Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -62,7 +62,8 @@\n {\n     private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n \n-    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+    private static final Pattern<AggregationNode> PATTERN =\n+            aggregation()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MDM3NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r437770375", "bodyText": "updated.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-09T23:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNzcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMxOTgzMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r437319832", "bodyText": "Intellij warns me\n\n'Map<String, ColumnHandle>' may not contain keys of type 'Symbol'\n\nand indeed i get NPE in the next line, as originalColumnHandle comes out as null", "author": "findepi", "createdAt": "2020-06-09T10:54:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationApplicationResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortItem;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN =\n+            aggregation()\n+            // skip arguments that are, for instance, lambda expressions\n+            .matching(PushAggregationIntoTableScan::allArgumentsAreSimpleReferences)\n+            .matching(node -> node.getGroupingSets().getGroupingSetCount() <= 1)\n+            .matching(PushAggregationIntoTableScan::hasNoMasks)\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    private static boolean allArgumentsAreSimpleReferences(AggregationNode node)\n+    {\n+        return node.getAggregations()\n+                .values().stream()\n+                .flatMap(aggregation -> aggregation.getArguments().stream())\n+                .allMatch(SymbolReference.class::isInstance);\n+    }\n+\n+    private static boolean hasNoMasks(AggregationNode node)\n+    {\n+        return !node.getAggregations()\n+                .values().stream()\n+                .map(aggregation -> aggregation.getMask().isPresent())\n+                .anyMatch(isMaskPresent -> isMaskPresent);\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet().stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = aggregations.stream()\n+                .map(Entry::getValue)\n+                .map(aggregation -> toAggregateFunction(context, aggregation))\n+                .collect(toImmutableList());\n+\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty() && !aggregations.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                ImmutableList.of(groupByColumns));\n+\n+        if (aggregationPushdownResult.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationApplicationResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        // The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableBiMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableBiMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n+\n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MTYwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r437771608", "bodyText": "updated the code so it now does assignments.get(groupBySymbol.getName()); so there is no warning anymore. I think it is a valid assumption though that the groupBy Symbol name must be present in original scan assignment. If you think that is a wrong assumption I can add a defensive check and return an empty plan if the defensive check fails.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-09T23:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMxOTgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2NzI2Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r438967267", "bodyText": "Let's call this groupingColumnMapping. Grouping sets are made of sets of columns, but this method is not specifically about the grouping sets themselves.", "author": "martint", "createdAt": "2020-06-11T17:51:59Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationApplicationResult<T>\n+{\n+    private final T handle;\n+    private final List<ConnectorExpression> projections;\n+    private final List<Assignment> assignments;\n+    private final Map<ColumnHandle, ColumnHandle> groupingSetMapping;\n+\n+    public AggregationApplicationResult(\n+            T handle,\n+            List<ConnectorExpression> projections,\n+            List<Assignment> assignments,\n+            Map<ColumnHandle, ColumnHandle> groupingSetMapping)\n+    {\n+        this.handle = requireNonNull(handle, \"handle is null\");\n+        requireNonNull(groupingSetMapping, \"goupingSetMapping is null\");\n+        requireNonNull(projections, \"projections is null\");\n+        requireNonNull(assignments, \"assignment is null\");\n+        this.groupingSetMapping = Map.copyOf(groupingSetMapping);\n+        this.projections = List.copyOf(projections);\n+        this.assignments = List.copyOf(assignments);\n+    }\n+\n+    public T getHandle()\n+    {\n+        return handle;\n+    }\n+\n+    public List<ConnectorExpression> getProjections()\n+    {\n+        return projections;\n+    }\n+\n+    public List<Assignment> getAssignments()\n+    {\n+        return assignments;\n+    }\n+\n+    public Map<ColumnHandle, ColumnHandle> getGroupingSetMapping()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNjIyOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r439036228", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-11T20:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2NzI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5NzU1Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r484797557", "bodyText": "@Parth-Brahmbhatt @martint what is groupingColumnMapping used for ? Thanks.", "author": "armsword", "createdAt": "2020-09-08T09:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2NzI2Nw=="}], "type": "inlineReview"}, {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "message": "Add support for aggregation pushdow", "committedDate": "2020-06-11T18:05:43Z", "type": "commit"}, {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "message": "Add support for aggregation pushdow", "committedDate": "2020-06-11T18:05:43Z", "type": "forcePushed"}]}