{"pr_number": 4886, "pr_title": "128 bit arithmetic upgrades", "pr_createdAt": "2020-08-19T08:18:19Z", "pr_url": "https://github.com/trinodb/trino/pull/4886", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxODgyOQ==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r472918829", "bodyText": "It appears that bit shift is slightly better\n\nWhat do you mean better? faster?", "author": "kokosing", "createdAt": "2020-08-19T10:14:17Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -724,27 +724,27 @@ public static void negate(Slice decimal)\n ", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk3MTQ1MQ==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r472971451", "bodyText": "faster obviously. good catch.", "author": "skrzypo987", "createdAt": "2020-08-19T11:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxODgyOQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDE5OA==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484820198", "bodyText": "is the SIGN_INT_MASK still needed?", "author": "sopel39", "createdAt": "2020-09-08T10:38:32Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -724,27 +724,27 @@ public static void negate(Slice decimal)\n \n     public static boolean isStrictlyNegative(Slice decimal)\n     {\n-        return isNegative(decimal) && (getLong(decimal, 0) != 0 || getLong(decimal, 1) != 0);\n+        return isStrictlyNegative(getRawLong(decimal, 0), getRawLong(decimal, 1));\n     }\n \n     public static boolean isStrictlyNegative(long rawLow, long rawHigh)\n     {\n-        return isNegative(rawLow, rawHigh) && (rawLow != 0 || unpackUnsignedLong(rawHigh) != 0);\n+        return isNegative(rawHigh) && (rawLow != 0 || unpackUnsignedLong(rawHigh) != 0);\n     }\n \n     private static boolean isNegative(int lastRawHigh)\n     {\n-        return (lastRawHigh & SIGN_INT_MASK) != 0;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg3OTE4NQ==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484879185", "bodyText": "Used 7 times", "author": "skrzypo987", "createdAt": "2020-09-08T12:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyODA2Ng==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484828066", "bodyText": "Could you explain why it works? Why do we need to add MIN_VALUE to both sides? Please add a comment in code also.", "author": "sopel39", "createdAt": "2020-09-08T10:53:54Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -353,77 +352,41 @@ else if (compare < 0) {\n      */\n     private static long addUnsignedReturnOverflow(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) + toUnsignedLong(r0);\n+        long intermediateResult = l0 + r0;\n+        long z0 = intermediateResult;\n+        // Unsigned compare\n+        int overflow = intermediateResult + Long.MIN_VALUE < l0 + Long.MIN_VALUE ? 1 : 0;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MDkwNw==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484860907", "bodyText": "This is Long.compareUnsigned() inlined.\nI added a comment", "author": "skrzypo987", "createdAt": "2020-09-08T11:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyODA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyODgxNA==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484828814", "bodyText": "Could you explain why it works? Why do we need to add MIN_VALUE to both sides? Please add a comment in code also.", "author": "sopel39", "createdAt": "2020-09-08T10:55:13Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -353,77 +352,41 @@ else if (compare < 0) {\n      */\n     private static long addUnsignedReturnOverflow(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) + toUnsignedLong(r0);\n+        long intermediateResult = l0 + r0;\n+        long z0 = intermediateResult;\n+        // Unsigned compare\n+        int overflow = intermediateResult + Long.MIN_VALUE < l0 + Long.MIN_VALUE ? 1 : 0;\n \n-        int z0 = (int) intermediateResult;\n+        intermediateResult = l1 + r1 + overflow;\n+        long z1 = intermediateResult & (~SIGN_LONG_MASK);\n+        pack(result, z0, z1, resultNegative);\n \n-        intermediateResult = toUnsignedLong(l1) + toUnsignedLong(r1) + (intermediateResult >>> 32);\n-\n-        int z1 = (int) intermediateResult;\n-\n-        intermediateResult = toUnsignedLong(l2) + toUnsignedLong(r2) + (intermediateResult >>> 32);\n-\n-        int z2 = (int) intermediateResult;\n-\n-        intermediateResult = toUnsignedLong(l3) + toUnsignedLong(r3) + (intermediateResult >>> 32);\n-\n-        int z3 = (int) intermediateResult & (~SIGN_INT_MASK);\n-\n-        pack(result, z0, z1, z2, z3, resultNegative);\n-\n-        return intermediateResult >> 31;\n+        return intermediateResult >>> 63;\n     }\n \n     /**\n      * This method ignores signs of the left and right and assumes that left is greater then right\n      */\n     private static void subtractUnsigned(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n-\n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) - toUnsignedLong(r0);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        int z0 = (int) intermediateResult;\n+        long z0 = l0 - r0;\n+        // Unsigned compare\n+        int overflow = z0 + Long.MIN_VALUE > l0 + Long.MIN_VALUE ? 1 : 0;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyOTYyMQ==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484829621", "bodyText": "intermediateResult is not need until this point", "author": "sopel39", "createdAt": "2020-09-08T10:56:45Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -353,77 +352,41 @@ else if (compare < 0) {\n      */\n     private static long addUnsignedReturnOverflow(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) + toUnsignedLong(r0);\n+        long intermediateResult = l0 + r0;\n+        long z0 = intermediateResult;\n+        // Unsigned compare\n+        int overflow = intermediateResult + Long.MIN_VALUE < l0 + Long.MIN_VALUE ? 1 : 0;\n \n-        int z0 = (int) intermediateResult;\n+        intermediateResult = l1 + r1 + overflow;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg3MTY0MA==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484871640", "bodyText": "corrected", "author": "skrzypo987", "createdAt": "2020-09-08T12:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyOTYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzMDM5NQ==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484830395", "bodyText": "previously we added (intermediateResult >> 32), but now we remove overflow. Is this correct?", "author": "sopel39", "createdAt": "2020-09-08T10:58:14Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -353,77 +352,41 @@ else if (compare < 0) {\n      */\n     private static long addUnsignedReturnOverflow(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) + toUnsignedLong(r0);\n+        long intermediateResult = l0 + r0;\n+        long z0 = intermediateResult;\n+        // Unsigned compare\n+        int overflow = intermediateResult + Long.MIN_VALUE < l0 + Long.MIN_VALUE ? 1 : 0;\n \n-        int z0 = (int) intermediateResult;\n+        intermediateResult = l1 + r1 + overflow;\n+        long z1 = intermediateResult & (~SIGN_LONG_MASK);\n+        pack(result, z0, z1, resultNegative);\n \n-        intermediateResult = toUnsignedLong(l1) + toUnsignedLong(r1) + (intermediateResult >>> 32);\n-\n-        int z1 = (int) intermediateResult;\n-\n-        intermediateResult = toUnsignedLong(l2) + toUnsignedLong(r2) + (intermediateResult >>> 32);\n-\n-        int z2 = (int) intermediateResult;\n-\n-        intermediateResult = toUnsignedLong(l3) + toUnsignedLong(r3) + (intermediateResult >>> 32);\n-\n-        int z3 = (int) intermediateResult & (~SIGN_INT_MASK);\n-\n-        pack(result, z0, z1, z2, z3, resultNegative);\n-\n-        return intermediateResult >> 31;\n+        return intermediateResult >>> 63;\n     }\n \n     /**\n      * This method ignores signs of the left and right and assumes that left is greater then right\n      */\n     private static void subtractUnsigned(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n-\n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) - toUnsignedLong(r0);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        int z0 = (int) intermediateResult;\n+        long z0 = l0 - r0;\n+        // Unsigned compare\n+        int overflow = z0 + Long.MIN_VALUE > l0 + Long.MIN_VALUE ? 1 : 0;\n+        long z1 = l1 - r1 - overflow;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg3ODc4MQ==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484878781", "bodyText": "The logic of subtraction is different than before\nThe previous one was just simple 4x subtraction on two 32-bit values within 64-bit placeholder. The intermediateResult >> 32 was the remainder, not the overflow.\nNow the overflow is just a flag indicating whether r0 > l0 so that we need to \"borrow\" 2^64 from l1.", "author": "skrzypo987", "createdAt": "2020-09-08T12:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzMDM5NQ=="}], "type": "inlineReview"}, {"oid": "71a8fcf46a6ddefaaa1e14ec41d621b75677491e", "url": "https://github.com/trinodb/trino/commit/71a8fcf46a6ddefaaa1e14ec41d621b75677491e", "message": "Change way of checking sign in 128-bit arithmetic\n\nIt appears that bit shift is slightly faster that &", "committedDate": "2020-09-08T12:15:37Z", "type": "commit"}, {"oid": "eae6fbc4ee1bf174be66a53c741ccf43526e28cf", "url": "https://github.com/trinodb/trino/commit/eae6fbc4ee1bf174be66a53c741ccf43526e28cf", "message": "Add unscaled values to decimal operators addition benchmark\n\nAddition benchmark relied only on values that needed rescaling,\nwhich is a multiplication by a power of 10.\nBenchmarking unscaled values makes addition benchmark more synthetic.", "committedDate": "2020-09-08T12:15:37Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkzODE0NA==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484938144", "bodyText": "It's not inlined method as unsignedCompare can return -1, 0 or 1.\nCould you extract unsignedIsSmaller method and add a comment what it's based on?", "author": "sopel39", "createdAt": "2020-09-08T13:53:02Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -353,77 +352,42 @@ else if (compare < 0) {\n      */\n     private static long addUnsignedReturnOverflow(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) + toUnsignedLong(r0);\n+        long z0 = l0 + r0;\n+        // Long.unsignedCompare() inlined", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0MDIyOQ==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484940229", "bodyText": "similar here, it's not unsignedCompare inlined. Please extract a separate method and add a comment what it's based on.", "author": "sopel39", "createdAt": "2020-09-08T13:55:51Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -353,77 +352,42 @@ else if (compare < 0) {\n      */\n     private static long addUnsignedReturnOverflow(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) + toUnsignedLong(r0);\n+        long z0 = l0 + r0;\n+        // Long.unsignedCompare() inlined\n+        // (unsigned) z0 < (unsigned) l0\n+        int overflow = z0 + Long.MIN_VALUE < l0 + Long.MIN_VALUE ? 1 : 0;\n \n-        int z0 = (int) intermediateResult;\n+        long intermediateResult = l1 + r1 + overflow;\n+        long z1 = intermediateResult & (~SIGN_LONG_MASK);\n+        pack(result, z0, z1, resultNegative);\n \n-        intermediateResult = toUnsignedLong(l1) + toUnsignedLong(r1) + (intermediateResult >>> 32);\n-\n-        int z1 = (int) intermediateResult;\n-\n-        intermediateResult = toUnsignedLong(l2) + toUnsignedLong(r2) + (intermediateResult >>> 32);\n-\n-        int z2 = (int) intermediateResult;\n-\n-        intermediateResult = toUnsignedLong(l3) + toUnsignedLong(r3) + (intermediateResult >>> 32);\n-\n-        int z3 = (int) intermediateResult & (~SIGN_INT_MASK);\n-\n-        pack(result, z0, z1, z2, z3, resultNegative);\n-\n-        return intermediateResult >> 31;\n+        return intermediateResult >>> 63;\n     }\n \n     /**\n      * This method ignores signs of the left and right and assumes that left is greater then right\n      */\n     private static void subtractUnsigned(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n-\n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) - toUnsignedLong(r0);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        int z0 = (int) intermediateResult;\n+        long z0 = l0 - r0;\n+        // Long.unsignedCompare() inlined", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0MTU4Mg==", "url": "https://github.com/trinodb/trino/pull/4886#discussion_r484941582", "bodyText": "should this be called underflow?", "author": "sopel39", "createdAt": "2020-09-08T13:57:31Z", "path": "presto-spi/src/main/java/io/prestosql/spi/type/UnscaledDecimal128Arithmetic.java", "diffHunk": "@@ -353,77 +352,42 @@ else if (compare < 0) {\n      */\n     private static long addUnsignedReturnOverflow(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) + toUnsignedLong(r0);\n+        long z0 = l0 + r0;\n+        // Long.unsignedCompare() inlined\n+        // (unsigned) z0 < (unsigned) l0\n+        int overflow = z0 + Long.MIN_VALUE < l0 + Long.MIN_VALUE ? 1 : 0;\n \n-        int z0 = (int) intermediateResult;\n+        long intermediateResult = l1 + r1 + overflow;\n+        long z1 = intermediateResult & (~SIGN_LONG_MASK);\n+        pack(result, z0, z1, resultNegative);\n \n-        intermediateResult = toUnsignedLong(l1) + toUnsignedLong(r1) + (intermediateResult >>> 32);\n-\n-        int z1 = (int) intermediateResult;\n-\n-        intermediateResult = toUnsignedLong(l2) + toUnsignedLong(r2) + (intermediateResult >>> 32);\n-\n-        int z2 = (int) intermediateResult;\n-\n-        intermediateResult = toUnsignedLong(l3) + toUnsignedLong(r3) + (intermediateResult >>> 32);\n-\n-        int z3 = (int) intermediateResult & (~SIGN_INT_MASK);\n-\n-        pack(result, z0, z1, z2, z3, resultNegative);\n-\n-        return intermediateResult >> 31;\n+        return intermediateResult >>> 63;\n     }\n \n     /**\n      * This method ignores signs of the left and right and assumes that left is greater then right\n      */\n     private static void subtractUnsigned(Slice left, Slice right, Slice result, boolean resultNegative)\n     {\n-        // TODO: consider two 7 bytes operations\n-        int l0 = getInt(left, 0);\n-        int l1 = getInt(left, 1);\n-        int l2 = getInt(left, 2);\n-        int l3 = getInt(left, 3);\n-\n-        int r0 = getInt(right, 0);\n-        int r1 = getInt(right, 1);\n-        int r2 = getInt(right, 2);\n-        int r3 = getInt(right, 3);\n+        long l0 = getLong(left, 0);\n+        long l1 = getLong(left, 1);\n \n-        long intermediateResult;\n-        intermediateResult = toUnsignedLong(l0) - toUnsignedLong(r0);\n+        long r0 = getLong(right, 0);\n+        long r1 = getLong(right, 1);\n \n-        int z0 = (int) intermediateResult;\n+        long z0 = l0 - r0;\n+        // Long.unsignedCompare() inlined\n+        // (unsigned) z0 > (unsigned) l0\n+        int overflow = z0 + Long.MIN_VALUE > l0 + Long.MIN_VALUE ? 1 : 0;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "c7cb2f0c8f9c88505ce4f6413bf9ae2a0cdf8b05", "url": "https://github.com/trinodb/trino/commit/c7cb2f0c8f9c88505ce4f6413bf9ae2a0cdf8b05", "message": "Make 128-bit addition use 2*64 bit values\n\nAs opposed to 4*32 bit values.\nDone for subtraction as well", "committedDate": "2020-09-09T08:02:30Z", "type": "commit"}, {"oid": "53ce46edbbae48c78e87dca483cd60650b1dd6e0", "url": "https://github.com/trinodb/trino/commit/53ce46edbbae48c78e87dca483cd60650b1dd6e0", "message": "Extract local variable", "committedDate": "2020-09-09T08:02:37Z", "type": "commit"}, {"oid": "53ce46edbbae48c78e87dca483cd60650b1dd6e0", "url": "https://github.com/trinodb/trino/commit/53ce46edbbae48c78e87dca483cd60650b1dd6e0", "message": "Extract local variable", "committedDate": "2020-09-09T08:02:37Z", "type": "forcePushed"}]}