{"pr_number": 5713, "pr_title": "Improve window frames further", "pr_createdAt": "2020-10-27T21:48:05Z", "pr_url": "https://github.com/trinodb/trino/pull/5713", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMTExNQ==", "url": "https://github.com/trinodb/trino/pull/5713#discussion_r513111115", "bodyText": "private", "author": "martint", "createdAt": "2020-10-28T00:33:37Z", "path": "presto-main/src/main/java/io/prestosql/operator/window/WindowPartition.java", "diffHunk": "@@ -546,4 +605,201 @@ private long getFrameValue(int channel, String type)\n         checkCondition(value >= 0, INVALID_WINDOW_FRAME, \"Window frame %s offset must not be negative\", value);\n         return value;\n     }\n+\n+    private GroupsFrame getFrameRange(FrameInfo frameInfo, GroupsFrame recentFrame)\n+    {\n+        Type startType = frameInfo.getStartType();\n+        Type endType = frameInfo.getEndType();\n+        int start;\n+        int end;\n+\n+        // Frame is unbounded or defined by current peer group\n+        if ((startType == UNBOUNDED_PRECEDING || startType == CURRENT_ROW) &&\n+                (endType == UNBOUNDED_FOLLOWING || endType == CURRENT_ROW)) {\n+            start = startType == UNBOUNDED_PRECEDING ? 0 : peerGroupStart - partitionStart;\n+            end = endType == UNBOUNDED_FOLLOWING ? partitionEnd - partitionStart - 1 : peerGroupEnd - partitionStart - 1;\n+            return new GroupsFrame(start, GroupsFrame.ignoreIndex(), end, GroupsFrame.ignoreIndex());\n+        }\n+\n+        // Frame definition has at least one of: X PRECEDING, Y FOLLOWING\n+        int startGroupIndex;\n+        int endGroupIndex;\n+        if (startType == UNBOUNDED_PRECEDING) {\n+            start = 0;\n+            startGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (startType == CURRENT_ROW) {\n+            start = peerGroupStart - partitionStart;\n+            startGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (startType == PRECEDING) {\n+            PositionAndGroup frameStart = seek(toIntExact(currentGroupIndex - getStartValue(frameInfo)), recentFrame.getStart(), recentFrame.getStartGroupIndex(), seekGroupStart, () -> new PositionAndGroup(0, 0));\n+            start = frameStart.getPosition();\n+            startGroupIndex = frameStart.getGroup();\n+        }\n+        else { // startType == FOLLOWING\n+            PositionAndGroup frameStart = seek(toIntExact(currentGroupIndex + getStartValue(frameInfo)), recentFrame.getStart(), recentFrame.getStartGroupIndex(), seekGroupStart, () -> new PositionAndGroup(partitionEnd - partitionStart, GroupsFrame.ignoreIndex()));\n+            start = frameStart.getPosition();\n+            startGroupIndex = frameStart.getGroup();\n+        }\n+\n+        if (endType == UNBOUNDED_FOLLOWING) {\n+            end = partitionEnd - partitionStart - 1;\n+            endGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (endType == CURRENT_ROW) {\n+            end = peerGroupEnd - partitionStart - 1;\n+            endGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (endType == PRECEDING) {\n+            PositionAndGroup frameEnd = seek(toIntExact(currentGroupIndex - getEndValue(frameInfo)), recentFrame.getEnd(), recentFrame.getEndGroupIndex(), seekGroupEnd, () -> new PositionAndGroup(-1, GroupsFrame.ignoreIndex()));\n+            end = frameEnd.getPosition();\n+            endGroupIndex = frameEnd.getGroup();\n+        }\n+        else { // endType == FOLLOWING\n+            PositionAndGroup frameEnd = seek(toIntExact(currentGroupIndex + getEndValue(frameInfo)), recentFrame.getEnd(), recentFrame.getEndGroupIndex(), seekGroupEnd, () -> new PositionAndGroup(partitionEnd - partitionStart - 1, lastPeerGroup));\n+            end = frameEnd.getPosition();\n+            endGroupIndex = frameEnd.getGroup();\n+        }\n+\n+        return new GroupsFrame(start, startGroupIndex, end, endGroupIndex);\n+    }\n+\n+    PositionAndGroup seek(int groupIndex, int recentPosition, int recentGroupIndex, Function<Integer, Integer> seekPositionWithinGroup, EdgeResultProvider edgeResult)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMTM0Mw==", "url": "https://github.com/trinodb/trino/pull/5713#discussion_r513111343", "bodyText": "These methods are part of the public interface of this class, so they should be public (even if class is private) to the enclosing class", "author": "martint", "createdAt": "2020-10-28T00:34:13Z", "path": "presto-main/src/main/java/io/prestosql/operator/window/WindowPartition.java", "diffHunk": "@@ -546,4 +605,201 @@ private long getFrameValue(int channel, String type)\n         checkCondition(value >= 0, INVALID_WINDOW_FRAME, \"Window frame %s offset must not be negative\", value);\n         return value;\n     }\n+\n+    private GroupsFrame getFrameRange(FrameInfo frameInfo, GroupsFrame recentFrame)\n+    {\n+        Type startType = frameInfo.getStartType();\n+        Type endType = frameInfo.getEndType();\n+        int start;\n+        int end;\n+\n+        // Frame is unbounded or defined by current peer group\n+        if ((startType == UNBOUNDED_PRECEDING || startType == CURRENT_ROW) &&\n+                (endType == UNBOUNDED_FOLLOWING || endType == CURRENT_ROW)) {\n+            start = startType == UNBOUNDED_PRECEDING ? 0 : peerGroupStart - partitionStart;\n+            end = endType == UNBOUNDED_FOLLOWING ? partitionEnd - partitionStart - 1 : peerGroupEnd - partitionStart - 1;\n+            return new GroupsFrame(start, GroupsFrame.ignoreIndex(), end, GroupsFrame.ignoreIndex());\n+        }\n+\n+        // Frame definition has at least one of: X PRECEDING, Y FOLLOWING\n+        int startGroupIndex;\n+        int endGroupIndex;\n+        if (startType == UNBOUNDED_PRECEDING) {\n+            start = 0;\n+            startGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (startType == CURRENT_ROW) {\n+            start = peerGroupStart - partitionStart;\n+            startGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (startType == PRECEDING) {\n+            PositionAndGroup frameStart = seek(toIntExact(currentGroupIndex - getStartValue(frameInfo)), recentFrame.getStart(), recentFrame.getStartGroupIndex(), seekGroupStart, () -> new PositionAndGroup(0, 0));\n+            start = frameStart.getPosition();\n+            startGroupIndex = frameStart.getGroup();\n+        }\n+        else { // startType == FOLLOWING\n+            PositionAndGroup frameStart = seek(toIntExact(currentGroupIndex + getStartValue(frameInfo)), recentFrame.getStart(), recentFrame.getStartGroupIndex(), seekGroupStart, () -> new PositionAndGroup(partitionEnd - partitionStart, GroupsFrame.ignoreIndex()));\n+            start = frameStart.getPosition();\n+            startGroupIndex = frameStart.getGroup();\n+        }\n+\n+        if (endType == UNBOUNDED_FOLLOWING) {\n+            end = partitionEnd - partitionStart - 1;\n+            endGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (endType == CURRENT_ROW) {\n+            end = peerGroupEnd - partitionStart - 1;\n+            endGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (endType == PRECEDING) {\n+            PositionAndGroup frameEnd = seek(toIntExact(currentGroupIndex - getEndValue(frameInfo)), recentFrame.getEnd(), recentFrame.getEndGroupIndex(), seekGroupEnd, () -> new PositionAndGroup(-1, GroupsFrame.ignoreIndex()));\n+            end = frameEnd.getPosition();\n+            endGroupIndex = frameEnd.getGroup();\n+        }\n+        else { // endType == FOLLOWING\n+            PositionAndGroup frameEnd = seek(toIntExact(currentGroupIndex + getEndValue(frameInfo)), recentFrame.getEnd(), recentFrame.getEndGroupIndex(), seekGroupEnd, () -> new PositionAndGroup(partitionEnd - partitionStart - 1, lastPeerGroup));\n+            end = frameEnd.getPosition();\n+            endGroupIndex = frameEnd.getGroup();\n+        }\n+\n+        return new GroupsFrame(start, startGroupIndex, end, endGroupIndex);\n+    }\n+\n+    PositionAndGroup seek(int groupIndex, int recentPosition, int recentGroupIndex, Function<Integer, Integer> seekPositionWithinGroup, EdgeResultProvider edgeResult)\n+    {\n+        if (groupIndex < 0 || groupIndex > lastPeerGroup) {\n+            return edgeResult.get();\n+        }\n+        while (recentGroupIndex > groupIndex) {\n+            recentPosition = seekGroupStart.apply(recentPosition);\n+            recentPosition--;\n+            recentGroupIndex--;\n+        }\n+\n+        while (recentGroupIndex < groupIndex) {\n+            recentPosition = seekGroupEnd.apply(recentPosition);\n+            if (recentPosition == partitionEnd - partitionStart - 1) {\n+                lastPeerGroup = recentGroupIndex;\n+                return edgeResult.get();\n+            }\n+            recentPosition++;\n+            recentGroupIndex++;\n+        }\n+\n+        recentPosition = seekPositionWithinGroup.apply(recentPosition);\n+        if (recentPosition == partitionEnd - partitionStart - 1) {\n+            lastPeerGroup = recentGroupIndex;\n+        }\n+        return new PositionAndGroup(recentPosition, recentGroupIndex);\n+    }\n+\n+    /**\n+     * Return a valid frame. A frame is valid if its start and end are within partition.\n+     * If frame start or frame end is out of partition bounds, it is set to the nearest position\n+     * for which peer group index can be determined.\n+     */\n+    private GroupsFrame nearestValidFrame(GroupsFrame frame)\n+    {\n+        if (frame.getStart() > partitionEnd - partitionStart - 1) {\n+            return frame.withStart(partitionEnd - partitionStart - 1, lastPeerGroup);\n+        }\n+        if (frame.getEnd() < 0) {\n+            return frame.withEnd(0, 0);\n+        }\n+        return frame;\n+    }\n+\n+    /**\n+     * Window frame representation for frame of type GROUPS.\n+     * start, end - first and last row of the frame within window partition\n+     * startGroupIndex, endGroupIndex - indexes of respective peer groups within partition\n+     * start points at the first row of startGroupIndex-th peer group\n+     * end points at the last row of endGroupIndex-th peer group\n+     */\n+    private static class GroupsFrame\n+    {\n+        private static final int IGNORE_GROUP_INDEX = -1;\n+\n+        private final int start;\n+        private final int startGroupIndex;\n+        private final int end;\n+        private final int endGroupIndex;\n+\n+        GroupsFrame(int start, int startGroupIndex, int end, int endGroupIndex)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMyODQwMA==", "url": "https://github.com/trinodb/trino/pull/5713#discussion_r516328400", "bodyText": "I think it'd be clearer to write the condition as follows. It's more \"symmetric\" with the one above.\nwhile (position < partitionEnd - 1 - partitionStart && ...", "author": "martint", "createdAt": "2020-11-02T23:25:46Z", "path": "presto-main/src/main/java/io/prestosql/operator/window/WindowPartition.java", "diffHunk": "@@ -95,6 +112,24 @@ public WindowPartition(\n         updatePeerGroup();\n \n         recentRanges = initializeRangeCache(partitionStart, partitionEnd, peerGroupEnd, windowFunctions);\n+\n+        recentGroupsFrames = initializeGroupsFrameCache(partitionStart, peerGroupEnd, windowFunctions);\n+\n+        seekGroupStart = position -> {\n+            requireNonNull(position, \"position is null\");\n+            while (position > 0 && pagesIndex.positionEqualsPosition(peerGroupHashStrategy, partitionStart + position, partitionStart + position - 1)) {\n+                position--;\n+            }\n+            return position;\n+        };\n+\n+        seekGroupEnd = position -> {\n+            requireNonNull(position, \"position is null\");\n+            while (partitionStart + position < partitionEnd - 1 && pagesIndex.positionEqualsPosition(peerGroupHashStrategy, partitionStart + position, partitionStart + position + 1)) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1Nzg4Mg==", "url": "https://github.com/trinodb/trino/pull/5713#discussion_r516357882", "bodyText": "There's some duplication and overlapping conditions in this method. How about simplifying to:\nprivate GroupsFrame getFrameRange(FrameInfo frameInfo, GroupsFrame recentFrame)\n{\n    Type startType = frameInfo.getStartType();\n    Type endType = frameInfo.getEndType();\n\n    int start;\n    int end;\n    int startGroupIndex = GroupsFrame.ignoreIndex();\n    int endGroupIndex = GroupsFrame.ignoreIndex();\n\n    switch (startType) {\n        case UNBOUNDED_PRECEDING:\n            start = 0;\n            break;\n        case CURRENT_ROW:\n            start = peerGroupStart - partitionStart;\n            break;\n        case PRECEDING: {\n            PositionAndGroup frameStart = seek(toIntExact(currentGroupIndex - getStartValue(frameInfo)), recentFrame.getStart(), recentFrame.getStartGroupIndex(), seekGroupStart, () -> new PositionAndGroup(0, 0));\n            start = frameStart.getPosition();\n            startGroupIndex = frameStart.getGroup();\n            break;\n        }\n        case FOLLOWING: {\n            PositionAndGroup frameStart = seek(toIntExact(currentGroupIndex + getStartValue(frameInfo)), recentFrame.getStart(), recentFrame.getStartGroupIndex(), seekGroupStart, () -> new PositionAndGroup(partitionEnd - partitionStart, GroupsFrame.ignoreIndex()));\n            start = frameStart.getPosition();\n            startGroupIndex = frameStart.getGroup();\n            break;\n        }\n        default:\n            throw new UnsupportedOperationException(\"Unsupported frame start type: \" + startType);\n    }\n\n    switch (endType) {\n        case UNBOUNDED_FOLLOWING:\n            end = partitionEnd - partitionStart - 1;\n            break;\n        case CURRENT_ROW:\n            end = peerGroupEnd - partitionStart - 1;\n            break;\n        case PRECEDING: {\n            PositionAndGroup frameEnd = seek(toIntExact(currentGroupIndex - getEndValue(frameInfo)), recentFrame.getEnd(), recentFrame.getEndGroupIndex(), seekGroupEnd, () -> new PositionAndGroup(-1, GroupsFrame.ignoreIndex()));\n            end = frameEnd.getPosition();\n            endGroupIndex = frameEnd.getGroup();\n            break;\n        }\n        case FOLLOWING: {\n            PositionAndGroup frameEnd = seek(toIntExact(currentGroupIndex + getEndValue(frameInfo)), recentFrame.getEnd(), recentFrame.getEndGroupIndex(), seekGroupEnd, () -> new PositionAndGroup(partitionEnd - partitionStart - 1, lastPeerGroup));\n            end = frameEnd.getPosition();\n            endGroupIndex = frameEnd.getGroup();\n            break;\n        }\n        default:\n            throw new UnsupportedOperationException(\"Unsupported frame end type: \" + endType);\n    }\n\n    return new GroupsFrame(start, startGroupIndex, end, endGroupIndex);\n}", "author": "martint", "createdAt": "2020-11-03T00:24:25Z", "path": "presto-main/src/main/java/io/prestosql/operator/window/WindowPartition.java", "diffHunk": "@@ -546,4 +605,201 @@ private long getFrameValue(int channel, String type)\n         checkCondition(value >= 0, INVALID_WINDOW_FRAME, \"Window frame %s offset must not be negative\", value);\n         return value;\n     }\n+\n+    private GroupsFrame getFrameRange(FrameInfo frameInfo, GroupsFrame recentFrame)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1ODgzOQ==", "url": "https://github.com/trinodb/trino/pull/5713#discussion_r516358839", "bodyText": "Why is the last argument passed as a lambda? It doesn't take any arguments, so there's no much point in computing it lazily.", "author": "martint", "createdAt": "2020-11-03T00:26:34Z", "path": "presto-main/src/main/java/io/prestosql/operator/window/WindowPartition.java", "diffHunk": "@@ -546,4 +605,201 @@ private long getFrameValue(int channel, String type)\n         checkCondition(value >= 0, INVALID_WINDOW_FRAME, \"Window frame %s offset must not be negative\", value);\n         return value;\n     }\n+\n+    private GroupsFrame getFrameRange(FrameInfo frameInfo, GroupsFrame recentFrame)\n+    {\n+        Type startType = frameInfo.getStartType();\n+        Type endType = frameInfo.getEndType();\n+        int start;\n+        int end;\n+\n+        // Frame is unbounded or defined by current peer group\n+        if ((startType == UNBOUNDED_PRECEDING || startType == CURRENT_ROW) &&\n+                (endType == UNBOUNDED_FOLLOWING || endType == CURRENT_ROW)) {\n+            start = startType == UNBOUNDED_PRECEDING ? 0 : peerGroupStart - partitionStart;\n+            end = endType == UNBOUNDED_FOLLOWING ? partitionEnd - partitionStart - 1 : peerGroupEnd - partitionStart - 1;\n+            return new GroupsFrame(start, GroupsFrame.ignoreIndex(), end, GroupsFrame.ignoreIndex());\n+        }\n+\n+        // Frame definition has at least one of: X PRECEDING, Y FOLLOWING\n+        int startGroupIndex;\n+        int endGroupIndex;\n+        if (startType == UNBOUNDED_PRECEDING) {\n+            start = 0;\n+            startGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (startType == CURRENT_ROW) {\n+            start = peerGroupStart - partitionStart;\n+            startGroupIndex = GroupsFrame.ignoreIndex();\n+        }\n+        else if (startType == PRECEDING) {\n+            PositionAndGroup frameStart = seek(toIntExact(currentGroupIndex - getStartValue(frameInfo)), recentFrame.getStart(), recentFrame.getStartGroupIndex(), seekGroupStart, () -> new PositionAndGroup(0, 0));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3OTk1MA==", "url": "https://github.com/trinodb/trino/pull/5713#discussion_r517179950", "bodyText": "It is a lambda, because it uses lastPeerGroup, which is variable.\nI could pass lastPeerGroup as an argument to the lambda.", "author": "kasiafi", "createdAt": "2020-11-04T08:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1ODgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ4MzkwMg==", "url": "https://github.com/trinodb/trino/pull/5713#discussion_r517483902", "bodyText": "Yes, that's much clearer.", "author": "martint", "createdAt": "2020-11-04T16:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1ODgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ4OTYzMA==", "url": "https://github.com/trinodb/trino/pull/5713#discussion_r517489630", "bodyText": "Cool. It's already done this way. Ready for review.", "author": "kasiafi", "createdAt": "2020-11-04T16:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1ODgzOQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "8583fea751fc868b01b80aca88fa8e716c27d4b9", "url": "https://github.com/trinodb/trino/commit/8583fea751fc868b01b80aca88fa8e716c27d4b9", "message": "Add support for GROUPS", "committedDate": "2020-11-04T16:57:40Z", "type": "commit"}, {"oid": "8583fea751fc868b01b80aca88fa8e716c27d4b9", "url": "https://github.com/trinodb/trino/commit/8583fea751fc868b01b80aca88fa8e716c27d4b9", "message": "Add support for GROUPS", "committedDate": "2020-11-04T16:57:40Z", "type": "forcePushed"}]}