{"pr_number": 3559, "pr_title": "Accumulo type mapping cleanup", "pr_createdAt": "2020-04-27T19:44:36Z", "pr_url": "https://github.com/trinodb/trino/pull/3559", "timeline": [{"oid": "f187a5d1e9ed9d990167744bae0468fa3c9a92c6", "url": "https://github.com/trinodb/trino/commit/f187a5d1e9ed9d990167744bae0468fa3c9a92c6", "message": "Remove unused method", "committedDate": "2020-04-27T21:19:51Z", "type": "commit"}, {"oid": "e1dc91cecb511333138d6d15e5c92a22b948dc2f", "url": "https://github.com/trinodb/trino/commit/e1dc91cecb511333138d6d15e5c92a22b948dc2f", "message": "Simplify Field#toString\n\nThe `Field`'s `toString` is complex, as if it was playing some\nconversion role, but it does not. Simplify it and make more robust\n(avoid throwing exceptions), at the cost of not producing human-readable\nstring representation of collections.", "committedDate": "2020-04-27T21:19:52Z", "type": "commit"}, {"oid": "7201342984fe51084b89991ce06a831bae25ce2e", "url": "https://github.com/trinodb/trino/commit/7201342984fe51084b89991ce06a831bae25ce2e", "message": "Correct constant to represent TIME", "committedDate": "2020-04-27T21:19:54Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "df2b33a72205e73169664ab15b4807b5f4673e40", "url": "https://github.com/trinodb/trino/commit/df2b33a72205e73169664ab15b4807b5f4673e40", "message": "Simplify type conversion code\n\nThe conversion code was flexible, allowing different representations for\ngiven Presto Type. This is unnecessary, as the value passed is always a\nPresto Type's stack representation.", "committedDate": "2020-04-28T17:45:54Z", "type": "commit"}, {"oid": "df2b33a72205e73169664ab15b4807b5f4673e40", "url": "https://github.com/trinodb/trino/commit/df2b33a72205e73169664ab15b4807b5f4673e40", "message": "Simplify type conversion code\n\nThe conversion code was flexible, allowing different representations for\ngiven Presto Type. This is unnecessary, as the value passed is always a\nPresto Type's stack representation.", "committedDate": "2020-04-28T17:45:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0OTE5OA==", "url": "https://github.com/trinodb/trino/pull/3559#discussion_r419149198", "bodyText": "Should we enforce the types here?\nreturn (Block) value;", "author": "electrum", "createdAt": "2020-05-03T19:36:44Z", "path": "presto-accumulo/src/main/java/io/prestosql/plugin/accumulo/model/Field.java", "diffHunk": "@@ -266,279 +266,92 @@ private static boolean equals(Block block1, Block block2)\n     @Override\n     public String toString()\n     {\n-        if (value == null) {\n-            return \"null\";\n-        }\n-\n-        if (Types.isArrayType(type)) {\n-            Type elementType = Types.getElementType(type);\n-            StringBuilder builder = new StringBuilder(\"ARRAY [\");\n-            for (Object element : AccumuloRowSerializer.getArrayFromBlock(elementType, this.getArray())) {\n-                if (Types.isArrayType(elementType)) {\n-                    Type elementElementType = Types.getElementType(elementType);\n-                    builder.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromArray(elementElementType, (List<?>) element),\n-                                    elementType))\n-                            .append(',');\n-                }\n-                else if (Types.isMapType(elementType)) {\n-                    builder.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromMap(elementType, (Map<?, ?>) element),\n-                                    elementType))\n-                            .append(',');\n-                }\n-                else {\n-                    builder.append(new Field(element, elementType))\n-                            .append(',');\n-                }\n-            }\n-\n-            return builder.deleteCharAt(builder.length() - 1).append(\"]\").toString();\n-        }\n-\n-        if (Types.isMapType(type)) {\n-            StringBuilder builder = new StringBuilder(\"MAP(\");\n-            StringBuilder keys = new StringBuilder(\"ARRAY [\");\n-            StringBuilder values = new StringBuilder(\"ARRAY [\");\n-            for (Entry<Object, Object> entry : AccumuloRowSerializer\n-                    .getMapFromBlock(type, this.getMap()).entrySet()) {\n-                Type keyType = Types.getKeyType(type);\n-                if (Types.isArrayType(keyType)) {\n-                    keys.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromArray(Types.getElementType(keyType), (List<?>) entry.getKey()),\n-                                    keyType))\n-                            .append(',');\n-                }\n-                else if (Types.isMapType(keyType)) {\n-                    keys.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromMap(keyType, (Map<?, ?>) entry.getKey()),\n-                                    keyType))\n-                            .append(',');\n-                }\n-                else {\n-                    keys.append(new Field(entry.getKey(), keyType))\n-                            .append(',');\n-                }\n-\n-                Type valueType = Types.getValueType(type);\n-                if (Types.isArrayType(valueType)) {\n-                    values.append(\n-                            new Field(AccumuloRowSerializer.getBlockFromArray(Types.getElementType(valueType),\n-                                    (List<?>) entry.getValue()), valueType))\n-                            .append(',');\n-                }\n-                else if (Types.isMapType(valueType)) {\n-                    values.append(\n-                            new Field(\n-                                    AccumuloRowSerializer.getBlockFromMap(valueType, (Map<?, ?>) entry.getValue()),\n-                                    valueType))\n-                            .append(',');\n-                }\n-                else {\n-                    values.append(new Field(entry.getValue(), valueType)).append(',');\n-                }\n-            }\n-\n-            keys.deleteCharAt(keys.length() - 1).append(']');\n-            values.deleteCharAt(values.length() - 1).append(']');\n-            return builder.append(keys).append(\", \").append(values).append(\")\").toString();\n-        }\n-\n-        // Validate the object is the given type\n-        if (type.equals(BIGINT) || type.equals(BOOLEAN) || type.equals(DOUBLE) || type.equals(INTEGER) || type.equals(REAL) || type.equals(TINYINT) || type.equals(SMALLINT)) {\n-            return value.toString();\n-        }\n-        if (type.equals(DATE)) {\n-            return \"DATE '\" + value.toString() + \"'\";\n-        }\n-        if (type.equals(TIME)) {\n-            return \"TIME '\" + value.toString() + \"'\";\n-        }\n-        if (type.equals(TIMESTAMP)) {\n-            return \"TIMESTAMP '\" + value.toString() + \"'\";\n-        }\n-        if (type.equals(VARBINARY)) {\n-            return \"CAST('\" + new String((byte[]) value, UTF_8).replaceAll(\"'\", \"''\") + \"' AS VARBINARY)\";\n-        }\n-        if (type instanceof VarcharType) {\n-            return \"'\" + value.toString().replaceAll(\"'\", \"''\") + \"'\";\n-        }\n-        throw new PrestoException(NOT_SUPPORTED, \"Unsupported PrestoType \" + type);\n+        return toStringHelper(this)\n+                .add(\"value\", value)\n+                .add(\"type\", type)\n+                .toString();\n     }\n \n     /**\n-     * Does it's damnedest job to convert the given object to the given type.\n+     * Convert Presto native value (stack representation) of given type to Accumulo equivalent.\n      *\n      * @param value Object to convert\n      * @param type Destination Presto type\n-     * @return Null if null, the converted type of it could convert it, or the same value if it is fine just the way it is :D\n-     * @throws PrestoException If the given object is not any flavor of the given type\n      */\n-    private static Object cleanObject(Object value, Type type)\n+    private static Object convert(Object value, Type type)\n     {\n         if (value == null) {\n             return null;\n         }\n \n+        checkArgument(Primitives.wrap(type.getJavaType()).isInstance(value), \"Invalid representation for %s: %s [%s]\", type, value, value.getClass().getName());\n+\n         // Array? Better be a block!\n         if (Types.isArrayType(type)) {\n-            if (!(value instanceof Block)) {\n-                throw new PrestoException(FUNCTION_IMPLEMENTATION_ERROR, \"Object is not a Block, but \" + value.getClass());\n-            }\n+            // Block", "originalCommit": "df2b33a72205e73169664ab15b4807b5f4673e40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MjcwNg==", "url": "https://github.com/trinodb/trino/pull/3559#discussion_r419152706", "bodyText": "I'd like to do this, but intellij frowns on \"unnecessary cast\". (which i dont want to ignore in general, although here it's incorrect).\nThis is, however, enforced by the checkArgument(Primitives.wrap(type.getJavaType()).isInstance(value), check above.", "author": "findepi", "createdAt": "2020-05-03T20:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0OTE5OA=="}], "type": "inlineReview"}]}