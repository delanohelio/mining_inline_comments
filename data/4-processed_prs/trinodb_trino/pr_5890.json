{"pr_number": 5890, "pr_title": "Add support for EXCEPT ALL, INTERSECT ALL", "pr_createdAt": "2020-11-09T22:33:51Z", "pr_url": "https://github.com/trinodb/trino/pull/5890", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTczMjEzMA==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521732130", "bodyText": "Add a test that would cause the result to contain duplicate values. E.g.:\nSELECT * FROM (VALUES 4, 4, 4, 3, 3) EXCEPT ALL SELECT * FROM (VALUES 1, 2, 3, 3, 3, 4)", "author": "martint", "createdAt": "2020-11-12T00:29:27Z", "path": "presto-tests/src/test/java/io/prestosql/tests/AbstractTestEngineOnlyQueries.java", "diffHunk": "@@ -199,15 +199,101 @@ public void testSelectNull()\n     }\n \n     @Test\n-    public void testExceptAllFails()\n+    public void testExceptAll()\n     {\n-        assertQueryFails(\"SELECT * FROM (VALUES 1, 2, 3, 4) EXCEPT ALL SELECT * FROM (VALUES 3, 4)\", \"line 1:35: EXCEPT ALL not yet implemented\");\n+        assertQuery(\n+                \"SELECT * FROM (VALUES 1, 2, 3, 4) EXCEPT ALL SELECT * FROM (VALUES 3, 4)\",\n+                \"VALUES 1, 2\");\n+\n+        assertQuery(\n+                \"SELECT * FROM (VALUES 4, 4, 4, 3, 3) EXCEPT ALL SELECT * FROM (VALUES 1, 2, 3, 3, 3, 4, 4)\",\n+                \"VALUES 4\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTczODg1Ng==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521738856", "bodyText": "Clever! :)", "author": "martint", "createdAt": "2020-11-12T00:41:15Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ImplementIntersectAll.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.IntersectNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.IfExpression;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static io.prestosql.sql.planner.plan.Patterns.Intersect.distinct;\n+import static io.prestosql.sql.planner.plan.Patterns.intersect;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN_OR_EQUAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Implement INTERSECT ALL using union, window and filter.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - Intersect all\n+ *   output: a, b\n+ *     - Source1 (a1, b1)\n+ *     - Source2 (a2, b2)\n+ *     - Source3 (a3, b3)\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Project (prune helper symbols)\n+ *   output: a, b\n+ *     - Filter (row_number <= min(min(count1, count2), count3))\n+ *         - Window (partition by a, b)\n+ *           count1 <- count(marker1)\n+ *           count2 <- count(marker2)\n+ *           count3 <- count(marker3)\n+ *           row_number <- row_number()\n+ *               - Union\n+ *                 output: a, b, marker1, marker2, marker3\n+ *                   - Project (marker1 <- true, marker2 <- null, marker3 <- null)\n+ *                       - Source1 (a1, b1)\n+ *                   - Project (marker1 <- null, marker2 <- true, marker3 <- null)\n+ *                       - Source2 (a2, b2)\n+ *                   - Project (marker1 <- null, marker2 <- null, marker3 <- true)\n+ *                       - Source3 (a3, b3)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc0Nzg5OA==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521747898", "bodyText": "This could be represented as greatest(first - second, 0)", "author": "martint", "createdAt": "2020-11-12T00:56:40Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ImplementExceptAll.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ExceptNode;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.ArithmeticBinaryExpression;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.GenericLiteral;\n+import io.prestosql.sql.tree.IfExpression;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static io.prestosql.sql.planner.plan.Patterns.Except.distinct;\n+import static io.prestosql.sql.planner.plan.Patterns.except;\n+import static io.prestosql.sql.tree.ArithmeticBinaryExpression.Operator.SUBTRACT;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN_OR_EQUAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Implement EXCEPT ALL using union, window and filter.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - Except all\n+ *   output: a, b\n+ *     - Source1 (a1, b1)\n+ *     - Source2 (a2, b2)\n+ *     - Source3 (a3, b3)\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Project (prune helper symbols)\n+ *   output: a, b\n+ *     - Filter (row_number <= max(max(count1 - count2, 0) - count3, 0))\n+ *         - Window (partition by a, b)\n+ *           count1 <- count(marker1)\n+ *           count2 <- count(marker2)\n+ *           count3 <- count(marker3)\n+ *           row_number <- row_number()\n+ *               - Union\n+ *                 output: a, b, marker1, marker2, marker3\n+ *                   - Project (marker1 <- true, marker2 <- null, marker3 <- null)\n+ *                       - Source1 (a1, b1)\n+ *                   - Project (marker1 <- null, marker2 <- true, marker3 <- null)\n+ *                       - Source2 (a2, b2)\n+ *                   - Project (marker1 <- null, marker2 <- null, marker3 <- true)\n+ *                       - Source3 (a3, b3)\n+ * </pre>\n+ */\n+public class ImplementExceptAll\n+        implements Rule<ExceptNode>\n+{\n+    private static final Pattern<ExceptNode> PATTERN = except()\n+            .with(distinct().equalTo(false));\n+\n+    private final Metadata metadata;\n+\n+    public ImplementExceptAll(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<ExceptNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(ExceptNode node, Captures captures, Context context)\n+    {\n+        SetOperationNodeTranslator translator = new SetOperationNodeTranslator(metadata, context.getSymbolAllocator(), context.getIdAllocator());\n+        SetOperationNodeTranslator.TranslationResult result = translator.makeSetContainmentPlanWithoutAggregation(node);\n+\n+        // compute expected multiplicity for every row\n+        checkState(result.getCountSymbols().size() > 0, \"ExceptNode translation result has no count symbols\");\n+        Expression count = result.getCountSymbols().get(0).toSymbolReference();\n+        for (int i = 1; i < result.getCountSymbols().size(); i++) {\n+            count = subtractCount(count, result.getCountSymbols().get(i).toSymbolReference());\n+        }\n+\n+        // filter rows so that expected number of rows remains\n+        Expression removeExtraRows = new ComparisonExpression(LESS_THAN_OR_EQUAL, result.getRowNumberSymbol().toSymbolReference(), count);\n+        FilterNode filter = new FilterNode(\n+                context.getIdAllocator().getNextId(),\n+                result.getPlanNode(),\n+                removeExtraRows);\n+\n+        // prune helper symbols\n+        ProjectNode project = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                filter,\n+                Assignments.identity(node.getOutputSymbols()));\n+\n+        return Result.ofPlanNode(project);\n+    }\n+\n+    private static Expression subtractCount(Expression first, Expression second)\n+    {\n+        Expression expression = new ArithmeticBinaryExpression(SUBTRACT, first, second);\n+        Expression zero = new GenericLiteral(\"BIGINT\", \"0\");\n+        return new IfExpression(\n+                new ComparisonExpression(LESS_THAN, expression, zero),\n+                zero,\n+                expression);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc0ODY2MA==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521748660", "bodyText": "This could be represented as least(first, second)", "author": "martint", "createdAt": "2020-11-12T00:57:56Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/ImplementIntersectAll.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.IntersectNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.ComparisonExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.IfExpression;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static io.prestosql.sql.planner.plan.Patterns.Intersect.distinct;\n+import static io.prestosql.sql.planner.plan.Patterns.intersect;\n+import static io.prestosql.sql.tree.ComparisonExpression.Operator.LESS_THAN_OR_EQUAL;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Implement INTERSECT ALL using union, window and filter.\n+ * <p>\n+ * Transforms:\n+ * <pre>\n+ * - Intersect all\n+ *   output: a, b\n+ *     - Source1 (a1, b1)\n+ *     - Source2 (a2, b2)\n+ *     - Source3 (a3, b3)\n+ * </pre>\n+ * Into:\n+ * <pre>\n+ * - Project (prune helper symbols)\n+ *   output: a, b\n+ *     - Filter (row_number <= min(min(count1, count2), count3))\n+ *         - Window (partition by a, b)\n+ *           count1 <- count(marker1)\n+ *           count2 <- count(marker2)\n+ *           count3 <- count(marker3)\n+ *           row_number <- row_number()\n+ *               - Union\n+ *                 output: a, b, marker1, marker2, marker3\n+ *                   - Project (marker1 <- true, marker2 <- null, marker3 <- null)\n+ *                       - Source1 (a1, b1)\n+ *                   - Project (marker1 <- null, marker2 <- true, marker3 <- null)\n+ *                       - Source2 (a2, b2)\n+ *                   - Project (marker1 <- null, marker2 <- null, marker3 <- true)\n+ *                       - Source3 (a3, b3)\n+ * </pre>\n+ */\n+public class ImplementIntersectAll\n+        implements Rule<IntersectNode>\n+{\n+    private static final Pattern<IntersectNode> PATTERN = intersect()\n+            .with(distinct().equalTo(false));\n+\n+    private final Metadata metadata;\n+\n+    public ImplementIntersectAll(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    @Override\n+    public Pattern<IntersectNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(IntersectNode node, Captures captures, Context context)\n+    {\n+        SetOperationNodeTranslator translator = new SetOperationNodeTranslator(metadata, context.getSymbolAllocator(), context.getIdAllocator());\n+        SetOperationNodeTranslator.TranslationResult result = translator.makeSetContainmentPlanWithoutAggregation(node);\n+\n+        // compute expected multiplicity for every row\n+        checkState(result.getCountSymbols().size() > 0, \"IntersectNode translation result has no count symbols\");\n+        Expression minCount = result.getCountSymbols().get(0).toSymbolReference();\n+        for (int i = 1; i < result.getCountSymbols().size(); i++) {\n+            minCount = min(minCount, result.getCountSymbols().get(i).toSymbolReference());\n+        }\n+\n+        // filter rows so that expected number of rows remains\n+        Expression removeExtraRows = new ComparisonExpression(LESS_THAN_OR_EQUAL, result.getRowNumberSymbol().toSymbolReference(), minCount);\n+        FilterNode filter = new FilterNode(\n+                context.getIdAllocator().getNextId(),\n+                result.getPlanNode(),\n+                removeExtraRows);\n+\n+        // prune helper symbols\n+        ProjectNode project = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                filter,\n+                Assignments.identity(node.getOutputSymbols()));\n+\n+        return Result.ofPlanNode(project);\n+    }\n+\n+    private static Expression min(Expression first, Expression second)\n+    {\n+        return new IfExpression(\n+                new ComparisonExpression(LESS_THAN_OR_EQUAL, first, second),\n+                first,\n+                second);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc1MTA4Mg==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521751082", "bodyText": "Make it symmetric:\n        if (node instanceof UnionNode) {\n            return ...\n        }\n        if (node instanceof IntersectNode) {\n            return ...\n        }\n        if (node instanceof ExceptNode) {\n            return ...\n        }\n\n        throw new IllegalArgumentException(\"Unexpected node type: \" + ...);", "author": "martint", "createdAt": "2020-11-12T01:02:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -55,58 +59,117 @@ public SetOperationMerge(SetOperationNode node, Context context, SetOperationNod\n                 .flatMap(lookup::resolveGroup)\n                 .collect(Collectors.toList());\n \n-        // If the first child is not the same with the parent, do nothing.\n-        if (!sources.get(0).getClass().equals(node.getClass())) {\n+        PlanNode child = sources.get(0);\n+\n+        // Determine if set operations can be merged and whether the resulting set operation is quantified DISTINCT or ALL\n+        Optional<Boolean> mergedQuantifier = mergedQuantifierIsDistinct(node, child);\n+        if (mergedQuantifier.isEmpty()) {\n             return Optional.empty();\n         }\n \n         ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n \n-        SetOperationNode child = (SetOperationNode) sources.get(0);\n         // Merge all sources of the first source.\n-        addMergedMappings(child, 0, newMappingsBuilder);\n+        addMergedMappings((SetOperationNode) child, 0, newMappingsBuilder);\n \n         // Keep remaining as it is\n         for (int i = 1; i < sources.size(); i++) {\n             PlanNode source = sources.get(i);\n             addOriginalMappings(source, i, newMappingsBuilder);\n         }\n \n-        return Optional.of(instantiator.create(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        if (node instanceof UnionNode) {\n+            return Optional.of(new UnionNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        }\n+        if (node instanceof IntersectNode) {\n+            return Optional.of(new IntersectNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols(), mergedQuantifier.get()));\n+        }\n+        checkState(node instanceof ExceptNode, \"unexpected node type: %s\", node.getClass().getSimpleName());\n+        return Optional.of(new ExceptNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols(), mergedQuantifier.get()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc1NDI2NQ==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521754265", "bodyText": "This needs additional clarification. If the child is DISTINCT, that branch is guaranteed to have unique values, so at most one element of the other branch will be retained -- this is equivalent to just doing DISTINCT on the parent.", "author": "martint", "createdAt": "2020-11-12T01:07:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -55,58 +59,117 @@ public SetOperationMerge(SetOperationNode node, Context context, SetOperationNod\n                 .flatMap(lookup::resolveGroup)\n                 .collect(Collectors.toList());\n \n-        // If the first child is not the same with the parent, do nothing.\n-        if (!sources.get(0).getClass().equals(node.getClass())) {\n+        PlanNode child = sources.get(0);\n+\n+        // Determine if set operations can be merged and whether the resulting set operation is quantified DISTINCT or ALL\n+        Optional<Boolean> mergedQuantifier = mergedQuantifierIsDistinct(node, child);\n+        if (mergedQuantifier.isEmpty()) {\n             return Optional.empty();\n         }\n \n         ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n \n-        SetOperationNode child = (SetOperationNode) sources.get(0);\n         // Merge all sources of the first source.\n-        addMergedMappings(child, 0, newMappingsBuilder);\n+        addMergedMappings((SetOperationNode) child, 0, newMappingsBuilder);\n \n         // Keep remaining as it is\n         for (int i = 1; i < sources.size(); i++) {\n             PlanNode source = sources.get(i);\n             addOriginalMappings(source, i, newMappingsBuilder);\n         }\n \n-        return Optional.of(instantiator.create(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        if (node instanceof UnionNode) {\n+            return Optional.of(new UnionNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        }\n+        if (node instanceof IntersectNode) {\n+            return Optional.of(new IntersectNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols(), mergedQuantifier.get()));\n+        }\n+        checkState(node instanceof ExceptNode, \"unexpected node type: %s\", node.getClass().getSimpleName());\n+        return Optional.of(new ExceptNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols(), mergedQuantifier.get()));\n     }\n \n     /**\n-     * Constructs the new mapping and source nodes\n+     * Merge all matching source nodes. This method is assumed to be used only for associative set operations: UNION and INTERSECT.\n      *\n      * @return Merged plan node if applied.\n      */\n     public Optional<SetOperationNode> merge()\n     {\n+        checkState(node instanceof UnionNode || node instanceof IntersectNode, \"unexpected node type: %s\", node.getClass().getSimpleName());\n+\n         Lookup lookup = context.getLookup();\n         List<PlanNode> sources = node.getSources().stream()\n                 .flatMap(lookup::resolveGroup)\n                 .collect(Collectors.toList());\n \n-        // There must be one same source node at least.\n-        if (sources.stream().noneMatch(node.getClass()::isInstance)) {\n-            return Optional.empty();\n-        }\n-\n         ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n+        boolean resultIsDistinct = false;\n+        boolean rewritten = false;\n \n         for (int i = 0; i < sources.size(); i++) {\n             PlanNode source = sources.get(i);\n-            if (node.getClass().equals(source.getClass())) {\n-                SetOperationNode setOperationNode = (SetOperationNode) source;\n-                addMergedMappings(setOperationNode, i, newMappingsBuilder);\n+\n+            // Determine if set operations can be merged and whether the resulting set operation is quantified DISTINCT or ALL\n+            Optional<Boolean> mergedQuantifier = mergedQuantifierIsDistinct(node, source);\n+            if (mergedQuantifier.isPresent()) {\n+                addMergedMappings((SetOperationNode) source, i, newMappingsBuilder);\n+                resultIsDistinct |= mergedQuantifier.get();\n+                rewritten = true;\n             }\n             else {\n                 // Keep mapping as it is\n                 addOriginalMappings(source, i, newMappingsBuilder);\n             }\n         }\n \n-        return Optional.of(instantiator.create(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        if (!rewritten) {\n+            return Optional.empty();\n+        }\n+        if (node instanceof UnionNode) {\n+            return Optional.of(new UnionNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        }\n+        return Optional.of(new IntersectNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols(), resultIsDistinct));\n+    }\n+\n+    /**\n+     * Check if node and child are mergable based on their set operation type and quantifier.\n+     * <p>\n+     * For parent and child of type UNION, merge is always possible and the assumed quantifier is ALL, because UnionNode always represents UNION ALL.\n+     * <p>\n+     * For parent and child of type INTERSECT, merge is always possible:\n+     * - if parent and child are both INTERSECT ALL, the resulting set operation is INTERSECT ALL\n+     * - otherwise, the resulting set operation is INTERSECT DISTINCT", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDI5MjU4OA==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r524292588", "bodyText": "I added this explanation.", "author": "kasiafi", "createdAt": "2020-11-16T14:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc1NDI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc1NzYwOQ==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521757609", "bodyText": "What child does this refer to? For EXCEPT, the first one vs any of the others matters.", "author": "martint", "createdAt": "2020-11-12T01:17:47Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -55,58 +59,117 @@ public SetOperationMerge(SetOperationNode node, Context context, SetOperationNod\n                 .flatMap(lookup::resolveGroup)\n                 .collect(Collectors.toList());\n \n-        // If the first child is not the same with the parent, do nothing.\n-        if (!sources.get(0).getClass().equals(node.getClass())) {\n+        PlanNode child = sources.get(0);\n+\n+        // Determine if set operations can be merged and whether the resulting set operation is quantified DISTINCT or ALL\n+        Optional<Boolean> mergedQuantifier = mergedQuantifierIsDistinct(node, child);\n+        if (mergedQuantifier.isEmpty()) {\n             return Optional.empty();\n         }\n \n         ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n \n-        SetOperationNode child = (SetOperationNode) sources.get(0);\n         // Merge all sources of the first source.\n-        addMergedMappings(child, 0, newMappingsBuilder);\n+        addMergedMappings((SetOperationNode) child, 0, newMappingsBuilder);\n \n         // Keep remaining as it is\n         for (int i = 1; i < sources.size(); i++) {\n             PlanNode source = sources.get(i);\n             addOriginalMappings(source, i, newMappingsBuilder);\n         }\n \n-        return Optional.of(instantiator.create(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        if (node instanceof UnionNode) {\n+            return Optional.of(new UnionNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        }\n+        if (node instanceof IntersectNode) {\n+            return Optional.of(new IntersectNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols(), mergedQuantifier.get()));\n+        }\n+        checkState(node instanceof ExceptNode, \"unexpected node type: %s\", node.getClass().getSimpleName());\n+        return Optional.of(new ExceptNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols(), mergedQuantifier.get()));\n     }\n \n     /**\n-     * Constructs the new mapping and source nodes\n+     * Merge all matching source nodes. This method is assumed to be used only for associative set operations: UNION and INTERSECT.\n      *\n      * @return Merged plan node if applied.\n      */\n     public Optional<SetOperationNode> merge()\n     {\n+        checkState(node instanceof UnionNode || node instanceof IntersectNode, \"unexpected node type: %s\", node.getClass().getSimpleName());\n+\n         Lookup lookup = context.getLookup();\n         List<PlanNode> sources = node.getSources().stream()\n                 .flatMap(lookup::resolveGroup)\n                 .collect(Collectors.toList());\n \n-        // There must be one same source node at least.\n-        if (sources.stream().noneMatch(node.getClass()::isInstance)) {\n-            return Optional.empty();\n-        }\n-\n         ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n+        boolean resultIsDistinct = false;\n+        boolean rewritten = false;\n \n         for (int i = 0; i < sources.size(); i++) {\n             PlanNode source = sources.get(i);\n-            if (node.getClass().equals(source.getClass())) {\n-                SetOperationNode setOperationNode = (SetOperationNode) source;\n-                addMergedMappings(setOperationNode, i, newMappingsBuilder);\n+\n+            // Determine if set operations can be merged and whether the resulting set operation is quantified DISTINCT or ALL\n+            Optional<Boolean> mergedQuantifier = mergedQuantifierIsDistinct(node, source);\n+            if (mergedQuantifier.isPresent()) {\n+                addMergedMappings((SetOperationNode) source, i, newMappingsBuilder);\n+                resultIsDistinct |= mergedQuantifier.get();\n+                rewritten = true;\n             }\n             else {\n                 // Keep mapping as it is\n                 addOriginalMappings(source, i, newMappingsBuilder);\n             }\n         }\n \n-        return Optional.of(instantiator.create(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        if (!rewritten) {\n+            return Optional.empty();\n+        }\n+        if (node instanceof UnionNode) {\n+            return Optional.of(new UnionNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols()));\n+        }\n+        return Optional.of(new IntersectNode(node.getId(), newSources, newMappingsBuilder.build(), node.getOutputSymbols(), resultIsDistinct));\n+    }\n+\n+    /**\n+     * Check if node and child are mergable based on their set operation type and quantifier.\n+     * <p>\n+     * For parent and child of type UNION, merge is always possible and the assumed quantifier is ALL, because UnionNode always represents UNION ALL.\n+     * <p>\n+     * For parent and child of type INTERSECT, merge is always possible:\n+     * - if parent and child are both INTERSECT ALL, the resulting set operation is INTERSECT ALL\n+     * - otherwise, the resulting set operation is INTERSECT DISTINCT\n+     * <p>\n+     * For parent and child of type EXCEPT:\n+     * - if parent is EXCEPT DISTINCT and child is EXCEPT ALL, merge is not possible\n+     * - if parent and child are both EXCEPT DISTINCT, the resulting set operation is EXCEPT DISTINCT\n+     * - if parent and child are both EXCEPT ALL, the resulting set operation is EXCEPT ALL\n+     * - if parent is EXCEPT ALL and child is EXCEPT DISTINCT, the resulting set operation is EXCEPT DISTINCT\n+     * <p>\n+     * Optional.empty() indicates that merge is not possible.\n+     */\n+    private Optional<Boolean> mergedQuantifierIsDistinct(SetOperationNode node, PlanNode child)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDI5MjcxOA==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r524292718", "bodyText": "For EXCEPT, this is supposed to be called only for the first child. For INTERSECT and UNION -- for all children.\nThis is responsibility of the caller to call the method for the appropriate children and aggregate the results.", "author": "kasiafi", "createdAt": "2020-11-16T14:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc1NzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc1OTg0MA==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521759840", "bodyText": "The names withAggregation and withoutAggregation are not very clear about the intent. Maybe rename to makeSetContainmentPlanForDistinct and makeSetContainmentPlanForAll", "author": "martint", "createdAt": "2020-11-12T01:25:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationNodeTranslator.java", "diffHunk": "@@ -39,31 +42,37 @@\n import java.util.Optional;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n import static com.google.common.collect.Iterables.concat;\n import static io.prestosql.spi.type.BigintType.BIGINT;\n import static io.prestosql.spi.type.BooleanType.BOOLEAN;\n import static io.prestosql.sql.analyzer.TypeSignatureProvider.fromTypes;\n import static io.prestosql.sql.analyzer.TypeSignatureTranslator.toSqlType;\n import static io.prestosql.sql.planner.plan.AggregationNode.singleGroupingSet;\n import static io.prestosql.sql.tree.BooleanLiteral.TRUE_LITERAL;\n+import static io.prestosql.sql.tree.FrameBound.Type.CURRENT_ROW;\n+import static io.prestosql.sql.tree.FrameBound.Type.UNBOUNDED_PRECEDING;\n+import static io.prestosql.sql.tree.WindowFrame.Type.RANGE;\n import static java.util.Objects.requireNonNull;\n \n public class SetOperationNodeTranslator\n {\n     private static final String MARKER = \"marker\";\n     private final SymbolAllocator symbolAllocator;\n     private final PlanNodeIdAllocator idAllocator;\n-    private final ResolvedFunction countAggregation;\n+    private final ResolvedFunction countFunction;\n+    private final ResolvedFunction rowNumberFunction;\n \n     public SetOperationNodeTranslator(Metadata metadata, SymbolAllocator symbolAllocator, PlanNodeIdAllocator idAllocator)\n     {\n         this.symbolAllocator = requireNonNull(symbolAllocator, \"SymbolAllocator is null\");\n         this.idAllocator = requireNonNull(idAllocator, \"PlanNodeIdAllocator is null\");\n         requireNonNull(metadata, \"metadata is null\");\n-        this.countAggregation = metadata.resolveFunction(QualifiedName.of(\"count\"), fromTypes(BOOLEAN));\n+        this.countFunction = metadata.resolveFunction(QualifiedName.of(\"count\"), fromTypes(BOOLEAN));\n+        this.rowNumberFunction = metadata.resolveFunction(QualifiedName.of(\"row_number\"), ImmutableList.of());\n     }\n \n-    public TranslationResult makeSetContainmentPlan(SetOperationNode node)\n+    public TranslationResult makeSetContainmentPlanWithAggregation(SetOperationNode node)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc2MTQwNQ==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521761405", "bodyText": "Why RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT_ROW? The frame doesn't really matter since there's no ORDER BY, but ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING would be more natural and neutral as way to indicate \"no frame\"", "author": "martint", "createdAt": "2020-11-12T01:31:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationNodeTranslator.java", "diffHunk": "@@ -155,15 +189,54 @@ private AggregationNode computeCounts(UnionNode sourceNode, List<Symbol> origina\n                 Optional.empty());\n     }\n \n+    private WindowNode appendCounts(UnionNode sourceNode, List<Symbol> originalColumns, List<Symbol> markers, List<Symbol> countOutputs, Symbol rowNumberSymbol)\n+    {\n+        ImmutableMap.Builder<Symbol, WindowNode.Function> functions = ImmutableMap.builder();\n+        WindowNode.Frame defaultFrame = new WindowNode.Frame(RANGE, UNBOUNDED_PRECEDING, Optional.empty(), Optional.empty(), CURRENT_ROW, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDI5Mjk3Mw==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r524292973", "bodyText": "OK, I'll change the frame.\nI used RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT_ROW to indicate \"no frame\", because this is the default frame that is assumed when frame isn't specified. To me it seems neutral.\nI agree that the one you suggested looks better with count()", "author": "kasiafi", "createdAt": "2020-11-16T14:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc2MTQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc2MTU3OA==", "url": "https://github.com/trinodb/trino/pull/5890#discussion_r521761578", "bodyText": "format as:\n                new Specification(originalColumns, Optional.empty()),", "author": "martint", "createdAt": "2020-11-12T01:31:40Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationNodeTranslator.java", "diffHunk": "@@ -155,15 +189,54 @@ private AggregationNode computeCounts(UnionNode sourceNode, List<Symbol> origina\n                 Optional.empty());\n     }\n \n+    private WindowNode appendCounts(UnionNode sourceNode, List<Symbol> originalColumns, List<Symbol> markers, List<Symbol> countOutputs, Symbol rowNumberSymbol)\n+    {\n+        ImmutableMap.Builder<Symbol, WindowNode.Function> functions = ImmutableMap.builder();\n+        WindowNode.Frame defaultFrame = new WindowNode.Frame(RANGE, UNBOUNDED_PRECEDING, Optional.empty(), Optional.empty(), CURRENT_ROW, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());\n+\n+        for (int i = 0; i < markers.size(); i++) {\n+            Symbol output = countOutputs.get(i);\n+            functions.put(output, new WindowNode.Function(\n+                    countFunction,\n+                    ImmutableList.of(markers.get(i).toSymbolReference()),\n+                    defaultFrame,\n+                    false));\n+        }\n+\n+        functions.put(rowNumberSymbol, new WindowNode.Function(\n+                rowNumberFunction,\n+                ImmutableList.of(),\n+                defaultFrame,\n+                false));\n+\n+        return new WindowNode(\n+                idAllocator.getNextId(),\n+                sourceNode,\n+                new Specification(\n+                        originalColumns,\n+                        Optional.empty()),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cdf39ec403b73173529efd359f504d5005d81203", "url": "https://github.com/trinodb/trino/commit/cdf39ec403b73173529efd359f504d5005d81203", "message": "Return counts from SetOperationTranslator\n\nReturn row counts instead of predicates based on them.\nIt will allow to reuse the information in other context than\nEXCEPT DISTINCT or INTERSECT DISTINCT.", "committedDate": "2020-11-16T14:16:09Z", "type": "commit"}, {"oid": "cc6f3775e501fc6a6a36f7a63007bef457e8c051", "url": "https://github.com/trinodb/trino/commit/cc6f3775e501fc6a6a36f7a63007bef457e8c051", "message": "Rename rules\n\nSpecify set quantifier in names of the rules\ntransforming certain SetOperationNodes", "committedDate": "2020-11-16T14:16:10Z", "type": "commit"}, {"oid": "ac5c0bb6590724feabea7da00c586a693ab96156", "url": "https://github.com/trinodb/trino/commit/ac5c0bb6590724feabea7da00c586a693ab96156", "message": "Verify column types in set operation\n\nImplementation of certain set operations involves grouping.\nAlso, according to the spec, if the set operator is\nUNION DISTINCT, EXCEPT ALL, EXCEPT DISTINCT,\nINTERSECT ALL, INTERSECT DISTINCT,\nall columns are operands of grouping operation.\nIn that case all columns must be of comparable types.", "committedDate": "2020-11-16T14:16:10Z", "type": "commit"}, {"oid": "12530a237217cd772cc4d2dbf69d215701c9e7c4", "url": "https://github.com/trinodb/trino/commit/12530a237217cd772cc4d2dbf69d215701c9e7c4", "message": "Remove redundant check", "committedDate": "2020-11-16T14:16:10Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "cb303140bcd3e4205f21b281e2ece7692df5ad88", "url": "https://github.com/trinodb/trino/commit/cb303140bcd3e4205f21b281e2ece7692df5ad88", "message": "Add support for EXCEPT ALL, INTERSECT ALL", "committedDate": "2020-11-16T20:02:12Z", "type": "commit"}, {"oid": "cb303140bcd3e4205f21b281e2ece7692df5ad88", "url": "https://github.com/trinodb/trino/commit/cb303140bcd3e4205f21b281e2ece7692df5ad88", "message": "Add support for EXCEPT ALL, INTERSECT ALL", "committedDate": "2020-11-16T20:02:12Z", "type": "forcePushed"}]}