{"pr_number": 5692, "pr_title": "Fix timestamp with time zone coercion", "pr_createdAt": "2020-10-26T14:20:53Z", "pr_url": "https://github.com/trinodb/trino/pull/5692", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512053053", "bodyText": "A comment will be helpful for why this check is needed. From what I understood this is to make sure we provide a TimestampLiteral only for cases where roundtrip is possible.", "author": "hashhar", "createdAt": "2020-10-26T15:31:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -210,6 +218,32 @@ public Expression toExpression(Object object, Type type)\n             return new GenericLiteral(\"DATE\", new SqlDate(toIntExact((Long) object)).toString());\n         }\n \n+        if (type instanceof TimestampType) {\n+            TimestampType timestampType = (TimestampType) type;\n+            String representation;\n+            if (timestampType.isShort()) {\n+                representation = TimestampToVarcharCast.cast(timestampType.getPrecision(), (Long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampToVarcharCast.cast(timestampType.getPrecision(), (LongTimestamp) object).toStringUtf8();\n+            }\n+            return new TimestampLiteral(representation);\n+        }\n+\n+        if (type instanceof TimestampWithTimeZoneType) {\n+            TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) type;\n+            String representation;\n+            if (timestampWithTimeZoneType.isShort()) {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (LongTimestampWithTimeZone) object).toStringUtf8();\n+            }\n+            if (object.equals(parseTimestampWithTimeZone(timestampWithTimeZoneType.getPrecision(), representation))) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzMjQ1Ng==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512132456", "bodyText": "This is weird check. Can't we determine if representation of given value as literal is possible just by looking at value itself. Not reverse-probing generated literal value?", "author": "losipiuk", "createdAt": "2020-10-26T17:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNjg1OA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512206858", "bodyText": "Agreed. The \"as varchar\" representation for a timestamp w/ tz is unambiguous, so this check is unnecessary.", "author": "martint", "createdAt": "2020-10-26T19:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUwMzM4OA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512503388", "bodyText": "The check is necessary & is test covered by these cases in TLE\n// DST change backward - no direct representation\nassertRoundTrip(packDateTimeWithZone(1603589478_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), Long::equals);\nassertRoundTrip(packDateTimeWithZone(1603589478_123L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(3), Long::equals);\nassertRoundTrip(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603589478_123L, 123000000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(6), LongTimestampWithTimeZone::equals);\nassertRoundTrip(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603589478_123L, 123456000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(9), LongTimestampWithTimeZone::equals);\nassertRoundTrip(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603589478_123L, 123456789, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(12), LongTimestampWithTimeZone::equals);", "author": "findepi", "createdAt": "2020-10-27T08:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxNDExNg==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515314116", "bodyText": "The question is how do we ever end up with a timestamp w/ tz that falls in the gap or that has dual representation.\nPlease, add a comment and TODO to evaluate that behavior. We may want to disallow that in general.", "author": "martint", "createdAt": "2020-10-30T18:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUxODQzMA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515518430", "bodyText": "We may want to disallow that in general.\n\nplease file an issue for this, i'll be ref it from the TODO comment", "author": "findepi", "createdAt": "2020-10-31T17:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4Mzg4Mw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516083883", "bodyText": "The question is how do we ever end up with a timestamp w/ tz that falls in the gap or that has dual representation.\n\nFWIW the Java Time solves this by encoding \"point in time\", zone and offset within a value\nInstant instant = Instant.parse(\"2020-10-25T01:01:00Z\");\nZoneId zone = ZoneId.of(\"Europe/Warsaw\");\nZonedDateTime zonedDateTime = instant.atZone(zone);\nSystem.out.printf(\"%s %s\\n\", zonedDateTime, zonedDateTime.toEpochSecond()); // 2020-10-25T02:01+01:00[Europe/Warsaw] 1603587660\nzonedDateTime = zonedDateTime.toLocalDateTime().atZone(zone);\nSystem.out.printf(\"%s %s\\n\", zonedDateTime, zonedDateTime.toEpochSecond()); // 2020-10-25T02:01+02:00[Europe/Warsaw] 1603584060\nthus it can distinguish otherwise ambiguous values within DST backwards change.", "author": "findepi", "createdAt": "2020-11-02T16:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NzQ1MA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512057450", "bodyText": "If this is something the SQL spec says then I would like if the comment ended with must be considered equal.\nFrom what I can see the spec says equality is when the UTC Instants are same (regardless of offset used).", "author": "hashhar", "createdAt": "2020-10-26T15:37:16Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -196,6 +210,11 @@ private Expression unwrapCast(ComparisonExpression expression)\n             Type sourceType = typeAnalyzer.getType(session, types, cast.getExpression());\n             Type targetType = typeAnalyzer.getType(session, types, expression.getRight());\n \n+            if (targetType instanceof TimestampWithTimeZoneType) {\n+                // Note: two TIMESTAMP WITH TIME ZONE values differing in zone only are considered equal.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMzQwMQ==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512213401", "bodyText": "Indeed, that comment is incorrect. They are considered equal if their instant in the same.\nThis deserves a better comment, too. The reason we reinterpret the value in the session timezone is so that the conversion roundtrips properly when going from timestamp w/ tz -> timestamp -> timestamp w/ tz.", "author": "martint", "createdAt": "2020-10-26T19:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NzQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUwNTc3NQ==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512505775", "bodyText": "Indeed, that comment is incorrect. They are considered equal if their instant in the same.\n\nThis is what i meant, i added \"same instant\"  to make the comment clearer\n// Note: two TIMESTAMP WITH TIME ZONE values differing in zone only (same instant) are considered equal.\n\n\nThis deserves a better comment, too. The reason we reinterpret the value in the session timezone is so that the conversion roundtrips properly when going from timestamp w/ tz -> timestamp -> timestamp w/ tz.\n\nYes, this is the point. I put the check & explanation in io.prestosql.sql.planner.iterative.rule.UnwrapCastInComparison.Visitor#hasInjectiveImplicitCoercion method.", "author": "findepi", "createdAt": "2020-10-27T08:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1OTU2MA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512059560", "bodyText": "nit: I'd like the null timestamp and timestamptz changes to also go here. Or move the BIGINT case into testEncodeBigint.", "author": "hashhar", "createdAt": "2020-10-26T15:39:53Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLiteralEncoder.java", "diffHunk": "@@ -90,28 +98,154 @@\n             ImmutableSet.of());\n \n     @Test\n-    public void testEncode()\n+    public void testEncodeNull()\n     {\n-        assertEncodeCaseInsensitively(utf8Slice(\"hello\"), VARBINARY, literalVarbinary(\"hello\".getBytes(UTF_8)));\n         assertEncode(null, UNKNOWN, \"null\");\n         assertEncode(null, BIGINT, \"CAST(null AS bigint)\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUwNjY3NQ==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512506675", "bodyText": "rearranged as requested", "author": "findepi", "createdAt": "2020-10-27T08:44:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1OTU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEyODE5NA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512128194", "bodyText": "typo in Rpresent TIMESTAMP constants readably in EXPLAIN commit message", "author": "losipiuk", "createdAt": "2020-10-26T17:08:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -23,11 +23,14 @@\n import io.prestosql.metadata.Metadata;\n import io.prestosql.metadata.ResolvedFunction;\n import io.prestosql.operator.scalar.VarbinaryFunctions;\n+import io.prestosql.operator.scalar.timestamp.TimestampToVarcharCast;\n import io.prestosql.spi.block.Block;\n import io.prestosql.spi.type.CharType;\n import io.prestosql.spi.type.DecimalType;\n import io.prestosql.spi.type.Decimals;\n+import io.prestosql.spi.type.LongTimestamp;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzMDE1Mw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512130153", "bodyText": "typo in Rpresent TIMESTAMP WITH TIME ZONE constants readably in EXPLAIN commit message", "author": "losipiuk", "createdAt": "2020-10-26T17:11:44Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -24,13 +24,16 @@\n import io.prestosql.metadata.ResolvedFunction;\n import io.prestosql.operator.scalar.VarbinaryFunctions;\n import io.prestosql.operator.scalar.timestamp.TimestampToVarcharCast;\n+import io.prestosql.operator.scalar.timestamptz.TimestampWithTimeZoneToVarcharCast;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzNTMwMA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512135300", "bodyText": "should assertEncode also call assertRoundTrip internally?", "author": "losipiuk", "createdAt": "2020-10-26T17:19:10Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLiteralEncoder.java", "diffHunk": "@@ -168,6 +173,62 @@ public void testEncodeTimestamp()\n         assertEncode(new LongTimestamp(1603710138_000000L, 0), createTimestampType(12), \"TIMESTAMP '2020-10-26 11:02:18.000000000000'\");\n     }\n \n+    @Test\n+    public void testEncodeTimestampWithTimeZone()\n+    {\n+        for (int precision = 0; precision <= 12; precision++) {\n+            assertEncode(null, createTimestampWithTimeZoneType(precision), format(\"CAST(null AS timestamp(%s) with time zone)\", precision));\n+        }\n+\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(0), \"TIMESTAMP '2020-10-26 11:02:18 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_100L, UTC_KEY), createTimestampWithTimeZoneType(1), \"TIMESTAMP '2020-10-26 11:02:18.1 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_120L, UTC_KEY), createTimestampWithTimeZoneType(2), \"TIMESTAMP '2020-10-26 11:02:18.12 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_123L, UTC_KEY), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-10-26 11:02:18.123 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 100000000, UTC_KEY), createTimestampWithTimeZoneType(4), \"TIMESTAMP '2020-10-26 11:02:18.1231 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 120000000, UTC_KEY), createTimestampWithTimeZoneType(5), \"TIMESTAMP '2020-10-26 11:02:18.12312 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123000000, UTC_KEY), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-10-26 11:02:18.123123 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123400000, UTC_KEY), createTimestampWithTimeZoneType(7), \"TIMESTAMP '2020-10-26 11:02:18.1231234 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123450000, UTC_KEY), createTimestampWithTimeZoneType(8), \"TIMESTAMP '2020-10-26 11:02:18.12312345 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456000, UTC_KEY), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-10-26 11:02:18.123123456 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456700, UTC_KEY), createTimestampWithTimeZoneType(10), \"TIMESTAMP '2020-10-26 11:02:18.1231234567 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456780, UTC_KEY), createTimestampWithTimeZoneType(11), \"TIMESTAMP '2020-10-26 11:02:18.12312345678 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456789, UTC_KEY), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-10-26 11:02:18.123123456789 UTC'\");\n+\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(1), \"TIMESTAMP '2020-10-26 11:02:18.0 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(2), \"TIMESTAMP '2020-10-26 11:02:18.00 UTC'\");\n+        assertEncode(packDateTimeWithZone(1603710138_000L, UTC_KEY), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-10-26 11:02:18.000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(4), \"TIMESTAMP '2020-10-26 11:02:18.0000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(5), \"TIMESTAMP '2020-10-26 11:02:18.00000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-10-26 11:02:18.000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(7), \"TIMESTAMP '2020-10-26 11:02:18.0000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(8), \"TIMESTAMP '2020-10-26 11:02:18.00000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-10-26 11:02:18.000000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(10), \"TIMESTAMP '2020-10-26 11:02:18.0000000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(11), \"TIMESTAMP '2020-10-26 11:02:18.00000000000 UTC'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_000L, 0, UTC_KEY), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-10-26 11:02:18.000000000000 UTC'\");\n+\n+        // with zone\n+        assertEncode(packDateTimeWithZone(1603710138_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), \"TIMESTAMP '2020-10-26 12:02:18 Europe/Warsaw'\");\n+        assertEncode(packDateTimeWithZone(1603710138_123L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-10-26 12:02:18.123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123000000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-10-26 12:02:18.123123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-10-26 12:02:18.123123456 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1603710138_123L, 123456789, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-10-26 12:02:18.123123456789 Europe/Warsaw'\");\n+\n+        // DST change forward\n+        assertEncode(packDateTimeWithZone(1585445478_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), \"TIMESTAMP '2020-03-29 03:31:18 Europe/Warsaw'\");\n+        assertEncode(packDateTimeWithZone(1585445478_123L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(3), \"TIMESTAMP '2020-03-29 03:31:18.123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1585445478_123L, 123000000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(6), \"TIMESTAMP '2020-03-29 03:31:18.123123 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1585445478_123L, 123456000, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(9), \"TIMESTAMP '2020-03-29 03:31:18.123123456 Europe/Warsaw'\");\n+        assertEncode(LongTimestampWithTimeZone.fromEpochMillisAndFraction(1585445478_123L, 123456789, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(12), \"TIMESTAMP '2020-03-29 03:31:18.123123456789 Europe/Warsaw'\");\n+\n+        // DST change backward - no direct representation\n+        assertRoundTrip(packDateTimeWithZone(1603589478_000L, TimeZoneKey.getTimeZoneKey(\"Europe/Warsaw\")), createTimestampWithTimeZoneType(0), Long::equals);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxMTMxNw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512211317", "bodyText": "This is probably something we should address separately. It shouldn't be possible to construct a timestamp w/ tz from a value that falls in a DST gap. The cast from varchar -> timestamp w/ tz already prevents it, but it's possible other places are not as strict.", "author": "martint", "createdAt": "2020-10-26T19:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzNTMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUxMDM2Nw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512510367", "bodyText": "should assertEncode also call assertRoundTrip internally?\n\n@losipiuk  let's keep it out of scope of this PR, maybe?\n\nThis is probably something we should address separately. It shouldn't be possible to construct a timestamp w/ tz from a value that falls in a DST gap.\n\n@martint maybe. This is a bigger change about semantics of the timestamp with time zone -- is it a pair of (instant, zone) or not. please file an issue.\nNote however that the case here is not about DST Gap (change forward), but about change backward -- local time being doubled, and so some instants being not \"addressable\".", "author": "findepi", "createdAt": "2020-10-27T08:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzNTMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc1ODk5Mw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r513758993", "bodyText": "is it a pair of (instant, zone) or not.\n\nFrom a SQL standard perspective, it's a collection of fields: year, month, day, hour, minute, second, timezone hour and timezone minute. Although, in multiple places in the spec there are references to the \"UTC component\", which is the value normalized to UTC + a time zone displacement:\nA datetime value, of data type TIME WITHOUT TIME ZONE or TIMESTAMP WITHOUT TIME ZONE, \nmay represent a local time, whereas a datetime value of data type TIME WITH TIME ZONE or \nTIMESTAMP WITH TIME ZONE represents UTC.", "author": "martint", "createdAt": "2020-10-28T21:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzNTMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM1NjU3OA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r514356578", "bodyText": "last time i checked, the spec conveniently did no go into details about political (named) zones. without them everything is simple.", "author": "findepi", "createdAt": "2020-10-29T15:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjEzNTMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxNDE3NA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512214174", "bodyText": "The commit message needs an explanation of why it's broken.", "author": "martint", "createdAt": "2020-10-26T19:27:36Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -13,6 +13,7 @@\n  */\n package io.prestosql.sql.planner.iterative.rule;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUzNjkwNA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512536904", "bodyText": "added", "author": "findepi", "createdAt": "2020-10-27T09:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxNDE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIzNDQ5NA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512234494", "bodyText": "What does \"instant truncation\" refer to here?", "author": "martint", "createdAt": "2020-10-26T20:04:19Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -462,6 +506,48 @@ private int compare(Type type, Object first, Object second)\n         }\n     }\n \n+    /**\n+     * Replace time zone component of a {@link TimestampWithTimeZoneType} value with a given one.\n+     */\n+    private static Object withTimeZone(TimestampWithTimeZoneType type, Object value, TimeZoneKey newZone)\n+    {\n+        if (type.isShort()) {\n+            return packDateTimeWithZone(unpackMillisUtc((long) value), newZone);\n+        }\n+        LongTimestampWithTimeZone longTimestampWithTimeZone = (LongTimestampWithTimeZone) value;\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(longTimestampWithTimeZone.getEpochMillis(), longTimestampWithTimeZone.getPicosOfMilli(), newZone);\n+    }\n+\n+    private static TimeZoneKey getTimeZone(TimestampWithTimeZoneType type, Object value)\n+    {\n+        if (type.isShort()) {\n+            return unpackZoneKey(((long) value));\n+        }\n+        return TimeZoneKey.getTimeZoneKey(((LongTimestampWithTimeZone) value).getTimeZoneKey());\n+    }\n+\n+    @VisibleForTesting\n+    static boolean isTimestampToTimestampWithTimeZoneInjectiveAt(ZoneId zone, Instant instant)\n+    {\n+        ZoneOffsetTransition transition = zone.getRules().previousTransition(instant);\n+        if (transition != null && !transition.getDuration().isNegative() &&\n+                transition.getDateTimeAfter().minusNanos(1).atZone(zone).toInstant().isAfter(instant)) {\n+            // DST change forward and the instant is ambiguous, being within the 'gap' area non-monotoic remapping\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static Instant getInstantTruncation(TimestampWithTimeZoneType type, Object value)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUzNzM0Nw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512537347", "bodyText": "sorry, this is a typo. Changed to getInstantWithTruncation\n(the point is -- there is no rounding involved when going from picos to nanos)", "author": "findepi", "createdAt": "2020-10-27T09:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIzNDQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIzNDgwOA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r512234808", "bodyText": "return ...", "author": "martint", "createdAt": "2020-10-26T20:04:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -462,6 +506,48 @@ private int compare(Type type, Object first, Object second)\n         }\n     }\n \n+    /**\n+     * Replace time zone component of a {@link TimestampWithTimeZoneType} value with a given one.\n+     */\n+    private static Object withTimeZone(TimestampWithTimeZoneType type, Object value, TimeZoneKey newZone)\n+    {\n+        if (type.isShort()) {\n+            return packDateTimeWithZone(unpackMillisUtc((long) value), newZone);\n+        }\n+        LongTimestampWithTimeZone longTimestampWithTimeZone = (LongTimestampWithTimeZone) value;\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(longTimestampWithTimeZone.getEpochMillis(), longTimestampWithTimeZone.getPicosOfMilli(), newZone);\n+    }\n+\n+    private static TimeZoneKey getTimeZone(TimestampWithTimeZoneType type, Object value)\n+    {\n+        if (type.isShort()) {\n+            return unpackZoneKey(((long) value));\n+        }\n+        return TimeZoneKey.getTimeZoneKey(((LongTimestampWithTimeZone) value).getTimeZoneKey());\n+    }\n+\n+    @VisibleForTesting\n+    static boolean isTimestampToTimestampWithTimeZoneInjectiveAt(ZoneId zone, Instant instant)\n+    {\n+        ZoneOffsetTransition transition = zone.getRules().previousTransition(instant);\n+        if (transition != null && !transition.getDuration().isNegative() &&", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwNjMzMg==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515306332", "bodyText": "I don't think this abstraction buys us much. I would just inline this in the few places where it's used.", "author": "martint", "createdAt": "2020-10-30T18:41:11Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestUnwrapCastInComparison.java", "diffHunk": "@@ -977,4 +1053,29 @@ public void testNoEffect()\n                         filter(\"CAST(A AS INTEGER) = 1\",\n                                 values(\"A\"))));\n     }\n+\n+    private void testNoUnwrap(Session session, String inputType, String inputPredicate, String expectedCastType)\n+    {\n+        assertPlan(format(\"SELECT * FROM (VALUES CAST(NULL AS %s)) t(a) WHERE a %s\", inputType, inputPredicate),\n+                session,\n+                anyTree(\n+                        filter(format(\"CAST(A AS %s) %s\", expectedCastType, inputPredicate),\n+                                values(\"A\"))));\n+    }\n+\n+    private void testUnwrap(Session session, String inputType, String inputPredicate, String expectedPredicate)\n+    {\n+        assertPlan(format(\"SELECT * FROM (VALUES CAST(NULL AS %s)) t(a) WHERE a %s\", inputType, inputPredicate),\n+                session,\n+                anyTree(\n+                        filter(\"A \" + expectedPredicate,\n+                                values(\"A\"))));\n+    }\n+\n+    private static Session withZone(Session session, TimeZoneKey timeZoneKey)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NDUyNA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516084524", "bodyText": "It's used in three places, so i don't think strongly about it, but i think it increases readability of the test code.", "author": "findepi", "createdAt": "2020-11-02T16:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwNjMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwODcxNg==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515308716", "bodyText": "Maybe it's just me, but I find this less readable than having the explicit query in each of the cases, as in the other tests in this class. I keep having to reverse engineer what each of inputType, inputPredicate and expectedCastType mean in the context of a query that would benefit from this optimization. Yes, there is some repetition, but the test cases are self-evident, easier to understand at first glance, and easier to copy/paste when testing with a live server.", "author": "martint", "createdAt": "2020-10-30T18:46:06Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestUnwrapCastInComparison.java", "diffHunk": "@@ -977,4 +1053,29 @@ public void testNoEffect()\n                         filter(\"CAST(A AS INTEGER) = 1\",\n                                 values(\"A\"))));\n     }\n+\n+    private void testNoUnwrap(Session session, String inputType, String inputPredicate, String expectedCastType)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NzY3OQ==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516087679", "bodyText": "I started with explicit tests, following other code in this class. Change the approach because:\n\nhaving 5 lines for each test case felt overly verbose in a test method when i plan to cover many individual test cases (eg timestamps case)\n\nwith that many cases it's important to be able to compare between them to see what's tested, what's not, so verbosity matters here\n\n\nafter extracting the method the test code provides what is important -- the symbol type, the constant compared against and the expected state -- without providing irrelevant pieces like VALUES\n\none day we will add constant folding for Filter on top of VALUES ...\nor we will just add additional  assertion where the VALUES are replaced with a temporary test table in eg memory connector\n\n\n\n\nbut the test cases are self-evident, easier to understand at first glance, and easier to copy/paste when testing with a live server.\n\ni agree with this", "author": "findepi", "createdAt": "2020-11-02T16:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwODcxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MzE5Mg==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516853192", "bodyText": "one day we will add constant folding for Filter on top of VALUES ...\nor we will just add additional assertion where the VALUES are replaced with a temporary test table in eg memory connector\n\n... and we'll adjust the code to match, then. But ok, leave it.", "author": "martint", "createdAt": "2020-11-03T17:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwODcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxMDQ5Ng==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515310496", "bodyText": "Is this still pending?", "author": "martint", "createdAt": "2020-10-30T18:49:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -433,6 +452,31 @@ private boolean hasInjectiveImplicitCoercion(Type source, Type target, Object va\n                 }\n             }\n \n+            if (target instanceof TimestampWithTimeZoneType) {\n+                TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) target;\n+                if (source instanceof TimestampType) {\n+                    // Cast from TIMESTAMP WITH TIME ZONE to TIMESTAMP and back to TIMESTAMP WITH TIME ZONE does not round trip, unless the value's zone is equal to sesion zone\n+                    if (!getTimeZone(timestampWithTimeZoneType, value).equals(session.getTimeZoneKey())) {\n+                        return false;\n+                    }\n+\n+                    // Cast from TIMESTAMP to TIMESTAMP WITH TIME ZONE is not monotonic when there is a forward DST change in the session zone\n+                    if (!isTimestampToTimestampWithTimeZoneInjectiveAt(session.getTimeZoneKey().getZoneId(), getInstantWithTruncation(timestampWithTimeZoneType, value))) {\n+                        return false;\n+                    }\n+\n+                    return true;\n+                }\n+                // CAST from TIMESTAMP WITH TIME ZONE to d and back to TIMESTAMP WITH TIME ZONE does not round trip for most types d\n+                // TODO add test coverage", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3OTQ5Nw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516079497", "bodyText": "Yes, this is about other types than TIMESTAMP -> TIMESTAMP WITH TIME ZONE.\nI conveniently block them, which is correct, but not ambitious.  Hence the TODO", "author": "findepi", "createdAt": "2020-11-02T16:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxMDQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxNzk2Nw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r515317967", "bodyText": "This is being used in the call to isTimestampToTimestampWithTimeZoneInjectiveAt. What is the implication of truncation in determining if there is a transition if the instant is at the edge? What if the actual value is right outside of the transition by a few picoseconds? What does previousTransition return if the instant in nanoseconds is exactly at upper edge of a transition?", "author": "martint", "createdAt": "2020-10-30T19:05:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -462,6 +506,48 @@ private int compare(Type type, Object first, Object second)\n         }\n     }\n \n+    /**\n+     * Replace time zone component of a {@link TimestampWithTimeZoneType} value with a given one, preserving point in time\n+     * (equivalent to {@link java.time.ZonedDateTime#withZoneSameInstant}.\n+     */\n+    private static Object withTimeZone(TimestampWithTimeZoneType type, Object value, TimeZoneKey newZone)\n+    {\n+        if (type.isShort()) {\n+            return packDateTimeWithZone(unpackMillisUtc((long) value), newZone);\n+        }\n+        LongTimestampWithTimeZone longTimestampWithTimeZone = (LongTimestampWithTimeZone) value;\n+        return LongTimestampWithTimeZone.fromEpochMillisAndFraction(longTimestampWithTimeZone.getEpochMillis(), longTimestampWithTimeZone.getPicosOfMilli(), newZone);\n+    }\n+\n+    private static TimeZoneKey getTimeZone(TimestampWithTimeZoneType type, Object value)\n+    {\n+        if (type.isShort()) {\n+            return unpackZoneKey(((long) value));\n+        }\n+        return TimeZoneKey.getTimeZoneKey(((LongTimestampWithTimeZone) value).getTimeZoneKey());\n+    }\n+\n+    @VisibleForTesting\n+    static boolean isTimestampToTimestampWithTimeZoneInjectiveAt(ZoneId zone, Instant instant)\n+    {\n+        ZoneOffsetTransition transition = zone.getRules().previousTransition(instant);\n+        if (transition == null) {\n+            return true;\n+        }\n+        // DST change forward and the instant is ambiguous, being within the 'gap' area non-monotonic remapping\n+        return transition.getDuration().isNegative() || !transition.getDateTimeAfter().minusNanos(1).atZone(zone).toInstant().isAfter(instant);\n+    }\n+\n+    private static Instant getInstantWithTruncation(TimestampWithTimeZoneType type, Object value)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4NDEwNw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516884107", "bodyText": "Truncation is correct, because transitions are defined with nanosecond precision (in fact, most likely with second precision only). This is why i truncate here -- all i want is not to round up to the next nanosecond, with could move me out of the ambiguity area.", "author": "findepi", "createdAt": "2020-11-03T18:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxNzk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NDc4OQ==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516894789", "bodyText": "See also \"last within\" test cases.", "author": "findepi", "createdAt": "2020-11-03T19:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxNzk2Nw=="}], "type": "inlineReview"}, {"oid": "1dfa2046f7e2887ef46b2e32b89ee8f11a7ed831", "url": "https://github.com/trinodb/trino/commit/1dfa2046f7e2887ef46b2e32b89ee8f11a7ed831", "message": "Import asList statically", "committedDate": "2020-11-03T12:10:35Z", "type": "commit"}, {"oid": "814f2c809ad169d780024b3e4f73f0b47816f3fc", "url": "https://github.com/trinodb/trino/commit/814f2c809ad169d780024b3e4f73f0b47816f3fc", "message": "Fix class/method names", "committedDate": "2020-11-03T12:10:38Z", "type": "commit"}, {"oid": "dcbf398aeaae8994521910ea461a792fe80bb3a0", "url": "https://github.com/trinodb/trino/commit/dcbf398aeaae8994521910ea461a792fe80bb3a0", "message": "Remove unused parameter", "committedDate": "2020-11-03T12:10:38Z", "type": "commit"}, {"oid": "8d540e1a57c3d7eb4804f986b0eee6bbe0daa70c", "url": "https://github.com/trinodb/trino/commit/8d540e1a57c3d7eb4804f986b0eee6bbe0daa70c", "message": "Split test method", "committedDate": "2020-11-03T12:10:38Z", "type": "commit"}, {"oid": "dd903dfed90452119bdb2476d01d12035824d4c9", "url": "https://github.com/trinodb/trino/commit/dd903dfed90452119bdb2476d01d12035824d4c9", "message": "Represent TIMESTAMP constants readably in EXPLAIN", "committedDate": "2020-11-03T12:10:38Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjczNzY4NA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516737684", "bodyText": "#5798", "author": "findepi", "createdAt": "2020-11-03T15:08:31Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/UnwrapCastInComparison.java", "diffHunk": "@@ -433,6 +452,34 @@ private boolean hasInjectiveImplicitCoercion(Type source, Type target, Object va\n                 }\n             }\n \n+            if (target instanceof TimestampWithTimeZoneType) {\n+                TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) target;\n+                if (source instanceof TimestampType) {\n+                    // Cast from TIMESTAMP WITH TIME ZONE to TIMESTAMP and back to TIMESTAMP WITH TIME ZONE does not round trip, unless the value's zone is equal to sesion zone\n+                    if (!getTimeZone(timestampWithTimeZoneType, value).equals(session.getTimeZoneKey())) {\n+                        return false;\n+                    }\n+\n+                    // Cast from TIMESTAMP to TIMESTAMP WITH TIME ZONE is not monotonic when there is a forward DST change in the session zone\n+                    if (!isTimestampToTimestampWithTimeZoneInjectiveAt(session.getTimeZoneKey().getZoneId(), getInstantWithTruncation(timestampWithTimeZoneType, value))) {\n+                        return false;\n+                    }\n+\n+                    return true;\n+                }\n+                // CAST from TIMESTAMP WITH TIME ZONE to d and back to TIMESTAMP WITH TIME ZONE does not round trip for most types d\n+                // TODO add test coverage\n+                // TODO (https://github.com/prestosql/presto/issues/5798) handle DATE -> TIMESTAMP WITH TIME ZONE", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxODE5OA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516818198", "bodyText": "Mention in the commit message that these were in a separate class to be able to test legacy timestamp semantics", "author": "martint", "createdAt": "2020-11-03T16:58:18Z", "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timestamptz/TestTimestampWithTimeZone.java", "diffHunk": "@@ -1310,6 +1310,298 @@ public void testCastToTimeWithTimeZone()\n         assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-03-08 01:23:45.123456789123 -00:35' AS TIME(12) WITH TIME ZONE)\")).matches(\"TIME '01:23:45.123456789123-00:35'\");\n     }\n \n+    @Test", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NjY0NA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516896644", "bodyText": "Added", "author": "findepi", "createdAt": "2020-11-03T19:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxODE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxOTk0Mg==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516819942", "bodyText": "These should already be covered in testRoundDown and testRoundUp", "author": "martint", "createdAt": "2020-11-03T17:00:52Z", "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timestamp/TestTimestamp.java", "diffHunk": "@@ -1165,6 +1165,298 @@ public void testCastToTimeWithTimeZone()\n         assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 23:59:59.999999999999' AS TIME(11) WITH TIME ZONE)\", session)).matches(\"TIME '00:00:00.00000000000+08:35'\");\n     }\n \n+    @Test\n+    public void testCastToTimestamp()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NjcxMw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516896713", "bodyText": "Commit dropped.", "author": "findepi", "createdAt": "2020-11-03T19:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgxOTk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MTAyMQ==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516841021", "bodyText": "Unrelated to this commit.", "author": "martint", "createdAt": "2020-11-03T17:33:56Z", "path": "presto-main/src/test/java/io/prestosql/operator/scalar/timestamp/TestTimestamp.java", "diffHunk": "@@ -1183,6 +1183,19 @@ public void testCastToTimestamp()\n         assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 12:34:56.12345678912' AS TIMESTAMP(11))\")).matches(\"TIMESTAMP '2020-05-01 12:34:56.12345678912'\");\n         assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 12:34:56.123456789123' AS TIMESTAMP(12))\")).matches(\"TIMESTAMP '2020-05-01 12:34:56.123456789123'\");\n \n+        assertThat(assertions.expression(\"CAST(TIMESTAMP '2020-05-01 12:34:56.9' AS TIMESTAMP(1))\")).matches(\"TIMESTAMP '2020-05-01 12:34:56.9'\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5Njk1MQ==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516896951", "bodyText": "Dropped", "author": "findepi", "createdAt": "2020-11-03T19:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg0MTAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NzExNA==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516857114", "bodyText": "Link to #5781", "author": "martint", "createdAt": "2020-11-03T18:00:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LiteralEncoder.java", "diffHunk": "@@ -226,6 +230,25 @@ public Expression toExpression(Object object, Type type)\n             return new TimestampLiteral(representation);\n         }\n \n+        if (type instanceof TimestampWithTimeZoneType) {\n+            TimestampWithTimeZoneType timestampWithTimeZoneType = (TimestampWithTimeZoneType) type;\n+            String representation;\n+            if (timestampWithTimeZoneType.isShort()) {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (long) object).toStringUtf8();\n+            }\n+            else {\n+                representation = TimestampWithTimeZoneToVarcharCast.cast(timestampWithTimeZoneType.getPrecision(), (LongTimestampWithTimeZone) object).toStringUtf8();\n+            }\n+            if (!object.equals(parseTimestampWithTimeZone(timestampWithTimeZoneType.getPrecision(), representation))) {\n+                // Certain (point in time, time zone) pairs cannot be represented as a TIMESTAMP literal, as the literal uses local date/time in given time zone.\n+                // Thus, during DST backwards change by e.g. 1 hour, the local time is \"repeated\" twice and thus one local date/time logically corresponds to two\n+                // points in time, leaving one of them non-referencable.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NzU5Mw==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516897593", "bodyText": "right, link added", "author": "findepi", "createdAt": "2020-11-03T19:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1NzExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1ODE4OQ==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516858189", "bodyText": "Why not build a session with that time zone instead? Then, the test won't depend on external factors and will be self-contained.", "author": "martint", "createdAt": "2020-11-03T18:02:17Z", "path": "presto-main/src/test/java/io/prestosql/sql/query/TestUnwrapCastInComparison.java", "diffHunk": "@@ -214,6 +218,107 @@ public void testVarchar()\n         }\n     }\n \n+    @Test\n+    public void testCastTimestampToTimestampWithTimeZone()\n+    {\n+        ZoneId sessionZone = assertions.getDefaultSession().getTimeZoneKey().getZoneId();\n+        verify(sessionZone.getId().equals(\"Pacific/Apia\"), \"The values in this test assume Pacific/Apia is the session zone\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5ODE0OQ==", "url": "https://github.com/trinodb/trino/pull/5692#discussion_r516898149", "bodyText": "I didn't want to overload validate, but OK, will do.", "author": "findepi", "createdAt": "2020-11-03T19:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1ODE4OQ=="}], "type": "inlineReview"}, {"oid": "3e1605dd05ef0f4b77dfd71d7dc2bda717810758", "url": "https://github.com/trinodb/trino/commit/3e1605dd05ef0f4b77dfd71d7dc2bda717810758", "message": "Represent TIMESTAMP WITH TIME ZONE constants readably in EXPLAIN", "committedDate": "2020-11-03T19:18:31Z", "type": "commit"}, {"oid": "1660fac59c576c70567d6de954b777b6394080c9", "url": "https://github.com/trinodb/trino/commit/1660fac59c576c70567d6de954b777b6394080c9", "message": "Move TIMESTAMP TZ to TIMESTAMP cast tests to TestTimestampWithTimeZone class\n\nThey were in a separate class for when we had to parameterize the tests\nfor legacy vs new timestamp semantics. That's no longer necessary.", "committedDate": "2020-11-03T19:18:31Z", "type": "commit"}, {"oid": "40855c69b8c045e55e8dfb4ee2d7fd1b13ec5361", "url": "https://github.com/trinodb/trino/commit/40855c69b8c045e55e8dfb4ee2d7fd1b13ec5361", "message": "Fix rounding in TIMESTAMP TZ to TIMESTAMP cast", "committedDate": "2020-11-03T19:18:31Z", "type": "commit"}, {"oid": "d0bd26cdc8f014f1ce17aacb15301c7d846f2a15", "url": "https://github.com/trinodb/trino/commit/d0bd26cdc8f014f1ce17aacb15301c7d846f2a15", "message": "Extract operator list constant", "committedDate": "2020-11-03T19:18:31Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "254db18c2efc213ed13f57b20971654d8ddfa9e3", "url": "https://github.com/trinodb/trino/commit/254db18c2efc213ed13f57b20971654d8ddfa9e3", "message": "Fix unwrap for TIMESTAMP and TIMESTAMP WITH TIME ZONE\n\nBefore the change, a predicate\n\n    timestamp_column > TIMESTAMP 'date-time some-zone'\n\nwas being converted to\n\n    timestamp_column > TIMESTAMP 'date-time'\n\nHowever, the conversion is correct only when some-zone = session zone.\n\nNote: this seems to be a behavior regression since 341, the\n53bafb41da3b36f923f57f995b012bec9b85be4c commit.", "committedDate": "2020-11-03T19:21:18Z", "type": "commit"}, {"oid": "254db18c2efc213ed13f57b20971654d8ddfa9e3", "url": "https://github.com/trinodb/trino/commit/254db18c2efc213ed13f57b20971654d8ddfa9e3", "message": "Fix unwrap for TIMESTAMP and TIMESTAMP WITH TIME ZONE\n\nBefore the change, a predicate\n\n    timestamp_column > TIMESTAMP 'date-time some-zone'\n\nwas being converted to\n\n    timestamp_column > TIMESTAMP 'date-time'\n\nHowever, the conversion is correct only when some-zone = session zone.\n\nNote: this seems to be a behavior regression since 341, the\n53bafb41da3b36f923f57f995b012bec9b85be4c commit.", "committedDate": "2020-11-03T19:21:18Z", "type": "forcePushed"}, {"oid": "0d82b34b01e50e02a33c4c17ee4455e91610dc3e", "url": "https://github.com/trinodb/trino/commit/0d82b34b01e50e02a33c4c17ee4455e91610dc3e", "message": "empty", "committedDate": "2020-11-03T21:02:26Z", "type": "commit"}]}