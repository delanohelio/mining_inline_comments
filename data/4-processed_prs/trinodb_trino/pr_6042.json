{"pr_number": 6042, "pr_title": "Aggregation simplify declarations", "pr_createdAt": "2020-11-21T21:02:44Z", "pr_url": "https://github.com/trinodb/trino/pull/6042", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ4MDM3NQ==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534480375", "bodyText": "for consistency, maybe call \"toParse\" => \"outputFunction\" or \"outputFunctionToParse? especially since you are calling getName and getAliases functions that require that input", "author": "erichwang", "createdAt": "2020-12-02T21:04:45Z", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -70,89 +70,104 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n         }\n+        // if there are non-exact functions, create a generic function\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n+        }\n+        return functions.build();\n+    }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated);\n+    private static boolean isExact(Signature signature)\n+    {\n+        return signature.getTypeVariableConstraints().isEmpty()\n+                && signature.getArgumentTypes().stream().noneMatch(TypeSignature::isCalculated)\n+                && !signature.getReturnType().isCalculated();\n     }\n \n-    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition)\n+    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition, AnnotatedElement toParse)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4ODI3NA==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534588274", "bodyText": "Typo in commit message \"aggergation\" => \"aggregation\"", "author": "erichwang", "createdAt": "2020-12-03T01:03:23Z", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxAggregationFunction.java", "diffHunk": "@@ -26,9 +26,12 @@\n import io.prestosql.operator.aggregation.AggregationMetadata.AccumulatorStateDescriptor;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4ODUzNQ==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534588535", "bodyText": "Typo in commit message \"aggergation\" => \"aggregation\"", "author": "erichwang", "createdAt": "2020-12-03T01:04:05Z", "path": "presto-main/src/main/java/io/prestosql/metadata/FunctionListBuilder.java", "diffHunk": "@@ -33,12 +33,6 @@ public FunctionListBuilder window(Class<? extends WindowFunction> clazz)\n         return this;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4ODc1Mg==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r534588752", "bodyText": "Commit message type: \"genertic\" => \"generic\"", "author": "erichwang", "createdAt": "2020-12-03T01:04:35Z", "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU3MTQzMQ==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535571431", "bodyText": "@SuppressWarnings(\"unchecked\")", "author": "martint", "createdAt": "2020-12-03T20:28:11Z", "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))\n+                        .collect(toImmutableList()),\n+                genericImplementations.stream()\n+                        .map(implementation2 -> this.withAlias(alias, implementation2))\n+                        .collect(toImmutableList()),\n+                signatureWithName(alias, signature));\n+    }\n+\n+    private T withAlias(String name, T implementation)\n+    {\n+        //noinspection unchecked", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4MDUwNA==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535580504", "bodyText": "This method can be static.\n(BTW, it's not clear to me why this class has to be generic, but I haven't looked at all the uses)", "author": "martint", "createdAt": "2020-12-03T20:36:31Z", "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))\n+                        .collect(toImmutableList()),\n+                genericImplementations.stream()\n+                        .map(implementation2 -> this.withAlias(alias, implementation2))\n+                        .collect(toImmutableList()),\n+                signatureWithName(alias, signature));\n+    }\n+\n+    private T withAlias(String name, T implementation)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4MDg1Mg==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535580852", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .map(implementation1 -> withAlias(alias, implementation1))\n          \n          \n            \n                                    .map(implementation -> withAlias(alias, implementation))", "author": "martint", "createdAt": "2020-12-03T20:36:48Z", "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU4MTQ4OQ==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535581489", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .map(implementation2 -> this.withAlias(alias, implementation2))\n          \n          \n            \n                                    .map(implementation -> withAlias(alias, implementation))", "author": "martint", "createdAt": "2020-12-03T20:37:19Z", "path": "presto-main/src/main/java/io/prestosql/operator/ParametricImplementationsGroup.java", "diffHunk": "@@ -114,6 +118,30 @@ public Signature getSignature()\n         return signature;\n     }\n \n+    public ParametricImplementationsGroup<T> withAlias(String alias)\n+    {\n+        if (alias.equals(signature.getName())) {\n+            return this;\n+        }\n+        return new ParametricImplementationsGroup<T>(\n+                exactImplementations.values().stream()\n+                        .map(implementation -> withAlias(alias, implementation))\n+                        .collect(toImmutableMap(T::getSignature, Function.identity())),\n+                specializedImplementations.stream()\n+                        .map(implementation1 -> withAlias(alias, implementation1))\n+                        .collect(toImmutableList()),\n+                genericImplementations.stream()\n+                        .map(implementation2 -> this.withAlias(alias, implementation2))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY0Njk4NQ==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535646985", "bodyText": "I'm not sure I understand what notion this method is trying to capture (and hence, whether isExact is a good name for it)", "author": "martint", "createdAt": "2020-12-03T21:35:02Z", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -70,89 +70,104 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n         }\n+        // if there are non-exact functions, create a generic function\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n+        }\n+        return functions.build();\n+    }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(implementations.getSignature(), header, implementations, deprecated);\n+    private static boolean isExact(Signature signature)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzOTI1Nw==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r537939257", "bodyText": "The annotated function framework handles exact functions (by this definition) differently than generic functions, so we have to split them.", "author": "dain", "createdAt": "2020-12-08T00:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY0Njk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NDE4NA==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535654184", "bodyText": "Should we get rid of these classes? There shouldn't be any reason to keep them around now that there's a replacement, no?", "author": "martint", "createdAt": "2020-12-03T21:42:20Z", "path": "presto-main/src/main/java/io/prestosql/operator/aggregation/AbstractMinMaxAggregationFunction.java", "diffHunk": "@@ -26,9 +26,12 @@\n import io.prestosql.operator.aggregation.AggregationMetadata.AccumulatorStateDescriptor;\n import io.prestosql.operator.aggregation.state.BlockPositionState;\n import io.prestosql.operator.aggregation.state.BlockPositionStateSerializer;\n-import io.prestosql.operator.aggregation.state.NullableBooleanState;\n-import io.prestosql.operator.aggregation.state.NullableDoubleState;\n-import io.prestosql.operator.aggregation.state.NullableLongState;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzODc1MQ==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r537938751", "bodyText": "They are used in other places where the new classes won't work", "author": "dain", "createdAt": "2020-12-08T00:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NDE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NzAyNw==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535657027", "bodyText": "How can an aggregation not have an intermediate type?", "author": "martint", "createdAt": "2020-12-03T21:45:13Z", "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */\n package io.prestosql.metadata;\n \n+import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.TypeSignatureParameter;\n \n+import java.util.Arrays;\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregationFunctionMetadata\n {\n     private final boolean orderSensitive;\n     private final Optional<TypeSignature> intermediateType;\n \n+    public AggregationFunctionMetadata(boolean orderSensitive, TypeSignature... intermediateTypes)\n+    {\n+        this.orderSensitive = orderSensitive;\n+\n+        if (intermediateTypes.length == 0) {\n+            intermediateType = Optional.empty();\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzODQ4NQ==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r537938485", "bodyText": "non-decomposable aggregations do not have intermediates", "author": "dain", "createdAt": "2020-12-08T00:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1NzAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1OTgyNw==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r535659827", "bodyText": "I think it'd be cleaner, more explicit, and symmetric (what gets passed here would match what gets returned by getIntermediateType() below) to take a single type here and make the caller build a row type if necessary. That could be done with a helper function on the caller side.", "author": "martint", "createdAt": "2020-12-03T21:47:33Z", "path": "presto-main/src/main/java/io/prestosql/metadata/AggregationFunctionMetadata.java", "diffHunk": "@@ -13,18 +13,39 @@\n  */\n package io.prestosql.metadata;\n \n+import io.prestosql.spi.type.StandardTypes;\n import io.prestosql.spi.type.TypeSignature;\n+import io.prestosql.spi.type.TypeSignatureParameter;\n \n+import java.util.Arrays;\n import java.util.Optional;\n \n import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n import static java.util.Objects.requireNonNull;\n \n public class AggregationFunctionMetadata\n {\n     private final boolean orderSensitive;\n     private final Optional<TypeSignature> intermediateType;\n \n+    public AggregationFunctionMetadata(boolean orderSensitive, TypeSignature... intermediateTypes)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzOTQwNg==", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r537939406", "bodyText": "This is a setup for future work", "author": "dain", "createdAt": "2020-12-08T00:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTY1OTgyNw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "532ff583e780db131b7771c705e613757ec3f0cd", "url": "https://github.com/trinodb/trino/commit/532ff583e780db131b7771c705e613757ec3f0cd", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-09-06T19:46:03Z", "type": "forcePushed"}, {"id": "PRRC_kwDOCezRTs4q6DGj", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r719860131", "bodyText": "This needs a better name. If you can you describe what concept this represents I can help come up with another name.", "author": "martint", "createdAt": "2021-10-01T00:29:31Z", "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -72,101 +70,112 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // There must be a single state class and combine function\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+\n+        // Each output function defines a new aggregation function\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            // Input functions can have either an exact signature, or generic/calculate signature\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            // register a set functions for the canonical name, and each alias\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n+        }\n \n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        // if there are non-exact functions, create a single generic/calculated function using these implementations\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n         }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated);\n+        return functions.build();\n+    }\n+\n+    private static boolean isExact(Signature signature)", "originalCommit": "8317c1c369ef96fce3ed80347f87aba5a8f08b9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "PRRC_kwDOCezRTs4q6DQs", "url": "https://github.com/trinodb/trino/pull/6042#discussion_r719860780", "bodyText": "Move arguments to the same line", "author": "martint", "createdAt": "2021-10-01T00:31:40Z", "path": "core/trino-main/src/main/java/io/trino/operator/aggregation/AggregationFromAnnotationsParser.java", "diffHunk": "@@ -72,101 +70,112 @@ public static ParametricAggregation parseFunctionDefinitionWithTypesConstraint(C\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n-\n-        ImmutableList.Builder<ParametricAggregation> builder = ImmutableList.builder();\n-\n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n-                for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                    Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                    for (AggregationHeader header : parseHeaders(aggregationDefinition, outputFunction)) {\n-                        AggregationImplementation onlyImplementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                        ParametricImplementationsGroup<AggregationImplementation> implementations = ParametricImplementationsGroup.of(onlyImplementation);\n-                        builder.add(new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated));\n-                    }\n+\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // There must be a single state class and combine function\n+        Class<?> stateClass = getStateClass(aggregationDefinition);\n+        Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n+\n+        // Each output function defines a new aggregation function\n+        for (Method outputFunction : getOutputFunctions(aggregationDefinition, stateClass)) {\n+            AggregationHeader header = parseHeader(aggregationDefinition, outputFunction);\n+\n+            // Input functions can have either an exact signature, or generic/calculate signature\n+            List<AggregationImplementation> exactImplementations = new ArrayList<>();\n+            List<AggregationImplementation> nonExactImplementations = new ArrayList<>();\n+            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n+                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n+                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header.getName(), inputFunction, removeInputFunction, outputFunction, combineFunction);\n+                if (isExact(implementation.getSignature())) {\n+                    exactImplementations.add(implementation);\n+                }\n+                else {\n+                    nonExactImplementations.add(implementation);\n                 }\n             }\n+\n+            // register a set functions for the canonical name, and each alias\n+            functions.addAll(buildFunctions(header.getName(), header, stateClass, exactImplementations, nonExactImplementations));\n+            for (String alias : getAliases(aggregationDefinition.getAnnotation(AggregationFunction.class), outputFunction)) {\n+                functions.addAll(buildFunctions(alias, header, stateClass, exactImplementations, nonExactImplementations));\n+            }\n         }\n \n-        return builder.build();\n+        return functions.build();\n     }\n \n-    public static ParametricAggregation parseFunctionDefinition(Class<?> aggregationDefinition)\n+    private static List<ParametricAggregation> buildFunctions(\n+            String name,\n+            AggregationHeader header,\n+            Class<?> stateClass,\n+            List<AggregationImplementation> exactImplementations,\n+            List<AggregationImplementation> nonExactImplementations)\n     {\n-        ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n-        AggregationHeader header = parseHeader(aggregationDefinition);\n-        boolean deprecated = aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0;\n+        ImmutableList.Builder<ParametricAggregation> functions = ImmutableList.builder();\n+\n+        // create a separate function for each exact implementation\n+        for (AggregationImplementation exactImplementation : exactImplementations) {\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, exactImplementation.getSignature()),\n+                    header,\n+                    stateClass,\n+                    ParametricImplementationsGroup.of(exactImplementation).withAlias(name)));\n+        }\n \n-        for (Class<?> stateClass : getStateClasses(aggregationDefinition)) {\n-            Method combineFunction = getCombineFunction(aggregationDefinition, stateClass);\n-            Method outputFunction = getOnlyElement(getOutputFunctions(aggregationDefinition, stateClass));\n-            for (Method inputFunction : getInputFunctions(aggregationDefinition, stateClass)) {\n-                Optional<Method> removeInputFunction = getRemoveInputFunction(aggregationDefinition, inputFunction);\n-                AggregationImplementation implementation = parseImplementation(aggregationDefinition, header, stateClass, inputFunction, removeInputFunction, outputFunction, combineFunction);\n-                implementationsBuilder.addImplementation(implementation);\n-            }\n+        // if there are non-exact functions, create a single generic/calculated function using these implementations\n+        if (!nonExactImplementations.isEmpty()) {\n+            ParametricImplementationsGroup.Builder<AggregationImplementation> implementationsBuilder = ParametricImplementationsGroup.builder();\n+            nonExactImplementations.forEach(implementationsBuilder::addImplementation);\n+            ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n+            functions.add(new ParametricAggregation(\n+                    signatureWithName(name, implementations.getSignature()),\n+                    header,\n+                    stateClass,\n+                    implementations.withAlias(name)));\n         }\n \n-        ParametricImplementationsGroup<AggregationImplementation> implementations = implementationsBuilder.build();\n-        return new ParametricAggregation(signatureWithName(header.getName(), implementations.getSignature()), header, implementations, deprecated);\n+        return functions.build();\n+    }\n+\n+    private static boolean isExact(Signature signature)\n+    {\n+        return signature.getTypeVariableConstraints().isEmpty()\n+                && signature.getArgumentTypes().stream().noneMatch(TypeSignature::isCalculated)\n+                && !signature.getReturnType().isCalculated();\n     }\n \n-    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition)\n+    private static AggregationHeader parseHeader(AnnotatedElement aggregationDefinition, AnnotatedElement outputFunction)\n     {\n         AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n         requireNonNull(aggregationAnnotation, \"aggregationAnnotation is null\");\n+        String name = getName(aggregationAnnotation, outputFunction);\n         return new AggregationHeader(\n-                aggregationAnnotation.value(),\n-                aggregationAnnotation.value(),\n-                parseDescription(aggregationDefinition),\n+                name,\n+                parseDescription(aggregationDefinition, outputFunction),\n                 aggregationAnnotation.decomposable(),\n                 aggregationAnnotation.isOrderSensitive(),\n-                aggregationAnnotation.hidden());\n+                aggregationAnnotation.hidden(),\n+                aggregationDefinition.getAnnotationsByType(Deprecated.class).length > 0);\n     }\n \n-    private static List<AggregationHeader> parseHeaders(AnnotatedElement aggregationDefinition, AnnotatedElement toParse)\n+    private static String getName(AggregationFunction aggregationAnnotation, AnnotatedElement outputFunction)\n     {\n-        AggregationFunction aggregationAnnotation = aggregationDefinition.getAnnotation(AggregationFunction.class);\n-\n-        return getNames(toParse, aggregationAnnotation).stream()\n-                .map(aggregationFunctionName ->\n-                        new AggregationHeader(\n-                                aggregationFunctionName.getActualName(),\n-                                aggregationFunctionName.getCanonicalName(),\n-                                parseDescription(aggregationDefinition, toParse),\n-                                aggregationAnnotation.decomposable(),\n-                                aggregationAnnotation.isOrderSensitive(),\n-                                aggregationAnnotation.hidden()))\n-                .collect(toImmutableList());\n+        AggregationFunction annotation = outputFunction.getAnnotation(AggregationFunction.class);\n+        if (annotation != null && !annotation.value().isEmpty()) {\n+            return emptyToNull(annotation.value());\n+        }\n+        return emptyToNull(aggregationAnnotation.value());\n     }\n \n-    private static List<AggregationFunctionName> getNames(@Nullable AnnotatedElement outputFunction, AggregationFunction aggregationAnnotation)\n+    private static List<String> getAliases(AggregationFunction aggregationAnnotation,\n+            AnnotatedElement outputFunction)", "originalCommit": "8317c1c369ef96fce3ed80347f87aba5a8f08b9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "250227ffda48a4ba1eedc7c2c83daa163bbc9607", "url": "https://github.com/trinodb/trino/commit/250227ffda48a4ba1eedc7c2c83daa163bbc9607", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-10-09T03:50:55Z", "type": "forcePushed"}, {"oid": "b87377002fbb1a6b8061def4da4de34b37b140a7", "url": "https://github.com/trinodb/trino/commit/b87377002fbb1a6b8061def4da4de34b37b140a7", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-10-09T05:36:04Z", "type": "forcePushed"}, {"oid": "6e02559f6a43715557b15e643cc5f11c5b1bb91c", "url": "https://github.com/trinodb/trino/commit/6e02559f6a43715557b15e643cc5f11c5b1bb91c", "message": "Change FunctionMetadata signature to be the actual caller signature\n\nRemove actual name field since signature carries actual name\nAdd canonical name field so push down can use canonical name", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "770d3fe1bc83a346775ef180287ba4fbace925c0", "url": "https://github.com/trinodb/trino/commit/770d3fe1bc83a346775ef180287ba4fbace925c0", "message": "Move boolean approx_distinct to separate class", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "db0c4be1912a140e8311dd3020c16de886aceff4", "url": "https://github.com/trinodb/trino/commit/db0c4be1912a140e8311dd3020c16de886aceff4", "message": "Move legacy approx_percentile to separate classes", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "5c1ea5696b20f1d76494f4308b5e01d7fba09b2e", "url": "https://github.com/trinodb/trino/commit/5c1ea5696b20f1d76494f4308b5e01d7fba09b2e", "message": "Simplify parametric aggregation\n\nConsolidate the two annotation processing strategy into a single strategy\nSimplify handling of function aliases\nMove deprecated flag to AggregationHeader", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "c6f8536601cb1e55a30fce8a4cf2e6c4137ad13e", "url": "https://github.com/trinodb/trino/commit/c6f8536601cb1e55a30fce8a4cf2e6c4137ad13e", "message": "Add generic aggregation state holders\n\nGeneric state holders can use an explicit type as opposed to only\nBIGINT, DOUBLE, and BOOLEAN", "committedDate": "2021-10-09T05:38:42Z", "type": "commit"}, {"oid": "e7818e667cdf132092d473ac32f03dab625ce6d7", "url": "https://github.com/trinodb/trino/commit/e7818e667cdf132092d473ac32f03dab625ce6d7", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-10-09T05:54:21Z", "type": "commit"}, {"oid": "e7818e667cdf132092d473ac32f03dab625ce6d7", "url": "https://github.com/trinodb/trino/commit/e7818e667cdf132092d473ac32f03dab625ce6d7", "message": "Require aggregation metadata at construction\n\nRequire full aggregation function metadata during construction of aggregation.\nChange intermediate types to allow generic type signatures.", "committedDate": "2021-10-09T05:54:21Z", "type": "forcePushed"}]}