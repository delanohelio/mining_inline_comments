{"pr_number": 5461, "pr_title": "Support for implicit casting of dynamic filters", "pr_createdAt": "2020-10-08T08:23:28Z", "pr_url": "https://github.com/trinodb/trino/pull/5461", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5ODg3Nw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501598877", "bodyText": "nit: separate commit", "author": "sopel39", "createdAt": "2020-10-08T10:03:02Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -228,9 +229,7 @@ public void unblockStageDynamicFilters(QueryId queryId, PlanFragment plan)\n     public DynamicFilter createDynamicFilter(QueryId queryId, List<DynamicFilters.Descriptor> dynamicFilterDescriptors, Map<Symbol, ColumnHandle> columnHandles)\n     {\n         Multimap<DynamicFilterId, ColumnHandle> sourceColumnHandles = extractSourceColumnHandles(dynamicFilterDescriptors, columnHandles);\n-        Set<DynamicFilterId> dynamicFilters = dynamicFilterDescriptors.stream()\n-                .map(DynamicFilters.Descriptor::getId)\n-                .collect(toImmutableSet());\n+        Set<DynamicFilterId> dynamicFilters = ImmutableSet.copyOf(sourceColumnHandles.keySet());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYzMDExOQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501630119", "bodyText": "I would prefer to keep it within this commit as it's not an unrelated refactoring. This change is needed to avoid failing the checkState in translateSummaryToTupleDomain.", "author": "raunaqmorarka", "createdAt": "2020-10-08T10:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5ODg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMDc1OA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501600758", "bodyText": "reverse if,\nif (!(castExpression.getExpression() instanceof SymbolReference)) {\n  return false;\n}", "author": "sopel39", "createdAt": "2020-10-08T10:06:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/RemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -285,6 +306,38 @@ private Expression removeDynamicFilters(Expression expression, Set<DynamicFilter\n                     .collect(toImmutableList()));\n         }\n \n+        private boolean isSupportedDynamicFilterExpression(Expression expression)\n+        {\n+            if (expression instanceof SymbolReference) {\n+                return true;\n+            }\n+            if (expression instanceof Cast) {\n+                Cast castExpression = (Cast) expression;\n+                if (castExpression.getExpression() instanceof SymbolReference) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMTAzMQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501601031", "bodyText": "reverse:\nif (!(expression instanceof Cast)) {\n  return false;\n}", "author": "sopel39", "createdAt": "2020-10-08T10:06:34Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/RemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -285,6 +306,38 @@ private Expression removeDynamicFilters(Expression expression, Set<DynamicFilter\n                     .collect(toImmutableList()));\n         }\n \n+        private boolean isSupportedDynamicFilterExpression(Expression expression)\n+        {\n+            if (expression instanceof SymbolReference) {\n+                return true;\n+            }\n+            if (expression instanceof Cast) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMTUzNQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501601535", "bodyText": "static import format", "author": "sopel39", "createdAt": "2020-10-08T10:07:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/DynamicFiltersChecker.java", "diffHunk": "@@ -146,6 +147,20 @@ public void validate(\n         }, null);\n     }\n \n+    private static void validateDynamicFilterExpression(Expression expression)\n+    {\n+        if (expression instanceof SymbolReference) {\n+            return;\n+        }\n+        verify(\n+                expression instanceof Cast,\n+                String.format(\"Dynamic filter expression %s must be a SymbolReference or a CAST of SymbolReference.\", expression));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMjE3Ng==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501602176", "bodyText": "what is the check here? That DF exist or not? Can' tell from the test (and the one above too)", "author": "sopel39", "createdAt": "2020-10-08T10:08:32Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -119,6 +119,33 @@ public void testJoinOnCast()\n                                                 tableScan(\"orders\", ImmutableMap.of(\"ORDERS_OK\", \"orderkey\")))),\n                                 anyTree(\n                                         tableScan(\"lineitem\", ImmutableMap.of(\"LINEITEM_OK\", \"orderkey\"))))));\n+\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE l.orderkey = cast(o.orderkey as int)\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYyNzYxNA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501627614", "bodyText": "Made the test more clear, DF should not exist in these cases", "author": "raunaqmorarka", "createdAt": "2020-10-08T10:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMjE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY2MTE5Mw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501661193", "bodyText": "Made the test more clear, DF should not exist in these cases\n\nanyTree will match filterNode that could have DFs. I don't think this join matcher ensures that there is no DF, does it?", "author": "sopel39", "createdAt": "2020-10-08T11:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMjE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1MTE0Mw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501751143", "bodyText": "yes that's right, I missed it\ni've updated the tests to avoid anyTree and explicitly match no DF now.", "author": "raunaqmorarka", "createdAt": "2020-10-08T14:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMjE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMzQwNQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501603405", "bodyText": "please add a comment why it's not supported", "author": "sopel39", "createdAt": "2020-10-08T10:10:28Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/optimizations/TestRemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -309,6 +310,39 @@ public void testNestedDynamicFilterConjunctionRewrite()\n                                         tableScan(\"lineitem\", ImmutableMap.of(\"LINEITEM_OK\", \"orderkey\"))))));\n     }\n \n+    @Test\n+    public void testRemoveUnsupportedCast()\n+    {\n+        // Use lineitem with DOUBLE orderkey to simulate the case of implicit casts\n+        Symbol lineitemDoubleOrderKeySymbol = builder.symbol(\"LINEITEM_DOUBLE_OK\", DOUBLE);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMzc2OQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501603769", "bodyText": "wasn't there a test case like that?", "author": "sopel39", "createdAt": "2020-10-08T10:11:01Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/sanity/TestDynamicFiltersChecker.java", "diffHunk": "@@ -200,6 +200,46 @@ public void testUnmatchedNestedDynamicFilter()\n         validatePlan(root);\n     }\n \n+    @Test(expectedExceptions = VerifyException.class, expectedExceptionsMessageRegExp = \"Dynamic filter expression \\\\(\\\"LINEITEM_OK\\\" \\\\+ BIGINT '1'\\\\) must be a SymbolReference or a CAST of SymbolReference.\")\n+    public void testUnsupportedDynamicFilterExpression()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYyODc1Ng==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r501628756", "bodyText": "i didn't come across one, if i look at the initial commit which added the check for SymbolReference in RemoveUnsupportedDynamicFilters, it relied on the test in TestDynamicFilter#testJoinOnCast", "author": "raunaqmorarka", "createdAt": "2020-10-08T10:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMzc2OQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI5NzA4Mg==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r502297082", "bodyText": "it's not build symbol. It's still probe symbol, but after casting. Maybe call them:\ncastSourceType\ncastTargetType", "author": "sopel39", "createdAt": "2020-10-09T09:15:03Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/RemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -285,6 +306,39 @@ private Expression removeDynamicFilters(Expression expression, Set<DynamicFilter\n                     .collect(toImmutableList()));\n         }\n \n+        private boolean isSupportedDynamicFilterExpression(Expression expression)\n+        {\n+            if (expression instanceof SymbolReference) {\n+                return true;\n+            }\n+            if (!(expression instanceof Cast)) {\n+                return false;\n+            }\n+            Cast castExpression = (Cast) expression;\n+            if (!(castExpression.getExpression() instanceof SymbolReference)) {\n+                return false;\n+            }\n+            Map<NodeRef<Expression>, Type> expressionTypes = typeAnalyzer.getTypes(session, types, expression);\n+            Type probeSymbolType = expressionTypes.get(NodeRef.of(castExpression.getExpression()));\n+            Type buildSymbolType = expressionTypes.get(NodeRef.<Expression>of(castExpression));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI5ODUyOA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r502298528", "bodyText": "now that we use this version of join matcher, we could still use anyTree. Otherwise this test is more fragile (e.g if some plan nodes are added by other rules independently)", "author": "sopel39", "createdAt": "2020-10-09T09:17:33Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -112,13 +111,53 @@ public void testJoinOnCast()\n     {\n         assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE cast(l.orderkey as int) = cast(o.orderkey as int)\",\n                 anyTree(\n-                        node(\n-                                JoinNode.class,\n-                                anyTree(\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(equiJoinClause(\"expr_orders\", \"expr_lineitem\")),\n+                                ImmutableMap.of(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI5OTUxNQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r502299515", "bodyText": "add a comment why it's not supported. I suppose it's because double cast.", "author": "sopel39", "createdAt": "2020-10-09T09:19:11Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -112,13 +111,53 @@ public void testJoinOnCast()\n     {\n         assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE cast(l.orderkey as int) = cast(o.orderkey as int)\",\n                 anyTree(\n-                        node(\n-                                JoinNode.class,\n-                                anyTree(\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(equiJoinClause(\"expr_orders\", \"expr_lineitem\")),\n+                                ImmutableMap.of(),\n+                                project(\n                                         project(\n+                                                ImmutableMap.of(\"expr_orders\", expression(\"CAST(ORDERS_OK AS int)\")),\n                                                 tableScan(\"orders\", ImmutableMap.of(\"ORDERS_OK\", \"orderkey\")))),\n-                                anyTree(\n-                                        tableScan(\"lineitem\", ImmutableMap.of(\"LINEITEM_OK\", \"orderkey\"))))));\n+                                exchange(\n+                                        project(\n+                                                project(\n+                                                        ImmutableMap.of(\"expr_lineitem\", expression(\"CAST(LINEITEM_OK AS int)\")),\n+                                                        tableScan(\"lineitem\", ImmutableMap.of(\"LINEITEM_OK\", \"orderkey\"))))))));\n+\n+        assertPlan(\"SELECT o.orderkey FROM orders o, lineitem l WHERE l.orderkey = cast(o.orderkey as int)\",\n+                anyTree(\n+                        join(\n+                                INNER,\n+                                ImmutableList.of(equiJoinClause(\"expr_orders\", \"LINEITEM_OK\")),\n+                                ImmutableMap.of(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwMjYzOA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r502302638", "bodyText": "no need to revalidate these. These are validated as part of other tests (e.g testJoinDynamicFilteringSingleValue)", "author": "sopel39", "createdAt": "2020-10-09T09:24:37Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -161,6 +161,20 @@ public void testJoinDynamicFilteringSingleValue()\n                 ImmutableSet.of(39, PART_COUNT));\n     }\n \n+    @Test\n+    public void testJoinDynamicFilteringImplicitCoercion()\n+    {\n+        assertUpdate(\"CREATE TABLE coerce_test AS SELECT CAST(orderkey as INT) orderkey_int FROM tpch.tiny.lineitem\", \"SELECT count(*) FROM lineitem\");\n+        assertQueryResult(\"SELECT orderkey FROM orders WHERE comment = 'nstructions sleep furiously among '\", 1L);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMwMjg1NQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r502302855", "bodyText": "add a comment what this asserts (e.g no DF)", "author": "sopel39", "createdAt": "2020-10-09T09:25:01Z", "path": "presto-memory/src/test/java/io/prestosql/plugin/memory/TestMemorySmoke.java", "diffHunk": "@@ -161,6 +161,20 @@ public void testJoinDynamicFilteringSingleValue()\n                 ImmutableSet.of(39, PART_COUNT));\n     }\n \n+    @Test\n+    public void testJoinDynamicFilteringImplicitCoercion()\n+    {\n+        assertUpdate(\"CREATE TABLE coerce_test AS SELECT CAST(orderkey as INT) orderkey_int FROM tpch.tiny.lineitem\", \"SELECT count(*) FROM lineitem\");\n+        assertQueryResult(\"SELECT orderkey FROM orders WHERE comment = 'nstructions sleep furiously among '\", 1L);\n+        assertQueryResult(\"SELECT COUNT() FROM lineitem WHERE orderkey = 1\", 6L);\n+\n+        assertDynamicFiltering(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcwOTUwNA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504709504", "bodyText": "new InterpretedFunctionInvoker(requireNotNull(metadata, \"metadata is null\"))", "author": "sopel39", "createdAt": "2020-10-14T14:10:27Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainCoercer.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.OperatorNotFoundException;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.predicate.AllOrNoneValueSet;\n+import io.prestosql.spi.predicate.DiscreteValues;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.EquatableValueSet;\n+import io.prestosql.spi.predicate.Marker;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.Ranges;\n+import io.prestosql.spi.predicate.SortedRangeSet;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.sql.InterpretedFunctionInvoker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.OperatorType.SATURATED_FLOOR_CAST;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Apply saturated floor casts for implicit coercions on TupleDomain\n+ */\n+public final class DomainCoercer\n+{\n+    private DomainCoercer() {}\n+\n+    public static Domain applySaturatedCasts(\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            Domain domain,\n+            Type coercedValueType)\n+    {\n+        return new ImplicitCoercer(metadata, typeOperators, session, domain, coercedValueType).applySaturatedCasts();\n+    }\n+\n+    private static class ImplicitCoercer\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final InterpretedFunctionInvoker functionInvoker;\n+        private final ResolvedFunction saturatedFloorCastOperator;\n+        private final ResolvedFunction castToOriginalTypeOperator;\n+        private final MethodHandle comparisonOperator;\n+        private final Domain domain;\n+        private final Type coercedValueType;\n+\n+        private ImplicitCoercer(Metadata metadata, TypeOperators typeOperators, Session session, Domain domain, Type coercedValueType)\n+        {\n+            this.connectorSession = requireNonNull(session, \"session is null\").toConnectorSession();\n+            this.functionInvoker = new InterpretedFunctionInvoker(metadata);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc2MzcxMA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504763710", "bodyText": "I avoided it because the InterpretedFunctionInvoker constructor already applies the requireNotNull check", "author": "raunaqmorarka", "createdAt": "2020-10-14T15:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcwOTUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczMzQwMA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504733400", "bodyText": "this is the case where // Coerced domain is narrower than the original domain. Only the floor can return greater value", "author": "sopel39", "createdAt": "2020-10-14T14:40:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainCoercer.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.OperatorNotFoundException;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.predicate.AllOrNoneValueSet;\n+import io.prestosql.spi.predicate.DiscreteValues;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.EquatableValueSet;\n+import io.prestosql.spi.predicate.Marker;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.Ranges;\n+import io.prestosql.spi.predicate.SortedRangeSet;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.sql.InterpretedFunctionInvoker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.OperatorType.SATURATED_FLOOR_CAST;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Apply saturated floor casts for implicit coercions on TupleDomain\n+ */\n+public final class DomainCoercer\n+{\n+    private DomainCoercer() {}\n+\n+    public static Domain applySaturatedCasts(\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            Domain domain,\n+            Type coercedValueType)\n+    {\n+        return new ImplicitCoercer(metadata, typeOperators, session, domain, coercedValueType).applySaturatedCasts();\n+    }\n+\n+    private static class ImplicitCoercer\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final InterpretedFunctionInvoker functionInvoker;\n+        private final ResolvedFunction saturatedFloorCastOperator;\n+        private final ResolvedFunction castToOriginalTypeOperator;\n+        private final MethodHandle comparisonOperator;\n+        private final Domain domain;\n+        private final Type coercedValueType;\n+\n+        private ImplicitCoercer(Metadata metadata, TypeOperators typeOperators, Session session, Domain domain, Type coercedValueType)\n+        {\n+            this.connectorSession = requireNonNull(session, \"session is null\").toConnectorSession();\n+            this.functionInvoker = new InterpretedFunctionInvoker(metadata);\n+            this.domain = requireNonNull(domain, \"domain is null\");\n+            this.coercedValueType = requireNonNull(coercedValueType, \"coercedValueType is null\");\n+            Type originalValueType = domain.getType();\n+            try {\n+                this.saturatedFloorCastOperator = metadata.getCoercion(SATURATED_FLOOR_CAST, originalValueType, coercedValueType);\n+            }\n+            catch (OperatorNotFoundException e) {\n+                throw new IllegalStateException(\n+                        format(\"Saturated floor cast operator not found for coercion from %s to %s\", originalValueType, coercedValueType));\n+            }\n+            this.castToOriginalTypeOperator = metadata.getCoercion(coercedValueType, originalValueType);\n+            this.comparisonOperator = typeOperators.getComparisonOperator(originalValueType, InvocationConvention.simpleConvention(FAIL_ON_NULL, NEVER_NULL, NEVER_NULL));\n+        }\n+\n+        public Domain applySaturatedCasts()\n+        {\n+            if (domain.isNone()) {\n+                return Domain.none(coercedValueType);\n+            }\n+            ValueSet saturatedValueSet = domain.getValues().getValuesProcessor().transform(\n+                    this::applySaturatedCasts,\n+                    this::applySaturatedCasts,\n+                    allOrNone -> new AllOrNoneValueSet(coercedValueType, allOrNone.isAll()));\n+\n+            return Domain.create(saturatedValueSet, domain.isNullAllowed());\n+        }\n+\n+        private ValueSet applySaturatedCasts(Ranges ranges)\n+        {\n+            ImmutableList.Builder<Range> builder = ImmutableList.builder();\n+            for (Range range : ranges.getOrderedRanges()) {\n+                Optional<Range> coercedRange = applySaturatedCasts(range);\n+                if (coercedRange.isEmpty()) {\n+                    continue;\n+                }\n+                if (coercedRange.get().isAll()) {\n+                    return ValueSet.all(coercedValueType);\n+                }\n+                builder.add(coercedRange.get());\n+            }\n+            return SortedRangeSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private ValueSet applySaturatedCasts(DiscreteValues discreteValues)\n+        {\n+            ImmutableList.Builder<Object> builder = ImmutableList.builder();\n+            for (Object value : discreteValues.getValues()) {\n+                Optional<Object> coercedValue = applySaturatedCast(value);\n+                if (coercedValue.isEmpty()) {\n+                    continue;\n+                }\n+                builder.add(coercedValue.get());\n+            }\n+            return EquatableValueSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private Optional<Range> applySaturatedCasts(Range range)\n+        {\n+            if (range.isSingleValue()) {\n+                Optional<Object> coercedValue = applySaturatedCast(range.getSingleValue());\n+                return coercedValue.map(value -> Range.equal(coercedValueType, value));\n+            }\n+\n+            Marker coercedLow;\n+            if (range.getLow().isLowerUnbounded()) {\n+                coercedLow = Marker.lowerUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalLowValue = range.getLow().getValue();\n+                Object coercedLowValue = floorValue(saturatedFloorCastOperator, originalLowValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalLowValue, coercedLowValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsLessThanOriginal = originalComparedToCoerced > 0;\n+\n+                switch (range.getLow().getBound()) {\n+                    case ABOVE:\n+                        if (coercedValueIsEqualToOriginal || coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            // Coerced domain is narrower than the original domain\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedLow = Marker.exactly(coercedValueType, coercedLowValue);\n+                        }\n+                        else if (coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case BELOW:\n+                        throw new IllegalStateException(\"Low Marker should never use BELOW bound: \" + range);\n+                    default:\n+                        throw new IllegalStateException(\"Unhandled bound: \" + range.getLow().getBound());\n+                }\n+            }\n+\n+            Marker coercedHigh;\n+            if (range.getHigh().isUpperUnbounded()) {\n+                coercedHigh = Marker.upperUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalHighValue = range.getHigh().getValue();\n+                Object coercedHighValue = floorValue(saturatedFloorCastOperator, originalHighValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalHighValue, coercedHighValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsGreaterThanOriginal = originalComparedToCoerced < 0;\n+\n+                switch (range.getHigh().getBound()) {\n+                    case ABOVE:\n+                        throw new IllegalStateException(\"High Marker should never use ABOVE bound: \" + range);\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedHigh = Marker.exactly(coercedValueType, coercedHighValue);\n+                        }\n+                        else if (coercedValueIsGreaterThanOriginal) {\n+                            coercedHigh = Marker.below(coercedValueType, coercedHighValue);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczMzY0Mg==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504733642", "bodyText": "this is not neccecerly that case. Lower value can be within domain.", "author": "sopel39", "createdAt": "2020-10-14T14:40:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainCoercer.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.OperatorNotFoundException;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.predicate.AllOrNoneValueSet;\n+import io.prestosql.spi.predicate.DiscreteValues;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.EquatableValueSet;\n+import io.prestosql.spi.predicate.Marker;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.Ranges;\n+import io.prestosql.spi.predicate.SortedRangeSet;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.sql.InterpretedFunctionInvoker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.OperatorType.SATURATED_FLOOR_CAST;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Apply saturated floor casts for implicit coercions on TupleDomain\n+ */\n+public final class DomainCoercer\n+{\n+    private DomainCoercer() {}\n+\n+    public static Domain applySaturatedCasts(\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            Domain domain,\n+            Type coercedValueType)\n+    {\n+        return new ImplicitCoercer(metadata, typeOperators, session, domain, coercedValueType).applySaturatedCasts();\n+    }\n+\n+    private static class ImplicitCoercer\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final InterpretedFunctionInvoker functionInvoker;\n+        private final ResolvedFunction saturatedFloorCastOperator;\n+        private final ResolvedFunction castToOriginalTypeOperator;\n+        private final MethodHandle comparisonOperator;\n+        private final Domain domain;\n+        private final Type coercedValueType;\n+\n+        private ImplicitCoercer(Metadata metadata, TypeOperators typeOperators, Session session, Domain domain, Type coercedValueType)\n+        {\n+            this.connectorSession = requireNonNull(session, \"session is null\").toConnectorSession();\n+            this.functionInvoker = new InterpretedFunctionInvoker(metadata);\n+            this.domain = requireNonNull(domain, \"domain is null\");\n+            this.coercedValueType = requireNonNull(coercedValueType, \"coercedValueType is null\");\n+            Type originalValueType = domain.getType();\n+            try {\n+                this.saturatedFloorCastOperator = metadata.getCoercion(SATURATED_FLOOR_CAST, originalValueType, coercedValueType);\n+            }\n+            catch (OperatorNotFoundException e) {\n+                throw new IllegalStateException(\n+                        format(\"Saturated floor cast operator not found for coercion from %s to %s\", originalValueType, coercedValueType));\n+            }\n+            this.castToOriginalTypeOperator = metadata.getCoercion(coercedValueType, originalValueType);\n+            this.comparisonOperator = typeOperators.getComparisonOperator(originalValueType, InvocationConvention.simpleConvention(FAIL_ON_NULL, NEVER_NULL, NEVER_NULL));\n+        }\n+\n+        public Domain applySaturatedCasts()\n+        {\n+            if (domain.isNone()) {\n+                return Domain.none(coercedValueType);\n+            }\n+            ValueSet saturatedValueSet = domain.getValues().getValuesProcessor().transform(\n+                    this::applySaturatedCasts,\n+                    this::applySaturatedCasts,\n+                    allOrNone -> new AllOrNoneValueSet(coercedValueType, allOrNone.isAll()));\n+\n+            return Domain.create(saturatedValueSet, domain.isNullAllowed());\n+        }\n+\n+        private ValueSet applySaturatedCasts(Ranges ranges)\n+        {\n+            ImmutableList.Builder<Range> builder = ImmutableList.builder();\n+            for (Range range : ranges.getOrderedRanges()) {\n+                Optional<Range> coercedRange = applySaturatedCasts(range);\n+                if (coercedRange.isEmpty()) {\n+                    continue;\n+                }\n+                if (coercedRange.get().isAll()) {\n+                    return ValueSet.all(coercedValueType);\n+                }\n+                builder.add(coercedRange.get());\n+            }\n+            return SortedRangeSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private ValueSet applySaturatedCasts(DiscreteValues discreteValues)\n+        {\n+            ImmutableList.Builder<Object> builder = ImmutableList.builder();\n+            for (Object value : discreteValues.getValues()) {\n+                Optional<Object> coercedValue = applySaturatedCast(value);\n+                if (coercedValue.isEmpty()) {\n+                    continue;\n+                }\n+                builder.add(coercedValue.get());\n+            }\n+            return EquatableValueSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private Optional<Range> applySaturatedCasts(Range range)\n+        {\n+            if (range.isSingleValue()) {\n+                Optional<Object> coercedValue = applySaturatedCast(range.getSingleValue());\n+                return coercedValue.map(value -> Range.equal(coercedValueType, value));\n+            }\n+\n+            Marker coercedLow;\n+            if (range.getLow().isLowerUnbounded()) {\n+                coercedLow = Marker.lowerUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalLowValue = range.getLow().getValue();\n+                Object coercedLowValue = floorValue(saturatedFloorCastOperator, originalLowValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalLowValue, coercedLowValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsLessThanOriginal = originalComparedToCoerced > 0;\n+\n+                switch (range.getLow().getBound()) {\n+                    case ABOVE:\n+                        if (coercedValueIsEqualToOriginal || coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            // Coerced domain is narrower than the original domain\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedLow = Marker.exactly(coercedValueType, coercedLowValue);\n+                        }\n+                        else if (coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case BELOW:\n+                        throw new IllegalStateException(\"Low Marker should never use BELOW bound: \" + range);\n+                    default:\n+                        throw new IllegalStateException(\"Unhandled bound: \" + range.getLow().getBound());\n+                }\n+            }\n+\n+            Marker coercedHigh;\n+            if (range.getHigh().isUpperUnbounded()) {\n+                coercedHigh = Marker.upperUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalHighValue = range.getHigh().getValue();\n+                Object coercedHighValue = floorValue(saturatedFloorCastOperator, originalHighValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalHighValue, coercedHighValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsGreaterThanOriginal = originalComparedToCoerced < 0;\n+\n+                switch (range.getHigh().getBound()) {\n+                    case ABOVE:\n+                        throw new IllegalStateException(\"High Marker should never use ABOVE bound: \" + range);\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedHigh = Marker.exactly(coercedValueType, coercedHighValue);\n+                        }\n+                        else if (coercedValueIsGreaterThanOriginal) {\n+                            coercedHigh = Marker.below(coercedValueType, coercedHighValue);\n+                        }\n+                        else {\n+                            // Coerced domain is narrower than the original domain", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczNzc5Mg==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504737792", "bodyText": "that should be exact", "author": "sopel39", "createdAt": "2020-10-14T14:45:25Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainCoercer.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.OperatorNotFoundException;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.predicate.AllOrNoneValueSet;\n+import io.prestosql.spi.predicate.DiscreteValues;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.EquatableValueSet;\n+import io.prestosql.spi.predicate.Marker;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.Ranges;\n+import io.prestosql.spi.predicate.SortedRangeSet;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.sql.InterpretedFunctionInvoker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.OperatorType.SATURATED_FLOOR_CAST;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Apply saturated floor casts for implicit coercions on TupleDomain\n+ */\n+public final class DomainCoercer\n+{\n+    private DomainCoercer() {}\n+\n+    public static Domain applySaturatedCasts(\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            Domain domain,\n+            Type coercedValueType)\n+    {\n+        return new ImplicitCoercer(metadata, typeOperators, session, domain, coercedValueType).applySaturatedCasts();\n+    }\n+\n+    private static class ImplicitCoercer\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final InterpretedFunctionInvoker functionInvoker;\n+        private final ResolvedFunction saturatedFloorCastOperator;\n+        private final ResolvedFunction castToOriginalTypeOperator;\n+        private final MethodHandle comparisonOperator;\n+        private final Domain domain;\n+        private final Type coercedValueType;\n+\n+        private ImplicitCoercer(Metadata metadata, TypeOperators typeOperators, Session session, Domain domain, Type coercedValueType)\n+        {\n+            this.connectorSession = requireNonNull(session, \"session is null\").toConnectorSession();\n+            this.functionInvoker = new InterpretedFunctionInvoker(metadata);\n+            this.domain = requireNonNull(domain, \"domain is null\");\n+            this.coercedValueType = requireNonNull(coercedValueType, \"coercedValueType is null\");\n+            Type originalValueType = domain.getType();\n+            try {\n+                this.saturatedFloorCastOperator = metadata.getCoercion(SATURATED_FLOOR_CAST, originalValueType, coercedValueType);\n+            }\n+            catch (OperatorNotFoundException e) {\n+                throw new IllegalStateException(\n+                        format(\"Saturated floor cast operator not found for coercion from %s to %s\", originalValueType, coercedValueType));\n+            }\n+            this.castToOriginalTypeOperator = metadata.getCoercion(coercedValueType, originalValueType);\n+            this.comparisonOperator = typeOperators.getComparisonOperator(originalValueType, InvocationConvention.simpleConvention(FAIL_ON_NULL, NEVER_NULL, NEVER_NULL));\n+        }\n+\n+        public Domain applySaturatedCasts()\n+        {\n+            if (domain.isNone()) {\n+                return Domain.none(coercedValueType);\n+            }\n+            ValueSet saturatedValueSet = domain.getValues().getValuesProcessor().transform(\n+                    this::applySaturatedCasts,\n+                    this::applySaturatedCasts,\n+                    allOrNone -> new AllOrNoneValueSet(coercedValueType, allOrNone.isAll()));\n+\n+            return Domain.create(saturatedValueSet, domain.isNullAllowed());\n+        }\n+\n+        private ValueSet applySaturatedCasts(Ranges ranges)\n+        {\n+            ImmutableList.Builder<Range> builder = ImmutableList.builder();\n+            for (Range range : ranges.getOrderedRanges()) {\n+                Optional<Range> coercedRange = applySaturatedCasts(range);\n+                if (coercedRange.isEmpty()) {\n+                    continue;\n+                }\n+                if (coercedRange.get().isAll()) {\n+                    return ValueSet.all(coercedValueType);\n+                }\n+                builder.add(coercedRange.get());\n+            }\n+            return SortedRangeSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private ValueSet applySaturatedCasts(DiscreteValues discreteValues)\n+        {\n+            ImmutableList.Builder<Object> builder = ImmutableList.builder();\n+            for (Object value : discreteValues.getValues()) {\n+                Optional<Object> coercedValue = applySaturatedCast(value);\n+                if (coercedValue.isEmpty()) {\n+                    continue;\n+                }\n+                builder.add(coercedValue.get());\n+            }\n+            return EquatableValueSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private Optional<Range> applySaturatedCasts(Range range)\n+        {\n+            if (range.isSingleValue()) {\n+                Optional<Object> coercedValue = applySaturatedCast(range.getSingleValue());\n+                return coercedValue.map(value -> Range.equal(coercedValueType, value));\n+            }\n+\n+            Marker coercedLow;\n+            if (range.getLow().isLowerUnbounded()) {\n+                coercedLow = Marker.lowerUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalLowValue = range.getLow().getValue();\n+                Object coercedLowValue = floorValue(saturatedFloorCastOperator, originalLowValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalLowValue, coercedLowValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsLessThanOriginal = originalComparedToCoerced > 0;\n+\n+                switch (range.getLow().getBound()) {\n+                    case ABOVE:\n+                        if (coercedValueIsEqualToOriginal || coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            // Coerced domain is narrower than the original domain\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedLow = Marker.exactly(coercedValueType, coercedLowValue);\n+                        }\n+                        else if (coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case BELOW:\n+                        throw new IllegalStateException(\"Low Marker should never use BELOW bound: \" + range);\n+                    default:\n+                        throw new IllegalStateException(\"Unhandled bound: \" + range.getLow().getBound());\n+                }\n+            }\n+\n+            Marker coercedHigh;\n+            if (range.getHigh().isUpperUnbounded()) {\n+                coercedHigh = Marker.upperUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalHighValue = range.getHigh().getValue();\n+                Object coercedHighValue = floorValue(saturatedFloorCastOperator, originalHighValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalHighValue, coercedHighValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsGreaterThanOriginal = originalComparedToCoerced < 0;\n+\n+                switch (range.getHigh().getBound()) {\n+                    case ABOVE:\n+                        throw new IllegalStateException(\"High Marker should never use ABOVE bound: \" + range);\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedHigh = Marker.exactly(coercedValueType, coercedHighValue);\n+                        }\n+                        else if (coercedValueIsGreaterThanOriginal) {\n+                            coercedHigh = Marker.below(coercedValueType, coercedHighValue);\n+                        }\n+                        else {\n+                            // Coerced domain is narrower than the original domain\n+                            coercedHigh = Marker.upperUnbounded(coercedValueType);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUyNDMzNw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507524337", "bodyText": "We reach here in two cases:\n\nTarget domain is narrower. E.g.: BIGINT -> INTEGER coercion where the bigint is outside integer range.\nDecimal(6, 3) to decimal(6, 1) coercion like 234.567 -> 234.5.\nAre we guaranteed that the value returned by saturated floor cast will always return the largest possible value in the target type that is smaller than the original value ?\nIf yes, then shouldn't this be Marker.exactly(coercedValueType, coercedHighValue) ?", "author": "raunaqmorarka", "createdAt": "2020-10-19T07:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczNzc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0MDgyOQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507640829", "bodyText": "Target domain is narrower. E.g.: BIGINT -> INTEGER coercion where the bigint is outside integer range.\n\nThat's not the case. when floor coerced value is lower than original value, it is from domain.\n\nAre we guaranteed that the value returned by saturated floor cast will always return the largest possible value in the target type that is smaller than the original value ?\n\nYes.", "author": "sopel39", "createdAt": "2020-10-19T10:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczNzc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5Nzc4MA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507897780", "bodyText": "fixed now", "author": "raunaqmorarka", "createdAt": "2020-10-19T16:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczNzc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczODYxNg==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504738616", "bodyText": "In case when high is outside of valid coerced domain, we should return Optional.empty(). Do we have a test for this?", "author": "sopel39", "createdAt": "2020-10-14T14:46:26Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainCoercer.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.OperatorNotFoundException;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.predicate.AllOrNoneValueSet;\n+import io.prestosql.spi.predicate.DiscreteValues;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.EquatableValueSet;\n+import io.prestosql.spi.predicate.Marker;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.Ranges;\n+import io.prestosql.spi.predicate.SortedRangeSet;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.sql.InterpretedFunctionInvoker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.OperatorType.SATURATED_FLOOR_CAST;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Apply saturated floor casts for implicit coercions on TupleDomain\n+ */\n+public final class DomainCoercer\n+{\n+    private DomainCoercer() {}\n+\n+    public static Domain applySaturatedCasts(\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            Domain domain,\n+            Type coercedValueType)\n+    {\n+        return new ImplicitCoercer(metadata, typeOperators, session, domain, coercedValueType).applySaturatedCasts();\n+    }\n+\n+    private static class ImplicitCoercer\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final InterpretedFunctionInvoker functionInvoker;\n+        private final ResolvedFunction saturatedFloorCastOperator;\n+        private final ResolvedFunction castToOriginalTypeOperator;\n+        private final MethodHandle comparisonOperator;\n+        private final Domain domain;\n+        private final Type coercedValueType;\n+\n+        private ImplicitCoercer(Metadata metadata, TypeOperators typeOperators, Session session, Domain domain, Type coercedValueType)\n+        {\n+            this.connectorSession = requireNonNull(session, \"session is null\").toConnectorSession();\n+            this.functionInvoker = new InterpretedFunctionInvoker(metadata);\n+            this.domain = requireNonNull(domain, \"domain is null\");\n+            this.coercedValueType = requireNonNull(coercedValueType, \"coercedValueType is null\");\n+            Type originalValueType = domain.getType();\n+            try {\n+                this.saturatedFloorCastOperator = metadata.getCoercion(SATURATED_FLOOR_CAST, originalValueType, coercedValueType);\n+            }\n+            catch (OperatorNotFoundException e) {\n+                throw new IllegalStateException(\n+                        format(\"Saturated floor cast operator not found for coercion from %s to %s\", originalValueType, coercedValueType));\n+            }\n+            this.castToOriginalTypeOperator = metadata.getCoercion(coercedValueType, originalValueType);\n+            this.comparisonOperator = typeOperators.getComparisonOperator(originalValueType, InvocationConvention.simpleConvention(FAIL_ON_NULL, NEVER_NULL, NEVER_NULL));\n+        }\n+\n+        public Domain applySaturatedCasts()\n+        {\n+            if (domain.isNone()) {\n+                return Domain.none(coercedValueType);\n+            }\n+            ValueSet saturatedValueSet = domain.getValues().getValuesProcessor().transform(\n+                    this::applySaturatedCasts,\n+                    this::applySaturatedCasts,\n+                    allOrNone -> new AllOrNoneValueSet(coercedValueType, allOrNone.isAll()));\n+\n+            return Domain.create(saturatedValueSet, domain.isNullAllowed());\n+        }\n+\n+        private ValueSet applySaturatedCasts(Ranges ranges)\n+        {\n+            ImmutableList.Builder<Range> builder = ImmutableList.builder();\n+            for (Range range : ranges.getOrderedRanges()) {\n+                Optional<Range> coercedRange = applySaturatedCasts(range);\n+                if (coercedRange.isEmpty()) {\n+                    continue;\n+                }\n+                if (coercedRange.get().isAll()) {\n+                    return ValueSet.all(coercedValueType);\n+                }\n+                builder.add(coercedRange.get());\n+            }\n+            return SortedRangeSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private ValueSet applySaturatedCasts(DiscreteValues discreteValues)\n+        {\n+            ImmutableList.Builder<Object> builder = ImmutableList.builder();\n+            for (Object value : discreteValues.getValues()) {\n+                Optional<Object> coercedValue = applySaturatedCast(value);\n+                if (coercedValue.isEmpty()) {\n+                    continue;\n+                }\n+                builder.add(coercedValue.get());\n+            }\n+            return EquatableValueSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private Optional<Range> applySaturatedCasts(Range range)\n+        {\n+            if (range.isSingleValue()) {\n+                Optional<Object> coercedValue = applySaturatedCast(range.getSingleValue());\n+                return coercedValue.map(value -> Range.equal(coercedValueType, value));\n+            }\n+\n+            Marker coercedLow;\n+            if (range.getLow().isLowerUnbounded()) {\n+                coercedLow = Marker.lowerUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalLowValue = range.getLow().getValue();\n+                Object coercedLowValue = floorValue(saturatedFloorCastOperator, originalLowValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalLowValue, coercedLowValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsLessThanOriginal = originalComparedToCoerced > 0;\n+\n+                switch (range.getLow().getBound()) {\n+                    case ABOVE:\n+                        if (coercedValueIsEqualToOriginal || coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            // Coerced domain is narrower than the original domain\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedLow = Marker.exactly(coercedValueType, coercedLowValue);\n+                        }\n+                        else if (coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case BELOW:\n+                        throw new IllegalStateException(\"Low Marker should never use BELOW bound: \" + range);\n+                    default:\n+                        throw new IllegalStateException(\"Unhandled bound: \" + range.getLow().getBound());\n+                }\n+            }\n+\n+            Marker coercedHigh;\n+            if (range.getHigh().isUpperUnbounded()) {\n+                coercedHigh = Marker.upperUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalHighValue = range.getHigh().getValue();\n+                Object coercedHighValue = floorValue(saturatedFloorCastOperator, originalHighValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalHighValue, coercedHighValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsGreaterThanOriginal = originalComparedToCoerced < 0;\n+\n+                switch (range.getHigh().getBound()) {\n+                    case ABOVE:\n+                        throw new IllegalStateException(\"High Marker should never use ABOVE bound: \" + range);\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedHigh = Marker.exactly(coercedValueType, coercedHighValue);\n+                        }\n+                        else if (coercedValueIsGreaterThanOriginal) {\n+                            coercedHigh = Marker.below(coercedValueType, coercedHighValue);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUwNDUzMw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507504533", "bodyText": "For the low case, I could test coercedValueIsGreaterThanOriginal by casting range(BIGINT, ((long) Integer.MAX_VALUE) * -2, false, ((long) Integer.MAX_VALUE) * 10, false) to INTEGER\nI didn't find any case where coercedValueIsGreaterThanOriginal is true for the high case.", "author": "raunaqmorarka", "createdAt": "2020-10-19T06:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczODYxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzOTQ1OA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507639458", "bodyText": "An example here would be decimal range where lo/hi is below INTEGER_MIN for instance", "author": "sopel39", "createdAt": "2020-10-19T10:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczODYxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg4OTYxOQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507889619", "bodyText": "Added tests now where both lo and hi are below target type min", "author": "raunaqmorarka", "createdAt": "2020-10-19T16:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczODYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczOTYyNw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504739627", "bodyText": "similar comment as above, coercedValueIsGreaterThanOriginal means out of range value, so it cannot be below", "author": "sopel39", "createdAt": "2020-10-14T14:47:45Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainCoercer.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.OperatorNotFoundException;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.predicate.AllOrNoneValueSet;\n+import io.prestosql.spi.predicate.DiscreteValues;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.EquatableValueSet;\n+import io.prestosql.spi.predicate.Marker;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.Ranges;\n+import io.prestosql.spi.predicate.SortedRangeSet;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.sql.InterpretedFunctionInvoker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.OperatorType.SATURATED_FLOOR_CAST;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Apply saturated floor casts for implicit coercions on TupleDomain\n+ */\n+public final class DomainCoercer\n+{\n+    private DomainCoercer() {}\n+\n+    public static Domain applySaturatedCasts(\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            Domain domain,\n+            Type coercedValueType)\n+    {\n+        return new ImplicitCoercer(metadata, typeOperators, session, domain, coercedValueType).applySaturatedCasts();\n+    }\n+\n+    private static class ImplicitCoercer\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final InterpretedFunctionInvoker functionInvoker;\n+        private final ResolvedFunction saturatedFloorCastOperator;\n+        private final ResolvedFunction castToOriginalTypeOperator;\n+        private final MethodHandle comparisonOperator;\n+        private final Domain domain;\n+        private final Type coercedValueType;\n+\n+        private ImplicitCoercer(Metadata metadata, TypeOperators typeOperators, Session session, Domain domain, Type coercedValueType)\n+        {\n+            this.connectorSession = requireNonNull(session, \"session is null\").toConnectorSession();\n+            this.functionInvoker = new InterpretedFunctionInvoker(metadata);\n+            this.domain = requireNonNull(domain, \"domain is null\");\n+            this.coercedValueType = requireNonNull(coercedValueType, \"coercedValueType is null\");\n+            Type originalValueType = domain.getType();\n+            try {\n+                this.saturatedFloorCastOperator = metadata.getCoercion(SATURATED_FLOOR_CAST, originalValueType, coercedValueType);\n+            }\n+            catch (OperatorNotFoundException e) {\n+                throw new IllegalStateException(\n+                        format(\"Saturated floor cast operator not found for coercion from %s to %s\", originalValueType, coercedValueType));\n+            }\n+            this.castToOriginalTypeOperator = metadata.getCoercion(coercedValueType, originalValueType);\n+            this.comparisonOperator = typeOperators.getComparisonOperator(originalValueType, InvocationConvention.simpleConvention(FAIL_ON_NULL, NEVER_NULL, NEVER_NULL));\n+        }\n+\n+        public Domain applySaturatedCasts()\n+        {\n+            if (domain.isNone()) {\n+                return Domain.none(coercedValueType);\n+            }\n+            ValueSet saturatedValueSet = domain.getValues().getValuesProcessor().transform(\n+                    this::applySaturatedCasts,\n+                    this::applySaturatedCasts,\n+                    allOrNone -> new AllOrNoneValueSet(coercedValueType, allOrNone.isAll()));\n+\n+            return Domain.create(saturatedValueSet, domain.isNullAllowed());\n+        }\n+\n+        private ValueSet applySaturatedCasts(Ranges ranges)\n+        {\n+            ImmutableList.Builder<Range> builder = ImmutableList.builder();\n+            for (Range range : ranges.getOrderedRanges()) {\n+                Optional<Range> coercedRange = applySaturatedCasts(range);\n+                if (coercedRange.isEmpty()) {\n+                    continue;\n+                }\n+                if (coercedRange.get().isAll()) {\n+                    return ValueSet.all(coercedValueType);\n+                }\n+                builder.add(coercedRange.get());\n+            }\n+            return SortedRangeSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private ValueSet applySaturatedCasts(DiscreteValues discreteValues)\n+        {\n+            ImmutableList.Builder<Object> builder = ImmutableList.builder();\n+            for (Object value : discreteValues.getValues()) {\n+                Optional<Object> coercedValue = applySaturatedCast(value);\n+                if (coercedValue.isEmpty()) {\n+                    continue;\n+                }\n+                builder.add(coercedValue.get());\n+            }\n+            return EquatableValueSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private Optional<Range> applySaturatedCasts(Range range)\n+        {\n+            if (range.isSingleValue()) {\n+                Optional<Object> coercedValue = applySaturatedCast(range.getSingleValue());\n+                return coercedValue.map(value -> Range.equal(coercedValueType, value));\n+            }\n+\n+            Marker coercedLow;\n+            if (range.getLow().isLowerUnbounded()) {\n+                coercedLow = Marker.lowerUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalLowValue = range.getLow().getValue();\n+                Object coercedLowValue = floorValue(saturatedFloorCastOperator, originalLowValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalLowValue, coercedLowValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsLessThanOriginal = originalComparedToCoerced > 0;\n+\n+                switch (range.getLow().getBound()) {\n+                    case ABOVE:\n+                        if (coercedValueIsEqualToOriginal || coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            // Coerced domain is narrower than the original domain\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedLow = Marker.exactly(coercedValueType, coercedLowValue);\n+                        }\n+                        else if (coercedValueIsLessThanOriginal) {\n+                            coercedLow = Marker.above(coercedValueType, coercedLowValue);\n+                        }\n+                        else {\n+                            coercedLow = Marker.lowerUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case BELOW:\n+                        throw new IllegalStateException(\"Low Marker should never use BELOW bound: \" + range);\n+                    default:\n+                        throw new IllegalStateException(\"Unhandled bound: \" + range.getLow().getBound());\n+                }\n+            }\n+\n+            Marker coercedHigh;\n+            if (range.getHigh().isUpperUnbounded()) {\n+                coercedHigh = Marker.upperUnbounded(coercedValueType);\n+            }\n+            else {\n+                Object originalHighValue = range.getHigh().getValue();\n+                Object coercedHighValue = floorValue(saturatedFloorCastOperator, originalHighValue);\n+                int originalComparedToCoerced = compareOriginalValueToCoerced(castToOriginalTypeOperator, comparisonOperator, originalHighValue, coercedHighValue);\n+                boolean coercedValueIsEqualToOriginal = originalComparedToCoerced == 0;\n+                boolean coercedValueIsGreaterThanOriginal = originalComparedToCoerced < 0;\n+\n+                switch (range.getHigh().getBound()) {\n+                    case ABOVE:\n+                        throw new IllegalStateException(\"High Marker should never use ABOVE bound: \" + range);\n+                    case EXACTLY:\n+                        if (coercedValueIsEqualToOriginal) {\n+                            coercedHigh = Marker.exactly(coercedValueType, coercedHighValue);\n+                        }\n+                        else if (coercedValueIsGreaterThanOriginal) {\n+                            coercedHigh = Marker.below(coercedValueType, coercedHighValue);\n+                        }\n+                        else {\n+                            // Coerced domain is narrower than the original domain\n+                            coercedHigh = Marker.upperUnbounded(coercedValueType);\n+                        }\n+                        break;\n+                    case BELOW:\n+                        if (coercedValueIsEqualToOriginal || coercedValueIsGreaterThanOriginal) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc1MTEyNw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504751127", "bodyText": "nit: in this case coercion is executed by caller. We might want to think about changing this in the future, so that coercion is executed by service threads", "author": "sopel39", "createdAt": "2020-10-14T15:01:50Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -287,7 +310,7 @@ public boolean isAwaitable()\n                 }\n \n                 TupleDomain<ColumnHandle> dynamicFilter = completedDynamicFilters.stream()\n-                        .map(filter -> translateSummaryToTupleDomain(filter, context.getDynamicFilterSummaries().get(filter), sourceColumnHandles))\n+                        .map(filter -> translateSummaryToTupleDomain(filter, context, symbolsMap, columnHandles, typeProvider))", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNjQ5OA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504926498", "bodyText": "Could we reuse io.prestosql.sql.planner.LocalDynamicFiltersCollector.TableSpecificDynamicFilter here. It seems quite generic and only needs List<ListenableFuture<TupleDomain<ColumnHandle>>> predicateFutures as argument. This way coercion will happen in service thread", "author": "sopel39", "createdAt": "2020-10-14T19:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc1MTEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc1MTk1NA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r504751954", "bodyText": "Let's extract this to io.prestosql.sql.DynamicFilters. I think it's being used in more than one place", "author": "sopel39", "createdAt": "2020-10-14T15:02:53Z", "path": "presto-main/src/main/java/io/prestosql/server/DynamicFilterService.java", "diffHunk": "@@ -362,21 +385,42 @@ private void collectDynamicFilters(StageId stageId, Optional<Set<DynamicFilterId\n         return Optional.ofNullable(dynamicFilterContexts.get(queryId).getDynamicFilterSummaries().get(filterId));\n     }\n \n-    private static TupleDomain<ColumnHandle> translateSummaryToTupleDomain(DynamicFilterId filterId, Domain summary, Multimap<DynamicFilterId, ColumnHandle> sourceColumnHandles)\n+    private TupleDomain<ColumnHandle> translateSummaryToTupleDomain(\n+            DynamicFilterId filterId,\n+            DynamicFilterContext dynamicFilterContext,\n+            Multimap<DynamicFilterId, Symbol> symbolsMap,\n+            Map<Symbol, ColumnHandle> columnHandles,\n+            TypeProvider typeProvider)\n     {\n-        checkState(sourceColumnHandles.containsKey(filterId), \"No source column handles for dynamic filter %s\", filterId);\n-        return TupleDomain.withColumnDomains(\n-                sourceColumnHandles.get(filterId).stream()\n-                        .collect(toImmutableMap(handle -> handle, handle -> summary)));\n+        Collection<Symbol> probeSymbols = symbolsMap.get(filterId);\n+        checkState(probeSymbols != null, \"No probe symbols for dynamic filter %s\", filterId);\n+        Domain summary = dynamicFilterContext.getDynamicFilterSummaries().get(filterId);\n+        return TupleDomain.withColumnDomains(probeSymbols.stream()\n+                .collect(toImmutableMap(\n+                        probeSymbol -> requireNonNull(columnHandles.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)),\n+                        probeSymbol -> {\n+                            Type targetType = typeProvider.get(probeSymbol);\n+                            if (!summary.getType().equals(targetType)) {\n+                                return DomainCoercer.applySaturatedCasts(metadata, typeOperators, dynamicFilterContext.getSession(), summary, targetType);\n+                            }\n+                            return summary;\n+                        })));\n     }\n \n-    private static Multimap<DynamicFilterId, ColumnHandle> extractSourceColumnHandles(List<DynamicFilters.Descriptor> dynamicFilters, Map<Symbol, ColumnHandle> columnHandles)\n+    private static Multimap<DynamicFilterId, Symbol> extractSourceSymbols(List<DynamicFilters.Descriptor> dynamicFilters, Map<Symbol, ColumnHandle> columnHandles)\n     {\n         return dynamicFilters.stream()\n-                .filter(descriptor -> descriptor.getInput() instanceof SymbolReference)\n                 .collect(toImmutableListMultimap(\n                         DynamicFilters.Descriptor::getId,\n-                        descriptor -> columnHandles.get(Symbol.from(descriptor.getInput()))));\n+                        descriptor -> {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE3OTU3Mg==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507179572", "bodyText": "done", "author": "raunaqmorarka", "createdAt": "2020-10-18T15:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc1MTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NTM2NA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505465364", "bodyText": "move private method to the bottom (after usages).", "author": "sopel39", "createdAt": "2020-10-15T11:25:51Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainCoercer.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SessionTestUtils.TEST_SESSION;\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.predicate.Domain.multipleValues;\n+import static io.prestosql.spi.predicate.Range.greaterThan;\n+import static io.prestosql.spi.predicate.Range.greaterThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.lessThan;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainCoercer\n+{\n+    private Metadata metadata;\n+    private TypeOperators typeOperators;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        metadata = createTestMetadataManager();\n+        typeOperators = new TypeOperators();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        metadata = null;\n+    }\n+\n+    private Domain applySaturatedCasts(Domain domain, Type coercedValueType)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NjcwMg==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505466702", "bodyText": "static import floatToIntBits", "author": "sopel39", "createdAt": "2020-10-15T11:28:18Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainCoercer.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SessionTestUtils.TEST_SESSION;\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.predicate.Domain.multipleValues;\n+import static io.prestosql.spi.predicate.Range.greaterThan;\n+import static io.prestosql.spi.predicate.Range.greaterThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.lessThan;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainCoercer\n+{\n+    private Metadata metadata;\n+    private TypeOperators typeOperators;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        metadata = createTestMetadataManager();\n+        typeOperators = new TypeOperators();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        metadata = null;\n+    }\n+\n+    private Domain applySaturatedCasts(Domain domain, Type coercedValueType)\n+    {\n+        return DomainCoercer.applySaturatedCasts(metadata, typeOperators, TEST_SESSION, domain, coercedValueType);\n+    }\n+\n+    @Test\n+    public void testNone()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.none(BIGINT), INTEGER), Domain.none(INTEGER));\n+    }\n+\n+    @Test\n+    public void testAll()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.all(BIGINT), INTEGER), Domain.all(INTEGER));\n+    }\n+\n+    @Test\n+    public void testOnlyNull()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.onlyNull(BIGINT), INTEGER), Domain.onlyNull(INTEGER));\n+    }\n+\n+    @Test\n+    public void testCoercedValueSameAsOriginal()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(multipleValues(BIGINT, ImmutableList.of(1L, 10000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, 10000L, -2000L)));\n+\n+        Domain original = Domain.create(\n+                ValueSet.ofRanges(\n+                        lessThan(DOUBLE, 0.0),\n+                        range(DOUBLE, 0.0, false, 1.0, false),\n+                        range(DOUBLE, 2.0, true, 3.0, true),\n+                        greaterThan(DOUBLE, 4.0)),\n+                true);\n+        assertEquals(\n+                applySaturatedCasts(original, REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges(\n+                                lessThan(REAL, (long) Float.floatToIntBits(0.0f)),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MDc5NA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505490794", "bodyText": "Is not-same as original tested anywhere? Preferably we should have a test case where there is a range that can be coerced and an exact value that cannot be coerced.", "author": "sopel39", "createdAt": "2020-10-15T12:12:31Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainCoercer.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SessionTestUtils.TEST_SESSION;\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.predicate.Domain.multipleValues;\n+import static io.prestosql.spi.predicate.Range.greaterThan;\n+import static io.prestosql.spi.predicate.Range.greaterThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.lessThan;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainCoercer\n+{\n+    private Metadata metadata;\n+    private TypeOperators typeOperators;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        metadata = createTestMetadataManager();\n+        typeOperators = new TypeOperators();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        metadata = null;\n+    }\n+\n+    private Domain applySaturatedCasts(Domain domain, Type coercedValueType)\n+    {\n+        return DomainCoercer.applySaturatedCasts(metadata, typeOperators, TEST_SESSION, domain, coercedValueType);\n+    }\n+\n+    @Test\n+    public void testNone()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.none(BIGINT), INTEGER), Domain.none(INTEGER));\n+    }\n+\n+    @Test\n+    public void testAll()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.all(BIGINT), INTEGER), Domain.all(INTEGER));\n+    }\n+\n+    @Test\n+    public void testOnlyNull()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.onlyNull(BIGINT), INTEGER), Domain.onlyNull(INTEGER));\n+    }\n+\n+    @Test\n+    public void testCoercedValueSameAsOriginal()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ2NzE3Nw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507467177", "bodyText": "testTruncatedCoercedValue has a case where we coerce [123.456, 234.567] to (123.4, 234.5)", "author": "raunaqmorarka", "createdAt": "2020-10-19T05:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MDc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MjA3Ng==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505492076", "bodyText": "is it tested (or possible to test)?", "author": "sopel39", "createdAt": "2020-10-15T12:14:52Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainCoercer.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.OperatorNotFoundException;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.predicate.AllOrNoneValueSet;\n+import io.prestosql.spi.predicate.DiscreteValues;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.EquatableValueSet;\n+import io.prestosql.spi.predicate.Marker;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.Ranges;\n+import io.prestosql.spi.predicate.SortedRangeSet;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.sql.InterpretedFunctionInvoker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.OperatorType.SATURATED_FLOOR_CAST;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Apply saturated floor casts for implicit coercions on TupleDomain\n+ */\n+public final class DomainCoercer\n+{\n+    private DomainCoercer() {}\n+\n+    public static Domain applySaturatedCasts(\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            Domain domain,\n+            Type coercedValueType)\n+    {\n+        return new ImplicitCoercer(metadata, typeOperators, session, domain, coercedValueType).applySaturatedCasts();\n+    }\n+\n+    private static class ImplicitCoercer\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final InterpretedFunctionInvoker functionInvoker;\n+        private final ResolvedFunction saturatedFloorCastOperator;\n+        private final ResolvedFunction castToOriginalTypeOperator;\n+        private final MethodHandle comparisonOperator;\n+        private final Domain domain;\n+        private final Type coercedValueType;\n+\n+        private ImplicitCoercer(Metadata metadata, TypeOperators typeOperators, Session session, Domain domain, Type coercedValueType)\n+        {\n+            this.connectorSession = requireNonNull(session, \"session is null\").toConnectorSession();\n+            this.functionInvoker = new InterpretedFunctionInvoker(metadata);\n+            this.domain = requireNonNull(domain, \"domain is null\");\n+            this.coercedValueType = requireNonNull(coercedValueType, \"coercedValueType is null\");\n+            Type originalValueType = domain.getType();\n+            try {\n+                this.saturatedFloorCastOperator = metadata.getCoercion(SATURATED_FLOOR_CAST, originalValueType, coercedValueType);\n+            }\n+            catch (OperatorNotFoundException e) {\n+                throw new IllegalStateException(\n+                        format(\"Saturated floor cast operator not found for coercion from %s to %s\", originalValueType, coercedValueType));\n+            }\n+            this.castToOriginalTypeOperator = metadata.getCoercion(coercedValueType, originalValueType);\n+            this.comparisonOperator = typeOperators.getComparisonOperator(originalValueType, InvocationConvention.simpleConvention(FAIL_ON_NULL, NEVER_NULL, NEVER_NULL));\n+        }\n+\n+        public Domain applySaturatedCasts()\n+        {\n+            if (domain.isNone()) {\n+                return Domain.none(coercedValueType);\n+            }\n+            ValueSet saturatedValueSet = domain.getValues().getValuesProcessor().transform(\n+                    this::applySaturatedCasts,\n+                    this::applySaturatedCasts,\n+                    allOrNone -> new AllOrNoneValueSet(coercedValueType, allOrNone.isAll()));\n+\n+            return Domain.create(saturatedValueSet, domain.isNullAllowed());\n+        }\n+\n+        private ValueSet applySaturatedCasts(Ranges ranges)\n+        {\n+            ImmutableList.Builder<Range> builder = ImmutableList.builder();\n+            for (Range range : ranges.getOrderedRanges()) {\n+                Optional<Range> coercedRange = applySaturatedCasts(range);\n+                if (coercedRange.isEmpty()) {\n+                    continue;\n+                }\n+                if (coercedRange.get().isAll()) {\n+                    return ValueSet.all(coercedValueType);\n+                }\n+                builder.add(coercedRange.get());\n+            }\n+            return SortedRangeSet.copyOf(coercedValueType, builder.build());\n+        }\n+\n+        private ValueSet applySaturatedCasts(DiscreteValues discreteValues)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE3MjY0OQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507172649", "bodyText": "Doesn't seem possible to test in a meaningful way. Should we just drop this part and return all in this case to simplify things ?", "author": "raunaqmorarka", "createdAt": "2020-10-18T14:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MjA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzNDQ0MA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507634440", "bodyText": "Let's drop it then.", "author": "sopel39", "createdAt": "2020-10-19T10:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MjA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgyMTk1MQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507821951", "bodyText": "removed this now", "author": "raunaqmorarka", "createdAt": "2020-10-19T14:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MjA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MzMzOQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505493339", "bodyText": "add a test case where both high and low are below and over target range", "author": "sopel39", "createdAt": "2020-10-15T12:16:59Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainCoercer.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SessionTestUtils.TEST_SESSION;\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.predicate.Domain.multipleValues;\n+import static io.prestosql.spi.predicate.Range.greaterThan;\n+import static io.prestosql.spi.predicate.Range.greaterThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.lessThan;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainCoercer\n+{\n+    private Metadata metadata;\n+    private TypeOperators typeOperators;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        metadata = createTestMetadataManager();\n+        typeOperators = new TypeOperators();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        metadata = null;\n+    }\n+\n+    private Domain applySaturatedCasts(Domain domain, Type coercedValueType)\n+    {\n+        return DomainCoercer.applySaturatedCasts(metadata, typeOperators, TEST_SESSION, domain, coercedValueType);\n+    }\n+\n+    @Test\n+    public void testNone()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.none(BIGINT), INTEGER), Domain.none(INTEGER));\n+    }\n+\n+    @Test\n+    public void testAll()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.all(BIGINT), INTEGER), Domain.all(INTEGER));\n+    }\n+\n+    @Test\n+    public void testOnlyNull()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.onlyNull(BIGINT), INTEGER), Domain.onlyNull(INTEGER));\n+    }\n+\n+    @Test\n+    public void testCoercedValueSameAsOriginal()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(multipleValues(BIGINT, ImmutableList.of(1L, 10000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, 10000L, -2000L)));\n+\n+        Domain original = Domain.create(\n+                ValueSet.ofRanges(\n+                        lessThan(DOUBLE, 0.0),\n+                        range(DOUBLE, 0.0, false, 1.0, false),\n+                        range(DOUBLE, 2.0, true, 3.0, true),\n+                        greaterThan(DOUBLE, 4.0)),\n+                true);\n+        assertEquals(\n+                applySaturatedCasts(original, REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges(\n+                                lessThan(REAL, (long) Float.floatToIntBits(0.0f)),\n+                                range(REAL, (long) Float.floatToIntBits(0.0f), false, (long) Float.floatToIntBits(1.0f), false),\n+                                range(REAL, (long) Float.floatToIntBits(2.0f), true, (long) Float.floatToIntBits(3.0f), true),\n+                                greaterThan(REAL, (long) Float.floatToIntBits(4.0f))),\n+                        true));\n+    }\n+\n+    @Test\n+    public void testOutsideTargetTypeRange()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(\n+                        multipleValues(BIGINT, ImmutableList.of(1L, 10000000000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, -2000L)));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(range(DOUBLE, 0.0, true, ((double) Float.MAX_VALUE) * 10, true)),\n+                                true),\n+                        REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges((greaterThanOrEqual(REAL, (long) Float.floatToIntBits(0.0f)))),\n+                        true));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(DOUBLE, ((double) Float.MAX_VALUE) * -2, true, ((double) Float.MAX_VALUE) * 10, true),\n+                                        range(DOUBLE, 0.0, false, 1.0, false)),\n+                                true),\n+                        REAL),\n+                Domain.all(REAL));\n+\n+        assertEquals(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQ2NDk0Mw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507464943", "bodyText": "I tried to test this case in last assertion through\nrange(BIGINT, ((long) Integer.MAX_VALUE) * -2, false, ((long) Integer.MAX_VALUE) * 10, false)\nDid you have something else in mind ?", "author": "raunaqmorarka", "createdAt": "2020-10-19T05:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MzMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0Mjc3OQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507642779", "bodyText": "I mean both low and hi should be either very negative (out of range) or very positive (out of range).", "author": "sopel39", "createdAt": "2020-10-19T10:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MzMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg5MDI5NA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507890294", "bodyText": "added both those type of tests now", "author": "raunaqmorarka", "createdAt": "2020-10-19T16:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5MzMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5Mzk2Nw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505493967", "bodyText": "add a test case where low is outside of target type range.", "author": "sopel39", "createdAt": "2020-10-15T12:18:06Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainCoercer.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SessionTestUtils.TEST_SESSION;\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.predicate.Domain.multipleValues;\n+import static io.prestosql.spi.predicate.Range.greaterThan;\n+import static io.prestosql.spi.predicate.Range.greaterThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.lessThan;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainCoercer\n+{\n+    private Metadata metadata;\n+    private TypeOperators typeOperators;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        metadata = createTestMetadataManager();\n+        typeOperators = new TypeOperators();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        metadata = null;\n+    }\n+\n+    private Domain applySaturatedCasts(Domain domain, Type coercedValueType)\n+    {\n+        return DomainCoercer.applySaturatedCasts(metadata, typeOperators, TEST_SESSION, domain, coercedValueType);\n+    }\n+\n+    @Test\n+    public void testNone()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.none(BIGINT), INTEGER), Domain.none(INTEGER));\n+    }\n+\n+    @Test\n+    public void testAll()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.all(BIGINT), INTEGER), Domain.all(INTEGER));\n+    }\n+\n+    @Test\n+    public void testOnlyNull()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.onlyNull(BIGINT), INTEGER), Domain.onlyNull(INTEGER));\n+    }\n+\n+    @Test\n+    public void testCoercedValueSameAsOriginal()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(multipleValues(BIGINT, ImmutableList.of(1L, 10000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, 10000L, -2000L)));\n+\n+        Domain original = Domain.create(\n+                ValueSet.ofRanges(\n+                        lessThan(DOUBLE, 0.0),\n+                        range(DOUBLE, 0.0, false, 1.0, false),\n+                        range(DOUBLE, 2.0, true, 3.0, true),\n+                        greaterThan(DOUBLE, 4.0)),\n+                true);\n+        assertEquals(\n+                applySaturatedCasts(original, REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges(\n+                                lessThan(REAL, (long) Float.floatToIntBits(0.0f)),\n+                                range(REAL, (long) Float.floatToIntBits(0.0f), false, (long) Float.floatToIntBits(1.0f), false),\n+                                range(REAL, (long) Float.floatToIntBits(2.0f), true, (long) Float.floatToIntBits(3.0f), true),\n+                                greaterThan(REAL, (long) Float.floatToIntBits(4.0f))),\n+                        true));\n+    }\n+\n+    @Test\n+    public void testOutsideTargetTypeRange()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(\n+                        multipleValues(BIGINT, ImmutableList.of(1L, 10000000000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, -2000L)));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(range(DOUBLE, 0.0, true, ((double) Float.MAX_VALUE) * 10, true)),\n+                                true),\n+                        REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges((greaterThanOrEqual(REAL, (long) Float.floatToIntBits(0.0f)))),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE3MzMxNw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507173317", "bodyText": "The next test case has such a scenario\nrange(DOUBLE, ((double) Float.MAX_VALUE) * -2, true, ((double) Float.MAX_VALUE) * 10, true)\nDid you mean a test where only low is outside target type range ?", "author": "raunaqmorarka", "createdAt": "2020-10-18T14:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ5Mzk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUwNjEzMA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505506130", "bodyText": "static import applySaturatedCasts (similar in DynamicFilteringService)", "author": "sopel39", "createdAt": "2020-10-15T12:37:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/LocalDynamicFiltersCollector.java", "diffHunk": "@@ -91,17 +113,24 @@ public DynamicFilter createDynamicFilter(List<Descriptor> descriptors, Map<Symbo\n                 .filter(futures.keySet()::contains)\n                 .map(filterId -> {\n                     // Probe-side columns that can be filtered with this dynamic filter resulting domain.\n-                    List<ColumnHandle> probeColumns = symbolsMap.get(filterId).stream()\n-                            .map(probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)))\n-                            .collect(toImmutableList());\n+                    Map<ColumnHandle, Type> probeColumnTypes = symbolsMap.get(filterId).stream()\n+                            .collect(toImmutableMap(\n+                                    probeSymbol -> requireNonNull(columnsMap.get(probeSymbol), () -> format(\"Missing probe column for %s\", probeSymbol)),\n+                                    typeProvider::get));\n                     return Futures.transform(\n                             requireNonNull(futures.get(filterId), () -> format(\"Missing dynamic filter %s\", filterId)),\n                             // Construct a probe-side predicate by duplicating the resulting domain over the corresponding columns.\n                             domain -> TupleDomain.withColumnDomains(\n-                                    probeColumns.stream()\n+                                    probeColumnTypes.entrySet().stream()\n                                             .collect(toImmutableMap(\n-                                                    column -> column,\n-                                                    column -> domain))),\n+                                                    Map.Entry::getKey,\n+                                                    entry -> {\n+                                                        Type targetType = entry.getValue();\n+                                                        if (!domain.getType().equals(targetType)) {\n+                                                            return DomainCoercer.applySaturatedCasts(metadata, typeOperators, session, domain, targetType);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxMTY3MA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505511670", "bodyText": "put in single line", "author": "sopel39", "createdAt": "2020-10-15T12:46:20Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -65,18 +79,53 @@ public void testSingle()\n         assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(ImmutableMap.of(column, domain)));\n     }\n \n+    @Test\n+    public void testDynamicFilterCoercion()\n+    {\n+        LocalDynamicFiltersCollector collector = new LocalDynamicFiltersCollector(metadata, typeOperators, session);\n+        DynamicFilterId filterId = new DynamicFilterId(\"filter\");\n+        collector.register(ImmutableSet.of(filterId));\n+\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+        Symbol symbol = symbolAllocator.newSymbol(\"symbol\", INTEGER);\n+        ColumnHandle column = new TestingColumnHandle(\"column\");\n+        DynamicFilter filter = collector.createDynamicFilter(\n+                ImmutableList.of(new DynamicFilters.Descriptor(filterId, new Cast(symbol.toSymbolReference(), toSqlType(BIGINT)))),\n+                ImmutableMap.of(symbol, column),\n+                symbolAllocator.getTypes());\n+\n+        // Filter is blocked and not completed.\n+        CompletableFuture<?> isBlocked = filter.isBlocked();\n+        assertFalse(filter.isComplete());\n+        assertTrue(filter.isAwaitable());\n+        assertFalse(isBlocked.isDone());\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.all());\n+\n+        Domain domain = Domain.singleValue(BIGINT, 7L);\n+        collector.collectDynamicFilterDomains(ImmutableMap.of(filterId, domain));\n+\n+        // Unblocked and completed.\n+        assertTrue(filter.isComplete());\n+        assertFalse(filter.isAwaitable());\n+        assertTrue(isBlocked.isDone());\n+        assertEquals(filter.getCurrentPredicate(), TupleDomain.withColumnDomains(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxMzY3NQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505513675", "bodyText": "it should be the other way around, l.suppkey (probe) should be joined with s.suppkey_decimal (build)", "author": "sopel39", "createdAt": "2020-10-15T12:49:23Z", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -160,6 +165,23 @@ public void testBroadcastJoinWithSelectiveBuildSide()\n                         singleValue(BIGINT, 1L))));\n     }\n \n+    @Test(timeOut = 30_000)\n+    public void testJoinWithImplicitCoercion()\n+    {\n+        // setup fact table with integer suppkey\n+        computeActual(\"CREATE TABLE lineitem_decimal AS SELECT orderkey, CAST(suppkey as decimal(19, 0)) suppkey_decimal FROM tpch.tiny.lineitem\");\n+\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem_decimal l JOIN tpch.tiny.supplier s ON l.suppkey_decimal = s.suppkey AND s.name >= 'Supplier#000000080'\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE3ODc4OA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507178788", "bodyText": "right, modified this test now", "author": "raunaqmorarka", "createdAt": "2020-10-18T15:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxMzY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxNDMyNw==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505514327", "bodyText": "TestMemorySmoke#testJoinDynamicFilteringImplicitCoercion should also start filtering.", "author": "sopel39", "createdAt": "2020-10-15T12:50:22Z", "path": "presto-tests/src/test/java/io/prestosql/execution/TestCoordinatorDynamicFiltering.java", "diffHunk": "@@ -160,6 +165,23 @@ public void testBroadcastJoinWithSelectiveBuildSide()\n                         singleValue(BIGINT, 1L))));\n     }\n \n+    @Test(timeOut = 30_000)\n+    public void testJoinWithImplicitCoercion()\n+    {\n+        // setup fact table with integer suppkey\n+        computeActual(\"CREATE TABLE lineitem_decimal AS SELECT orderkey, CAST(suppkey as decimal(19, 0)) suppkey_decimal FROM tpch.tiny.lineitem\");\n+\n+        assertQueryDynamicFilters(\n+                \"SELECT * FROM lineitem_decimal l JOIN tpch.tiny.supplier s ON l.suppkey_decimal = s.suppkey AND s.name >= 'Supplier#000000080'\",\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        new TestingMetadata.TestingColumnHandle(\"suppkey_decimal\", 1, createDecimalType(19, 0)),\n+                        multipleValues(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE3Mzg4MQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507173881", "bodyText": "Yes, in the planner commit it does not filter. In the execution commit, it is modified to assert on filtering.", "author": "raunaqmorarka", "createdAt": "2020-10-18T15:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxNDMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxNzEwMQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505517101", "bodyText": "put these in same line", "author": "sopel39", "createdAt": "2020-10-15T12:54:30Z", "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -339,17 +357,66 @@ public void testShortCircuitOnAllTupleDomain()\n         assertTrue(dynamicFilter.isBlocked().isDone());\n     }\n \n+    @Test\n+    public void testDynamicFilterCoercion()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(metadata, typeOperators, newDirectExecutorService());\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"DF_SYMBOL1\", INTEGER);\n+        Expression df1 = new Cast(symbol1.toSymbolReference(), toSqlType(BIGINT));\n+\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId1 = new StageId(queryId, 1);\n+\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                session,\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of());\n+        dynamicFilterService.stageCannotScheduleMoreTasks(stageId1, 2);\n+\n+        DynamicFilter dynamicFilter = dynamicFilterService.createDynamicFilter(\n+                queryId,\n+                ImmutableList.of(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxNzY2NA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r505517664", "bodyText": "DF from single task is sufficient (test will be simpler). In this test we are testing coercions explicitly.", "author": "sopel39", "createdAt": "2020-10-15T12:55:17Z", "path": "presto-main/src/test/java/io/prestosql/server/TestDynamicFilterService.java", "diffHunk": "@@ -339,17 +357,66 @@ public void testShortCircuitOnAllTupleDomain()\n         assertTrue(dynamicFilter.isBlocked().isDone());\n     }\n \n+    @Test\n+    public void testDynamicFilterCoercion()\n+    {\n+        DynamicFilterService dynamicFilterService = new DynamicFilterService(metadata, typeOperators, newDirectExecutorService());\n+        DynamicFilterId filterId1 = new DynamicFilterId(\"df1\");\n+        SymbolAllocator symbolAllocator = new SymbolAllocator();\n+        Symbol symbol1 = symbolAllocator.newSymbol(\"DF_SYMBOL1\", INTEGER);\n+        Expression df1 = new Cast(symbol1.toSymbolReference(), toSqlType(BIGINT));\n+\n+        QueryId queryId = new QueryId(\"query\");\n+        StageId stageId1 = new StageId(queryId, 1);\n+\n+        dynamicFilterService.registerQuery(\n+                queryId,\n+                session,\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of(filterId1),\n+                ImmutableSet.of());\n+        dynamicFilterService.stageCannotScheduleMoreTasks(stageId1, 2);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0NTk1OA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507645958", "bodyText": "upper bound is missing, but should be there", "author": "sopel39", "createdAt": "2020-10-19T10:39:39Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainCoercer.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SessionTestUtils.TEST_SESSION;\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.predicate.Domain.multipleValues;\n+import static io.prestosql.spi.predicate.Range.greaterThan;\n+import static io.prestosql.spi.predicate.Range.greaterThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.lessThan;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static java.lang.Float.floatToIntBits;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainCoercer\n+{\n+    private Metadata metadata;\n+    private TypeOperators typeOperators;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        metadata = createTestMetadataManager();\n+        typeOperators = new TypeOperators();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        metadata = null;\n+    }\n+\n+    @Test\n+    public void testNone()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.none(BIGINT), INTEGER), Domain.none(INTEGER));\n+    }\n+\n+    @Test\n+    public void testAll()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.all(BIGINT), INTEGER), Domain.all(INTEGER));\n+    }\n+\n+    @Test\n+    public void testOnlyNull()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.onlyNull(BIGINT), INTEGER), Domain.onlyNull(INTEGER));\n+    }\n+\n+    @Test\n+    public void testCoercedValueSameAsOriginal()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(multipleValues(BIGINT, ImmutableList.of(1L, 10000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, 10000L, -2000L)));\n+\n+        Domain original = Domain.create(\n+                ValueSet.ofRanges(\n+                        lessThan(DOUBLE, 0.0),\n+                        range(DOUBLE, 0.0, false, 1.0, false),\n+                        range(DOUBLE, 2.0, true, 3.0, true),\n+                        greaterThan(DOUBLE, 4.0)),\n+                true);\n+        assertEquals(\n+                applySaturatedCasts(original, REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges(\n+                                lessThan(REAL, (long) floatToIntBits(0.0f)),\n+                                range(REAL, (long) floatToIntBits(0.0f), false, (long) floatToIntBits(1.0f), false),\n+                                range(REAL, (long) floatToIntBits(2.0f), true, (long) floatToIntBits(3.0f), true),\n+                                greaterThan(REAL, (long) floatToIntBits(4.0f))),\n+                        true));\n+    }\n+\n+    @Test\n+    public void testOutsideTargetTypeRange()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(\n+                        multipleValues(BIGINT, ImmutableList.of(1L, 10000000000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, -2000L)));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(range(DOUBLE, 0.0, true, ((double) Float.MAX_VALUE) * 10, true)),\n+                                true),\n+                        REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges((greaterThanOrEqual(REAL, (long) floatToIntBits(0.0f)))),\n+                        true));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(DOUBLE, ((double) Float.MAX_VALUE) * -2, true, ((double) Float.MAX_VALUE) * 10, true),\n+                                        range(DOUBLE, 0.0, false, 1.0, false)),\n+                                true),\n+                        REAL),\n+                Domain.all(REAL));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(BIGINT, ((long) Integer.MAX_VALUE) * -2, false, ((long) Integer.MAX_VALUE) * 10, false),\n+                                        range(BIGINT, 2L, true, 3L, true)),\n+                                true),\n+                        INTEGER),\n+                Domain.all(INTEGER));\n+    }\n+\n+    @Test\n+    public void testTruncatedCoercedValue()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(createDecimalType(6, 3), 123456L, true, 234567L, true)),\n+                                true),\n+                        createDecimalType(6, 1)),\n+                Domain.create(\n+                        ValueSet.ofRanges(greaterThan(createDecimalType(6, 1), 1234L)),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgyMjQ3Ng==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r507822476", "bodyText": "fixed now", "author": "raunaqmorarka", "createdAt": "2020-10-19T14:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0NTk1OA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NzczMA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r508377730", "bodyText": "add a not that this doesn't handle NaNs since it's being used by dynamic filtering and NaNs are not possible", "author": "sopel39", "createdAt": "2020-10-20T10:11:27Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainCoercer.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.OperatorNotFoundException;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.predicate.AllOrNoneValueSet;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Marker;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.Ranges;\n+import io.prestosql.spi.predicate.SortedRangeSet;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.sql.InterpretedFunctionInvoker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.OperatorType.SATURATED_FLOOR_CAST;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Apply saturated floor casts for implicit coercions on TupleDomain\n+ */\n+public final class DomainCoercer", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU2MzA0OQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r508563049", "bodyText": "We should also have explicit check for NaNs", "author": "sopel39", "createdAt": "2020-10-20T14:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NzczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3ODMyNQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r508378325", "bodyText": "put in previous line", "author": "sopel39", "createdAt": "2020-10-20T10:12:26Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainCoercer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SessionTestUtils.TEST_SESSION;\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.predicate.Domain.multipleValues;\n+import static io.prestosql.spi.predicate.Range.greaterThan;\n+import static io.prestosql.spi.predicate.Range.greaterThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.lessThan;\n+import static io.prestosql.spi.predicate.Range.lessThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static java.lang.Float.floatToIntBits;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainCoercer\n+{\n+    private Metadata metadata;\n+    private TypeOperators typeOperators;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        metadata = createTestMetadataManager();\n+        typeOperators = new TypeOperators();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        metadata = null;\n+    }\n+\n+    @Test\n+    public void testNone()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.none(BIGINT), INTEGER), Domain.none(INTEGER));\n+    }\n+\n+    @Test\n+    public void testAll()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.all(BIGINT), INTEGER), Domain.all(INTEGER));\n+    }\n+\n+    @Test\n+    public void testOnlyNull()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.onlyNull(BIGINT), INTEGER), Domain.onlyNull(INTEGER));\n+    }\n+\n+    @Test\n+    public void testCoercedValueSameAsOriginal()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(multipleValues(BIGINT, ImmutableList.of(1L, 10000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, 10000L, -2000L)));\n+\n+        Domain original = Domain.create(\n+                ValueSet.ofRanges(\n+                        lessThan(DOUBLE, 0.0),\n+                        range(DOUBLE, 0.0, false, 1.0, false),\n+                        range(DOUBLE, 2.0, true, 3.0, true),\n+                        greaterThan(DOUBLE, 4.0)),\n+                true);\n+        assertEquals(\n+                applySaturatedCasts(original, REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges(\n+                                lessThan(REAL, (long) floatToIntBits(0.0f)),\n+                                range(REAL, (long) floatToIntBits(0.0f), false, (long) floatToIntBits(1.0f), false),\n+                                range(REAL, (long) floatToIntBits(2.0f), true, (long) floatToIntBits(3.0f), true),\n+                                greaterThan(REAL, (long) floatToIntBits(4.0f))),\n+                        true));\n+    }\n+\n+    @Test\n+    public void testOutsideTargetTypeRange()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(\n+                        multipleValues(BIGINT, ImmutableList.of(1L, 10000000000L, -2000L)), SMALLINT),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4ODE5NQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r508388195", "bodyText": "make 234567L, true not inclusive. It should become inclusive", "author": "sopel39", "createdAt": "2020-10-20T10:28:52Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDomainCoercer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static io.prestosql.SessionTestUtils.TEST_SESSION;\n+import static io.prestosql.metadata.MetadataManager.createTestMetadataManager;\n+import static io.prestosql.spi.predicate.Domain.multipleValues;\n+import static io.prestosql.spi.predicate.Range.greaterThan;\n+import static io.prestosql.spi.predicate.Range.greaterThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.lessThan;\n+import static io.prestosql.spi.predicate.Range.lessThanOrEqual;\n+import static io.prestosql.spi.predicate.Range.range;\n+import static io.prestosql.spi.type.BigintType.BIGINT;\n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n+import static io.prestosql.spi.type.DoubleType.DOUBLE;\n+import static io.prestosql.spi.type.IntegerType.INTEGER;\n+import static io.prestosql.spi.type.RealType.REAL;\n+import static io.prestosql.spi.type.SmallintType.SMALLINT;\n+import static java.lang.Float.floatToIntBits;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDomainCoercer\n+{\n+    private Metadata metadata;\n+    private TypeOperators typeOperators;\n+\n+    @BeforeClass\n+    public void setup()\n+    {\n+        metadata = createTestMetadataManager();\n+        typeOperators = new TypeOperators();\n+    }\n+\n+    @AfterClass(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        metadata = null;\n+    }\n+\n+    @Test\n+    public void testNone()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.none(BIGINT), INTEGER), Domain.none(INTEGER));\n+    }\n+\n+    @Test\n+    public void testAll()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.all(BIGINT), INTEGER), Domain.all(INTEGER));\n+    }\n+\n+    @Test\n+    public void testOnlyNull()\n+    {\n+        assertEquals(applySaturatedCasts(Domain.onlyNull(BIGINT), INTEGER), Domain.onlyNull(INTEGER));\n+    }\n+\n+    @Test\n+    public void testCoercedValueSameAsOriginal()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(multipleValues(BIGINT, ImmutableList.of(1L, 10000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, 10000L, -2000L)));\n+\n+        Domain original = Domain.create(\n+                ValueSet.ofRanges(\n+                        lessThan(DOUBLE, 0.0),\n+                        range(DOUBLE, 0.0, false, 1.0, false),\n+                        range(DOUBLE, 2.0, true, 3.0, true),\n+                        greaterThan(DOUBLE, 4.0)),\n+                true);\n+        assertEquals(\n+                applySaturatedCasts(original, REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges(\n+                                lessThan(REAL, (long) floatToIntBits(0.0f)),\n+                                range(REAL, (long) floatToIntBits(0.0f), false, (long) floatToIntBits(1.0f), false),\n+                                range(REAL, (long) floatToIntBits(2.0f), true, (long) floatToIntBits(3.0f), true),\n+                                greaterThan(REAL, (long) floatToIntBits(4.0f))),\n+                        true));\n+    }\n+\n+    @Test\n+    public void testOutsideTargetTypeRange()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(\n+                        multipleValues(BIGINT, ImmutableList.of(1L, 10000000000L, -2000L)), SMALLINT),\n+                multipleValues(SMALLINT, ImmutableList.of(1L, -2000L)));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(range(DOUBLE, 0.0, true, ((double) Float.MAX_VALUE) * 10, true)),\n+                                true),\n+                        REAL),\n+                Domain.create(\n+                        ValueSet.ofRanges((range(REAL, (long) floatToIntBits(0.0f), true, (long) floatToIntBits(Float.MAX_VALUE), true))),\n+                        true));\n+\n+        // low below and high above target type range\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(DOUBLE, ((double) Float.MAX_VALUE) * -2, true, ((double) Float.MAX_VALUE) * 10, true)),\n+                                true),\n+                        REAL),\n+                Domain.create(ValueSet.ofRanges(lessThanOrEqual(REAL, (long) floatToIntBits(Float.MAX_VALUE))), true));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(BIGINT, ((long) Integer.MAX_VALUE) * -2, false, ((long) Integer.MAX_VALUE) * 10, false)),\n+                                true),\n+                        INTEGER),\n+                Domain.create(ValueSet.ofRanges(lessThanOrEqual(INTEGER, (long) Integer.MAX_VALUE)), true));\n+\n+        // Low and high below target type range\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(BIGINT, ((long) Integer.MAX_VALUE) * -4, false, ((long) Integer.MAX_VALUE) * -2, false)),\n+                                false),\n+                        INTEGER),\n+                Domain.none(INTEGER));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(DOUBLE, ((double) Float.MAX_VALUE) * -4, true, ((double) Float.MAX_VALUE) * -2, true)),\n+                                true),\n+                        REAL),\n+                Domain.onlyNull(REAL));\n+\n+        // Low and high above target type range\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(BIGINT, ((long) Integer.MAX_VALUE) * 2, false, ((long) Integer.MAX_VALUE) * 4, false)),\n+                                false),\n+                        INTEGER),\n+                Domain.none(INTEGER));\n+\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(DOUBLE, ((double) Float.MAX_VALUE) * 2, true, ((double) Float.MAX_VALUE) * 4, true)),\n+                                true),\n+                        REAL),\n+                Domain.onlyNull(REAL));\n+\n+        // all short-circuit\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        greaterThanOrEqual(DOUBLE, ((double) Float.MAX_VALUE) * -4),\n+                                        range(DOUBLE, 0.0, true, 1.0, true)),\n+                                true),\n+                        REAL),\n+                Domain.all(REAL));\n+    }\n+\n+    @Test\n+    public void testTruncatedCoercedValue()\n+    {\n+        assertEquals(\n+                applySaturatedCasts(\n+                        Domain.create(\n+                                ValueSet.ofRanges(\n+                                        range(createDecimalType(6, 3), 123456L, true, 234567L, true)),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4ODM2OQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r508388369", "bodyText": "undo", "author": "sopel39", "createdAt": "2020-10-20T10:29:07Z", "path": "presto-spi/src/main/java/io/prestosql/spi/predicate/EquatableValueSet.java", "diffHunk": "@@ -99,7 +99,7 @@ static EquatableValueSet of(Type type, Object first, Object... rest)\n         return new EquatableValueSet(type, true, set);\n     }\n \n-    static EquatableValueSet copyOf(Type type, Collection<Object> values)\n+    public static EquatableValueSet copyOf(Type type, Collection<Object> values)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4OTYxMQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r508389611", "bodyText": "It's still collected as BIGINT.", "author": "sopel39", "createdAt": "2020-10-20T10:31:13Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveDynamicPartitionPruning.java", "diffHunk": "@@ -252,8 +252,7 @@ public void testJoinWithImplicitCoercion()\n         assertEquals(dynamicFiltersStats.getReplicatedDynamicFilters(), 0L);\n         assertEquals(dynamicFiltersStats.getDynamicFiltersCompleted(), 1L);\n         DynamicFilterDomainStats domainStats = getOnlyElement(dynamicFiltersStats.getDynamicFilterDomainStats());\n-        // Dynamic filter is collected from build side but not used for such cases\n-        assertEquals(domainStats.getSimplifiedDomain(), singleValue(BIGINT, 1L).toString(getSession().toConnectorSession()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwOTI1NQ==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r508409255", "bodyText": "right, dynamicFilterDomainStats doesn't know about the coerced value", "author": "raunaqmorarka", "createdAt": "2020-10-20T11:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4OTYxMQ=="}], "type": "inlineReview"}, {"oid": "9ca1d0322774f9abb07f6076160244f95ce89f42", "url": "https://github.com/trinodb/trino/commit/9ca1d0322774f9abb07f6076160244f95ce89f42", "message": "Allow dynamic filters with implicit coercion cast in planner", "committedDate": "2020-10-20T10:58:03Z", "type": "commit"}, {"oid": "6f8433daa42d9e9ccc9f80ebb2375acb4c763da1", "url": "https://github.com/trinodb/trino/commit/6f8433daa42d9e9ccc9f80ebb2375acb4c763da1", "message": "Implement DomainCoercer", "committedDate": "2020-10-20T10:58:03Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "c77f477e127541c2aa6ee2c2e7184243feb82db0", "url": "https://github.com/trinodb/trino/commit/c77f477e127541c2aa6ee2c2e7184243feb82db0", "message": "Implement dynamic filter coercion in execution", "committedDate": "2020-10-20T11:04:34Z", "type": "commit"}, {"oid": "c77f477e127541c2aa6ee2c2e7184243feb82db0", "url": "https://github.com/trinodb/trino/commit/c77f477e127541c2aa6ee2c2e7184243feb82db0", "message": "Implement dynamic filter coercion in execution", "committedDate": "2020-10-20T11:04:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY0ODkyNA==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r509648924", "bodyText": "There are two possible approaches: SATURATED_FLOOR_CAST and coerce-coerce (as in UnwrapCastInComparison).\nWhat was the reason to choose the former over the latter?\nCan we capture the reasoning in writing somewhere?\ncc @sopel39 @martint", "author": "findepi", "createdAt": "2020-10-21T20:11:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/DomainCoercer.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner;\n+\n+import com.google.common.base.Throwables;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.Session;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.OperatorNotFoundException;\n+import io.prestosql.metadata.ResolvedFunction;\n+import io.prestosql.spi.PrestoException;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.function.InvocationConvention;\n+import io.prestosql.spi.predicate.AllOrNoneValueSet;\n+import io.prestosql.spi.predicate.Domain;\n+import io.prestosql.spi.predicate.Marker;\n+import io.prestosql.spi.predicate.Range;\n+import io.prestosql.spi.predicate.Ranges;\n+import io.prestosql.spi.predicate.SortedRangeSet;\n+import io.prestosql.spi.predicate.ValueSet;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.spi.type.TypeOperators;\n+import io.prestosql.sql.InterpretedFunctionInvoker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationArgumentConvention.NEVER_NULL;\n+import static io.prestosql.spi.function.InvocationConvention.InvocationReturnConvention.FAIL_ON_NULL;\n+import static io.prestosql.spi.function.OperatorType.SATURATED_FLOOR_CAST;\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Apply saturated floor casts for implicit coercions on TupleDomain.\n+ * This class does not handle Float.NaN and Double.NaN because\n+ * currently it is used only in dynamic filtering where NaNs are not part of TupleDomain.\n+ */\n+public final class DomainCoercer\n+{\n+    private DomainCoercer() {}\n+\n+    public static Domain applySaturatedCasts(\n+            Metadata metadata,\n+            TypeOperators typeOperators,\n+            Session session,\n+            Domain domain,\n+            Type coercedValueType)\n+    {\n+        return new ImplicitCoercer(metadata, typeOperators, session, domain, coercedValueType).applySaturatedCasts();\n+    }\n+\n+    private static class ImplicitCoercer\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final InterpretedFunctionInvoker functionInvoker;\n+        private final ResolvedFunction saturatedFloorCastOperator;\n+        private final ResolvedFunction castToOriginalTypeOperator;\n+        private final MethodHandle comparisonOperator;\n+        private final Domain domain;\n+        private final Type coercedValueType;\n+\n+        private ImplicitCoercer(Metadata metadata, TypeOperators typeOperators, Session session, Domain domain, Type coercedValueType)\n+        {\n+            this.connectorSession = requireNonNull(session, \"session is null\").toConnectorSession();\n+            this.functionInvoker = new InterpretedFunctionInvoker(metadata);\n+            this.domain = requireNonNull(domain, \"domain is null\");\n+            this.coercedValueType = requireNonNull(coercedValueType, \"coercedValueType is null\");\n+            Type originalValueType = domain.getType();\n+            try {\n+                this.saturatedFloorCastOperator = metadata.getCoercion(SATURATED_FLOOR_CAST, originalValueType, coercedValueType);", "originalCommit": "c77f477e127541c2aa6ee2c2e7184243feb82db0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTg3MTg4Ng==", "url": "https://github.com/trinodb/trino/pull/5461#discussion_r579871886", "bodyText": "ping?", "author": "findepi", "createdAt": "2021-02-21T21:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTY0ODkyNA=="}], "type": "inlineReview"}]}