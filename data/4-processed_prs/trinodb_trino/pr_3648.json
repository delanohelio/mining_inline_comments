{"pr_number": 3648, "pr_title": "Optimize system.jdbc.columns metadata calls", "pr_createdAt": "2020-05-06T14:53:06Z", "pr_url": "https://github.com/trinodb/trino/pull/3648", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg1NTY4Ng==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r420855686", "bodyText": "#3647", "author": "findepi", "createdAt": "2020-05-06T14:53:15Z", "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "diffHunk": "@@ -156,12 +157,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n \n         TupleDomain<ColumnHandle> oldDomain = table.getConstraint();\n         TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain) && !constraint.predicate().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        SystemTable systemTable = checkAndGetTable(session, table);\n+        if (systemTable instanceof JdbcTable) {\n+            TupleDomain<ColumnHandle> filtered = ((JdbcTable) systemTable).applyFilter(session, new Constraint(newDomain, constraint.predicate(), constraint.getColumns()));\n+            newDomain = newDomain.intersect(filtered);\n+        }\n+\n         if (oldDomain.equals(newDomain)) {\n             return Optional.empty();\n         }\n \n+        if (newDomain.isNone()) {\n+            // TODO (https://github.com/prestosql/presto/issues/3647) indicate the table scan is empty", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "53fcc625392eb2dfc494b9c1218ac31e3a7e13af", "url": "https://github.com/trinodb/trino/commit/53fcc625392eb2dfc494b9c1218ac31e3a7e13af", "message": "Remove redundant condition\n\nThe method is used to get `varchar` `Domain`'s value, so we know the\nvalue is a `Slice`.", "committedDate": "2020-05-06T15:37:14Z", "type": "commit"}, {"oid": "e881624eb3d998382a168104e7f1b7add2f2d3d0", "url": "https://github.com/trinodb/trino/commit/e881624eb3d998382a168104e7f1b7add2f2d3d0", "message": "Rename method and make more flexible", "committedDate": "2020-05-06T15:37:15Z", "type": "commit"}, {"oid": "46b104c0f5faee70e62a985dee98ecb4cca746f7", "url": "https://github.com/trinodb/trino/commit/46b104c0f5faee70e62a985dee98ecb4cca746f7", "message": "Replace FilterUtil.filter method\n\nReplace the method with better API.", "committedDate": "2020-05-06T15:37:16Z", "type": "commit"}, {"oid": "0e0a8ccf73b236910db1d89950a226351a98242f", "url": "https://github.com/trinodb/trino/commit/0e0a8ccf73b236910db1d89950a226351a98242f", "message": "Simplify control flow", "committedDate": "2020-05-06T15:37:17Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTc0OQ==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421221749", "bodyText": "Why special-case JdbcTable? It'd be more naturally (and less code-smelly) to add applyFilter to SystemTable.", "author": "martint", "createdAt": "2020-05-07T03:45:43Z", "path": "presto-main/src/main/java/io/prestosql/connector/system/SystemTablesMetadata.java", "diffHunk": "@@ -156,12 +157,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n \n         TupleDomain<ColumnHandle> oldDomain = table.getConstraint();\n         TupleDomain<ColumnHandle> newDomain = oldDomain.intersect(constraint.getSummary());\n+        if (oldDomain.equals(newDomain) && !constraint.predicate().isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        SystemTable systemTable = checkAndGetTable(session, table);\n+        if (systemTable instanceof JdbcTable) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzM0MA==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421267340", "bodyText": "For the cursor method, we translate TupleDomain<ColumnHandle>, into ordinals:  TupleDomain<Integer>.\nFor applyFilter\n\nWe can't pass Constraint since  it is expressed in terms of ColumnHandle, but SystemColumnHandle is not SPI. And we can't translate to ordinals, because of  f148e56 (of course, we can revert that, but I would strongly prefer this to be a follow up)\nfor same reason we cannot have the method return ConstraintApplicationResult... The applyFilter  returns refined domain.\n\nI concluded we are not ready to add this method to SystemTable. I considered adding a new interface for this, but decided it's not warranted in current situation.\nHence this is how it is. But this is definitely easy to improve in the future, when we conclude this is ready. (So far I didn't change SPI in any way, so no debt on this aspect.)", "author": "findepi", "createdAt": "2020-05-07T06:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0Nzg3MA==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421647870", "bodyText": "Can you add a comment with a TODO so that future readers know why it was done this way?", "author": "martint", "createdAt": "2020-05-07T16:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgxMjA1OQ==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421812059", "bodyText": "Added some comment in the code too.", "author": "findepi", "createdAt": "2020-05-07T21:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMjM0MQ==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421222341", "bodyText": "In what scenarios would these be empty strings? If this is just an optimization, add a comment.", "author": "martint", "createdAt": "2020-05-07T03:48:11Z", "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2Nzg5NQ==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421267895", "bodyText": "It will be empty string when user query contains filters like TABLE_CAT = ''.\nIt is not really an optimization, because eg SchemaTablePrefix constrcuted below validates args are non-empty, so the code would fail without this if here.", "author": "findepi", "createdAt": "2020-05-07T06:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMjM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzkzMQ==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421267931", "bodyText": "Will add a comment.", "author": "findepi", "createdAt": "2020-05-07T06:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMjM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYwNjA4OQ==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421606089", "bodyText": "This is same problem as in #2523. I will rework that fix, so that it's applicable to .jdbc.columns as well.", "author": "findepi", "createdAt": "2020-05-07T15:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMjM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNTkxOA==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421225918", "bodyText": "Using ImmutableMap.builder() is less sensitive to reformatting changes that may end up placing arguments in separate lines (and even if that happens, it's still clear which ones are keys and which ones are values). TLDR, when there are multiple entries, it's more robust to use the builder form than the multi-entry ImmutableMap.of().", "author": "martint", "createdAt": "2020-05-07T04:02:33Z", "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();\n+        }\n+\n+        List<String> catalogs = listCatalogs(session, metadata, accessControl, catalogFilter).keySet().stream()\n+                .filter(catalogName -> predicate.test(ImmutableMap.of(TABLE_CATALOG_COLUMN, toNullableValue(catalogName))))\n+                .collect(toImmutableList());\n+\n+        List<CatalogSchemaName> schemas = catalogs.stream()\n+                .flatMap(catalogName ->\n+                        listSchemas(session, metadata, accessControl, catalogName, schemaFilter).stream()\n+                                .filter(schemaName -> !hasSchemaPredicate || predicate.test(ImmutableMap.of(\n+                                        TABLE_CATALOG_COLUMN, toNullableValue(catalogName),\n+                                        TABLE_SCHEMA_COLUMN, toNullableValue(schemaName))))\n+                                .map(schemaName -> new CatalogSchemaName(catalogName, schemaName)))\n+                .collect(toImmutableList());\n+\n+        if (!hasTablePredicate) {\n+            return TupleDomain.withColumnDomains(ImmutableMap.of(\n+                    TABLE_CATALOG_COLUMN, schemas.stream()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNjQ1OQ==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421226459", "bodyText": ".simplify(...) on the next line", "author": "martint", "createdAt": "2020-05-07T04:04:54Z", "path": "presto-main/src/main/java/io/prestosql/connector/system/jdbc/ColumnJdbcTable.java", "diffHunk": "@@ -111,24 +139,155 @@ public ConnectorTableMetadata getTableMetadata()\n         return METADATA;\n     }\n \n+    @Override\n+    public TupleDomain<ColumnHandle> applyFilter(ConnectorSession connectorSession, Constraint constraint)\n+    {\n+        TupleDomain<ColumnHandle> tupleDomain = constraint.getSummary();\n+        if (tupleDomain.isNone() || !constraint.predicate().isPresent()) {\n+            return tupleDomain;\n+        }\n+        Predicate<Map<ColumnHandle, NullableValue>> predicate = constraint.predicate().get();\n+        Set<ColumnHandle> predicateColumns = constraint.getColumns().orElseThrow(() -> new VerifyException(\"columns not present for a predicate\"));\n+\n+        boolean hasSchemaPredicate = predicateColumns.contains(TABLE_SCHEMA_COLUMN);\n+        boolean hasTablePredicate = predicateColumns.contains(TABLE_NAME_COLUMN);\n+        if (!hasSchemaPredicate && !hasTablePredicate) {\n+            // No filter on schema name and table name at all.\n+            return tupleDomain;\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+\n+        Optional<String> catalogFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_CATALOG_COLUMN);\n+        Optional<String> schemaFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_SCHEMA_COLUMN);\n+        Optional<String> tableFilter = tryGetSingleVarcharValue(tupleDomain, TABLE_NAME_COLUMN);\n+\n+        if (catalogFilter.equals(Optional.of(\"\")) ||\n+                schemaFilter.equals(Optional.of(\"\")) ||\n+                tableFilter.equals(Optional.of(\"\"))) {\n+            return TupleDomain.none();\n+        }\n+\n+        List<String> catalogs = listCatalogs(session, metadata, accessControl, catalogFilter).keySet().stream()\n+                .filter(catalogName -> predicate.test(ImmutableMap.of(TABLE_CATALOG_COLUMN, toNullableValue(catalogName))))\n+                .collect(toImmutableList());\n+\n+        List<CatalogSchemaName> schemas = catalogs.stream()\n+                .flatMap(catalogName ->\n+                        listSchemas(session, metadata, accessControl, catalogName, schemaFilter).stream()\n+                                .filter(schemaName -> !hasSchemaPredicate || predicate.test(ImmutableMap.of(\n+                                        TABLE_CATALOG_COLUMN, toNullableValue(catalogName),\n+                                        TABLE_SCHEMA_COLUMN, toNullableValue(schemaName))))\n+                                .map(schemaName -> new CatalogSchemaName(catalogName, schemaName)))\n+                .collect(toImmutableList());\n+\n+        if (!hasTablePredicate) {\n+            return TupleDomain.withColumnDomains(ImmutableMap.of(\n+                    TABLE_CATALOG_COLUMN, schemas.stream()\n+                            .map(CatalogSchemaName::getCatalogName)\n+                            .collect(toVarcharDomain())\n+                            .simplify(MAX_DOMAIN_SIZE),\n+                    TABLE_SCHEMA_COLUMN, schemas.stream()\n+                            .map(CatalogSchemaName::getSchemaName)\n+                            .collect(toVarcharDomain())\n+                            .simplify(MAX_DOMAIN_SIZE)));\n+        }\n+\n+        List<CatalogSchemaTableName> tables = schemas.stream()\n+                .flatMap(schema -> {\n+                    QualifiedTablePrefix tablePrefix = tableFilter.isPresent()\n+                            ? new QualifiedTablePrefix(schema.getCatalogName(), schema.getSchemaName(), tableFilter.get())\n+                            : new QualifiedTablePrefix(schema.getCatalogName(), schema.getSchemaName());\n+                    return listTables(session, metadata, accessControl, tablePrefix).stream()\n+                            .filter(schemaTableName -> predicate.test(ImmutableMap.of(\n+                                    TABLE_CATALOG_COLUMN, toNullableValue(schema.getCatalogName()),\n+                                    TABLE_SCHEMA_COLUMN, toNullableValue(schemaTableName.getSchemaName()),\n+                                    TABLE_NAME_COLUMN, toNullableValue(schemaTableName.getTableName()))))\n+                            .map(schemaTableName -> new CatalogSchemaTableName(schema.getCatalogName(), schemaTableName.getSchemaName(), schemaTableName.getTableName()));\n+                })\n+                .collect(toImmutableList());\n+\n+        return TupleDomain.withColumnDomains(ImmutableMap.of(\n+                TABLE_CATALOG_COLUMN, tables.stream()\n+                        .map(CatalogSchemaTableName::getCatalogName)\n+                        .collect(toVarcharDomain()).simplify(MAX_DOMAIN_SIZE),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "e13b802b1f8429471472711ce5551b24231ff45f", "url": "https://github.com/trinodb/trino/commit/e13b802b1f8429471472711ce5551b24231ff45f", "message": "Move empty table name check to MetadataManager\n\n`MetadataManager` does not correctly behave when asked for `new\nQualifiedObjectName(\"\", \"\", \"\")` table or view.\n\nThis was previously worked around in the `information_schema`\nconnector, but since it applies to other metadata users, it should be\nfixed in `MetadataManager` directly.", "committedDate": "2020-05-07T21:42:50Z", "type": "commit"}, {"oid": "2b82112eb15004567793b2c72a115918c93283b6", "url": "https://github.com/trinodb/trino/commit/2b82112eb15004567793b2c72a115918c93283b6", "message": "Optimize system.jdbc.columns metadata calls", "committedDate": "2020-05-07T21:42:50Z", "type": "commit"}, {"oid": "2b82112eb15004567793b2c72a115918c93283b6", "url": "https://github.com/trinodb/trino/commit/2b82112eb15004567793b2c72a115918c93283b6", "message": "Optimize system.jdbc.columns metadata calls", "committedDate": "2020-05-07T21:42:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2Mjk2NA==", "url": "https://github.com/trinodb/trino/pull/3648#discussion_r421962964", "bodyText": "Nice!", "author": "kokosing", "createdAt": "2020-05-08T06:23:58Z", "path": "presto-jdbc/src/test/java/io/prestosql/jdbc/TestPrestoDatabaseMetaData.java", "diffHunk": "@@ -1169,22 +1169,52 @@ public void testGetColumnsMetadataCalls()\n                         list(\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"TYPE_NAME\")),\n                 list(list(COUNTING_CATALOG, \"test_schema1\", \"test_table1\", \"column_17\", \"varchar\")),\n                 new MetadataCallsCount()\n-                        .withListSchemasCount(1)\n-                        .withListTablesCount(2)\n-                        .withGetColumnsCount(3000));", "originalCommit": "2b82112eb15004567793b2c72a115918c93283b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}