{"pr_number": 4383, "pr_title": "Fix failure for IN expression in join criteria", "pr_createdAt": "2020-07-08T04:36:44Z", "pr_url": "https://github.com/trinodb/trino/pull/4383", "timeline": [{"oid": "cacfe1dcf1d017b5da590c59e203ca0273980cf5", "url": "https://github.com/trinodb/trino/commit/cacfe1dcf1d017b5da590c59e203ca0273980cf5", "message": "Fix failure for IN expression in join criteria\n\nThe planner was making a decision of whether to plan the subquery on the\nleft or right depending on whether all the columns in the expression\ncould be satisfied by either side. However, it was not excluding\ncolumns in the subquery.", "committedDate": "2020-07-08T04:35:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyMTUwMQ==", "url": "https://github.com/trinodb/trino/pull/4383#discussion_r451421501", "bodyText": "what if there is a reference to outer column within subquery?", "author": "sopel39", "createdAt": "2020-07-08T09:50:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SymbolsExtractor.java", "diffHunk": "@@ -181,5 +191,15 @@ protected Void visitIdentifier(Identifier node, ImmutableSet.Builder<QualifiedNa\n             builder.add(QualifiedName.of(node.getValue()));\n             return null;\n         }\n+\n+        @Override\n+        protected Void visitSubqueryExpression(SubqueryExpression node, ImmutableSet.Builder<QualifiedName> context)", "originalCommit": "cacfe1dcf1d017b5da590c59e203ca0273980cf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1MjA0NQ==", "url": "https://github.com/trinodb/trino/pull/4383#discussion_r451552045", "bodyText": "That\u2019s taken care of during analysis. See the comment where this is used in join planning.\nThere\u2019s a broader cleanup that needs to be done at some point. Unfortunately, we currently resolve columns in join planning to determine where they originate. This should be done entirely during analysis.", "author": "martint", "createdAt": "2020-07-08T13:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyMTUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU2NDY0NA==", "url": "https://github.com/trinodb/trino/pull/4383#discussion_r451564644", "bodyText": "Could we have a test case for such subquery (referencing outer scope)?", "author": "sopel39", "createdAt": "2020-07-08T13:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyMTUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU3MjY0OQ==", "url": "https://github.com/trinodb/trino/pull/4383#discussion_r451572649", "bodyText": "We already have a bunch of them. See the tests further down below the one I added. E.g.,\n        assertThatThrownBy(() -> assertions.query(\n                \"SELECT * FROM (VALUES 1, 2, NULL) t(x) FULL JOIN (VALUES 1, 3, NULL) u(x) ON u.x IN (VALUES t.x)\"))\n                .hasMessage(\"line 1:93: Reference to column 't.x' from outer scope not allowed in this context\");", "author": "martint", "createdAt": "2020-07-08T14:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyMTUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ5MDk5MA==", "url": "https://github.com/trinodb/trino/pull/4383#discussion_r451490990", "bodyText": "consider using io.prestosql.sql.util.AstUtils#preOrder instead of DefaultExpressionTraversalVisitor", "author": "kokosing", "createdAt": "2020-07-08T12:07:13Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/SymbolsExtractor.java", "diffHunk": "@@ -124,7 +125,14 @@ private SymbolsExtractor() {}\n     public static Set<QualifiedName> extractNames(Expression expression, Set<NodeRef<Expression>> columnReferences)\n     {\n         ImmutableSet.Builder<QualifiedName> builder = ImmutableSet.builder();\n-        new QualifiedNameBuilderVisitor(columnReferences).process(expression, builder);\n+        new QualifiedNameBuilderVisitor(columnReferences, true).process(expression, builder);\n+        return builder.build();\n+    }\n+\n+    public static Set<QualifiedName> extractNamesNoSubqueries(Expression expression, Set<NodeRef<Expression>> columnReferences)\n+    {\n+        ImmutableSet.Builder<QualifiedName> builder = ImmutableSet.builder();\n+        new QualifiedNameBuilderVisitor(columnReferences, false).process(expression, builder);", "originalCommit": "cacfe1dcf1d017b5da590c59e203ca0273980cf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU3NTU3Ng==", "url": "https://github.com/trinodb/trino/pull/4383#discussion_r451575576", "bodyText": "That's more complicated, as there's no way to stop the recursion with preOrder. In any case, I just extended what's already there. That would be a separate cleanup task.", "author": "martint", "createdAt": "2020-07-08T14:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQ5MDk5MA=="}], "type": "inlineReview"}]}