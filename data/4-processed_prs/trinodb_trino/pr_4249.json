{"pr_number": 4249, "pr_title": "SPI and optimizer rule for connectors that can support complete topN \u2026", "pr_createdAt": "2020-06-26T21:35:49Z", "pr_url": "https://github.com/trinodb/trino/pull/4249", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5ODcxMQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r448298711", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        TopNFunction topNFunctions,\n          \n          \n            \n                        TopNFunction topNFunction,", "author": "findepi", "createdAt": "2020-07-01T11:28:09Z", "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -362,6 +363,12 @@\n             Map<String, ColumnHandle> assignments,\n             List<List<ColumnHandle>> groupingSets);\n \n+    Optional<TableHandle> applyTopN(\n+            Session session,\n+            TableHandle handle,\n+            TopNFunction topNFunctions,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NTc3OA==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r449445778", "bodyText": "Fixed", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-03T08:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5ODcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMDEwMw==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r448300103", "bodyText": "I am not sure this is a \"function\".\nI will defer to Martin for the name though", "author": "findepi", "createdAt": "2020-07-01T11:30:55Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/TopNFunction.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class TopNFunction", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NTgxMg==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r449445812", "bodyText": "renamed it to just TopN", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-03T08:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMDEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMDM4Ng==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r448300386", "bodyText": "List.copyOf\nvalidate the list is not empty", "author": "findepi", "createdAt": "2020-07-01T11:31:34Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/TopNFunction.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class TopNFunction\n+{\n+    private final long count;\n+    private final List<SortItem> orderBy;\n+\n+    public TopNFunction(long count, List<SortItem> orderBy)\n+    {\n+        this.count = count;\n+        this.orderBy = requireNonNull(orderBy, \"sortItems is null\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NTgzNg==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r449445836", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-03T08:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMDM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMTIxMg==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r448301212", "bodyText": "we do not expect a need to remap column handles, do we?", "author": "findepi", "createdAt": "2020-07-01T11:33:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -925,6 +925,28 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /**\n+     * Attempt to push down the topN into the table scan.\n+     * <p>\n+     * Connectors can indicate whether they don't support topN pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * </p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports topN pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * <p>\n+     * If the connector can handle TopN Pushdown it should return a new table handle which will replace the existing\n+     * table handle in the TableScan.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NTk2NQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r449445965", "bodyText": "I don't think that is needed as all the connector should need is a way to know what is the sort order and the limit and no column handle should change in any way.", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-03T08:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMTIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMTM2OQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r448301369", "bodyText": "topN -> TopN ?", "author": "findepi", "createdAt": "2020-07-01T11:33:37Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -925,6 +925,28 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /**\n+     * Attempt to push down the topN into the table scan.", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NjAzNQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r449446035", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-03T08:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMTM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMjE3Ng==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r448302176", "bodyText": "keep every argument on a separate line\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ApplyTopN applyTopN, BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> getInsertLayout,\n          \n          \n            \n                            ApplyTopN applyTopN, \n          \n          \n            \n                            BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> getInsertLayout,", "author": "findepi", "createdAt": "2020-07-01T11:35:26Z", "path": "presto-main/src/test/java/io/prestosql/connector/MockConnectorFactory.java", "diffHunk": "@@ -162,7 +173,7 @@ private MockConnector(\n                 BiFunction<ConnectorSession, SchemaTableName, ConnectorTableHandle> getTableHandle,\n                 Function<SchemaTableName, List<ColumnMetadata>> getColumns,\n                 ApplyProjection applyProjection,\n-                BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> getInsertLayout,\n+                ApplyTopN applyTopN, BiFunction<ConnectorSession, SchemaTableName, Optional<ConnectorNewTableLayout>> getInsertLayout,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NjA3Mw==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r449446073", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-03T08:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMjE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMjI5Mw==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r448302293", "bodyText": "requireNonNull", "author": "findepi", "createdAt": "2020-07-01T11:35:42Z", "path": "presto-main/src/test/java/io/prestosql/connector/MockConnectorFactory.java", "diffHunk": "@@ -98,6 +101,7 @@ private MockConnectorFactory(\n         this.getTableHandle = requireNonNull(getTableHandle, \"getTableHandle is null\");\n         this.getColumns = getColumns;\n         this.applyProjection = applyProjection;\n+        this.applyTopN = applyTopN;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NjExMw==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r449446113", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-03T08:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwMjI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwNjI4OQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r448306289", "bodyText": "orderBy -> symbol", "author": "findepi", "createdAt": "2020-07-01T11:44:12Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushTopNIntoTableScan.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortItem;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.connector.TopNFunction;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.topN;\n+\n+public class PushTopNIntoTableScan\n+        implements Rule<TopNNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<TopNNode> PATTERN = topN().with(source().matching(\n+            tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushTopNIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<TopNNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(TopNNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+\n+        TopNFunction topNFunction = toTopNFunction(node);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+\n+        Optional<TableHandle> result = metadata.applyTopN(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                topNFunction,\n+                assignments);\n+\n+        if (result.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        return Result.ofPlanNode(\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                result.get(),\n+                                tableScan.getOutputSymbols(),\n+                                tableScan.getAssignments()));\n+    }\n+\n+    private TopNFunction toTopNFunction(TopNNode topNNode)\n+    {\n+        long count = topNNode.getCount();\n+        OrderingScheme orderingScheme = topNNode.getOrderingScheme();\n+        List<SortItem> sortBy = orderingScheme.getOrderBy().stream()\n+                .map(orderBy -> new SortItem(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NjE0Mw==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r449446143", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-03T08:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwNjI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwNjgwMQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r448306801", "bodyText": "please extract private static List<SortItem> toSortItems(OrderingScheme orderingScheme) here", "author": "findepi", "createdAt": "2020-07-01T11:45:13Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushTopNIntoTableScan.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortItem;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.connector.TopNFunction;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.topN;\n+\n+public class PushTopNIntoTableScan\n+        implements Rule<TopNNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<TopNNode> PATTERN = topN().with(source().matching(\n+            tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushTopNIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<TopNNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(TopNNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+\n+        TopNFunction topNFunction = toTopNFunction(node);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+\n+        Optional<TableHandle> result = metadata.applyTopN(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                topNFunction,\n+                assignments);\n+\n+        if (result.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        return Result.ofPlanNode(\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                result.get(),\n+                                tableScan.getOutputSymbols(),\n+                                tableScan.getAssignments()));\n+    }\n+\n+    private TopNFunction toTopNFunction(TopNNode topNNode)\n+    {\n+        long count = topNNode.getCount();\n+        OrderingScheme orderingScheme = topNNode.getOrderingScheme();\n+        List<SortItem> sortBy = orderingScheme.getOrderBy().stream()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ0NjIxNA==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r449446214", "bodyText": "I actually moved the method to OrderingScheme class as we already reuse this for both TopN and Agg Pushdown.", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-03T08:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMwNjgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1Mjk2MQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r456652961", "bodyText": "Having a dedicated class for this seems overkill. Every place that uses this has immediate access to the count and SortItems from a TopNNode. The SPI method can just take both fields separately.", "author": "martint", "createdAt": "2020-07-17T20:12:21Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/TopN.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import java.util.List;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class TopN", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYzNTg2MQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r459635861", "bodyText": "Removed the class and added topNCount and sortItems as just arguments.", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-23T18:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1Mjk2MQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2ODg4Mg==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r461968882", "bodyText": "I think we'll want to return a structure similar to applyLimit, where it indicates whether the limit is guaranteed by the connector. In the case of a distributed connector implementation, it may not be able to perform a global top N, but it could still benefit from pushing down the operation, for instance, to each individual storage shard.", "author": "martint", "createdAt": "2020-07-29T00:27:45Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -933,6 +933,29 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /**\n+     * Attempt to push down the TopN into the table scan.\n+     * <p>\n+     * Connectors can indicate whether they don't support topN pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * </p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports topN pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * <p>\n+     * If the connector can handle TopN Pushdown it should return a new table handle which will replace the existing\n+     * table handle in the TableScan.\n+     */\n+    default Optional<ConnectorTableHandle> applyTopN(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYwNzg1Mg==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r462607852", "bodyText": "Added TopNApplicationResult which is basically same as LimitApplicationResult for now and added a test case that tests that when limitGuaranteed is set to false we create a plan with TopNPartial stage with updated connector table handle reference.", "author": "Parth-Brahmbhatt", "createdAt": "2020-07-29T21:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2ODg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3ODE5NQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r464578195", "bodyText": "@martint can you review this again when you find some time?", "author": "Parth-Brahmbhatt", "createdAt": "2020-08-03T18:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2ODg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjg2OQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r464712869", "bodyText": "I believe this should be Step.FINAL. The partial Top N is being handled by the connector at this point.", "author": "martint", "createdAt": "2020-08-03T23:24:52Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushTopNIntoTableScan.java", "diffHunk": "@@ -56,33 +55,30 @@ public PushTopNIntoTableScan(Metadata metadata)\n     }\n \n     @Override\n-    public Result apply(TopNNode node, Captures captures, Context context)\n+    public Result apply(TopNNode topNNode, Captures captures, Context context)\n     {\n         TableScanNode tableScan = captures.get(TABLE_SCAN);\n \n-        long topNCount = node.getCount();\n-        List<SortItem> sortItems = node.getOrderingScheme().toSortItems();\n+        long topNCount = topNNode.getCount();\n+        List<SortItem> sortItems = topNNode.getOrderingScheme().toSortItems();\n \n         Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n                 .entrySet().stream()\n                 .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n \n-        Optional<TableHandle> result = metadata.applyTopN(\n-                context.getSession(),\n-                tableScan.getTable(),\n-                topNCount,\n-                sortItems,\n-                assignments);\n+        return metadata.applyTopN(context.getSession(), tableScan.getTable(), topNCount, sortItems, assignments)\n+                .map(result -> {\n+                    PlanNode node = TableScanNode.newInstance(\n+                            context.getIdAllocator().getNextId(),\n+                            result.getHandle(),\n+                            tableScan.getOutputSymbols(),\n+                            tableScan.getAssignments());\n \n-        if (result.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n-        return Result.ofPlanNode(\n-                        TableScanNode.newInstance(\n-                                context.getIdAllocator().getNextId(),\n-                                result.get(),\n-                                tableScan.getOutputSymbols(),\n-                                tableScan.getAssignments()));\n+                    if (!result.isTopNGuaranteed()) {\n+                        node = new TopNNode(topNNode.getId(), node, topNNode.getCount(), topNNode.getOrderingScheme(), TopNNode.Step.PARTIAL);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2MjYzMw==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r465362633", "bodyText": "Fixed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-08-04T22:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDk4MTgyOA==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r580981828", "bodyText": "Followed up here: #4249 (comment)", "author": "findepi", "createdAt": "2021-02-23T12:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxMjg2OQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "9c94323428ea17bd492b0e809456dc2b164ba009", "url": "https://github.com/trinodb/trino/commit/9c94323428ea17bd492b0e809456dc2b164ba009", "message": "Add support for TopN pushdown", "committedDate": "2020-08-05T03:40:07Z", "type": "commit"}, {"oid": "9c94323428ea17bd492b0e809456dc2b164ba009", "url": "https://github.com/trinodb/trino/commit/9c94323428ea17bd492b0e809456dc2b164ba009", "message": "Add support for TopN pushdown", "committedDate": "2020-08-05T03:40:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDk3NDA5NQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r580974095", "bodyText": "I think this should trigger no SINGLE step only.\nWe should not push partial and final separately (and IMO -- we should not push them at all)", "author": "findepi", "createdAt": "2021-02-23T11:52:56Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushTopNIntoTableScan.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortItem;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.topN;\n+\n+public class PushTopNIntoTableScan\n+        implements Rule<TopNNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<TopNNode> PATTERN = topN().with(source().matching(\n+            tableScan().capturedAs(TABLE_SCAN)));", "originalCommit": "9c94323428ea17bd492b0e809456dc2b164ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDk3ODY5OQ==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r580978699", "bodyText": "This should be added to pushIntoTableScanOptimizer, when other PushXxxIntoTableScan rules are registered.\nThis is important for two reasons:\n\nthis will unlock other pushdowns once TopN is pushed into TableScan fully\nthis will let the rule operate on TopNNode while it is SINGLE step (and consume it fully), making reasoning about engine-connector interactions simpler\n\n@wendigo is going to address this in #6847", "author": "findepi", "createdAt": "2021-02-23T12:00:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -623,7 +624,8 @@ public PlanOptimizers(\n                         new CreatePartialTopN(),\n                         new PushTopNThroughProject(),\n                         new PushTopNThroughOuterJoin(),\n-                        new PushTopNThroughUnion())));\n+                        new PushTopNThroughUnion(),\n+                        new PushTopNIntoTableScan(metadata))));", "originalCommit": "9c94323428ea17bd492b0e809456dc2b164ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDk4MDcwMg==", "url": "https://github.com/trinodb/trino/pull/4249#discussion_r580980702", "bodyText": "Relates  to #4249 (comment)\nInserting FINAL step is not correct when the rule triggered on TopNNode with Step PARTIAL.\nI suggest\n\nmake the rule trigger for SINGLE step only (my preferred)\n\ni am aware sibling PushLimitIntoTableScan triggers for partial limits, but i am not convinced it is beneficial\n\n\nkeep same step as it used to be used (basically, use topNNode.replaceChildren)\n\n(this is not being addressed in @wendigo #6847)", "author": "findepi", "createdAt": "2021-02-23T12:03:55Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushTopNIntoTableScan.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortItem;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.planner.plan.TopNNode;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static io.prestosql.sql.planner.plan.Patterns.topN;\n+\n+public class PushTopNIntoTableScan\n+        implements Rule<TopNNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<TopNNode> PATTERN = topN().with(source().matching(\n+            tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushTopNIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<TopNNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(TopNNode topNNode, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+\n+        long topNCount = topNNode.getCount();\n+        List<SortItem> sortItems = topNNode.getOrderingScheme().toSortItems();\n+\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Map.Entry::getValue));\n+\n+        return metadata.applyTopN(context.getSession(), tableScan.getTable(), topNCount, sortItems, assignments)\n+                .map(result -> {\n+                    PlanNode node = TableScanNode.newInstance(\n+                            context.getIdAllocator().getNextId(),\n+                            result.getHandle(),\n+                            tableScan.getOutputSymbols(),\n+                            tableScan.getAssignments());\n+\n+                    if (!result.isTopNGuaranteed()) {\n+                        node = new TopNNode(topNNode.getId(), node, topNNode.getCount(), topNNode.getOrderingScheme(), TopNNode.Step.FINAL);", "originalCommit": "9c94323428ea17bd492b0e809456dc2b164ba009", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}