{"pr_number": 5794, "pr_title": "Reuse immutable partition fields in Glue partition conversion", "pr_createdAt": "2020-11-03T12:56:24Z", "pr_url": "https://github.com/trinodb/trino/pull/5794", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NDY1NQ==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519064655", "bodyText": "Nit: No need to wrap here", "author": "electrum", "createdAt": "2020-11-07T00:14:29Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -728,7 +728,8 @@ public void dropColumn(HiveIdentity identity, String databaseName, String tableN\n                             .withDatabaseName(table.getDatabaseName())\n                             .withTableName(table.getTableName())\n                             .withPartitionValues(partitionValues)));\n-            return Optional.of(GlueToPrestoConverter.convertPartition(result.getPartition(), table.getParameters()));\n+            return Optional.of(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NTUzNA==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519065534", "bodyText": "We could keep this as toImmutableList(). Moving away from streams simply to pre-size the output list, in code that's already doing expensive RPC calls, is a hard sell from a code readability standpoint.", "author": "electrum", "createdAt": "2020-11-07T00:18:56Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -822,9 +827,11 @@ public void dropColumn(HiveIdentity identity, String databaseName, String tableN\n \n     private static List<String> buildPartitionNames(List<Column> partitionColumns, List<Partition> partitions)\n     {\n-        return partitions.stream()\n-                .map(partition -> makePartitionName(partitionColumns, partition.getValues()))\n-                .collect(toList());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkwMTM2NA==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519901364", "bodyText": "This one's a little tricky. It's not exactly the same \"memoization\" strategy as the rest of the PR, but it's attempting to reduce heap pressure when dealing with a large number of partitions just the same. Since buildPartitionNames is called from getPartitionNamesByFilter which might be requesting all partitions for table, the intermediate copies are material when the partition count is high.\nAssuming a JVM without compressed OOPs enabled:\n\n8 bytes per element in the list\ninitial capacity of 4 (for ImmutableList.builder(), 10 for ArrayList although Collectors.toList() won't trim the resulting list to size which can be a source of wasted heap)\n\nAt 1M partitions, that's 7.6MiB for the resulting list and:\n\n18 doubling copies meaning ~16MiB of allocations and copies as the builder grows\nOne final 7.6MiB copy since the result is not an exact power of 2\n\nSo ~7.6MiB instead of ~23.6MiB of allocation and copying by presizing the builder, a material improvement for only a minor stylistic difference.", "author": "pettyjamesm", "createdAt": "2020-11-09T15:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NTUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2NjcyNQ==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520166725", "bodyText": "That's a compelling argument -- let's keep it. One alternative idea would be to use\n.collect(toCollection(() -> new ArrayList(partitions.size()))", "author": "electrum", "createdAt": "2020-11-09T22:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NTUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2Njg5Mg==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519066892", "bodyText": "Import GluePartitionConverter so that it doesn't need to be qualified", "author": "electrum", "createdAt": "2020-11-07T00:25:46Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/GlueHiveMetastore.java", "diffHunk": "@@ -797,6 +798,9 @@ public void dropColumn(HiveIdentity identity, String databaseName, String tableN\n                 List<Partition> partitions = new ArrayList<>();\n                 String nextToken = null;\n \n+                // Reuse immutable field instances opportunistically between partitions\n+                GlueToPrestoConverter.GluePartitionConverter converter = new GlueToPrestoConverter.GluePartitionConverter(table);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2ODMwNQ==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519068305", "bodyText": "You could use a stream here", "author": "electrum", "createdAt": "2020-11-07T00:33:12Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -75,81 +76,166 @@ public static Table convertTable(com.amazonaws.services.glue.model.Table glueTab\n                 .setOwner(nullToEmpty(glueTable.getOwner()))\n                 // Athena treats missing table type as EXTERNAL_TABLE.\n                 .setTableType(firstNonNull(glueTable.getTableType(), EXTERNAL_TABLE.name()))\n-                .setDataColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n+                .setDataColumns(convertColumns(sd.getColumns()))\n                 .setParameters(tableParameters)\n                 .setViewOriginalText(Optional.ofNullable(glueTable.getViewOriginalText()))\n                 .setViewExpandedText(Optional.ofNullable(glueTable.getViewExpandedText()));\n \n         if (glueTable.getPartitionKeys() != null) {\n-            tableBuilder.setPartitionColumns(glueTable.getPartitionKeys().stream()\n-                    .map(GlueToPrestoConverter::convertColumn)\n-                    .collect(toImmutableList()));\n+            tableBuilder.setPartitionColumns(convertColumns(glueTable.getPartitionKeys()));\n         }\n         else {\n-            tableBuilder.setPartitionColumns(new ArrayList<>());\n+            tableBuilder.setPartitionColumns(ImmutableList.of());\n         }\n-\n-        setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n+        // No benefit to memoizing here, just reusing the implementation\n+        new StorageConverter().setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n         return tableBuilder.build();\n     }\n \n-    private static void setStorageBuilder(StorageDescriptor sd, Storage.Builder storageBuilder, Map<String, String> tableParameters)\n+    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n     {\n-        requireNonNull(sd.getSerdeInfo(), \"StorageDescriptor SerDeInfo is null\");\n-        SerDeInfo serdeInfo = sd.getSerdeInfo();\n+        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+    }\n \n-        Optional<HiveBucketProperty> bucketProperty = Optional.empty();\n-        if (sd.getNumberOfBuckets() > 0) {\n-            if (isNullOrEmpty(sd.getBucketColumns())) {\n-                throw new PrestoException(HIVE_INVALID_METADATA, \"Table/partition metadata has 'numBuckets' set, but 'bucketCols' is not set\");\n-            }\n-            List<SortingColumn> sortedBy = ImmutableList.of();\n-            if (!isNullOrEmpty(sd.getSortColumns())) {\n-                sortedBy = sd.getSortColumns().stream()\n-                        .map(column -> new SortingColumn(\n-                                column.getColumn(),\n-                                Order.fromMetastoreApiOrder(column.getSortOrder(), \"unknown\")))\n-                        .collect(toImmutableList());\n-            }\n-            BucketingVersion bucketingVersion = HiveBucketing.getBucketingVersion(tableParameters);\n-            bucketProperty = Optional.of(new HiveBucketProperty(sd.getBucketColumns(), bucketingVersion, sd.getNumberOfBuckets(), sortedBy));\n+    private static List<Column> convertColumns(List<com.amazonaws.services.glue.model.Column> glueColumns)\n+    {\n+        ImmutableList.Builder<Column> builder = ImmutableList.builderWithExpectedSize(glueColumns.size());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkwNTcyOA==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519905728", "bodyText": "You could, but for simple transformations like this that are relatively common and when the output list size is guaranteed to be known, I've found defaulting to a sized list to be preferable. See my reply about the buildPartitionNames case.\nObviously, 1M columns is much less likely than 1M partitions, but convertColumns is also performed within each partition conversion so the effect can be much more significant when the number of columns is non-trivial.", "author": "pettyjamesm", "createdAt": "2020-11-09T15:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2ODMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMjMwMA==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519932300", "bodyText": "So maybe we should improve io.prestosql.util.MoreLists#mappedCopy and make it more commonly used?", "author": "findepi", "createdAt": "2020-11-09T16:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2ODMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2NzQ1Mg==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520167452", "bodyText": "@findepi that's a good suggestion. We could do that here and have even more concise code than streams\nreturn mappedCopy(glueColumns, this::convertColumn);", "author": "electrum", "createdAt": "2020-11-09T22:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2ODMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4MTczOA==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520381738", "bodyText": "To be clear --  while i am concerned about conciseness, i am even more concerned about \"durability\" of the change.\nbuilder-based code can easily be later replaced with stream-based in a wholesale fashion. \"Improve readability\", \"Use JDK APIs for mapping lists\", etc can be compelling reason to merge such a change. Given we cannot test improvement proposed here, we need to find a non-test way to make it stay with us for longer.\nThus, using mappedCopy alone is not enough. We need to also adorn that method with some explanation why&where it is better than stream/map/list.", "author": "findepi", "createdAt": "2020-11-10T08:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2ODMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU2OTU0Nw==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520569547", "bodyText": "Added a comment in to the mappedCopy method explaining the presized builder.", "author": "pettyjamesm", "createdAt": "2020-11-10T13:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2ODMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2ODgzMw==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519068833", "bodyText": "Nit: format empty methods like\nprivate Memoizers() {}", "author": "electrum", "createdAt": "2020-11-07T00:36:09Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/util/Memoizers.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.util;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public final class Memoizers\n+{\n+    private Memoizers()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2OTUxNw==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519069517", "bodyText": "I think it would be cleaner to make these methods that return standard functional types\npublic static Function<T, T> memoizeLast() ...\n\npublic static Function<I, O> memoizeLast(Function<I, O> transform) ...\nRather than exposing the implementation classes in the usages", "author": "electrum", "createdAt": "2020-11-07T00:39:49Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/util/Memoizers.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.hive.metastore.util;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public final class Memoizers\n+{\n+    private Memoizers()\n+    {\n+    }\n+\n+    public static final class Simple<T>", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkwNjUwMg==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r519906502", "bodyText": "Done, except using UnaryOperator<T> for memoizeLast() to reduce the verbosity of type signatures.", "author": "pettyjamesm", "createdAt": "2020-11-09T15:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2OTUxNw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjQwNw==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520232407", "bodyText": "Make this private and put it at the end of the class (we put private methods at the end)", "author": "electrum", "createdAt": "2020-11-10T01:43:21Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -51,6 +53,16 @@\n \n     private GlueToPrestoConverter() {}\n \n+    public static <T, R> List<R> mappedCopy(List<T> list, Function<T, R> mapper)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4MjUwOQ==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520382509", "bodyText": "i'd rather see the existing io.prestosql.util.MoreLists#mappedCopy being improved & made reusable for hive connector.", "author": "findepi", "createdAt": "2020-11-10T08:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU0MzM4OQ==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520543389", "bodyText": "Currently doesn't seem like there are any good options. The presto-spi module intentionally avoids depending on Guava and isn't for utilities anyway, so there doesn't seem to be a good location to share the implementation from.", "author": "pettyjamesm", "createdAt": "2020-11-10T13:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU3OTE3Mg==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520579172", "bodyText": "We have some shared classes in presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/util\n(as the name suggests, this is not an ideal location, so once we have more of them, we can find a better home for them)", "author": "findepi", "createdAt": "2020-11-10T13:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MzQ2OA==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r522343468", "bodyText": "Having a few duplicated methods between connectors is preferable to presto-plugin-toolkit becoming a \"junk drawer\". There's a reason we don't have a generic util or common module in Presto. This is fine for now.", "author": "electrum", "createdAt": "2020-11-12T19:00:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjQ5Mw==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520232493", "bodyText": "I'd check this above, with the other check, since this line is already long", "author": "electrum", "createdAt": "2020-11-10T01:43:36Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -51,6 +53,16 @@\n \n     private GlueToPrestoConverter() {}\n \n+    public static <T, R> List<R> mappedCopy(List<T> list, Function<T, R> mapper)\n+    {\n+        requireNonNull(mapper, \"mapper is null\");\n+        ImmutableList.Builder<R> builder = ImmutableList.builderWithExpectedSize(requireNonNull(list, \"list is null\").size());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjYyMg==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520232622", "bodyText": "Nit: no need to wrap here", "author": "electrum", "createdAt": "2020-11-10T01:44:02Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -75,81 +87,162 @@ public static Table convertTable(com.amazonaws.services.glue.model.Table glueTab\n                 .setOwner(nullToEmpty(glueTable.getOwner()))\n                 // Athena treats missing table type as EXTERNAL_TABLE.\n                 .setTableType(firstNonNull(glueTable.getTableType(), EXTERNAL_TABLE.name()))\n-                .setDataColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n+                .setDataColumns(convertColumns(sd.getColumns()))\n                 .setParameters(tableParameters)\n                 .setViewOriginalText(Optional.ofNullable(glueTable.getViewOriginalText()))\n                 .setViewExpandedText(Optional.ofNullable(glueTable.getViewExpandedText()));\n \n         if (glueTable.getPartitionKeys() != null) {\n-            tableBuilder.setPartitionColumns(glueTable.getPartitionKeys().stream()\n-                    .map(GlueToPrestoConverter::convertColumn)\n-                    .collect(toImmutableList()));\n+            tableBuilder.setPartitionColumns(convertColumns(glueTable.getPartitionKeys()));\n         }\n         else {\n-            tableBuilder.setPartitionColumns(new ArrayList<>());\n+            tableBuilder.setPartitionColumns(ImmutableList.of());\n         }\n-\n-        setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n+        // No benefit to memoizing here, just reusing the implementation\n+        new StorageConverter().setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n         return tableBuilder.build();\n     }\n \n-    private static void setStorageBuilder(StorageDescriptor sd, Storage.Builder storageBuilder, Map<String, String> tableParameters)\n+    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n     {\n-        requireNonNull(sd.getSerdeInfo(), \"StorageDescriptor SerDeInfo is null\");\n-        SerDeInfo serdeInfo = sd.getSerdeInfo();\n-\n-        Optional<HiveBucketProperty> bucketProperty = Optional.empty();\n-        if (sd.getNumberOfBuckets() > 0) {\n-            if (isNullOrEmpty(sd.getBucketColumns())) {\n-                throw new PrestoException(HIVE_INVALID_METADATA, \"Table/partition metadata has 'numBuckets' set, but 'bucketCols' is not set\");\n-            }\n-            List<SortingColumn> sortedBy = ImmutableList.of();\n-            if (!isNullOrEmpty(sd.getSortColumns())) {\n-                sortedBy = sd.getSortColumns().stream()\n-                        .map(column -> new SortingColumn(\n-                                column.getColumn(),\n-                                Order.fromMetastoreApiOrder(column.getSortOrder(), \"unknown\")))\n-                        .collect(toImmutableList());\n-            }\n-            BucketingVersion bucketingVersion = HiveBucketing.getBucketingVersion(tableParameters);\n-            bucketProperty = Optional.of(new HiveBucketProperty(sd.getBucketColumns(), bucketingVersion, sd.getNumberOfBuckets(), sortedBy));\n-        }\n+        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+    }\n \n-        storageBuilder.setStorageFormat(StorageFormat.createNullable(serdeInfo.getSerializationLibrary(), sd.getInputFormat(), sd.getOutputFormat()))\n-                .setLocation(nullToEmpty(sd.getLocation()))\n-                .setBucketProperty(bucketProperty)\n-                .setSkewed(sd.getSkewedInfo() != null && !isNullOrEmpty(sd.getSkewedInfo().getSkewedColumnNames()))\n-                .setSerdeParameters(firstNonNull(serdeInfo.getParameters(), ImmutableMap.of()))\n-                .build();\n+    private static List<Column> convertColumns(List<com.amazonaws.services.glue.model.Column> glueColumns)\n+    {\n+        return mappedCopy(glueColumns, GlueToPrestoConverter::convertColumn);\n     }\n \n-    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n+    private static Map<String, String> convertParameters(Map<String, String> parameters)\n     {\n-        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+        if (parameters == null || parameters.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+        return ImmutableMap.copyOf(parameters);\n     }\n \n-    public static Partition convertPartition(com.amazonaws.services.glue.model.Partition gluePartition, Map<String, String> tableParameters)\n+    private static Function<Map<String, String>, Map<String, String>> parametersConverter()\n     {\n-        requireNonNull(gluePartition.getStorageDescriptor(), \"Partition StorageDescriptor is null\");\n-        StorageDescriptor sd = gluePartition.getStorageDescriptor();\n-\n-        Partition.Builder partitionBuilder = Partition.builder()\n-                .setDatabaseName(gluePartition.getDatabaseName())\n-                .setTableName(gluePartition.getTableName())\n-                .setValues(gluePartition.getValues())\n-                .setColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n-                .setParameters(firstNonNull(gluePartition.getParameters(), ImmutableMap.of()));\n-\n-        setStorageBuilder(sd, partitionBuilder.getStorageBuilder(), tableParameters);\n-        return partitionBuilder.build();\n+        return Memoizers.memoizeLast(GlueToPrestoConverter::convertParameters);\n     }\n \n     private static boolean isNullOrEmpty(List<?> list)\n     {\n         return list == null || list.isEmpty();\n     }\n+\n+    public static final class GluePartitionConverter\n+            implements Function<com.amazonaws.services.glue.model.Partition, Partition>\n+    {\n+        private final Function<List<com.amazonaws.services.glue.model.Column>, List<Column>> columnsConverter = Memoizers.memoizeLast(\n+                GlueToPrestoConverter::convertColumns);\n+        private final Function<Map<String, String>, Map<String, String>> parametersConverter = parametersConverter();\n+        private final StorageConverter storageConverter = new StorageConverter();\n+        private final String databaseName;\n+        private final String tableName;\n+        private final Map<String, String> tableParameters;\n+\n+        public GluePartitionConverter(Table table)\n+        {\n+            requireNonNull(table, \"table is null\");\n+            this.databaseName = requireNonNull(table.getDatabaseName(), \"databaseName is null\");\n+            this.tableName = requireNonNull(table.getTableName(), \"tableName is null\");\n+            this.tableParameters = convertParameters(table.getParameters());\n+        }\n+\n+        @Override\n+        public Partition apply(com.amazonaws.services.glue.model.Partition gluePartition)\n+        {\n+            requireNonNull(gluePartition.getStorageDescriptor(), \"Partition StorageDescriptor is null\");\n+            StorageDescriptor sd = gluePartition.getStorageDescriptor();\n+\n+            if (!databaseName.equals(gluePartition.getDatabaseName())) {\n+                throw new IllegalArgumentException(format(\"Unexpected databaseName, expected: %s, but found: %s\", databaseName, gluePartition.getDatabaseName()));\n+            }\n+            if (!tableName.equals(gluePartition.getTableName())) {\n+                throw new IllegalArgumentException(format(\"Unexpected tableName, expected: %s, but found: %s\", tableName, gluePartition.getTableName()));\n+            }\n+\n+            Partition.Builder partitionBuilder = Partition.builder()\n+                    .setDatabaseName(databaseName)\n+                    .setTableName(tableName)\n+                    .setValues(gluePartition.getValues()) // No memoization benefit\n+                    .setColumns(columnsConverter.apply(sd.getColumns()))\n+                    .setParameters(parametersConverter.apply(gluePartition.getParameters()));\n+\n+            storageConverter.setStorageBuilder(sd, partitionBuilder.getStorageBuilder(), tableParameters);\n+\n+            return partitionBuilder.build();\n+        }\n+    }\n+\n+    private static final class StorageConverter\n+    {\n+        private final Function<List<String>, List<String>> bucketColumns = Memoizers.memoizeLast(ImmutableList::copyOf);\n+        private final Function<List<com.amazonaws.services.glue.model.Order>, List<SortingColumn>> sortColumns = Memoizers.memoizeLast(\n+                StorageConverter::createSortingColumns);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjgyNg==", "url": "https://github.com/trinodb/trino/pull/5794#discussion_r520232826", "bodyText": "Static import memoizeLast", "author": "electrum", "createdAt": "2020-11-10T01:44:39Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/glue/converter/GlueToPrestoConverter.java", "diffHunk": "@@ -75,81 +87,162 @@ public static Table convertTable(com.amazonaws.services.glue.model.Table glueTab\n                 .setOwner(nullToEmpty(glueTable.getOwner()))\n                 // Athena treats missing table type as EXTERNAL_TABLE.\n                 .setTableType(firstNonNull(glueTable.getTableType(), EXTERNAL_TABLE.name()))\n-                .setDataColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n+                .setDataColumns(convertColumns(sd.getColumns()))\n                 .setParameters(tableParameters)\n                 .setViewOriginalText(Optional.ofNullable(glueTable.getViewOriginalText()))\n                 .setViewExpandedText(Optional.ofNullable(glueTable.getViewExpandedText()));\n \n         if (glueTable.getPartitionKeys() != null) {\n-            tableBuilder.setPartitionColumns(glueTable.getPartitionKeys().stream()\n-                    .map(GlueToPrestoConverter::convertColumn)\n-                    .collect(toImmutableList()));\n+            tableBuilder.setPartitionColumns(convertColumns(glueTable.getPartitionKeys()));\n         }\n         else {\n-            tableBuilder.setPartitionColumns(new ArrayList<>());\n+            tableBuilder.setPartitionColumns(ImmutableList.of());\n         }\n-\n-        setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n+        // No benefit to memoizing here, just reusing the implementation\n+        new StorageConverter().setStorageBuilder(sd, tableBuilder.getStorageBuilder(), tableParameters);\n         return tableBuilder.build();\n     }\n \n-    private static void setStorageBuilder(StorageDescriptor sd, Storage.Builder storageBuilder, Map<String, String> tableParameters)\n+    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n     {\n-        requireNonNull(sd.getSerdeInfo(), \"StorageDescriptor SerDeInfo is null\");\n-        SerDeInfo serdeInfo = sd.getSerdeInfo();\n-\n-        Optional<HiveBucketProperty> bucketProperty = Optional.empty();\n-        if (sd.getNumberOfBuckets() > 0) {\n-            if (isNullOrEmpty(sd.getBucketColumns())) {\n-                throw new PrestoException(HIVE_INVALID_METADATA, \"Table/partition metadata has 'numBuckets' set, but 'bucketCols' is not set\");\n-            }\n-            List<SortingColumn> sortedBy = ImmutableList.of();\n-            if (!isNullOrEmpty(sd.getSortColumns())) {\n-                sortedBy = sd.getSortColumns().stream()\n-                        .map(column -> new SortingColumn(\n-                                column.getColumn(),\n-                                Order.fromMetastoreApiOrder(column.getSortOrder(), \"unknown\")))\n-                        .collect(toImmutableList());\n-            }\n-            BucketingVersion bucketingVersion = HiveBucketing.getBucketingVersion(tableParameters);\n-            bucketProperty = Optional.of(new HiveBucketProperty(sd.getBucketColumns(), bucketingVersion, sd.getNumberOfBuckets(), sortedBy));\n-        }\n+        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+    }\n \n-        storageBuilder.setStorageFormat(StorageFormat.createNullable(serdeInfo.getSerializationLibrary(), sd.getInputFormat(), sd.getOutputFormat()))\n-                .setLocation(nullToEmpty(sd.getLocation()))\n-                .setBucketProperty(bucketProperty)\n-                .setSkewed(sd.getSkewedInfo() != null && !isNullOrEmpty(sd.getSkewedInfo().getSkewedColumnNames()))\n-                .setSerdeParameters(firstNonNull(serdeInfo.getParameters(), ImmutableMap.of()))\n-                .build();\n+    private static List<Column> convertColumns(List<com.amazonaws.services.glue.model.Column> glueColumns)\n+    {\n+        return mappedCopy(glueColumns, GlueToPrestoConverter::convertColumn);\n     }\n \n-    private static Column convertColumn(com.amazonaws.services.glue.model.Column glueColumn)\n+    private static Map<String, String> convertParameters(Map<String, String> parameters)\n     {\n-        return new Column(glueColumn.getName(), HiveType.valueOf(glueColumn.getType().toLowerCase(Locale.ENGLISH)), Optional.ofNullable(glueColumn.getComment()));\n+        if (parameters == null || parameters.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+        return ImmutableMap.copyOf(parameters);\n     }\n \n-    public static Partition convertPartition(com.amazonaws.services.glue.model.Partition gluePartition, Map<String, String> tableParameters)\n+    private static Function<Map<String, String>, Map<String, String>> parametersConverter()\n     {\n-        requireNonNull(gluePartition.getStorageDescriptor(), \"Partition StorageDescriptor is null\");\n-        StorageDescriptor sd = gluePartition.getStorageDescriptor();\n-\n-        Partition.Builder partitionBuilder = Partition.builder()\n-                .setDatabaseName(gluePartition.getDatabaseName())\n-                .setTableName(gluePartition.getTableName())\n-                .setValues(gluePartition.getValues())\n-                .setColumns(sd.getColumns().stream()\n-                        .map(GlueToPrestoConverter::convertColumn)\n-                        .collect(toImmutableList()))\n-                .setParameters(firstNonNull(gluePartition.getParameters(), ImmutableMap.of()));\n-\n-        setStorageBuilder(sd, partitionBuilder.getStorageBuilder(), tableParameters);\n-        return partitionBuilder.build();\n+        return Memoizers.memoizeLast(GlueToPrestoConverter::convertParameters);\n     }\n \n     private static boolean isNullOrEmpty(List<?> list)\n     {\n         return list == null || list.isEmpty();\n     }\n+\n+    public static final class GluePartitionConverter\n+            implements Function<com.amazonaws.services.glue.model.Partition, Partition>\n+    {\n+        private final Function<List<com.amazonaws.services.glue.model.Column>, List<Column>> columnsConverter = Memoizers.memoizeLast(\n+                GlueToPrestoConverter::convertColumns);\n+        private final Function<Map<String, String>, Map<String, String>> parametersConverter = parametersConverter();\n+        private final StorageConverter storageConverter = new StorageConverter();\n+        private final String databaseName;\n+        private final String tableName;\n+        private final Map<String, String> tableParameters;\n+\n+        public GluePartitionConverter(Table table)\n+        {\n+            requireNonNull(table, \"table is null\");\n+            this.databaseName = requireNonNull(table.getDatabaseName(), \"databaseName is null\");\n+            this.tableName = requireNonNull(table.getTableName(), \"tableName is null\");\n+            this.tableParameters = convertParameters(table.getParameters());\n+        }\n+\n+        @Override\n+        public Partition apply(com.amazonaws.services.glue.model.Partition gluePartition)\n+        {\n+            requireNonNull(gluePartition.getStorageDescriptor(), \"Partition StorageDescriptor is null\");\n+            StorageDescriptor sd = gluePartition.getStorageDescriptor();\n+\n+            if (!databaseName.equals(gluePartition.getDatabaseName())) {\n+                throw new IllegalArgumentException(format(\"Unexpected databaseName, expected: %s, but found: %s\", databaseName, gluePartition.getDatabaseName()));\n+            }\n+            if (!tableName.equals(gluePartition.getTableName())) {\n+                throw new IllegalArgumentException(format(\"Unexpected tableName, expected: %s, but found: %s\", tableName, gluePartition.getTableName()));\n+            }\n+\n+            Partition.Builder partitionBuilder = Partition.builder()\n+                    .setDatabaseName(databaseName)\n+                    .setTableName(tableName)\n+                    .setValues(gluePartition.getValues()) // No memoization benefit\n+                    .setColumns(columnsConverter.apply(sd.getColumns()))\n+                    .setParameters(parametersConverter.apply(gluePartition.getParameters()));\n+\n+            storageConverter.setStorageBuilder(sd, partitionBuilder.getStorageBuilder(), tableParameters);\n+\n+            return partitionBuilder.build();\n+        }\n+    }\n+\n+    private static final class StorageConverter\n+    {\n+        private final Function<List<String>, List<String>> bucketColumns = Memoizers.memoizeLast(ImmutableList::copyOf);\n+        private final Function<List<com.amazonaws.services.glue.model.Order>, List<SortingColumn>> sortColumns = Memoizers.memoizeLast(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "e64555d87950d72f2c50621f3a5cc4106fc5b56f", "url": "https://github.com/trinodb/trino/commit/e64555d87950d72f2c50621f3a5cc4106fc5b56f", "message": "Reuse immutable partition fields in Glue partition conversion\n\nWhen loading a large number of partitions from Glue (and\nespecially when storing the loaded values into a cache), partition\ninstances often share equivalent immutable field values (eg:\ntheir columns list) which can consume a large amount of\ncoordinator heap space.\n\nThis change enables opportunistic reuse of some partition fields\nby memoizing values during transformation and opportunistically\nreusing equivalent shared instances for consecutive converted\npartitions.", "committedDate": "2020-11-10T13:41:18Z", "type": "commit"}, {"oid": "e64555d87950d72f2c50621f3a5cc4106fc5b56f", "url": "https://github.com/trinodb/trino/commit/e64555d87950d72f2c50621f3a5cc4106fc5b56f", "message": "Reuse immutable partition fields in Glue partition conversion\n\nWhen loading a large number of partitions from Glue (and\nespecially when storing the loaded values into a cache), partition\ninstances often share equivalent immutable field values (eg:\ntheir columns list) which can consume a large amount of\ncoordinator heap space.\n\nThis change enables opportunistic reuse of some partition fields\nby memoizing values during transformation and opportunistically\nreusing equivalent shared instances for consecutive converted\npartitions.", "committedDate": "2020-11-10T13:41:18Z", "type": "forcePushed"}]}