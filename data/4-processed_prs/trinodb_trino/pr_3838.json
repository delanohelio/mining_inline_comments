{"pr_number": 3838, "pr_title": "Fix Oracle connector data type mappings", "pr_createdAt": "2020-05-23T22:38:48Z", "pr_url": "https://github.com/trinodb/trino/pull/3838", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMzOTcxMA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430339710", "bodyText": "why 3.. oracle default is 6.\nwe shouldn't carry a limitation of presto timestamp to oracle", "author": "eskabetxe", "createdAt": "2020-05-26T11:22:25Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -215,10 +213,10 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n             return WriteMapping.longMapping(\"number(19,0)\", bigintWriteFunction());\n         }\n         if (type instanceof TimestampType) {\n-            return WriteMapping.longMapping(format(\"timestamp(%s)\", timestampDefaultPrecision), timestampWriteFunction(session));\n+            return WriteMapping.longMapping(\"timestamp(3)\", timestampWriteFunction(session));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0Njg1Nw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430346857", "bodyText": "timestamp(6) will lead to incorrect results (different results when predicate is pushed down and when it is not)\nAnyway, this will be addressed soon the right way with the ongoing work at #1284", "author": "findepi", "createdAt": "2020-05-26T11:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMzOTcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM1MzA2NA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430353064", "bodyText": "so any table create outside presto will have that problem (it will be created as timestamp(6))", "author": "eskabetxe", "createdAt": "2020-05-26T11:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMzOTcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcwOTg4Mw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430709883", "bodyText": "correct", "author": "findepi", "createdAt": "2020-05-26T21:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMzOTcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyNDUyNw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431424527", "bodyText": "Predicate pushdown seems like an unrelated issue. It should work correctly regardless of the precision in Presto vs Oracle. We can't depend on the types matching.\nBut removing precision here and using timestamp(3) is the right behavior as that will continue working after we support precision for timestamp in Presto (timestamp will likely mean timestamp(3) for compatibility reasons).", "author": "electrum", "createdAt": "2020-05-27T20:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMzOTcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0MjM5OA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430342398", "bodyText": "the test of negative scale will be moved to another side?", "author": "eskabetxe", "createdAt": "2020-05-26T11:27:51Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -141,9 +141,9 @@ public void testBooleanType()\n     @Test\n     public void testSpecialNumberFormats()\n     {\n-        oracleServer.execute(\"CREATE TABLE test (num1 number, num2 number(*,-2))\");\n-        oracleServer.execute(\"INSERT INTO test VALUES (12345678901234567890.12345678901234567890123456789012345678, 1234567890.123)\");\n-        assertQuery(\"SELECT * FROM test\", \"VALUES (12345678901234567890.1234567890, 1234567900.0000000000)\");\n+        oracleServer.execute(\"CREATE TABLE test (num1 number)\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2NDE2OA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430964168", "bodyText": "There are tests for negative scale in testNumberNegativeScaleReadMapping.\nThis specific case which was tested here is not supported as it would require decimal precision of 40 in Presto, while up to 38 is supported.", "author": "losipiuk", "createdAt": "2020-05-27T08:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0MjM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2NjcwNA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431266704", "bodyText": "really not, as -2 will affect the first part..\nthis 1234567890 will be saved as 1234567900", "author": "eskabetxe", "createdAt": "2020-05-27T16:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0MjM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MjM4Mw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431452383", "bodyText": "The problem is that Oracle will allow for numbers with up to 38 meaningful digits for types with negative scale (in your example meaningful digits are 12345679).\nThe number of total digits (including obvious trailing zeroes) larger.\nE.g. for `NUMBER(*,-2) total number of digits in represented values can be 40.\nIf you run such query in Oracle:\nSELECT CAST(1234567890123456789012345678901234567890 AS NUMBER(*,-2)) FROM dual;\n\nIt will work fine and return 40 digit number 1234567890123456789012345678901234567900.\nAs we do not support negative scale in Presto, we need to be able to represent the value, including trailing zeroes. Hence the limitation.", "author": "losipiuk", "createdAt": "2020-05-27T21:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0MjM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r430347274", "bodyText": "starting on oracle 12c varchar could be increased from 4000 to 32767 bytes (any value between) using Extended Data Types", "author": "eskabetxe", "createdAt": "2020-05-26T11:38:05Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleConfig.java", "diffHunk": "@@ -68,17 +67,4 @@ public OracleConfig setNumberRoundingMode(RoundingMode numberRoundingMode)\n         this.numberRoundingMode = numberRoundingMode;\n         return this;\n     }\n-\n-    @Min(4000)\n-    public int getVarcharMaxSize()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyNTYzNQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431025635", "bodyText": "I reintroduced the config parameter. Just changed the name slightly, so it is obvious that limit is about number of bytes. Not characters.", "author": "losipiuk", "createdAt": "2020-05-27T10:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2Nzc2Ng==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431267766", "bodyText": "could be added the  @max(32767)", "author": "eskabetxe", "createdAt": "2020-05-27T16:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1NDA3MQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431454071", "bodyText": "Actually can it be something in between 4000 and 32767. Or just 4000 or 32767?\nIf latter is the case maybe we should make the config parameter oracle.enable-extended-datatypes=true/false?", "author": "losipiuk", "createdAt": "2020-05-27T21:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1ODA1Ng==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431658056", "bodyText": "@losipiuk the true/false may work, checking the documentation to activate that is used\nALTER SYSTEM SET max_string_size=extended SCOPE=SPFILE;\nthat change this values:\nVARCHAR2 : 4000 bytes\nNVARCHAR2 : 4000 bytes\nRAW : 2000 bytes\nto\nVARCHAR2 : 32767 bytes\nNVARCHAR2 : 32767 bytes\nRAW : 32767 bytes", "author": "eskabetxe", "createdAt": "2020-05-28T08:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc1ODE2Mw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431758163", "bodyText": "Why exactly do we have this setting? What would be the downside to having this hard-coded, at 4000 (safe value)?\n(since this isn't obvious, we should capture the reasoning in the code comment at least)\nIf desired, in the future, we could try to detect server configuration and adapt, without user needing to set anything.", "author": "findepi", "createdAt": "2020-05-28T11:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgwNDMyMQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431804321", "bodyText": "I kinda agree with what @findepi wrote. @eskabetxe do you feel strongly about the functionality and can provide rationale? If not I would simplify configuration (after all, the lest configuration switches the better) and live with 4000 for now.", "author": "losipiuk", "createdAt": "2020-05-28T12:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkxMTE3NA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431911174", "bodyText": "I updated the PR removing oracle.varchar2.max-bytes. We may discuss later on if we want to add it (in this or other form) as a followup.", "author": "losipiuk", "createdAt": "2020-05-28T15:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NTM4OQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r432065389", "bodyText": "@findepi  this allow you to use the extended data types added on 12c\nyou can use the hard-coded value, but if the database have the extended version activated and on creation for example you create a table with varchar (5000), the connector will create a nlob field (because 5000 > than 4000 limit)\nwe can address this after but this was already on connector, we are adding a limitation that previous not exists", "author": "eskabetxe", "createdAt": "2020-05-28T19:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyNTE0MQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r432325141", "bodyText": "I think we all understand what having a parameter changes in logic for CREATE TABLE issued from Presto to create Oracle table. The question is, is the benefit worth added complexity and extra configuration parameter. As @findepi mentioned above it can be improved to support higher limits without explicit configuration parameter. Also I believe that typical usecase for Oracle connector is to query tables created in Oracle already. Not to create new ones.", "author": "losipiuk", "createdAt": "2020-05-29T08:11:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM0NzI3NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMjM3MQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431422371", "bodyText": "This only leaves 36^5 = 60466176 maximum values. Also, the choice of this value seems arbitrary. We should probably have a maximum length and validate that the prefix+suffix is under the length. But we can follow up on that.", "author": "electrum", "createdAt": "2020-05-27T20:28:35Z", "path": "presto-testing/src/main/java/io/prestosql/testing/sql/TestTable.java", "diffHunk": "@@ -27,7 +27,7 @@\n         implements AutoCloseable\n {\n     private static final SecureRandom random = new SecureRandom();\n-    private static final int RANDOM_SUFFIX_LENGTH = 12;\n+    private static final int RANDOM_SUFFIX_LENGTH = 5;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyNzA3OA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431427078", "bodyText": "Use static import (that already exists)", "author": "electrum", "createdAt": "2020-05-27T20:37:41Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleDistributedQueries.java", "diffHunk": "@@ -115,7 +116,7 @@ protected TestTable createTableWithDefaultColumns()\n     {\n         return new TestTable(\n                 oracleServer::execute,\n-                \"tpch.table\",\n+                String.format(\"%s.table\", TEST_SCHEMA),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4Nzc4Mw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431487783", "bodyText": "Can we make this calendar instance a constant? They are mutable, but this should be read-only.", "author": "electrum", "createdAt": "2020-05-27T22:54:29Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -190,10 +212,77 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 return Optional.of(varcharColumnMapping(createVarcharType(columnSize)));\n             case Types.VARCHAR:\n                 return Optional.of(varcharColumnMapping(createVarcharType(columnSize)));\n+            // This mapping covers both DATE and TIMESTAMP, as Oracle's DATE has second precision.\n+            case OracleTypes.TIMESTAMP:\n+                return Optional.of(oracleTimestampColumnMapping(session));\n+            case OracleTypes.TIMESTAMPTZ:\n+                return Optional.of(oracleTimestampWithTimeZoneColumnMapping());\n         }\n         return super.toPrestoType(session, connection, typeHandle);\n     }\n \n+    public static LongWriteFunction oracleDateWriteFunction()\n+    {\n+        return (statement, index, value) -> {\n+            long utcMillis = DAYS.toMillis(value);\n+            ZonedDateTime date = Instant.ofEpochMilli(utcMillis).atZone(ZoneOffset.UTC);\n+            // because of how JDBC works with dates we need to use the ZonedDataTime object and not a LocalDateTime\n+            statement.setObject(index, date);\n+        };\n+    }\n+\n+    public static LongWriteFunction oracleTimestampWriteFunction(ConnectorSession session)\n+    {\n+        if (session.isLegacyTimestamp()) {\n+            return (statement, index, utcMillis) -> {\n+                long dateTimeAsUtcMillis = Instant.ofEpochMilli(utcMillis)\n+                        .atZone(ZoneId.of(session.getTimeZoneKey().getId()))\n+                        .withZoneSameLocal(ZoneOffset.UTC)\n+                        .toInstant().toEpochMilli();\n+                statement.setObject(index, new oracle.sql.TIMESTAMP(new Timestamp(dateTimeAsUtcMillis), Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"))));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5OTg3Ng==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431699876", "bodyText": "I would rather leave it as is.\nUnder the hood getTimeZone() is called which looks like this:\n    public TimeZone getTimeZone() {\n        if (this.sharedZone) {\n            this.zone = (TimeZone)this.zone.clone();\n            this.sharedZone = false;\n        }\n\n        return this.zone;\n    }\n\nIt kinda can mutate calendar state, even if it does not do it in our case as sharedZone==false. Yet it still looks fragile.\nAlso new oracle.sql.TIMESTAMP(...) caretes yet another calendar instance internally, so we are not gaining much by avoiding creation of our own :)", "author": "losipiuk", "createdAt": "2020-05-28T09:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4Nzc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5NzYzNg==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431797636", "bodyText": "Right, Calendar is mutable even when used \"read only\".", "author": "findepi", "createdAt": "2020-05-28T12:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4Nzc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODM3Ng==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431488376", "bodyText": "This seems repeated for no reason", "author": "electrum", "createdAt": "2020-05-27T22:56:10Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.oracle;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.testing.datatype.DataType;\n+\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static java.lang.String.format;\n+\n+public final class OracleDataTypes\n+{\n+    private OracleDataTypes() {}\n+\n+    /* Datetime types */\n+\n+    public static DataType<LocalDate> dateDataType()\n+    {\n+        return dataType(\"DATE\", TimestampType.TIMESTAMP,\n+                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n+                LocalDate::atStartOfDay);\n+    }\n+\n+    public static DataType<ZonedDateTime> prestoTimestampWithTimeZoneDataType()\n+    {\n+        return dataType(\n+                \"timestamp with time zone\",\n+                TIMESTAMP_WITH_TIME_ZONE,\n+                DateTimeFormatter.ofPattern(\"'TIMESTAMP '''yyyy-MM-dd HH:mm:ss.SSS VV''\")::format,\n+                OracleDataTypes::normalizeForOracleStorage);\n+    }\n+\n+    @SuppressWarnings(\"MisusedWeekYear\")\n+    public static DataType<ZonedDateTime> oracleTimestamp3TimeZoneDataType()\n+    {\n+        return dataType(\n+                \"TIMESTAMP(3) WITH TIME ZONE\",\n+                TIMESTAMP_WITH_TIME_ZONE,\n+                zonedDateTime -> {\n+                    String zoneId = zonedDateTime.getZone().getId();\n+                    if (zoneId.equals(\"Z\")) {\n+                        zoneId = \"UTC\";\n+                    }\n+                    return format(\n+                            \"from_tz(TIMESTAMP '%s', '%s')\",\n+                            DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSS\").format(zonedDateTime.toLocalDateTime()),\n+                            zoneId);\n+                },\n+                OracleDataTypes::normalizeForOracleStorage);\n+    }\n+\n+    private static ZonedDateTime normalizeForOracleStorage(ZonedDateTime zonedDateTime)\n+    {\n+        // Oracle conflates UTC-equivalent zones to UTC.\n+        String zoneId = zonedDateTime.getZone().getId();\n+        if (zoneId.equals(\"Z\")) {\n+            // Oracle conflates UTC-equivalent zones to UTC.", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODQ3OA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431488478", "bodyText": "Wrap all arguments or none", "author": "electrum", "createdAt": "2020-05-27T22:56:24Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.oracle;\n+\n+import io.prestosql.spi.type.TimestampType;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.testing.datatype.DataType;\n+\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.function.Function;\n+\n+import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static java.lang.String.format;\n+\n+public final class OracleDataTypes\n+{\n+    private OracleDataTypes() {}\n+\n+    /* Datetime types */\n+\n+    public static DataType<LocalDate> dateDataType()\n+    {\n+        return dataType(\"DATE\", TimestampType.TIMESTAMP,\n+                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n+                LocalDate::atStartOfDay);\n+    }\n+\n+    public static DataType<ZonedDateTime> prestoTimestampWithTimeZoneDataType()\n+    {\n+        return dataType(\n+                \"timestamp with time zone\",\n+                TIMESTAMP_WITH_TIME_ZONE,\n+                DateTimeFormatter.ofPattern(\"'TIMESTAMP '''yyyy-MM-dd HH:mm:ss.SSS VV''\")::format,\n+                OracleDataTypes::normalizeForOracleStorage);\n+    }\n+\n+    @SuppressWarnings(\"MisusedWeekYear\")\n+    public static DataType<ZonedDateTime> oracleTimestamp3TimeZoneDataType()\n+    {\n+        return dataType(\n+                \"TIMESTAMP(3) WITH TIME ZONE\",\n+                TIMESTAMP_WITH_TIME_ZONE,\n+                zonedDateTime -> {\n+                    String zoneId = zonedDateTime.getZone().getId();\n+                    if (zoneId.equals(\"Z\")) {\n+                        zoneId = \"UTC\";\n+                    }\n+                    return format(\n+                            \"from_tz(TIMESTAMP '%s', '%s')\",\n+                            DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSSSSS\").format(zonedDateTime.toLocalDateTime()),\n+                            zoneId);\n+                },\n+                OracleDataTypes::normalizeForOracleStorage);\n+    }\n+\n+    private static ZonedDateTime normalizeForOracleStorage(ZonedDateTime zonedDateTime)\n+    {\n+        // Oracle conflates UTC-equivalent zones to UTC.\n+        String zoneId = zonedDateTime.getZone().getId();\n+        if (zoneId.equals(\"Z\")) {\n+            // Oracle conflates UTC-equivalent zones to UTC.\n+            return zonedDateTime.withZoneSameInstant(ZoneId.of(\"UTC\"));\n+        }\n+        return zonedDateTime;\n+    }\n+\n+    /* Utility */\n+\n+    private static <T> DataType<T> dataType(String insertType, Type prestoResultType,\n+            Function<T, String> toLiteral, Function<T, ?> toPrestoQueryResult)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODc1OQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431488759", "bodyText": "Nit: s -> value", "author": "electrum", "createdAt": "2020-05-27T22:57:15Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcwNjAwMQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431706001", "bodyText": "Changed to more appropriate zone", "author": "losipiuk", "createdAt": "2020-05-28T09:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTAwMg==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431489002", "bodyText": "This is not a Javadoc comment, so don't use Javadoc tags", "author": "electrum", "createdAt": "2020-05-27T22:57:50Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));\n+    }\n+\n+    private void legacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    legacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcwNzY5Nw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431707697", "bodyText": "I dropped the comment. It was not valid any more.", "author": "losipiuk", "createdAt": "2020-05-28T09:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTA1OA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431489058", "bodyText": "Same", "author": "electrum", "createdAt": "2020-05-27T22:58:00Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));\n+    }\n+\n+    private void legacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    legacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private static DataTypeTest legacyDateTests()\n+    {\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateMapping()\n+    {\n+        nonLegacyDateTests(s -> prestoCreateAsSelect(\"nl_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateReadMapping()\n+    {\n+        nonLegacyDateTests(s -> oracleCreateAndInsert(\"nl_read_date_\" + s));\n+    }\n+\n+    void nonLegacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runNonLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    nonLegacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTM4MQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431489381", "bodyText": "Why? Add a TODO comment or remove these", "author": "electrum", "createdAt": "2020-05-27T22:59:03Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));\n+    }\n+\n+    private void legacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    legacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private static DataTypeTest legacyDateTests()\n+    {\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateMapping()\n+    {\n+        nonLegacyDateTests(s -> prestoCreateAsSelect(\"nl_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateReadMapping()\n+    {\n+        nonLegacyDateTests(s -> oracleCreateAndInsert(\"nl_read_date_\" + s));\n+    }\n+\n+    void nonLegacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runNonLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    nonLegacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private DataTypeTest nonLegacyDateTests()\n+    {\n+        // Note: these test cases are duplicates of those for PostgreSQL and MySQL.\n+\n+        LocalDate dateOfLocalTimeChangeForwardAtMidnightInJvmZone =\n+                LocalDate.of(1970, 1, 1);\n+\n+        verify(jvmZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeForwardAtMidnightInJvmZone\n+                        .atStartOfDay()).isEmpty());\n+\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeForwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 4, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeForwardAtMidnightInSomeZone\n+                        .atStartOfDay()).isEmpty());\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 1, 1))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeForwardAtMidnightInJvmZone)\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeForwardAtMidnightInSomeZone)\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test(dataProvider = \"testTimestampDataProvider\")\n+    public void testTimestamp(boolean legacyTimestamp, boolean insertWithPresto, ZoneId sessionZone)\n+    {\n+        // using two non-JVM zones so that we don't need to worry what Oracle system zone is\n+        DataTypeTest tests = DataTypeTest.create()\n+                .addRoundTrip(timestampDataType(), beforeEpoch)\n+                .addRoundTrip(timestampDataType(), afterEpoch)\n+                .addRoundTrip(timestampDataType(), timeDoubledInJvmZone)\n+                .addRoundTrip(timestampDataType(), timeDoubledInVilnius);\n+\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, epoch); // epoch also is a gap in JVM zone\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInJvmZone1);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInJvmZone2);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInVilnius);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInKathmandu);\n+\n+        Session session = Session.builder(getQueryRunner().getDefaultSession())\n+                .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(sessionZone.getId()))\n+                .setSystemProperty(\"legacy_timestamp\", Boolean.toString(legacyTimestamp))\n+                .build();\n+\n+        if (insertWithPresto) {\n+            tests.execute(getQueryRunner(), session, prestoCreateAsSelect(session, \"test_timestamp\"));\n+        }\n+        else {\n+            tests.execute(getQueryRunner(), session, oracleCreateAndInsert(\"test_timestamp\"));\n+        }\n+    }\n+\n+    private void addTimestampTestIfSupported(DataTypeTest tests, boolean legacyTimestamp, ZoneId sessionZone, LocalDateTime dateTime)\n+    {\n+        if (legacyTimestamp && isGap(sessionZone, dateTime)) {\n+            // in legacy timestamp semantics we cannot represent this dateTime\n+            return;\n+        }\n+\n+        tests.addRoundTrip(timestampDataType(), dateTime);\n+    }\n+\n+    @DataProvider\n+    public Object[][] testTimestampDataProvider()\n+    {\n+        return new Object[][] {\n+                {true, true, ZoneOffset.UTC},\n+                {false, true, ZoneOffset.UTC},\n+                {true, false, ZoneOffset.UTC},\n+                {false, false, ZoneOffset.UTC},\n+\n+                {true, true, jvmZone},\n+                {false, true, jvmZone},\n+                {true, false, jvmZone},\n+                {false, false, jvmZone},\n+\n+                // using two non-JVM zones so that we don't need to worry what Oracle system zone is\n+                {true, true, vilnius},\n+                {false, true, vilnius},\n+                {true, false, vilnius},\n+                {false, false, vilnius},\n+\n+                {true, true, kathmandu},\n+                {false, true, kathmandu},\n+                {true, false, kathmandu},\n+                {false, false, kathmandu},\n+\n+                {true, true, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {false, true, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {true, false, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {false, false, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testTimestampWithTimeZoneDataProvider\")\n+    public void testTimestampWithTimeZone(boolean insertWithPresto)\n+    {\n+        DataType<ZonedDateTime> dataType;\n+        DataSetup dataSetup;\n+        if (insertWithPresto) {\n+            dataType = prestoTimestampWithTimeZoneDataType();\n+            dataSetup = prestoCreateAsSelect(\"timestamp_tz\");\n+        }\n+        else {\n+            dataType = oracleTimestamp3TimeZoneDataType();\n+            dataSetup = oracleCreateAndInsert(\"timestamp_tz\");\n+        }\n+\n+        DataTypeTest tests = DataTypeTest.create()\n+                .addRoundTrip(dataType, epoch.atZone(UTC))\n+                .addRoundTrip(dataType, epoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, epoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, epoch.atZone(fixedOffsetWest))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(UTC))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(fixedOffsetWest))\n+                .addRoundTrip(dataType, afterEpoch.atZone(UTC))\n+                .addRoundTrip(dataType, afterEpoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, afterEpoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, afterEpoch.atZone(fixedOffsetWest))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"GMT\")))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTUzNg==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431489536", "bodyText": "Nit: no need to wrap here", "author": "electrum", "createdAt": "2020-05-27T22:59:35Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -153,12 +204,322 @@ public void testNumericTypes()\n                 queryResult);\n     }\n \n-    public static DataType<LocalDate> dateOracleType()\n+    /* Datetime tests */\n+\n+    @Test\n+    public void testLegacyDateMapping()\n     {\n-        return DataType.dataType(\n-                \"date\",\n-                TimestampType.TIMESTAMP,\n-                DateTimeFormatter.ofPattern(\"'DATE '''yyyy-MM-dd''\")::format,\n-                LocalDate::atStartOfDay);\n+        legacyDateTests(s -> prestoCreateAsSelect(\"l_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testLegacyDateReadMapping()\n+    {\n+        legacyDateTests(s -> oracleCreateAndInsert(\"l_read_date_\" + s));\n+    }\n+\n+    private void legacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    legacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private static DataTypeTest legacyDateTests()\n+    {\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateMapping()\n+    {\n+        nonLegacyDateTests(s -> prestoCreateAsSelect(\"nl_date_\" + s));\n+    }\n+\n+    @Test\n+    public void testNonLegacyDateReadMapping()\n+    {\n+        nonLegacyDateTests(s -> oracleCreateAndInsert(\"nl_read_date_\" + s));\n+    }\n+\n+    void nonLegacyDateTests(Function<String, DataSetup> dataSetup)\n+    {\n+        Map<String, TimeZoneKey> zonesBySqlName = ImmutableMap.of(\n+                \"UTC\", UTC_KEY,\n+                \"JVM\", getTimeZoneKey(ZoneId.systemDefault().getId()),\n+                \"other\", getTimeZoneKey(ZoneId.of(\"Europe/Vilnius\").getId()));\n+\n+        for (Map.Entry<String, TimeZoneKey> zone : zonesBySqlName.entrySet()) {\n+            runNonLegacyTimestampTestInZone(\n+                    dataSetup.apply(zone.getKey()),\n+                    zone.getValue().getId(),\n+                    nonLegacyDateTests());\n+        }\n+    }\n+\n+    /*\n+     * TODO These tests should be executed in {@link io.prestosql.Session Sessions}\n+     * configured for the JVM time zone, Europe/Vilnius, and UTC.\n+     */\n+    private DataTypeTest nonLegacyDateTests()\n+    {\n+        // Note: these test cases are duplicates of those for PostgreSQL and MySQL.\n+\n+        LocalDate dateOfLocalTimeChangeForwardAtMidnightInJvmZone =\n+                LocalDate.of(1970, 1, 1);\n+\n+        verify(jvmZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeForwardAtMidnightInJvmZone\n+                        .atStartOfDay()).isEmpty());\n+\n+        ZoneId someZone = ZoneId.of(\"Europe/Vilnius\");\n+\n+        LocalDate dateOfLocalTimeChangeForwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 4, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeForwardAtMidnightInSomeZone\n+                        .atStartOfDay()).isEmpty());\n+\n+        LocalDate dateOfLocalTimeChangeBackwardAtMidnightInSomeZone =\n+                LocalDate.of(1983, 10, 1);\n+\n+        verify(someZone.getRules().getValidOffsets(\n+                dateOfLocalTimeChangeBackwardAtMidnightInSomeZone\n+                        .atStartOfDay().minusMinutes(1)).size() == 2);\n+\n+        return DataTypeTest.create()\n+                // before epoch\n+                .addRoundTrip(dateDataType(), LocalDate.of(1952, 4, 3))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 1, 1))\n+                .addRoundTrip(dateDataType(), LocalDate.of(1970, 2, 3))\n+                // summer on northern hemisphere (possible DST)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 7, 1))\n+                // winter on northern hemisphere\n+                // (possible DST on southern hemisphere)\n+                .addRoundTrip(dateDataType(), LocalDate.of(2017, 1, 1))\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeForwardAtMidnightInJvmZone)\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeForwardAtMidnightInSomeZone)\n+                .addRoundTrip(dateDataType(),\n+                        dateOfLocalTimeChangeBackwardAtMidnightInSomeZone);\n+    }\n+\n+    @Test(dataProvider = \"testTimestampDataProvider\")\n+    public void testTimestamp(boolean legacyTimestamp, boolean insertWithPresto, ZoneId sessionZone)\n+    {\n+        // using two non-JVM zones so that we don't need to worry what Oracle system zone is\n+        DataTypeTest tests = DataTypeTest.create()\n+                .addRoundTrip(timestampDataType(), beforeEpoch)\n+                .addRoundTrip(timestampDataType(), afterEpoch)\n+                .addRoundTrip(timestampDataType(), timeDoubledInJvmZone)\n+                .addRoundTrip(timestampDataType(), timeDoubledInVilnius);\n+\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, epoch); // epoch also is a gap in JVM zone\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInJvmZone1);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInJvmZone2);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInVilnius);\n+        addTimestampTestIfSupported(tests, legacyTimestamp, sessionZone, timeGapInKathmandu);\n+\n+        Session session = Session.builder(getQueryRunner().getDefaultSession())\n+                .setTimeZoneKey(TimeZoneKey.getTimeZoneKey(sessionZone.getId()))\n+                .setSystemProperty(\"legacy_timestamp\", Boolean.toString(legacyTimestamp))\n+                .build();\n+\n+        if (insertWithPresto) {\n+            tests.execute(getQueryRunner(), session, prestoCreateAsSelect(session, \"test_timestamp\"));\n+        }\n+        else {\n+            tests.execute(getQueryRunner(), session, oracleCreateAndInsert(\"test_timestamp\"));\n+        }\n+    }\n+\n+    private void addTimestampTestIfSupported(DataTypeTest tests, boolean legacyTimestamp, ZoneId sessionZone, LocalDateTime dateTime)\n+    {\n+        if (legacyTimestamp && isGap(sessionZone, dateTime)) {\n+            // in legacy timestamp semantics we cannot represent this dateTime\n+            return;\n+        }\n+\n+        tests.addRoundTrip(timestampDataType(), dateTime);\n+    }\n+\n+    @DataProvider\n+    public Object[][] testTimestampDataProvider()\n+    {\n+        return new Object[][] {\n+                {true, true, ZoneOffset.UTC},\n+                {false, true, ZoneOffset.UTC},\n+                {true, false, ZoneOffset.UTC},\n+                {false, false, ZoneOffset.UTC},\n+\n+                {true, true, jvmZone},\n+                {false, true, jvmZone},\n+                {true, false, jvmZone},\n+                {false, false, jvmZone},\n+\n+                // using two non-JVM zones so that we don't need to worry what Oracle system zone is\n+                {true, true, vilnius},\n+                {false, true, vilnius},\n+                {true, false, vilnius},\n+                {false, false, vilnius},\n+\n+                {true, true, kathmandu},\n+                {false, true, kathmandu},\n+                {true, false, kathmandu},\n+                {false, false, kathmandu},\n+\n+                {true, true, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {false, true, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {true, false, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+                {false, false, ZoneId.of(TestingSession.DEFAULT_TIME_ZONE_KEY.getId())},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testTimestampWithTimeZoneDataProvider\")\n+    public void testTimestampWithTimeZone(boolean insertWithPresto)\n+    {\n+        DataType<ZonedDateTime> dataType;\n+        DataSetup dataSetup;\n+        if (insertWithPresto) {\n+            dataType = prestoTimestampWithTimeZoneDataType();\n+            dataSetup = prestoCreateAsSelect(\"timestamp_tz\");\n+        }\n+        else {\n+            dataType = oracleTimestamp3TimeZoneDataType();\n+            dataSetup = oracleCreateAndInsert(\"timestamp_tz\");\n+        }\n+\n+        DataTypeTest tests = DataTypeTest.create()\n+                .addRoundTrip(dataType, epoch.atZone(UTC))\n+                .addRoundTrip(dataType, epoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, epoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, epoch.atZone(fixedOffsetWest))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(UTC))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, beforeEpoch.atZone(fixedOffsetWest))\n+                .addRoundTrip(dataType, afterEpoch.atZone(UTC))\n+                .addRoundTrip(dataType, afterEpoch.atZone(kathmandu))\n+                .addRoundTrip(dataType, afterEpoch.atZone(fixedOffsetEast))\n+                .addRoundTrip(dataType, afterEpoch.atZone(fixedOffsetWest))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"GMT\")))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"UTC\")))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"Z\")))\n+//                .addRoundTrip(dataType, afterEpoch.atZone(ZoneId.of(\"UTC+00:00\")))\n+                .addRoundTrip(dataType, timeDoubledInJvmZone.atZone(UTC))\n+                .addRoundTrip(dataType, timeDoubledInJvmZone.atZone(jvmZone))\n+                .addRoundTrip(dataType, timeDoubledInJvmZone.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeDoubledInVilnius.atZone(UTC))\n+                .addRoundTrip(dataType, timeDoubledInVilnius.atZone(vilnius))\n+                .addRoundTrip(dataType, timeDoubledInVilnius.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeGapInJvmZone1.atZone(UTC))\n+                .addRoundTrip(dataType, timeGapInJvmZone1.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeGapInJvmZone2.atZone(UTC))\n+                .addRoundTrip(dataType, timeGapInJvmZone2.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeGapInVilnius.atZone(kathmandu))\n+                .addRoundTrip(dataType, timeGapInKathmandu.atZone(vilnius));\n+\n+        tests.execute(getQueryRunner(), dataSetup);\n+    }\n+\n+    @DataProvider\n+    public Object[][] testTimestampWithTimeZoneDataProvider()\n+    {\n+        return new Object[][] {\n+                {true},\n+                {false},\n+        };\n+    }\n+\n+    private DataSetup oracleCreateAndInsert(String tableNamePrefix)\n+    {\n+        return new CreateAndInsertDataSetup(\n+                getSqlExecutor(),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTAzNQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431491035", "bodyText": "This is confusing to read, add parens\nboolean precisionUnspecified = (columnSize + max(-typeHandle.getDecimalDigits(), 0)) == 127;", "author": "electrum", "createdAt": "2020-05-27T23:03:52Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -202,7 +203,8 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 if (scale == 0) {\n                     return Optional.of(bigintColumnMapping());\n                 }\n-                if (scale < 0 || scale > precision) {\n+                boolean precisionUnspecified = columnSize + max(-typeHandle.getDecimalDigits(), 0) == 127;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTYxNw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431491617", "bodyText": "Actually, I think this separate boolean makes it harder to read. I'd inline this\nif ((columnSize + max(-typeHandle.getDecimalDigits(), 0)) == 127) {\nOr split it out like\nint digits = columnSize + max(-typeHandle.getDecimalDigits(), 0);\nif (digits == 127) {", "author": "electrum", "createdAt": "2020-05-27T23:05:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MjY3NA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431492674", "bodyText": "Nit: redundant else", "author": "electrum", "createdAt": "2020-05-27T23:08:32Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -205,7 +205,12 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 }\n                 boolean precisionUnspecified = columnSize + max(-typeHandle.getDecimalDigits(), 0) == 127;\n                 if (precisionUnspecified) {\n-                    return Optional.of(decimalColumnMapping(createDecimalType(precision, numberDefaultScale), numberRoundingMode));\n+                    if (numberDefaultScale.isPresent()) {\n+                        return Optional.of(decimalColumnMapping(createDecimalType(precision, numberDefaultScale.get()), numberRoundingMode));\n+                    }\n+                    else {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzQ4Mw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431493483", "bodyText": "This can be replaced with\nreturn numberDefaultScale.map(scale -> decimalColumnMapping(createDecimalType(precision, scale), numberRoundingMode));\nOr\nreturn numberDefaultScale\n        .map(scale -> createDecimalType(precision, scale))\n        .map(type -> decimalColumnMapping(type, numberRoundingMode));", "author": "electrum", "createdAt": "2020-05-27T23:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MjY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDEwNQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431494105", "bodyText": "Can you add a test using assertFailsValidation() to verify that this works?", "author": "electrum", "createdAt": "2020-05-27T23:12:37Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleConfig.java", "diffHunk": "@@ -41,17 +43,16 @@ public OracleConfig setSynonymsEnabled(boolean enabled)\n         return this;\n     }\n \n-    @Min(0)\n-    @Max(38)\n-    public int getNumberDefaultScale()\n+    public Optional<@Min(0) @Max(38) Integer> getDefaultNumberScale()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDM3Ng==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431494376", "bodyText": "date -> data", "author": "electrum", "createdAt": "2020-05-27T23:13:27Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleConfig.java", "diffHunk": "@@ -41,17 +43,16 @@ public OracleConfig setSynonymsEnabled(boolean enabled)\n         return this;\n     }\n \n-    @Min(0)\n-    @Max(38)\n-    public int getNumberDefaultScale()\n+    public Optional<@Min(0) @Max(38) Integer> getDefaultNumberScale()\n     {\n-        return numberDefaultScale;\n+        return Optional.ofNullable(defaultNumberScale);\n     }\n \n     @Config(\"oracle.number.default-scale\")\n-    public OracleConfig setNumberDefaultScale(Integer numberDefaultScale)\n+    @ConfigDescription(\"Default Presto DECIMAL scale for Oracle NUMBER date type\")", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDU4NQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431494585", "bodyText": "We usually static import the session property getters", "author": "electrum", "createdAt": "2020-05-27T23:14:09Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -203,6 +199,8 @@ public void createSchema(JdbcIdentity identity, String schemaName)\n                 if (scale == 0) {\n                     return Optional.of(bigintColumnMapping());\n                 }\n+                RoundingMode numberRoundingMode = OracleSessionProperties.getNumberRoundingMode(session);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NDc5OA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431494798", "bodyText": "Nit: could shorten parameter to config", "author": "electrum", "createdAt": "2020-05-27T23:14:54Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleSessionProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.plugin.oracle;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.plugin.jdbc.SessionPropertiesProvider;\n+import io.prestosql.spi.connector.ConnectorSession;\n+import io.prestosql.spi.session.PropertyMetadata;\n+\n+import javax.inject.Inject;\n+\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static io.prestosql.spi.session.PropertyMetadata.enumProperty;\n+import static io.prestosql.spi.session.PropertyMetadata.integerProperty;\n+\n+public final class OracleSessionProperties\n+        implements SessionPropertiesProvider\n+{\n+    public static final String NUMBER_ROUNDING_MODE = \"number_rounding_mode\";\n+    public static final String NUMBER_DEFAULT_SCALE = \"number_default_scale\";\n+\n+    private final List<PropertyMetadata<?>> sessionProperties;\n+\n+    @Inject\n+    public OracleSessionProperties(OracleConfig oracleConfig)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5Njk4MQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431496981", "bodyText": "Wrap all arguments or none. (I wouldn't wrap here)", "author": "electrum", "createdAt": "2020-05-27T23:21:30Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -319,6 +337,14 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n                 return WriteMapping.sliceMapping(\"clob\", varcharWriteFunction());\n             }\n         }\n+        if (type instanceof DecimalType) {\n+            String dataType = format(\"number(%s, %s)\",\n+                    ((DecimalType) type).getPrecision(), ((DecimalType) type).getScale());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NzQ0OA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431497448", "bodyText": "Shouldn't this just be \"\\\\d\"? Or do \"[0-9]\"", "author": "electrum", "createdAt": "2020-05-27T23:23:02Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -17,19 +17,84 @@\n import io.prestosql.spi.type.Type;\n import io.prestosql.testing.datatype.DataType;\n \n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n import java.time.LocalDate;\n import java.time.ZoneId;\n import java.time.ZonedDateTime;\n import java.time.format.DateTimeFormatter;\n import java.util.function.Function;\n \n+import static io.prestosql.spi.type.DecimalType.createDecimalType;\n import static io.prestosql.spi.type.TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+import static java.lang.Math.max;\n import static java.lang.String.format;\n+import static java.math.RoundingMode.UNNECESSARY;\n \n public final class OracleDataTypes\n {\n     private OracleDataTypes() {}\n \n+    /* Fixed-point numeric types */\n+\n+    public static DataType<BigDecimal> unspecifiedNumberDataType(int expectedScaleInPresto)\n+    {\n+        return numberDataType(38, expectedScaleInPresto, \"number\");\n+    }\n+\n+    public static DataType<BigDecimal> numberDataType(int precision)\n+    {\n+        return numberDataType(precision, 0, format(\"number(%d)\", precision));\n+    }\n+\n+    /**\n+     * Create a number type using the same transformation as\n+     * OracleClient.toPrestoType to handle negative scale.\n+     */\n+    public static DataType<BigDecimal> numberDataType(int precision, int scale)\n+    {\n+        return numberDataType(precision, scale, format(\"number(%d, %d)\", precision, scale));\n+    }\n+\n+    private static DataType<BigDecimal> numberDataType(int precision, int scale, String oracleInsertType)\n+    {\n+        int prestoPrecision = precision + max(-scale, 0);\n+        int prestoScale = max(scale, 0);\n+        return dataType(\n+                oracleInsertType,\n+                createDecimalType(prestoPrecision, prestoScale),\n+                BigDecimal::toString,\n+                // Round to Oracle's scale if necessary, then return to the scale Presto will use.\n+                i -> i.setScale(scale, RoundingMode.HALF_UP).setScale(prestoScale));\n+    }\n+\n+    public static DataType<BigDecimal> oracleDecimalDataType(int precision, int scale)\n+    {\n+        String databaseType = format(\"decimal(%s, %s)\", precision, scale);\n+        return dataType(\n+                databaseType,\n+                createDecimalType(precision, scale),\n+                bigDecimal -> format(\"CAST(TO_NUMBER('%s', '%s') AS %s)\", bigDecimal.toPlainString(), toNumberFormatMask(bigDecimal), databaseType),\n+                bigDecimal -> bigDecimal.setScale(scale, UNNECESSARY));\n+    }\n+\n+    private static String toNumberFormatMask(BigDecimal bigDecimal)\n+    {\n+        return bigDecimal.toPlainString()\n+                .replace(\"-\", \"\")\n+                .replaceAll(\"[\\\\d]\", \"9\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMDI4Mw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431500283", "bodyText": "Nit: capitalize last AND", "author": "electrum", "createdAt": "2020-05-27T23:32:05Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleDistributedQueries.java", "diffHunk": "@@ -352,6 +352,17 @@ public void testShowColumns()\n                 format(\"%s does not matches %s\", actual, expectedParametrizedVarchar));\n     }\n \n+    @Override\n+    public void testInformationSchemaFiltering()\n+    {\n+        assertQuery(\n+                \"SELECT table_name FROM information_schema.tables WHERE table_name = 'orders' LIMIT 1\",\n+                \"SELECT 'orders' table_name\");\n+        assertQuery(\n+                \"SELECT table_name FROM information_schema.columns WHERE data_type = 'decimal(19,0)' AND table_name = 'customer' and column_name = 'custkey' LIMIT 1\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMDgyOA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431500828", "bodyText": "Nit: d -> value", "author": "electrum", "createdAt": "2020-05-27T23:33:39Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -95,6 +99,85 @@ private static String toNumberFormatMask(BigDecimal bigDecimal)\n         return dataType(\"boolean\", createDecimalType(1), Object::toString, value -> value ? BigDecimal.ONE : BigDecimal.ZERO);\n     }\n \n+    /* Floating point numeric types */\n+\n+    public static DataType<Double> binaryDoubleDataType()\n+    {\n+        return dataType(\"binary_double\", DoubleType.DOUBLE,\n+                value -> {\n+                    if (Double.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Double.isNaN(value)) {\n+                        return \"binary_double_nan\";\n+                    }\n+                    return format(\"%sbinary_double_infinity\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Float> binaryFloatDataType()\n+    {\n+        return dataType(\"binary_float\", RealType.REAL,\n+                value -> {\n+                    if (Float.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Float.isNaN(value)) {\n+                        return \"binary_float_nan\";\n+                    }\n+                    return format(\"%sbinary_float_infinity\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Double> doubleDataType()\n+    {\n+        return dataType(\"double\", DoubleType.DOUBLE,\n+                value -> {\n+                    if (Double.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Double.isNaN(value)) {\n+                        return \"nan()\";\n+                    }\n+                    return format(\"%sinfinity()\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Float> realDataType()\n+    {\n+        return dataType(\"real\", RealType.REAL,\n+                value -> {\n+                    if (Float.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Float.isNaN(value)) {\n+                        return \"nan()\";\n+                    }\n+                    return format(\"%sinfinity()\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType()\n+    {\n+        return oracleFloatDataType(Optional.empty());\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType(int precision)\n+    {\n+        return oracleFloatDataType(Optional.of(precision));\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType(Optional<Integer> precision)\n+    {\n+        String insertType = \"float\" + (precision.isPresent() ? format(\"(%s)\", precision.get()) : \"\");\n+        return dataType(insertType, DoubleType.DOUBLE,\n+                d -> {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMTA1MQ==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431501051", "bodyText": "precision.map(value -> format(\"(%s)\", value)).orElse(\"\")", "author": "electrum", "createdAt": "2020-05-27T23:34:21Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -95,6 +99,85 @@ private static String toNumberFormatMask(BigDecimal bigDecimal)\n         return dataType(\"boolean\", createDecimalType(1), Object::toString, value -> value ? BigDecimal.ONE : BigDecimal.ZERO);\n     }\n \n+    /* Floating point numeric types */\n+\n+    public static DataType<Double> binaryDoubleDataType()\n+    {\n+        return dataType(\"binary_double\", DoubleType.DOUBLE,\n+                value -> {\n+                    if (Double.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Double.isNaN(value)) {\n+                        return \"binary_double_nan\";\n+                    }\n+                    return format(\"%sbinary_double_infinity\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Float> binaryFloatDataType()\n+    {\n+        return dataType(\"binary_float\", RealType.REAL,\n+                value -> {\n+                    if (Float.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Float.isNaN(value)) {\n+                        return \"binary_float_nan\";\n+                    }\n+                    return format(\"%sbinary_float_infinity\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Double> doubleDataType()\n+    {\n+        return dataType(\"double\", DoubleType.DOUBLE,\n+                value -> {\n+                    if (Double.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Double.isNaN(value)) {\n+                        return \"nan()\";\n+                    }\n+                    return format(\"%sinfinity()\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Float> realDataType()\n+    {\n+        return dataType(\"real\", RealType.REAL,\n+                value -> {\n+                    if (Float.isFinite(value)) {\n+                        return value.toString();\n+                    }\n+                    if (Float.isNaN(value)) {\n+                        return \"nan()\";\n+                    }\n+                    return format(\"%sinfinity()\", value > 0 ? \"+\" : \"-\");\n+                });\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType()\n+    {\n+        return oracleFloatDataType(Optional.empty());\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType(int precision)\n+    {\n+        return oracleFloatDataType(Optional.of(precision));\n+    }\n+\n+    public static DataType<Double> oracleFloatDataType(Optional<Integer> precision)\n+    {\n+        String insertType = \"float\" + (precision.isPresent() ? format(\"(%s)\", precision.get()) : \"\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMTYzMA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431501630", "bodyText": "Fix wrapping", "author": "electrum", "createdAt": "2020-05-27T23:36:04Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/OracleDataTypes.java", "diffHunk": "@@ -150,4 +233,10 @@ private static ZonedDateTime normalizeForOracleStorage(ZonedDateTime zonedDateTi\n     {\n         return DataType.dataType(insertType, prestoResultType, toLiteral, toPrestoQueryResult);\n     }\n+\n+    private static <T> DataType<T> dataType(String insertType, Type prestoResultType,\n+            Function<T, String> toLiteral)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMTcyMg==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431501722", "bodyText": "Fix wrapping", "author": "electrum", "createdAt": "2020-05-27T23:36:20Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -376,6 +376,7 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n         if (writeMapping != null) {\n             return writeMapping;\n         }\n-        return super.toWriteMapping(session, type);\n+        throw new PrestoException(NOT_SUPPORTED,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMTk2Nw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431501967", "bodyText": "This would read better as\n// single UTF char may require up to 4 bytes of storage", "author": "electrum", "createdAt": "2020-05-27T23:37:09Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -101,11 +109,17 @@\n public class OracleClient\n         extends BaseJdbcClient\n {\n+    // single UTF char may require at most 4 bytes of storage", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMjM3OA==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431502378", "bodyText": "Nit: don't wrap here", "author": "electrum", "createdAt": "2020-05-27T23:38:31Z", "path": "presto-oracle/src/main/java/io/prestosql/plugin/oracle/OracleClient.java", "diffHunk": "@@ -350,16 +379,37 @@ public static DoubleWriteFunction oracleDoubleWriteFunction()\n         return ((statement, index, value) -> ((OraclePreparedStatement) statement).setBinaryDouble(index, value));\n     }\n \n+    private SliceWriteFunction oracleCharWriteFunction(CharType charType)\n+    {\n+        return (statement, index, value) -> {\n+            statement.setString(index, Chars.padSpaces(value, charType).toStringUtf8());\n+        };\n+    }\n+\n     @Override\n     public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n     {\n         if (isVarcharType(type)) {\n-            if (((VarcharType) type).isUnbounded()) {\n-                return super.toWriteMapping(session, createVarcharType(varcharMaxSize));\n+            String dataType;\n+            VarcharType varcharType = (VarcharType) type;\n+            if (varcharType.isUnbounded() ||", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwOTU5Mw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431509593", "bodyText": "The word \"converts\" here seems to be a mistake.", "author": "electrum", "createdAt": "2020-05-28T00:02:13Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -347,6 +351,35 @@ private static DataTypeTest unicodeTests(IntFunction<DataType<String>> typeConst\n                 .addRoundTrip(typeConstructor.apply(nonBmpLength + 5), nonBmpCharacter);\n     }\n \n+    /* Varbinary tests */\n+\n+    @Test\n+    public void testVarbinaryMapping()\n+    {\n+        testTypeMapping(\"varbinary\", varbinaryTests(varbinaryDataType()));\n+    }\n+\n+    @Test\n+    public void testVarbinaryReadMapping()\n+    {\n+        testTypeReadMapping(\"read_varbinary\",\n+                varbinaryTests(blobDataType())\n+                        .addRoundTrip(blobDataType(), new byte[] {}),\n+                varbinaryTests(rawDataType(2000)));\n+        // The test with the empty array is read-only because Oracle converts treats", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxMDIwNg==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431510206", "bodyText": "What happens for CONVERT_TO_VARCHAR or jdbc-types-mapped-to-varchar?", "author": "electrum", "createdAt": "2020-05-28T00:04:12Z", "path": "presto-oracle/src/test/java/io/prestosql/plugin/oracle/TestOracleTypes.java", "diffHunk": "@@ -842,6 +842,36 @@ public void testTimestampWithTimeZone(boolean insertWithPresto)\n         };\n     }\n \n+    /* Unsupported type tests */\n+\n+    @Test\n+    public void testUnsupportedBasicType()\n+    {\n+        testUnsupportedOracleType(\"BFILE\"); // Never in mapping", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc3MDM1Mw==", "url": "https://github.com/trinodb/trino/pull/3838#discussion_r431770353", "bodyText": "It does not work with BFILE. Actually if one enables CONVERT_TO_VARCHAR and tries to read from table containing BFILE column, the query will fail because resultSet.getString(columnIndex) here would return null. And that is not supported.\nThe mapping of unsupported numbers to varchar is already tested in testHighNumberScale and others.\nIt could be improved but let's do that as a followup.", "author": "losipiuk", "createdAt": "2020-05-28T11:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxMDIwNg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "090e188f2c1c7d1435164db16100f4ce1be9232b", "url": "https://github.com/trinodb/trino/commit/090e188f2c1c7d1435164db16100f4ce1be9232b", "message": "Make random suffix for test tables shorter\n\nLong random suffix does not play well with limits on length of identifiers\npresent in some databases (e.g. Oracle 11).", "committedDate": "2020-05-28T12:08:52Z", "type": "commit"}, {"oid": "f2baf62836b069862e494118fa49bb841f40f80c", "url": "https://github.com/trinodb/trino/commit/f2baf62836b069862e494118fa49bb841f40f80c", "message": "Drop oracle.timestamp.precision configuration parameter\n\nTimestamp precision is currently a work in progress and soon will be\naddressed engine-wide.", "committedDate": "2020-05-28T12:08:53Z", "type": "commit"}, {"oid": "79057b5a3bf451e694e76213cc92d191b4632a7e", "url": "https://github.com/trinodb/trino/commit/79057b5a3bf451e694e76213cc92d191b4632a7e", "message": "Cleanup Oracle test user and schema setup", "committedDate": "2020-05-28T12:08:54Z", "type": "commit"}, {"oid": "712e26341f0775dbc0f656c4b62533e0192dacfc", "url": "https://github.com/trinodb/trino/commit/712e26341f0775dbc0f656c4b62533e0192dacfc", "message": "Fix type mappings for temporal data types", "committedDate": "2020-05-28T12:08:55Z", "type": "commit"}, {"oid": "b4153f3ba4ade6c75fbb70b3658ce9d939b7d256", "url": "https://github.com/trinodb/trino/commit/b4153f3ba4ade6c75fbb70b3658ce9d939b7d256", "message": "Do not fall through to BaseJDBC type mapping", "committedDate": "2020-05-28T12:08:56Z", "type": "commit"}, {"oid": "30b5979043540fa38d77d81d4a10c5f0dcb9e360", "url": "https://github.com/trinodb/trino/commit/30b5979043540fa38d77d81d4a10c5f0dcb9e360", "message": "Use default number scale only if unspecified in Oracle", "committedDate": "2020-05-28T12:08:57Z", "type": "commit"}, {"oid": "a438ba5d2e114b54b4048c48cc620624c7bf849d", "url": "https://github.com/trinodb/trino/commit/a438ba5d2e114b54b4048c48cc620624c7bf849d", "message": "Make oracle.number.default-scale optional", "committedDate": "2020-05-28T12:08:58Z", "type": "commit"}, {"oid": "3e9d45db7e1901a980c0a3bdacc79c353b27d584", "url": "https://github.com/trinodb/trino/commit/3e9d45db7e1901a980c0a3bdacc79c353b27d584", "message": "Expose rounding mode and default scale as session properties", "committedDate": "2020-05-28T12:09:00Z", "type": "commit"}, {"oid": "fe3dd7c5693b534d5cbb9959eac027b003bb6d96", "url": "https://github.com/trinodb/trino/commit/fe3dd7c5693b534d5cbb9959eac027b003bb6d96", "message": "Fix type mappings for numeric data types", "committedDate": "2020-05-28T12:09:01Z", "type": "commit"}, {"oid": "6dad049892c45e497153af311f987a1601e6b38d", "url": "https://github.com/trinodb/trino/commit/6dad049892c45e497153af311f987a1601e6b38d", "message": "Fix type mappings for floating point number types", "committedDate": "2020-05-28T12:09:02Z", "type": "commit"}, {"oid": "7741ce44457dd5cb40f05930d1c03a6010576736", "url": "https://github.com/trinodb/trino/commit/7741ce44457dd5cb40f05930d1c03a6010576736", "message": "Do not fall through to BaseJDBC write mappings", "committedDate": "2020-05-28T12:09:03Z", "type": "commit"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "225e1af3ce6797996a42d30fe949ea6ca820078f", "url": "https://github.com/trinodb/trino/commit/225e1af3ce6797996a42d30fe949ea6ca820078f", "message": "Fix type mappings for character types", "committedDate": "2020-05-28T14:59:13Z", "type": "commit"}, {"oid": "b06e4dd7f410c14e7906de7323decd7044ee2317", "url": "https://github.com/trinodb/trino/commit/b06e4dd7f410c14e7906de7323decd7044ee2317", "message": "Remove obsolete character type mapping test", "committedDate": "2020-05-28T14:59:13Z", "type": "commit"}, {"oid": "3aeb7fb81e2dcdf0b8a3ed1125d87c32fba4436e", "url": "https://github.com/trinodb/trino/commit/3aeb7fb81e2dcdf0b8a3ed1125d87c32fba4436e", "message": "Fix type mappings for binary types", "committedDate": "2020-05-28T14:59:13Z", "type": "commit"}, {"oid": "fe3106b179563ac524a8c2641f18001345b932f5", "url": "https://github.com/trinodb/trino/commit/fe3106b179563ac524a8c2641f18001345b932f5", "message": "Add tests for unsupported Oracle types", "committedDate": "2020-05-28T14:59:13Z", "type": "commit"}, {"oid": "878a24649562e3fb01ab6b07da73f9bbc643c9f9", "url": "https://github.com/trinodb/trino/commit/878a24649562e3fb01ab6b07da73f9bbc643c9f9", "message": "Use UNNECESSARY as default rounding mode\n\nMajor motivation for the change is fact that UNNECESSARY rounding mode\nis more conservative (safer) than HALF_UP.", "committedDate": "2020-05-28T14:59:13Z", "type": "commit"}, {"oid": "878a24649562e3fb01ab6b07da73f9bbc643c9f9", "url": "https://github.com/trinodb/trino/commit/878a24649562e3fb01ab6b07da73f9bbc643c9f9", "message": "Use UNNECESSARY as default rounding mode\n\nMajor motivation for the change is fact that UNNECESSARY rounding mode\nis more conservative (safer) than HALF_UP.", "committedDate": "2020-05-28T14:59:13Z", "type": "forcePushed"}]}