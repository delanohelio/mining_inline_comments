{"pr_number": 4942, "pr_title": "Dynamic filtering for semi-joins: planner", "pr_createdAt": "2020-08-23T23:47:07Z", "pr_url": "https://github.com/trinodb/trino/pull/4942", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ5MjMwNg==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475492306", "bodyText": "make it conditional, e.g:\nif (!node.getDynamicFilterId().isPresent()) {\n  return visitPlan(node, allowedDynamicFilterIds);\n}\n\nDynamicFilterId filterId = node.getDynamicFilterId().get()", "author": "sopel39", "createdAt": "2020-08-24T10:12:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/RemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -184,6 +187,58 @@ public PlanWithConsumedDynamicFilters visitSpatialJoin(SpatialJoinNode node, Set\n             return new PlanWithConsumedDynamicFilters(node, consumed);\n         }\n \n+        @Override\n+        public PlanWithConsumedDynamicFilters visitSemiJoin(SemiJoinNode node, Set<DynamicFilterId> allowedDynamicFilterIds)\n+        {\n+            Optional<DynamicFilterId> dynamicFilterId = node.getDynamicFilterId();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ5NTMxNg==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475495316", "bodyText": "do something similar as we do for visitJoin:\nSet<DynamicFilterId> consumed = new HashSet<>(filteringSourceResult.getConsumedDynamicFilterIds());\nconsumed.addAll(sourceResult.getConsumedDynamicFilterIds());\nOptional<DynamicFilterId> newFilterId;\nif (consumed.contains(filterId)) {\n  consumed.remove(filterId);\n  newFilterId = Optional.of(filterId);\n} else {\n  newFilterId = Optional.empty();\n}", "author": "sopel39", "createdAt": "2020-08-24T10:18:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/RemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -184,6 +187,58 @@ public PlanWithConsumedDynamicFilters visitSpatialJoin(SpatialJoinNode node, Set\n             return new PlanWithConsumedDynamicFilters(node, consumed);\n         }\n \n+        @Override\n+        public PlanWithConsumedDynamicFilters visitSemiJoin(SemiJoinNode node, Set<DynamicFilterId> allowedDynamicFilterIds)\n+        {\n+            Optional<DynamicFilterId> dynamicFilterId = node.getDynamicFilterId();\n+\n+            Set<DynamicFilterId> allowedDynamicFilterIdsSourceSide = dynamicFilterId.isEmpty() ?\n+                    allowedDynamicFilterIds :\n+                    ImmutableSet.<DynamicFilterId>builder()\n+                            .add(dynamicFilterId.get())\n+                            .addAll(allowedDynamicFilterIds)\n+                            .build();\n+            PlanWithConsumedDynamicFilters sourceResult = node.getSource().accept(this, allowedDynamicFilterIdsSourceSide);\n+            PlanWithConsumedDynamicFilters filteringSourceResult = node.getFilteringSource().accept(this, allowedDynamicFilterIds);\n+\n+            Set<DynamicFilterId> consumedSourceSide = sourceResult.getConsumedDynamicFilterIds();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUwNzg3MQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475507871", "bodyText": "Let's inline DF creation.\nOptional<DynamicFilterId> filterId = node.getDynamicFilterId();\nif (!filterId.isPresent() && isEnableDynamicFiltering(session) && dynamicFiltering) {\n  filterId = Optional.of(new DynamicFilterId(\"df_\" + idAllocator.getNextId().toString()));\n  Symbol sourceSymbol = node.getSourceJoinSymbol();\n  sourceConjuncts.add(createDynamicFilterExpression(metadata, filterId.get(), symbolAllocator.getTypes().get(sourceSymbol), sourceSymbol.toSymbolReference())\n}", "author": "sopel39", "createdAt": "2020-08-24T10:34:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -1262,6 +1277,15 @@ private PlanNode visitFilteringSemiJoin(SemiJoinNode node, RewriteContext<Expres\n             sourceConjuncts.addAll(allInferenceWithoutSourceInferred.generateEqualitiesPartitionedBy(sourceScope).getScopeEqualities());\n             filteringSourceConjuncts.addAll(allInferenceWithoutFilteringSourceInferred.generateEqualitiesPartitionedBy(filterScope).getScopeEqualities());\n \n+            // Add dynamic filtering predicate\n+            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, session, idAllocator);\n+            Optional<DynamicFilterId> dynamicFilterId = Optional.empty();\n+            List<Expression> dynamicFilteringPredicates = dynamicFiltersResult.getPredicates();\n+            if (!dynamicFilteringPredicates.isEmpty()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUwOTEzOQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475509139", "bodyText": "let's be explicit here and also check in if below whether dynamic filter changed:\n|| !newFilterId.equals(node.getDynamicFilterId())", "author": "sopel39", "createdAt": "2020-08-24T10:36:25Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -1262,6 +1277,15 @@ private PlanNode visitFilteringSemiJoin(SemiJoinNode node, RewriteContext<Expres\n             sourceConjuncts.addAll(allInferenceWithoutSourceInferred.generateEqualitiesPartitionedBy(sourceScope).getScopeEqualities());\n             filteringSourceConjuncts.addAll(allInferenceWithoutFilteringSourceInferred.generateEqualitiesPartitionedBy(filterScope).getScopeEqualities());\n \n+            // Add dynamic filtering predicate\n+            DynamicFiltersResult dynamicFiltersResult = createDynamicFilters(node, session, idAllocator);\n+            Optional<DynamicFilterId> dynamicFilterId = Optional.empty();\n+            List<Expression> dynamicFilteringPredicates = dynamicFiltersResult.getPredicates();\n+            if (!dynamicFilteringPredicates.isEmpty()) {\n+                sourceConjuncts.addAll(dynamicFilteringPredicates);\n+                dynamicFilterId = Optional.of(getOnlyElement(dynamicFiltersResult.getDynamicFilters().keySet()));\n+            }\n+\n             PlanNode rewrittenSource = context.rewrite(node.getSource(), combineConjuncts(metadata, sourceConjuncts));\n             PlanNode rewrittenFilteringSource = context.rewrite(node.getFilteringSource(), combineConjuncts(metadata, filteringSourceConjuncts));\n ", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMzIxMQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475513211", "bodyText": "this method is not really needed. We can inline logic in visitFilteringSemiJoin (see my comment there)", "author": "sopel39", "createdAt": "2020-08-24T10:45:21Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -597,6 +598,20 @@ private DynamicFiltersResult createDynamicFilters(JoinNode node, List<JoinNode.E\n             return new DynamicFiltersResult(dynamicFilters, predicates);\n         }\n \n+        private DynamicFiltersResult createDynamicFilters(SemiJoinNode node, Session session, PlanNodeIdAllocator idAllocator)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxOTE1NQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475519155", "bodyText": "move it below\nnode.getDistributionType().ifPresent(distributionType -> nodeOutput.appendDetailsLine(\"Distribution: %s\", distributionType));\n\nline\nCould you share EXPLAIN to see how it looks?", "author": "sopel39", "createdAt": "2020-08-24T10:57:59Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/planprinter/PlanPrinter.java", "diffHunk": "@@ -451,6 +451,7 @@ public Void visitSemiJoin(SemiJoinNode node, Void context)\n             node.getDistributionType().ifPresent(distributionType -> nodeOutput.appendDetailsLine(\"Distribution: %s\", distributionType));\n             node.getSource().accept(this, context);\n             node.getFilteringSource().accept(this, context);\n+            node.getDynamicFilterId().ifPresent(dynamicFilterId -> nodeOutput.appendDetailsLine(\"dynamicFilterId: %s\", dynamicFilterId));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2NTUzMA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476165530", "bodyText": "\u2514\u2500 SemiJoin[ss_sold_date_sk = d_date_sk][$hashvalue, $hashvalue_0]                                                                                                                                \n           \u2502   Layout: [ss_sold_date_sk:bigint, ss_promo_sk:bigint, $hashvalue:bigint, expr:boolean]                                                                                                      \n           \u2502   Estimates: {rows: 120527 (3.25MB), cpu: 15.92M, memory: 545B, network: 545B}                                                                                                               \n           \u2502   Distribution: REPLICATED                                                                                                                                                                   \n           \u2502   dynamicFilterId: df_439", "author": "lxynov", "createdAt": "2020-08-25T04:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxOTE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxOTg0Nw==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475519847", "bodyText": "replace semijoin with semi-join", "author": "sopel39", "createdAt": "2020-08-24T10:59:30Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/DynamicFiltersChecker.java", "diffHunk": "@@ -98,6 +100,25 @@ public void validate(PlanNode plan, Session session, Metadata metadata, TypeAnal\n                 return ImmutableSet.copyOf(unmatched);\n             }\n \n+            @Override\n+            public Set<DynamicFilterId> visitSemiJoin(SemiJoinNode node, Void context)\n+            {\n+                Set<DynamicFilterId> consumedSourceSide = node.getSource().accept(this, context);\n+                Set<DynamicFilterId> consumedFilteringSourceSide = node.getFilteringSource().accept(this, context);\n+                if (node.getDynamicFilterId().isPresent()) {\n+                    DynamicFilterId dynamicFilterId = node.getDynamicFilterId().get();\n+                    verify(consumedSourceSide.contains(dynamicFilterId),\n+                            \"The dynamic filter %s present in semijoin was not consumed by it's source side.\", dynamicFilterId);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMDc4MQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475520781", "bodyText": "use something similar as for visitJoin:\nSet<DynamicFilterId> unmatched = new HashSet<>(consumedBuildSide);\nunmatched.addAll(consumedProbeSide);\nnode.getDynamicFilterId().ifPresent(unmatched::remove);\nreturn ImmutableSet.copyOf(unmatched);", "author": "sopel39", "createdAt": "2020-08-24T11:01:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/DynamicFiltersChecker.java", "diffHunk": "@@ -98,6 +100,25 @@ public void validate(PlanNode plan, Session session, Metadata metadata, TypeAnal\n                 return ImmutableSet.copyOf(unmatched);\n             }\n \n+            @Override\n+            public Set<DynamicFilterId> visitSemiJoin(SemiJoinNode node, Void context)\n+            {\n+                Set<DynamicFilterId> consumedSourceSide = node.getSource().accept(this, context);\n+                Set<DynamicFilterId> consumedFilteringSourceSide = node.getFilteringSource().accept(this, context);\n+                if (node.getDynamicFilterId().isPresent()) {\n+                    DynamicFilterId dynamicFilterId = node.getDynamicFilterId().get();\n+                    verify(consumedSourceSide.contains(dynamicFilterId),\n+                            \"The dynamic filter %s present in semijoin was not consumed by it's source side.\", dynamicFilterId);\n+                    verify(!consumedFilteringSourceSide.contains(dynamicFilterId),\n+                            \"The dynamic filter %s present in semijoin was consumed by it's filtering source side.\", dynamicFilterId);\n+                    consumedSourceSide = consumedSourceSide.stream().filter(id -> !id.equals(dynamicFilterId)).collect(toImmutableSet());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyNTMwMA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475525300", "bodyText": "each arg in newline", "author": "sopel39", "createdAt": "2020-08-24T11:11:21Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/AbstractPredicatePushdownTest.java", "diffHunk": "@@ -122,11 +123,15 @@ public void testNonDeterministicPredicateDoesNotPropagateFromFilteringSideToSour\n     {\n         assertPlan(\"SELECT * FROM lineitem WHERE orderkey IN (SELECT orderkey FROM orders WHERE orderkey = random(5))\",\n                 anyTree(\n-                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\",\n-                                // NO filter here\n-                                project(\n-                                        tableScan(\"lineitem\", ImmutableMap.of(\n-                                                \"LINE_ORDER_KEY\", \"orderkey\"))),\n+                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\", Optional.empty(), enableDynamicFiltering,\n+                                enableDynamicFiltering ?\n+                                        anyTree(\n+                                                tableScan(\"lineitem\", ImmutableMap.of(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzMzU5Ng==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475533596", "bodyText": "introduce another semiJoin with just hasDynamicFilter so that we can avoid passing Optional.empty().", "author": "sopel39", "createdAt": "2020-08-24T11:29:07Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/AbstractPredicatePushdownTest.java", "diffHunk": "@@ -81,7 +82,7 @@ public void testPushDownToLhsOfSemiJoin()\n         assertPlan(\"SELECT quantity FROM (SELECT * FROM lineitem WHERE orderkey IN (SELECT orderkey FROM orders)) \" +\n                         \"WHERE linenumber = 2\",\n                 anyTree(\n-                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\",\n+                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\", Optional.empty(), enableDynamicFiltering,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzNTE5MA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475535190", "bodyText": "just\n                                        anyTree(\n                                                tableScan(\"lineitem\", ImmutableMap.of(\n                                                        \"LINE_ORDER_KEY\", \"orderkey\"))) :\n\nshould work for both cases", "author": "sopel39", "createdAt": "2020-08-24T11:31:22Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/AbstractPredicatePushdownTest.java", "diffHunk": "@@ -122,11 +123,15 @@ public void testNonDeterministicPredicateDoesNotPropagateFromFilteringSideToSour\n     {\n         assertPlan(\"SELECT * FROM lineitem WHERE orderkey IN (SELECT orderkey FROM orders WHERE orderkey = random(5))\",\n                 anyTree(\n-                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\",\n-                                // NO filter here\n-                                project(\n-                                        tableScan(\"lineitem\", ImmutableMap.of(\n-                                                \"LINE_ORDER_KEY\", \"orderkey\"))),\n+                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\", Optional.empty(), enableDynamicFiltering,\n+                                enableDynamicFiltering ?", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzNTI4MA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475535280", "bodyText": "put each tableScan argument in newline", "author": "sopel39", "createdAt": "2020-08-24T11:31:33Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/AbstractPredicatePushdownTest.java", "diffHunk": "@@ -122,11 +123,15 @@ public void testNonDeterministicPredicateDoesNotPropagateFromFilteringSideToSour\n     {\n         assertPlan(\"SELECT * FROM lineitem WHERE orderkey IN (SELECT orderkey FROM orders WHERE orderkey = random(5))\",\n                 anyTree(\n-                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\",\n-                                // NO filter here\n-                                project(\n-                                        tableScan(\"lineitem\", ImmutableMap.of(\n-                                                \"LINE_ORDER_KEY\", \"orderkey\"))),\n+                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\", Optional.empty(), enableDynamicFiltering,\n+                                enableDynamicFiltering ?\n+                                        anyTree(\n+                                                tableScan(\"lineitem\", ImmutableMap.of(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzNTk0Ng==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475535946", "bodyText": "pass false here to assert that DF is not added", "author": "sopel39", "createdAt": "2020-08-24T11:33:00Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -326,6 +306,103 @@ public void testNonPushedDownJoinFilterRemoval()\n                                                 tableScan(\"part\", ImmutableMap.of(\"K2\", \"partkey\", \"V2\", \"size\")))))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        assertPlan(\"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0)\",\n+                anyTree(\n+                        filter(\"S\",\n+                                project(\n+                                        semiJoin(\"X\", \"Y\", \"S\", Optional.empty(), true,\n+                                                anyTree(\n+                                                        tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\"lineitem\", ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testNonFilteringSemiJoin()\n+    {\n+        // Dynamic filtering is not applied to non-filtering semi-join queries\n+        assertPlan(\"SELECT * FROM orders WHERE orderkey NOT IN (SELECT orderkey FROM lineitem WHERE linenumber < 0)\",\n+                anyTree(\n+                        filter(\"NOT S\",\n+                                project(\n+                                        semiJoin(\"X\", \"Y\", \"S\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzNzIxOQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475537219", "bodyText": "move this to testSemiJoin and assert DF is present. This is filtering semi join", "author": "sopel39", "createdAt": "2020-08-24T11:35:44Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -326,6 +306,103 @@ public void testNonPushedDownJoinFilterRemoval()\n                                                 tableScan(\"part\", ImmutableMap.of(\"K2\", \"partkey\", \"V2\", \"size\")))))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        assertPlan(\"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0)\",\n+                anyTree(\n+                        filter(\"S\",\n+                                project(\n+                                        semiJoin(\"X\", \"Y\", \"S\", Optional.empty(), true,\n+                                                anyTree(\n+                                                        tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\"lineitem\", ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testNonFilteringSemiJoin()\n+    {\n+        // Dynamic filtering is not applied to non-filtering semi-join queries\n+        assertPlan(\"SELECT * FROM orders WHERE orderkey NOT IN (SELECT orderkey FROM lineitem WHERE linenumber < 0)\",\n+                anyTree(\n+                        filter(\"NOT S\",\n+                                project(\n+                                        semiJoin(\"X\", \"Y\", \"S\",\n+                                                anyTree(\n+                                                        tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\"lineitem\", ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+\n+        assertPlan(\"SELECT orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber < 0) FROM orders\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxMDUzOQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476210539", "bodyText": "it's a non-filtering semi join since it returns boolean values instead of filtering out rows?", "author": "lxynov", "createdAt": "2020-08-25T06:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzNzIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzOTQ1OQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475539459", "bodyText": "this test can be simplified by removing semijoin IN (SELECT orders.orderkey FROM orders) which is non essential for this test", "author": "sopel39", "createdAt": "2020-08-24T11:40:43Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -326,6 +306,103 @@ public void testNonPushedDownJoinFilterRemoval()\n                                                 tableScan(\"part\", ImmutableMap.of(\"K2\", \"partkey\", \"V2\", \"size\")))))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        assertPlan(\"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0)\",\n+                anyTree(\n+                        filter(\"S\",\n+                                project(\n+                                        semiJoin(\"X\", \"Y\", \"S\", Optional.empty(), true,\n+                                                anyTree(\n+                                                        tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\"lineitem\", ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testNonFilteringSemiJoin()\n+    {\n+        // Dynamic filtering is not applied to non-filtering semi-join queries\n+        assertPlan(\"SELECT * FROM orders WHERE orderkey NOT IN (SELECT orderkey FROM lineitem WHERE linenumber < 0)\",\n+                anyTree(\n+                        filter(\"NOT S\",\n+                                project(\n+                                        semiJoin(\"X\", \"Y\", \"S\",\n+                                                anyTree(\n+                                                        tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\"lineitem\", ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+\n+        assertPlan(\"SELECT orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber < 0) FROM orders\",\n+                anyTree(\n+                        semiJoin(\"X\", \"Y\", \"S\",\n+                                anyTree(\n+                                        tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                anyTree(\n+                                        tableScan(\"lineitem\", ImmutableMap.of(\"Y\", \"orderkey\"))))));\n+    }\n+\n+    @Test\n+    public void testSemiJoinWithStaticFiltering()\n+    {\n+        assertPlan(\"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0) AND orderkey > 0\",\n+                anyTree(\n+                        filter(\"S\",\n+                                project(\n+                                        semiJoin(\"X\", \"Y\", \"S\", Optional.empty(), true,\n+                                                anyTree(\n+                                                        filter(\n+                                                                \"X > BIGINT '0'\",\n+                                                                tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\")))),\n+                                                anyTree(\n+                                                        tableScan(\"lineitem\", ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testMultiSemiJoin()\n+    {\n+        assertPlan(\"SELECT part.partkey FROM part WHERE part.partkey IN (SELECT lineitem.partkey FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders))\",\n+                anyTree(\n+                        filter(\"S0\",\n+                                project(\n+                                        semiJoin(\"PART_PK\", \"LINEITEM_PK\", \"S0\", Optional.empty(), true,\n+                                                anyTree(\n+                                                        tableScan(\"part\", ImmutableMap.of(\"PART_PK\", \"partkey\"))),\n+                                                anyTree(\n+                                                        filter(\"S1\",\n+                                                                project(\n+                                                                        semiJoin(\"LINEITEM_OK\", \"ORDERS_OK\", \"S1\", Optional.empty(), true,\n+                                                                                anyTree(\n+                                                                                        tableScan(\"lineitem\", ImmutableMap.of(\"LINEITEM_PK\", \"partkey\", \"LINEITEM_OK\", \"orderkey\"))),\n+                                                                                anyTree(\n+                                                                                        tableScan(\"orders\", ImmutableMap.of(\"ORDERS_OK\", \"orderkey\"))))))))))));\n+    }\n+\n+    @Test\n+    public void testSemiJoinUnsupportedDynamicFilterRemoval()\n+    {\n+        // Dynamic filters are supported only after a table scan\n+        assertPlan(\"WITH t AS (SELECT lineitem.partkey + 1000 partkey FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders)) \" +\n+                        \"SELECT t.partkey FROM t WHERE t.partkey IN (SELECT part.partkey FROM part)\",\n+                anyTree(\n+                        filter(\"S0\",\n+                                project(\n+                                        semiJoin(\"LINEITEM_PK_PLUS_1000\", \"PART_PK\", \"S0\", Optional.empty(), false,\n+                                                anyTree(\n+                                                        project(ImmutableMap.of(\"LINEITEM_PK_PLUS_1000\", expression(\"(LINEITEM_PK + BIGINT '1000')\")),\n+                                                                anyTree(\n+                                                                        filter(\"S1\",\n+                                                                                project(\n+                                                                                        semiJoin(\"LINEITEM_OK\", \"ORDERS_OK\", \"S1\", Optional.empty(), true,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxMTEwMA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476211100", "bodyText": "yeah but I feel we can keep it as a comparison with the outer one, WDYT?", "author": "lxynov", "createdAt": "2020-08-25T06:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzOTQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU0NDQ0NQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475544445", "bodyText": "this can be simplified, see: io.prestosql.server.DynamicFilterService#getConsumedDynamicFilters:\nboolean dynamicFilterConsumed = extractExpressions(planNode).stream()\n                .flatMap(expression -> extractDynamicFilters(expression).getDynamicConjuncts().stream())\n                .filter(filter -> filter.getId().eqals(dynamicFilterId))\n                .anyMatch(filter -> {\n                  Symbol filterSourceSymbol = Symbol.from(filter.getInput());\n                  return symbolAliases.get(sourceSymbolAlias).equals(filterSourceSymbol.toSymbolReference());\n                })\nif (!dynamicFilterConsumed) {\n  return NO_MATCH;\n}", "author": "sopel39", "createdAt": "2020-08-24T11:51:52Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/SemiJoinMatcher.java", "diffHunk": "@@ -64,6 +78,31 @@ public MatchResult detailMatches(PlanNode node, StatsProvider stats, Session ses\n             return NO_MATCH;\n         }\n \n+        if (hasDynamicFilter) {\n+            if (semiJoinNode.getDynamicFilterId().isEmpty()) {\n+                return NO_MATCH;\n+            }\n+            DynamicFilterId dynamicFilterId = semiJoinNode.getDynamicFilterId().get();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU1MDMwNg==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475550306", "bodyText": "keep this test cases separate", "author": "sopel39", "createdAt": "2020-08-24T12:03:45Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/optimizations/TestRemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -319,6 +320,77 @@ public void testSpatialJoin()\n                                 values(\"RIGHT_SYMBOL\"))));\n     }\n \n+    @Test\n+    public void testSemiJoin()", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU1MTg0NA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475551844", "bodyText": "put \"orders\" argument in newline", "author": "sopel39", "createdAt": "2020-08-24T12:06:50Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/optimizations/TestRemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -319,6 +320,77 @@ public void testSpatialJoin()\n                                 values(\"RIGHT_SYMBOL\"))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        // Unconsumed dynamic filter\n+        PlanNode root = builder.semiJoin(\n+                builder.filter(expression(\"ORDERS_OK > 0\"), ordersTableScanNode),\n+                lineitemTableScanNode,\n+                ordersOrderKeySymbol,\n+                lineitemOrderKeySymbol,\n+                new Symbol(\"SEMIJOIN_OUTPUT\"),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.of(new DynamicFilterId(\"DF\")));\n+        assertPlan(\n+                removeUnsupportedDynamicFilters(root),\n+                semiJoin(\"ORDERS_OK\", \"LINEITEM_OK\", \"SEMIJOIN_OUTPUT\", Optional.empty(), false,\n+                        filter(\"ORDERS_OK > 0\",\n+                                tableScan(\"orders\", ImmutableMap.of(\"ORDERS_OK\", \"orderkey\"))),", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2ODM1Ng==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475568356", "bodyText": "use io.prestosql.sql.planner.assertions.PlanMatchPattern#filter(io.prestosql.sql.tree.Expression, io.prestosql.sql.tree.Expression, io.prestosql.sql.planner.assertions.PlanMatchPattern) version of filter to assert DF is really gone", "author": "sopel39", "createdAt": "2020-08-24T12:39:06Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/optimizations/TestRemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -319,6 +320,77 @@ public void testSpatialJoin()\n                                 values(\"RIGHT_SYMBOL\"))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        // Unconsumed dynamic filter\n+        PlanNode root = builder.semiJoin(\n+                builder.filter(expression(\"ORDERS_OK > 0\"), ordersTableScanNode),\n+                lineitemTableScanNode,\n+                ordersOrderKeySymbol,\n+                lineitemOrderKeySymbol,\n+                new Symbol(\"SEMIJOIN_OUTPUT\"),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.of(new DynamicFilterId(\"DF\")));\n+        assertPlan(\n+                removeUnsupportedDynamicFilters(root),\n+                semiJoin(\"ORDERS_OK\", \"LINEITEM_OK\", \"SEMIJOIN_OUTPUT\", Optional.empty(), false,\n+                        filter(\"ORDERS_OK > 0\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2ODU0OA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475568548", "bodyText": "use io.prestosql.sql.planner.assertions.PlanMatchPattern#filter(io.prestosql.sql.tree.Expression, io.prestosql.sql.tree.Expression, io.prestosql.sql.planner.assertions.PlanMatchPattern)", "author": "sopel39", "createdAt": "2020-08-24T12:39:26Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/optimizations/TestRemoveUnsupportedDynamicFilters.java", "diffHunk": "@@ -319,6 +320,77 @@ public void testSpatialJoin()\n                                 values(\"RIGHT_SYMBOL\"))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        // Unconsumed dynamic filter\n+        PlanNode root = builder.semiJoin(\n+                builder.filter(expression(\"ORDERS_OK > 0\"), ordersTableScanNode),\n+                lineitemTableScanNode,\n+                ordersOrderKeySymbol,\n+                lineitemOrderKeySymbol,\n+                new Symbol(\"SEMIJOIN_OUTPUT\"),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.of(new DynamicFilterId(\"DF\")));\n+        assertPlan(\n+                removeUnsupportedDynamicFilters(root),\n+                semiJoin(\"ORDERS_OK\", \"LINEITEM_OK\", \"SEMIJOIN_OUTPUT\", Optional.empty(), false,\n+                        filter(\"ORDERS_OK > 0\",\n+                                tableScan(\"orders\", ImmutableMap.of(\"ORDERS_OK\", \"orderkey\"))),\n+                        tableScan(\"lineitem\", ImmutableMap.of(\"LINEITEM_OK\", \"orderkey\"))));\n+\n+        Expression dynamicFilterExpression = createDynamicFilterExpression(metadata, new DynamicFilterId(\"DF\"), BIGINT, ordersOrderKeySymbol.toSymbolReference());\n+\n+        // Unmatched dynamic filter\n+        root = builder.semiJoin(\n+                builder.filter(\n+                        combineConjuncts(\n+                                metadata,\n+                                expression(\"ORDERS_OK > 0\"),\n+                                dynamicFilterExpression),\n+                        ordersTableScanNode),\n+                lineitemTableScanNode,\n+                ordersOrderKeySymbol,\n+                lineitemOrderKeySymbol,\n+                new Symbol(\"SEMIJOIN_OUTPUT\"),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty(),\n+                Optional.empty());\n+        assertPlan(\n+                removeUnsupportedDynamicFilters(root),\n+                semiJoin(\"ORDERS_OK\", \"LINEITEM_OK\", \"SEMIJOIN_OUTPUT\", Optional.empty(), false,\n+                        filter(\"ORDERS_OK > 0\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2OTIyNw==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r475569227", "bodyText": "please add a test to TestDynamicFiltersChecker", "author": "sopel39", "createdAt": "2020-08-24T12:40:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/sanity/DynamicFiltersChecker.java", "diffHunk": "@@ -98,6 +100,25 @@ public void validate(PlanNode plan, Session session, Metadata metadata, TypeAnal\n                 return ImmutableSet.copyOf(unmatched);\n             }\n \n+            @Override", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNTU2NA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476315564", "bodyText": "please just inline all tableScan params:\ntableScan(\"lineitem\", ImmutableMap.of(\"LINE_ORDER_KEY\", \"orderkey\"))", "author": "sopel39", "createdAt": "2020-08-25T09:36:12Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/AbstractPredicatePushdownTest.java", "diffHunk": "@@ -122,11 +122,10 @@ public void testNonDeterministicPredicateDoesNotPropagateFromFilteringSideToSour\n     {\n         assertPlan(\"SELECT * FROM lineitem WHERE orderkey IN (SELECT orderkey FROM orders WHERE orderkey = random(5))\",\n                 anyTree(\n-                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\",\n-                                // NO filter here\n-                                project(\n-                                        tableScan(\"lineitem\", ImmutableMap.of(\n-                                                \"LINE_ORDER_KEY\", \"orderkey\"))),\n+                        semiJoin(\"LINE_ORDER_KEY\", \"ORDERS_ORDER_KEY\", \"SEMI_JOIN_RESULT\", enableDynamicFiltering,\n+                                        anyTree(\n+                                                tableScan(\"lineitem\", ImmutableMap.of(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc5MDgwMg==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476790802", "bodyText": "The diff here is misleading. This line is actually from a previous commit 9e066115 Push SemiJoin predicate inferred from filter side to source side, so let's keep it as it is", "author": "lxynov", "createdAt": "2020-08-25T22:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNjYxNg==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476316616", "bodyText": "actually, I think\nfilter(\"S\",\n  project(\n    semiJoin(\"X\", \"Y\", \"S\", true,\n      anyTree\n\nis more readable, e.g: args that are not subtrees should stay in same line. Sorry for confusion", "author": "sopel39", "createdAt": "2020-08-25T09:37:53Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -326,6 +306,177 @@ public void testNonPushedDownJoinFilterRemoval()\n                                                 tableScan(\"part\", ImmutableMap.of(\"K2\", \"partkey\", \"V2\", \"size\")))))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0)\",\n+                anyTree(\n+                        filter(\n+                                \"S\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0OTgwNg==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476649806", "bodyText": "agreed, this looks much nicer", "author": "lxynov", "createdAt": "2020-08-25T18:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNjYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNzg2OQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476317869", "bodyText": "yeah. Definitely previous formatting was better. ;)", "author": "sopel39", "createdAt": "2020-08-25T09:39:59Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -326,6 +306,177 @@ public void testNonPushedDownJoinFilterRemoval()\n                                                 tableScan(\"part\", ImmutableMap.of(\"K2\", \"partkey\", \"V2\", \"size\")))))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0)\",\n+                anyTree(\n+                        filter(\n+                                \"S\",\n+                                project(\n+                                        semiJoin(\n+                                                \"X\",\n+                                                \"Y\",\n+                                                \"S\",\n+                                                true,\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"orders\",\n+                                                                ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"lineitem\",\n+                                                                ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testNonFilteringSemiJoin()\n+    {\n+        // Dynamic filtering is not applied to non-filtering semi-join queries\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey NOT IN (SELECT orderkey FROM lineitem WHERE linenumber < 0)\",\n+                anyTree(\n+                        filter(\n+                                \"NOT S\",\n+                                project(\n+                                        semiJoin(\n+                                                \"X\",\n+                                                \"Y\",\n+                                                \"S\",\n+                                                false,\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"orders\",\n+                                                                ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"lineitem\",\n+                                                                ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+\n+        assertPlan(\n+                \"SELECT orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber < 0) FROM orders\",\n+                anyTree(\n+                        semiJoin(\n+                                \"X\",\n+                                \"Y\",\n+                                \"S\",\n+                                false,\n+                                anyTree(\n+                                        tableScan(\n+                                                \"orders\",\n+                                                ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                anyTree(\n+                                        tableScan(\n+                                                \"lineitem\",\n+                                                ImmutableMap.of(\"Y\", \"orderkey\"))))));\n+    }\n+\n+    @Test\n+    public void testSemiJoinWithStaticFiltering()\n+    {\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0) AND orderkey > 0\",\n+                anyTree(\n+                        filter(\n+                                \"S\",\n+                                project(\n+                                        semiJoin(\n+                                                \"X\",\n+                                                \"Y\",\n+                                                \"S\",\n+                                                true,\n+                                                anyTree(\n+                                                        filter(\n+                                                                \"X > BIGINT '0'\",\n+                                                                tableScan(\n+                                                                        \"orders\",\n+                                                                        ImmutableMap.of(\"X\", \"orderkey\")))),\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"lineitem\",\n+                                                                ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testMultiSemiJoin()\n+    {\n+        assertPlan(\n+                \"SELECT part.partkey FROM part WHERE part.partkey IN (SELECT lineitem.partkey FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders))\",\n+                anyTree(\n+                        filter(\n+                                \"S0\",\n+                                project(\n+                                        semiJoin(", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxODExNg==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476318116", "bodyText": "please put subquery in newline", "author": "sopel39", "createdAt": "2020-08-25T09:40:21Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -326,6 +306,177 @@ public void testNonPushedDownJoinFilterRemoval()\n                                                 tableScan(\"part\", ImmutableMap.of(\"K2\", \"partkey\", \"V2\", \"size\")))))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0)\",\n+                anyTree(\n+                        filter(\n+                                \"S\",\n+                                project(\n+                                        semiJoin(\n+                                                \"X\",\n+                                                \"Y\",\n+                                                \"S\",\n+                                                true,\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"orders\",\n+                                                                ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"lineitem\",\n+                                                                ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testNonFilteringSemiJoin()\n+    {\n+        // Dynamic filtering is not applied to non-filtering semi-join queries\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey NOT IN (SELECT orderkey FROM lineitem WHERE linenumber < 0)\",\n+                anyTree(\n+                        filter(\n+                                \"NOT S\",\n+                                project(\n+                                        semiJoin(\n+                                                \"X\",\n+                                                \"Y\",\n+                                                \"S\",\n+                                                false,\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"orders\",\n+                                                                ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"lineitem\",\n+                                                                ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+\n+        assertPlan(\n+                \"SELECT orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber < 0) FROM orders\",\n+                anyTree(\n+                        semiJoin(\n+                                \"X\",\n+                                \"Y\",\n+                                \"S\",\n+                                false,\n+                                anyTree(\n+                                        tableScan(\n+                                                \"orders\",\n+                                                ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                anyTree(\n+                                        tableScan(\n+                                                \"lineitem\",\n+                                                ImmutableMap.of(\"Y\", \"orderkey\"))))));\n+    }\n+\n+    @Test\n+    public void testSemiJoinWithStaticFiltering()\n+    {\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0) AND orderkey > 0\",\n+                anyTree(\n+                        filter(\n+                                \"S\",\n+                                project(\n+                                        semiJoin(\n+                                                \"X\",\n+                                                \"Y\",\n+                                                \"S\",\n+                                                true,\n+                                                anyTree(\n+                                                        filter(\n+                                                                \"X > BIGINT '0'\",\n+                                                                tableScan(\n+                                                                        \"orders\",\n+                                                                        ImmutableMap.of(\"X\", \"orderkey\")))),\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"lineitem\",\n+                                                                ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testMultiSemiJoin()\n+    {\n+        assertPlan(\n+                \"SELECT part.partkey FROM part WHERE part.partkey IN (SELECT lineitem.partkey FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders))\",", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxOTE2OQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476319169", "bodyText": "We can cut WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders)) out. This case was tested already in other testSemiJoin method", "author": "sopel39", "createdAt": "2020-08-25T09:41:57Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestDynamicFilter.java", "diffHunk": "@@ -326,6 +306,177 @@ public void testNonPushedDownJoinFilterRemoval()\n                                                 tableScan(\"part\", ImmutableMap.of(\"K2\", \"partkey\", \"V2\", \"size\")))))));\n     }\n \n+    @Test\n+    public void testSemiJoin()\n+    {\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0)\",\n+                anyTree(\n+                        filter(\n+                                \"S\",\n+                                project(\n+                                        semiJoin(\n+                                                \"X\",\n+                                                \"Y\",\n+                                                \"S\",\n+                                                true,\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"orders\",\n+                                                                ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"lineitem\",\n+                                                                ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testNonFilteringSemiJoin()\n+    {\n+        // Dynamic filtering is not applied to non-filtering semi-join queries\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey NOT IN (SELECT orderkey FROM lineitem WHERE linenumber < 0)\",\n+                anyTree(\n+                        filter(\n+                                \"NOT S\",\n+                                project(\n+                                        semiJoin(\n+                                                \"X\",\n+                                                \"Y\",\n+                                                \"S\",\n+                                                false,\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"orders\",\n+                                                                ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"lineitem\",\n+                                                                ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+\n+        assertPlan(\n+                \"SELECT orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber < 0) FROM orders\",\n+                anyTree(\n+                        semiJoin(\n+                                \"X\",\n+                                \"Y\",\n+                                \"S\",\n+                                false,\n+                                anyTree(\n+                                        tableScan(\n+                                                \"orders\",\n+                                                ImmutableMap.of(\"X\", \"orderkey\"))),\n+                                anyTree(\n+                                        tableScan(\n+                                                \"lineitem\",\n+                                                ImmutableMap.of(\"Y\", \"orderkey\"))))));\n+    }\n+\n+    @Test\n+    public void testSemiJoinWithStaticFiltering()\n+    {\n+        assertPlan(\n+                \"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0) AND orderkey > 0\",\n+                anyTree(\n+                        filter(\n+                                \"S\",\n+                                project(\n+                                        semiJoin(\n+                                                \"X\",\n+                                                \"Y\",\n+                                                \"S\",\n+                                                true,\n+                                                anyTree(\n+                                                        filter(\n+                                                                \"X > BIGINT '0'\",\n+                                                                tableScan(\n+                                                                        \"orders\",\n+                                                                        ImmutableMap.of(\"X\", \"orderkey\")))),\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"lineitem\",\n+                                                                ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n+    }\n+\n+    @Test\n+    public void testMultiSemiJoin()\n+    {\n+        assertPlan(\n+                \"SELECT part.partkey FROM part WHERE part.partkey IN (SELECT lineitem.partkey FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders))\",\n+                anyTree(\n+                        filter(\n+                                \"S0\",\n+                                project(\n+                                        semiJoin(\n+                                                \"PART_PK\",\n+                                                \"LINEITEM_PK\",\n+                                                \"S0\",\n+                                                true,\n+                                                anyTree(\n+                                                        tableScan(\n+                                                                \"part\",\n+                                                                ImmutableMap.of(\"PART_PK\", \"partkey\"))),\n+                                                anyTree(\n+                                                        filter(\n+                                                                \"S1\",\n+                                                                project(\n+                                                                        semiJoin(\n+                                                                                \"LINEITEM_OK\",\n+                                                                                \"ORDERS_OK\",\n+                                                                                \"S1\",\n+                                                                                true,\n+                                                                                anyTree(\n+                                                                                        tableScan(\n+                                                                                                \"lineitem\",\n+                                                                                                ImmutableMap.of(\"LINEITEM_PK\", \"partkey\", \"LINEITEM_OK\", \"orderkey\"))),\n+                                                                                anyTree(\n+                                                                                        tableScan(\n+                                                                                                \"orders\",\n+                                                                                                ImmutableMap.of(\"ORDERS_OK\", \"orderkey\"))))))))))));\n+    }\n+\n+    @Test\n+    public void testSemiJoinUnsupportedDynamicFilterRemoval()\n+    {\n+        // Dynamic filters are supported only after a table scan\n+        assertPlan(\n+                \"WITH t AS (SELECT lineitem.partkey + 1000 partkey FROM lineitem WHERE lineitem.orderkey IN (SELECT orders.orderkey FROM orders)) \" +", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4Nzk2MA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476787960", "bodyText": "With WITH t AS (SELECT lineitem.partkey + 1000 partkey FROM lineitem), the project will be merged with table scan but we don't have TableScanAndProjectMatcher to represent it. Would it be good to keep the inner semi-join here as it can also serve as a comparison to the outer semi-join? We can see clearly that the inner semi-join has dynamic filter but not the outer one.", "author": "lxynov", "createdAt": "2020-08-25T22:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxOTE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NjQwNQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r477196405", "bodyText": "I think\nSELECT partkey FROM (SELECT lineitem.partkey + 1000 partkey FROM lineitem) WHERE partkey IN (SELECT part.partkey FROM part)\n\nshould be sufficient.\nIt would be easier for reader to undestand the test intent and matched tree.", "author": "sopel39", "createdAt": "2020-08-26T10:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxOTE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMDI1MA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476320250", "bodyText": "please fix query assertion instead", "author": "sopel39", "createdAt": "2020-08-25T09:43:45Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestLogicalPlanner.java", "diffHunk": "@@ -430,6 +431,9 @@ public void testUncorrelatedSubqueries()\n                                                         tableScan(\"lineitem\", ImmutableMap.of(\"Y\", \"orderkey\"))))))));\n \n         assertPlan(\"SELECT * FROM orders WHERE orderkey IN (SELECT orderkey FROM lineitem WHERE linenumber % 4 = 0)\",\n+                Session.builder(this.getQueryRunner().getDefaultSession())", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMDQ0OQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476320449", "bodyText": "please fix query assertion instead", "author": "sopel39", "createdAt": "2020-08-25T09:44:06Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestQuantifiedComparison.java", "diffHunk": "@@ -35,12 +37,16 @@\n     public void testQuantifiedComparisonEqualsAny()\n     {\n         String query = \"SELECT orderkey, custkey FROM orders WHERE orderkey = ANY (VALUES ROW(CAST(5 as BIGINT)), ROW(CAST(3 as BIGINT)))\";\n-        assertPlan(query, anyTree(\n-                filter(\"S\",\n-                        project(\n-                                semiJoin(\"X\", \"Y\", \"S\",\n-                                        anyTree(tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n-                                        anyTree(values(ImmutableMap.of(\"Y\", 0))))))));\n+        assertPlan(query,\n+                Session.builder(this.getQueryRunner().getDefaultSession())\n+                        .setSystemProperty(ENABLE_DYNAMIC_FILTERING, Boolean.toString(false))", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMjM1NQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476322355", "bodyText": "let's make dynamic filter check optional, e.g use:\nOptional<Boolean> hasDynamicFilter\n\nthis way DF tests are isolated", "author": "sopel39", "createdAt": "2020-08-25T09:47:13Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/PlanMatchPattern.java", "diffHunk": "@@ -417,12 +417,22 @@ public static PlanMatchPattern strictProject(Map<String, ExpressionMatcher> assi\n \n     public static PlanMatchPattern semiJoin(String sourceSymbolAlias, String filteringSymbolAlias, String outputAlias, PlanMatchPattern source, PlanMatchPattern filtering)\n     {\n-        return semiJoin(sourceSymbolAlias, filteringSymbolAlias, outputAlias, Optional.empty(), source, filtering);\n+        return semiJoin(sourceSymbolAlias, filteringSymbolAlias, outputAlias, Optional.empty(), false, source, filtering);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyOTIzOQ==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476329239", "bodyText": "Please also match that filtered symbol matches probe symbol:\nsymbolAliases.get(sourceSymbolAlias).equals(filterSourceSymbol.toSymbolReference());\n\nthat was a good assertion (unless it doesn't hold in tests)", "author": "sopel39", "createdAt": "2020-08-25T09:58:33Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/SemiJoinMatcher.java", "diffHunk": "@@ -64,6 +76,26 @@ public MatchResult detailMatches(PlanNode node, StatsProvider stats, Session ses\n             return NO_MATCH;\n         }\n \n+        if (hasDynamicFilter) {\n+            if (semiJoinNode.getDynamicFilterId().isEmpty()) {\n+                return NO_MATCH;\n+            }\n+            DynamicFilterId dynamicFilterId = semiJoinNode.getDynamicFilterId().get();\n+            boolean dynamicFilterConsumed = searchFrom(semiJoinNode.getSource())\n+                    .where(FilterNode.class::isInstance)\n+                    .findAll()\n+                    .stream()\n+                    .flatMap(filterNode -> extractExpressions(filterNode).stream())\n+                    .flatMap(expression -> extractDynamicFilters(expression).getDynamicConjuncts().stream())\n+                    .anyMatch(descriptor -> descriptor.getId().equals(dynamicFilterId));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3MTg2Nw==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r476671867", "bodyText": "oh I missed that one while refactoring, thanks for the catch!", "author": "lxynov", "createdAt": "2020-08-25T19:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyOTIzOQ=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5MTg0NA==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r477191844", "bodyText": "We should break that into multiple lines at this point", "author": "sopel39", "createdAt": "2020-08-26T10:14:19Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/optimizations/PredicatePushDown.java", "diffHunk": "@@ -1184,7 +1184,7 @@ private PlanNode visitNonFilteringSemiJoin(SemiJoinNode node, RewriteContext<Exp\n \n             PlanNode output = node;\n             if (rewrittenSource != node.getSource() || rewrittenFilteringSource != node.getFilteringSource()) {\n-                output = new SemiJoinNode(node.getId(), rewrittenSource, rewrittenFilteringSource, node.getSourceJoinSymbol(), node.getFilteringSourceJoinSymbol(), node.getSemiJoinOutput(), node.getSourceHashSymbol(), node.getFilteringSourceHashSymbol(), node.getDistributionType());\n+                output = new SemiJoinNode(node.getId(), rewrittenSource, rewrittenFilteringSource, node.getSourceJoinSymbol(), node.getFilteringSourceJoinSymbol(), node.getSemiJoinOutput(), node.getSourceHashSymbol(), node.getFilteringSourceHashSymbol(), node.getDistributionType(), Optional.empty());", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NzEyMw==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r477197123", "bodyText": "nit for future: this should be separate commit (it changes formatting)", "author": "sopel39", "createdAt": "2020-08-26T10:24:44Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/TestQuantifiedComparison.java", "diffHunk": "@@ -35,12 +35,13 @@\n     public void testQuantifiedComparisonEqualsAny()\n     {\n         String query = \"SELECT orderkey, custkey FROM orders WHERE orderkey = ANY (VALUES ROW(CAST(5 as BIGINT)), ROW(CAST(3 as BIGINT)))\";\n-        assertPlan(query, anyTree(\n-                filter(\"S\",\n-                        project(\n-                                semiJoin(\"X\", \"Y\", \"S\",\n-                                        anyTree(tableScan(\"orders\", ImmutableMap.of(\"X\", \"orderkey\"))),\n-                                        anyTree(values(ImmutableMap.of(\"Y\", 0))))))));\n+        assertPlan(query,", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwMjUwMg==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r477202502", "bodyText": "you should make sure that there is at least one match (allMatch returns true on empty stream), e.g:\nList<DynamicFilter.Descriptor> matchingDescriptors = searchFrom(semiJoinNode.getSource())\n  .where(FilterNode.class::isInstance)\n  .findAll()\n  .stream()\n  .flatMap(filterNode -> extractExpressions(filterNode).stream())\n  .flatMap(expression -> extractDynamicFilters(expression).getDynamicConjuncts().stream())\n  .filter(descriptor -> descriptor.getId().equals(dynamicFilterId))\n  .collect(toImmutableList();\nboolean sourceSymbolsMatch = matchingDescriptors.stream()\n  .map(descriptor -> Symbol.from(descriptor.getInput()))\n  .allMatch(sourceSymbol -> symbolAliases.get(sourceSymbolAlias).equals(sourceSymbol.toSymbolReference()));\nif (!matchingDescriptors.isEmpty() && sourceSymbolsMatch) {\n  ...\n}", "author": "sopel39", "createdAt": "2020-08-26T10:35:09Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/assertions/SemiJoinMatcher.java", "diffHunk": "@@ -64,6 +77,31 @@ public MatchResult detailMatches(PlanNode node, StatsProvider stats, Session ses\n             return NO_MATCH;\n         }\n \n+        if (hasDynamicFilter.isPresent()) {\n+            if (hasDynamicFilter.get()) {\n+                if (semiJoinNode.getDynamicFilterId().isEmpty()) {\n+                    return NO_MATCH;\n+                }\n+                DynamicFilterId dynamicFilterId = semiJoinNode.getDynamicFilterId().get();\n+                boolean dynamicFilterMatched = searchFrom(semiJoinNode.getSource())\n+                        .where(FilterNode.class::isInstance)\n+                        .findAll()\n+                        .stream()\n+                        .flatMap(filterNode -> extractExpressions(filterNode).stream())\n+                        .flatMap(expression -> extractDynamicFilters(expression).getDynamicConjuncts().stream())\n+                        .filter(descriptor -> descriptor.getId().equals(dynamicFilterId))\n+                        .map(descriptor -> Symbol.from(descriptor.getInput()))\n+                        .allMatch(sourceSymbol -> symbolAliases.get(sourceSymbolAlias).equals(sourceSymbol.toSymbolReference()));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ0MzI5Nw==", "url": "https://github.com/trinodb/trino/pull/4942#discussion_r477443297", "bodyText": "oh good catch. Thanks for the pointer", "author": "lxynov", "createdAt": "2020-08-26T16:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwMjUwMg=="}], "type": "inlineReview"}, {"oid": "bdb21a6e00f61bb46930d5370a4fe5de7beff7af", "url": "https://github.com/trinodb/trino/commit/bdb21a6e00f61bb46930d5370a4fe5de7beff7af", "message": "Dynamic filtering for semi-joins: planner", "committedDate": "2020-08-26T17:21:02Z", "type": "commit"}, {"oid": "bdb21a6e00f61bb46930d5370a4fe5de7beff7af", "url": "https://github.com/trinodb/trino/commit/bdb21a6e00f61bb46930d5370a4fe5de7beff7af", "message": "Dynamic filtering for semi-joins: planner", "committedDate": "2020-08-26T17:21:02Z", "type": "forcePushed"}]}