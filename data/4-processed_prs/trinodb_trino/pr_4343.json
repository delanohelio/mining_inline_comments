{"pr_number": 4343, "pr_title": "Fix support for object types in some functions", "pr_createdAt": "2020-07-04T07:15:06Z", "pr_url": "https://github.com/trinodb/trino/pull/4343", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQxNzA1Ng==", "url": "https://github.com/trinodb/trino/pull/4343#discussion_r450417056", "bodyText": "This isn't used in this commit", "author": "martint", "createdAt": "2020-07-06T18:52:17Z", "path": "presto-main/src/test/java/io/prestosql/type/TestArrayOperators.java", "diffHunk": "@@ -1875,4 +1878,14 @@ private static SqlDate sqlDate(String dateString)\n         dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n         return new SqlDate(toIntExact(TimeUnit.MILLISECONDS.toDays(dateFormat.parse(dateString).getTime())));\n     }\n+\n+    private static SqlTimestamp sqlTimestamp(int precision, String value)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMDc3Mg==", "url": "https://github.com/trinodb/trino/pull/4343#discussion_r450420772", "bodyText": "Why legacy? Ideally, we should test both legacy and new semantics. It may be easier to pull off by adding a test to io.prestosql.operator.scalar.timestamp.BaseTestTimestamp (take a look at testLiterals) or maybe even a dedicated test similar to the ones in io.prestosql.sql.query, instead, since assertFunction doesn't allow customizing the session.\nAlso, we should have tests for multiple precisions, as the underlying representation affects what code paths the execution will go through.", "author": "martint", "createdAt": "2020-07-06T18:59:31Z", "path": "presto-main/src/test/java/io/prestosql/type/TestArrayOperators.java", "diffHunk": "@@ -1875,4 +1878,14 @@ private static SqlDate sqlDate(String dateString)\n         dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n         return new SqlDate(toIntExact(TimeUnit.MILLISECONDS.toDays(dateFormat.parse(dateString).getTime())));\n     }\n+\n+    private static SqlTimestamp sqlTimestamp(int precision, String value)\n+    {\n+        Object timestamp = parseLegacyTimestamp(precision, TEST_SESSION.getTimeZoneKey(), value);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQyMzg2NQ==", "url": "https://github.com/trinodb/trino/pull/4343#discussion_r450423865", "bodyText": "Same comments as for array_contains", "author": "martint", "createdAt": "2020-07-06T19:05:58Z", "path": "presto-main/src/test/java/io/prestosql/operator/scalar/TestTryFunction.java", "diffHunk": "@@ -78,4 +84,14 @@ private static String createTryExpression(String expression)\n     {\n         return \"\\\"\" + TryFunction.NAME + \"\\\"(() -> \" + expression + \")\";\n     }\n+\n+    private static SqlTimestamp sqlTimestamp(int precision, String value)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU2OTI3NQ==", "url": "https://github.com/trinodb/trino/pull/4343#discussion_r450569275", "bodyText": "typo: \"byt he\"", "author": "martint", "createdAt": "2020-07-07T01:57:36Z", "path": "presto-main/src/main/java/io/prestosql/operator/scalar/MapToMapCast.java", "diffHunk": "@@ -112,27 +114,31 @@ public ScalarFunctionImplementation specialize(BoundVariables boundVariables, in\n      */\n     private MethodHandle buildProcessor(Metadata metadata, Type fromType, Type toType, boolean isKey)\n     {\n-        MethodHandle getter = nativeValueGetter(fromType);\n-\n-        // Adapt cast that takes ([ConnectorSession,] ?) to one that takes (?, ConnectorSession), where ? is the return type of getter.\n+        // Get block position cast, with optional connector session\n         ResolvedFunction resolvedFunction = metadata.getCoercion(fromType, toType);\n         FunctionMetadata functionMetadata = metadata.getFunctionMetadata(resolvedFunction);\n-        MethodHandle cast = metadata.getScalarFunctionInvoker(resolvedFunction, Optional.empty()).getMethodHandle();\n+        InvocationConvention invocationConvention = new InvocationConvention(ImmutableList.of(BLOCK_POSITION), functionMetadata.isNullable() ? NULLABLE_RETURN : FAIL_ON_NULL, true, false);\n+        MethodHandle cast = metadata.getScalarFunctionInvoker(resolvedFunction, Optional.of(invocationConvention)).getMethodHandle();\n+        // Normalize cast to have connector session as first argument\n         if (cast.type().parameterArray()[0] != ConnectorSession.class) {\n             cast = MethodHandles.dropArguments(cast, 0, ConnectorSession.class);\n         }\n-        cast = permuteArguments(cast, methodType(cast.type().returnType(), cast.type().parameterArray()[1], cast.type().parameterArray()[0]), 1, 0);\n-        MethodHandle target = compose(cast, getter);\n+        // Change cast signature to (Block.class, int.class, ConnectorSession.class):T\n+        cast = permuteArguments(cast, methodType(cast.type().returnType(), Block.class, int.class, ConnectorSession.class), 2, 0, 1);\n \n-        // If the key cast function is nullable, check the result is not null.\n+        // If the key cast function is nullable, check the result is not null\n         if (isKey && functionMetadata.isNullable()) {\n-            target = compose(nullChecker(target.type().returnType()), target);\n+            cast = compose(nullChecker(cast.type().returnType()), cast);\n         }\n \n+        // get write method with signature: (T, BlockBuilder.class):void\n         MethodHandle writer = nativeValueWriter(toType);\n-        writer = permuteArguments(writer, methodType(void.class, writer.type().parameterArray()[1], writer.type().parameterArray()[0]), 1, 0);\n+        writer = permuteArguments(writer, methodType(void.class, writer.type().parameterArray()[1], BlockBuilder.class), 1, 0);\n+\n+        // ensure cast returns type expected byt he writer", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "003cf2bc2ef425bc1004bfce44c83c35f43e4fec", "url": "https://github.com/trinodb/trino/commit/003cf2bc2ef425bc1004bfce44c83c35f43e4fec", "message": "Cleanup parametric function variants\n\nConsoliate Slice and Block variants into Object where possible", "committedDate": "2020-07-07T03:36:42Z", "type": "commit"}, {"oid": "cf2b667cf867664105426b38b4d4854af13250bc", "url": "https://github.com/trinodb/trino/commit/cf2b667cf867664105426b38b4d4854af13250bc", "message": "Remove unnecessary repeat variant", "committedDate": "2020-07-07T03:36:44Z", "type": "commit"}, {"oid": "cf2b667cf867664105426b38b4d4854af13250bc", "url": "https://github.com/trinodb/trino/commit/cf2b667cf867664105426b38b4d4854af13250bc", "message": "Remove unnecessary repeat variant", "committedDate": "2020-07-07T03:36:44Z", "type": "forcePushed"}]}