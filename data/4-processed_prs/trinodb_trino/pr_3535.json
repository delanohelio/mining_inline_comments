{"pr_number": 3535, "pr_title": "Add an information_schema. role_authorization_descriptors table", "pr_createdAt": "2020-04-24T02:37:03Z", "pr_url": "https://github.com/trinodb/trino/pull/3535", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNTM4Mw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415725383", "bodyText": "listGrantedPrincipals?", "author": "kokosing", "createdAt": "2020-04-27T11:16:35Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveMetadata.java", "diffHunk": "@@ -2341,6 +2341,12 @@ public void dropRole(ConnectorSession session, String role)\n         return accessControlMetadata.listRoles(session);\n     }\n \n+    @Override\n+    public Set<RoleGrant> listPrincipals(ConnectorSession session, String role)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2NDI5OQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415964299", "bodyText": "Yeah, that's better.", "author": "lhofhansl", "createdAt": "2020-04-27T16:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNTc5OA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415725798", "bodyText": "remove default? Other methods do not have default here?", "author": "kokosing", "createdAt": "2020-04-27T11:17:20Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/HiveMetastore.java", "diffHunk": "@@ -105,6 +108,11 @@\n \n     void revokeRoles(Set<String> roles, Set<HivePrincipal> grantees, boolean adminOption, HivePrincipal grantor);\n \n+    default Set<RoleGrant> listPrincipals(String role)", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2NDQ1OA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415964458", "bodyText": "New update soon.", "author": "lhofhansl", "createdAt": "2020-04-27T16:30:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNTc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNzQ5Ng==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415727496", "bodyText": "Can you test different users here? Like admin who sees everything, user that sees only his role grants and user that does not see anything because has no role grants?", "author": "kokosing", "createdAt": "2020-04-27T11:20:09Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveIntegrationSmokeTest.java", "diffHunk": "@@ -4962,6 +4962,74 @@ public void testShowColumnMetadata()\n         assertUpdate(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test\n+    public void testRoleGrants()\n+    {\n+        assertUpdate(\"CREATE ROLE test_role_grant1\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyODI4OQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415728289", "bodyText": "can you please add tests for role_grants here as well?", "author": "kokosing", "createdAt": "2020-04-27T11:21:23Z", "path": "presto-tests/src/test/java/io/prestosql/tests/TestInformationSchemaConnector.java", "diffHunk": "@@ -52,12 +52,12 @@\n     public void testBasic()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2MjY3Ng==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415962676", "bodyText": "There are 0 tests for any other role or access related stuff (roles, enabled_roles, applicable_roles, table_privileges) in there. I assume it's because it does not work in all connectors?", "author": "lhofhansl", "createdAt": "2020-04-27T16:28:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyODI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMjI0Mg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427112242", "bodyText": "it's because it does not work in all connectors\n\nThis test is using dedicated testing connector called CountingMockConnector\n\nThere are 0 tests for any other role or access related stuff\n\nThat is a mistake (we didn't catch that). I think having such tests bring a lot of value. Could you please add them? Adding tests for other tables could be done in separate commits.", "author": "kokosing", "createdAt": "2020-05-19T08:13:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyODI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0NDM0NQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427644345", "bodyText": "I added some tests....", "author": "lhofhansl", "createdAt": "2020-05-19T22:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyODI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyODQzNw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415728437", "bodyText": "why this numbers got higher?", "author": "kokosing", "createdAt": "2020-04-27T11:21:37Z", "path": "presto-tests/src/test/java/io/prestosql/tests/TestInformationSchemaConnector.java", "diffHunk": "@@ -52,12 +52,12 @@\n     public void testBasic()\n     {\n         assertQuery(\"SELECT count(*) FROM tpch.information_schema.schemata\", \"VALUES 10\");\n-        assertQuery(\"SELECT count(*) FROM tpch.information_schema.tables\", \"VALUES 80\");\n-        assertQuery(\"SELECT count(*) FROM tpch.information_schema.columns\", \"VALUES 583\");\n+        assertQuery(\"SELECT count(*) FROM tpch.information_schema.tables\", \"VALUES 81\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkzNzEyNg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415937126", "bodyText": "This is because these include the new tables and columns in information_schema so both tables and columns have more values.", "author": "lhofhansl", "createdAt": "2020-04-27T15:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyODQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyOTQ0MA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r415729440", "bodyText": "@electrum Can you please take a look at this pull request too? I would like to have a second pair of eyes before adding any new table to information_schema?", "author": "kokosing", "createdAt": "2020-04-27T11:23:22Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveMetadata.java", "diffHunk": "@@ -2341,6 +2341,12 @@ public void dropRole(ConnectorSession session, String role)\n         return accessControlMetadata.listRoles(session);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYwMzU5Mg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r425603592", "bodyText": "If there's a more elegant to phrase this let me know.\nInstead of the break label that could build() and return as well.", "author": "lhofhansl", "createdAt": "2020-05-15T06:58:37Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/security/SqlStandardAccessControlMetadata.java", "diffHunk": "@@ -84,6 +87,62 @@ private static void checkRoleIsNotReserved(String role)\n         return ImmutableSet.copyOf(metastore.listRoles());\n     }\n \n+    @Override\n+    public Set<RoleGrant> listAllRoleGrants(ConnectorSession session, Optional<Set<String>> roles, Optional<Set<String>> grantees, OptionalLong limit)\n+    {\n+        /*\n+         * The Hive Metadata interface provides us with two ways to retrieve role grants:\n+         * 1. principals by single role\n+         * 2. roles by single principal\n+         *\n+         * We check the passed predicates to decide which path is most optimal.\n+         */\n+        if (roles.isPresent() && grantees.isPresent()) {\n+            if (roles.get().size() <= grantees.get().size() * 2) {\n+                // 2x because for the grantees we do not know the grantee type (ROLE or USER)\n+                grantees = Optional.empty();\n+            }\n+            else {\n+                roles = Optional.empty();\n+            }\n+        }\n+\n+        ImmutableSet.Builder<RoleGrant> builder = ImmutableSet.builder();\n+        long count = 0;\n+        if (grantees.isPresent()) {\n+            TOP:\n+            for (String grantee : grantees.get()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNzAzMg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427107032", "bodyText": "extract a method and use return?", "author": "kokosing", "createdAt": "2020-05-19T08:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYwMzU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNDA2NQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427104065", "bodyText": "The schema of this table is:\nrole_nane | grantor | grantor_type | grantee | grantee_type | is_grantable\n\nIs this how it is defined in standard? Does standard defines types for these columns? Do we use same column types?", "author": "kokosing", "createdAt": "2020-05-19T07:59:55Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/HiveMetadata.java", "diffHunk": "@@ -2346,6 +2346,12 @@ public void dropRole(ConnectorSession session, String role)\n         return accessControlMetadata.listRoles(session);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwODYyMw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427408623", "bodyText": "ROLE_NAME, GRANTEE, and GRANTOR are defined as INFORMATION_SCHEMA.SQL_IDENTIFIER (which looks like it's not defined in the copy of the standard I have).\nI think we should go by the other tables we have (ROLES, APPLICABLE_ROLES, ENABLED_ROLES), which use VARCHAR as I have done here.\nThe standard does not have grantor_type and grantee_type. This is an artifact Presto (PrestoPrincipals can be USER or ROLE). We need those to support any connector where USERs and ROLEs are from separate domains, and we have to distinguish them.", "author": "lhofhansl", "createdAt": "2020-05-19T15:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNDA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNTI2OA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427105268", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ImmutableSet.Builder<RoleGrant> result = ImmutableSet.builder();\n          \n          \n            \n                    result.addAll(listRoleGrantsSanitized().stream()\n          \n          \n            \n                            .filter(grant -> grant.getRoleName().equals(role))\n          \n          \n            \n                            .collect(toSet()));\n          \n          \n            \n                    return result.build();\n          \n          \n            \n                    return listRoleGrantsSanitized().stream()\n          \n          \n            \n                            .filter(grant -> grant.getRoleName().equals(role))\n          \n          \n            \n                            .collect(toImmutableSet());", "author": "kokosing", "createdAt": "2020-05-19T08:01:52Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/file/FileHiveMetastore.java", "diffHunk": "@@ -814,6 +814,16 @@ public synchronized void revokeRoles(Set<String> roles, Set<HivePrincipal> grant\n         }\n     }\n \n+    @Override\n+    public synchronized Set<RoleGrant> listGrantedPrincipals(String role)\n+    {\n+        ImmutableSet.Builder<RoleGrant> result = ImmutableSet.builder();\n+        result.addAll(listRoleGrantsSanitized().stream()\n+                .filter(grant -> grant.getRoleName().equals(role))\n+                .collect(toSet()));\n+        return result.build();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNzk5NQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427417995", "bodyText": "I was going by listRoleGrants below. :)  I'll change them both.", "author": "lhofhansl", "createdAt": "2020-05-19T16:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNTI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1ODI2NA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427558264", "bodyText": "Done", "author": "lhofhansl", "createdAt": "2020-05-19T19:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNTI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNTYxOA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427105618", "bodyText": "s/resp/response", "author": "kokosing", "createdAt": "2020-05-19T08:02:26Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/thrift/ThriftHiveMetastoreClient.java", "diffHunk": "@@ -418,6 +420,15 @@ private void removeGrant(String role, String granteeName, PrincipalType granteeT\n         }\n     }\n \n+    @Override\n+    public List<RolePrincipalGrant> listGrantedPrincipals(String role)\n+            throws TException\n+    {\n+        GetPrincipalsInRoleRequest request = new GetPrincipalsInRoleRequest(role);\n+        GetPrincipalsInRoleResponse resp = client.get_principals_in_role(request);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1ODIyMQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427558221", "bodyText": "Done", "author": "lhofhansl", "createdAt": "2020-05-19T19:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNTYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNjI5NA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427106294", "bodyText": "rename this variable to match the value it holds", "author": "kokosing", "createdAt": "2020-05-19T08:03:36Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/security/SqlStandardAccessControl.java", "diffHunk": "@@ -95,6 +95,7 @@\n     public static final String ADMIN_ROLE_NAME = \"admin\";\n     private static final String INFORMATION_SCHEMA_NAME = \"information_schema\";\n     private static final SchemaTableName ROLES = new SchemaTableName(INFORMATION_SCHEMA_NAME, \"roles\");\n+    private static final SchemaTableName ROLE_GRANTS = new SchemaTableName(INFORMATION_SCHEMA_NAME, \"role_authorization_descriptors\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1ODE1NA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427558154", "bodyText": "Done", "author": "lhofhansl", "createdAt": "2020-05-19T19:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNzkyNA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427107924", "bodyText": "use some constant for \"public\". There should be some already.", "author": "kokosing", "createdAt": "2020-05-19T08:06:23Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/security/SqlStandardAccessControlMetadata.java", "diffHunk": "@@ -84,6 +87,62 @@ private static void checkRoleIsNotReserved(String role)\n         return ImmutableSet.copyOf(metastore.listRoles());\n     }\n \n+    @Override\n+    public Set<RoleGrant> listAllRoleGrants(ConnectorSession session, Optional<Set<String>> roles, Optional<Set<String>> grantees, OptionalLong limit)\n+    {\n+        /*\n+         * The Hive Metadata interface provides us with two ways to retrieve role grants:\n+         * 1. principals by single role\n+         * 2. roles by single principal\n+         *\n+         * We check the passed predicates to decide which path is most optimal.\n+         */\n+        if (roles.isPresent() && grantees.isPresent()) {\n+            if (roles.get().size() <= grantees.get().size() * 2) {\n+                // 2x because for the grantees we do not know the grantee type (ROLE or USER)\n+                grantees = Optional.empty();\n+            }\n+            else {\n+                roles = Optional.empty();\n+            }\n+        }\n+\n+        ImmutableSet.Builder<RoleGrant> builder = ImmutableSet.builder();\n+        long count = 0;\n+        if (grantees.isPresent()) {\n+            TOP:\n+            for (String grantee : grantees.get()) {\n+                for (PrincipalType type : new PrincipalType[]{USER, ROLE}) {\n+                    for (RoleGrant grant : metastore.listRoleGrants(new HivePrincipal(type, grantee))) {\n+                        if (limit.isPresent() && count >= limit.getAsLong()) {\n+                            break TOP;\n+                        }\n+                        // Filter out the \"public\" role since it is not explicitly granted in Hive.\n+                        if (\"public\".equals(grant.getRoleName())) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNDI5Mg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427434292", "bodyText": "The trick is that we absolutely need to honor the limit the first time it hits. Each loop here is a roundtrip to the metastore (that's why the logic is a bit convoluted with the break label).\nI could pass the builder to a method and that method returns a boolean to indicate whether we had hit the limit or not (so that the outer loops knows it's done).\nNot sure that is much prettier. At least with the behavior is explicit. Lemme mull over that a bit more.", "author": "lhofhansl", "createdAt": "2020-05-19T16:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNzkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NDkxNA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427444914", "bodyText": "On \"public\". Honestly, none that I could find. The \"public\" string is all over the place in the Hive connector. There're private constants iniThriftMetastoreUtil, I could make those public.", "author": "lhofhansl", "createdAt": "2020-05-19T16:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNzkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1ODA1OQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427558059", "bodyText": "Added a constant to this class at least.", "author": "lhofhansl", "createdAt": "2020-05-19T19:48:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNzkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1ODU0MA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427558540", "bodyText": "Cleaned up the logic too, extracted methods, etc.", "author": "lhofhansl", "createdAt": "2020-05-19T19:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNzkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwODQ0Mw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427108443", "bodyText": "please extract one method for collecting output for grantees and one method for roles", "author": "kokosing", "createdAt": "2020-05-19T08:07:16Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/security/SqlStandardAccessControlMetadata.java", "diffHunk": "@@ -84,6 +87,62 @@ private static void checkRoleIsNotReserved(String role)\n         return ImmutableSet.copyOf(metastore.listRoles());\n     }\n \n+    @Override\n+    public Set<RoleGrant> listAllRoleGrants(ConnectorSession session, Optional<Set<String>> roles, Optional<Set<String>> grantees, OptionalLong limit)\n+    {\n+        /*\n+         * The Hive Metadata interface provides us with two ways to retrieve role grants:\n+         * 1. principals by single role\n+         * 2. roles by single principal\n+         *\n+         * We check the passed predicates to decide which path is most optimal.\n+         */\n+        if (roles.isPresent() && grantees.isPresent()) {\n+            if (roles.get().size() <= grantees.get().size() * 2) {\n+                // 2x because for the grantees we do not know the grantee type (ROLE or USER)\n+                grantees = Optional.empty();\n+            }\n+            else {\n+                roles = Optional.empty();\n+            }\n+        }\n+\n+        ImmutableSet.Builder<RoleGrant> builder = ImmutableSet.builder();\n+        long count = 0;\n+        if (grantees.isPresent()) {\n+            TOP:\n+            for (String grantee : grantees.get()) {\n+                for (PrincipalType type : new PrincipalType[]{USER, ROLE}) {\n+                    for (RoleGrant grant : metastore.listRoleGrants(new HivePrincipal(type, grantee))) {\n+                        if (limit.isPresent() && count >= limit.getAsLong()) {\n+                            break TOP;\n+                        }\n+                        // Filter out the \"public\" role since it is not explicitly granted in Hive.\n+                        if (\"public\".equals(grant.getRoleName())) {\n+                            continue;\n+                        }\n+                        count++;\n+                        builder.add(grant);\n+                    }\n+                }\n+            }\n+            return builder.build();\n+        }\n+\n+        // if no roles or grantees were passed get a list of roles from the metastore\n+        for (String role : roles.orElseGet(() -> metastore.listRoles())) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1Nzg3OA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427557878", "bodyText": "Done.", "author": "lhofhansl", "createdAt": "2020-05-19T19:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwODQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwODczMw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427108733", "bodyText": "update test name to match role_authorization_descriptors", "author": "kokosing", "createdAt": "2020-05-19T08:07:45Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveIntegrationSmokeTest.java", "diffHunk": "@@ -4973,6 +4973,87 @@ public void testShowColumnMetadata()\n         assertUpdate(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test\n+    public void testRoleGrants()", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1NzgyMw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427557823", "bodyText": "Done", "author": "lhofhansl", "createdAt": "2020-05-19T19:47:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwODczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwOTA1MQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427109051", "bodyText": "Please add some test with LIMIT", "author": "kokosing", "createdAt": "2020-05-19T08:08:16Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveIntegrationSmokeTest.java", "diffHunk": "@@ -4973,6 +4973,87 @@ public void testShowColumnMetadata()\n         assertUpdate(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test\n+    public void testRoleGrants()\n+    {\n+        Session user = testSessionBuilder()\n+                .setCatalog(getSession().getCatalog().get())\n+                .setIdentity(Identity.forUser(\"user\").withPrincipal(getSession().getIdentity().getPrincipal()).build())\n+                .build();\n+\n+        assertUpdate(\"CREATE ROLE test_role_grant1\");\n+        assertUpdate(\"CREATE ROLE test_role_grant2\");\n+        assertUpdate(\"CREATE ROLE test_role_grant3\");\n+\n+        // nothing showing because no roles have been granted\n+        assertQueryReturnsEmptyResult(\"SELECT * FROM information_schema.role_authorization_descriptors\");\n+\n+        // role_authorization_descriptors is not accessible for a non-admin user, even when it's empty\n+        assertQueryFails(user, \"SELECT * FROM information_schema.role_authorization_descriptors\",\n+                \"Access Denied: Cannot select from table information_schema.role_authorization_descriptors\");\n+\n+        assertUpdate(\"GRANT test_role_grant1 TO USER user\");\n+        // user with same name as a role\n+        assertUpdate(\"GRANT test_role_grant2 TO USER test_role_grant1\");\n+        assertUpdate(\"GRANT test_role_grant2 TO USER user1 WITH ADMIN OPTION\");\n+        assertUpdate(\"GRANT test_role_grant2 TO USER user2\");\n+        assertUpdate(\"GRANT test_role_grant2 TO ROLE test_role_grant1\");\n+\n+        // role_authorization_descriptors is not accessible for a non-admin user\n+        assertQueryFails(user, \"SELECT * FROM information_schema.role_authorization_descriptors\",\n+                \"Access Denied: Cannot select from table information_schema.role_authorization_descriptors\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors\",\n+                \"VALUES \" +\n+                        \"('test_role_grant2', null, null, 'test_role_grant1', 'ROLE', 'NO'),\" +\n+                        \"('test_role_grant2', null, null, 'user2', 'USER', 'NO'),\" +\n+                        \"('test_role_grant2', null, null, 'user1', 'USER', 'YES'),\" +\n+                        \"('test_role_grant2', null, null, 'test_role_grant1', 'USER', 'NO'),\" +\n+                        \"('test_role_grant1', null, null, 'user', 'USER', 'NO')\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors WHERE role_name = 'test_role_grant2'\",\n+                \"VALUES \" +\n+                        \"('test_role_grant2', null, null, 'test_role_grant1', 'USER', 'NO'),\" +\n+                        \"('test_role_grant2', null, null, 'test_role_grant1', 'ROLE', 'NO'),\" +\n+                        \"('test_role_grant2', null, null, 'user1', 'USER', 'YES'),\" +\n+                        \"('test_role_grant2', null, null, 'user2', 'USER', 'NO')\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors WHERE grantee = 'user'\",\n+                \"VALUES ('test_role_grant1', null, null, 'user', 'USER', 'NO')\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors WHERE grantee like 'user%'\",\n+                \"VALUES \" +\n+                        \"('test_role_grant1', null, null, 'user', 'USER', 'NO'),\" +\n+                        \"('test_role_grant2', null, null, 'user2', 'USER', 'NO'),\" +\n+                        \"('test_role_grant2', null, null, 'user1', 'USER', 'YES')\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors WHERE grantee = 'test_role_grant1'\",\n+                \"VALUES \" +\n+                        \"('test_role_grant2', null, null, 'test_role_grant1', 'ROLE', 'NO'),\" +\n+                        \"('test_role_grant2', null, null, 'test_role_grant1', 'USER', 'NO')\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors WHERE grantee = 'test_role_grant1' AND grantee_type = 'USER'\",\n+                \"VALUES ('test_role_grant2', null, null, 'test_role_grant1', 'USER', 'NO')\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors WHERE grantee = 'test_role_grant1' AND grantee_type = 'ROLE'\",\n+                \"VALUES ('test_role_grant2', null, null, 'test_role_grant1', 'ROLE', 'NO')\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors WHERE grantee_type = 'ROLE'\",\n+                \"VALUES ('test_role_grant2', null, null, 'test_role_grant1', 'ROLE', 'NO')\");\n+", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1NzcxMA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427557710", "bodyText": "Done", "author": "lhofhansl", "createdAt": "2020-05-19T19:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwOTA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMDA5NA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427110094", "bodyText": "It would be nice to have these defined in RoleGrant, but being unused currently. So other connector implementations could benefit from that.", "author": "kokosing", "createdAt": "2020-05-19T08:10:01Z", "path": "presto-main/src/main/java/io/prestosql/connector/informationschema/InformationSchemaPageSource.java", "diffHunk": "@@ -346,13 +355,35 @@ private void addRolesRecords()\n         }\n     }\n \n+    private void addRoleAuthorizationDescriptorRecords()\n+    {\n+        try {\n+            accessControl.checkCanShowRoles(session.toSecurityContext(), catalogName);\n+        }\n+        catch (AccessDeniedException exception) {\n+            return;\n+        }\n+\n+        for (RoleGrant grant : metadata.listAllRoleGrants(session, catalogName, roles, grantees, limit)) {\n+            addRecord(\n+                    grant.getRoleName(),\n+                    null, // grantor", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMDYzNQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427410635", "bodyText": "Let's do that in a separate PR if that's ok.", "author": "lhofhansl", "createdAt": "2020-05-19T15:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMDA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMDQ0Nw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427110447", "bodyText": "I think we need dedicated access control method for that.", "author": "kokosing", "createdAt": "2020-05-19T08:10:37Z", "path": "presto-main/src/main/java/io/prestosql/connector/informationschema/InformationSchemaPageSource.java", "diffHunk": "@@ -346,13 +355,35 @@ private void addRolesRecords()\n         }\n     }\n \n+    private void addRoleAuthorizationDescriptorRecords()\n+    {\n+        try {\n+            accessControl.checkCanShowRoles(session.toSecurityContext(), catalogName);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMjcxOA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427412718", "bodyText": "I was thinking about that. Personally I thought there's access to roles or not.\nOne could argue that access to ROLE_AUTHORIZATION_DESCRIPTORS is a superset access right (I can get the list of roles from that table as well.)\nSeparate access rights seems a bit overkill - happy to put it in if you feel strongly, though.", "author": "lhofhansl", "createdAt": "2020-05-19T15:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMDQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczODUxNg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427738516", "bodyText": "Presto SPI do not assume much about authorization system implementation. Having separate method allows it to decide how it should behave. I would prefer to have separate method.", "author": "kokosing", "createdAt": "2020-05-20T04:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMDQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIzNjU2OA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r428236568", "bodyText": "OK... Added that.", "author": "lhofhansl", "createdAt": "2020-05-20T18:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExMDQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNDY1Mw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427114653", "bodyText": "I don't think we should do such ifs. I would prefer to try to update prefixes and grantees always. And if any of them is not changed return Optional.empty() (as it was before).", "author": "kokosing", "createdAt": "2020-05-19T08:17:23Z", "path": "presto-main/src/main/java/io/prestosql/connector/informationschema/InformationSchemaMetadata.java", "diffHunk": "@@ -191,19 +195,24 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n     {\n         InformationSchemaTableHandle table = (InformationSchemaTableHandle) handle;\n \n-        if (!isTablesEnumeratingTable(table.getTable()) || !table.getPrefixes().equals(defaultPrefixes(catalogName))) {\n-            return Optional.empty();\n+        Optional<Set<String>> roles = table.getRoles();\n+        Optional<Set<String>> grantees = table.getGrantees();\n+        if (ROLE_AUTHORIZATION_DESCRIPTORS.equals(table.getTable()) && table.getRoles().isEmpty() && table.getGrantees().isEmpty()) {\n+            roles = calculateRoles(session, constraint.getSummary(), constraint.predicate());\n+            grantees = calculateGrantees(session, constraint.getSummary(), constraint.predicate());\n         }\n \n-        Set<QualifiedTablePrefix> prefixes = getPrefixes(session, table, constraint);\n-\n-        if (prefixes.equals(table.getPrefixes())) {\n-            return Optional.empty();\n+        Set<QualifiedTablePrefix> prefixes = table.getPrefixes();\n+        if (isTablesEnumeratingTable(table.getTable()) && table.getPrefixes().equals(defaultPrefixes(catalogName))) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzMDE4NQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427430185", "bodyText": "Agreed. Much better.", "author": "lhofhansl", "createdAt": "2020-05-19T16:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNDY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU1NzU3OA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427557578", "bodyText": "Done.", "author": "lhofhansl", "createdAt": "2020-05-19T19:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNDY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNjIxNg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427116216", "bodyText": "Do we have a tests that covers cases like filter(limit(scan) and limit(filter(scan)). In other words I think we should consider banning filter pushdown if there is already limit applied as I guess it is buggy today.", "author": "kokosing", "createdAt": "2020-05-19T08:19:59Z", "path": "presto-main/src/main/java/io/prestosql/connector/informationschema/InformationSchemaMetadata.java", "diffHunk": "@@ -182,7 +186,7 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n         }\n \n         return Optional.of(new LimitApplicationResult<>(", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxNDk1MA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427414950", "bodyText": "That's something I wanted to ask. It seems we can push down either a filter or a limit, but not both.\nI debugged it and found that the framework is doing the right thing. When a filter is present it does not push the limit down (i.e. does not call applyLimit) and vice versa. So that works fine, and I assume the \"framework\" has tests for that.", "author": "lhofhansl", "createdAt": "2020-05-19T15:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNjIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjM5NA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427736394", "bodyText": "Framework might have such tests but for regular tables. I think we need to add new ones for information_schema tables.", "author": "kokosing", "createdAt": "2020-05-20T04:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNjIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyODI4Ng==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427728286", "bodyText": "Use ImmutableSet.toImmutableSet(), then there is no need to use Builder.", "author": "kokosing", "createdAt": "2020-05-20T04:01:12Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/file/FileHiveMetastore.java", "diffHunk": "@@ -814,6 +814,16 @@ public synchronized void revokeRoles(Set<String> roles, Set<HivePrincipal> grant\n         }\n     }\n \n+    @Override\n+    public synchronized Set<RoleGrant> listGrantedPrincipals(String role)\n+    {\n+        ImmutableSet.Builder<RoleGrant> result = ImmutableSet.builder();\n+        result.addAll(listRoleGrantsSanitized().stream()\n+                .filter(grant -> grant.getRoleName().equals(role))\n+                .collect(toUnmodifiableSet()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyODcwOQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427728709", "bodyText": "This is unrelated to the change so it should go as separate commit.\nInstead collect and addAll I would use forEach(result::add)", "author": "kokosing", "createdAt": "2020-05-20T04:03:15Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/metastore/file/FileHiveMetastore.java", "diffHunk": "@@ -826,7 +836,7 @@ public synchronized void revokeRoles(Set<String> roles, Set<HivePrincipal> grant\n         }\n         result.addAll(listRoleGrantsSanitized().stream()\n                 .filter(grant -> HivePrincipal.from(grant.getGrantee()).equals(principal))\n-                .collect(toSet()));\n+                .collect(toUnmodifiableSet()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMDE2NQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427730165", "bodyText": "you should verify limit before doing a call to HMS (in outer loop), then you could simply use break.", "author": "kokosing", "createdAt": "2020-05-20T04:09:49Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/security/SqlStandardAccessControlMetadata.java", "diffHunk": "@@ -84,6 +88,69 @@ private static void checkRoleIsNotReserved(String role)\n         return ImmutableSet.copyOf(metastore.listRoles());\n     }\n \n+    @Override\n+    public Set<RoleGrant> listAllRoleGrants(ConnectorSession session, Optional<Set<String>> roles, Optional<Set<String>> grantees, OptionalLong limit)\n+    {\n+        /*\n+         * The Hive Metadata interface provides us with two ways to retrieve role grants:\n+         * 1. principals by single role\n+         * 2. roles by single principal\n+         *\n+         * We check the passed predicates to decide which path is most optimal.\n+         */\n+        if (grantees.isPresent()) {\n+            if (roles.isPresent() && roles.get().size() <= grantees.get().size() * 2) {\n+                // 2x because for the grantees we do not know the grantee type (ROLE or USER)\n+                return getRoleGrantsByRoles(roles.get(), limit);\n+            }\n+            else {\n+                return getRoleGrantsByGrantees(grantees.get(), limit);\n+            }\n+        }\n+        else {\n+            // if roles are present use those, otherwise get a list of roles from the metastore\n+            return getRoleGrantsByRoles(roles.orElseGet(() -> metastore.listRoles()), limit);\n+        }\n+    }\n+\n+    private Set<RoleGrant> getRoleGrantsByGrantees(Set<String> grantees, OptionalLong limit)\n+    {\n+        ImmutableSet.Builder<RoleGrant> builder = ImmutableSet.builder();\n+        int count = 0;\n+        for (String grantee : grantees) {\n+            for (PrincipalType type : new PrincipalType[]{USER, ROLE}) {\n+                for (RoleGrant grant : metastore.listRoleGrants(new HivePrincipal(type, grantee))) {\n+                    if (limit.isPresent() && count >= limit.getAsLong()) {\n+                        return builder.build();\n+                    }\n+                    // Filter out the \"public\" role since it is not explicitly granted in Hive.\n+                    if (PUBLIC_ROLE_NAME.equals(grant.getRoleName())) {\n+                        continue;\n+                    }\n+                    count++;\n+                    builder.add(grant);\n+                }\n+            }\n+        }\n+        return builder.build();\n+    }\n+\n+    private Set<RoleGrant> getRoleGrantsByRoles(Set<String> roles, OptionalLong limit)\n+    {\n+        ImmutableSet.Builder<RoleGrant> builder = ImmutableSet.builder();\n+        int count = 0;\n+        for (String role : roles) {\n+            for (RoleGrant grant : metastore.listGrantedPrincipals(role)) {\n+                if (limit.isPresent() && count >= limit.getAsLong()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyODczNg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r428128736", "bodyText": "Oops. That's embarrassing. :(", "author": "lhofhansl", "createdAt": "2020-05-20T16:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMDE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMDQwMA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427730400", "bodyText": "you should verify limit before doing a call to HMS (in the middle loop)", "author": "kokosing", "createdAt": "2020-05-20T04:10:42Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/security/SqlStandardAccessControlMetadata.java", "diffHunk": "@@ -84,6 +88,69 @@ private static void checkRoleIsNotReserved(String role)\n         return ImmutableSet.copyOf(metastore.listRoles());\n     }\n \n+    @Override\n+    public Set<RoleGrant> listAllRoleGrants(ConnectorSession session, Optional<Set<String>> roles, Optional<Set<String>> grantees, OptionalLong limit)\n+    {\n+        /*\n+         * The Hive Metadata interface provides us with two ways to retrieve role grants:\n+         * 1. principals by single role\n+         * 2. roles by single principal\n+         *\n+         * We check the passed predicates to decide which path is most optimal.\n+         */\n+        if (grantees.isPresent()) {\n+            if (roles.isPresent() && roles.get().size() <= grantees.get().size() * 2) {\n+                // 2x because for the grantees we do not know the grantee type (ROLE or USER)\n+                return getRoleGrantsByRoles(roles.get(), limit);\n+            }\n+            else {\n+                return getRoleGrantsByGrantees(grantees.get(), limit);\n+            }\n+        }\n+        else {\n+            // if roles are present use those, otherwise get a list of roles from the metastore\n+            return getRoleGrantsByRoles(roles.orElseGet(() -> metastore.listRoles()), limit);\n+        }\n+    }\n+\n+    private Set<RoleGrant> getRoleGrantsByGrantees(Set<String> grantees, OptionalLong limit)\n+    {\n+        ImmutableSet.Builder<RoleGrant> builder = ImmutableSet.builder();\n+        int count = 0;\n+        for (String grantee : grantees) {\n+            for (PrincipalType type : new PrincipalType[]{USER, ROLE}) {\n+                for (RoleGrant grant : metastore.listRoleGrants(new HivePrincipal(type, grantee))) {\n+                    if (limit.isPresent() && count >= limit.getAsLong()) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyODc4OQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r428128789", "bodyText": "Same as above... A bit embarrassing.", "author": "lhofhansl", "createdAt": "2020-05-20T16:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMDQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMDQ5OQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427730499", "bodyText": "s/builder/roleGrants", "author": "kokosing", "createdAt": "2020-05-20T04:11:12Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/security/SqlStandardAccessControlMetadata.java", "diffHunk": "@@ -84,6 +88,69 @@ private static void checkRoleIsNotReserved(String role)\n         return ImmutableSet.copyOf(metastore.listRoles());\n     }\n \n+    @Override\n+    public Set<RoleGrant> listAllRoleGrants(ConnectorSession session, Optional<Set<String>> roles, Optional<Set<String>> grantees, OptionalLong limit)\n+    {\n+        /*\n+         * The Hive Metadata interface provides us with two ways to retrieve role grants:\n+         * 1. principals by single role\n+         * 2. roles by single principal\n+         *\n+         * We check the passed predicates to decide which path is most optimal.\n+         */\n+        if (grantees.isPresent()) {\n+            if (roles.isPresent() && roles.get().size() <= grantees.get().size() * 2) {\n+                // 2x because for the grantees we do not know the grantee type (ROLE or USER)\n+                return getRoleGrantsByRoles(roles.get(), limit);\n+            }\n+            else {\n+                return getRoleGrantsByGrantees(grantees.get(), limit);\n+            }\n+        }\n+        else {\n+            // if roles are present use those, otherwise get a list of roles from the metastore\n+            return getRoleGrantsByRoles(roles.orElseGet(() -> metastore.listRoles()), limit);\n+        }\n+    }\n+\n+    private Set<RoleGrant> getRoleGrantsByGrantees(Set<String> grantees, OptionalLong limit)\n+    {\n+        ImmutableSet.Builder<RoleGrant> builder = ImmutableSet.builder();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMDUyMw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427730523", "bodyText": "s/builder/roleGrants", "author": "kokosing", "createdAt": "2020-05-20T04:11:17Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/security/SqlStandardAccessControlMetadata.java", "diffHunk": "@@ -84,6 +88,69 @@ private static void checkRoleIsNotReserved(String role)\n         return ImmutableSet.copyOf(metastore.listRoles());\n     }\n \n+    @Override\n+    public Set<RoleGrant> listAllRoleGrants(ConnectorSession session, Optional<Set<String>> roles, Optional<Set<String>> grantees, OptionalLong limit)\n+    {\n+        /*\n+         * The Hive Metadata interface provides us with two ways to retrieve role grants:\n+         * 1. principals by single role\n+         * 2. roles by single principal\n+         *\n+         * We check the passed predicates to decide which path is most optimal.\n+         */\n+        if (grantees.isPresent()) {\n+            if (roles.isPresent() && roles.get().size() <= grantees.get().size() * 2) {\n+                // 2x because for the grantees we do not know the grantee type (ROLE or USER)\n+                return getRoleGrantsByRoles(roles.get(), limit);\n+            }\n+            else {\n+                return getRoleGrantsByGrantees(grantees.get(), limit);\n+            }\n+        }\n+        else {\n+            // if roles are present use those, otherwise get a list of roles from the metastore\n+            return getRoleGrantsByRoles(roles.orElseGet(() -> metastore.listRoles()), limit);\n+        }\n+    }\n+\n+    private Set<RoleGrant> getRoleGrantsByGrantees(Set<String> grantees, OptionalLong limit)\n+    {\n+        ImmutableSet.Builder<RoleGrant> builder = ImmutableSet.builder();\n+        int count = 0;\n+        for (String grantee : grantees) {\n+            for (PrincipalType type : new PrincipalType[]{USER, ROLE}) {\n+                for (RoleGrant grant : metastore.listRoleGrants(new HivePrincipal(type, grantee))) {\n+                    if (limit.isPresent() && count >= limit.getAsLong()) {\n+                        return builder.build();\n+                    }\n+                    // Filter out the \"public\" role since it is not explicitly granted in Hive.\n+                    if (PUBLIC_ROLE_NAME.equals(grant.getRoleName())) {\n+                        continue;\n+                    }\n+                    count++;\n+                    builder.add(grant);\n+                }\n+            }\n+        }\n+        return builder.build();\n+    }\n+\n+    private Set<RoleGrant> getRoleGrantsByRoles(Set<String> roles, OptionalLong limit)\n+    {\n+        ImmutableSet.Builder<RoleGrant> builder = ImmutableSet.builder();", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMjIyNg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427732226", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /*\n          \n          \n            \n                     * The Hive Metadata interface provides us with two ways to retrieve role grants:\n          \n          \n            \n                     * 1. principals by single role\n          \n          \n            \n                     * 2. roles by single principal\n          \n          \n            \n                     *\n          \n          \n            \n                     * We check the passed predicates to decide which path is most optimal.\n          \n          \n            \n                     */\n          \n          \n            \n                    if (grantees.isPresent()) {\n          \n          \n            \n                        if (roles.isPresent() && roles.get().size() <= grantees.get().size() * 2) {\n          \n          \n            \n                            // 2x because for the grantees we do not know the grantee type (ROLE or USER)\n          \n          \n            \n                            return getRoleGrantsByRoles(roles.get(), limit);\n          \n          \n            \n                        }\n          \n          \n            \n                        else {\n          \n          \n            \n                            return getRoleGrantsByGrantees(grantees.get(), limit);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    else {\n          \n          \n            \n                        // if roles are present use those, otherwise get a list of roles from the metastore\n          \n          \n            \n                        return getRoleGrantsByRoles(roles.orElseGet(() -> metastore.listRoles()), limit);\n          \n          \n            \n                    }\n          \n          \n            \n                    Set<String> actualRoles = roles.orElseGet(() -> metastore.listRoles());\n          \n          \n            \n                  \n          \n          \n            \n                    // choose more efficient path\n          \n          \n            \n                    if (grantees.isPresent() && actualRoles.size() > grantees.get().size() * 2) {\n          \n          \n            \n                            // 2x because we check two grantee types (ROLE or USER)\n          \n          \n            \n                            return getRoleGrantsByGrantees(grantees.get(), limit);\n          \n          \n            \n                    }\n          \n          \n            \n                    return getRoleGrantsByRoles(actualRoles, limit);", "author": "kokosing", "createdAt": "2020-05-20T04:18:29Z", "path": "presto-hive/src/main/java/io/prestosql/plugin/hive/security/SqlStandardAccessControlMetadata.java", "diffHunk": "@@ -84,6 +88,69 @@ private static void checkRoleIsNotReserved(String role)\n         return ImmutableSet.copyOf(metastore.listRoles());\n     }\n \n+    @Override\n+    public Set<RoleGrant> listAllRoleGrants(ConnectorSession session, Optional<Set<String>> roles, Optional<Set<String>> grantees, OptionalLong limit)\n+    {\n+        /*\n+         * The Hive Metadata interface provides us with two ways to retrieve role grants:\n+         * 1. principals by single role\n+         * 2. roles by single principal\n+         *\n+         * We check the passed predicates to decide which path is most optimal.\n+         */\n+        if (grantees.isPresent()) {\n+            if (roles.isPresent() && roles.get().size() <= grantees.get().size() * 2) {\n+                // 2x because for the grantees we do not know the grantee type (ROLE or USER)\n+                return getRoleGrantsByRoles(roles.get(), limit);\n+            }\n+            else {\n+                return getRoleGrantsByGrantees(grantees.get(), limit);\n+            }\n+        }\n+        else {\n+            // if roles are present use those, otherwise get a list of roles from the metastore\n+            return getRoleGrantsByRoles(roles.orElseGet(() -> metastore.listRoles()), limit);\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExMTQ3Ng==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r428111476", "bodyText": "That leads to a possibly unnecessary call to the HMS, though.", "author": "lhofhansl", "createdAt": "2020-05-20T15:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMjIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNDM4Nw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r428124387", "bodyText": "On the other hand it's a nice safety check to upper bind the number to RPC to no more that Roles+1. So I'll do that indeed.", "author": "lhofhansl", "createdAt": "2020-05-20T15:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMjIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMzE4OQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427733189", "bodyText": "use LIMIT 5", "author": "kokosing", "createdAt": "2020-05-20T04:22:29Z", "path": "presto-hive/src/test/java/io/prestosql/plugin/hive/TestHiveIntegrationSmokeTest.java", "diffHunk": "@@ -4973,6 +4973,113 @@ public void testShowColumnMetadata()\n         assertUpdate(\"DROP TABLE \" + tableName);\n     }\n \n+    @Test\n+    public void testRoleAuthorizationDescriptors()\n+    {\n+        Session user = testSessionBuilder()\n+                .setCatalog(getSession().getCatalog().get())\n+                .setIdentity(Identity.forUser(\"user\").withPrincipal(getSession().getIdentity().getPrincipal()).build())\n+                .build();\n+\n+        assertUpdate(\"CREATE ROLE test_r_a_d1\");\n+        assertUpdate(\"CREATE ROLE test_r_a_d2\");\n+        assertUpdate(\"CREATE ROLE test_r_a_d3\");\n+\n+        // nothing showing because no roles have been granted\n+        assertQueryReturnsEmptyResult(\"SELECT * FROM information_schema.role_authorization_descriptors\");\n+\n+        // role_authorization_descriptors is not accessible for a non-admin user, even when it's empty\n+        assertQueryFails(user, \"SELECT * FROM information_schema.role_authorization_descriptors\",\n+                \"Access Denied: Cannot select from table information_schema.role_authorization_descriptors\");\n+\n+        assertUpdate(\"GRANT test_r_a_d1 TO USER user\");\n+        // user with same name as a role\n+        assertUpdate(\"GRANT test_r_a_d2 TO USER test_r_a_d1\");\n+        assertUpdate(\"GRANT test_r_a_d2 TO USER user1 WITH ADMIN OPTION\");\n+        assertUpdate(\"GRANT test_r_a_d2 TO USER user2\");\n+        assertUpdate(\"GRANT test_r_a_d2 TO ROLE test_r_a_d1\");\n+\n+        // role_authorization_descriptors is not accessible for a non-admin user\n+        assertQueryFails(user, \"SELECT * FROM information_schema.role_authorization_descriptors\",\n+                \"Access Denied: Cannot select from table information_schema.role_authorization_descriptors\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors\",\n+                \"VALUES \" +\n+                        \"('test_r_a_d2', null, null, 'test_r_a_d1', 'ROLE', 'NO'),\" +\n+                        \"('test_r_a_d2', null, null, 'user2', 'USER', 'NO'),\" +\n+                        \"('test_r_a_d2', null, null, 'user1', 'USER', 'YES'),\" +\n+                        \"('test_r_a_d2', null, null, 'test_r_a_d1', 'USER', 'NO'),\" +\n+                        \"('test_r_a_d1', null, null, 'user', 'USER', 'NO')\");\n+\n+        assertQuery(\n+                \"SELECT * FROM information_schema.role_authorization_descriptors LIMIT 1000000000\",", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExMTgzMg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r428111832", "bodyText": "I tried specifically with a very large number to make sure it does not cause any issues.", "author": "lhofhansl", "createdAt": "2020-05-20T15:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMzE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczOTMzOQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427739339", "bodyText": "Do you think it is doable to implement predicate and limit pushdown only here (instead of SqlStandardAccessControlMetadata)? That way it will out of the box for any other connectors or even for any access control metadata in hive. That would possibly require adding different methods to metadata (more granular ones).\nWDYT?", "author": "kokosing", "createdAt": "2020-05-20T04:49:53Z", "path": "presto-main/src/main/java/io/prestosql/connector/informationschema/InformationSchemaPageSource.java", "diffHunk": "@@ -346,13 +355,35 @@ private void addRolesRecords()\n         }\n     }\n \n+    private void addRoleAuthorizationDescriptorRecords()\n+    {\n+        try {\n+            accessControl.checkCanShowRoles(session.toSecurityContext(), catalogName);\n+        }\n+        catch (AccessDeniedException exception) {\n+            return;\n+        }\n+\n+        for (RoleGrant grant : metadata.listAllRoleGrants(session, catalogName, roles, grantees, limit)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNDIzMw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r428114233", "bodyText": "That's what I had first, but @electrum correctly pointed out that this is a vert Hive specific.\nSo in this design here we just pass the predicates down, and then let the Connectors do what's best for them. (For example only HMS has this weird limit that the only APIs are getting Roles by a single Principal, or Principals by a single Role).", "author": "lhofhansl", "createdAt": "2020-05-20T15:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczOTMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxODA1MQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r430218051", "bodyText": "I see, but I am afraid that we went to far with this being too much hive specific and so it can be difficult in future to reuse it as one might need to reimplement predicate pushdown in the one use case.\n\nHMS has this weird limit that the only APIs are getting Roles by a single Principal, or Principals by a single Role\n\nCould expose this in Connector metadata SPI? I would imagine that in future we could also have batch version of these methods. In case when batch version is not implemented (like in Hive) we could fallback to using methods to access roles for given principal or principals for given role.\nWDYT?", "author": "kokosing", "createdAt": "2020-05-26T07:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczOTMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyNDc0OA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r431424748", "bodyText": "ConnectorMetadata has now two relevant methods: (1) list all roles, and (2) list all role grants (with optional filter criteria).\nI think connectors will be quite different on this front. Databases (Postgres, Oracel, MySQL, Phoenix, etc) have their own information_schema and the connector would just turn this into a query on their information_schema in that case we'd want to pass the predicate through (both on role and principal).\nOthers (like Hive) have limited and different APIs, and that needs some logic to be \"optimal\". Yet, other connectors have other way to query their role metadata.\nBoth methods may or may not be batched, but it's completely hidden now. The connector decides how to implement them. Note that the Hive implementation is completely hidden in the Hive Metadata, and the only part the InformationSchema needs are these two methods to be called. Everything else is automated (extracting the predicate, passing it down, etc)\nIf we do not want to leak Hive specifics into the InformationSchemas code I do not see how to do it fundamentally differently. If I put specific logic any higher than ConnectorMetadata we'd leak the details of Hive up.\nBut maybe I don't understand what you mean...\nPerhaps could outline what methods you would add to ConnectorMetadata, and how would the code in InformationSchemaPageSource use them...?\nThanks!", "author": "lhofhansl", "createdAt": "2020-05-27T20:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczOTMzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1MTI2OQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r431651269", "bodyText": "Thanks!", "author": "kokosing", "createdAt": "2020-05-28T07:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczOTMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczOTg3OQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r427739879", "bodyText": "can you use assertMetadataCalls to make sure that predicate pushdown and limit works.", "author": "kokosing", "createdAt": "2020-05-20T04:52:09Z", "path": "presto-tests/src/test/java/io/prestosql/tests/TestInformationSchemaConnector.java", "diffHunk": "@@ -97,6 +97,17 @@ public void testLimit()\n         assertQuery(\"SELECT count(*) FROM (SELECT * FROM test_catalog.information_schema.tables LIMIT 1000)\", \"VALUES 1000\");\n     }\n \n+    @Test\n+    public void testRoleAuthorizationDescriptor()\n+    {\n+        assertQuery(\"SELECT count(*) FROM test_catalog.information_schema.role_authorization_descriptors\", \"VALUES 100\");\n+        assertQuery(\"SELECT count(*) FROM test_catalog.information_schema.roles\", \"VALUES 50\");\n+        assertQuery(\"SELECT count(*) FROM test_catalog.information_schema.enabled_roles\", \"VALUES 50\");\n+        assertQuery(\"SELECT count(*) FROM test_catalog.information_schema.applicable_roles\", \"VALUES 1\");\n+        assertQuery(\"SELECT role_name FROM test_catalog.information_schema.role_authorization_descriptors WHERE grantee = 'user5'\", \"VALUES ('role2')\");\n+        assertQuery(\"SELECT grantee FROM test_catalog.information_schema.role_authorization_descriptors WHERE role_name = 'role2'\", \"VALUES ('user4'), ('user5')\");", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIzNTk5Nw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r428235997", "bodyText": "Hmm... I'd have to look inside the function calls then (i.e. I'd have to know not only that a function was called, but also what was passed). Let me think about how I'd change the CountingMockConnector to do so.", "author": "lhofhansl", "createdAt": "2020-05-20T18:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczOTg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY0NzAyNg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r431647026", "bodyText": "You might want to invert the condition (just to have less code nested)", "author": "kokosing", "createdAt": "2020-05-28T07:51:47Z", "path": "presto-main/src/main/java/io/prestosql/connector/informationschema/InformationSchemaMetadata.java", "diffHunk": "@@ -242,6 +251,65 @@ public static boolean isTablesEnumeratingTable(InformationSchemaTable table)\n         return ImmutableSet.of(COLUMNS, VIEWS, TABLES, TABLE_PRIVILEGES).contains(table);\n     }\n \n+    private Optional<Set<String>> calculateRoles(\n+            ConnectorSession connectorSession,\n+            TupleDomain<ColumnHandle> constraint,\n+            Optional<Predicate<Map<ColumnHandle, NullableValue>>> predicate)\n+    {\n+        if (constraint.isNone()) {\n+            return Optional.empty();\n+        }\n+\n+        Optional<Set<String>> roles = filterString(constraint, ROLE_NAME_COLUMN_HANDLE);\n+        if (roles.isPresent()) {\n+            Set<String> result = roles.get().stream()\n+                    .filter(this::isLowerCase)\n+                    .filter(role -> !predicate.isPresent() || predicate.get().test(roleAsFixedValues(role)))\n+                    .collect(toImmutableSet());\n+\n+            if (result.isEmpty()) {\n+                return Optional.empty();\n+            }\n+            if (result.size() <= MAX_ROLE_COUNT) {\n+                return Optional.of(result);\n+            }\n+        }\n+\n+        if (!predicate.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        Session session = ((FullConnectorSession) connectorSession).getSession();\n+        return Optional.of(metadata.listRoles(session, catalogName)\n+                .stream()\n+                .filter(role -> predicate.get().test(roleAsFixedValues(role)))\n+                .collect(toImmutableSet()));\n+    }\n+\n+    private Optional<Set<String>> calculateGrantees(\n+            ConnectorSession connectorSession,\n+            TupleDomain<ColumnHandle> constraint,\n+            Optional<Predicate<Map<ColumnHandle, NullableValue>>> predicate)\n+    {\n+        if (constraint.isNone()) {\n+            return Optional.empty();\n+        }\n+\n+        Optional<Set<String>> grantees = filterString(constraint, GRANTEE_COLUMN_HANDLE);\n+        if (grantees.isPresent()) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1MDY5OQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r431650699", "bodyText": "listRowGrantsCallsCounter, rolesPushedCounter, rolesPushedCounter and limitPushedCounter should be grouped into a single bean that represents interaction with metadata call. Typically we had single counter per method, you had 4. Using bean we would maintain having single counter per method, where one counter is just complex.", "author": "kokosing", "createdAt": "2020-05-28T07:58:34Z", "path": "presto-testing/src/main/java/io/prestosql/testing/CountingMockConnector.java", "diffHunk": "@@ -101,6 +121,19 @@ private ConnectorFactory getConnectorFactory()\n                     getColumnsCallsCounter.incrementAndGet();\n                     return defaultGetColumns().apply(schemaTableName);\n                 })\n+                .withRoleGrants((connectorSession, roles, grantees, limit) -> {\n+                    listRowGrantsCallsCounter.incrementAndGet();\n+                    if (roles.isPresent()) {\n+                        rolesPushedCounter.incrementAndGet();\n+                    }\n+                    if (grantees.isPresent()) {\n+                        granteesPushedCounter.incrementAndGet();\n+                    }\n+                    if (limit.isPresent()) {\n+                        limitPushedCounter.incrementAndGet();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyNTg5Nw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r432225897", "bodyText": "I added beans: a Counter bean a Count bean to compare against.", "author": "lhofhansl", "createdAt": "2020-05-29T02:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1MDY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM5OTEzNg==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r432399136", "bodyText": "That is very nice. How about going one step further and having this more fluent, like\nnew MetadataCallsCount().with(roleGrantCount(/*method calls count*/ 1).withGranteesPushedDown(1));\n\n?", "author": "kokosing", "createdAt": "2020-05-29T10:34:26Z", "path": "presto-tests/src/test/java/io/prestosql/tests/TestInformationSchemaConnector.java", "diffHunk": "@@ -97,6 +97,48 @@ public void testLimit()\n         assertQuery(\"SELECT count(*) FROM (SELECT * FROM test_catalog.information_schema.tables LIMIT 1000)\", \"VALUES 1000\");\n     }\n \n+    @Test\n+    public void testRoleAuthorizationDescriptor()\n+    {\n+        assertQuery(\"SELECT count(*) FROM test_catalog.information_schema.role_authorization_descriptors\", \"VALUES 100\");\n+        assertQuery(\"SELECT count(*) FROM test_catalog.information_schema.roles\", \"VALUES 50\");\n+        assertQuery(\"SELECT count(*) FROM test_catalog.information_schema.enabled_roles\", \"VALUES 50\");\n+        assertQuery(\"SELECT count(*) FROM test_catalog.information_schema.applicable_roles\", \"VALUES 1\");\n+        assertQuery(\"SELECT role_name FROM test_catalog.information_schema.role_authorization_descriptors WHERE grantee = 'user5'\", \"VALUES ('role2')\");\n+        assertQuery(\"SELECT grantee FROM test_catalog.information_schema.role_authorization_descriptors WHERE role_name = 'role2'\", \"VALUES ('user4'), ('user5')\");\n+\n+        assertMetadataCalls(\n+                \"SELECT count(*) FROM test_catalog.information_schema.role_authorization_descriptors\", \"VALUES 100\",\n+                new MetadataCallsCount()\n+                        .withRoleGrantCount(1, 0, 0, 0));\n+\n+        assertMetadataCalls(\n+                \"SELECT role_name FROM test_catalog.information_schema.role_authorization_descriptors WHERE grantee = 'user5'\", \"VALUES ('role2')\",\n+                new MetadataCallsCount()\n+                        .withRoleGrantCount(1, 0, 1, 0));\n+\n+        assertMetadataCalls(\n+                \"SELECT grantee FROM test_catalog.information_schema.role_authorization_descriptors WHERE role_name = 'role2'\", \"VALUES ('user4'), ('user5')\",\n+                new MetadataCallsCount()\n+                        .withRoleGrantCount(1, 1, 0, 0));\n+\n+        assertMetadataCalls(\n+                \"SELECT grantee FROM test_catalog.information_schema.role_authorization_descriptors WHERE role_name = 'role2' AND grantee = 'user4'\", \"VALUES 'user4'\",\n+                new MetadataCallsCount()\n+                        .withRoleGrantCount(1, 1, 1, 0));\n+\n+        assertMetadataCalls(\n+                \"SELECT count(*) FROM (SELECT * FROM test_catalog.information_schema.role_authorization_descriptors LIMIT 1)\", \"VALUES 1\",\n+                new MetadataCallsCount()\n+                        .withRoleGrantCount(1, 0, 0, 1));\n+\n+        // verify that predicate and LIMIT are not pushed down together\n+        assertMetadataCalls(\n+                \"SELECT count(*) FROM (SELECT * FROM test_catalog.information_schema.role_authorization_descriptors WHERE grantee = 'user5' LIMIT 1)\", \"VALUES 1\",\n+                new MetadataCallsCount()\n+                        .withRoleGrantCount(1, 0, 1, 0));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwMzU2Ng==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r432603566", "bodyText": "I had those methods before. It just seemed to now make more sense to compare the beans...\nMaybe it was better the way I had it before?\nIn the end we have certain metrics we want to count for the connector; those are the atomic counters.\nI think I misunderstood what you wanted... MetadataCallsCount is already a \"bean\", and so having the individual members for counts is fine...?", "author": "lhofhansl", "createdAt": "2020-05-29T16:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM5OTEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM5OTQzMQ==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r432399431", "bodyText": "RoleGrantCounter?", "author": "kokosing", "createdAt": "2020-05-29T10:35:07Z", "path": "presto-testing/src/main/java/io/prestosql/testing/CountingMockConnector.java", "diffHunk": "@@ -167,6 +202,103 @@ public String toString()\n                     .add(\"listSchemasCount\", listSchemasCount)\n                     .add(\"listTablesCount\", listTablesCount)\n                     .add(\"getColumnsCount\", getColumnsCount)\n+                    .add(\"roleGrantCount\", roleGrantCount)\n+                    .toString();\n+        }\n+    }\n+\n+    public static class RoleGrantCounter", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5OTU1Nw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r432599557", "bodyText": "Yeah... Naming is hard. :)", "author": "lhofhansl", "createdAt": "2020-05-29T16:28:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM5OTQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM5OTY1OA==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r432399658", "bodyText": "I would prefer to have bean to be immutable. incrementListRoleGrants could return new instance. Then you don't need two classes.", "author": "kokosing", "createdAt": "2020-05-29T10:35:40Z", "path": "presto-testing/src/main/java/io/prestosql/testing/CountingMockConnector.java", "diffHunk": "@@ -167,6 +202,103 @@ public String toString()\n                     .add(\"listSchemasCount\", listSchemasCount)\n                     .add(\"listTablesCount\", listTablesCount)\n                     .add(\"getColumnsCount\", getColumnsCount)\n+                    .add(\"roleGrantCount\", roleGrantCount)\n+                    .toString();\n+        }\n+    }\n+\n+    public static class RoleGrantCounter\n+    {\n+        private final AtomicLong listRowGrantsCallsCounter = new AtomicLong();\n+        private final AtomicLong rolesPushedCounter = new AtomicLong();\n+        private final AtomicLong granteesPushedCounter = new AtomicLong();\n+        private final AtomicLong limitPushedCounter = new AtomicLong();", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNjQwNw==", "url": "https://github.com/trinodb/trino/pull/3535#discussion_r432616407", "bodyText": "The AtomicLongs for the other counters are mutable. I think this counter would be inherently mutable.\nHow do you handle atomicity between calls? Have the counter bean be an atomic reference and you update the reference with each new instance?\nWe're going to need 2 beans, right? One for counting and one to compare against during the test.\nThe more I think about it, the more I think the previous code was better.", "author": "lhofhansl", "createdAt": "2020-05-29T16:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM5OTY1OA=="}], "type": "inlineReview"}, {"oid": "ef9b5f045d179c3afc21324d4a2b550c4baeb58f", "url": "https://github.com/trinodb/trino/commit/ef9b5f045d179c3afc21324d4a2b550c4baeb58f", "message": "Add information_schema.role_authorization_descriptors\n\nThe schema of this table is:\nrole_nane | grantor | grantor_type | grantee | grantee_type | is_grantable\n\nFor Hive, queries on this table are translated to calls to\nmetastore.get_principals_in_role or metastore.get_role_grants_for_principal,\nwith proper predicate pushdown to avoid excessive requests to the metastore.\n\ngrantor and grantor_type are not yet implemented and always NULL.", "committedDate": "2020-05-29T17:38:32Z", "type": "commit"}]}