{"pr_number": 5105, "pr_title": "Add support for precision for TIMESTAMP W/TZ in Postgresql type mapping", "pr_createdAt": "2020-09-08T20:27:17Z", "pr_url": "https://github.com/trinodb/trino/pull/5105", "timeline": [{"oid": "61c7b36afe776b64d0c3972b09fb3784a64b4b73", "url": "https://github.com/trinodb/trino/commit/61c7b36afe776b64d0c3972b09fb3784a64b4b73", "message": "Extract method", "committedDate": "2020-09-08T16:32:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyODAwMw==", "url": "https://github.com/trinodb/trino/pull/5105#discussion_r485428003", "bodyText": "Postgres currently supports p <=6 (according to docs), so we do not have behavioral regression here.\nWorth mentioning in the commit message that we are leveraging this fact.", "author": "findepi", "createdAt": "2020-09-09T08:22:24Z", "path": "presto-postgresql/src/main/java/io/prestosql/plugin/postgresql/PostgreSqlClient.java", "diffHunk": "@@ -434,8 +442,15 @@ public WriteMapping toWriteMapping(ConnectorSession session, Type type)\n         if (TIMESTAMP_MILLIS.equals(type)) {\n             return WriteMapping.longMapping(\"timestamp\", timestampWriteFunction());\n         }\n-        if (TIMESTAMP_WITH_TIME_ZONE.equals(type)) {\n-            return WriteMapping.longMapping(\"timestamptz\", timestampWithTimeZoneWriteFunction());\n+        if (type instanceof TimestampWithTimeZoneType && ((TimestampWithTimeZoneType) type).getPrecision() <= 6) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ3OTA4NA==", "url": "https://github.com/trinodb/trino/pull/5105#discussion_r485479084", "bodyText": "Until 9 we would be fine. It would harder with 10,11,12 as I am not sure if that is compatible with JDBC. At least not via OffsetDateTime PSQL uses.\nThe ((TimestampWithTimeZoneType) type).getPrecision() <= 6 condition is merly a checkstate. I just did not want to have it explicitly in if (type instanceof TimestampWithTimeZoneType) {, so standard unsupported type handling logic triggers if for some magical reason we get timestamp with precision >6 (e.g with some future version of PSQL)", "author": "losipiuk", "createdAt": "2020-09-09T09:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyODAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyODUzNA==", "url": "https://github.com/trinodb/trino/pull/5105#discussion_r485428534", "bodyText": "Add\n// PostgreSQL currently supports precision up to microseconds\n\nto argument that throwing is actually OK think to do", "author": "findepi", "createdAt": "2020-09-09T08:23:13Z", "path": "presto-postgresql/src/main/java/io/prestosql/plugin/postgresql/PostgreSqlClient.java", "diffHunk": "@@ -489,15 +504,25 @@ private static LongWriteFunction timestampWriteFunction()\n         };\n     }\n \n-    private static ColumnMapping timestampWithTimeZoneColumnMapping()\n+    private static ColumnMapping timestampWithTimeZoneColumnMapping(int precision)\n     {\n-        return ColumnMapping.longMapping(\n-                TIMESTAMP_WITH_TIME_ZONE,\n-                timeStampWithTimeZoneReadFunction(),\n-                timestampWithTimeZoneWriteFunction());\n+        checkArgument(precision <= 6, \"unsupported precision value\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ0ODgxNw==", "url": "https://github.com/trinodb/trino/pull/5105#discussion_r485448817", "bodyText": "MICROSECONDS_PER_MILLISECOND -> MILLISECONDS_PER_SECOND\n@martint is the % and / right here? or floorDiv instead?\ndo we have helper methods somewhere so that we do not have to ask the above question ever again?", "author": "findepi", "createdAt": "2020-09-09T08:53:26Z", "path": "presto-postgresql/src/main/java/io/prestosql/plugin/postgresql/PostgreSqlClient.java", "diffHunk": "@@ -515,6 +540,32 @@ private static LongWriteFunction timestampWithTimeZoneWriteFunction()\n         };\n     }\n \n+    private static ObjectReadFunction longTimestampWithTimeZoneReadFunction()\n+    {\n+        return ObjectReadFunction.of(\n+                LongTimestampWithTimeZone.class,\n+                (resultSet, columnIndex) -> {\n+                    // PostgreSQL does not store zone information in \"timestamp with time zone\" data type\n+                    OffsetDateTime offsetDateTime = resultSet.getObject(columnIndex, OffsetDateTime.class);\n+                    return LongTimestampWithTimeZone.fromEpochSecondsAndFraction(\n+                            offsetDateTime.toEpochSecond(),\n+                            (long) offsetDateTime.getNano() * PICOSECONDS_PER_NANOSECOND,\n+                            UTC_KEY);\n+                });\n+    }\n+\n+    private static ObjectWriteFunction longTimestampWithTimeZoneWriteFunction()\n+    {\n+        return ObjectWriteFunction.of(\n+                LongTimestampWithTimeZone.class,\n+                (statement, index, value) -> {\n+                    // PostgreSQL does not store zone information in \"timestamp with time zone\" data type\n+                    long epochSeconds = value.getEpochMillis() / MILLISECONDS_PER_SECOND;\n+                    long nanosOfSecond = value.getEpochMillis() % MICROSECONDS_PER_MILLISECOND * NANOSECONDS_PER_MILLISECOND + value.getPicosOfMilli() / PICOSECONDS_PER_NANOSECOND;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MDc4NQ==", "url": "https://github.com/trinodb/trino/pull/5105#discussion_r485450785", "bodyText": "MICROSECONDS_PER_MILLISECOND -> ..", "author": "findepi", "createdAt": "2020-09-09T08:56:21Z", "path": "presto-postgresql/src/main/java/io/prestosql/plugin/postgresql/TypeUtils.java", "diffHunk": "@@ -180,10 +194,20 @@ private static Object prestoNativeToJdbcObject(ConnectorSession session, Type pr\n             return toPgTimestamp(fromPrestoTimestamp((long) prestoNative));\n         }\n \n-        if (TIMESTAMP_WITH_TIME_ZONE.equals(prestoType)) {\n-            long millisUtc = unpackMillisUtc((long) prestoNative);\n+        if (prestoType instanceof TimestampWithTimeZoneType) {\n             // PostgreSQL does not store zone, only the point in time\n-            return new Timestamp(millisUtc);\n+            int precision = ((TimestampWithTimeZoneType) prestoType).getPrecision();\n+            if (precision <= TimestampWithTimeZoneType.MAX_SHORT_PRECISION) {\n+                long millisUtc = unpackMillisUtc((long) prestoNative);\n+                return new Timestamp(millisUtc);\n+            }\n+            else {\n+                LongTimestampWithTimeZone value = (LongTimestampWithTimeZone) prestoNative;\n+                long epochSeconds = value.getEpochMillis() / MILLISECONDS_PER_SECOND;\n+                long nanosOfSecond = value.getEpochMillis() % MICROSECONDS_PER_MILLISECOND * NANOSECONDS_PER_MILLISECOND", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MTYxNw==", "url": "https://github.com/trinodb/trino/pull/5105#discussion_r485451617", "bodyText": "Let's also add test what happens if we try create table with timestamp(7).", "author": "findepi", "createdAt": "2020-09-09T08:57:35Z", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1141,16 +1141,16 @@ public void testTimestampWithTimeZone(boolean insertWithPresto)\n     }\n \n     @Test(dataProvider = \"testTimestampWithTimeZoneDataProvider\")\n-    public void testArrayTimestampWithTimeZone(boolean insertWithPresto)\n+    public void testArrayTimestampWithTimeZone(boolean insertWithPresto, int precision)", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MjUzNw==", "url": "https://github.com/trinodb/trino/pull/5105#discussion_r485452537", "bodyText": "Method is called \"round to precision\", but this truncates.", "author": "findepi", "createdAt": "2020-09-09T08:58:57Z", "path": "presto-postgresql/src/test/java/io/prestosql/plugin/postgresql/TestPostgreSqlTypeMapping.java", "diffHunk": "@@ -1376,26 +1386,35 @@ private void testUnsupportedDataTypeConvertedToVarchar(Session session, String d\n         }\n     }\n \n-    public static DataType<ZonedDateTime> prestoTimestampWithTimeZoneDataType()\n+    public static DataType<ZonedDateTime> prestoTimestampWithTimeZoneDataType(int precision)\n     {\n         return dataType(\n-                \"timestamp with time zone\",\n-                TIMESTAMP_WITH_TIME_ZONE,\n-                DateTimeFormatter.ofPattern(\"'TIMESTAMP '''yyyy-MM-dd HH:mm:ss.SSS VV''\")::format,\n+                format(\"timestamp(%d) with time zone\", precision),\n+                createTimestampWithTimeZoneType(precision),\n+                zonedDateTime -> DateTimeFormatter.ofPattern(\"'TIMESTAMP '''yyyy-MM-dd HH:mm:ss.SSSSSS VV''\").format(roundToPrecision(zonedDateTime, precision)),\n                 // PostgreSQL does not store zone, only the point in time\n-                zonedDateTime -> zonedDateTime.withZoneSameInstant(ZoneId.of(\"UTC\")));\n+                zonedDateTime -> roundToPrecision(zonedDateTime, precision).withZoneSameInstant(ZoneId.of(\"UTC\")));\n     }\n \n-    public static DataType<ZonedDateTime> postgreSqlTimestampWithTimeZoneDataType()\n+    public static DataType<ZonedDateTime> postgreSqlTimestampWithTimeZoneDataType(int precision)\n     {\n         return dataType(\n-                \"timestamp with time zone\",\n-                TIMESTAMP_WITH_TIME_ZONE,\n+                format(\"timestamp(%d) with time zone\", precision),\n+                createTimestampWithTimeZoneType(precision),\n                 // PostgreSQL never examines the content of a literal string before determining its type, so `TIMESTAMP '.... {zone}'` won't work.\n                 // PostgreSQL does not store zone, only the point in time\n-                zonedDateTime -> DateTimeFormatter.ofPattern(\"'TIMESTAMP WITH TIME ZONE '''yyyy-MM-dd HH:mm:ss.SSS VV''\").format(zonedDateTime.withZoneSameInstant(UTC)),\n-                DateTimeFormatter.ofPattern(\"'TIMESTAMP '''yyyy-MM-dd HH:mm:ss.SSS VV''\")::format,\n-                zonedDateTime -> zonedDateTime.withZoneSameInstant(ZoneId.of(\"UTC\")));\n+                zonedDateTime -> {\n+                    String pattern = format(\"'TIMESTAMP (%d) WITH TIME ZONE '''yyyy-MM-dd HH:mm:ss.SSSSSS VV''\", precision);\n+                    return DateTimeFormatter.ofPattern(pattern).format(roundToPrecision(zonedDateTime, precision).withZoneSameInstant(UTC));\n+                },\n+                zonedDateTime -> DateTimeFormatter.ofPattern(\"'TIMESTAMP '''yyyy-MM-dd HH:mm:ss.SSSSSS VV''\").format(roundToPrecision(zonedDateTime, precision)),\n+                zonedDateTime -> roundToPrecision(zonedDateTime, precision).withZoneSameInstant(ZoneId.of(\"UTC\")));\n+    }\n+\n+    private static ZonedDateTime roundToPrecision(ZonedDateTime zonedDateTime, int precision)\n+    {\n+        int divisor = (int) Math.pow(10, 9 - precision);\n+        return zonedDateTime.withNano(zonedDateTime.getNano() / divisor * divisor);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ3NDI3Nw==", "url": "https://github.com/trinodb/trino/pull/5105#discussion_r485474277", "bodyText": "Yeah - previous version used to round :)", "author": "losipiuk", "createdAt": "2020-09-09T09:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ1MjUzNw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "e12f1ba75c157f098b5e805bd2af6b208aa71daf", "url": "https://github.com/trinodb/trino/commit/e12f1ba75c157f098b5e805bd2af6b208aa71daf", "message": "Add support for precision for TIMESTAMP W/TZ in Postgresql type mapping\n\nAdd support for mapping TIMESTAMP WITH TIME ZONE from Presto to\nPostgreSQL (and vice versa) for precisions 1 to 6. It covers all\nprecisions currently supported by PostgreSQL.", "committedDate": "2020-09-09T13:58:03Z", "type": "commit"}, {"oid": "e12f1ba75c157f098b5e805bd2af6b208aa71daf", "url": "https://github.com/trinodb/trino/commit/e12f1ba75c157f098b5e805bd2af6b208aa71daf", "message": "Add support for precision for TIMESTAMP W/TZ in Postgresql type mapping\n\nAdd support for mapping TIMESTAMP WITH TIME ZONE from Presto to\nPostgreSQL (and vice versa) for precisions 1 to 6. It covers all\nprecisions currently supported by PostgreSQL.", "committedDate": "2020-09-09T13:58:03Z", "type": "forcePushed"}]}