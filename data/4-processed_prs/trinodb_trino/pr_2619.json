{"pr_number": 2619, "pr_title": "Flattening optimizer for set operations", "pr_createdAt": "2020-01-24T12:46:39Z", "pr_url": "https://github.com/trinodb/trino/pull/2619", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc5NTE5MQ==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r370795191", "bodyText": "I'd call this MergeIntersect", "author": "martint", "createdAt": "2020-01-24T19:08:18Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/FlatteningIntersect.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.IntersectNode;\n+\n+import static io.prestosql.sql.planner.plan.Patterns.intersect;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ * - Intersect\n+ *   - Intersect\n+ *     - Relation1\n+ *     - Relation2\n+ *   - Intersect\n+ *     - Relation3\n+ *     - Relation4\n+ * </pre>\n+ * Into\n+ * <pre>\n+ * - Intersect\n+ *   - Relation1\n+ *   - Relation2\n+ *   - Relation3\n+ *   - Relation4\n+ * </pre>\n+ */\n+public class FlatteningIntersect", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc5NTI3Mg==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r370795272", "bodyText": "I'd call this MergeUnion", "author": "martint", "createdAt": "2020-01-24T19:08:31Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/FlatteningUnion.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.UnionNode;\n+\n+import static io.prestosql.sql.planner.plan.Patterns.union;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ * - Union\n+ *   - Union\n+ *     - Relation1\n+ *     - Relation2\n+ *   - Union\n+ *     - Relation3\n+ *     - Relation4\n+ * </pre>\n+ * Into\n+ * <pre>\n+ * - Union\n+ *   - Relation1\n+ *   - Relation2\n+ *   - Relation3\n+ *   - Relation4\n+ * </pre>\n+ */\n+public class FlatteningUnion", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMzcwNw==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r370803707", "bodyText": "Instead of using inheritance for code reuse, it'd be cleaner to model this as a method that takes a callback to abstract newSetOperationNode. Then, you can pass an inline lambda which does the appropriate new XXXNode as the callback. Something like:\npublic static SetOperationNode flatten(SetOperationNode node, Context context, NodeInstantiator instantiator)\n{\n    if (flattening not necessary) {\n        return null;\n    }   \n    ...\n    return instantiator.create(....);\n}\n(NodeInstantiator would be a single-method interface that takes the arguments needed to instantiate an IntersectNode, UnionNode, etc)\nand in the rule:\nSetOperationNode result = flatten(node, IntersectNode::new);\nif (result != null) {\n    return Optional.ofPlanNode(result);\n}", "author": "martint", "createdAt": "2020-01-24T19:27:41Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationFlattening.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+abstract class SetOperationFlattening", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2ODQwMQ==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r370968401", "bodyText": "That makes sense. I'll update accordingly.", "author": "Lewuathe", "createdAt": "2020-01-26T02:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgwMzcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExMzg5NA==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371113894", "bodyText": "These can all be private", "author": "martint", "createdAt": "2020-01-27T08:41:46Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+class SetOperationMerge\n+{\n+    private final Context context;\n+    protected final SetOperationNode node;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExMzk5Mg==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371113992", "bodyText": "This can be final", "author": "martint", "createdAt": "2020-01-27T08:42:00Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+class SetOperationMerge\n+{\n+    private final Context context;\n+    protected final SetOperationNode node;\n+    protected List<PlanNode> newSources;\n+    protected ImmutableListMultimap<Symbol, Symbol> newMappings;\n+    private SetOperationNodeInstantiator instantiator;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1ODA3OQ==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371158079", "bodyText": "newMappings is not used outside this call, so inline it and get rid of the class-level field.", "author": "martint", "createdAt": "2020-01-27T10:20:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+class SetOperationMerge\n+{\n+    private final Context context;\n+    protected final SetOperationNode node;\n+    protected List<PlanNode> newSources;\n+    protected ImmutableListMultimap<Symbol, Symbol> newMappings;\n+    private SetOperationNodeInstantiator instantiator;\n+\n+    public SetOperationMerge(SetOperationNode node, Context context, SetOperationNodeInstantiator instantiator)\n+    {\n+        this.node = node;\n+        this.context = context;\n+        this.newSources = new ArrayList<>();\n+        this.instantiator = instantiator;\n+    }\n+\n+    /**\n+     * Only merge first source node, which is assumed to be used for non-associative set operation.\n+     * @return Merged plan node if applied.\n+     */\n+    public Optional<SetOperationNode> mergeFirstSource()\n+    {\n+        Lookup lookup = context.getLookup();\n+        List<PlanNode> sources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .collect(Collectors.toList());\n+\n+        // If the first child is not the same with the parent, do nothing.\n+        if (!sources.get(0).getClass().equals(node.getClass())) {\n+            return Optional.empty();\n+        }\n+\n+        ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n+\n+        SetOperationNode child = (SetOperationNode) sources.get(0);\n+        // Merge all sources of the first source.\n+        addMergedMappings(child, 0, newMappingsBuilder);\n+\n+        // Keep remaining as it is\n+        for (int i = 1; i < sources.size(); i++) {\n+            PlanNode source = sources.get(i);\n+            addOriginalMappings(source, i, newMappingsBuilder);\n+        }\n+\n+        newMappings = newMappingsBuilder.build();\n+        return Optional.of(instantiator.create(node.getId(), newSources, newMappings, node.getOutputSymbols()));", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1ODU2Mw==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371158563", "bodyText": "Don't use abbreviations. Rename s to source for clarity", "author": "martint", "createdAt": "2020-01-27T10:21:44Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/SetOperationMerge.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableListMultimap;\n+import com.google.common.collect.Iterables;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule.Context;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.SetOperationNode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+class SetOperationMerge\n+{\n+    private final Context context;\n+    protected final SetOperationNode node;\n+    protected List<PlanNode> newSources;\n+    protected ImmutableListMultimap<Symbol, Symbol> newMappings;\n+    private SetOperationNodeInstantiator instantiator;\n+\n+    public SetOperationMerge(SetOperationNode node, Context context, SetOperationNodeInstantiator instantiator)\n+    {\n+        this.node = node;\n+        this.context = context;\n+        this.newSources = new ArrayList<>();\n+        this.instantiator = instantiator;\n+    }\n+\n+    /**\n+     * Only merge first source node, which is assumed to be used for non-associative set operation.\n+     * @return Merged plan node if applied.\n+     */\n+    public Optional<SetOperationNode> mergeFirstSource()\n+    {\n+        Lookup lookup = context.getLookup();\n+        List<PlanNode> sources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .collect(Collectors.toList());\n+\n+        // If the first child is not the same with the parent, do nothing.\n+        if (!sources.get(0).getClass().equals(node.getClass())) {\n+            return Optional.empty();\n+        }\n+\n+        ImmutableListMultimap.Builder<Symbol, Symbol> newMappingsBuilder = ImmutableListMultimap.builder();\n+\n+        SetOperationNode child = (SetOperationNode) sources.get(0);\n+        // Merge all sources of the first source.\n+        addMergedMappings(child, 0, newMappingsBuilder);\n+\n+        // Keep remaining as it is\n+        for (int i = 1; i < sources.size(); i++) {\n+            PlanNode source = sources.get(i);\n+            addOriginalMappings(source, i, newMappingsBuilder);\n+        }\n+\n+        newMappings = newMappingsBuilder.build();\n+        return Optional.of(instantiator.create(node.getId(), newSources, newMappings, node.getOutputSymbols()));\n+    }\n+\n+    /**\n+     * Constructs the new mapping and source nodes\n+     * @return Merged plan node if applied.\n+     */\n+    public Optional<SetOperationNode> merge()\n+    {\n+        Lookup lookup = context.getLookup();\n+        List<PlanNode> sources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .collect(Collectors.toList());\n+\n+        // There must be one same source node at least.\n+        if (sources.stream().noneMatch(s -> node.getClass().equals(s.getClass()))) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE2MDAxOA==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r371160018", "bodyText": "Also, this can be replaced with:\nif (sources.stream().noneMatch(node.getClass()::isInstance)) {\n\nIt's a little more robust, as it's checking for instanceof instead of class equality.", "author": "martint", "createdAt": "2020-01-27T10:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1ODU2Mw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAwOTg1Mw==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r401009853", "bodyText": "Instead of using a visitor, this should be done pairwise by a rule that matches the expected pattern. I.e., it if matches Aggregation -> SetOperation -> {Aggregation -> X, ... }, it should rewrite to Aggregation -> SetOperation -> {X, ...}.", "author": "martint", "createdAt": "2020-03-31T15:33:16Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneDistinctAggregation.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.iterative.Lookup;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.ExceptNode;\n+import io.prestosql.sql.planner.plan.IntersectNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.PlanVisitor;\n+import io.prestosql.sql.planner.plan.UnionNode;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.plan.ChildReplacer.replaceChildren;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+\n+public class PruneDistinctAggregation\n+        implements Rule<AggregationNode>\n+{\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .matching(PruneDistinctAggregation::isDistinctOperator);\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        Lookup lookup = context.getLookup();\n+        DistinctAggregationRewriter rewriter = new DistinctAggregationRewriter(lookup);\n+\n+        List<PlanNode> newSources = node.getSources().stream()\n+                .flatMap(lookup::resolveGroup)\n+                .map(source -> source.accept(rewriter, true))\n+                .collect(Collectors.toList());\n+\n+        if (rewriter.isRewritten()) {\n+            return Result.ofPlanNode(replaceChildren(node, newSources));\n+        }\n+        else {\n+            return Result.empty();\n+        }\n+    }\n+\n+    private static boolean isDistinctOperator(AggregationNode node)\n+    {\n+        return node.getAggregations().isEmpty();\n+    }\n+\n+    private static class DistinctAggregationRewriter", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5NzcxOQ==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r408497719", "bodyText": "I see. But it needs to match any number of the intermediate set operations as described before.\nIt should rewrite the following patterns.\nAggregation -> SetOperation -> {Aggregation -> X, ...\nAggregation -> SetOperation -> {SetOperation -> {Aggregation -> X, ...\nAggregation -> SetOperation -> {SetOperation -> {SetOperation -> {Aggregation -> X, ...\n...\n\nInitially, I wrote the DistinctAggregationRewriter as pattern match rule. But it did not work as expected due to the previous reason. Is it possible to match the pattern with arbitrary number of intermediate set operations?", "author": "Lewuathe", "createdAt": "2020-04-14T23:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAwOTg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU5OTEwMw==", "url": "https://github.com/trinodb/trino/pull/2619#discussion_r425599103", "bodyText": "That's right. Currently it's not possible to match that pattern with rules. If the intermediate set operations are of the same type, the MergeXXX rules should take care of them, but if they are not, there's no way to jump an arbitrary number of levels. This will require support for traits and properties in the iterative optimizer. Let's leave it as you did for now.", "author": "martint", "createdAt": "2020-05-15T06:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAwOTg1Mw=="}], "type": "inlineReview"}, {"oid": "71100e0c8b16496d290d96f30d62ee1d0670f530", "url": "https://github.com/trinodb/trino/commit/71100e0c8b16496d290d96f30d62ee1d0670f530", "message": "Optimizer for merging set operations", "committedDate": "2020-05-15T13:42:26Z", "type": "commit"}, {"oid": "71100e0c8b16496d290d96f30d62ee1d0670f530", "url": "https://github.com/trinodb/trino/commit/71100e0c8b16496d290d96f30d62ee1d0670f530", "message": "Optimizer for merging set operations", "committedDate": "2020-05-15T13:42:26Z", "type": "forcePushed"}]}