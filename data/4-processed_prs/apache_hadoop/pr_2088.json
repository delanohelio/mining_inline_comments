{"pr_number": 2088, "pr_title": "HDFS-15427. Merged ListStatus with Fallback target filesystem and InternalDirViewFS.", "pr_createdAt": "2020-06-22T08:03:32Z", "pr_url": "https://github.com/apache/hadoop/pull/2088", "timeline": [{"oid": "4961c40f490e137d410d6dd44a0e5f9fd0fb1d6a", "url": "https://github.com/apache/hadoop/commit/4961c40f490e137d410d6dd44a0e5f9fd0fb1d6a", "message": "HDFS-15427. Merged ListStatus with Fallback target filesystem and InternalDirViewFS.", "committedDate": "2020-06-22T08:01:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4OTc1Nw==", "url": "https://github.com/apache/hadoop/pull/2088#discussion_r443489757", "bodyText": "Thanx @umamaheswararao for initiating this, The idea seems good. This fallback mechanism is there in RBF too, through default namespace implementation, shall be great to bring it to ViewFs as well.\nI got the overall idea, Just a doubt regarding the above line.\nWhy in case showMountLinkAsSymlinks is true, we need to give preference to the fallback paths?\nTaking example from the structure in testLSOnLinkParentWithFallbackLinkWithSameMountDirectoryTree\nif we do ls on /user1/hive/warehouse the linkStatuses will have one partition0 which is mounted and the internalDirStatusesMergedWithFallBack will have another partition0 from the fallback. Shouldn't we give preference to the one from the mount entry. Since if I perform an operation on `user1/hive/warehouse/partiton0 the operation will be performed on the mount link resolved path rather than the Fallback partion0?\nHere collision is possible only between linkStatus and fallbackStatus, linkStatus and internalDirStatuses can not collide since ViewFs isn't allowing to mount /user1/hive -> (some path) as well as /user1/hive/warehouse -> (some path) which is allowed in RBF. So, In case if the exact mount entry is present any call will go to mount entry resolved path and the fallback dir will never be used, so in listing also it could have been overwritten?\nCan you help with logic here.", "author": "ayushtkn", "createdAt": "2020-06-22T11:21:46Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystem.java", "diffHunk": "@@ -1258,40 +1260,52 @@ public FileStatus getFileStatus(Path f) throws IOException {\n             FileStatus status =\n                 ((ChRootedFileSystem)link.getTargetFileSystem())\n                 .getMyFs().getFileStatus(new Path(linkedPath));\n-            result[i++] = new FileStatus(status.getLen(), status.isDirectory(),\n-                status.getReplication(), status.getBlockSize(),\n-                status.getModificationTime(), status.getAccessTime(),\n-                status.getPermission(), status.getOwner(), status.getGroup(),\n-                null, path);\n+            linkStatuses.add(\n+                new FileStatus(status.getLen(), status.isDirectory(),\n+                    status.getReplication(), status.getBlockSize(),\n+                    status.getModificationTime(), status.getAccessTime(),\n+                    status.getPermission(), status.getOwner(),\n+                    status.getGroup(), null, path));\n           } catch (FileNotFoundException ex) {\n             LOG.warn(\"Cannot get one of the children's(\" + path\n                 + \")  target path(\" + link.getTargetFileSystem().getUri()\n                 + \") file status.\", ex);\n             throw ex;\n           }\n         } else {\n-          result[i++] =\n+          internalDirStatuses.add(\n               new FileStatus(0, true, 0, 0, creationTime, creationTime,\n                   PERMISSION_555, ugi.getShortUserName(),\n-                  ugi.getPrimaryGroupName(), path);\n+                  ugi.getPrimaryGroupName(), path));\n         }\n       }\n+      FileStatus[] internalDirStatusesMergedWithFallBack = internalDirStatuses\n+          .toArray(new FileStatus[internalDirStatuses.size()]);\n       if (fallbackStatuses.length > 0) {\n-        return consolidateFileStatuses(fallbackStatuses, result);\n+        internalDirStatusesMergedWithFallBack =\n+            merge(fallbackStatuses, internalDirStatusesMergedWithFallBack);\n+      }\n+\n+      // we don't use target file status as we show the mount link as symlink.\n+      if (showMountLinksAsSymlinks) {\n+        return merge(internalDirStatusesMergedWithFallBack,\n+            linkStatuses.toArray(new FileStatus[linkStatuses.size()]));", "originalCommit": "4961c40f490e137d410d6dd44a0e5f9fd0fb1d6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNDUwMA==", "url": "https://github.com/apache/hadoop/pull/2088#discussion_r443704500", "bodyText": "Hi @ayushtkn , thank you for questions.\n>>Just a doubt regarding the above line.\nWhy in case showMountLinkAsSymlinks is true, we need to give preference to the fallback paths?\n\nIf you notice in tests, I have set showMountLinkAsSymlinks to false to represent more ViewFSOerloadScheme scenarios where we have showMountLinkAsSymlinks=false bydefault.\nIn the case showMountLinkAsSymlinks=true, mount link wants to represent as symlink. Here in symlink we will not actually taking any values from targetDirs resolved. This is ViewFileSystem default behavior. In the case of InternalDir we never represent as symlinks. So, this config will not be applicable to internal dir.\nJust to be clear: if mount path is /user/hibe/warehouse/partition-0 --> o3fs://....\nHere (/user or /user/hive or /user/hive/warehouse ) will be represented as \"InternalDirs\"\nthat last dir partition-0 will only be represented as link. So, that configuration will comeinto picture only for partition-0.\nIn InternalDIr case we are trying get from fallback if they are matching. The reason is, we may want to implement to have mkdirs or other functions to work on internalDir matching path if there is fallback. Example: mkdirs /user/hive/warehouse2\nCurrently it will not work because we will say /user/hive is readOnly. But the plan is to support and create  /user/hive/warehouse2 in fallback fs. So, it make sense to get the permission/others from fallback dir and represent. Does this make sense? Basically we will want to apply\n\n\ninternalDirStatuses can not collide since ViewFs isn't allowing to mount /user1/hive -> (some path) as well as /user1/hive/warehouse -> (some path) which is allowed in RBF.\n\n\nYes, you are right. We don't allow to configure any other mount path in the same tree. Here the idea is if there is fallback, that can be applied everywhere where there is no link configured. That way we can bring the scenario that a base cluster can be a fallback cluster and mount some of the paths from it to some remote fs. So, only links will go to target fs and rest of folder should be pointed to fallback fs. Because fallbackFS is just a single global config, but not specific to any path.", "author": "umamaheswararao", "createdAt": "2020-06-22T17:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4OTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0MzYzMw==", "url": "https://github.com/apache/hadoop/pull/2088#discussion_r443743633", "bodyText": "Currently it will not work because we will say /user/hive is readOnly. But the plan is to support and create /user/hive/warehouse2 in fallback fs. So, it make sense to get the permission/others from fallback dir and represent. Does this make sense?\n\nIn most cases it makes sense, For one case I still have a doubt.\nBut say taking the same tree,  /user1/hive/warehouse/partition-0 is mounted. and the same partion-0 is available through fallback as well.\nif I perform any operation say mkdir(/user1/hive/warehouse/partition-0/file) this will go to mount point resolved path not to partion-0 of the fallback path. The above line while listing will show permissions of partion-0 from fall back link, when listing /user1/hive/warehouse, Correct? But actually the mount entry will always be used. The question is which case partion-0 of the fallback will be used above the partion-0 from the mount entry. Even when partion-0 has target path available.\nif say in the fallback partion-0 isn't a directory, it is a file, we will show it as a file on listing /user1/hive/warehouse/, but mkdir on (/user1/hive/warehouse/partition-0/file) will be success, Wouldn't it be a inconsistent behavior ?\nI modified your test for my case :\n @Test\n  public void testLSOnLinkParentWithFallbackLinkWithSameMountDirectoryTree()\n      throws Exception {\n    Configuration conf = new Configuration();\n    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, true);\n    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n        new Path(targetTestRoot.toString()).toUri());\n    // Creating multiple directories path under the fallback directory.\n    // \"/user1/hive/warehouse/partition-0\" directory already exists as\n    // configured mount point.\n    Path file1 = new Path(targetTestRoot,\n        \"fallbackDir/user1/hive/warehouse/partition-0\"); // partition-0 in\n    // fallback is a file  ---> Changed this...\n    Path dir2 = new Path(targetTestRoot, \"fallbackDir/user1/hive/warehouse1\");\n    fsTarget.create(file1).close();\n    fsTarget.mkdirs(dir2);\n    URI viewFsUri = new URI(FsConstants.VIEWFS_SCHEME,\n        Constants.CONFIG_VIEWFS_DEFAULT_MOUNT_TABLE, \"/\", null, null);\n\n    ConfigUtil\n        .addLinkFallback(conf, new Path(targetTestRoot, \"fallbackDir\").toUri());\n\n    try (FileSystem vfs = FileSystem.get(viewFsUri, conf)) {\n      for (FileStatus stat : vfs.listStatus(\n          new Path(viewFsUri.toString(), \"/user1/hive/warehouse/\"))) {\n        if (file1.getName().equals(stat.getPath().getName())) {\n          assertTrue(stat.isFile()); // listing says\n          // /user1/hive/warehouse/partition-0 is a file.\n          Path fileUnderDir = new Path(stat.getPath(), \"check\");\n          assertTrue(vfs.mkdirs(fileUnderDir)); // Created a file under file?\n\n        }\n      }\n    }\n  }\n\nIs this behavior fine?", "author": "ayushtkn", "createdAt": "2020-06-22T18:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4OTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyNDM5NA==", "url": "https://github.com/apache/hadoop/pull/2088#discussion_r443824394", "bodyText": "HI @ayushtkn ,\nThe file actually creates under the above mount link you added.\nConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n        new Path(targetTestRoot.toString()).toUri());\n\nOnce you have mounted a path, links are more prioritized in ViewFS. I don't see a requirement people will configure files as mount links. We only support dirs. That dir takes the precedence. You will loose complete access to fallback, once you added mount path link. Tricky case here is, when you have matching file at fallback, you no more see that file. That you configured to represent as dir from mount view. we don't create anything under file in fallback fs.\nin SymLinks enabled, isFile always should be false. I think you raised a good point that we don't need that 'if condition' where it's making fallback high precedence unnecessarily and making think wrong in symlink enabled case. I will removed it and verify. I think I overthought there.\nTo make thing clear:\nMount tree links will have higher precendence.\nFallback dirs have higher precedence compared to moount tree internal dir.\nIf no matching mount tree internal dirs will have as last precedence.\nAfter removing that if condition: the following will be the result\nassertFalse(stat.isFile()); // listing says\nassertFalse(stat.isDirectory());\nassertTrue(stat.isSymlink());\nI hope this make sense now right?", "author": "umamaheswararao", "createdAt": "2020-06-22T21:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4OTc1Nw=="}], "type": "inlineReview"}, {"oid": "e628bcd3b5fe2eee3a43f9444244d00dca3c54df", "url": "https://github.com/apache/hadoop/commit/e628bcd3b5fe2eee3a43f9444244d00dca3c54df", "message": "Fixed checkstyle. Handled in ViewFs. Also fixed the precedence issue between fallback and link with symlink case", "committedDate": "2020-06-23T00:07:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk5OTU3MQ==", "url": "https://github.com/apache/hadoop/pull/2088#discussion_r443999571", "bodyText": "This comment line can be removed now? Now it isn't just root?", "author": "ayushtkn", "createdAt": "2020-06-23T06:52:31Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystem.java", "diffHunk": "@@ -1258,63 +1261,72 @@ public FileStatus getFileStatus(Path f) throws IOException {\n             FileStatus status =\n                 ((ChRootedFileSystem)link.getTargetFileSystem())\n                 .getMyFs().getFileStatus(new Path(linkedPath));\n-            result[i++] = new FileStatus(status.getLen(), status.isDirectory(),\n-                status.getReplication(), status.getBlockSize(),\n-                status.getModificationTime(), status.getAccessTime(),\n-                status.getPermission(), status.getOwner(), status.getGroup(),\n-                null, path);\n+            linkStatuses.add(\n+                new FileStatus(status.getLen(), status.isDirectory(),\n+                    status.getReplication(), status.getBlockSize(),\n+                    status.getModificationTime(), status.getAccessTime(),\n+                    status.getPermission(), status.getOwner(),\n+                    status.getGroup(), null, path));\n           } catch (FileNotFoundException ex) {\n             LOG.warn(\"Cannot get one of the children's(\" + path\n                 + \")  target path(\" + link.getTargetFileSystem().getUri()\n                 + \") file status.\", ex);\n             throw ex;\n           }\n         } else {\n-          result[i++] =\n+          internalDirStatuses.add(\n               new FileStatus(0, true, 0, 0, creationTime, creationTime,\n                   PERMISSION_555, ugi.getShortUserName(),\n-                  ugi.getPrimaryGroupName(), path);\n+                  ugi.getPrimaryGroupName(), path));\n         }\n       }\n+      FileStatus[] internalDirStatusesMergedWithFallBack = internalDirStatuses\n+          .toArray(new FileStatus[internalDirStatuses.size()]);\n       if (fallbackStatuses.length > 0) {\n-        return consolidateFileStatuses(fallbackStatuses, result);\n-      } else {\n-        return result;\n+        internalDirStatusesMergedWithFallBack =\n+            merge(fallbackStatuses, internalDirStatusesMergedWithFallBack);\n       }\n+      // Links will always have precedence than internalDir or fallback paths.\n+      return merge(linkStatuses.toArray(new FileStatus[linkStatuses.size()]),\n+          internalDirStatusesMergedWithFallBack);\n     }\n \n-    private FileStatus[] consolidateFileStatuses(FileStatus[] fallbackStatuses,\n-        FileStatus[] mountPointStatuses) {\n+    private FileStatus[] merge(FileStatus[] toStatuses,\n+        FileStatus[] fromStatuses) {\n       ArrayList<FileStatus> result = new ArrayList<>();\n       Set<String> pathSet = new HashSet<>();\n-      for (FileStatus status : mountPointStatuses) {\n+      for (FileStatus status : toStatuses) {\n         result.add(status);\n         pathSet.add(status.getPath().getName());\n       }\n-      for (FileStatus status : fallbackStatuses) {\n+      for (FileStatus status : fromStatuses) {\n         if (!pathSet.contains(status.getPath().getName())) {\n           result.add(status);\n         }\n       }\n-      return result.toArray(new FileStatus[0]);\n+      return result.toArray(new FileStatus[result.size()]);\n     }\n \n     private FileStatus[] listStatusForFallbackLink() throws IOException {\n-      if (theInternalDir.isRoot() &&\n-          theInternalDir.getFallbackLink() != null) {\n-        FileSystem linkedFs =\n-            theInternalDir.getFallbackLink().getTargetFileSystem();\n-        // Fallback link is only applicable for root\n-        FileStatus[] statuses = linkedFs.listStatus(new Path(\"/\"));\n-        for (FileStatus status : statuses) {\n-          // Fix the path back to viewfs scheme\n-          status.setPath(\n-              new Path(myUri.toString(), status.getPath().getName()));\n+      if (this.fsState.getRootFallbackLink() != null) {\n+        FileSystem linkedFallbackFs =\n+            this.fsState.getRootFallbackLink().getTargetFileSystem();\n+        Path p = Path.getPathWithoutSchemeAndAuthority(\n+            new Path(theInternalDir.fullPath));\n+        if (theInternalDir.isRoot() || linkedFallbackFs.exists(p)) {\n+          // Fallback link is only applicable for root", "originalCommit": "e628bcd3b5fe2eee3a43f9444244d00dca3c54df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyNDc5NA==", "url": "https://github.com/apache/hadoop/pull/2088#discussion_r444024794", "bodyText": "Thanks updated java doc as well.", "author": "umamaheswararao", "createdAt": "2020-06-23T07:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk5OTU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwMDAwMA==", "url": "https://github.com/apache/hadoop/pull/2088#discussion_r444000000", "bodyText": "nit: can be assertEqual()", "author": "ayushtkn", "createdAt": "2020-06-23T06:53:33Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "diffHunk": "@@ -359,4 +361,249 @@ public void testListingWithFallbackLinkWithSameMountDirectories()\n       assertTrue(vfs.getFileStatus(childDir).isDirectory());\n     }\n   }\n+\n+  /**\n+   * Tests ListStatus on non-link parent with fallback configured.\n+   * =============================Example.======================================\n+   * ===== Fallback path tree =============== Mount Path Tree ==================\n+   * ===========================================================================\n+   * *             /            *****               /          *****************\n+   * *            /             *****              /           *****************\n+   * *          user1           *****          user1           *****************\n+   * *           /              *****          /               *****************\n+   * *         hive             *****        hive              *****************\n+   * *       /      \\           *****       /                  *****************\n+   * * warehouse    warehouse1  *****  warehouse               *****************\n+   * * (-rwxr--r--)             ***** (-r-xr--r--)             *****************\n+   * *     /                    *****    /                     *****************\n+   * * partition-0              ***** partition-0              *****************\n+   * ===========================================================================\n+   * ===========================================================================\n+   * ***         ls /user1/hive                                        *********\n+   * ***         viewfs://default/user1/hive/warehouse (-rwxr--r--)    *********\n+   * ***         viewfs://default/user1/hive/warehouse1                *********\n+   * ===========================================================================\n+   */\n+  @Test\n+  public void testListingWithFallbackLinkWithSameMountDirectoryTree()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    conf.setBoolean(Constants.CONFIG_VIEWFS_MOUNT_LINKS_AS_SYMLINKS, false);\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    // Creating multiple directories path under the fallback directory.\n+    // \"/user1/hive/warehouse/partition-0\" directory already exists as\n+    // configured mount point.\n+    Path dir1 = new Path(targetTestRoot,\n+        \"fallbackDir/user1/hive/warehouse/partition-0\");\n+    Path dir2 = new Path(targetTestRoot, \"fallbackDir/user1/hive/warehouse1\");\n+    fsTarget.mkdirs(dir1);\n+    fsTarget.mkdirs(dir2);\n+    fsTarget.setPermission(new Path(targetTestRoot, \"fallbackDir/user1/hive/\"),\n+        FsPermission.valueOf(\"-rwxr--r--\"));\n+    URI viewFsUri = new URI(FsConstants.VIEWFS_SCHEME,\n+        Constants.CONFIG_VIEWFS_DEFAULT_MOUNT_TABLE, \"/\", null, null);\n+\n+    HashSet<Path> beforeFallback = new HashSet<>();\n+    try (FileSystem vfs = FileSystem.get(viewFsUri, conf)) {\n+      for (FileStatus stat : vfs\n+          .listStatus(new Path(viewFsUri.toString(), \"/user1/hive/\"))) {\n+        beforeFallback.add(stat.getPath());\n+      }\n+    }\n+    ConfigUtil\n+        .addLinkFallback(conf, new Path(targetTestRoot, \"fallbackDir\").toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsUri, conf)) {\n+      HashSet<Path> afterFallback = new HashSet<>();\n+      for (FileStatus stat : vfs\n+          .listStatus(new Path(viewFsUri.toString(), \"/user1/hive/\"))) {\n+        afterFallback.add(stat.getPath());\n+        if (dir1.getName().equals(stat.getPath().getName())) {\n+          // make sure fallback dir listed out with correct permissions, but not\n+          // with link permissions.\n+          assertEquals(FsPermission.valueOf(\"-rwxr--r--\"),\n+              stat.getPermission());\n+        }\n+      }\n+      //\n+      //viewfs://default/user1/hive/warehouse\n+      afterFallback.removeAll(beforeFallback);\n+      assertTrue(\"The same directory name in fallback link should be shaded\",", "originalCommit": "e628bcd3b5fe2eee3a43f9444244d00dca3c54df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyNDkzNA==", "url": "https://github.com/apache/hadoop/pull/2088#discussion_r444024934", "bodyText": "done.", "author": "umamaheswararao", "createdAt": "2020-06-23T07:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAwMDAwMA=="}], "type": "inlineReview"}, {"oid": "d395b01b4c5f68a6b85c2d75e7c3f58f5ec30bc0", "url": "https://github.com/apache/hadoop/commit/d395b01b4c5f68a6b85c2d75e7c3f58f5ec30bc0", "message": "Updated doc and fixed few review comments.", "committedDate": "2020-06-23T07:41:23Z", "type": "commit"}]}