{"pr_number": 1988, "pr_title": "HDFS-15305. Extend ViewFS and provide ViewFSOverloadScheme implementation with scheme configurable.", "pr_createdAt": "2020-04-30T07:03:37Z", "pr_url": "https://github.com/apache/hadoop/pull/1988", "timeline": [{"oid": "421efbd24c2653273cda895aca33c8a146cecb62", "url": "https://github.com/apache/hadoop/commit/421efbd24c2653273cda895aca33c8a146cecb62", "message": "HDFS-15305. Extend ViewFS and provide ViewFsOverloadScheme implementation with scheme configurable.", "committedDate": "2020-04-30T06:55:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3NTQzNw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418375437", "bodyText": "Why add this here? This is just used in tests right?", "author": "virajith", "createdAt": "2020-05-01T01:23:52Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FsConstants.java", "diffHunk": "@@ -42,4 +42,11 @@\n    */\n   public static final URI VIEWFS_URI = URI.create(\"viewfs:///\");\n   public static final String VIEWFS_SCHEME = \"viewfs\";\n+\n+  public static final String VIEWFS_OVERLOAD_SCHEME_KEY =\n+      \"fs.viewfs.overload.scheme\";\n+  public static final String VIEWFS_OVERLOAD_SCHEME_DEFAULT = \"hdfs\";\n+  public static final String FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN_KEY =\n+      \"fs.viewfs.overload.scheme.target.%s.impl\";\n+  public static final String FS_IMPL_PATTERN_KEY = \"fs.%s.impl\";", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MDQyOQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418460429", "bodyText": "Initial commit was using first two in src, anyway now I removed config of VIEWFS_OVERLOAD_SCHEME_DEFAULT completely. So, only FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN is there now and using this in ViewFsOverloadScheme class.", "author": "umamaheswararao", "createdAt": "2020-05-01T08:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3NTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3NjA0NA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418376044", "bodyText": "javadoc for this method? This seems a bit hacky but I understand the need. I think initializeSuperFs is a slightly  better name but don't have a strong opinion here.", "author": "virajith", "createdAt": "2020-05-01T01:26:26Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystem.java", "diffHunk": "@@ -302,6 +320,11 @@ protected FileSystem getTargetFileSystem(final String settings,\n     }\n   }\n \n+  protected void superFSInit(final URI theUri, final Configuration conf)", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MDYyNg==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418460626", "bodyText": "Removed this method now. After refactoring initialization part, this got addressed along with that.", "author": "umamaheswararao", "createdAt": "2020-05-01T08:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3NjA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3NjI3OQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418376279", "bodyText": "nits:\n\"object is\" -> \"objective here is to handle\"\n\"a multiple\" -> multiple.", "author": "virajith", "createdAt": "2020-05-01T01:27:23Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************\n+ * This class is extended from the ViewFileSystem for the overloaded scheme \n+ * file system. This object is the way end-user code interacts with a multiple", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MDcxNA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418460714", "bodyText": "Thanks corrected them.", "author": "umamaheswararao", "createdAt": "2020-05-01T08:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3NjI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3Njc2Ng==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418376766", "bodyText": "The explanation here is a little confusing. I think it's easier to provide an example on how it works rather than try to write about it.", "author": "virajith", "createdAt": "2020-05-01T01:29:34Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MDg1Nw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418460857", "bodyText": "I added examples please let me know if they are make sense.", "author": "umamaheswararao", "createdAt": "2020-05-01T08:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3Njc2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MDk3Nw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419040977", "bodyText": "Thanks for adding these Uma. A couple of comments:\n(a) \"The objective here is to handle multiple mounted file systems transparently.\", \"Unlike ViewFileSystem\nscheme (viewfs://), the users would be able to use any scheme.\"   --> These are not functions of this class. ViewFileSystem already does this.\n(b) Configuring fs.SCHEME.impl = ViewFsOverloadScheme is not explained in these examples. That should also be brought up.", "author": "virajith", "createdAt": "2020-05-03T03:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3Njc2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE3NDk0Mw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419174943", "bodyText": "#b) added config details. Further more details, we will be covering in user guide.\n#a) first point, yes that ViewFS function. second part, we have overridden getScheme, and that will allow VFSOS to work with any scheme. Any scheme flexibility should come to this class only.", "author": "umamaheswararao", "createdAt": "2020-05-03T23:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3Njc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3OTU5NA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418379594", "bodyText": "What if this is not set? No check for this currently.", "author": "virajith", "createdAt": "2020-05-01T01:42:28Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************\n+ * This class is extended from the ViewFileSystem for the overloaded scheme \n+ * file system. This object is the way end-user code interacts with a multiple\n+ * mounted file systems transparently. Overloaded scheme based uri can be\n+ * continued to use as end user interactive uri and mount links can be\n+ * configured to any Hadoop compatible file system. This class maintains all \n+ * the target file system instances and delegates the calls to respective \n+ * target file system based on mount link mapping. Mount link configuration\n+ * format and behavior is same as ViewFileSystem.\n+ *****************************************************************************/\n+@InterfaceAudience.LimitedPrivate({ \"MapReduce\", \"HBase\", \"Hive\" })\n+@InterfaceStability.Evolving\n+public class ViewFsOverloadScheme extends ViewFileSystem {\n+\n+  public ViewFsOverloadScheme() throws IOException {\n+    super();\n+  }\n+\n+  private FsCreator fsCreator;\n+  private String myScheme;\n+\n+  @Override\n+  public String getScheme() {\n+    return myScheme;\n+  }\n+\n+  @Override\n+  public void initialize(final URI theUri, final Configuration conf)\n+      throws IOException {\n+    superFSInit(theUri, conf);\n+    setConf(conf);\n+    config = conf;\n+    myScheme = config.get(FsConstants.VIEWFS_OVERLOAD_SCHEME_KEY);", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MTIxMg==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418461212", "bodyText": "Good point. This config is not required now. Allowing to init by any scheme URI.", "author": "umamaheswararao", "createdAt": "2020-05-01T08:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM3OTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MDE2Ng==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418380166", "bodyText": "Is there a reason why the scheme of this FS needs to be set using VIEWFS_OVERLOAD_SCHEME_KEY? I would have assumed that we use \"view://\" similar to ViewFileSystem. Will we have valid use cases where fs.getScheme() needs to match \"hdfs\"?", "author": "virajith", "createdAt": "2020-05-01T01:44:55Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************\n+ * This class is extended from the ViewFileSystem for the overloaded scheme \n+ * file system. This object is the way end-user code interacts with a multiple\n+ * mounted file systems transparently. Overloaded scheme based uri can be\n+ * continued to use as end user interactive uri and mount links can be\n+ * configured to any Hadoop compatible file system. This class maintains all \n+ * the target file system instances and delegates the calls to respective \n+ * target file system based on mount link mapping. Mount link configuration\n+ * format and behavior is same as ViewFileSystem.\n+ *****************************************************************************/\n+@InterfaceAudience.LimitedPrivate({ \"MapReduce\", \"HBase\", \"Hive\" })\n+@InterfaceStability.Evolving\n+public class ViewFsOverloadScheme extends ViewFileSystem {\n+\n+  public ViewFsOverloadScheme() throws IOException {\n+    super();\n+  }\n+\n+  private FsCreator fsCreator;\n+  private String myScheme;\n+\n+  @Override\n+  public String getScheme() {\n+    return myScheme;\n+  }\n+\n+  @Override\n+  public void initialize(final URI theUri, final Configuration conf)\n+      throws IOException {\n+    superFSInit(theUri, conf);\n+    setConf(conf);\n+    config = conf;\n+    myScheme = config.get(FsConstants.VIEWFS_OVERLOAD_SCHEME_KEY);", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MTQwNw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418461407", "bodyText": "same as above. Removed this now and that should address your comment. Please let me know if that not the case.", "author": "umamaheswararao", "createdAt": "2020-05-01T08:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MDE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MDk4OA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418380988", "bodyText": "Currently, the override only works for one scheme. This alone can prevent the circular dependency. However, should we consider calling createFileSystem for all schemes that have FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN_KEY set?", "author": "virajith", "createdAt": "2020-05-01T01:48:35Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************\n+ * This class is extended from the ViewFileSystem for the overloaded scheme \n+ * file system. This object is the way end-user code interacts with a multiple\n+ * mounted file systems transparently. Overloaded scheme based uri can be\n+ * continued to use as end user interactive uri and mount links can be\n+ * configured to any Hadoop compatible file system. This class maintains all \n+ * the target file system instances and delegates the calls to respective \n+ * target file system based on mount link mapping. Mount link configuration\n+ * format and behavior is same as ViewFileSystem.\n+ *****************************************************************************/\n+@InterfaceAudience.LimitedPrivate({ \"MapReduce\", \"HBase\", \"Hive\" })\n+@InterfaceStability.Evolving\n+public class ViewFsOverloadScheme extends ViewFileSystem {\n+\n+  public ViewFsOverloadScheme() throws IOException {\n+    super();\n+  }\n+\n+  private FsCreator fsCreator;\n+  private String myScheme;\n+\n+  @Override\n+  public String getScheme() {\n+    return myScheme;\n+  }\n+\n+  @Override\n+  public void initialize(final URI theUri, final Configuration conf)\n+      throws IOException {\n+    superFSInit(theUri, conf);\n+    setConf(conf);\n+    config = conf;\n+    myScheme = config.get(FsConstants.VIEWFS_OVERLOAD_SCHEME_KEY);\n+    fsCreator = new FsCreator() {\n+\n+      /**\n+       * This method is overridden because in ViewFsOverloadScheme if\n+       * overloaded scheme matches with mounted target fs scheme, file system\n+       * should be created without going into fs.<scheme>.impl based \n+       * resolution. Otherwise it will end up into loop as target will be \n+       * resolved again to ViewFsOverloadScheme as fs.<scheme>.impl points to\n+       * ViewFsOverloadScheme. So, below method will initialize the\n+       * fs.viewfs.overload.scheme.target.<scheme>.impl. Other schemes can\n+       * follow fs.newInstance\n+       */\n+      @Override\n+      public FileSystem createFs(URI uri, Configuration conf)\n+          throws IOException {\n+        if (uri.getScheme().equals(myScheme)) {", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MTgwOQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418461809", "bodyText": "Yes, addressed this. Thanks", "author": "umamaheswararao", "createdAt": "2020-05-01T08:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MDk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NTYwNA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419045604", "bodyText": "Don't think this is addressed. I am saying createFileSystem should be called here for every scheme for which the appropriate FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN_KEY is set and only those where uri.getScheme().equals(myScheme) . Wdyt?", "author": "virajith", "createdAt": "2020-05-03T04:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MDk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE3Njg5OQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419176899", "bodyText": "For other schemes which are not matching will be able to get it resolved by FileSystem itself right?\nWhen target uri is scheme is same as OverloadScheme uri sheme, then only we need to bypass to avoid looping. Other cases, FileSystem#get or FileSystem#newInstance will get the right instance. Am I missing?\nSince your exposed uri scheme occupied with OverloadScheme impl, we need that additional config to get actual impl. This was the idea of that configuration.\n\nCurrently, the override only works for one scheme.\n\nUser is going to use one scheme from out side right per OverloadScheme instance right?\nBecause your OverloadScheme init will take one uri to initialize, That will be user initialized uri. Rest all will go as mapping uris.\nexample: inited uri is hdfs://xyz:9000\nmapping target uris are /target1 -> hdfs://target1:9000, /target2 -> hdfs://target2:9000, /target3 -> s3a://bucket1/target3\nHere when getting target fs: we would check if scheme matches with inited. Here hdfs was inited. So, for hdfs scheme, FileSystem#get resolution will always to OverloadSchem impl. To get actual impl we use the FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN_KEY to initialize target fs. Other impls should be able to resolved by FileSystem#get.\nIs your use case is for configuring Overload scheme for all fs..impl in same client process? example in same client process, you would configure, fs.hdfs.impl=ViewFSOverloadScheme and fs.s3a.impl=ViewFSOverloadScheme ?\nBefore changing it would be good for me to understand your use case here. -Thanks", "author": "umamaheswararao", "createdAt": "2020-05-03T23:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MDk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MjIxNg==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418382216", "bodyText": "nit: \"with mounted target fs scheme\" -> \"the scheme of the target fs\"\n\"file system should be created\" -> \"the target file system ..\"", "author": "virajith", "createdAt": "2020-05-01T01:53:50Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************\n+ * This class is extended from the ViewFileSystem for the overloaded scheme \n+ * file system. This object is the way end-user code interacts with a multiple\n+ * mounted file systems transparently. Overloaded scheme based uri can be\n+ * continued to use as end user interactive uri and mount links can be\n+ * configured to any Hadoop compatible file system. This class maintains all \n+ * the target file system instances and delegates the calls to respective \n+ * target file system based on mount link mapping. Mount link configuration\n+ * format and behavior is same as ViewFileSystem.\n+ *****************************************************************************/\n+@InterfaceAudience.LimitedPrivate({ \"MapReduce\", \"HBase\", \"Hive\" })\n+@InterfaceStability.Evolving\n+public class ViewFsOverloadScheme extends ViewFileSystem {\n+\n+  public ViewFsOverloadScheme() throws IOException {\n+    super();\n+  }\n+\n+  private FsCreator fsCreator;\n+  private String myScheme;\n+\n+  @Override\n+  public String getScheme() {\n+    return myScheme;\n+  }\n+\n+  @Override\n+  public void initialize(final URI theUri, final Configuration conf)\n+      throws IOException {\n+    superFSInit(theUri, conf);\n+    setConf(conf);\n+    config = conf;\n+    myScheme = config.get(FsConstants.VIEWFS_OVERLOAD_SCHEME_KEY);\n+    fsCreator = new FsCreator() {\n+\n+      /**\n+       * This method is overridden because in ViewFsOverloadScheme if\n+       * overloaded scheme matches with mounted target fs scheme, file system", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MTUxOQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418461519", "bodyText": "corrected. Thanks", "author": "umamaheswararao", "createdAt": "2020-05-01T08:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MjIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MjUyNw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418382527", "bodyText": "nit: \"into loop\" -> \"in an infinite loop as the target\"", "author": "virajith", "createdAt": "2020-05-01T01:55:04Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************\n+ * This class is extended from the ViewFileSystem for the overloaded scheme \n+ * file system. This object is the way end-user code interacts with a multiple\n+ * mounted file systems transparently. Overloaded scheme based uri can be\n+ * continued to use as end user interactive uri and mount links can be\n+ * configured to any Hadoop compatible file system. This class maintains all \n+ * the target file system instances and delegates the calls to respective \n+ * target file system based on mount link mapping. Mount link configuration\n+ * format and behavior is same as ViewFileSystem.\n+ *****************************************************************************/\n+@InterfaceAudience.LimitedPrivate({ \"MapReduce\", \"HBase\", \"Hive\" })\n+@InterfaceStability.Evolving\n+public class ViewFsOverloadScheme extends ViewFileSystem {\n+\n+  public ViewFsOverloadScheme() throws IOException {\n+    super();\n+  }\n+\n+  private FsCreator fsCreator;\n+  private String myScheme;\n+\n+  @Override\n+  public String getScheme() {\n+    return myScheme;\n+  }\n+\n+  @Override\n+  public void initialize(final URI theUri, final Configuration conf)\n+      throws IOException {\n+    superFSInit(theUri, conf);\n+    setConf(conf);\n+    config = conf;\n+    myScheme = config.get(FsConstants.VIEWFS_OVERLOAD_SCHEME_KEY);\n+    fsCreator = new FsCreator() {\n+\n+      /**\n+       * This method is overridden because in ViewFsOverloadScheme if\n+       * overloaded scheme matches with mounted target fs scheme, file system\n+       * should be created without going into fs.<scheme>.impl based \n+       * resolution. Otherwise it will end up into loop as target will be ", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MTk4OQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418461989", "bodyText": "done.", "author": "umamaheswararao", "createdAt": "2020-05-01T08:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MjUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4NDYxNQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418384615", "bodyText": "If we add a protected method getFsCreator(String scheme) in ViewFileSystem and override it this class,I think initialize can be made much simpler. it just needs to conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, true) and call  super.initialize(theUri, conf). Is that correct?", "author": "virajith", "createdAt": "2020-05-01T02:04:35Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************\n+ * This class is extended from the ViewFileSystem for the overloaded scheme \n+ * file system. This object is the way end-user code interacts with a multiple\n+ * mounted file systems transparently. Overloaded scheme based uri can be\n+ * continued to use as end user interactive uri and mount links can be\n+ * configured to any Hadoop compatible file system. This class maintains all \n+ * the target file system instances and delegates the calls to respective \n+ * target file system based on mount link mapping. Mount link configuration\n+ * format and behavior is same as ViewFileSystem.\n+ *****************************************************************************/\n+@InterfaceAudience.LimitedPrivate({ \"MapReduce\", \"HBase\", \"Hive\" })\n+@InterfaceStability.Evolving\n+public class ViewFsOverloadScheme extends ViewFileSystem {\n+\n+  public ViewFsOverloadScheme() throws IOException {\n+    super();\n+  }\n+\n+  private FsCreator fsCreator;\n+  private String myScheme;\n+\n+  @Override\n+  public String getScheme() {\n+    return myScheme;\n+  }\n+\n+  @Override\n+  public void initialize(final URI theUri, final Configuration conf)", "originalCommit": "421efbd24c2653273cda895aca33c8a146cecb62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MjM1NQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418462355", "bodyText": "Thanks. Refactored and please check if it is addressing this comment.", "author": "umamaheswararao", "createdAt": "2020-05-01T08:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4NDYxNQ=="}], "type": "inlineReview"}, {"oid": "8010048dc27959c10c7a982774b4312f4c64924c", "url": "https://github.com/apache/hadoop/commit/8010048dc27959c10c7a982774b4312f4c64924c", "message": "HDFS-15305. Update: Simplified initialization part and added a test case along with comment fixups.", "committedDate": "2020-05-01T08:13:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMjE1OA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418732158", "bodyText": "why do need this method while we can just call new FsGetter() directly?", "author": "chliang71", "createdAt": "2020-05-01T20:50:29Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystem.java", "diffHunk": "@@ -96,16 +96,49 @@ static AccessControlException readOnlyMountTable(final String operation,\n     return readOnlyMountTable(operation, p.toString());\n   }\n \n+  /**\n+   * File system instance getter.\n+   */\n+  static class FsGetter {\n+\n+    /**\n+     * Gets new file system instance of given uri.\n+     */\n+    public FileSystem getNewInstance(URI uri, Configuration conf)\n+        throws IOException {\n+      return FileSystem.newInstance(uri, conf);\n+    }\n+\n+    /**\n+     * Gets file system instance of given uri.\n+     */\n+    public FileSystem get(URI uri, Configuration conf) throws IOException {\n+      return FileSystem.get(uri, conf);\n+    }\n+  }\n+\n+  /**\n+   * Gets file system creator instance.\n+   */\n+  protected FsGetter fsGetter() {", "originalCommit": "8010048dc27959c10c7a982774b4312f4c64924c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0Mjk2MA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418742960", "bodyText": "Thanks @chliang71  for the review. We have overridden this method in ViewFSOverloadScheme class. In ViewFSOverloadScheme, fsGetter gets its special FsGetter anonymous subclass instance with its own implemented methods. Does this answers your question?", "author": "umamaheswararao", "createdAt": "2020-05-01T21:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1OTE3OQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419659179", "bodyText": "I see, thanks!", "author": "chliang71", "createdAt": "2020-05-04T19:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMjE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMzIyMA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418733220", "bodyText": "a general comment is it would be good to have some logging in this class (DEBUG level)", "author": "chliang71", "createdAt": "2020-05-01T20:53:10Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************\n+ * This class is extended from the ViewFileSystem for the overloaded scheme file\n+ * system. The objective here is to handle multiple mounted file systems\n+ * transparently. Mount link configurations and in-memory mount table\n+ * building behaviors are inherited from ViewFileSystem. Unlike ViewFileSystem\n+ * scheme (viewfs://), the users would be able to use any scheme.\n+ *\n+ * Example 1:\n+ * If users want some of their existing cluster (hdfs://Cluster)\n+ * data to mount with other hdfs and object store clusters(hdfs://NN1,\n+ * o3fs://bucket1.volume1/, s3a://bucket1/)\n+ *\n+ * fs.viewfs.mounttable.Cluster./user = hdfs://NN1/user\n+ * fs.viewfs.mounttable.Cluster./data = o3fs://bucket1.volume1/data\n+ * fs.viewfs.mounttable.Cluster./backup = s3a://bucket1/backup/\n+ *\n+ * Op1: Create file hdfs://Cluster/user/fileA will go to hdfs://NN1/user/fileA\n+ * Op2: Create file hdfs://Cluster/data/datafile will go to\n+ *      o3fs://bucket1.volume1/data/datafile\n+ * Op3: Create file hdfs://Cluster/backup/data.zip will go to\n+ *      s3a://bucket1/backup/data.zip\n+ *\n+ * Example 2:\n+ * If users want some of their existing cluster (s3a://bucketA/)\n+ * data to mount with other hdfs and object store clusters\n+ * (hdfs://NN1, o3fs://bucket1.volume1/)\n+ *\n+ * fs.viewfs.mounttable.bucketA./user = hdfs://NN1/user\n+ * fs.viewfs.mounttable.bucketA./data = o3fs://bucket1.volume1/data\n+ * fs.viewfs.mounttable.bucketA./salesDB = s3a://bucketA/salesDB/\n+ *\n+ * Op1: Create file s3a://bucketA/user/fileA will go to hdfs://NN1/user/fileA\n+ * Op2: Create file s3a://bucketA/data/datafile will go to\n+ *      o3fs://bucket1.volume1/data/datafile\n+ * Op3: Create file s3a://bucketA/salesDB/dbfile will go to\n+ *      s3a://bucketA/salesDB/dbfile\n+ *****************************************************************************/\n+@InterfaceAudience.LimitedPrivate({ \"MapReduce\", \"HBase\", \"Hive\" })\n+@InterfaceStability.Evolving\n+public class ViewFsOverloadScheme extends ViewFileSystem {", "originalCommit": "8010048dc27959c10c7a982774b4312f4c64924c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MzA1Mw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418743053", "bodyText": "Sure I will add logging for this.", "author": "umamaheswararao", "createdAt": "2020-05-01T21:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMzIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczNzEwNQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418737105", "bodyText": "shouldn't this message be testLocalFsLinkSlashMerge? similar for the other test below", "author": "chliang71", "createdAt": "2020-05-01T21:03:54Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeLocalFileSystem.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.LocalFileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ * Test the TestViewFsOverloadSchemeLocalFS using a file with authority:\n+ * file://mountTableName/ i.e, the authority is used to load a mount table.\n+ */\n+public class TestViewFsOverloadSchemeLocalFileSystem {\n+  private static final String FILE = \"file\";\n+  private static final Log LOG =\n+      LogFactory.getLog(TestViewFsOverloadSchemeLocalFileSystem.class);\n+  private FileSystem fsTarget;\n+  private Configuration conf;\n+  private Path targetTestRoot;\n+  private FileSystemTestHelper fileSystemTestHelper;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    conf.set(String.format(\"fs.%s.impl\",\n+        FILE),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        FILE),\n+        LocalFileSystem.class.getName());\n+    fsTarget = new LocalFileSystem();\n+    fsTarget.initialize(new URI(\"file:///\"), conf);\n+    fileSystemTestHelper = new FileSystemTestHelper();\n+    // create the test root on local_fs\n+    targetTestRoot = fileSystemTestHelper.getAbsoluteTestRootPath(fsTarget);\n+    fsTarget.delete(targetTestRoot, true);\n+    fsTarget.mkdirs(targetTestRoot);\n+  }\n+\n+  /**\n+   * Tests write file and read file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalTargetLinkWriteSimple() throws IOException {\n+    LOG.info(\"Starting testLocalTargetLinkWriteSimple\");\n+    final String testString = \"Hello Local!...\";\n+    final Path lfsRoot = new Path(\"/lfsRoot\");\n+    ConfigUtil.addLink(conf, lfsRoot.toString(),\n+        URI.create(targetTestRoot + \"/local\"));\n+    final FileSystem lViewFs = FileSystem.get(URI.create(\"file:///\"), conf);\n+\n+    final Path testPath = new Path(lfsRoot, \"test.txt\");\n+    final FSDataOutputStream fsDos = lViewFs.create(testPath);\n+    try {\n+      fsDos.writeUTF(testString);\n+    } finally {\n+      fsDos.close();\n+    }\n+\n+    FSDataInputStream lViewIs = lViewFs.open(testPath);\n+    try {\n+      Assert.assertEquals(testString, lViewIs.readUTF());\n+    } finally {\n+      lViewIs.close();\n+    }\n+  }\n+\n+  /**\n+   * Tests create file and delete file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalFsCreateAndDelete() throws Exception {\n+    LOG.info(\"Starting testLocalFsCreateAndDelete\");\n+    ConfigUtil.addLink(conf, \"mt\", \"/lfsroot\",\n+        URI.create(targetTestRoot + \"/wd2\"));\n+    final URI mountURI = URI.create(\"file://mt/\");\n+    final FileSystem lViewFS = FileSystem.get(mountURI, conf);\n+    try {\n+      Path testPath = new Path(mountURI.toString() + \"/lfsroot/test\");\n+      lViewFS.create(testPath);\n+      Assert.assertTrue(lViewFS.exists(testPath));\n+      lViewFS.delete(testPath, true);\n+      Assert.assertFalse(lViewFS.exists(testPath));\n+    } finally {\n+      lViewFS.close();\n+    }\n+  }\n+\n+  /**\n+   * Tests root level file with linkMergeSlash with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalFsLinkSlashMerge() throws Exception {\n+    LOG.info(\"Starting testLocalFSCreateAndDelete\");", "originalCommit": "8010048dc27959c10c7a982774b4312f4c64924c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MzUzMA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r418743530", "bodyText": "thanks. I will change them in next patch.", "author": "umamaheswararao", "createdAt": "2020-05-01T21:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczNzEwNQ=="}], "type": "inlineReview"}, {"oid": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "url": "https://github.com/apache/hadoop/commit/c1525f808f02ed40ca7451d4d71b7fa12708e106", "message": "HDFS-15305. Update: Fixed few review comments..", "committedDate": "2020-05-01T22:28:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MjEyNQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419042125", "bodyText": "indentation of the conf.set lines is confusing. can you make this better?", "author": "virajith", "createdAt": "2020-05-03T03:46:45Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeLocalFileSystem.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.LocalFileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ * Test the TestViewFsOverloadSchemeLocalFS using a file with authority:\n+ * file://mountTableName/ i.e, the authority is used to load a mount table.\n+ */\n+public class TestViewFsOverloadSchemeLocalFileSystem {\n+  private static final String FILE = \"file\";\n+  private static final Log LOG =\n+      LogFactory.getLog(TestViewFsOverloadSchemeLocalFileSystem.class);\n+  private FileSystem fsTarget;\n+  private Configuration conf;\n+  private Path targetTestRoot;\n+  private FileSystemTestHelper fileSystemTestHelper;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    conf.set(String.format(\"fs.%s.impl\",", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MjM1NA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419042354", "bodyText": "try (FSDataOutputStream fsDos = lViewFs.create(testPath)) { }", "author": "virajith", "createdAt": "2020-05-03T03:49:17Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeLocalFileSystem.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.LocalFileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ * Test the TestViewFsOverloadSchemeLocalFS using a file with authority:\n+ * file://mountTableName/ i.e, the authority is used to load a mount table.\n+ */\n+public class TestViewFsOverloadSchemeLocalFileSystem {\n+  private static final String FILE = \"file\";\n+  private static final Log LOG =\n+      LogFactory.getLog(TestViewFsOverloadSchemeLocalFileSystem.class);\n+  private FileSystem fsTarget;\n+  private Configuration conf;\n+  private Path targetTestRoot;\n+  private FileSystemTestHelper fileSystemTestHelper;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    conf.set(String.format(\"fs.%s.impl\",\n+        FILE),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        FILE),\n+        LocalFileSystem.class.getName());\n+    fsTarget = new LocalFileSystem();\n+    fsTarget.initialize(new URI(\"file:///\"), conf);\n+    fileSystemTestHelper = new FileSystemTestHelper();\n+    // create the test root on local_fs\n+    targetTestRoot = fileSystemTestHelper.getAbsoluteTestRootPath(fsTarget);\n+    fsTarget.delete(targetTestRoot, true);\n+    fsTarget.mkdirs(targetTestRoot);\n+  }\n+\n+  /**\n+   * Tests write file and read file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalTargetLinkWriteSimple() throws IOException {\n+    LOG.info(\"Starting testLocalTargetLinkWriteSimple\");\n+    final String testString = \"Hello Local!...\";\n+    final Path lfsRoot = new Path(\"/lfsRoot\");\n+    ConfigUtil.addLink(conf, lfsRoot.toString(),\n+        URI.create(targetTestRoot + \"/local\"));\n+    final FileSystem lViewFs = FileSystem.get(URI.create(\"file:///\"), conf);\n+\n+    final Path testPath = new Path(lfsRoot, \"test.txt\");\n+    final FSDataOutputStream fsDos = lViewFs.create(testPath);", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MjM5OA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419042398", "bodyText": "try(FSDataInputStream lViewIs = lViewFs.open(testPath)) {}", "author": "virajith", "createdAt": "2020-05-03T03:49:54Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeLocalFileSystem.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.LocalFileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ * Test the TestViewFsOverloadSchemeLocalFS using a file with authority:\n+ * file://mountTableName/ i.e, the authority is used to load a mount table.\n+ */\n+public class TestViewFsOverloadSchemeLocalFileSystem {\n+  private static final String FILE = \"file\";\n+  private static final Log LOG =\n+      LogFactory.getLog(TestViewFsOverloadSchemeLocalFileSystem.class);\n+  private FileSystem fsTarget;\n+  private Configuration conf;\n+  private Path targetTestRoot;\n+  private FileSystemTestHelper fileSystemTestHelper;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    conf.set(String.format(\"fs.%s.impl\",\n+        FILE),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        FILE),\n+        LocalFileSystem.class.getName());\n+    fsTarget = new LocalFileSystem();\n+    fsTarget.initialize(new URI(\"file:///\"), conf);\n+    fileSystemTestHelper = new FileSystemTestHelper();\n+    // create the test root on local_fs\n+    targetTestRoot = fileSystemTestHelper.getAbsoluteTestRootPath(fsTarget);\n+    fsTarget.delete(targetTestRoot, true);\n+    fsTarget.mkdirs(targetTestRoot);\n+  }\n+\n+  /**\n+   * Tests write file and read file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalTargetLinkWriteSimple() throws IOException {\n+    LOG.info(\"Starting testLocalTargetLinkWriteSimple\");\n+    final String testString = \"Hello Local!...\";\n+    final Path lfsRoot = new Path(\"/lfsRoot\");\n+    ConfigUtil.addLink(conf, lfsRoot.toString(),\n+        URI.create(targetTestRoot + \"/local\"));\n+    final FileSystem lViewFs = FileSystem.get(URI.create(\"file:///\"), conf);\n+\n+    final Path testPath = new Path(lfsRoot, \"test.txt\");\n+    final FSDataOutputStream fsDos = lViewFs.create(testPath);\n+    try {\n+      fsDos.writeUTF(testString);\n+    } finally {\n+      fsDos.close();\n+    }\n+\n+    FSDataInputStream lViewIs = lViewFs.open(testPath);\n+    try {", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MjcxNA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419042714", "bodyText": "stream is not closed. may be use createNewFile?", "author": "virajith", "createdAt": "2020-05-03T03:54:13Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeLocalFileSystem.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.LocalFileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ * Test the TestViewFsOverloadSchemeLocalFS using a file with authority:\n+ * file://mountTableName/ i.e, the authority is used to load a mount table.\n+ */\n+public class TestViewFsOverloadSchemeLocalFileSystem {\n+  private static final String FILE = \"file\";\n+  private static final Log LOG =\n+      LogFactory.getLog(TestViewFsOverloadSchemeLocalFileSystem.class);\n+  private FileSystem fsTarget;\n+  private Configuration conf;\n+  private Path targetTestRoot;\n+  private FileSystemTestHelper fileSystemTestHelper;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    conf.set(String.format(\"fs.%s.impl\",\n+        FILE),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        FILE),\n+        LocalFileSystem.class.getName());\n+    fsTarget = new LocalFileSystem();\n+    fsTarget.initialize(new URI(\"file:///\"), conf);\n+    fileSystemTestHelper = new FileSystemTestHelper();\n+    // create the test root on local_fs\n+    targetTestRoot = fileSystemTestHelper.getAbsoluteTestRootPath(fsTarget);\n+    fsTarget.delete(targetTestRoot, true);\n+    fsTarget.mkdirs(targetTestRoot);\n+  }\n+\n+  /**\n+   * Tests write file and read file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalTargetLinkWriteSimple() throws IOException {\n+    LOG.info(\"Starting testLocalTargetLinkWriteSimple\");\n+    final String testString = \"Hello Local!...\";\n+    final Path lfsRoot = new Path(\"/lfsRoot\");\n+    ConfigUtil.addLink(conf, lfsRoot.toString(),\n+        URI.create(targetTestRoot + \"/local\"));\n+    final FileSystem lViewFs = FileSystem.get(URI.create(\"file:///\"), conf);\n+\n+    final Path testPath = new Path(lfsRoot, \"test.txt\");\n+    final FSDataOutputStream fsDos = lViewFs.create(testPath);\n+    try {\n+      fsDos.writeUTF(testString);\n+    } finally {\n+      fsDos.close();\n+    }\n+\n+    FSDataInputStream lViewIs = lViewFs.open(testPath);\n+    try {\n+      Assert.assertEquals(testString, lViewIs.readUTF());\n+    } finally {\n+      lViewIs.close();\n+    }\n+  }\n+\n+  /**\n+   * Tests create file and delete file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalFsCreateAndDelete() throws Exception {\n+    LOG.info(\"Starting testLocalFsCreateAndDelete\");\n+    ConfigUtil.addLink(conf, \"mt\", \"/lfsroot\",\n+        URI.create(targetTestRoot + \"/wd2\"));\n+    final URI mountURI = URI.create(\"file://mt/\");\n+    final FileSystem lViewFS = FileSystem.get(mountURI, conf);\n+    try {\n+      Path testPath = new Path(mountURI.toString() + \"/lfsroot/test\");\n+      lViewFS.create(testPath);", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA2NzUwNg==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419067506", "bodyText": "Let me use this other method which closes itself. I dont need stream here.", "author": "umamaheswararao", "createdAt": "2020-05-03T08:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MjcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0Mjc3MA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419042770", "bodyText": "same comment here -- use createNewFile?", "author": "virajith", "createdAt": "2020-05-03T03:54:48Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeLocalFileSystem.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.LocalFileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ * Test the TestViewFsOverloadSchemeLocalFS using a file with authority:\n+ * file://mountTableName/ i.e, the authority is used to load a mount table.\n+ */\n+public class TestViewFsOverloadSchemeLocalFileSystem {\n+  private static final String FILE = \"file\";\n+  private static final Log LOG =\n+      LogFactory.getLog(TestViewFsOverloadSchemeLocalFileSystem.class);\n+  private FileSystem fsTarget;\n+  private Configuration conf;\n+  private Path targetTestRoot;\n+  private FileSystemTestHelper fileSystemTestHelper;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    conf.set(String.format(\"fs.%s.impl\",\n+        FILE),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        FILE),\n+        LocalFileSystem.class.getName());\n+    fsTarget = new LocalFileSystem();\n+    fsTarget.initialize(new URI(\"file:///\"), conf);\n+    fileSystemTestHelper = new FileSystemTestHelper();\n+    // create the test root on local_fs\n+    targetTestRoot = fileSystemTestHelper.getAbsoluteTestRootPath(fsTarget);\n+    fsTarget.delete(targetTestRoot, true);\n+    fsTarget.mkdirs(targetTestRoot);\n+  }\n+\n+  /**\n+   * Tests write file and read file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalTargetLinkWriteSimple() throws IOException {\n+    LOG.info(\"Starting testLocalTargetLinkWriteSimple\");\n+    final String testString = \"Hello Local!...\";\n+    final Path lfsRoot = new Path(\"/lfsRoot\");\n+    ConfigUtil.addLink(conf, lfsRoot.toString(),\n+        URI.create(targetTestRoot + \"/local\"));\n+    final FileSystem lViewFs = FileSystem.get(URI.create(\"file:///\"), conf);\n+\n+    final Path testPath = new Path(lfsRoot, \"test.txt\");\n+    final FSDataOutputStream fsDos = lViewFs.create(testPath);\n+    try {\n+      fsDos.writeUTF(testString);\n+    } finally {\n+      fsDos.close();\n+    }\n+\n+    FSDataInputStream lViewIs = lViewFs.open(testPath);\n+    try {\n+      Assert.assertEquals(testString, lViewIs.readUTF());\n+    } finally {\n+      lViewIs.close();\n+    }\n+  }\n+\n+  /**\n+   * Tests create file and delete file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalFsCreateAndDelete() throws Exception {\n+    LOG.info(\"Starting testLocalFsCreateAndDelete\");\n+    ConfigUtil.addLink(conf, \"mt\", \"/lfsroot\",\n+        URI.create(targetTestRoot + \"/wd2\"));\n+    final URI mountURI = URI.create(\"file://mt/\");\n+    final FileSystem lViewFS = FileSystem.get(mountURI, conf);\n+    try {\n+      Path testPath = new Path(mountURI.toString() + \"/lfsroot/test\");\n+      lViewFS.create(testPath);\n+      Assert.assertTrue(lViewFS.exists(testPath));\n+      lViewFS.delete(testPath, true);\n+      Assert.assertFalse(lViewFS.exists(testPath));\n+    } finally {\n+      lViewFS.close();\n+    }\n+  }\n+\n+  /**\n+   * Tests root level file with linkMergeSlash with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalFsLinkSlashMerge() throws Exception {\n+    LOG.info(\"Starting testLocalFsLinkSlashMerge\");\n+    ConfigUtil.addLinkMergeSlash(conf, \"mt\",\n+        URI.create(targetTestRoot + \"/wd2\"));\n+    final URI mountURI = URI.create(\"file://mt/\");\n+    final FileSystem lViewFS = FileSystem.get(mountURI, conf);\n+    try {\n+      Path fileOnRoot = new Path(mountURI.toString() + \"/NewFile\");\n+      lViewFS.create(fileOnRoot);", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MzEwMg==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419043102", "bodyText": "fsTarget.close() as well?", "author": "virajith", "createdAt": "2020-05-03T03:59:08Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeLocalFileSystem.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.LocalFileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ * Test the TestViewFsOverloadSchemeLocalFS using a file with authority:\n+ * file://mountTableName/ i.e, the authority is used to load a mount table.\n+ */\n+public class TestViewFsOverloadSchemeLocalFileSystem {\n+  private static final String FILE = \"file\";\n+  private static final Log LOG =\n+      LogFactory.getLog(TestViewFsOverloadSchemeLocalFileSystem.class);\n+  private FileSystem fsTarget;\n+  private Configuration conf;\n+  private Path targetTestRoot;\n+  private FileSystemTestHelper fileSystemTestHelper;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    conf.set(String.format(\"fs.%s.impl\",\n+        FILE),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        FILE),\n+        LocalFileSystem.class.getName());\n+    fsTarget = new LocalFileSystem();\n+    fsTarget.initialize(new URI(\"file:///\"), conf);\n+    fileSystemTestHelper = new FileSystemTestHelper();\n+    // create the test root on local_fs\n+    targetTestRoot = fileSystemTestHelper.getAbsoluteTestRootPath(fsTarget);\n+    fsTarget.delete(targetTestRoot, true);\n+    fsTarget.mkdirs(targetTestRoot);\n+  }\n+\n+  /**\n+   * Tests write file and read file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalTargetLinkWriteSimple() throws IOException {\n+    LOG.info(\"Starting testLocalTargetLinkWriteSimple\");\n+    final String testString = \"Hello Local!...\";\n+    final Path lfsRoot = new Path(\"/lfsRoot\");\n+    ConfigUtil.addLink(conf, lfsRoot.toString(),\n+        URI.create(targetTestRoot + \"/local\"));\n+    final FileSystem lViewFs = FileSystem.get(URI.create(\"file:///\"), conf);\n+\n+    final Path testPath = new Path(lfsRoot, \"test.txt\");\n+    final FSDataOutputStream fsDos = lViewFs.create(testPath);\n+    try {\n+      fsDos.writeUTF(testString);\n+    } finally {\n+      fsDos.close();\n+    }\n+\n+    FSDataInputStream lViewIs = lViewFs.open(testPath);\n+    try {\n+      Assert.assertEquals(testString, lViewIs.readUTF());\n+    } finally {\n+      lViewIs.close();\n+    }\n+  }\n+\n+  /**\n+   * Tests create file and delete file with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalFsCreateAndDelete() throws Exception {\n+    LOG.info(\"Starting testLocalFsCreateAndDelete\");\n+    ConfigUtil.addLink(conf, \"mt\", \"/lfsroot\",\n+        URI.create(targetTestRoot + \"/wd2\"));\n+    final URI mountURI = URI.create(\"file://mt/\");\n+    final FileSystem lViewFS = FileSystem.get(mountURI, conf);\n+    try {\n+      Path testPath = new Path(mountURI.toString() + \"/lfsroot/test\");\n+      lViewFS.create(testPath);\n+      Assert.assertTrue(lViewFS.exists(testPath));\n+      lViewFS.delete(testPath, true);\n+      Assert.assertFalse(lViewFS.exists(testPath));\n+    } finally {\n+      lViewFS.close();\n+    }\n+  }\n+\n+  /**\n+   * Tests root level file with linkMergeSlash with ViewFSOverloadScheme.\n+   */\n+  @Test\n+  public void testLocalFsLinkSlashMerge() throws Exception {\n+    LOG.info(\"Starting testLocalFsLinkSlashMerge\");\n+    ConfigUtil.addLinkMergeSlash(conf, \"mt\",\n+        URI.create(targetTestRoot + \"/wd2\"));\n+    final URI mountURI = URI.create(\"file://mt/\");\n+    final FileSystem lViewFS = FileSystem.get(mountURI, conf);\n+    try {\n+      Path fileOnRoot = new Path(mountURI.toString() + \"/NewFile\");\n+      lViewFS.create(fileOnRoot);\n+      Assert.assertTrue(lViewFS.exists(fileOnRoot));\n+    } finally {\n+      lViewFS.close();\n+    }\n+  }\n+\n+  /**\n+   * Tests with linkMergeSlash and other mounts in ViewFSOverloadScheme.\n+   */\n+  @Test(expected = IOException.class)\n+  public void testLocalFsLinkSlashMergeWithOtherMountLinks() throws Exception {\n+    LOG.info(\"Starting testLocalFsLinkSlashMergeWithOtherMountLinks\");\n+    ConfigUtil.addLink(conf, \"mt\", \"/lfsroot\",\n+        URI.create(targetTestRoot + \"/wd2\"));\n+    ConfigUtil.addLinkMergeSlash(conf, \"mt\",\n+        URI.create(targetTestRoot + \"/wd2\"));\n+    final URI mountURI = URI.create(\"file://mt/\");\n+    FileSystem.get(mountURI, conf);\n+    Assert.fail(\"A merge slash cannot be configured with other mount links.\");\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    fsTarget.delete(fileSystemTestHelper.getTestRootPath(fsTarget), true);", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MzY1OQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419043659", "bodyText": "cast not required.", "author": "virajith", "createdAt": "2020-05-03T04:06:11Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeHdfsFileSystemContract.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import static org.junit.Assume.assumeTrue;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.CommonConfigurationKeys;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemContractBaseTest;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.AppendTestUtil;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.HdfsConfiguration;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.TestHDFSFileSystemContract;\n+import org.apache.hadoop.security.AccessControlException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+/**\n+ * Tests ViewFsOverloadScheme with file system contract tests.\n+ */\n+public class TestViewFsOverloadSchemeHdfsFileSystemContract\n+    extends TestHDFSFileSystemContract {\n+\n+  private MiniDFSCluster cluster;\n+  private String defaultWorkingDirectory;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    final Configuration conf = new HdfsConfiguration();\n+    conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY,\n+        FileSystemContractBaseTest.TEST_UMASK);\n+    final File basedir = GenericTestUtils.getRandomizedTestDir();\n+    cluster = new MiniDFSCluster.Builder(conf, basedir)\n+        .numDataNodes(2)\n+        .build();\n+    defaultWorkingDirectory =\n+        \"/user/\" + UserGroupInformation.getCurrentUser().getShortUserName();\n+    conf.set(String.format(\"fs.%s.impl\", \"hdfs\"),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        \"hdfs\"),\n+        DistributedFileSystem.class.getName());\n+    URI defaultFSURI =\n+        URI.create(conf.get(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY));\n+    ConfigUtil.addLink(conf, defaultFSURI.getAuthority(), \"/user\",\n+        defaultFSURI);\n+    ConfigUtil.addLink(conf, defaultFSURI.getAuthority(), \"/append\",\n+        defaultFSURI);\n+    ConfigUtil.addLink(conf, defaultFSURI.getAuthority(),\n+        \"/FileSystemContractBaseTest/\",\n+        new URI(defaultFSURI.toString() + \"/FileSystemContractBaseTest/\"));\n+    fs = (ViewFsOverloadScheme) FileSystem.get(conf);", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MzkwOA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419043908", "bodyText": "Except for these two, can the rest be done @BeforeClass?", "author": "virajith", "createdAt": "2020-05-03T04:09:01Z", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeLocalFileSystem.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.LocalFileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ *\n+ * Test the TestViewFsOverloadSchemeLocalFS using a file with authority:\n+ * file://mountTableName/ i.e, the authority is used to load a mount table.\n+ */\n+public class TestViewFsOverloadSchemeLocalFileSystem {\n+  private static final String FILE = \"file\";\n+  private static final Log LOG =\n+      LogFactory.getLog(TestViewFsOverloadSchemeLocalFileSystem.class);\n+  private FileSystem fsTarget;\n+  private Configuration conf;\n+  private Path targetTestRoot;\n+  private FileSystemTestHelper fileSystemTestHelper;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    conf.set(String.format(\"fs.%s.impl\",\n+        FILE),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        FILE),\n+        LocalFileSystem.class.getName());\n+    fsTarget = new LocalFileSystem();\n+    fsTarget.initialize(new URI(\"file:///\"), conf);\n+    fileSystemTestHelper = new FileSystemTestHelper();\n+    // create the test root on local_fs\n+    targetTestRoot = fileSystemTestHelper.getAbsoluteTestRootPath(fsTarget);\n+    fsTarget.delete(targetTestRoot, true);", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA2NzczNQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419067735", "bodyText": "Some tests has slashmerge config which will not work if there are other mount links in config. I think its ok to keep config inits in @before ( local fs is not heavy)", "author": "umamaheswararao", "createdAt": "2020-05-03T08:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0MzkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NDAzNw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419044037", "bodyText": "do we need the cluster created for every test? seems heavy :|\nAlso, can we set FS_DEFAULT_NAME_KEY explicitly here?", "author": "virajith", "createdAt": "2020-05-03T04:11:05Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeHdfsFileSystemContract.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import static org.junit.Assume.assumeTrue;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.CommonConfigurationKeys;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemContractBaseTest;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.AppendTestUtil;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.HdfsConfiguration;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.TestHDFSFileSystemContract;\n+import org.apache.hadoop.security.AccessControlException;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+/**\n+ * Tests ViewFsOverloadScheme with file system contract tests.\n+ */\n+public class TestViewFsOverloadSchemeHdfsFileSystemContract\n+    extends TestHDFSFileSystemContract {\n+\n+  private MiniDFSCluster cluster;\n+  private String defaultWorkingDirectory;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    final Configuration conf = new HdfsConfiguration();\n+    conf.set(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY,\n+        FileSystemContractBaseTest.TEST_UMASK);\n+    final File basedir = GenericTestUtils.getRandomizedTestDir();\n+    cluster = new MiniDFSCluster.Builder(conf, basedir)", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA2OTc1MQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419069751", "bodyText": "Let me check that if I can start cluster once and use. We reused existing HDFSContract test.\nIf existing contract tests passes with one time cluster start, I should be good to do that. I will try that.\nWhy do we need to set  FS_DEFAULT_NAME_KEY explicitly? Minicluster will do that for is we use that same config.", "author": "umamaheswararao", "createdAt": "2020-05-03T08:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NDAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE3OTc1Mg==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419179752", "bodyText": "I tried to moved cluster init into Before class. Contract tests are passing. Please check.", "author": "umamaheswararao", "createdAt": "2020-05-04T00:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NDAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NDI4Mw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419044283", "bodyText": "I think ViewOverloadSchemeFilesystem is a better name. Also do we need an implementation extending ViewFs class (which extends AbstractFileSystem)?", "author": "virajith", "createdAt": "2020-05-03T04:14:15Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFsOverloadScheme.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URI;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+\n+/******************************************************************************\n+ * This class is extended from the ViewFileSystem for the overloaded scheme file\n+ * system. The objective here is to handle multiple mounted file systems\n+ * transparently. Mount link configurations and in-memory mount table\n+ * building behaviors are inherited from ViewFileSystem. Unlike ViewFileSystem\n+ * scheme (viewfs://), the users would be able to use any scheme.\n+ *\n+ * Example 1:\n+ * If users want some of their existing cluster (hdfs://Cluster)\n+ * data to mount with other hdfs and object store clusters(hdfs://NN1,\n+ * o3fs://bucket1.volume1/, s3a://bucket1/)\n+ *\n+ * fs.viewfs.mounttable.Cluster./user = hdfs://NN1/user\n+ * fs.viewfs.mounttable.Cluster./data = o3fs://bucket1.volume1/data\n+ * fs.viewfs.mounttable.Cluster./backup = s3a://bucket1/backup/\n+ *\n+ * Op1: Create file hdfs://Cluster/user/fileA will go to hdfs://NN1/user/fileA\n+ * Op2: Create file hdfs://Cluster/data/datafile will go to\n+ *      o3fs://bucket1.volume1/data/datafile\n+ * Op3: Create file hdfs://Cluster/backup/data.zip will go to\n+ *      s3a://bucket1/backup/data.zip\n+ *\n+ * Example 2:\n+ * If users want some of their existing cluster (s3a://bucketA/)\n+ * data to mount with other hdfs and object store clusters\n+ * (hdfs://NN1, o3fs://bucket1.volume1/)\n+ *\n+ * fs.viewfs.mounttable.bucketA./user = hdfs://NN1/user\n+ * fs.viewfs.mounttable.bucketA./data = o3fs://bucket1.volume1/data\n+ * fs.viewfs.mounttable.bucketA./salesDB = s3a://bucketA/salesDB/\n+ *\n+ * Op1: Create file s3a://bucketA/user/fileA will go to hdfs://NN1/user/fileA\n+ * Op2: Create file s3a://bucketA/data/datafile will go to\n+ *      o3fs://bucket1.volume1/data/datafile\n+ * Op3: Create file s3a://bucketA/salesDB/dbfile will go to\n+ *      s3a://bucketA/salesDB/dbfile\n+ *****************************************************************************/\n+@InterfaceAudience.LimitedPrivate({ \"MapReduce\", \"HBase\", \"Hive\" })\n+@InterfaceStability.Evolving\n+public class ViewFsOverloadScheme extends ViewFileSystem {", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA1ODQ1NA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419058454", "bodyText": "This we discussed. Sanjay suggested to keep ViewFsOverloadScheme to indicate that most of the implementation is ViewFS itself but we get to overload the scheme. ViewOverloadSchemeFilesystem and ViewFsOverloadScheme are discussed names while writing the doc. :-)\nYes, we have that FileContext based implementation in consideration. I will be filing a JIRA for that.", "author": "umamaheswararao", "createdAt": "2020-05-03T06:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NDI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NTA5Mw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419045093", "bodyText": "calling createLinks isn't even needed here right?", "author": "virajith", "createdAt": "2020-05-03T04:24:39Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeWithHdfsScheme.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.CommonConfigurationKeys;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.RawLocalFileSystem;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+import org.apache.hadoop.hdfs.DFSConfigKeys;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.security.AccessControlException;\n+import org.apache.hadoop.test.PathUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Tests ViewFsOverloadScheme with configured mount links.\n+ */\n+public class TestViewFsOverloadSchemeWithHdfsScheme {\n+  private static final String FS_IMPL_PATTERN_KEY = \"fs.%s.impl\";\n+  private static final String HDFS_SCHEME = \"hdfs\";\n+  private Configuration conf = null;\n+  private MiniDFSCluster cluster = null;\n+  private URI defaultFSURI;\n+  private File localTargetDir;\n+  private static final String TEST_ROOT_DIR =\n+      PathUtils.getTestDirName(TestViewFsOverloadSchemeWithHdfsScheme.class);\n+  private static final String HDFS_USER_FOLDER = \"/HDFSUser\";\n+  private static final String LOCAL_FOLDER = \"/local\";\n+\n+  @Before\n+  public void startCluster() throws IOException {\n+    conf = new Configuration();\n+    conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,\n+        true);\n+    conf.set(String.format(FS_IMPL_PATTERN_KEY, HDFS_SCHEME),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        HDFS_SCHEME), DistributedFileSystem.class.getName());\n+    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(2).build();\n+    cluster.waitClusterUp();\n+    defaultFSURI =\n+        URI.create(conf.get(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY));\n+    localTargetDir = new File(TEST_ROOT_DIR, \"/root/\");\n+    Assert.assertEquals(HDFS_SCHEME, defaultFSURI.getScheme()); // hdfs scheme.\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    if (cluster != null) {\n+      FileSystem.closeAll();\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  private void createLinks(boolean needFalbackLink, Path hdfsTargetPath,\n+      Path localTragetPath) {\n+    ConfigUtil.addLink(conf, defaultFSURI.getAuthority(), HDFS_USER_FOLDER,\n+        hdfsTargetPath.toUri());\n+    ConfigUtil.addLink(conf, defaultFSURI.getAuthority(), LOCAL_FOLDER,\n+        localTragetPath.toUri());\n+    if (needFalbackLink) {\n+      ConfigUtil.addLinkFallback(conf, defaultFSURI.getAuthority(),\n+          hdfsTargetPath.toUri());\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows.\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   *\n+   * create file /HDFSUser/testfile should create in hdfs\n+   * create file /local/test should create directory in local fs\n+   */\n+  @Test(timeout = 30000)\n+  public void testMountLinkWithLocalAndHDFS() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(false, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    Assert.assertEquals(2, fs.getMountPoints().length);\n+\n+    // /HDFSUser/testfile\n+    Path hdfsFile = new Path(HDFS_USER_FOLDER + \"/testfile\");\n+    // /local/test\n+    Path localDir = new Path(LOCAL_FOLDER + \"/test\");\n+\n+    fs.create(hdfsFile); // /HDFSUser/testfile\n+    fs.mkdirs(localDir); // /local/test\n+\n+    // Initialize HDFS and test files exist in ls or not\n+    DistributedFileSystem dfs = new DistributedFileSystem();\n+    dfs.initialize(defaultFSURI, conf);\n+    try {\n+      Assert.assertTrue(dfs.exists(\n+          new Path(Path.getPathWithoutSchemeAndAuthority(hdfsTargetPath),\n+              hdfsFile.getName()))); // should be in hdfs.\n+      Assert.assertFalse(dfs.exists(\n+          new Path(Path.getPathWithoutSchemeAndAuthority(localTragetPath),\n+              localDir.getName()))); // should not be in local fs.\n+    } finally {\n+      dfs.close();\n+    }\n+\n+    RawLocalFileSystem lfs = new RawLocalFileSystem();\n+    lfs.initialize(localTragetPath.toUri(), conf);\n+    try {\n+      Assert.assertFalse(lfs.exists(\n+          new Path(Path.getPathWithoutSchemeAndAuthority(hdfsTargetPath),\n+              hdfsFile.getName()))); // should not be in hdfs.\n+      Assert.assertTrue(lfs.exists(\n+          new Path(Path.getPathWithoutSchemeAndAuthority(localTragetPath),\n+              localDir.getName()))); // should be in local fs.\n+    } finally {\n+      lfs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows.\n+   * hdfs://localhost:xxx/HDFSUser --> nonexistent://NonExistent/User/\n+   * It should fail to add non existent fs link.\n+   */\n+  @Test(expected = IOException.class, timeout = 30000)\n+  public void testMountLinkWithNonExistentLink() throws Exception {\n+    final String userFolder = \"/User\";\n+    final Path nonExistTargetPath =\n+        new Path(\"nonexistent://NonExistent\" + userFolder);\n+\n+    /**\n+     * Below addLink will create following mount points\n+     * hdfs://localhost:xxx/User --> nonexistent://NonExistent/User/\n+     */\n+    ConfigUtil.addLink(conf, defaultFSURI.getAuthority(), userFolder,\n+        nonExistTargetPath.toUri());\n+    FileSystem.get(conf);\n+    Assert.fail(\"Expected to fail with non existent link\");\n+  }\n+\n+  /**\n+   * Create mount links as follows.\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   * ListStatus on / should list the mount links.\n+   */\n+  @Test(timeout = 30000)\n+  public void testListStatusOnRootShouldListAllMountLinks() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(false, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      FileStatus[] ls = fs.listStatus(new Path(\"/\"));\n+      Assert.assertEquals(2, ls.length);\n+      String lsPath1 =\n+          Path.getPathWithoutSchemeAndAuthority(ls[0].getPath()).toString();\n+      String lsPath2 =\n+          Path.getPathWithoutSchemeAndAuthority(ls[1].getPath()).toString();\n+      Assert.assertTrue(\n+          HDFS_USER_FOLDER.equals(lsPath1) || LOCAL_FOLDER.equals(lsPath1));\n+      Assert.assertTrue(\n+          HDFS_USER_FOLDER.equals(lsPath2) || LOCAL_FOLDER.equals(lsPath2));\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   * ListStatus non mount directory should fail.\n+   */\n+  @Test(expected = IOException.class, timeout = 30000)\n+  public void testListStatusOnNonMountedPath() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(false, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      fs.listStatus(new Path(\"/nonMount\"));\n+      Assert.fail(\"It should fail as no mount link with /nonMount\");\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows hdfs://localhost:xxx/HDFSUser -->\n+   * hdfs://localhost:xxx/HDFSUser/ hdfs://localhost:xxx/local -->\n+   * file://TEST_ROOT_DIR/root/ fallback --> hdfs://localhost:xxx/HDFSUser/\n+   * Creating file or directory at non root level should succeed with fallback\n+   * links.\n+   */\n+  @Test(timeout = 30000)\n+  public void testWithLinkFallBack() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(true, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      fs.create(new Path(\"/nonMount/myfile\"));\n+      FileStatus[] ls = fs.listStatus(new Path(\"/nonMount\"));\n+      Assert.assertEquals(1, ls.length);\n+      Assert.assertEquals(\n+          Path.getPathWithoutSchemeAndAuthority(ls[0].getPath()).getName(),\n+          \"myfile\");\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   *\n+   * It can not find any mount link. ViewFS expects a mount point from root.\n+   */\n+  @Test(expected = NotInMountpointException.class, timeout = 30000)\n+  public void testCreateOnRootShouldFailWhenMountLinkConfigured()\n+      throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(false, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      fs.create(new Path(\"/newFileOnRoot\"));\n+      Assert.fail(\"It should fail as root is read only in viewFS.\");\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   * fallback --> hdfs://localhost:xxx/HDFSUser/\n+   *\n+   * It will find fallback link, but root is not accessible and read only.\n+   */\n+  @Test(expected = AccessControlException.class, timeout = 30000)\n+  public void testCreateOnRootShouldFailEvenFallBackMountLinkConfigured()\n+      throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(true, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      fs.create(new Path(\"/onRootWhenFallBack\"));\n+      Assert.fail(\n+          \"It should fail as root is read only in viewFS, even when configured\"\n+              + \" with fallback.\");\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   * fallback --> hdfs://localhost:xxx/HDFSUser/\n+   *\n+   * It will find fallback link, but root is not accessible and read only.\n+   */\n+  @Test(expected = UnsupportedFileSystemException.class, timeout = 30000)\n+  public void testInvalidOverloadSchemeTargetFS() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+    conf = new Configuration();\n+    createLinks(true, hdfsTargetPath, localTragetPath);", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3ODYyMA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419078620", "bodyText": "Without creating links ViewFS fails with \"not mount points configured\". So, to move forward to the intended scenario, we just need to create links.", "author": "umamaheswararao", "createdAt": "2020-05-03T09:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NTEyNQ==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419045125", "bodyText": "Can we add a test that cache actually works?", "author": "virajith", "createdAt": "2020-05-03T04:25:11Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsOverloadSchemeWithHdfsScheme.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.CommonConfigurationKeys;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.RawLocalFileSystem;\n+import org.apache.hadoop.fs.UnsupportedFileSystemException;\n+import org.apache.hadoop.hdfs.DFSConfigKeys;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.security.AccessControlException;\n+import org.apache.hadoop.test.PathUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Tests ViewFsOverloadScheme with configured mount links.\n+ */\n+public class TestViewFsOverloadSchemeWithHdfsScheme {\n+  private static final String FS_IMPL_PATTERN_KEY = \"fs.%s.impl\";\n+  private static final String HDFS_SCHEME = \"hdfs\";\n+  private Configuration conf = null;\n+  private MiniDFSCluster cluster = null;\n+  private URI defaultFSURI;\n+  private File localTargetDir;\n+  private static final String TEST_ROOT_DIR =\n+      PathUtils.getTestDirName(TestViewFsOverloadSchemeWithHdfsScheme.class);\n+  private static final String HDFS_USER_FOLDER = \"/HDFSUser\";\n+  private static final String LOCAL_FOLDER = \"/local\";\n+\n+  @Before\n+  public void startCluster() throws IOException {\n+    conf = new Configuration();\n+    conf.setBoolean(DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,\n+        true);\n+    conf.set(String.format(FS_IMPL_PATTERN_KEY, HDFS_SCHEME),\n+        ViewFsOverloadScheme.class.getName());\n+    conf.set(String.format(\n+        FsConstants.FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN,\n+        HDFS_SCHEME), DistributedFileSystem.class.getName());\n+    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(2).build();\n+    cluster.waitClusterUp();\n+    defaultFSURI =\n+        URI.create(conf.get(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY));\n+    localTargetDir = new File(TEST_ROOT_DIR, \"/root/\");\n+    Assert.assertEquals(HDFS_SCHEME, defaultFSURI.getScheme()); // hdfs scheme.\n+  }\n+\n+  @After\n+  public void tearDown() throws IOException {\n+    if (cluster != null) {\n+      FileSystem.closeAll();\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  private void createLinks(boolean needFalbackLink, Path hdfsTargetPath,\n+      Path localTragetPath) {\n+    ConfigUtil.addLink(conf, defaultFSURI.getAuthority(), HDFS_USER_FOLDER,\n+        hdfsTargetPath.toUri());\n+    ConfigUtil.addLink(conf, defaultFSURI.getAuthority(), LOCAL_FOLDER,\n+        localTragetPath.toUri());\n+    if (needFalbackLink) {\n+      ConfigUtil.addLinkFallback(conf, defaultFSURI.getAuthority(),\n+          hdfsTargetPath.toUri());\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows.\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   *\n+   * create file /HDFSUser/testfile should create in hdfs\n+   * create file /local/test should create directory in local fs\n+   */\n+  @Test(timeout = 30000)\n+  public void testMountLinkWithLocalAndHDFS() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(false, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    Assert.assertEquals(2, fs.getMountPoints().length);\n+\n+    // /HDFSUser/testfile\n+    Path hdfsFile = new Path(HDFS_USER_FOLDER + \"/testfile\");\n+    // /local/test\n+    Path localDir = new Path(LOCAL_FOLDER + \"/test\");\n+\n+    fs.create(hdfsFile); // /HDFSUser/testfile\n+    fs.mkdirs(localDir); // /local/test\n+\n+    // Initialize HDFS and test files exist in ls or not\n+    DistributedFileSystem dfs = new DistributedFileSystem();\n+    dfs.initialize(defaultFSURI, conf);\n+    try {\n+      Assert.assertTrue(dfs.exists(\n+          new Path(Path.getPathWithoutSchemeAndAuthority(hdfsTargetPath),\n+              hdfsFile.getName()))); // should be in hdfs.\n+      Assert.assertFalse(dfs.exists(\n+          new Path(Path.getPathWithoutSchemeAndAuthority(localTragetPath),\n+              localDir.getName()))); // should not be in local fs.\n+    } finally {\n+      dfs.close();\n+    }\n+\n+    RawLocalFileSystem lfs = new RawLocalFileSystem();\n+    lfs.initialize(localTragetPath.toUri(), conf);\n+    try {\n+      Assert.assertFalse(lfs.exists(\n+          new Path(Path.getPathWithoutSchemeAndAuthority(hdfsTargetPath),\n+              hdfsFile.getName()))); // should not be in hdfs.\n+      Assert.assertTrue(lfs.exists(\n+          new Path(Path.getPathWithoutSchemeAndAuthority(localTragetPath),\n+              localDir.getName()))); // should be in local fs.\n+    } finally {\n+      lfs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows.\n+   * hdfs://localhost:xxx/HDFSUser --> nonexistent://NonExistent/User/\n+   * It should fail to add non existent fs link.\n+   */\n+  @Test(expected = IOException.class, timeout = 30000)\n+  public void testMountLinkWithNonExistentLink() throws Exception {\n+    final String userFolder = \"/User\";\n+    final Path nonExistTargetPath =\n+        new Path(\"nonexistent://NonExistent\" + userFolder);\n+\n+    /**\n+     * Below addLink will create following mount points\n+     * hdfs://localhost:xxx/User --> nonexistent://NonExistent/User/\n+     */\n+    ConfigUtil.addLink(conf, defaultFSURI.getAuthority(), userFolder,\n+        nonExistTargetPath.toUri());\n+    FileSystem.get(conf);\n+    Assert.fail(\"Expected to fail with non existent link\");\n+  }\n+\n+  /**\n+   * Create mount links as follows.\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   * ListStatus on / should list the mount links.\n+   */\n+  @Test(timeout = 30000)\n+  public void testListStatusOnRootShouldListAllMountLinks() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(false, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      FileStatus[] ls = fs.listStatus(new Path(\"/\"));\n+      Assert.assertEquals(2, ls.length);\n+      String lsPath1 =\n+          Path.getPathWithoutSchemeAndAuthority(ls[0].getPath()).toString();\n+      String lsPath2 =\n+          Path.getPathWithoutSchemeAndAuthority(ls[1].getPath()).toString();\n+      Assert.assertTrue(\n+          HDFS_USER_FOLDER.equals(lsPath1) || LOCAL_FOLDER.equals(lsPath1));\n+      Assert.assertTrue(\n+          HDFS_USER_FOLDER.equals(lsPath2) || LOCAL_FOLDER.equals(lsPath2));\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   * ListStatus non mount directory should fail.\n+   */\n+  @Test(expected = IOException.class, timeout = 30000)\n+  public void testListStatusOnNonMountedPath() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(false, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      fs.listStatus(new Path(\"/nonMount\"));\n+      Assert.fail(\"It should fail as no mount link with /nonMount\");\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows hdfs://localhost:xxx/HDFSUser -->\n+   * hdfs://localhost:xxx/HDFSUser/ hdfs://localhost:xxx/local -->\n+   * file://TEST_ROOT_DIR/root/ fallback --> hdfs://localhost:xxx/HDFSUser/\n+   * Creating file or directory at non root level should succeed with fallback\n+   * links.\n+   */\n+  @Test(timeout = 30000)\n+  public void testWithLinkFallBack() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(true, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      fs.create(new Path(\"/nonMount/myfile\"));\n+      FileStatus[] ls = fs.listStatus(new Path(\"/nonMount\"));\n+      Assert.assertEquals(1, ls.length);\n+      Assert.assertEquals(\n+          Path.getPathWithoutSchemeAndAuthority(ls[0].getPath()).getName(),\n+          \"myfile\");\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   *\n+   * It can not find any mount link. ViewFS expects a mount point from root.\n+   */\n+  @Test(expected = NotInMountpointException.class, timeout = 30000)\n+  public void testCreateOnRootShouldFailWhenMountLinkConfigured()\n+      throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(false, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      fs.create(new Path(\"/newFileOnRoot\"));\n+      Assert.fail(\"It should fail as root is read only in viewFS.\");\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   * fallback --> hdfs://localhost:xxx/HDFSUser/\n+   *\n+   * It will find fallback link, but root is not accessible and read only.\n+   */\n+  @Test(expected = AccessControlException.class, timeout = 30000)\n+  public void testCreateOnRootShouldFailEvenFallBackMountLinkConfigured()\n+      throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+\n+    createLinks(true, hdfsTargetPath, localTragetPath);\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      fs.create(new Path(\"/onRootWhenFallBack\"));\n+      Assert.fail(\n+          \"It should fail as root is read only in viewFS, even when configured\"\n+              + \" with fallback.\");\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   * fallback --> hdfs://localhost:xxx/HDFSUser/\n+   *\n+   * It will find fallback link, but root is not accessible and read only.\n+   */\n+  @Test(expected = UnsupportedFileSystemException.class, timeout = 30000)\n+  public void testInvalidOverloadSchemeTargetFS() throws Exception {\n+    final Path hdfsTargetPath = new Path(defaultFSURI + HDFS_USER_FOLDER);\n+    final Path localTragetPath = new Path(localTargetDir.toURI());\n+    conf = new Configuration();\n+    createLinks(true, hdfsTargetPath, localTragetPath);\n+    conf.set(CommonConfigurationKeys.FS_DEFAULT_NAME_KEY,\n+        defaultFSURI.toString());\n+    conf.set(String.format(FS_IMPL_PATTERN_KEY, HDFS_SCHEME),\n+        ViewFsOverloadScheme.class.getName());\n+\n+    ViewFsOverloadScheme fs = (ViewFsOverloadScheme) FileSystem.get(conf);\n+    try {\n+      fs.create(new Path(\"/onRootWhenFallBack\"));\n+      Assert.fail(\"OverloadScheme target fs should be valid.\");\n+    } finally {\n+      fs.close();\n+    }\n+  }\n+\n+  /**\n+   * Create mount links as follows\n+   * hdfs://localhost:xxx/HDFSUser --> hdfs://localhost:xxx/HDFSUser/\n+   * hdfs://localhost:xxx/local --> file://TEST_ROOT_DIR/root/\n+   *\n+   * It should be able to create file using ViewFsOverloadScheme.\n+   */\n+  @Test(timeout = 30000)\n+  public void testViewFsOverloadSchemeWhenInnerCacheDisabled()", "originalCommit": "c1525f808f02ed40ca7451d4d71b7fa12708e106", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3OTEyMw==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419079123", "bodyText": "We have not changed cache behavior itself. When cache disabled, we have varied path.\nAnyway Its should be easy to add a test for that I think. Let me add one.", "author": "umamaheswararao", "createdAt": "2020-05-03T09:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NTEyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE3OTYxMA==", "url": "https://github.com/apache/hadoop/pull/1988#discussion_r419179610", "bodyText": "Added Tests.", "author": "umamaheswararao", "createdAt": "2020-05-04T00:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NTEyNQ=="}], "type": "inlineReview"}, {"oid": "c3129e386369381d61694ad685ef6ade775e5f46", "url": "https://github.com/apache/hadoop/commit/c3129e386369381d61694ad685ef6ade775e5f46", "message": "HDFS-15305. Update: Fixed few review comments.", "committedDate": "2020-05-03T10:44:35Z", "type": "commit"}, {"oid": "bb8c3c3ad79e2aa2dfc943e30deb2b81c1c165fb", "url": "https://github.com/apache/hadoop/commit/bb8c3c3ad79e2aa2dfc943e30deb2b81c1c165fb", "message": "HDFS-15305. Update: Fixed checkstyle comments.", "committedDate": "2020-05-03T20:48:11Z", "type": "commit"}, {"oid": "2513bc5ca25e3e754bf0b2d31a2780f1332c4fe5", "url": "https://github.com/apache/hadoop/commit/2513bc5ca25e3e754bf0b2d31a2780f1332c4fe5", "message": "HDFS-15305. Improvement: name FS->FileSystem.", "committedDate": "2020-05-04T19:34:42Z", "type": "commit"}]}