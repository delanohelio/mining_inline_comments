{"pr_number": 1942, "pr_title": "Fix a bug where enum value extensions were not picked up by schema validation", "pr_createdAt": "2020-06-07T08:35:13Z", "pr_url": "https://github.com/graphql-java/graphql-java/pull/1942", "timeline": [{"oid": "d1d8a4b36fc847b5f219e2600e8989c0ebe8c3a9", "url": "https://github.com/graphql-java/graphql-java/commit/d1d8a4b36fc847b5f219e2600e8989c0ebe8c3a9", "message": "Fix a bug where enum value extensions were not picked up by schema validation correctly", "committedDate": "2020-06-07T08:34:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzOTQ0Nw==", "url": "https://github.com/graphql-java/graphql-java/pull/1942#discussion_r436339447", "bodyText": "This is the guts of the fix here.  Sorry for all the other guff (broken windows and all)\nWe didn't include extensions in this pre argument checking code", "author": "bbakerman", "createdAt": "2020-06-07T08:36:29Z", "path": "src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java", "diffHunk": "@@ -139,66 +147,72 @@ private void checkArgValueMatchesAllowedInputType(List<GraphQLError> errors, Val\n         // then it must be the same type as the definition\n \n         List<ObjectField> fields = objectValue.getObjectFields();\n-        List<InputValueDefinition> inputValueDefinitions = allowedTypeDefinition.getInputValueDefinitions();\n+        List<InputObjectTypeExtensionDefinition> inputObjExt = typeRegistry.inputObjectTypeExtensions().getOrDefault(allowedTypeDefinition.getName(), emptyList());\n+        Stream<InputValueDefinition> inputObjExtValues = inputObjExt.stream().flatMap(inputObj -> inputObj.getInputValueDefinitions().stream());\n+        List<InputValueDefinition> inputValueDefinitions = Stream.concat(allowedTypeDefinition.getInputValueDefinitions().stream(), inputObjExtValues).collect(toList());\n \n         // check for duplicated fields\n         Map<String, Long> fieldsToOccurrenceMap = fields.stream().map(ObjectField::getName)\n-                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+                .collect(groupingBy(Function.identity(), counting()));\n \n         if (fieldsToOccurrenceMap.values().stream().anyMatch(count -> count > 1)) {\n             addValidationError(errors, DUPLICATED_KEYS_MESSAGE, fieldsToOccurrenceMap.entrySet().stream()\n                     .filter(entry -> entry.getValue() > 1)\n                     .map(Map.Entry::getKey)\n-                    .collect(Collectors.joining(\",\")));\n+                    .collect(joining(\",\")));\n             return;\n         }\n \n         // check for unknown fields\n         Map<String, InputValueDefinition> nameToInputValueDefMap = inputValueDefinitions.stream()\n-                .collect(Collectors.toMap(InputValueDefinition::getName, inputValueDef -> inputValueDef));\n+                .collect(toMap(InputValueDefinition::getName, inputValueDef -> inputValueDef));\n \n         List<ObjectField> unknownFields = fields.stream()\n                 .filter(field -> !nameToInputValueDefMap.containsKey(field.getName()))\n-                .collect(Collectors.toList());\n+                .collect(toList());\n \n         if (!unknownFields.isEmpty()) {\n             addValidationError(errors, UNKNOWN_FIELDS_MESSAGE,\n                     unknownFields.stream()\n                             .map(ObjectField::getName)\n-                            .collect(Collectors.joining(\",\")),\n+                            .collect(joining(\",\")),\n                     allowedTypeDefinition.getName());\n             return;\n         }\n \n         // fields to map for easy access\n         Map<String, ObjectField> nameToFieldsMap = fields.stream()\n-                .collect(Collectors.toMap(ObjectField::getName, objectField -> objectField));\n+                .collect(toMap(ObjectField::getName, objectField -> objectField));\n         // check each single field with its definition\n         inputValueDefinitions.forEach(allowedValueDef -> {\n             ObjectField objectField = nameToFieldsMap.get(allowedValueDef.getName());\n             checkArgInputObjectValueFieldMatchesAllowedDefinition(errors, objectField, allowedValueDef);\n         });\n     }\n \n-    private void checkArgValueMatchesAllowedEnum(List<GraphQLError> errors, Value instanceValue, EnumTypeDefinition allowedTypeDefinition) {\n+    private void checkArgValueMatchesAllowedEnum(List<GraphQLError> errors, Value<?> instanceValue, EnumTypeDefinition allowedTypeDefinition) {\n         if (!(instanceValue instanceof EnumValue)) {\n             addValidationError(errors, EXPECTED_ENUM_MESSAGE, instanceValue.getClass().getSimpleName());\n             return;\n         }\n \n         EnumValue enumValue = ((EnumValue) instanceValue);\n \n-        boolean noneMatchAllowedEnumValue = allowedTypeDefinition.getEnumValueDefinitions().stream()\n+        List<EnumTypeExtensionDefinition> enumExtensions = typeRegistry.enumTypeExtensions().getOrDefault(allowedTypeDefinition.getName(), emptyList());\n+        Stream<EnumValueDefinition> enumExtStream = enumExtensions.stream().flatMap(enumExt -> enumExt.getEnumValueDefinitions().stream());\n+        List<EnumValueDefinition> enumValueDefinitions = Stream.concat(allowedTypeDefinition.getEnumValueDefinitions().stream(), enumExtStream).collect(toList());\n+\n+        boolean noneMatchAllowedEnumValue = enumValueDefinitions.stream()\n                 .noneMatch(enumAllowedValue -> enumAllowedValue.getName().equals(enumValue.getName()));", "originalCommit": "d1d8a4b36fc847b5f219e2600e8989c0ebe8c3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzOTQ3Nw==", "url": "https://github.com/graphql-java/graphql-java/pull/1942#discussion_r436339477", "bodyText": "InputObjects has the same bug", "author": "bbakerman", "createdAt": "2020-06-07T08:36:52Z", "path": "src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java", "diffHunk": "@@ -139,66 +147,72 @@ private void checkArgValueMatchesAllowedInputType(List<GraphQLError> errors, Val\n         // then it must be the same type as the definition\n \n         List<ObjectField> fields = objectValue.getObjectFields();\n-        List<InputValueDefinition> inputValueDefinitions = allowedTypeDefinition.getInputValueDefinitions();\n+        List<InputObjectTypeExtensionDefinition> inputObjExt = typeRegistry.inputObjectTypeExtensions().getOrDefault(allowedTypeDefinition.getName(), emptyList());\n+        Stream<InputValueDefinition> inputObjExtValues = inputObjExt.stream().flatMap(inputObj -> inputObj.getInputValueDefinitions().stream());\n+        List<InputValueDefinition> inputValueDefinitions = Stream.concat(allowedTypeDefinition.getInputValueDefinitions().stream(), inputObjExtValues).collect(toList());\n ", "originalCommit": "d1d8a4b36fc847b5f219e2600e8989c0ebe8c3a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c452f655a3290ef95121194ea6f1dc1454cd368", "url": "https://github.com/graphql-java/graphql-java/commit/7c452f655a3290ef95121194ea6f1dc1454cd368", "message": "Merge remote-tracking branch 'origin/master' into 1937-extended-enums\n\n# Conflicts:\n#\tsrc/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java", "committedDate": "2020-11-10T10:53:02Z", "type": "commit"}]}