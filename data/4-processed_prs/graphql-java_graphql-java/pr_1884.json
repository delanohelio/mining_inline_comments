{"pr_number": 1884, "pr_title": "1764 allow interfaces to implement other interfaces", "pr_createdAt": "2020-04-27T10:11:03Z", "pr_url": "https://github.com/graphql-java/graphql-java/pull/1884", "timeline": [{"oid": "1b120b2858f08cd535fceb04e56f5380fb0de52d", "url": "https://github.com/graphql-java/graphql-java/commit/1b120b2858f08cd535fceb04e56f5380fb0de52d", "message": "1764: Interfaces implementing interfaces working with partial validation", "committedDate": "2020-04-27T08:49:57Z", "type": "commit"}, {"oid": "5dca065f49021a26ec7041dfdd85d0eec334c638", "url": "https://github.com/graphql-java/graphql-java/commit/5dca065f49021a26ec7041dfdd85d0eec334c638", "message": "1764: Assert error messages", "committedDate": "2020-04-27T09:34:40Z", "type": "commit"}, {"oid": "ecb52d31d3db49aeca521fccc8f2b6c1e15eb040", "url": "https://github.com/graphql-java/graphql-java/commit/ecb52d31d3db49aeca521fccc8f2b6c1e15eb040", "message": "1764: Check if interface is implementing itself\n\nfixes: #1764", "committedDate": "2020-04-27T10:08:04Z", "type": "commit"}, {"oid": "ea740efacc54ea02d415f35448aa3e5e4fefd95a", "url": "https://github.com/graphql-java/graphql-java/commit/ea740efacc54ea02d415f35448aa3e5e4fefd95a", "message": "1764: Fix bug with circular dependency", "committedDate": "2020-04-28T23:07:02Z", "type": "commit"}, {"oid": "ea740efacc54ea02d415f35448aa3e5e4fefd95a", "url": "https://github.com/graphql-java/graphql-java/commit/ea740efacc54ea02d415f35448aa3e5e4fefd95a", "message": "1764: Fix bug with circular dependency", "committedDate": "2020-04-28T23:07:02Z", "type": "forcePushed"}, {"oid": "3dfdab1b12fa64c4032737d59dec792083c86bb8", "url": "https://github.com/graphql-java/graphql-java/commit/3dfdab1b12fa64c4032737d59dec792083c86bb8", "message": "1764: Use String.join instead of realying on Collection#toString", "committedDate": "2020-04-28T23:19:56Z", "type": "commit"}, {"oid": "3dfdab1b12fa64c4032737d59dec792083c86bb8", "url": "https://github.com/graphql-java/graphql-java/commit/3dfdab1b12fa64c4032737d59dec792083c86bb8", "message": "1764: Use String.join instead of realying on Collection#toString", "committedDate": "2020-04-28T23:19:56Z", "type": "forcePushed"}, {"oid": "ae71b4a3898bb26823ea0c158856b0cdae044dc7", "url": "https://github.com/graphql-java/graphql-java/commit/ae71b4a3898bb26823ea0c158856b0cdae044dc7", "message": "1764: Better test assertions", "committedDate": "2020-04-29T08:44:59Z", "type": "commit"}, {"oid": "81b1b2628018493c6ff265ce7906270d2a7cf765", "url": "https://github.com/graphql-java/graphql-java/commit/81b1b2628018493c6ff265ce7906270d2a7cf765", "message": "1764: Add tests for transitive implementation declared in interface extensions", "committedDate": "2020-04-29T09:01:37Z", "type": "commit"}, {"oid": "0039150ff8f3179d5bd98ec72f64225e9c026fd7", "url": "https://github.com/graphql-java/graphql-java/commit/0039150ff8f3179d5bd98ec72f64225e9c026fd7", "message": "1764: Simplify implementation of transitive validation", "committedDate": "2020-04-29T22:57:58Z", "type": "commit"}, {"oid": "465e4a98490411b1011dd09b68aa9ff10b1f2c3b", "url": "https://github.com/graphql-java/graphql-java/commit/465e4a98490411b1011dd09b68aa9ff10b1f2c3b", "message": "1764: Fix transitive implementation declared in extension interface bug", "committedDate": "2020-05-17T09:52:17Z", "type": "commit"}, {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "url": "https://github.com/graphql-java/graphql-java/commit/4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "message": "1764: Add tests for field and arguments check", "committedDate": "2020-05-17T09:52:29Z", "type": "commit"}, {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "url": "https://github.com/graphql-java/graphql-java/commit/4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "message": "1764: Add tests for field and arguments check", "committedDate": "2020-05-17T09:52:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5ODgxMQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426398811", "bodyText": "Nice one!  We should do this in other tests.\nCan you please rewrite all our tests to this pattern please! ;)", "author": "bbakerman", "createdAt": "2020-05-18T06:41:14Z", "path": "src/test/groovy/graphql/InterfacesImplementingInterfacesTest.groovy", "diffHunk": "@@ -0,0 +1,861 @@\n+package graphql\n+\n+import graphql.schema.idl.SchemaGenerator\n+import graphql.schema.idl.SchemaParser\n+import graphql.schema.idl.errors.SchemaProblem\n+import spock.lang.Specification\n+\n+class InterfacesImplementingInterfacesTest extends Specification {\n+    def 'Simple interface implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When implementing interface does not declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface type 'Resource' [@n:n] does not have a field 'id' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'Transitively implemented interfaces defined in implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+\n+    def 'Transitively implemented interfaces defined in implementing type'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing interface, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \n+            interface LargeImage implements Image & Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+              large: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Image' [@n:n]\")\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing type, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface implements itself, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node implements Named & Node {\n+              id: ID!\n+              name: String\n+            }\n+            \n+            interface Named implements Node & Named {\n+              id: ID!\n+              name: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'Node' [@n:n] cannot implement itself\")\n+        assertErrorMessage(error, \"The interface type 'Named' [@n:n] cannot implement itself\")\n+    }\n+\n+    def 'When interface extension implements interface and declares required field, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface but doesn\\'t declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+              extraField: String\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Resource' [@n:n] does not have a field 'extraField' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'When object extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When object extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When hierarchy results in circular reference, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface3 & Interface2 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface2 implements Interface1 & Interface3 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface3 implements Interface2 & Interface1 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+\n+        error.errors.size() == 6\n+\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+    }\n+\n+    def 'When interface doesn\\'t implement transitive interface declared in extension, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(\n+                error,\n+                \"The interface type 'Interface1' [@n:n] must implement 'Interface3' [@n:n] because it is implemented by 'Interface2' [@n:n]\"\n+        )\n+    }\n+\n+    def 'When interface implements transitive interface declared in extension, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface1 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When field required by new extension implementation is declared in original interface type, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 implements Interface2\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When type declares interface and extension declares required field, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 {\n+              field2: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface implements same interface more than once via extensions, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+           type Query {\n+              find(id: String!): Type1\n+           }\n+           \n+           type Type1 {\n+             field1: String\n+           }\n+           \n+           interface Interface2  {\n+             field20: String\n+             field21: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {\n+             field20: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {\n+             field21: String\n+           }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+\n+        assertErrorMessage(error, \"The object extension type 'Type1' [@n:n] can only implement 'Interface2' [@n:n] once.\")\n+    }\n+\n+    def 'When interface implements same interface more than once, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+           type Query {\n+              find(id: String!): Type1\n+           }\n+           \n+           type Type1 implements Interface2 {\n+             field1: String\n+             field20: String\n+           }\n+           \n+           interface Interface2  {\n+             field20: String\n+             field21: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {\n+             field21: String\n+           }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+\n+        assertErrorMessage(error, \"The object extension type 'Type1' [@n:n] can only implement 'Interface2' [@n:n] once.\")\n+        assertErrorMessage(error, \"The object type 'Type1' [@n:n] can only implement 'Interface2' [@n:n] once.\")\n+    }\n+\n+    def 'When interface implements interface and redefines non-null field as nullable, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+              id: ID\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(error, \"The interface type 'Resource' [@n:n] has tried to redefine field 'id' defined via interface 'Node' [@n:n] from 'ID!' to 'ID'\")\n+    }\n+\n+    def 'When interface extension implements interface and redefines non-null field as nullable, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(error, \"The interface extension type 'Resource' [@n:n] has tried to redefine field 'id' defined via interface 'Node' [@n:n] from 'ID!' to 'ID'\")\n+    }\n+\n+    def 'When interface implements interface and redefines nullable field as non-null, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+              id: ID!\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface and redefines nullable field as non-null, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface and misses field arguments, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            interface InterfaceType {\n+                fieldA(arg1 : Int) : Int \n+                fieldB(arg1 : String = \"defaultVal\", arg2 : String, arg3 : Int) : String \n+            }\n+\n+            interface BaseInterface {\n+                fieldX : Int\n+            }\n+\n+            extend interface BaseInterface implements InterfaceType {\n+                fieldA : Int\n+                fieldB(arg1 : String = \"defaultValX\", arg2 : String!, arg3 : String) : String \n+            }\n+            \n+            type Query {\n+               mock: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 4\n+\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] field 'fieldA' does not have the same number of arguments as specified via interface 'InterfaceType' [@n:n]\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg1:String =\\\"defaultVal\\\"' to 'arg1:String =\\\"defaultValX\\\"\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg2:String' to 'arg2:String!\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg3:Int' to 'arg3:String\")\n+    }\n+\n+    def 'When interface implements interface and misses field arguments, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            interface InterfaceType {\n+                fieldA(arg1 : Int) : Int \n+                fieldB(arg1 : String = \"defaultVal\", arg2 : String, arg3 : Int) : String \n+            }\n+\n+            interface BaseInterface implements InterfaceType {\n+                fieldX : Int\n+                fieldA : Int\n+                fieldB(arg1 : String = \"defaultValX\", arg2 : String!, arg3 : String) : String \n+            }\n+            \n+            type Query {\n+               mock: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 4\n+\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] field 'fieldA' does not have the same number of arguments as specified via interface 'InterfaceType' [@n:n]\")\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg1:String =\\\"defaultVal\\\"' to 'arg1:String =\\\"defaultValX\\\"\")\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg2:String' to 'arg2:String!\")\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg3:Int' to 'arg3:String\")\n+    }\n+\n+    def 'When interface implements interface via extension and misses field arguments, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            interface InterfaceType {\n+                fieldA(arg1 : Int) : Int \n+                fieldB(arg1 : String = \"defaultVal\", arg2 : String, arg3 : Int) : String \n+            }\n+\n+            interface BaseInterface {\n+                fieldX : Int\n+                fieldA : Int\n+                fieldB(arg1 : String = \"defaultValX\", arg2 : String!, arg3 : String) : String \n+            }\n+            \n+            extend interface BaseInterface implements InterfaceType\n+            \n+            type BaseType {\n+                id: ID!\n+            }\n+\n+            type Query {\n+               mock: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 4\n+\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] field 'fieldA' does not have the same number of arguments as specified via interface 'InterfaceType' [@n:n]\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg1:String =\\\"defaultVal\\\"' to 'arg1:String =\\\"defaultValX\\\"\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg2:String' to 'arg2:String!\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg3:Int' to 'arg3:String\")\n+    }\n+\n+    def assertErrorMessage(SchemaProblem error, expectedMessage) {", "originalCommit": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5OTE3OA==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426399178", "bodyText": "Why does this need to be removed?  Is it no longer valid or just not longer relevant and tested in the other places", "author": "bbakerman", "createdAt": "2020-05-18T06:42:11Z", "path": "src/test/groovy/graphql/schema/idl/SchemaGeneratorTest.groovy", "diffHunk": "@@ -542,13 +542,6 @@ class SchemaGeneratorTest extends Specification {\n             extend type BaseType {\n                extraField5 : Boolean!\n             }\n-            #\n-            # if we repeat a definition, that's ok as long as its the same types as before\n-            # they will be de-duped since the effect is the same\n-            #\n-            extend type BaseType implements Interface1 {\n-               extraField1 : String\n-            }", "originalCommit": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1NDQyOQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426454429", "bodyText": "This is actually invalid now.\nI've added a new validation rule which prevents extensions from implementing an interface which has already been implemented from a base type, or other extensions for the same type.\nThis will make the graphql-java validation more aligned with graphql-js", "author": "felipe-gdr", "createdAt": "2020-05-18T08:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5OTE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5OTQ4Mw==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426399483", "bodyText": "My comment below is covered by this test", "author": "bbakerman", "createdAt": "2020-05-18T06:43:01Z", "path": "src/test/groovy/graphql/InterfacesImplementingInterfacesTest.groovy", "diffHunk": "@@ -0,0 +1,861 @@\n+package graphql\n+\n+import graphql.schema.idl.SchemaGenerator\n+import graphql.schema.idl.SchemaParser\n+import graphql.schema.idl.errors.SchemaProblem\n+import spock.lang.Specification\n+\n+class InterfacesImplementingInterfacesTest extends Specification {\n+    def 'Simple interface implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When implementing interface does not declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface type 'Resource' [@n:n] does not have a field 'id' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'Transitively implemented interfaces defined in implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+\n+    def 'Transitively implemented interfaces defined in implementing type'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing interface, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \n+            interface LargeImage implements Image & Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+              large: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Image' [@n:n]\")\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing type, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface implements itself, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node implements Named & Node {\n+              id: ID!\n+              name: String\n+            }\n+            \n+            interface Named implements Node & Named {\n+              id: ID!\n+              name: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'Node' [@n:n] cannot implement itself\")\n+        assertErrorMessage(error, \"The interface type 'Named' [@n:n] cannot implement itself\")\n+    }\n+\n+    def 'When interface extension implements interface and declares required field, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface but doesn\\'t declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+              extraField: String\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Resource' [@n:n] does not have a field 'extraField' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'When object extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When object extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When hierarchy results in circular reference, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface3 & Interface2 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface2 implements Interface1 & Interface3 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface3 implements Interface2 & Interface1 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+\n+        error.errors.size() == 6\n+\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+    }\n+\n+    def 'When interface doesn\\'t implement transitive interface declared in extension, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(\n+                error,\n+                \"The interface type 'Interface1' [@n:n] must implement 'Interface3' [@n:n] because it is implemented by 'Interface2' [@n:n]\"\n+        )\n+    }\n+\n+    def 'When interface implements transitive interface declared in extension, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface1 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When field required by new extension implementation is declared in original interface type, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 implements Interface2\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When type declares interface and extension declares required field, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 {\n+              field2: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface implements same interface more than once via extensions, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+           type Query {\n+              find(id: String!): Type1\n+           }\n+           \n+           type Type1 {\n+             field1: String\n+           }\n+           \n+           interface Interface2  {\n+             field20: String\n+             field21: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {", "originalCommit": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxOTgwNw==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426919807", "bodyText": "please use our map static function instead of streams directly", "author": "andimarek", "createdAt": "2020-05-18T22:10:27Z", "path": "src/main/java/graphql/introspection/IntrospectionResultToSchema.java", "diffHunk": "@@ -185,6 +184,13 @@ InterfaceTypeDefinition createInterface(Map<String, Object> input) {\n \n         InterfaceTypeDefinition.Builder interfaceTypeDefinition = InterfaceTypeDefinition.newInterfaceTypeDefinition().name((String) input.get(\"name\"));\n         interfaceTypeDefinition.description(toDescription(input));\n+        if (input.containsKey(\"interfaces\") && input.get(\"interfaces\") != null) {\n+            interfaceTypeDefinition.implementz(\n+                    ((List<Map<String, Object>>) input.get(\"interfaces\")).stream()", "originalCommit": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMDU2MQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426920561", "bodyText": "why the recursive type definition here?", "author": "andimarek", "createdAt": "2020-05-18T22:12:26Z", "path": "src/main/java/graphql/language/ImplementingTypeDefinition.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package graphql.language;\n+\n+\n+import graphql.PublicApi;\n+\n+import java.util.List;\n+\n+/**\n+ * A {@link TypeDefinition} that might implement interfaces\n+ *\n+ * @param <T>\n+ */\n+@PublicApi\n+public interface ImplementingTypeDefinition<T extends ImplementingTypeDefinition> extends TypeDefinition<T> {", "originalCommit": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNjQ3MA==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r427116470", "bodyText": "Yep, not needed. <T extends TypeDefinition> should be enough.", "author": "felipe-gdr", "createdAt": "2020-05-19T08:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMDU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMDcyMA==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426920720", "bodyText": "not great name, but not in scope to change it here.", "author": "andimarek", "createdAt": "2020-05-18T22:12:50Z", "path": "src/main/java/graphql/language/ImplementingTypeDefinition.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package graphql.language;\n+\n+\n+import graphql.PublicApi;\n+\n+import java.util.List;\n+\n+/**\n+ * A {@link TypeDefinition} that might implement interfaces\n+ *\n+ * @param <T>\n+ */\n+@PublicApi\n+public interface ImplementingTypeDefinition<T extends ImplementingTypeDefinition> extends TypeDefinition<T> {\n+\n+    List<Type> getImplements();", "originalCommit": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTQwNg==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426921406", "bodyText": "please use our map util function.", "author": "andimarek", "createdAt": "2020-05-18T22:14:42Z", "path": "src/main/java/graphql/parser/GraphqlAntlrToLanguage.java", "diffHunk": "@@ -882,4 +878,14 @@ protected SourceLocation getSourceLocation(ParserRuleContext parserRuleContext)\n         return comments;\n     }\n \n+\n+    private List<Type> getImplementz(GraphqlParser.ImplementsInterfacesContext implementsInterfacesContext) {\n+        List<Type> implementz = new ArrayList<>();\n+        while (implementsInterfacesContext != null) {\n+            List<TypeName> typeNames = implementsInterfacesContext.typeName().stream().map(this::createTypeName).collect(toList());", "originalCommit": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTgxOA==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426921818", "bodyText": "please use the util function", "author": "andimarek", "createdAt": "2020-05-18T22:15:47Z", "path": "src/main/java/graphql/schema/idl/SchemaTypeChecker.java", "diffHunk": "@@ -90,7 +85,7 @@\n \n     private void checkForMissingTypes(List<GraphQLError> errors, TypeDefinitionRegistry typeRegistry) {\n         // type extensions\n-        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.objectTypeExtensions().values().stream().flatMap(Collection::stream).collect(Collectors.toList());\n+        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.objectTypeExtensions().values().stream().flatMap(Collection::stream).collect(toList());", "originalCommit": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEyMjEzNw==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r427122137", "bodyText": "FpKit#flatList applies to List<List<>> and we have a Collection<List<>> here.\nShould we create a more generic flatten method in FpKit?", "author": "felipe-gdr", "createdAt": "2020-05-19T08:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMjI4NQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426922285", "bodyText": "this is a breaking change. Should we consider adding another one and keeping this one for use object implementations?", "author": "andimarek", "createdAt": "2020-05-18T22:17:06Z", "path": "src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java", "diffHunk": "@@ -453,13 +454,13 @@ public boolean isObjectType(Type type) {\n     }\n \n     /**\n-     * Returns the list of object types that implement the given interface type\n+     * Returns the list of object and interface types that implement the given interface type\n      *\n      * @param targetInterface the target to search for\n      * @return the list of object types that implement the given interface type\n      */\n-    public List<ObjectTypeDefinition> getImplementationsOf(InterfaceTypeDefinition targetInterface) {\n-        List<ObjectTypeDefinition> objectTypeDefinitions = getTypes(ObjectTypeDefinition.class);\n+    public List<ImplementingTypeDefinition> getImplementationsOf(InterfaceTypeDefinition targetInterface) {", "originalCommit": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEyNTU3Mg==", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r427125572", "bodyText": "Yep, just noticed that this is public API. I'll create a new method.", "author": "felipe-gdr", "createdAt": "2020-05-19T08:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMjI4NQ=="}], "type": "inlineReview"}, {"oid": "cfe170ee8966c63d2a8e10ba7f75f7cc24b8b2ce", "url": "https://github.com/graphql-java/graphql-java/commit/cfe170ee8966c63d2a8e10ba7f75f7cc24b8b2ce", "message": "1764: Create integration test", "committedDate": "2020-05-20T10:42:05Z", "type": "commit"}, {"oid": "04cfbe74b09e7b67094c0b7a69cff427d113f5bb", "url": "https://github.com/graphql-java/graphql-java/commit/04cfbe74b09e7b67094c0b7a69cff427d113f5bb", "message": "1764: PR feedback\n- use FpKit\n- fix Generic definition in ImplementingTypeDefinition\n- don't break public API in TypeDefinitionRegistry", "committedDate": "2020-05-20T10:46:58Z", "type": "commit"}, {"oid": "04cfbe74b09e7b67094c0b7a69cff427d113f5bb", "url": "https://github.com/graphql-java/graphql-java/commit/04cfbe74b09e7b67094c0b7a69cff427d113f5bb", "message": "1764: PR feedback\n- use FpKit\n- fix Generic definition in ImplementingTypeDefinition\n- don't break public API in TypeDefinitionRegistry", "committedDate": "2020-05-20T10:46:58Z", "type": "forcePushed"}, {"oid": "39dc3d4f59671ef3459dd138e384e5802eea1208", "url": "https://github.com/graphql-java/graphql-java/commit/39dc3d4f59671ef3459dd138e384e5802eea1208", "message": "1764: Improve query integration test and add introspection query test", "committedDate": "2020-05-21T22:12:22Z", "type": "commit"}, {"oid": "765698305714677f61fb0e1c2ac469ed97f6a48c", "url": "https://github.com/graphql-java/graphql-java/commit/765698305714677f61fb0e1c2ac469ed97f6a48c", "message": "improve tests", "committedDate": "2020-05-21T23:19:18Z", "type": "commit"}, {"oid": "d04a6ec315e1fc2301c22a1f44712ab16842b507", "url": "https://github.com/graphql-java/graphql-java/commit/d04a6ec315e1fc2301c22a1f44712ab16842b507", "message": "add Interfaces to GraphQLInterfaceType\nfix introspection interfaces field", "committedDate": "2020-05-22T00:47:51Z", "type": "commit"}, {"oid": "b785a5b0266e4bb1ff191be541c62d90d76de519", "url": "https://github.com/graphql-java/graphql-java/commit/b785a5b0266e4bb1ff191be541c62d90d76de519", "message": "test programmatically GraphQLInterfaceType\nand test SchemaPrinter", "committedDate": "2020-05-22T01:38:48Z", "type": "commit"}, {"oid": "2792f3aaa692d17bb86332a78a7c3f4ab94f1452", "url": "https://github.com/graphql-java/graphql-java/commit/2792f3aaa692d17bb86332a78a7c3f4ab94f1452", "message": "transitively declaring all interfaces", "committedDate": "2020-05-22T01:49:13Z", "type": "commit"}, {"oid": "24150503f8a7db0cdd7d7c567cc317d24a9ea731", "url": "https://github.com/graphql-java/graphql-java/commit/24150503f8a7db0cdd7d7c567cc317d24a9ea731", "message": "astprinter handles interfaces in interfaces", "committedDate": "2020-05-22T04:35:09Z", "type": "commit"}, {"oid": "e7a5d841afff2d81c011aae33e4c37cb9898de19", "url": "https://github.com/graphql-java/graphql-java/commit/e7a5d841afff2d81c011aae33e4c37cb9898de19", "message": "add schema printer test", "committedDate": "2020-05-22T04:46:28Z", "type": "commit"}, {"oid": "420481f12a40de2abf22578a711a50d921ffd620", "url": "https://github.com/graphql-java/graphql-java/commit/420481f12a40de2abf22578a711a50d921ffd620", "message": "1764: Implemente interface implement interface validation in SchemaValidator", "committedDate": "2020-05-24T04:30:12Z", "type": "commit"}, {"oid": "08d4bb9d8bb83148e2fdef4e25fedcc850a3029d", "url": "https://github.com/graphql-java/graphql-java/commit/08d4bb9d8bb83148e2fdef4e25fedcc850a3029d", "message": "add test for interface extensions", "committedDate": "2020-05-24T06:19:00Z", "type": "commit"}, {"oid": "760188984685d7572893027e2e9b92af9c267f22", "url": "https://github.com/graphql-java/graphql-java/commit/760188984685d7572893027e2e9b92af9c267f22", "message": "Merge branch 'master' into 1764_allow-interfaces-to-implement-other-interfaces", "committedDate": "2020-05-24T06:34:30Z", "type": "commit"}]}