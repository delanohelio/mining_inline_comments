{"pr_number": 1804, "pr_title": "Support for DataFetcherResult values in subscriptions and better instrumentation.", "pr_createdAt": "2020-02-28T21:40:52Z", "pr_url": "https://github.com/graphql-java/graphql-java/pull/1804", "timeline": [{"oid": "a415bde36945a6ff75e2a5337eeb7d5ab0e92613", "url": "https://github.com/graphql-java/graphql-java/commit/a415bde36945a6ff75e2a5337eeb7d5ab0e92613", "message": "Support for DataFetcherResult values in subscriptions.\n\nThis supports BOTH the Publisher being in a DFR and also any streamed events being in DFRs\n\nIt also adds error support correctly for sending back a stream of possible errors and data as per spec", "committedDate": "2020-02-28T21:40:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNTQyMQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r385935421", "bodyText": "helps with debugging", "author": "bbakerman", "createdAt": "2020-02-28T21:41:22Z", "path": "src/main/java/graphql/GraphqlErrorBuilder.java", "diffHunk": "@@ -135,6 +135,11 @@ public ErrorClassification getErrorType() {\n         public Map<String, Object> getExtensions() {\n             return extensions;\n         }\n+\n+        @Override\n+        public String toString() {\n+            return message;\n+        }", "originalCommit": "a415bde36945a6ff75e2a5337eeb7d5ab0e92613", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDgxOQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r385954819", "bodyText": "we need this because in subscroptions we start a new execution per streamed event", "author": "bbakerman", "createdAt": "2020-02-28T22:38:23Z", "path": "src/main/java/graphql/execution/ExecutionContextBuilder.java", "diffHunk": "@@ -172,6 +172,11 @@ public ExecutionContextBuilder valueUnboxer(ValueUnboxer valueUnboxer) {\n         return this;\n     }\n \n+    public ExecutionContextBuilder resetErrors() {\n+        this.errors.clear();\n+        return this;\n+    }", "originalCommit": "a415bde36945a6ff75e2a5337eeb7d5ab0e92613", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDk3NA==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r385954974", "bodyText": "We reset errors so that we have errors per streamed event BUT we use the same other execution context", "author": "bbakerman", "createdAt": "2020-02-28T22:38:53Z", "path": "src/main/java/graphql/execution/SubscriptionExecutionStrategy.java", "diffHunk": "@@ -92,15 +92,16 @@ public SubscriptionExecutionStrategy(DataFetcherExceptionHandler dataFetcherExce\n      */\n \n     private CompletableFuture<ExecutionResult> executeSubscriptionEvent(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object eventPayload) {\n-        ExecutionContext newExecutionContext = executionContext.transform(builder -> builder.root(eventPayload));\n+        ExecutionContext newExecutionContext = executionContext.transform(builder -> builder\n+                .root(eventPayload)\n+                .resetErrors()\n+        );", "originalCommit": "a415bde36945a6ff75e2a5337eeb7d5ab0e92613", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NTA1MQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r385955051", "bodyText": "The fix here was to called unboxPossibleDataFetcherResult", "author": "bbakerman", "createdAt": "2020-02-28T22:39:14Z", "path": "src/main/java/graphql/execution/SubscriptionExecutionStrategy.java", "diffHunk": "@@ -92,15 +92,16 @@ public SubscriptionExecutionStrategy(DataFetcherExceptionHandler dataFetcherExce\n      */\n \n     private CompletableFuture<ExecutionResult> executeSubscriptionEvent(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object eventPayload) {\n-        ExecutionContext newExecutionContext = executionContext.transform(builder -> builder.root(eventPayload));\n+        ExecutionContext newExecutionContext = executionContext.transform(builder -> builder\n+                .root(eventPayload)\n+                .resetErrors()\n+        );\n \n         ExecutionStrategyParameters newParameters = firstFieldOfSubscriptionSelection(parameters);\n-        FetchedValue fetchedValue = FetchedValue.newFetchedValue().fetchedValue(eventPayload)\n-                .rawFetchedValue(eventPayload)\n-                .localContext(parameters.getLocalContext())\n-                .build();\n-\n-        return completeField(newExecutionContext, newParameters, fetchedValue).getFieldValue()\n+        FetchedValue fetchedValue = unboxPossibleDataFetcherResult(newExecutionContext, parameters, eventPayload);\n+        FieldValueInfo fieldValueInfo = completeField(newExecutionContext, newParameters, fetchedValue);\n+        return fieldValueInfo\n+                .getFieldValue()", "originalCommit": "a415bde36945a6ff75e2a5337eeb7d5ab0e92613", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NTMwNg==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r385955306", "bodyText": "A test of DataFectherResult + errors at the Publisher level and also at each streamed event level and also errors on sub levels", "author": "bbakerman", "createdAt": "2020-02-28T22:40:09Z", "path": "src/test/groovy/graphql/execution/SubscriptionExecutionStrategyTest.groovy", "diffHunk": "@@ -335,4 +351,85 @@ class SubscriptionExecutionStrategyTest extends Specification {\n             }\n         }\n     }\n+\n+    def \"subscriptions can return DataFetcher results with errors\"() {\n+\n+        //\n+        // this tests that we can wrap the Publisher in a DataFetcherResult AND that the return types of the Publisher\n+        // can themselves be DataFetcherResult objects - hence DataFetcherResult<Publisher<DataFetcherResult<Message>>>\n+        // in this case\n+        DataFetcher newMessageDF = new DataFetcher() {\n+            @Override\n+            Object get(DataFetchingEnvironment environment) {\n+                def objectMaker = { int index ->\n+                    def message = new Message(\"sender\" + index, \"text\" + index)\n+                    GraphQLError error = null\n+                    if (index == 1) {\n+                        error = mkError(\"1 is the loneliest number that you'll ever know\")\n+                    }\n+                    // wrap inner result in DataFetcherResult\n+                    def resultBuilder = DataFetcherResult.newResult().data(message).localContext(index)\n+                    if (error != null) {\n+                        resultBuilder.error(error)\n+                    }\n+                    return resultBuilder.build()\n+                }\n+                def publisher = new ReactiveStreamsObjectPublisher(10, objectMaker)\n+                // we also use DFR here to wrap the publisher to show it can work\n+                return DataFetcherResult.newResult().data(publisher).error(mkError(\"The top level field publisher can have errors\")).build()\n+            }\n+\n+        }\n+\n+        DataFetcher senderDF = new DataFetcher() {\n+            @Override\n+            Object get(DataFetchingEnvironment environment) throws Exception {\n+                Message msg = environment.getSource()\n+                if (msg.sender == \"sender1\") {\n+                    return DataFetcherResult.newResult().data(msg.sender).error(mkError(\"Sub level fields can have errors\")).build()\n+                }\n+                return msg.sender\n+            }\n+        }\n+\n+        GraphQL graphQL = buildSubscriptionQL(newMessageDF, senderDF, PropertyDataFetcher.fetching(\"text\"))\n+\n+        def executionInput = ExecutionInput.newExecutionInput().query(\"\"\"\n+            subscription NewMessages {\n+              newMessage(roomId: 123) {\n+                sender\n+                text\n+              }\n+            }\n+        \"\"\").build()\n+\n+        when:\n+\n+        def executionResult = graphQL.execute(executionInput)\n+\n+        Publisher<ExecutionResult> msgStream = executionResult.getData()\n+\n+        def capturingSubscriber = new CapturingSubscriber<ExecutionResult>()\n+        msgStream.subscribe(capturingSubscriber)\n+\n+        then:\n+        Awaitility.await().untilTrue(capturingSubscriber.isDone())\n+\n+        executionResult.errors.size() == 1\n+        executionResult.errors[0].message == \"The top level field publisher can have errors\"\n+\n+        def messages = capturingSubscriber.events\n+        messages.size() == 10\n+        for (int i = 0; i < messages.size(); i++) {\n+            def message = messages[i]\n+            // error handling on publisher events\n+            if (i == 1) {\n+                assert message.errors[0].message == \"1 is the loneliest number that you'll ever know\"\n+                assert message.errors[1].message == \"Sub level fields can have errors\"\n+            } else {\n+                assert message.errors.isEmpty(), \"There should be no errors present\"\n+            }\n+            assert message.data == [\"newMessage\": [sender: \"sender\" + i, text: \"text\" + i]]\n+        }\n+    }", "originalCommit": "a415bde36945a6ff75e2a5337eeb7d5ab0e92613", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8e7bf3bf4283f719c878168df6f9178f2a02852b", "url": "https://github.com/graphql-java/graphql-java/commit/8e7bf3bf4283f719c878168df6f9178f2a02852b", "message": "Made sure local context works as expected", "committedDate": "2020-02-29T07:36:20Z", "type": "commit"}, {"oid": "14c180847177ae1c1df1e45fccd2fd4f9e2c9dbd", "url": "https://github.com/graphql-java/graphql-java/commit/14c180847177ae1c1df1e45fccd2fd4f9e2c9dbd", "message": "Added on subscribed field instrumentation", "committedDate": "2020-02-29T22:51:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2MTM3Mw==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r386061373", "bodyText": "We need this later in subscriptions and the instrumentDataFetcherResult calls.   Its nominally useful as well but execution context unpacks it any way", "author": "bbakerman", "createdAt": "2020-02-29T22:54:13Z", "path": "src/main/java/graphql/execution/Execution.java", "diffHunk": "@@ -96,6 +96,7 @@ public Execution(ExecutionStrategy queryStrategy, ExecutionStrategy mutationStra\n                 .cacheControl(executionInput.getCacheControl())\n                 .locale(executionInput.getLocale())\n                 .valueUnboxer(valueUnboxer)\n+                .executionInput(executionInput)", "originalCommit": "14c180847177ae1c1df1e45fccd2fd4f9e2c9dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2MTM4Nw==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r386061387", "bodyText": "After 18 parameters its time for this pattern", "author": "bbakerman", "createdAt": "2020-02-29T22:54:46Z", "path": "src/main/java/graphql/execution/ExecutionContext.java", "diffHunk": "@@ -46,33 +48,40 @@\n     private final Locale locale;\n     private final DeferSupport deferSupport = new DeferSupport();\n     private final ValueUnboxer valueUnboxer;\n-\n-    ExecutionContext(Instrumentation instrumentation, ExecutionId executionId, GraphQLSchema graphQLSchema, InstrumentationState instrumentationState, ExecutionStrategy queryStrategy, ExecutionStrategy mutationStrategy, ExecutionStrategy subscriptionStrategy, Map<String, FragmentDefinition> fragmentsByName, Document document, OperationDefinition operationDefinition, Map<String, Object> variables, Object context, Object root, DataLoaderRegistry dataLoaderRegistry, CacheControl cacheControl, Locale locale, List<GraphQLError> startingErrors, ValueUnboxer valueUnboxer) {\n-        this.graphQLSchema = graphQLSchema;\n-        this.executionId = executionId;\n-        this.instrumentationState = instrumentationState;\n-        this.queryStrategy = queryStrategy;\n-        this.mutationStrategy = mutationStrategy;\n-        this.subscriptionStrategy = subscriptionStrategy;\n-        this.fragmentsByName = Collections.unmodifiableMap(fragmentsByName);\n-        this.variables = Collections.unmodifiableMap(variables);\n-        this.document = document;\n-        this.operationDefinition = operationDefinition;\n-        this.context = context;\n-        this.root = root;\n-        this.instrumentation = instrumentation;\n-        this.dataLoaderRegistry = dataLoaderRegistry;\n-        this.cacheControl = cacheControl;\n-        this.locale = locale;\n-        this.valueUnboxer = valueUnboxer;\n-        this.errors.addAll(startingErrors);\n+    private final ExecutionInput executionInput;\n+\n+    @Internal\n+    ExecutionContext(ExecutionContextBuilder builder) {", "originalCommit": "14c180847177ae1c1df1e45fccd2fd4f9e2c9dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2e035734cda115a8c77e939a4fed91c893d0aa95", "url": "https://github.com/graphql-java/graphql-java/commit/2e035734cda115a8c77e939a4fed91c893d0aa95", "message": "Added on subscribed field instrumentation", "committedDate": "2020-02-29T22:56:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2MTUwNw==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r386061507", "bodyText": "Better instrumentation of subscription queries", "author": "bbakerman", "createdAt": "2020-02-29T22:56:51Z", "path": "src/main/java/graphql/execution/SubscriptionExecutionStrategy.java", "diffHunk": "@@ -34,22 +44,27 @@ public SubscriptionExecutionStrategy(DataFetcherExceptionHandler dataFetcherExce\n     @Override\n     public CompletableFuture<ExecutionResult> execute(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException {\n \n+        Instrumentation instrumentation = executionContext.getInstrumentation();\n+        InstrumentationExecutionStrategyParameters instrumentationParameters = new InstrumentationExecutionStrategyParameters(executionContext, parameters);\n+        ExecutionStrategyInstrumentationContext executionStrategyCtx = instrumentation.beginExecutionStrategy(instrumentationParameters);\n+", "originalCommit": "14c180847177ae1c1df1e45fccd2fd4f9e2c9dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2MTU2Ng==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r386061566", "bodyText": "This is weird but needed.  We want a execution step info here for the instrumentation - the soon to be called completeValue call will do something similar soon but we need this to descrive the \"beginSubscribedFieldEvent\" in instrumentation terms", "author": "bbakerman", "createdAt": "2020-02-29T22:58:24Z", "path": "src/main/java/graphql/execution/SubscriptionExecutionStrategy.java", "diffHunk": "@@ -125,4 +158,10 @@ private ExecutionStrategyParameters firstFieldOfSubscriptionSelection(ExecutionS\n         return parameters.transform(builder -> builder.field(firstField).path(fieldPath));\n     }\n \n+    private ExecutionStepInfo createSubscribedFieldStepInfo(ExecutionContext executionContext, ExecutionStrategyParameters parameters) {\n+        Field field = parameters.getField().getSingleField();\n+        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();\n+        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n+        return createExecutionStepInfo(executionContext, parameters, fieldDef, parentType);\n+    }", "originalCommit": "14c180847177ae1c1df1e45fccd2fd4f9e2c9dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2MTU5Mw==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r386061593", "bodyText": "code fix up of change in constructor", "author": "bbakerman", "createdAt": "2020-02-29T22:59:07Z", "path": "src/test/groovy/graphql/execution/ExecutionStrategyTest.groovy", "diffHunk": "@@ -60,11 +60,21 @@ class ExecutionStrategyTest extends Specification {\n     def buildContext(GraphQLSchema schema = null) {\n         ExecutionId executionId = ExecutionId.from(\"executionId123\")\n         def variables = [arg1: \"value1\"]\n-        new ExecutionContext(SimpleInstrumentation.INSTANCE, executionId, schema ?: StarWarsSchema.starWarsSchema, null,\n-                executionStrategy, executionStrategy, executionStrategy,\n-                [:], null, null,\n-                variables, \"context\", \"root\", new DataLoaderRegistry(),\n-                null, Locale.getDefault(), Collections.emptyList(), ValueUnboxer.DEFAULT)\n+        def builder = ExecutionContextBuilder.newExecutionContextBuilder()\n+                .instrumentation(SimpleInstrumentation.INSTANCE)\n+                .executionId(executionId)\n+                .graphQLSchema(schema ?: StarWarsSchema.starWarsSchema)\n+                .queryStrategy(executionStrategy)\n+                .mutationStrategy(executionStrategy)\n+                .subscriptionStrategy(executionStrategy)\n+                .variables(variables)\n+                .context(\"context\")\n+                .root(\"root\")\n+                .dataLoaderRegistry(new DataLoaderRegistry())\n+                .locale(Locale.getDefault())\n+                .valueUnboxer(ValueUnboxer.DEFAULT)\n+\n+        new ExecutionContext(builder)", "originalCommit": "14c180847177ae1c1df1e45fccd2fd4f9e2c9dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA2MTYxNA==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r386061614", "bodyText": "A reactive stream thats a little more generic", "author": "bbakerman", "createdAt": "2020-02-29T22:59:47Z", "path": "src/test/groovy/graphql/execution/pubsub/ReactiveStreamsObjectPublisher.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package graphql.execution.pubsub;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.example.unicast.AsyncIterablePublisher;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.function.Function;\n+\n+/**\n+ * This example publisher will create count \"objects\" and then terminate. Its\n+ * uses the reactive streams TCK as its implementation\n+ */\n+public class ReactiveStreamsObjectPublisher implements Publisher<Object> {\n+\n+    private final AsyncIterablePublisher<Object> iterablePublisher;\n+\n+    public ReactiveStreamsObjectPublisher(final int count, Function<Integer, Object> objectMaker) {\n+        Iterable<Object> iterable = mkIterable(count, objectMaker);\n+        iterablePublisher = new AsyncIterablePublisher<>(iterable, ForkJoinPool.commonPool());\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super Object> s) {\n+        iterablePublisher.subscribe(s);\n+    }\n+\n+    private static Iterable<Object> mkIterable(int count, Function<Integer, Object> objectMaker) {\n+        return () -> new Iterator<Object>() {\n+            private int at = 0;\n+\n+            @Override\n+            public boolean hasNext() {\n+                return at < count;\n+            }\n+\n+            @Override\n+            public Object next() {\n+                Object message = objectMaker.apply(at);\n+                at++;\n+                return message;\n+            }\n+        };\n+    }\n+\n+}", "originalCommit": "14c180847177ae1c1df1e45fccd2fd4f9e2c9dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEwMDIwMQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r388100201", "bodyText": "nit: use this on other assignments for consistency", "author": "felipe-gdr", "createdAt": "2020-03-05T06:31:17Z", "path": "src/main/java/graphql/execution/ExecutionContextBuilder.java", "diffHunk": "@@ -84,6 +85,7 @@ public ExecutionContextBuilder() {\n         locale = other.getLocale();\n         errors = new ArrayList<>(other.getErrors());\n         valueUnboxer = other.getValueUnboxer();\n+        this.executionInput = other.getExecutionInput();", "originalCommit": "2e035734cda115a8c77e939a4fed91c893d0aa95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEwMDcxMA==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r388100710", "bodyText": "nit: typo \"and its needs to be mapped\" should be \"and it needs to be mapped\"", "author": "felipe-gdr", "createdAt": "2020-03-05T06:33:20Z", "path": "src/main/java/graphql/execution/instrumentation/Instrumentation.java", "diffHunk": "@@ -114,6 +114,17 @@ default InstrumentationState createState(InstrumentationCreateStateParameters pa\n      */\n     DeferredFieldInstrumentationContext beginDeferredField(InstrumentationDeferredFieldParameters parameters);\n \n+    /**\n+     * This is called each time a subscription field produces a new reactive stream event value and its needs to be mapped over via the graphql field subselection.", "originalCommit": "2e035734cda115a8c77e939a4fed91c893d0aa95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODEwMTEwNg==", "url": "https://github.com/graphql-java/graphql-java/pull/1804#discussion_r388101106", "bodyText": "typo: \"Its uses\" should be \"It uses\"", "author": "felipe-gdr", "createdAt": "2020-03-05T06:34:50Z", "path": "src/test/groovy/graphql/execution/pubsub/ReactiveStreamsObjectPublisher.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package graphql.execution.pubsub;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.example.unicast.AsyncIterablePublisher;\n+\n+import java.util.Iterator;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.function.Function;\n+\n+/**\n+ * This example publisher will create count \"objects\" and then terminate. Its", "originalCommit": "2e035734cda115a8c77e939a4fed91c893d0aa95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "670ce33fb55471a6ce5d589dd66cb9b8bd9035a1", "url": "https://github.com/graphql-java/graphql-java/commit/670ce33fb55471a6ce5d589dd66cb9b8bd9035a1", "message": "Merge remote-tracking branch 'origin/master' into 1795-support-datafetcher-result-in-subscription\n\n# Conflicts:\n#\tsrc/main/java/graphql/execution/ExecutionContext.java\n#\tsrc/main/java/graphql/execution/ExecutionContextBuilder.java\n#\tsrc/test/groovy/graphql/execution/ExecutionStrategyTest.groovy", "committedDate": "2020-05-21T11:19:01Z", "type": "commit"}]}