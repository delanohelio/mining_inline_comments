{"pr_number": 2067, "pr_title": "Support for Streams and Iterators", "pr_createdAt": "2020-10-02T20:29:25Z", "pr_url": "https://github.com/graphql-java/graphql-java/pull/2067", "timeline": [{"oid": "a14f55ce3e098d7813d6a45ac7d415c6a416c284", "url": "https://github.com/graphql-java/graphql-java/commit/a14f55ce3e098d7813d6a45ac7d415c6a416c284", "message": "centralizing isIterable logic in FpKit", "committedDate": "2020-10-03T05:45:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2MTI2OQ==", "url": "https://github.com/graphql-java/graphql-java/pull/2067#discussion_r500061269", "bodyText": "This is a mild breaking change - the input is \"Object\" but the actual type has changed.\nI think this is ok (did we say it WOULD always be a collection??) but I just want to call it out and see others thoughts on this.", "author": "bbakerman", "createdAt": "2020-10-06T07:29:08Z", "path": "src/main/java/graphql/execution/ExecutionStrategy.java", "diffHunk": "@@ -494,19 +496,19 @@ protected FieldValueInfo completeValueForList(ExecutionContext executionContext,\n      */\n     protected FieldValueInfo completeValueForList(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Iterable<Object> iterableValues) {\n \n-        Collection<Object> values = FpKit.toCollection(iterableValues);\n+        OptionalInt size = FpKit.toSize(iterableValues);\n         ExecutionStepInfo executionStepInfo = parameters.getExecutionStepInfo();\n \n-        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, () -> executionStepInfo, values);\n+        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, () -> executionStepInfo, iterableValues);", "originalCommit": "a14f55ce3e098d7813d6a45ac7d415c6a416c284", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIwODkxOA==", "url": "https://github.com/graphql-java/graphql-java/pull/2067#discussion_r500208918", "bodyText": "yes, this could be a breaking change.\nArrays are reallocated anymore as List (but I could easily re-introduce this behavior).\nFor Collections we should be fine: toIterable does not change the concrete type.\nFor Streams/Iterators we should be fine as well: nobody is using that right now.", "author": "dfa1", "createdAt": "2020-10-06T11:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2MTI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2NzYwMw==", "url": "https://github.com/graphql-java/graphql-java/pull/2067#discussion_r500067603", "bodyText": "I had a look at graphql.execution.ExecutionStrategyParameters#getListSize - we never use it.\nI was worried this -1 semantics could affect some one )badly but we never use it - I think this will be ok", "author": "bbakerman", "createdAt": "2020-10-06T07:40:24Z", "path": "src/main/java/graphql/execution/ExecutionStrategy.java", "diffHunk": "@@ -519,7 +521,7 @@ protected FieldValueInfo completeValueForList(ExecutionContext executionContext,\n             ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                     builder.executionStepInfo(stepInfoForListElement)\n                             .nonNullFieldValidator(nonNullableFieldValidator)\n-                            .listSize(values.size())\n+                            .listSize(size.orElse(-1)) // -1 signals that we don't know the size", "originalCommit": "a14f55ce3e098d7813d6a45ac7d415c6a416c284", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIwNTg1Mw==", "url": "https://github.com/graphql-java/graphql-java/pull/2067#discussion_r500205853", "bodyText": "yes, I think it is backward compatible.\nMaybe we can introduce a new method that returns OptionalInt ?", "author": "dfa1", "createdAt": "2020-10-06T11:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2NzYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2OTQ4Mg==", "url": "https://github.com/graphql-java/graphql-java/pull/2067#discussion_r500069482", "bodyText": "At the end of the day we are still allocated an array the size of the list -  So source of the data can be a stream but we can stay streaming all the way.\nThis is an improvement - as you say it greatly reduces your memory usage (nearly half??) but longer term could we have streams all the way down to the turtles?\nThinking aloud here it might be too theoretical - I know there is code out there that assumes ExecutionResult is really a Map of lists and maps and values.  Would introducing \"streams\" in that break things?", "author": "bbakerman", "createdAt": "2020-10-06T07:43:35Z", "path": "src/main/java/graphql/execution/ExecutionStrategy.java", "diffHunk": "@@ -494,19 +496,19 @@ protected FieldValueInfo completeValueForList(ExecutionContext executionContext,\n      */\n     protected FieldValueInfo completeValueForList(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Iterable<Object> iterableValues) {\n \n-        Collection<Object> values = FpKit.toCollection(iterableValues);\n+        OptionalInt size = FpKit.toSize(iterableValues);\n         ExecutionStepInfo executionStepInfo = parameters.getExecutionStepInfo();\n \n-        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, () -> executionStepInfo, values);\n+        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, () -> executionStepInfo, iterableValues);\n         Instrumentation instrumentation = executionContext.getInstrumentation();\n \n         InstrumentationContext<ExecutionResult> completeListCtx = instrumentation.beginFieldListComplete(\n                 instrumentationParams\n         );\n \n-        List<FieldValueInfo> fieldValueInfos = new ArrayList<>(values.size());\n+        List<FieldValueInfo> fieldValueInfos = new ArrayList<>(size.orElse(1));", "originalCommit": "a14f55ce3e098d7813d6a45ac7d415c6a416c284", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIwNDI5MQ==", "url": "https://github.com/graphql-java/graphql-java/pull/2067#discussion_r500204291", "bodyText": "At the end of the day we are still allocated an array the size of the list - So source of the data can be a stream but we can stay streaming all the way.\n\nyes, I was not able to remove this big list.\n\nThis is an improvement - as you say it greatly reduces your memory usage (nearly half??) but longer term could we have streams all the way down to the turtles?\nDon't know yet: eventually everything is \"materialized\" in a single ExecutionResult. Would be nice to minimize everything else.\n\nThis the most big query we have so far.\nBefore\n\nAfter\n\n\nThinking aloud here it might be too theoretical - I know there is code out there that assumes ExecutionResult is really a Map of lists and maps and values. Would introducing \"streams\" in that break things?\n\nWe are merely introducing streaming between datafetchers and execution strategy: so this is very conservative choice by now.", "author": "dfa1", "createdAt": "2020-10-06T11:35:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA2OTQ4Mg=="}], "type": "inlineReview"}, {"oid": "101e06aa7848959d60150732f630038638c62cf6", "url": "https://github.com/graphql-java/graphql-java/commit/101e06aa7848959d60150732f630038638c62cf6", "message": "support for streams/iterators\n\nAllowing DataFetchers to return Stream<T> and Iterator<T>.", "committedDate": "2020-10-06T15:38:10Z", "type": "commit"}, {"oid": "101e06aa7848959d60150732f630038638c62cf6", "url": "https://github.com/graphql-java/graphql-java/commit/101e06aa7848959d60150732f630038638c62cf6", "message": "support for streams/iterators\n\nAllowing DataFetchers to return Stream<T> and Iterator<T>.", "committedDate": "2020-10-06T15:38:10Z", "type": "forcePushed"}]}