{"pr_number": 3529, "pr_title": "[RW-4760][risk=no] MapStruct Best Practices Doc", "pr_createdAt": "2020-05-03T22:07:24Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3529", "timeline": [{"oid": "76064f6274c5bdc2fe23226e91debb9e71663268", "url": "https://github.com/all-of-us/workbench/commit/76064f6274c5bdc2fe23226e91debb9e71663268", "message": "[skip ci]", "committedDate": "2020-05-03T22:02:34Z", "type": "commit"}, {"oid": "4e167999a501d9d0a50243e7f759009360d68ec7", "url": "https://github.com/all-of-us/workbench/commit/4e167999a501d9d0a50243e7f759009360d68ec7", "message": "start testing section", "committedDate": "2020-05-03T22:11:36Z", "type": "commit"}, {"oid": "547a08ce2d5835d457894130dc85ef3b8034c0e6", "url": "https://github.com/all-of-us/workbench/commit/547a08ce2d5835d457894130dc85ef3b8034c0e6", "message": "add test case", "committedDate": "2020-05-03T22:13:41Z", "type": "commit"}, {"oid": "84460942f76b953a05feded4ecc46f5575753e98", "url": "https://github.com/all-of-us/workbench/commit/84460942f76b953a05feded4ecc46f5575753e98", "message": "finish up thoughts [skip ci]", "committedDate": "2020-05-03T22:34:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNzMwMw==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419637303", "bodyText": "I would prefer to have this section at the very end of the doc or possibly in a subdirectory for stories and other protracted examples. It distracts from the actual reason I come looking for this file - the coding standards we want to uphold when using this library.", "author": "als364", "createdAt": "2020-05-04T18:25:00Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyODIyNw==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419728227", "bodyText": "I think my preference here is to put the examples where they are relevant. A full, complete example should go at the bottom (I agree with Ariel) and maybe have a link here. But I would love to see examples scattered throughout with each standard.", "author": "s-rubenstein", "createdAt": "2020-05-04T21:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNzMwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczMTE5NA==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419731194", "bodyText": "Pulling it out into its own tutorial makes sense.", "author": "jaycarlton", "createdAt": "2020-05-04T21:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNzMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzODI3Mw==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419638273", "bodyText": "For what reason do you want to be careful? What does being careful or not being careful look like? What happens when you are not careful?", "author": "als364", "createdAt": "2020-05-04T18:26:38Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTEyMA==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419645120", "bodyText": "docment -> document. does your mac hate u?", "author": "als364", "createdAt": "2020-05-04T18:37:47Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers\n+It's pretty tedious to write tests for generated code, as the computer is coding faster than you.\n+I still think it's worth it, because,\n+- it documents usage of your generated methods\n+- you catch things the compiler can't (such as when a string format changes)\n+- it's a good opportunity to update old test code\n+- It makes it look less magical\n+\n+### Consider other use cases\n+It's possible to write a mapper from a type to itself and use that as a copy constructor of sorts.\n+\n+### Tune the classes' public APIs\n+If you find yourself writing arcane helper methods, ask yourself if adding a simple setter or\n+getter on one of your classes would make the job easier and the generated code cleaner. Since our\n+model classes are generated, we frequently have to have external helper methods defined in either\n+the mapper class or a utility class.\n+\n+## Handling missing target properties\n+### Avoid `ignore = true` unless absolutely necessary\n+It's annoying to see warnings about missing target properties, and for good reason. The quick way to\n+stifle these is to use the `ignore` parameter, which tells MapStruct to elide the setter code for\n+that target property.\n+```java\n+@Mapping(target = \"billingAccountName\", ignore = true)\n+```\n+\n+While there are some places this is necessary, it should really be a last resort, for a couple of\n+reasons.\n+\n+First, we plan to use mappers to replace existing chunks of code in a clean way. We don't want to\n+have to docment that mapping function X leaves the created object in state Y with respect to fields", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyNTcyMw==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419725723", "bodyText": "yeah. My cat was sleeping on the keyboard and I wiped all the hair and whatever oil she likes to secrete off, and the u key has never been the same since.", "author": "jaycarlton", "createdAt": "2020-05-04T21:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTIzMA==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419645230", "bodyText": "annal -> annual", "author": "als364", "createdAt": "2020-05-04T18:37:59Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTQ3Ng==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419645476", "bodyText": "difficuult -> difficult. maybe it took all the u's and put them here.", "author": "als364", "createdAt": "2020-05-04T18:38:26Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers\n+It's pretty tedious to write tests for generated code, as the computer is coding faster than you.\n+I still think it's worth it, because,\n+- it documents usage of your generated methods\n+- you catch things the compiler can't (such as when a string format changes)\n+- it's a good opportunity to update old test code\n+- It makes it look less magical\n+\n+### Consider other use cases\n+It's possible to write a mapper from a type to itself and use that as a copy constructor of sorts.\n+\n+### Tune the classes' public APIs\n+If you find yourself writing arcane helper methods, ask yourself if adding a simple setter or\n+getter on one of your classes would make the job easier and the generated code cleaner. Since our\n+model classes are generated, we frequently have to have external helper methods defined in either\n+the mapper class or a utility class.\n+\n+## Handling missing target properties\n+### Avoid `ignore = true` unless absolutely necessary\n+It's annoying to see warnings about missing target properties, and for good reason. The quick way to\n+stifle these is to use the `ignore` parameter, which tells MapStruct to elide the setter code for\n+that target property.\n+```java\n+@Mapping(target = \"billingAccountName\", ignore = true)\n+```\n+\n+While there are some places this is necessary, it should really be a last resort, for a couple of\n+reasons.\n+\n+First, we plan to use mappers to replace existing chunks of code in a clean way. We don't want to\n+have to docment that mapping function X leaves the created object in state Y with respect to fields\n+P, Q, and R. Many of our objects are relatively complex, and it's not obvious when looking at a call\n+to `fooMapper.toModel()` that the output model is incomplete in some way(s).\n+\n+Second, if a target property is difficuult to satisfy, this is a signal that either our class design", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTY1Mw==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419645653", "bodyText": "prereqisite -> prerequisite", "author": "als364", "createdAt": "2020-05-04T18:38:43Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers\n+It's pretty tedious to write tests for generated code, as the computer is coding faster than you.\n+I still think it's worth it, because,\n+- it documents usage of your generated methods\n+- you catch things the compiler can't (such as when a string format changes)\n+- it's a good opportunity to update old test code\n+- It makes it look less magical\n+\n+### Consider other use cases\n+It's possible to write a mapper from a type to itself and use that as a copy constructor of sorts.\n+\n+### Tune the classes' public APIs\n+If you find yourself writing arcane helper methods, ask yourself if adding a simple setter or\n+getter on one of your classes would make the job easier and the generated code cleaner. Since our\n+model classes are generated, we frequently have to have external helper methods defined in either\n+the mapper class or a utility class.\n+\n+## Handling missing target properties\n+### Avoid `ignore = true` unless absolutely necessary\n+It's annoying to see warnings about missing target properties, and for good reason. The quick way to\n+stifle these is to use the `ignore` parameter, which tells MapStruct to elide the setter code for\n+that target property.\n+```java\n+@Mapping(target = \"billingAccountName\", ignore = true)\n+```\n+\n+While there are some places this is necessary, it should really be a last resort, for a couple of\n+reasons.\n+\n+First, we plan to use mappers to replace existing chunks of code in a clean way. We don't want to\n+have to docment that mapping function X leaves the created object in state Y with respect to fields\n+P, Q, and R. Many of our objects are relatively complex, and it's not obvious when looking at a call\n+to `fooMapper.toModel()` that the output model is incomplete in some way(s).\n+\n+Second, if a target property is difficuult to satisfy, this is a signal that either our class design\n+could be better, or we've left out a prereqisite.", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0NTg3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419645872", "bodyText": "defauld -> default", "author": "als364", "createdAt": "2020-05-04T18:39:03Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers\n+It's pretty tedious to write tests for generated code, as the computer is coding faster than you.\n+I still think it's worth it, because,\n+- it documents usage of your generated methods\n+- you catch things the compiler can't (such as when a string format changes)\n+- it's a good opportunity to update old test code\n+- It makes it look less magical\n+\n+### Consider other use cases\n+It's possible to write a mapper from a type to itself and use that as a copy constructor of sorts.\n+\n+### Tune the classes' public APIs\n+If you find yourself writing arcane helper methods, ask yourself if adding a simple setter or\n+getter on one of your classes would make the job easier and the generated code cleaner. Since our\n+model classes are generated, we frequently have to have external helper methods defined in either\n+the mapper class or a utility class.\n+\n+## Handling missing target properties\n+### Avoid `ignore = true` unless absolutely necessary\n+It's annoying to see warnings about missing target properties, and for good reason. The quick way to\n+stifle these is to use the `ignore` parameter, which tells MapStruct to elide the setter code for\n+that target property.\n+```java\n+@Mapping(target = \"billingAccountName\", ignore = true)\n+```\n+\n+While there are some places this is necessary, it should really be a last resort, for a couple of\n+reasons.\n+\n+First, we plan to use mappers to replace existing chunks of code in a clean way. We don't want to\n+have to docment that mapping function X leaves the created object in state Y with respect to fields\n+P, Q, and R. Many of our objects are relatively complex, and it's not obvious when looking at a call\n+to `fooMapper.toModel()` that the output model is incomplete in some way(s).\n+\n+Second, if a target property is difficuult to satisfy, this is a signal that either our class design\n+could be better, or we've left out a prereqisite.\n+\n+One strategy for avoiding unmatched target property is to add parameters to the method specifying\n+them. Then simply specify defaults for those at the call site as appropriate.\n+\n+If the type of the target property has a reasonable defalt (such as zero), and `null` isn't a valid\n+state for it, then using `NullValuePropertyMappingStrategy.SET_TO_DEFAULT` is an option.\n+\n+## Handling Default Values\n+### Handling database defalts\n+If the target class is a Hibernate model, and one or more fields have defaults\n+defined in the database schema, we do not want to overwrite that field with `null`\n+or any defauld value listed in the mapper's annotations. To get around this, we need", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MjIxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419652211", "bodyText": "This is the section I most want to see in this document and it's 563 lines in. Could you move this closer to the beginning of the document?", "author": "als364", "createdAt": "2020-05-04T18:49:58Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers\n+It's pretty tedious to write tests for generated code, as the computer is coding faster than you.\n+I still think it's worth it, because,\n+- it documents usage of your generated methods\n+- you catch things the compiler can't (such as when a string format changes)\n+- it's a good opportunity to update old test code\n+- It makes it look less magical\n+\n+### Consider other use cases\n+It's possible to write a mapper from a type to itself and use that as a copy constructor of sorts.\n+\n+### Tune the classes' public APIs\n+If you find yourself writing arcane helper methods, ask yourself if adding a simple setter or\n+getter on one of your classes would make the job easier and the generated code cleaner. Since our\n+model classes are generated, we frequently have to have external helper methods defined in either\n+the mapper class or a utility class.\n+\n+## Handling missing target properties\n+### Avoid `ignore = true` unless absolutely necessary\n+It's annoying to see warnings about missing target properties, and for good reason. The quick way to\n+stifle these is to use the `ignore` parameter, which tells MapStruct to elide the setter code for\n+that target property.\n+```java\n+@Mapping(target = \"billingAccountName\", ignore = true)\n+```\n+\n+While there are some places this is necessary, it should really be a last resort, for a couple of\n+reasons.\n+\n+First, we plan to use mappers to replace existing chunks of code in a clean way. We don't want to\n+have to docment that mapping function X leaves the created object in state Y with respect to fields\n+P, Q, and R. Many of our objects are relatively complex, and it's not obvious when looking at a call\n+to `fooMapper.toModel()` that the output model is incomplete in some way(s).\n+\n+Second, if a target property is difficuult to satisfy, this is a signal that either our class design\n+could be better, or we've left out a prereqisite.\n+\n+One strategy for avoiding unmatched target property is to add parameters to the method specifying\n+them. Then simply specify defaults for those at the call site as appropriate.\n+\n+If the type of the target property has a reasonable defalt (such as zero), and `null` isn't a valid\n+state for it, then using `NullValuePropertyMappingStrategy.SET_TO_DEFAULT` is an option.\n+\n+## Handling Default Values\n+### Handling database defalts\n+If the target class is a Hibernate model, and one or more fields have defaults\n+defined in the database schema, we do not want to overwrite that field with `null`\n+or any defauld value listed in the mapper's annotations. To get around this, we need\n+to set the `nullValuePropertyMappingStrategy` to `NullValuePropertyMappingStrategy.IGNORE`.\n+This prevents the MapStruct implementation from writing to the target property if the source is null.\n+```java\n+  @Mapping(\n+      source = \"workspace.billingStatus\",\n+      target = \"billingStatus\",\n+      nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)\n+```\n+Note that in this case I'm adding an annotation for a field that MapStruct was previously happy\n+to map implicitly to override its defalt behavior.\n+\n+### Specifying a non-default default\n+It's possible to set a default value in the `@Mapping` by\n+using `defaultValue`. This is rarely a good idea, as\n+either the constructor of the target class should be\n+doing this, or the application should specify it. It's mainly\n+useful for dealing with awkward legacy structure that you can't change.\n+\n+One place where this seems to be the least bad option is with\n+the read-only `etag` column in the `workspace` table:\n+```java\n+// Use default CDR version if null. There are really no other good options (i.e. a zero version is just wrong).\n+@Mapping(source = \"workspace.etag\", target = \"version\", qualifiedByName = \"etagToCdrVersion\", defaultValue = \"1\")\n+```\n+## Semi-advanced topics", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczNTE3MA==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419735170", "bodyText": "I am not sure I actually agree here. I do think we could probably move the big, early example down, but my preference is for the basics and then the advanced topics, so that people new to mapstruct don't get thrown in the deep end before they know the basics.", "author": "s-rubenstein", "createdAt": "2020-05-04T21:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MjIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1MjI2Ng==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419652266", "bodyText": "stratgegies -> strategies", "author": "als364", "createdAt": "2020-05-04T18:50:04Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers\n+It's pretty tedious to write tests for generated code, as the computer is coding faster than you.\n+I still think it's worth it, because,\n+- it documents usage of your generated methods\n+- you catch things the compiler can't (such as when a string format changes)\n+- it's a good opportunity to update old test code\n+- It makes it look less magical\n+\n+### Consider other use cases\n+It's possible to write a mapper from a type to itself and use that as a copy constructor of sorts.\n+\n+### Tune the classes' public APIs\n+If you find yourself writing arcane helper methods, ask yourself if adding a simple setter or\n+getter on one of your classes would make the job easier and the generated code cleaner. Since our\n+model classes are generated, we frequently have to have external helper methods defined in either\n+the mapper class or a utility class.\n+\n+## Handling missing target properties\n+### Avoid `ignore = true` unless absolutely necessary\n+It's annoying to see warnings about missing target properties, and for good reason. The quick way to\n+stifle these is to use the `ignore` parameter, which tells MapStruct to elide the setter code for\n+that target property.\n+```java\n+@Mapping(target = \"billingAccountName\", ignore = true)\n+```\n+\n+While there are some places this is necessary, it should really be a last resort, for a couple of\n+reasons.\n+\n+First, we plan to use mappers to replace existing chunks of code in a clean way. We don't want to\n+have to docment that mapping function X leaves the created object in state Y with respect to fields\n+P, Q, and R. Many of our objects are relatively complex, and it's not obvious when looking at a call\n+to `fooMapper.toModel()` that the output model is incomplete in some way(s).\n+\n+Second, if a target property is difficuult to satisfy, this is a signal that either our class design\n+could be better, or we've left out a prereqisite.\n+\n+One strategy for avoiding unmatched target property is to add parameters to the method specifying\n+them. Then simply specify defaults for those at the call site as appropriate.\n+\n+If the type of the target property has a reasonable defalt (such as zero), and `null` isn't a valid\n+state for it, then using `NullValuePropertyMappingStrategy.SET_TO_DEFAULT` is an option.\n+\n+## Handling Default Values\n+### Handling database defalts\n+If the target class is a Hibernate model, and one or more fields have defaults\n+defined in the database schema, we do not want to overwrite that field with `null`\n+or any defauld value listed in the mapper's annotations. To get around this, we need\n+to set the `nullValuePropertyMappingStrategy` to `NullValuePropertyMappingStrategy.IGNORE`.\n+This prevents the MapStruct implementation from writing to the target property if the source is null.\n+```java\n+  @Mapping(\n+      source = \"workspace.billingStatus\",\n+      target = \"billingStatus\",\n+      nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)\n+```\n+Note that in this case I'm adding an annotation for a field that MapStruct was previously happy\n+to map implicitly to override its defalt behavior.\n+\n+### Specifying a non-default default\n+It's possible to set a default value in the `@Mapping` by\n+using `defaultValue`. This is rarely a good idea, as\n+either the constructor of the target class should be\n+doing this, or the application should specify it. It's mainly\n+useful for dealing with awkward legacy structure that you can't change.\n+\n+One place where this seems to be the least bad option is with\n+the read-only `etag` column in the `workspace` table:\n+```java\n+// Use default CDR version if null. There are really no other good options (i.e. a zero version is just wrong).\n+@Mapping(source = \"workspace.etag\", target = \"version\", qualifiedByName = \"etagToCdrVersion\", defaultValue = \"1\")\n+```\n+## Semi-advanced topics\n+\n+### Mapping to a subset of target properties\n+If you need to map from an object with sub-objects to a target type that's flat, there are two\n+stratgegies. The first is to use dot indexing in the `@Mapping` annotation, for example", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY1NDI1NA==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419654254", "bodyText": "It seems like this sentence isn't quite finished", "author": "als364", "createdAt": "2020-05-04T18:53:27Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers\n+It's pretty tedious to write tests for generated code, as the computer is coding faster than you.\n+I still think it's worth it, because,\n+- it documents usage of your generated methods\n+- you catch things the compiler can't (such as when a string format changes)\n+- it's a good opportunity to update old test code\n+- It makes it look less magical\n+\n+### Consider other use cases\n+It's possible to write a mapper from a type to itself and use that as a copy constructor of sorts.\n+\n+### Tune the classes' public APIs\n+If you find yourself writing arcane helper methods, ask yourself if adding a simple setter or\n+getter on one of your classes would make the job easier and the generated code cleaner. Since our\n+model classes are generated, we frequently have to have external helper methods defined in either\n+the mapper class or a utility class.\n+\n+## Handling missing target properties\n+### Avoid `ignore = true` unless absolutely necessary\n+It's annoying to see warnings about missing target properties, and for good reason. The quick way to\n+stifle these is to use the `ignore` parameter, which tells MapStruct to elide the setter code for\n+that target property.\n+```java\n+@Mapping(target = \"billingAccountName\", ignore = true)\n+```\n+\n+While there are some places this is necessary, it should really be a last resort, for a couple of\n+reasons.\n+\n+First, we plan to use mappers to replace existing chunks of code in a clean way. We don't want to\n+have to docment that mapping function X leaves the created object in state Y with respect to fields\n+P, Q, and R. Many of our objects are relatively complex, and it's not obvious when looking at a call\n+to `fooMapper.toModel()` that the output model is incomplete in some way(s).\n+\n+Second, if a target property is difficuult to satisfy, this is a signal that either our class design\n+could be better, or we've left out a prereqisite.\n+\n+One strategy for avoiding unmatched target property is to add parameters to the method specifying\n+them. Then simply specify defaults for those at the call site as appropriate.\n+\n+If the type of the target property has a reasonable defalt (such as zero), and `null` isn't a valid\n+state for it, then using `NullValuePropertyMappingStrategy.SET_TO_DEFAULT` is an option.\n+\n+## Handling Default Values\n+### Handling database defalts\n+If the target class is a Hibernate model, and one or more fields have defaults\n+defined in the database schema, we do not want to overwrite that field with `null`\n+or any defauld value listed in the mapper's annotations. To get around this, we need\n+to set the `nullValuePropertyMappingStrategy` to `NullValuePropertyMappingStrategy.IGNORE`.\n+This prevents the MapStruct implementation from writing to the target property if the source is null.\n+```java\n+  @Mapping(\n+      source = \"workspace.billingStatus\",\n+      target = \"billingStatus\",\n+      nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)\n+```\n+Note that in this case I'm adding an annotation for a field that MapStruct was previously happy\n+to map implicitly to override its defalt behavior.\n+\n+### Specifying a non-default default\n+It's possible to set a default value in the `@Mapping` by\n+using `defaultValue`. This is rarely a good idea, as\n+either the constructor of the target class should be\n+doing this, or the application should specify it. It's mainly\n+useful for dealing with awkward legacy structure that you can't change.\n+\n+One place where this seems to be the least bad option is with\n+the read-only `etag` column in the `workspace` table:\n+```java\n+// Use default CDR version if null. There are really no other good options (i.e. a zero version is just wrong).\n+@Mapping(source = \"workspace.etag\", target = \"version\", qualifiedByName = \"etagToCdrVersion\", defaultValue = \"1\")\n+```\n+## Semi-advanced topics\n+\n+### Mapping to a subset of target properties\n+If you need to map from an object with sub-objects to a target type that's flat, there are two\n+stratgegies. The first is to use dot indexing in the `@Mapping` annotation, for example\n+`@Mapping(source = \"employee.contact.address\", target = \"address\")`. This works well, but the\n+generated code will look sloppy if you have to do this many times (e.g. for ResearchPurpose).\n+If you want to have the address member on the source accessed only once in the mapping (e.g. if it\n+involves some expensive calculation or network call), then it's better to have a separate method\n+using `@MappingTarget` on the target type. Something like the following may work\n+```java\n+default void setAddress(@MappingTarget DbEmployee dbEmployee, EmployeeModel employee) {\n+  dbEmployee.setAddress(employee.address);\n+}\n+```\n+\n+You could also elect to have a setter for this object on the target class itself, but then you may\n+lose some of the benefits of MapStruct's compile-time checking.\n+\n+Finally, note that this hierarchical mismatch may be a design smell.\n+\n+### Pulling in other mappers\n+The `uses` directive instructs MapStruct to look for candidates in external classes. We have one\n+class just for this purpose called `CommonMappers`. Additionally, classes exposing public static\n+methods, such as `DbStorageEnums` can be used to good effect.\n+\n+### Using the `@AfterMapping` annotation\n+Sometimes it's desirable to perform some fixup or post-mapping operations. While this should not be\n+common, it's a handy tool to have around. In the case of target types that are generated from\n+`swagger-codegen`, often the default constructor is lacking. For example it does not initialize\n+array members to empty arrays but leaves them as null. We can fix this with an appropriate\n+after mapping method that initializes those fields if they're not already.\n+\n+### Using DAOs\n+If you specify `componentModel = \"spring\"` in the top-level `@Mapper` annotation, you can inject\n+Spring beans and services. If you go this route, be sure to document and test all side effects. I'm\n+not sure what the convention should be on whether a target Hibernate entity should be saved inside\n+the mapping method or not.\n+\n+## False positive matches\n+Although the rules used in the codegen are reliable, they may not be intuitive when you're dealing\n+with large classes with many similar fields of the same types. In particular for this project,\n+be very careful with various combinations of `Workspace`, `DbWorkspace`, and `FirecloudWorkspace`. \n+- Timestamp vs SqlTimestamp. SqlTimestamp is slightly special, and many of the generated time conversions are not _quite_ what we\n+want. For example, we spun our own Sql Timestamps to String mapper\n+- Application-specific order dependence", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyNzMxOQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419727319", "bodyText": "Nit: There's some double letters here.", "author": "s-rubenstein", "createdAt": "2020-05-04T21:04:11Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyOTM2MA==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419729360", "bodyText": "These are exactly the sort of small examples I like.", "author": "s-rubenstein", "createdAt": "2020-05-04T21:07:54Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5NTQxNg==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r421895416", "bodyText": "Thanks. It was fun and educational to go through the exercise of writing it and convincing myself I knew what I was talking about.", "author": "jaycarlton", "createdAt": "2020-05-08T02:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyOTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczMjQxOQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419732419", "bodyText": "I mean, I am sure you could do it the same way you did name in the same class, but that is less reusable.", "author": "s-rubenstein", "createdAt": "2020-05-04T21:13:52Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us ", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5NTcxNA==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r421895714", "bodyText": "A Mapper can use another Mapper, so as long as you avoid cycles it's still reusable.", "author": "jaycarlton", "createdAt": "2020-05-08T02:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczMjQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczMzU1Mw==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r419733553", "bodyText": "It would be great to mention some sample file names and where they appear in the filetree here. (Filetree optional, since it could move and make our documentation stale)", "author": "s-rubenstein", "createdAt": "2020-05-04T21:16:09Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5NzY4Mw==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r421897683", "bodyText": "I yanked them from the repo. I'd need to make a new project and put them there. In the end I decided this article could be the source of truth.\nIf you just make a new file in the existing mappers directory (or anywhere) it'll work. Then put the test case in the same package under the test tree.", "author": "jaycarlton", "createdAt": "2020-05-08T02:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczMzU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0ODM1NQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r420948355", "bodyText": "move below CircleCI", "author": "jmthibault79", "createdAt": "2020-05-06T17:02:14Z", "path": "README.md", "diffHunk": "@@ -1,11 +1,14 @@\n # Workbench\n \n-[![CircleCI Build Status](https://circleci.com/gh/all-of-us/workbench.svg)](https://circleci.com/gh/all-of-us/workflows/workbench)\n+## Development Guides", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2MzYwNw==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r421063607", "bodyText": "\ud83d\udc4d We also need a blurb about what this project is.", "author": "jaycarlton", "createdAt": "2020-05-06T20:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0ODM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk1MzQ1Mg==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r420953452", "bodyText": "awkward wording here.  Maybe \"it only mapped one out of four\"", "author": "jmthibault79", "createdAt": "2020-05-06T17:10:25Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk1NzY1OQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r420957659", "bodyText": "I'm pretty sure the reason this worked is because there's an unambiguous match from \"needs a String\" to \"provides a String\".", "author": "jmthibault79", "createdAt": "2020-05-06T17:16:44Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk1ODc5MQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r420958791", "bodyText": "So I'd prefer adding another String field to this example, which I expect would cause an error.  THEN we can find out if it's clever enough to match \"name\" if it sees toName()", "author": "jmthibault79", "createdAt": "2020-05-06T17:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk1NzY1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MTE4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r420961189", "bodyText": "ok you get into that later.  great!", "author": "jmthibault79", "createdAt": "2020-05-06T17:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk1NzY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxNTYzMQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r421015631", "bodyText": "Add how to resolve ambiguity here.  See qualifiedByName in VerifiedInstitutionalAffiliationMapper", "author": "jmthibault79", "createdAt": "2020-05-06T18:49:23Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxNzQxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r421017411", "bodyText": "I disagree on \"last resort\".  Certain patterns require it, such as a DB model class with a DB-specific primary key field which isn't present in the API model class.", "author": "jmthibault79", "createdAt": "2020-05-06T18:52:07Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers\n+It's pretty tedious to write tests for generated code, as the computer is coding faster than you.\n+I still think it's worth it, because,\n+- it documents usage of your generated methods\n+- you catch things the compiler can't (such as when a string format changes)\n+- it's a good opportunity to update old test code\n+- It makes it look less magical\n+\n+### Consider other use cases\n+It's possible to write a mapper from a type to itself and use that as a copy constructor of sorts.\n+\n+### Tune the classes' public APIs\n+If you find yourself writing arcane helper methods, ask yourself if adding a simple setter or\n+getter on one of your classes would make the job easier and the generated code cleaner. Since our\n+model classes are generated, we frequently have to have external helper methods defined in either\n+the mapper class or a utility class.\n+\n+## Handling missing target properties\n+### Avoid `ignore = true` unless absolutely necessary\n+It's annoying to see warnings about missing target properties, and for good reason. The quick way to\n+stifle these is to use the `ignore` parameter, which tells MapStruct to elide the setter code for\n+that target property.\n+```java\n+@Mapping(target = \"billingAccountName\", ignore = true)\n+```\n+\n+While there are some places this is necessary, it should really be a last resort, for a couple of", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c5eeb6352abefbbce11320f460cd49936a7943b7", "url": "https://github.com/all-of-us/workbench/commit/c5eeb6352abefbbce11320f460cd49936a7943b7", "message": "Merge branch 'master' into jaycarlton/mapstructBestPractices", "committedDate": "2020-05-06T20:11:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMDIxOA==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r421110218", "bodyText": "At a glance this does not look like a best practice. If we support doing this, I think it should pretty clearly be for read-only operations and should be loudly documented. Could you add a bit more here about why you might need to do this?\nFWIW there's only one example I found in the code that does this. It's very unclear from reading the code whether it's actively in use, or if it is, how it is being used (if it's needed, I'm guessing maybe something around lazy lookup of a foreign relationship to user).  \n  \n    \n      workbench/api/src/test/java/org/pmiops/workbench/utils/CohortMapper.java\n    \n    \n         Line 25\n      in\n      f97fe71\n    \n    \n    \n    \n\n        \n          \n           default String dbUserToCreatorEmail(DbUser creator) {", "author": "calbach", "createdAt": "2020-05-06T21:43:12Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers\n+It's pretty tedious to write tests for generated code, as the computer is coding faster than you.\n+I still think it's worth it, because,\n+- it documents usage of your generated methods\n+- you catch things the compiler can't (such as when a string format changes)\n+- it's a good opportunity to update old test code\n+- It makes it look less magical\n+\n+### Consider other use cases\n+It's possible to write a mapper from a type to itself and use that as a copy constructor of sorts.\n+\n+### Tune the classes' public APIs\n+If you find yourself writing arcane helper methods, ask yourself if adding a simple setter or\n+getter on one of your classes would make the job easier and the generated code cleaner. Since our\n+model classes are generated, we frequently have to have external helper methods defined in either\n+the mapper class or a utility class.\n+\n+## Handling missing target properties\n+### Avoid `ignore = true` unless absolutely necessary\n+It's annoying to see warnings about missing target properties, and for good reason. The quick way to\n+stifle these is to use the `ignore` parameter, which tells MapStruct to elide the setter code for\n+that target property.\n+```java\n+@Mapping(target = \"billingAccountName\", ignore = true)\n+```\n+\n+While there are some places this is necessary, it should really be a last resort, for a couple of\n+reasons.\n+\n+First, we plan to use mappers to replace existing chunks of code in a clean way. We don't want to\n+have to docment that mapping function X leaves the created object in state Y with respect to fields\n+P, Q, and R. Many of our objects are relatively complex, and it's not obvious when looking at a call\n+to `fooMapper.toModel()` that the output model is incomplete in some way(s).\n+\n+Second, if a target property is difficuult to satisfy, this is a signal that either our class design\n+could be better, or we've left out a prereqisite.\n+\n+One strategy for avoiding unmatched target property is to add parameters to the method specifying\n+them. Then simply specify defaults for those at the call site as appropriate.\n+\n+If the type of the target property has a reasonable defalt (such as zero), and `null` isn't a valid\n+state for it, then using `NullValuePropertyMappingStrategy.SET_TO_DEFAULT` is an option.\n+\n+## Handling Default Values\n+### Handling database defalts\n+If the target class is a Hibernate model, and one or more fields have defaults\n+defined in the database schema, we do not want to overwrite that field with `null`\n+or any defauld value listed in the mapper's annotations. To get around this, we need\n+to set the `nullValuePropertyMappingStrategy` to `NullValuePropertyMappingStrategy.IGNORE`.\n+This prevents the MapStruct implementation from writing to the target property if the source is null.\n+```java\n+  @Mapping(\n+      source = \"workspace.billingStatus\",\n+      target = \"billingStatus\",\n+      nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)\n+```\n+Note that in this case I'm adding an annotation for a field that MapStruct was previously happy\n+to map implicitly to override its defalt behavior.\n+\n+### Specifying a non-default default\n+It's possible to set a default value in the `@Mapping` by\n+using `defaultValue`. This is rarely a good idea, as\n+either the constructor of the target class should be\n+doing this, or the application should specify it. It's mainly\n+useful for dealing with awkward legacy structure that you can't change.\n+\n+One place where this seems to be the least bad option is with\n+the read-only `etag` column in the `workspace` table:\n+```java\n+// Use default CDR version if null. There are really no other good options (i.e. a zero version is just wrong).\n+@Mapping(source = \"workspace.etag\", target = \"version\", qualifiedByName = \"etagToCdrVersion\", defaultValue = \"1\")\n+```\n+## Semi-advanced topics\n+\n+### Mapping to a subset of target properties\n+If you need to map from an object with sub-objects to a target type that's flat, there are two\n+stratgegies. The first is to use dot indexing in the `@Mapping` annotation, for example\n+`@Mapping(source = \"employee.contact.address\", target = \"address\")`. This works well, but the\n+generated code will look sloppy if you have to do this many times (e.g. for ResearchPurpose).\n+If you want to have the address member on the source accessed only once in the mapping (e.g. if it\n+involves some expensive calculation or network call), then it's better to have a separate method\n+using `@MappingTarget` on the target type. Something like the following may work\n+```java\n+default void setAddress(@MappingTarget DbEmployee dbEmployee, EmployeeModel employee) {\n+  dbEmployee.setAddress(employee.address);\n+}\n+```\n+\n+You could also elect to have a setter for this object on the target class itself, but then you may\n+lose some of the benefits of MapStruct's compile-time checking.\n+\n+Finally, note that this hierarchical mismatch may be a design smell.\n+\n+### Pulling in other mappers\n+The `uses` directive instructs MapStruct to look for candidates in external classes. We have one\n+class just for this purpose called `CommonMappers`. Additionally, classes exposing public static\n+methods, such as `DbStorageEnums` can be used to good effect.\n+\n+### Using the `@AfterMapping` annotation\n+Sometimes it's desirable to perform some fixup or post-mapping operations. While this should not be\n+common, it's a handy tool to have around. In the case of target types that are generated from\n+`swagger-codegen`, often the default constructor is lacking. For example it does not initialize\n+array members to empty arrays but leaves them as null. We can fix this with an appropriate\n+after mapping method that initializes those fields if they're not already.\n+\n+### Using DAOs", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEzNzQxMg==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r422137412", "bodyText": "I'll just remove this section as I have no experience. I know @ericsong mentioned this as one of the powerful features/advantages of the Spring component model version.\nDepending on  how much existing code could move to mappers, I agree that read-only use cases are safer, though I could see a convention someday where we do all our saving in @AfterMapping methods so we don't forget.", "author": "jaycarlton", "createdAt": "2020-05-08T13:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTExMDIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEyODYyOQ==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r421128629", "bodyText": "Future idea: It would be nice if these Java warning for missed properties could be asserted in a simple resuable test", "author": "calbach", "createdAt": "2020-05-06T22:27:32Z", "path": "api/docs/mapstruct.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# MapStruct Best Practices\n+## What is MapStruct?\n+[MapStruct](https://mapstruct.org/documentation/stable/reference/html/) is a Java code generator specializing in writing\n+conversion or mapping functions between an object instance and an instance of\n+a corresponding object in a class designed for another architectural tier, protocol, or technology.\n+It works mainly by matching types and names via reflection, or using programmer-provided\n+hints where that strategy isn't effective.\n+## Is this a gimmick? Why do I need it?\n+Everything MapStruct does is simple and deterministic, and every programmer has done it before. So why\n+bring in another library and codegen step? What's the advantage?\n+\n+First, by defining a mapper, you're adding some executable documentation to your types, and being\n+explicit about how they should map.\n+ \n+Second, you don't have to rely on developers to perform awkward null\n+checks for every field, as you get that for free. The generated code is very uniform and thus\n+quite readable.\n+\n+Third, and most important, is that once you've defined a mapper, maintenance is very easy. New fields\n+will simply be mapped for you (assuming they exist on both the source and the target type). If there's\n+a new target field that doesn't have a sourcce, youll gget a compile-time warning reminding you. (It's\n+important to stay on top of those). \n+\n+### Examples\n+Consider an `EmployeeModel` class:\n+```java\n+public class EmployeeModel {\n+  private String name;\n+  private Department department;\n+  private String address;\n+  private double salary;\n+\n+  public EmployeeModel() {\n+  }\n+\n+  public EmployeeModel(String name,\n+      Department department, String address, double salary) {\n+    this.name = name;\n+    this.department = department;\n+    this.address = address;\n+    this.salary = salary;\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  public Department getDepartment() {\n+    return department;\n+  }\n+  public void setDepartment(Department department) {\n+    this.department = department;\n+  }\n+\n+  public double getSalary() {\n+    return salary;\n+  }\n+  public void setSalary(double salary) {\n+    this.salary = salary;\n+  }\n+\n+  public double getWeeklySalary() {\n+    return getSalary() / 52.0;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+Additionally, we have a (nearly) corresponding entity in the database. (Hibernate bindings omitted.)\n+```java\n+// ORM details omitted.\n+public class EmployeeDbEntity {\n+\n+  private String firstName;\n+  private String lastName;\n+  private int departmentCode; // corresponds to enum\n+  private double hourlyRate;\n+  private String address;\n+\n+  public EmployeeDbEntity(String firstName, String lastName, int departmentCode, double hourlyRate,\n+      String address) {\n+    this.firstName = firstName;\n+    this.lastName = lastName;\n+    this.departmentCode = departmentCode;\n+    this.hourlyRate = hourlyRate;\n+    this.address = address;\n+  }\n+\n+  public String getFirstName() {\n+    return firstName;\n+  }\n+  public void setFirstName(String firstName) {\n+    this.firstName = firstName;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+  public void setDepartmentCode(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public double getHourlyRate() {\n+    return hourlyRate;\n+  }\n+  public void setHourlyRate(double hourlyRate) {\n+    this.hourlyRate = hourlyRate;\n+  }\n+\n+  public String getLastName() {\n+    return lastName;\n+  }\n+  public void setLastName(String lastName) {\n+    this.lastName = lastName;\n+  }\n+\n+  public String getAddress() {\n+    return address;\n+  }\n+  public void setAddress(String address) {\n+    this.address = address;\n+  }\n+}\n+```\n+\n+A naive first cut at a mapping function might look like this:\n+```java\n+import org.mapstruct.Mapper;\n+\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+}\n+```\n+\n+Using `./gradlew compileJava`, I see that this compiles, but gives warnings\n+```\n+examples/EmployeeMapper.java:8: warning: Unmapped target properties: \"name, department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+```\n+\n+So the good news is I've successfully generated a mapper. The bad news is that it's only one for\n+four properties.\n+```java\n+@Generated(\n+    value = \"org.mapstruct.ap.MappingProcessor\",\n+    date = \"2020-05-02T18:10:18-0400\",\n+    comments = \"version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_221 (Oracle Corporation)\"\n+)\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+To fix the name mapping we need to add a method to build a full name from first & last names. Let's pretend our\n+system didn't already have a good one, and add it directly in the mapper itself for brevity. To do\n+this, we need to create a `default` method on the interface, which is a relatively new facility in\n+Java to make life easier in this kind of situation.\n+\n+Our default method is itself another mapper, though you want to be careful when the source type of\n+such a mapper is a common type like String or Timestamp.\n+\n+```java\n+@Mapper\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toName(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+On compiling this, we have a shorter error message:\n+```\n+EmployeeMapper.java:11: warning: Unmapped target properties: \"department, salary\".\n+```\n+\n+Our generated implementation class now looks like this:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toName( employeeDbEntity ) ); // <-- our default mapper method\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+If you're following along, notice that MapStruct is being clever here, but not too clever\n+(by design). Since our `EmployeeDbEntity` class doesn't have an attribute named `name`\n+(or a `getName()` method), it doesn't just grab any String property from that class and hope for the\n+best. We had to tell it in a `@Mapping` annotation that it can in fact get a `String` called \"name\" from this\n+`employeeDbEntity` if it looks a little harder.\n+\n+Since our default method takes in the entity and returns a string, this is a good candidate, and\n+that's what it uses.\n+\n+What if we hadn't named it `toName()`? I tried that just now and the answer was slightly surprising:\n+it generated a line like `employeeModel.setName( toNickname( employeeDbEntity ) );`. I, for one,\n+welcome our new automatically programmed overlords.\n+\n+We have two more properties to fix: the enum `department`, and the `double salary`. Let's start with\n+the enum. It's class definition looks like this:\n+```java\n+public enum Department {\n+  SALES(0),\n+  MARKETING(1),\n+  IT(2);\n+\n+  private int departmentCode;\n+\n+  Department(int departmentCode) {\n+    this.departmentCode = departmentCode;\n+  }\n+\n+  public int getDepartmentCode() {\n+    return departmentCode;\n+  }\n+\n+  public static Department fromDepartmentCode(int code) {\n+    switch(code) {\n+      case 0:\n+        return SALES;\n+      case 1:\n+        return MARKETING;\n+      case 2:\n+        return IT;\n+      default:\n+        return SALES; // they never know their code, so probably them\n+    }\n+  }\n+}\n+```\n+\n+I thought I'd be clever and just pull in the enum type via a `uses` directive at the top of the mapper:\n+```java\n+@Mapper(uses = Department.class)\n+```\n+This did exactly the wrong thing. It generated the class without errors, but then failed to compile:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final Department department = new Department();\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = department.clone();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+New errors:\n+```\n+> Task :compileJava \n+/Users/jaycarlton/repos/workbench/api/src/main/java/org/pmiops/workbench/utils/mappers/examples/EmployeeMapper.java:10: warning: Unmapped target properties: \"department, salary\".\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:12: error: enum types may not be instantiated\n+    private final Department department = new Department();\n+                                          ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: clone() has protected access in Enum\n+        EmployeeModel employeeModel = department.clone();\n+                                                ^\n+/Users/jaycarlton/repos/workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/mappers/examples/EmployeeMapperImpl.java:20: error: incompatible types: Object cannot be converted to EmployeeModel\n+        EmployeeModel employeeModel = department.clone();\n+                                                      ^\n+```\n+\n+Fine, we can do it the less slick but more reliable way:\n+\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+}\n+```\n+\n+where the new `SampleEnumMapper` looks like:\n+```java\n+@Mapper\n+public interface SampleEnumMapper {\n+  default Department toDepartment(int departmentCode) {\n+    return Department.fromDepartmentCode(departmentCode);\n+  }\n+}\n+```\n+\n+I'm sure there's a way to do this without creating another mapper class. Anyway, this gives us \n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+Our `@Mapping` instruction let MapStruct know which source property (an int) to match to the target\n+property (`Department`). There was only one such method, so it was selected.\n+\n+To see what happens when there's ambiguity, add another method to `SampleEnumMapper`:\n+```java\n+  default Department anotherOne(int anInt) {\n+    return Department.SALES;\n+  }\n+```\n+\n+This gives us a helpful, if verbose error message and breaks the build. I've stripped the packages\n+and full paths for clarity:\n+```\n+> Task :compileJava \n+examples/EmployeeMapper.java:11: error: Ambiguous mapping methods found for mapping property \n+\"int departmentCode\" to Department: \n+  Department SampleEnumMapper.toDepartment(int departmentCode),\n+  Department SampleEnumMapper.anotherOne(int anInt).\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+```\n+\n+\n+Finally, for the salary mapping, we need to do real math. The database stores an hourly rate as a\n+double (never do this), and the API exposes an annual salary. We assume 2000.0 hours in a work year.\n+\n+We can do this via a simple method `toAnnualSalary()`\n+```java\n+@Mapper(uses = SampleEnumMapper.class)\n+public interface EmployeeMapper {\n+\n+  double HOURS_IN_YEAR = 2000.0;\n+\n+  @Mapping(source = \"employeeDbEntity\", target = \"name\")\n+  @Mapping(source = \"employeeDbEntity.departmentCode\", target = \"department\")\n+  @Mapping(source = \"employeeDbEntity.hourlyRate\", target = \"salary\")\n+  EmployeeModel toModel(EmployeeDbEntity employeeDbEntity);\n+\n+  default String toNickname(EmployeeDbEntity employeeDbEntity) {\n+    return String.format(\"%s %s\", employeeDbEntity.getFirstName(), employeeDbEntity.getLastName());\n+  }\n+\n+  default double toAnnalSalary(double hourlyRate) {\n+    return hourlyRate * HOURS_IN_YEAR;\n+  }\n+}\n+```\n+\n+This compiles with no warnings, and our mapper implementation is now:\n+```java\n+public class EmployeeMapperImpl implements EmployeeMapper {\n+\n+    private final SampleEnumMapper sampleEnumMapper = Mappers.getMapper( SampleEnumMapper.class );\n+\n+    @Override\n+    public EmployeeModel toModel(EmployeeDbEntity employeeDbEntity) {\n+        if ( employeeDbEntity == null ) {\n+            return null;\n+        }\n+\n+        EmployeeModel employeeModel = new EmployeeModel();\n+\n+        employeeModel.setName( toNickname( employeeDbEntity ) );\n+        employeeModel.setDepartment( sampleEnumMapper.toDepartment( employeeDbEntity.getDepartmentCode() ) );\n+        employeeModel.setSalary( toAnnalSalary( employeeDbEntity.getHourlyRate() ) );\n+        employeeModel.setAddress( employeeDbEntity.getAddress() );\n+\n+        return employeeModel;\n+    }\n+}\n+```\n+\n+### Testing\n+It's pretty easy to add a test class for the mapper. Here's a basic test case for the happy path.\n+If your input class has any nullable parameters or fields on those parameters, or there are any other\n+edge cases, you'd want to test those as well.\n+```java\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.utils.mappers.examples.Department;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeDbEntity;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapper;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeMapperImpl;\n+import org.pmiops.workbench.utils.mappers.examples.EmployeeModel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class EmployeeMapperTest {\n+\n+  public static final String ADDRESS = \"123 Sesame Street\";\n+  @Autowired private EmployeeMapper employeeMapper;\n+\n+  @TestConfiguration\n+  @Import({EmployeeMapperImpl.class})\n+  static class Configuration {}\n+\n+  @Test\n+  public void testToModel() {\n+    final EmployeeDbEntity employeeDbEntity = new EmployeeDbEntity(\"John\", \"Doe\", 2, 3.00, ADDRESS);\n+\n+    final EmployeeModel employeeModel = employeeMapper.toModel(employeeDbEntity);\n+    assertThat(employeeModel.getDepartment()).isEqualTo(Department.IT);\n+    assertThat(employeeModel.getSalary()).isWithin(1.0e-6).of(6000.0);\n+    assertThat(employeeModel.getName()).isEqualTo(\"John Doe\");\n+    assertThat(employeeModel.getAddress()).isEqualTo(ADDRESS);\n+  }\n+}\n+```\n+## Tips & Strategies\n+\n+### Stub it so it builds, and go one property at a time\n+For big target classes, put in some temporary `ignore` statements or other hacks just to get it\n+to the point that it generates the implemmentation class and actually compiles without errors. Then\n+proceed one property at a time until all the warnings are gone.\n+ \n+### Proofread the generated code\n+First, you should *always* look at the generated code and step through it in the debugger. This is\n+because, while the codegen should be deterministic, most of us don't go around with its order of\n+operator precedence in our head. Particularly if you have many input parameters with multiple fields\n+with common names, you may find that `foo.id` is getting used instead of `bar.id` becase one's a \n+`long` and the other an `int`. Or something. \n+\n+In general, the library gives very reasonable error\n+messages and is very cranky at compile time. This is A Good Thing.\n+\n+## Write tests for mappers", "originalCommit": "84460942f76b953a05feded4ecc46f5575753e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5OTAzNw==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r421899037", "bodyText": "Even better, we can set up a @MapperConfig class and set the unmappedTargetPolicy on it globally to ERROR (as well as specify Spring and a couple other things that are tedious to set everywhere, like the null source policy.\nFiled https://precisionmedicineinitiative.atlassian.net/browse/RW-4926", "author": "jaycarlton", "createdAt": "2020-05-08T02:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEyODYyOQ=="}], "type": "inlineReview"}, {"oid": "5b3cdb18aa025095d7651a86a6c15e8c297990e1", "url": "https://github.com/all-of-us/workbench/commit/5b3cdb18aa025095d7651a86a6c15e8c297990e1", "message": "add to introl", "committedDate": "2020-05-07T16:19:31Z", "type": "commit"}, {"oid": "ba428cf22805705681258efb8fe37fec6254b89e", "url": "https://github.com/all-of-us/workbench/commit/ba428cf22805705681258efb8fe37fec6254b89e", "message": "Merge branch 'master' into jaycarlton/mapstructBestPractices", "committedDate": "2020-05-07T21:36:49Z", "type": "commit"}, {"oid": "966549317f1dd1118581042f132eb20372970761", "url": "https://github.com/all-of-us/workbench/commit/966549317f1dd1118581042f132eb20372970761", "message": "progress [skip ci]", "committedDate": "2020-05-08T02:24:06Z", "type": "commit"}, {"oid": "593ff43defa7dfcc15c1a915d1d4024e6449ba91", "url": "https://github.com/all-of-us/workbench/commit/593ff43defa7dfcc15c1a915d1d4024e6449ba91", "message": "progress", "committedDate": "2020-05-08T13:22:26Z", "type": "commit"}, {"oid": "4d876497eea125cd35a6d28e7c226fe0135d795a", "url": "https://github.com/all-of-us/workbench/commit/4d876497eea125cd35a6d28e7c226fe0135d795a", "message": "progress [skip ci]", "committedDate": "2020-05-08T13:24:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI3NDg3OA==", "url": "https://github.com/all-of-us/workbench/pull/3529#discussion_r422274878", "bodyText": "currently", "author": "calbach", "createdAt": "2020-05-08T17:36:46Z", "path": "README.md", "diffHunk": "@@ -1,11 +1,23 @@\n # Workbench\n+CircleCI Test Status [![CircleCI Build Status](https://circleci.com/gh/all-of-us/workbench.svg)](https://circleci.com/gh/all-of-us/workflows/workbench)\n \n-[![CircleCI Build Status](https://circleci.com/gh/all-of-us/workbench.svg)](https://circleci.com/gh/all-of-us/workflows/workbench)\n+## Introduction\n+The [All of Us Research Program](https://allofus.nih.gov/) Researcher Workbench is a platform for researchers to work with program\n+data in a secure and convenient way. It provides users with an environment for running Jupyter notebooks\n+in R or Python that can access data in the program's Curated Data Repository. For information on research\n+opportunities see the [official website](https://allofus.nih.gov/get-involved/opportunities-researchers).\n \n-[Documentation on API Structure](https://github.com/all-of-us/workbench/blob/master/api/doc/code-structure.md)\n+While the code in this repository is available according to the terms of our  [licence](LICENSE.txt), not all features\n+are available for external use. In particular, it's not crrenlty possible for third parties to build and", "originalCommit": "4d876497eea125cd35a6d28e7c226fe0135d795a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}