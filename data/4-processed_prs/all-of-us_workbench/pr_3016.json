{"pr_number": 3016, "pr_title": "[RW-2840][risk=low] Support delegated user credentials without private keys", "pr_createdAt": "2020-01-21T13:37:21Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3016", "timeline": [{"oid": "ea56a316832784144b5461b858d2312f1b5dc469", "url": "https://github.com/all-of-us/workbench/commit/ea56a316832784144b5461b858d2312f1b5dc469", "message": "Get integration tests into working shape.", "committedDate": "2020-01-21T02:34:29Z", "type": "commit"}, {"oid": "342fdcd8a1c58db1d65f1e628e77f324e42357fe", "url": "https://github.com/all-of-us/workbench/commit/342fdcd8a1c58db1d65f1e628e77f324e42357fe", "message": "Simplify some of the integration test config and remove unused WorkbenchEnvironment.", "committedDate": "2020-01-21T02:35:33Z", "type": "commit"}, {"oid": "927b454c5959dea89d05f49edf85b88c92c30104", "url": "https://github.com/all-of-us/workbench/commit/927b454c5959dea89d05f49edf85b88c92c30104", "message": "Fix command-line tools.", "committedDate": "2020-01-21T02:37:58Z", "type": "commit"}, {"oid": "43e25c4e288762e28576fc992f77dd71a08e0073", "url": "https://github.com/all-of-us/workbench/commit/43e25c4e288762e28576fc992f77dd71a08e0073", "message": "Formatting fixes.", "committedDate": "2020-01-21T02:38:58Z", "type": "commit"}, {"oid": "abecff4b0b037d5cca1f34b37f6c53bbb43c19bb", "url": "https://github.com/all-of-us/workbench/commit/abecff4b0b037d5cca1f34b37f6c53bbb43c19bb", "message": "Create a DelegatedUserCredentials class and migrate all usage away from GCS-stored keys.", "committedDate": "2020-01-21T02:43:14Z", "type": "commit"}, {"oid": "caf2da08cd3aafe9d57858faf3a9930f2189084c", "url": "https://github.com/all-of-us/workbench/commit/caf2da08cd3aafe9d57858faf3a9930f2189084c", "message": "Bring back GCS-stored key code and add feature flag to toggle between key and keyless usage.", "committedDate": "2020-01-21T02:48:15Z", "type": "commit"}, {"oid": "ea4ed6d5b91ad7b3edac60b80239ac66d0d282e4", "url": "https://github.com/all-of-us/workbench/commit/ea4ed6d5b91ad7b3edac60b80239ac66d0d282e4", "message": "Tweak things a bit so DirectoryService is only instantiated from within a request context; this fixes the local API smoke tests.", "committedDate": "2020-01-21T02:48:32Z", "type": "commit"}, {"oid": "f6caf847786cb2e83dede4690911eadd1e86c911", "url": "https://github.com/all-of-us/workbench/commit/f6caf847786cb2e83dede4690911eadd1e86c911", "message": "Add unit tests for DelegatedUserCredentials", "committedDate": "2020-01-21T02:48:32Z", "type": "commit"}, {"oid": "a78ec749808a2c21c38a5379837341f539919cd6", "url": "https://github.com/all-of-us/workbench/commit/a78ec749808a2c21c38a5379837341f539919cd6", "message": "Fix rebase error.", "committedDate": "2020-01-21T02:50:35Z", "type": "commit"}, {"oid": "165e591708f0837063c065e46d33a5e5ba696b0c", "url": "https://github.com/all-of-us/workbench/commit/165e591708f0837063c065e46d33a5e5ba696b0c", "message": "Doc and formatting fixes.", "committedDate": "2020-01-21T13:09:57Z", "type": "commit"}, {"oid": "fb262760de52015bbc193d3d304bc15d6ee972cd", "url": "https://github.com/all-of-us/workbench/commit/fb262760de52015bbc193d3d304bc15d6ee972cd", "message": "Spotless format fixes.", "committedDate": "2020-01-21T13:13:22Z", "type": "commit"}, {"oid": "1c66db8856cc54f7fd3546aa94b196d26c5f659b", "url": "https://github.com/all-of-us/workbench/commit/1c66db8856cc54f7fd3546aa94b196d26c5f659b", "message": "Remove unintended Gradle build file change.", "committedDate": "2020-01-21T13:38:15Z", "type": "commit"}, {"oid": "018cc9d1824035e69cd9eee74d72c34b2be5fd3c", "url": "https://github.com/all-of-us/workbench/commit/018cc9d1824035e69cd9eee74d72c34b2be5fd3c", "message": "Revert a couple unintended rebase errors.", "committedDate": "2020-01-21T13:41:20Z", "type": "commit"}, {"oid": "299bf5e62068d7e4b4e1c8e90af9e2346c9c7ef6", "url": "https://github.com/all-of-us/workbench/commit/299bf5e62068d7e4b4e1c8e90af9e2346c9c7ef6", "message": "Spotless formatting.", "committedDate": "2020-01-21T13:41:32Z", "type": "commit"}, {"oid": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "url": "https://github.com/all-of-us/workbench/commit/3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "message": "Add a couple test comments and remove an unnecessary instance var.", "committedDate": "2020-01-21T13:52:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNTczOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369105738", "bodyText": "Could we rename ImpersonatedCredentials ImpersonatedServiceCredentials to make this more obvious?", "author": "jaycarlton", "createdAt": "2020-01-21T16:27:32Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2Mjc0Mw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369362743", "bodyText": "Unfortunately not \u2013\u00a0ImpersonatedCredentials is from the Google-provided oauth2 library. I agree, the naming is confusing.", "author": "gjuggler", "createdAt": "2020-01-22T04:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNjA1Mg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369106052", "bodyText": "Is this just a GAE feature?", "author": "jaycarlton", "createdAt": "2020-01-21T16:28:03Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MjkxNQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369362915", "bodyText": "It's common to all Google API clients: https://cloud.google.com/docs/authentication/production#finding_credentials_automatically", "author": "gjuggler", "createdAt": "2020-01-22T04:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwNjA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwOTczMA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369109730", "bodyText": "why is the directory named service?", "author": "jaycarlton", "createdAt": "2020-01-21T16:34:00Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MzI3MA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369363270", "bodyText": "Fair point \u2013\u00a0changed.", "author": "gjuggler", "createdAt": "2020-01-22T04:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEwOTczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjA3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369142075", "bodyText": "nit: you can use Optional.ofNullable(client).orElseGet(IamCredentialsClient::create);", "author": "jaycarlton", "createdAt": "2020-01-21T17:32:47Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createClaims() {\n+    JsonWebToken.Payload payload = new JsonWebToken.Payload();\n+    payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n+    payload.setExpirationTimeSeconds(\n+        Instant.now().getEpochSecond() + ACCESS_TOKEN_DURATION.getSeconds());\n+    payload.setAudience(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    payload.setIssuer(this.serviceAccountEmail);\n+    payload.setSubject(this.userEmail);\n+    payload.set(\"scope\", String.join(\" \", this.scopes));\n+    return payload;\n+  }\n+\n+  @Override\n+  public AccessToken refreshAccessToken() throws IOException {\n+    // The first step is to call the IamCredentials API to generate a signed JWT with the\n+    // appropriate claims. This call is authorized with application default credentials (ADCs). The\n+    // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n+    // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n+    JsonWebToken.Payload payload = createClaims();\n+\n+    if (client == null) {", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NDE4Mw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369364183", "bodyText": "Personally I find the if-else more readable.", "author": "gjuggler", "createdAt": "2020-01-22T04:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjY5OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369622698", "bodyText": "The root issue for me here is having a nullable field to begin with. Instead of accessing the private client directly, you could have a private Optional< IamCredentialsClient > get IamCredentialsClient(). so it's just getClient().orElseGet(...) here. Or even do the default inside the accessor.\nI like the closely packed style because someone maintaining the code later will be less likely to just stick something in one of the branches without updating all the other places.", "author": "jaycarlton", "createdAt": "2020-01-22T15:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjYyOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369142628", "bodyText": "FWIW, you could put this a Spring configuration and inject Provider<AccessToken>", "author": "jaycarlton", "createdAt": "2020-01-21T17:34:03Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createClaims() {\n+    JsonWebToken.Payload payload = new JsonWebToken.Payload();\n+    payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n+    payload.setExpirationTimeSeconds(\n+        Instant.now().getEpochSecond() + ACCESS_TOKEN_DURATION.getSeconds());\n+    payload.setAudience(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    payload.setIssuer(this.serviceAccountEmail);\n+    payload.setSubject(this.userEmail);\n+    payload.set(\"scope\", String.join(\" \", this.scopes));\n+    return payload;\n+  }\n+\n+  @Override\n+  public AccessToken refreshAccessToken() throws IOException {", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NDAxMA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369364010", "bodyText": "That wouldn't work \u2013\u00a0this is an override of a method from the Google-provided OAuth2Credentials module (code).\nThis is the crux of why migrating to the newer GoogleCredentials package was a pre-requisite for this task: it allowed for seamless integration with Google's existing machinery by leveraging this hook for credential-generating subclasses.", "author": "gjuggler", "createdAt": "2020-01-22T04:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MjYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MzUxOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369143518", "bodyText": "nit: I was looking for a simpler way to do this, and the Calendar class might be one way. https://stackoverflow.com/a/1655450/12345554", "author": "jaycarlton", "createdAt": "2020-01-21T17:35:53Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createClaims() {\n+    JsonWebToken.Payload payload = new JsonWebToken.Payload();\n+    payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n+    payload.setExpirationTimeSeconds(\n+        Instant.now().getEpochSecond() + ACCESS_TOKEN_DURATION.getSeconds());\n+    payload.setAudience(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    payload.setIssuer(this.serviceAccountEmail);\n+    payload.setSubject(this.userEmail);\n+    payload.set(\"scope\", String.join(\" \", this.scopes));\n+    return payload;\n+  }\n+\n+  @Override\n+  public AccessToken refreshAccessToken() throws IOException {\n+    // The first step is to call the IamCredentials API to generate a signed JWT with the\n+    // appropriate claims. This call is authorized with application default credentials (ADCs). The\n+    // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n+    // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n+    JsonWebToken.Payload payload = createClaims();\n+\n+    if (client == null) {\n+      client = IamCredentialsClient.create();\n+    }\n+    SignJwtRequest jwtRequest =\n+        SignJwtRequest.newBuilder()\n+            .setName(String.format(SERVICE_ACCOUNT_NAME_FORMAT, serviceAccountEmail))\n+            .setPayload(JSON_FACTORY.toString(payload))\n+            .build();\n+    String jwt = client.signJwt(jwtRequest).getSignedJwt();\n+\n+    // With the signed JWT in hand, we call Google's OAuth2 token server to exchange the JWT for\n+    // an access token.\n+    if (httpTransport == null) {\n+      httpTransport = new NetHttpTransport();\n+    }\n+    TokenRequest tokenRequest =\n+        new TokenRequest(\n+            httpTransport,\n+            JSON_FACTORY,\n+            new GenericUrl(GoogleOAuthConstants.TOKEN_SERVER_URL),\n+            JWT_BEARER_GRANT_TYPE);\n+    tokenRequest.put(\"assertion\", jwt);\n+    TokenResponse tokenResponse = tokenRequest.execute();\n+    return new AccessToken(\n+        tokenResponse.getAccessToken(),\n+        Date.from(Instant.now().plusSeconds(tokenResponse.getExpiresInSeconds())));", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NTA3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369365071", "bodyText": "This is the best I could manage with Calendar:\nCalendar calendar = Calendar.getInstance(); // no fluent API\ncalendar.add(Math.toIntExact(tokenResponse.getExpiresInSeconds()), Calendar.SECOND); // calendar.add only supports integer arguments\ncalendar.getTime(); // Returns Date instance\nInstant seems like the best option here.", "author": "gjuggler", "createdAt": "2020-01-22T04:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NDI3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369144271", "bodyText": "I'm not used to seeing the WorkbenchConfig passed int like this FWIW. I kinda feel like this should just take in the service account name and the project ID directly.", "author": "jaycarlton", "createdAt": "2020-01-21T17:37:30Z", "path": "api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java", "diffHunk": "@@ -66,25 +69,9 @@ public static String getScopedServiceAccessToken(List<String> scopes) throws IOE\n     return scopedCreds.getAccessToken().getTokenValue();\n   }\n \n-  /**\n-   * Converts a service account Google credential into credentials for impersonating an end user.\n-   * This method assumes that the given service account has been enabled for domain-wide delegation,\n-   * and the given set of scopes have been included in the GSuite admin panel.\n-   *\n-   * <p>See docs/domain-delegation.md for more details.\n-   *\n-   * @param originalCredentials\n-   * @param userEmail Email address of the user to impersonate.\n-   * @param scopes The list of Google / OAuth API scopes to be authorized for.\n-   * @return\n-   * @throws IOException\n-   */\n-  public static GoogleCredentials getImpersonatedCredentials(\n-      GoogleCredentials originalCredentials, String userEmail, List<String> scopes)\n-      throws IOException {\n-    GoogleCredentials impersonatedCreds =\n-        originalCredentials.createScoped(scopes).createDelegated(userEmail);\n-    impersonatedCreds.refresh();\n-    return impersonatedCreds;\n+  public static String getServiceAccountEmail(\n+      String serviceAccountName, WorkbenchConfig workbenchConfig) {", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NjM2NA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369366364", "bodyText": "Sounds reasonable \u2013 done.\nUltimately, this kind of thing feels like it might naturally belong as a method on the WorkbenchConfig object itself. Similar to the Cloud Task / App Engine location methods we recently added... I wonder if it wouldn't be heresy to start adding some basic bits of read-only logic to that data class.", "author": "gjuggler", "createdAt": "2020-01-22T04:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NDI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NTg1OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369145858", "bodyText": "nit: make delegatedCreds final so that anyone fiddling with the logic below doesn't forget to initialize it.\nCan we split this function into on that gets delegated credentials and another that gets the Firecloud API client? I kinda wonder if the first function would belong in this service.", "author": "jaycarlton", "createdAt": "2020-01-21T17:40:54Z", "path": "api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java", "diffHunk": "@@ -132,14 +133,24 @@ public FireCloudServiceImpl(\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    // Load credentials for the firecloud-admin Service Account. This account has been granted\n-    // domain-wide delegation for the OAuth scopes required by FireCloud.\n-    GoogleCredentials impersonatedUserCredentials =\n-        ServiceAccounts.getImpersonatedCredentials(\n-            fcAdminCredsProvider.get(), userEmail, FIRECLOUD_API_OAUTH_SCOPES);\n+    OAuth2Credentials delegatedCreds;", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NzA5MA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369367090", "bodyText": "Added final. I don't think splitting this method into two 3-line methods will provide a meaningful benefit.", "author": "gjuggler", "createdAt": "2020-01-22T04:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NjQ5OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369146498", "bodyText": "FWIW this could also be provided by spring configuration methods: one to give you up-to-date delegated credentials and another to give the firecloud API. Both would need to be prototype scope I think.", "author": "jaycarlton", "createdAt": "2020-01-21T17:42:20Z", "path": "api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java", "diffHunk": "@@ -132,14 +133,24 @@ public FireCloudServiceImpl(\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    // Load credentials for the firecloud-admin Service Account. This account has been granted\n-    // domain-wide delegation for the OAuth scopes required by FireCloud.\n-    GoogleCredentials impersonatedUserCredentials =\n-        ServiceAccounts.getImpersonatedCredentials(\n-            fcAdminCredsProvider.get(), userEmail, FIRECLOUD_API_OAUTH_SCOPES);\n+    OAuth2Credentials delegatedCreds;\n+    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n+      delegatedCreds =\n+          new DelegatedUserCredentials(\n+              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),\n+              userEmail,\n+              FIRECLOUD_API_OAUTH_SCOPES);\n+    } else {\n+      delegatedCreds =\n+          fcAdminCredsProvider\n+              .get()\n+              .createScoped(FIRECLOUD_API_OAUTH_SCOPES)\n+              .createDelegated(userEmail);\n+    }\n+    delegatedCreds.refreshIfExpired();", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2ODg5Ng==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369368896", "bodyText": "What benefit would that give us? My instinct is to try and only add configuration when it's immediately needed, or plausibly required in the near term.\n(More pragmatically, I'm trying to be fairly surgical in these PRs to avoid adding unnecessary outage or rollback risk to the roll-out of this feature.)", "author": "gjuggler", "createdAt": "2020-01-22T04:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0NjQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0OTQ4NQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369149485", "bodyText": "nit: If these two methods will live side-by-side, you might want to have an enum like ImpersonationOptions.DELEGATE and pass that into the function. if this branch is going away after the gate is removed, then it's not important.", "author": "jaycarlton", "createdAt": "2020-01-21T17:48:40Z", "path": "api/src/main/java/org/pmiops/workbench/google/CloudResourceManagerServiceImpl.java", "diffHunk": "@@ -28,32 +30,41 @@\n   public static final List<String> SCOPES =\n       Arrays.asList(CloudResourceManagerScopes.CLOUD_PLATFORM_READ_ONLY);\n \n-  private final Provider<ServiceAccountCredentials> cloudResourceManagerAdminCredsProvider;\n+  private final Provider<ServiceAccountCredentials> credentialsProvider;\n+  private final Provider<WorkbenchConfig> configProvider;\n   private final HttpTransport httpTransport;\n   private final GoogleRetryHandler retryHandler;\n \n   @Autowired\n   public CloudResourceManagerServiceImpl(\n       @Qualifier(Constants.CLOUD_RESOURCE_MANAGER_ADMIN_CREDS)\n-          Provider<ServiceAccountCredentials> cloudResourceManagerAdminCredsProvider,\n+          Provider<ServiceAccountCredentials> credentialsProvider,\n+      Provider<WorkbenchConfig> configProvider,\n       HttpTransport httpTransport,\n       GoogleRetryHandler retryHandler) {\n-    this.cloudResourceManagerAdminCredsProvider = cloudResourceManagerAdminCredsProvider;\n+    this.credentialsProvider = credentialsProvider;\n+    this.configProvider = configProvider;\n     this.httpTransport = httpTransport;\n     this.retryHandler = retryHandler;\n   }\n \n   private CloudResourceManager getCloudResourceManagerServiceWithImpersonation(DbUser user)\n       throws IOException {\n-    // Load credentials for the cloud-resource-manager Service Account. This account has been\n-    // granted\n-    // domain-wide delegation for the OAuth scopes required by cloud apis.\n-    GoogleCredentials credentials =\n-        ServiceAccounts.getImpersonatedCredentials(\n-            cloudResourceManagerAdminCredsProvider.get(), user.getUsername(), SCOPES);\n+    OAuth2Credentials delegatedCreds;\n+    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n+      delegatedCreds =\n+          new DelegatedUserCredentials(\n+              ServiceAccounts.getServiceAccountEmail(\"cloud-resource-admin\", configProvider.get()),\n+              user.getUsername(),\n+              SCOPES);\n+    } else {\n+      delegatedCreds =", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2OTIxNQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369369215", "bodyText": "The branch will go away once the rollout is complete and feature flag gets torn down.", "author": "gjuggler", "createdAt": "2020-01-22T04:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0OTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0OTgyNA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369149824", "bodyText": "nit: final", "author": "jaycarlton", "createdAt": "2020-01-21T17:49:21Z", "path": "api/src/main/java/org/pmiops/workbench/google/DirectoryServiceImpl.java", "diffHunk": "@@ -87,25 +88,24 @@ public DirectoryServiceImpl(\n     this.retryHandler = retryHandler;\n   }\n \n-  private GoogleCredentials createCredentialWithImpersonation() throws IOException {\n-    String gSuiteDomain = configProvider.get().googleDirectoryService.gSuiteDomain;\n-    return ServiceAccounts.getImpersonatedCredentials(\n-        googleCredentialsProvider.get(), \"directory-service@\" + gSuiteDomain, SCOPES);\n-  }\n+  private Directory getGoogleDirectoryService() {\n+    OAuth2Credentials delegatedCreds;", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2OTc2OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369369768", "bodyText": "Done", "author": "gjuggler", "createdAt": "2020-01-22T04:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0OTgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1MDM1NA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369150354", "bodyText": "nit: you could argue for putting this into a test resource file", "author": "jaycarlton", "createdAt": "2020-01-21T17:50:29Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.pmiops.workbench.auth;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.googleapis.testing.auth.oauth2.MockTokenServerTransport;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebSignature;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.api.client.util.PemReader;\n+import com.google.api.client.util.SecurityUtils;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.cloud.iam.credentials.v1.SignJwtResponse;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class DelegatedUserCredentialsTest {\n+\n+  static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n+  static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n+  static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+\n+  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  // A random private key string generated for testing purposed with the following commands:\n+  // $ openssl genrsa -out keypair.pem 512\n+  // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n+  static final String SA_PRIVATE_KEY_PKCS8 =", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2OTg3Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369369877", "bodyText": "Could do, but Google's own tests include similar strings inline, so I felt following that pattern was warranted.", "author": "gjuggler", "createdAt": "2020-01-22T04:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1MDM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1MDgyNw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369150827", "bodyText": "I'd spell this out. On reading the first time it's hard to keep up with the context.", "author": "jaycarlton", "createdAt": "2020-01-21T17:51:25Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.pmiops.workbench.auth;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.googleapis.testing.auth.oauth2.MockTokenServerTransport;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebSignature;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.api.client.util.PemReader;\n+import com.google.api.client.util.SecurityUtils;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.cloud.iam.credentials.v1.SignJwtResponse;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class DelegatedUserCredentialsTest {\n+\n+  static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n+  static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n+  static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+\n+  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  // A random private key string generated for testing purposed with the following commands:\n+  // $ openssl genrsa -out keypair.pem 512\n+  // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n+  static final String SA_PRIVATE_KEY_PKCS8 =\n+      \"-----BEGIN PRIVATE KEY-----\\n\"\n+          + \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA04/ClUlp9Y1HEOPe\\n\"\n+          + \"2FGpSkkSkR94c2JD1Wet2qyVvXLlCBqQyTYtJugSaBWNSDe/M+6astFrWLOSZU2o\\n\"\n+          + \"OVK1AwIDAQABAkEAwQQX8zvXgEA05iP/3Dwkx7GDTwP3UM4GNV0yMJ/kvcG8lTzh\\n\"\n+          + \"/WpVThpktn5roeoiwOcQP3jbGbUTlGw2JJYVAQIhAO2jAKAoqoBIiEimrES0eery\\n\"\n+          + \"8aVmJEu+LzO2+ZgjNRZJAiEA4+juaKu6PxbBHtV4NVN1viX0mIRUxr4jcrZGlz3d\\n\"\n+          + \"QOsCIFRCxggEI2DVVy2bm93IuKosdq6VJy2MRCRsLthZM4uxAiB0A/HApJJFZT7f\\n\"\n+          + \"hEkR1C9eoRGWxd4l4UpILZNXj+1eCwIgZOwMPzJi5thQysHlvf0cqBO/7tv2fd6K\\n\"\n+          + \"qzJzcrNQfMs=\\n\"\n+          + \"-----END PRIVATE KEY-----\";\n+\n+  // We'll handle mocking out the call to the IAM Credentials API.\n+  @Mock private IamCredentialsClient mockIamCredentialsClient;\n+  // Google's API client library provides a convenient mock for their token server API,\n+  // so we'll use that to mock out the call to request an access token.\n+  private MockTokenServerTransport mockTokenServerTransport;\n+  private DelegatedUserCredentials creds;", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2OTk5OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369369998", "bodyText": "Done", "author": "gjuggler", "createdAt": "2020-01-22T04:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1MDgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NDU4Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369154587", "bodyText": "Do you want scopes to be writeable? If not, I'd do Collections.emptyList()", "author": "jaycarlton", "createdAt": "2020-01-21T17:58:56Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MzM2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369363367", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-22T04:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NDU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NTA1NQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369155055", "bodyText": "nit: The name of the function doesn't suggest to me the type. Maybe createClaimsJwt()?", "author": "jaycarlton", "createdAt": "2020-01-21T17:59:54Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createClaims() {", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MzY1OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369363658", "bodyText": "Good catch \u2013\u00a0I'll go with createJwtPayload for even more alignment.", "author": "gjuggler", "createdAt": "2020-01-22T04:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NzcyMw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369157723", "bodyText": "These comments are great. It might help to have a readme going over the different auth types we have and in what situations we should use each one.", "author": "jaycarlton", "createdAt": "2020-01-21T18:05:34Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory service = new Directory.Builder(new NetHttpTransport(), new JacksonFactory(), null)\n+ *     .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *     .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = new ArrayList<>();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2MzUzNQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369363535", "bodyText": "I agree some system overview docs are long overdue, but I won't bite that off for this PR.", "author": "gjuggler", "createdAt": "2020-01-22T04:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1NzcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1ODM5OQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369158399", "bodyText": "I feel like the user name should be configured in the JSON, even though we don't expect it to change. IOW someone else who finds this class on github would have to change that, so it doesn't feel like it should live in code.", "author": "jaycarlton", "createdAt": "2020-01-21T18:07:03Z", "path": "api/src/main/java/org/pmiops/workbench/firecloud/FireCloudServiceImpl.java", "diffHunk": "@@ -132,14 +133,24 @@ public FireCloudServiceImpl(\n    * @return\n    */\n   public ApiClient getApiClientWithImpersonation(String userEmail) throws IOException {\n-    // Load credentials for the firecloud-admin Service Account. This account has been granted\n-    // domain-wide delegation for the OAuth scopes required by FireCloud.\n-    GoogleCredentials impersonatedUserCredentials =\n-        ServiceAccounts.getImpersonatedCredentials(\n-            fcAdminCredsProvider.get(), userEmail, FIRECLOUD_API_OAUTH_SCOPES);\n+    OAuth2Credentials delegatedCreds;\n+    if (configProvider.get().featureFlags.useKeylessDelegatedCredentials) {\n+      delegatedCreds =\n+          new DelegatedUserCredentials(\n+              ServiceAccounts.getServiceAccountEmail(\"firecloud-admin\", configProvider.get()),", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM2NzI3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369367271", "bodyText": "This class isn't meant to be a reusable library, so I don't think we should be worrying about making things ultra-portable in the near term. At the very least I'll bump these up to class-level constants so they're not raw strings hanging in the code.", "author": "gjuggler", "createdAt": "2020-01-22T04:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1ODM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1OTczOQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369159739", "bodyText": "Is there anything else you can mock & verify? Looks like all we verify is that the token value is preserved.", "author": "jaycarlton", "createdAt": "2020-01-21T18:10:02Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.pmiops.workbench.auth;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.googleapis.testing.auth.oauth2.MockTokenServerTransport;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebSignature;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.api.client.util.PemReader;\n+import com.google.api.client.util.SecurityUtils;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.cloud.iam.credentials.v1.SignJwtResponse;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class DelegatedUserCredentialsTest {\n+\n+  static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n+  static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n+  static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+\n+  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  // A random private key string generated for testing purposed with the following commands:\n+  // $ openssl genrsa -out keypair.pem 512\n+  // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n+  static final String SA_PRIVATE_KEY_PKCS8 =\n+      \"-----BEGIN PRIVATE KEY-----\\n\"\n+          + \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA04/ClUlp9Y1HEOPe\\n\"\n+          + \"2FGpSkkSkR94c2JD1Wet2qyVvXLlCBqQyTYtJugSaBWNSDe/M+6astFrWLOSZU2o\\n\"\n+          + \"OVK1AwIDAQABAkEAwQQX8zvXgEA05iP/3Dwkx7GDTwP3UM4GNV0yMJ/kvcG8lTzh\\n\"\n+          + \"/WpVThpktn5roeoiwOcQP3jbGbUTlGw2JJYVAQIhAO2jAKAoqoBIiEimrES0eery\\n\"\n+          + \"8aVmJEu+LzO2+ZgjNRZJAiEA4+juaKu6PxbBHtV4NVN1viX0mIRUxr4jcrZGlz3d\\n\"\n+          + \"QOsCIFRCxggEI2DVVy2bm93IuKosdq6VJy2MRCRsLthZM4uxAiB0A/HApJJFZT7f\\n\"\n+          + \"hEkR1C9eoRGWxd4l4UpILZNXj+1eCwIgZOwMPzJi5thQysHlvf0cqBO/7tv2fd6K\\n\"\n+          + \"qzJzcrNQfMs=\\n\"\n+          + \"-----END PRIVATE KEY-----\";\n+\n+  // We'll handle mocking out the call to the IAM Credentials API.\n+  @Mock private IamCredentialsClient mockIamCredentialsClient;\n+  // Google's API client library provides a convenient mock for their token server API,\n+  // so we'll use that to mock out the call to request an access token.\n+  private MockTokenServerTransport mockTokenServerTransport;\n+  private DelegatedUserCredentials creds;\n+\n+  @Before\n+  public void setUp() {\n+    mockTokenServerTransport = new MockTokenServerTransport();\n+\n+    creds = new DelegatedUserCredentials(SERVICE_ACCOUNT_EMAIL, USER_EMAIL, SCOPES);\n+    creds.setHttpTransport(mockTokenServerTransport);\n+    creds.setIamCredentialsClient(mockIamCredentialsClient);\n+  }\n+\n+  /**\n+   * Creates a PrivateKey from a PKCS8 private key string. This is effectively a copy of\n+   * ServiceAccountCredentials.privateKeyFromPkcs8 which is privately scoped.\n+   */\n+  private static PrivateKey privateKeyFromPkcs8(String privateKeyPem) throws IOException {\n+    Reader reader = new StringReader(privateKeyPem);\n+    PemReader.Section section = PemReader.readFirstSectionAndClose(reader, \"PRIVATE KEY\");\n+    if (section == null) {\n+      throw new IOException(\"Invalid PKCS8 data.\");\n+    }\n+    byte[] bytes = section.getBase64DecodedBytes();\n+    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(bytes);\n+    try {\n+      KeyFactory keyFactory = SecurityUtils.getRsaKeyFactory();\n+      PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n+      return privateKey;\n+    } catch (NoSuchAlgorithmException | InvalidKeySpecException exception) {\n+      throw new IOException(\"Unexpected expcetion reading PKCS data\", exception);\n+    }\n+  }\n+\n+  /**\n+   * Given a JWT payload, create a self-signed JWT using an OAuth2 compliant algorithm. This method\n+   * mocks out the behavior of the IAM Credentials API, which signs JWTs using Google-managed\n+   * service account private keys.\n+   */\n+  private static String createSelfSignedJwt(JsonWebToken.Payload payload)\n+      throws IOException, GeneralSecurityException {\n+    JsonWebSignature.Header header = new JsonWebSignature.Header();\n+    header.setAlgorithm(\"RS256\");\n+    header.setType(\"JWT\");\n+    header.setKeyId(SA_PRIVATE_KEY_ID);\n+\n+    return JsonWebSignature.signUsingRsaSha256(\n+        privateKeyFromPkcs8(SA_PRIVATE_KEY_PKCS8),\n+        JacksonFactory.getDefaultInstance(),\n+        header,\n+        payload);\n+  }\n+\n+  @Test\n+  public void testClaims() {\n+    JsonWebToken.Payload payload = creds.createClaims();\n+\n+    assertThat(payload.getAudience()).isEqualTo(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    assertThat(payload.getIssuer()).isEqualTo(SERVICE_ACCOUNT_EMAIL);\n+    assertThat(payload.getSubject()).isEqualTo(USER_EMAIL);\n+    assertThat(payload.get(\"scope\")).isEqualTo(String.join(\" \", SCOPES));\n+  }\n+\n+  @Test\n+  public void testRefreshFlow() throws IOException {\n+    // Mock out the IAM Credentials API client to create a self-signed JsonWebSignature instead of\n+    // calling Google's API.\n+    when(mockIamCredentialsClient.signJwt(any(SignJwtRequest.class)))\n+        .then(\n+            invocation -> {\n+              SignJwtRequest request = invocation.getArgument(0);\n+              JsonWebToken.Payload payload =\n+                  DelegatedUserCredentials.JSON_FACTORY.fromInputStream(\n+                      new ByteArrayInputStream(request.getPayload().getBytes()),\n+                      JsonWebToken.Payload.class);\n+              return SignJwtResponse.newBuilder()\n+                  .setSignedJwt(createSelfSignedJwt(payload))\n+                  .build();\n+            });\n+    // Register the expected service account & access token with the mock token server transport.\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+\n+    // Kick off the refresh flow.\n+    creds.refresh();\n+", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM3NDkxOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369374918", "bodyText": "I added a couple more assertions.\nA key goal of this test is to ensure that we're correctly passing the signed JWT from IAM Credentials over to the token server. This check is performed by the mock token server transport as part of its internal implementation.", "author": "gjuggler", "createdAt": "2020-01-22T05:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1OTczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1OTg1MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369159851", "bodyText": "I'd make \"access-token\" a constant.", "author": "jaycarlton", "createdAt": "2020-01-21T18:10:17Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package org.pmiops.workbench.auth;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.googleapis.testing.auth.oauth2.MockTokenServerTransport;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebSignature;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.api.client.util.PemReader;\n+import com.google.api.client.util.SecurityUtils;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.cloud.iam.credentials.v1.SignJwtResponse;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class DelegatedUserCredentialsTest {\n+\n+  static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n+  static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n+  static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+\n+  private static final String SA_PRIVATE_KEY_ID = \"private-key-for-testing-only\";\n+  // A random private key string generated for testing purposed with the following commands:\n+  // $ openssl genrsa -out keypair.pem 512\n+  // $ openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key\n+  static final String SA_PRIVATE_KEY_PKCS8 =\n+      \"-----BEGIN PRIVATE KEY-----\\n\"\n+          + \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEA04/ClUlp9Y1HEOPe\\n\"\n+          + \"2FGpSkkSkR94c2JD1Wet2qyVvXLlCBqQyTYtJugSaBWNSDe/M+6astFrWLOSZU2o\\n\"\n+          + \"OVK1AwIDAQABAkEAwQQX8zvXgEA05iP/3Dwkx7GDTwP3UM4GNV0yMJ/kvcG8lTzh\\n\"\n+          + \"/WpVThpktn5roeoiwOcQP3jbGbUTlGw2JJYVAQIhAO2jAKAoqoBIiEimrES0eery\\n\"\n+          + \"8aVmJEu+LzO2+ZgjNRZJAiEA4+juaKu6PxbBHtV4NVN1viX0mIRUxr4jcrZGlz3d\\n\"\n+          + \"QOsCIFRCxggEI2DVVy2bm93IuKosdq6VJy2MRCRsLthZM4uxAiB0A/HApJJFZT7f\\n\"\n+          + \"hEkR1C9eoRGWxd4l4UpILZNXj+1eCwIgZOwMPzJi5thQysHlvf0cqBO/7tv2fd6K\\n\"\n+          + \"qzJzcrNQfMs=\\n\"\n+          + \"-----END PRIVATE KEY-----\";\n+\n+  // We'll handle mocking out the call to the IAM Credentials API.\n+  @Mock private IamCredentialsClient mockIamCredentialsClient;\n+  // Google's API client library provides a convenient mock for their token server API,\n+  // so we'll use that to mock out the call to request an access token.\n+  private MockTokenServerTransport mockTokenServerTransport;\n+  private DelegatedUserCredentials creds;\n+\n+  @Before\n+  public void setUp() {\n+    mockTokenServerTransport = new MockTokenServerTransport();\n+\n+    creds = new DelegatedUserCredentials(SERVICE_ACCOUNT_EMAIL, USER_EMAIL, SCOPES);\n+    creds.setHttpTransport(mockTokenServerTransport);\n+    creds.setIamCredentialsClient(mockIamCredentialsClient);\n+  }\n+\n+  /**\n+   * Creates a PrivateKey from a PKCS8 private key string. This is effectively a copy of\n+   * ServiceAccountCredentials.privateKeyFromPkcs8 which is privately scoped.\n+   */\n+  private static PrivateKey privateKeyFromPkcs8(String privateKeyPem) throws IOException {\n+    Reader reader = new StringReader(privateKeyPem);\n+    PemReader.Section section = PemReader.readFirstSectionAndClose(reader, \"PRIVATE KEY\");\n+    if (section == null) {\n+      throw new IOException(\"Invalid PKCS8 data.\");\n+    }\n+    byte[] bytes = section.getBase64DecodedBytes();\n+    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(bytes);\n+    try {\n+      KeyFactory keyFactory = SecurityUtils.getRsaKeyFactory();\n+      PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n+      return privateKey;\n+    } catch (NoSuchAlgorithmException | InvalidKeySpecException exception) {\n+      throw new IOException(\"Unexpected expcetion reading PKCS data\", exception);\n+    }\n+  }\n+\n+  /**\n+   * Given a JWT payload, create a self-signed JWT using an OAuth2 compliant algorithm. This method\n+   * mocks out the behavior of the IAM Credentials API, which signs JWTs using Google-managed\n+   * service account private keys.\n+   */\n+  private static String createSelfSignedJwt(JsonWebToken.Payload payload)\n+      throws IOException, GeneralSecurityException {\n+    JsonWebSignature.Header header = new JsonWebSignature.Header();\n+    header.setAlgorithm(\"RS256\");\n+    header.setType(\"JWT\");\n+    header.setKeyId(SA_PRIVATE_KEY_ID);\n+\n+    return JsonWebSignature.signUsingRsaSha256(\n+        privateKeyFromPkcs8(SA_PRIVATE_KEY_PKCS8),\n+        JacksonFactory.getDefaultInstance(),\n+        header,\n+        payload);\n+  }\n+\n+  @Test\n+  public void testClaims() {\n+    JsonWebToken.Payload payload = creds.createClaims();\n+\n+    assertThat(payload.getAudience()).isEqualTo(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    assertThat(payload.getIssuer()).isEqualTo(SERVICE_ACCOUNT_EMAIL);\n+    assertThat(payload.getSubject()).isEqualTo(USER_EMAIL);\n+    assertThat(payload.get(\"scope\")).isEqualTo(String.join(\" \", SCOPES));\n+  }\n+\n+  @Test\n+  public void testRefreshFlow() throws IOException {\n+    // Mock out the IAM Credentials API client to create a self-signed JsonWebSignature instead of\n+    // calling Google's API.\n+    when(mockIamCredentialsClient.signJwt(any(SignJwtRequest.class)))\n+        .then(\n+            invocation -> {\n+              SignJwtRequest request = invocation.getArgument(0);\n+              JsonWebToken.Payload payload =\n+                  DelegatedUserCredentials.JSON_FACTORY.fromInputStream(\n+                      new ByteArrayInputStream(request.getPayload().getBytes()),\n+                      JsonWebToken.Payload.class);\n+              return SignJwtResponse.newBuilder()\n+                  .setSignedJwt(createSelfSignedJwt(payload))\n+                  .build();\n+            });\n+    // Register the expected service account & access token with the mock token server transport.\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM3NDU2Ng==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369374566", "bodyText": "Done", "author": "gjuggler", "createdAt": "2020-01-22T05:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE1OTg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2MDIyMg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369160222", "bodyText": "nit: private link from public doc. Maybe just RW-2840 is enough?", "author": "jaycarlton", "createdAt": "2020-01-21T18:11:05Z", "path": "common-api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java", "diffHunk": "@@ -209,6 +209,10 @@ public static WorkbenchConfig createEmptyConfig() {\n     // Whether or not AoU should handle inbound SumoLogic high-egress event requests.\n     // See RW-2253.\n     public boolean enableSumoLogicEventHandling;\n+    // Causes the server to use an API-based method for generating delegated user credentials,\n+    // as opposed to reading service account private keys from GCS.\n+    // See https://precisionmedicineinitiative.atlassian.net/browse/RW-2840 for details.", "originalCommit": "3dfad6a3c1cd5328eb46b2ebe3727c45727ef295", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM3NTA4Ng==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369375086", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-22T05:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE2MDIyMg=="}], "type": "inlineReview"}, {"oid": "8a44f30151402bbed4d867cf437ae00247d1c19c", "url": "https://github.com/all-of-us/workbench/commit/8a44f30151402bbed4d867cf437ae00247d1c19c", "message": "Responding to PR comments.", "committedDate": "2020-01-22T05:25:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyNzY5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369627697", "bodyText": "Cool. times(1) is the default, so you can leave that out.", "author": "jaycarlton", "createdAt": "2020-01-22T15:27:37Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -138,11 +143,23 @@ public void testRefreshFlow() throws IOException {\n                   .build();\n             });\n     // Register the expected service account & access token with the mock token server transport.\n-    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, MOCK_ACCESS_TOKEN);\n \n     // Kick off the refresh flow.\n-    creds.refresh();\n-\n-    assertThat(creds.getAccessToken().getTokenValue()).isEqualTo(\"access-token\");\n+    delegatedCredentials.refresh();\n+\n+    // Verify the call to IAM Credentials API.\n+    ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n+    verify(mockIamCredentialsClient, Mockito.times(1)).signJwt(captor.capture());", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyODM3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369628372", "bodyText": "I'd declare a static Instant so you have the same calculation every time. May need to inject a fake clock somewhere though.", "author": "jaycarlton", "createdAt": "2020-01-22T15:28:40Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -138,11 +143,23 @@ public void testRefreshFlow() throws IOException {\n                   .build();\n             });\n     // Register the expected service account & access token with the mock token server transport.\n-    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, \"access-token\");\n+    mockTokenServerTransport.addServiceAccount(SERVICE_ACCOUNT_EMAIL, MOCK_ACCESS_TOKEN);\n \n     // Kick off the refresh flow.\n-    creds.refresh();\n-\n-    assertThat(creds.getAccessToken().getTokenValue()).isEqualTo(\"access-token\");\n+    delegatedCredentials.refresh();\n+\n+    // Verify the call to IAM Credentials API.\n+    ArgumentCaptor<SignJwtRequest> captor = ArgumentCaptor.forClass(SignJwtRequest.class);\n+    verify(mockIamCredentialsClient, Mockito.times(1)).signJwt(captor.capture());\n+    assertThat(captor.getValue().getName())\n+        .isEqualTo(\"projects/-/serviceAccounts/\" + SERVICE_ACCOUNT_EMAIL);\n+\n+    // The mockTokenServerTransport class runs some lightweight verification of its own (i.e.,\n+    // ensuring the signed JWT can be parsed and that the service account is known). Beyond that,\n+    // we mainly care that the access token is returned and has a correct expiration.\n+    assertThat(delegatedCredentials.getAccessToken().getTokenValue()).isEqualTo(MOCK_ACCESS_TOKEN);\n+    assertThat(\n+            delegatedCredentials.getAccessToken().getExpirationTime().toInstant().getEpochSecond())", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzcwOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967708", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-26T01:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyODM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyOTA3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369629075", "bodyText": "Is this what access tokens look like? It's fine for test purposes, but I find it easier to pick up a new class if the test methods use data that look like the real thing.", "author": "jaycarlton", "createdAt": "2020-01-22T15:29:48Z", "path": "api/src/test/java/org/pmiops/workbench/auth/DelegatedUserCredentialsTest.java", "diffHunk": "@@ -38,8 +42,9 @@\n   static final String USER_EMAIL = \"john.doe@researchallofus.org\";\n   static final String SERVICE_ACCOUNT_EMAIL = \"gsuite-admin@test-project.iam.gserviceaccount.com\";\n   static final List<String> SCOPES = Arrays.asList(\"openid\", \"profile\");\n+  static final String MOCK_ACCESS_TOKEN = \"access-token\";", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzQ5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967497", "bodyText": "Updated with something more realistic. (Heartwarming side note: without the FAKE_ prefix, git-secrets catches this and prevents a successful commit.)", "author": "gjuggler", "createdAt": "2020-01-26T01:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyOTA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyOTkwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369629905", "bodyText": "Do we need to accept a null list here? If possible I would avoid this kind of convention and just use overloaded constructors.", "author": "jaycarlton", "createdAt": "2020-01-22T15:31:02Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -88,7 +89,7 @@ public DelegatedUserCredentials(\n     this.scopes = scopes;", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzM3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967371", "bodyText": "Fair point. I removed all code that deals with a null list.", "author": "gjuggler", "createdAt": "2020-01-26T01:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyOTkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0Nzk5OA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369747998", "bodyText": "nit: line wrapping", "author": "calbach", "createdAt": "2020-01-22T19:07:54Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1NDYyNg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370954626", "bodyText": "Spotless must not have liked my poor man's list formatting. Split out into separate paragraphs.", "author": "gjuggler", "createdAt": "2020-01-25T20:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0Nzk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MDM2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369750367", "bodyText": "Why the lazy initialization of the IAM client and HTTP transport?", "author": "calbach", "createdAt": "2020-01-22T19:12:37Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;\n+\n+  public DelegatedUserCredentials(\n+      String serviceAccountEmail, String userEmail, List<String> scopes) {\n+    super();\n+    this.serviceAccountEmail = serviceAccountEmail;\n+    this.userEmail = userEmail;\n+    this.scopes = scopes;\n+\n+    if (this.scopes == null) {\n+      this.scopes = Collections.emptyList();\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  public void setIamCredentialsClient(IamCredentialsClient client) {\n+    this.client = client;\n+  }\n+\n+  @VisibleForTesting\n+  public void setHttpTransport(HttpTransport httpTransport) {\n+    this.httpTransport = httpTransport;\n+  }\n+\n+  /**\n+   * Creates the set of JWT claims representing a service account `serviceAccountEmail` using\n+   * domain-wide delegation of authority to generate an access token on behalf of a G Suite user,\n+   * `userEmail`.\n+   *\n+   * <p>For reference, see the ServiceAccountCredentials.createAssertion method which builds a\n+   * similar JWT payload in the context of a JWT being self-signed using a service account's private\n+   * key.\n+   *\n+   * @return\n+   */\n+  @VisibleForTesting\n+  public JsonWebToken.Payload createJwtPayload() {\n+    JsonWebToken.Payload payload = new JsonWebToken.Payload();\n+    payload.setIssuedAtTimeSeconds(Instant.now().getEpochSecond());\n+    payload.setExpirationTimeSeconds(\n+        Instant.now().getEpochSecond() + ACCESS_TOKEN_DURATION.getSeconds());\n+    payload.setAudience(GoogleOAuthConstants.TOKEN_SERVER_URL);\n+    payload.setIssuer(this.serviceAccountEmail);\n+    payload.setSubject(this.userEmail);\n+    payload.set(\"scope\", String.join(\" \", this.scopes));\n+    return payload;\n+  }\n+\n+  @Override\n+  public AccessToken refreshAccessToken() throws IOException {\n+    // The first step is to call the IamCredentials API to generate a signed JWT with the\n+    // appropriate claims. This call is authorized with application default credentials (ADCs). The\n+    // ADC service account may be different from `serviceAccountEmail` if the ADC account has the\n+    // roles/iam.serviceAccountTokenCreator role on the `serviceAccountEmail` account.\n+    JsonWebToken.Payload payload = createJwtPayload();\n+\n+    if (client == null) {\n+      client = IamCredentialsClient.create();", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzM4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967389", "bodyText": "See my response to your comment above \u2013 I switched to requiring constructor DI for these classes.", "author": "gjuggler", "createdAt": "2020-01-26T01:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MDM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MTQzMQ==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369751431", "bodyText": "This seems high to me. I think 5 minutes might be more typical for this kind of token. Do we have a use case where we'd need a long-lived token here? (and if it expires, the refresh should kick in - right?)", "author": "calbach", "createdAt": "2020-01-22T19:14:46Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1NDQ2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370954462", "bodyText": "AFAICT, 60min appears to be Google's default expiration for oauth2 access tokens if left blank (c.f. https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateAccessToken#request-body and https://stackoverflow.com/questions/13851157/oauth2-and-google-api-access-token-expiration-time).\nAnother clue comes from logic in the base OAuth2Credentials class, which refreshes a token if the expiration time is any less than 5 minutes away: https://github.com/googleapis/google-auth-library-java/blob/master/oauth2_http/java/com/google/auth/oauth2/OAuth2Credentials.java#L58. So requesting an expiration of 5 minutes would effectively mean we can never reuse an access token. (That said, to be fair I think most services are regenerating delegated credentials for each inbound request anyway, so we're likely not yet using the benefit of cached access tokens.)\nI don't disagree that an hour feels like more than we \"need\", but given that it seems to be pretty widely used, I'm inclined to leave as-is.", "author": "gjuggler", "createdAt": "2020-01-25T20:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc1MTQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2MDg2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369760867", "bodyText": "The documentation for this client indicates that it should be closed: https://github.com/googleapis/java-iamcredentials/blob/master/google-cloud-iamcredentials/src/main/java/com/google/cloud/iam/credentials/v1/IamCredentialsClient.java#L56-L57\nProviding this as a spring singleton and moving this to be a constructor parameter (callers would inject the client and pass it through) would probably be my preferred solution to this.", "author": "calbach", "createdAt": "2020-01-22T19:33:36Z", "path": "api/src/main/java/org/pmiops/workbench/auth/DelegatedUserCredentials.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package org.pmiops.workbench.auth;\n+\n+import com.google.api.client.auth.oauth2.TokenRequest;\n+import com.google.api.client.auth.oauth2.TokenResponse;\n+import com.google.api.client.googleapis.auth.oauth2.GoogleOAuthConstants;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpTransport;\n+import com.google.api.client.http.javanet.NetHttpTransport;\n+import com.google.api.client.json.JsonFactory;\n+import com.google.api.client.json.jackson2.JacksonFactory;\n+import com.google.api.client.json.webtoken.JsonWebToken;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.OAuth2Credentials;\n+import com.google.cloud.iam.credentials.v1.IamCredentialsClient;\n+import com.google.cloud.iam.credentials.v1.SignJwtRequest;\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+\n+/**\n+ * OAuth2 Credentials representing a Service Account using domain-wide delegation of authority to\n+ * generate access tokens on behalf of a G Suite user.\n+ *\n+ * <p>This class calls the IAM Credentials API to request a JWT to be signed using a service\n+ * account's system-managed private key. This is different from the approach adopted by the\n+ * ServiceAccountCredentials class, where an application-provided private key is used to self-sign\n+ * the JWT and then exchange it for an access token.\n+ *\n+ * <p>This use of the IAM Credentials API allows a system to use domain-wide delegation of authority\n+ * to authorize calls as end users without loading private keys directly into the application.\n+ *\n+ * <p>This class shares some patterns in common with the ImpersonatedCredentials class; namely, it\n+ * uses the IAM Credentials API to allow one service account to perform some actions on behalf of\n+ * another service account. However, this class differs in two notable ways: (1) it supports\n+ * impersonation of end users, while ImpersonatedCredentials supports only impersonation of service\n+ * accounts, and (2) it relies on application default credentials for simplicity in the All of Us\n+ * Researcher Workbench use case.\n+ *\n+ * <p>Example usage, for authorizing user requests to the Google Directory API:<br>\n+ *\n+ * <pre>\n+ *   DelegatedUserCredentials delegatedCredentials = new DelegatedUserCredentials(\n+ *     \"service-account-with-dwd-enabled@project-name.iam.gserviceaccount.com\",\n+ *     \"admin-gsuite-user@my-gsuite-domain.com\",\n+ *     DirectoryScopes.ADMIN_DIRECTORY_USERS);\n+ *   Directory directoryClient = new Directory.Builder(\n+ *       new NetHttpTransport(), new JacksonFactory(), null)\n+ *       .setHttpRequestInitializer(new HttpCredentialsAdapter(delegatedCredentials))\n+ *       .build();\n+ * </pre>\n+ */\n+public class DelegatedUserCredentials extends OAuth2Credentials {\n+\n+  static final String JWT_BEARER_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\";\n+  static final String SERVICE_ACCOUNT_NAME_FORMAT = \"projects/-/serviceAccounts/%s\";\n+  static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();\n+  public static final Duration ACCESS_TOKEN_DURATION = Duration.ofMinutes(60);\n+\n+  // The email of the service account whose system-managed key should be used to sign the JWT\n+  // assertion which is exchanged for an access token. This service account:\n+  // - Must have domain-wide delegation enabled for the target user's G Suite domain and scopes.\n+  // - Does not need to be the same service account (SA) as the application default credentials\n+  // (ADC)\n+  //     service account. If they are different, the ADC account must have the Service Account Token\n+  //     Creator role granted on this service account. See\n+  //     https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials for more\n+  //     details.\n+  private String serviceAccountEmail;\n+  // The full G Suite email address of the user for whom an access token will be generated.\n+  private String userEmail;\n+  // The set of Google OAuth scopes to be requested.\n+  private List<String> scopes;\n+  // The HttpTransport to be used for making requests to Google's OAuth2 token server. If null,\n+  // a default NetHttpTransport instance is used.\n+  private HttpTransport httpTransport;\n+  // The IAM Credentials API client to be used for fetching a signed JWT from Google. If null,\n+  // a default API client will be used.\n+  private IamCredentialsClient client;", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2NzMzOA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r370967338", "bodyText": "Good point \u2013 I'd been trying to avoid getting too deep into changing our Spring dependencies, but the combination of the .close() method and the awkwardness of logic to lazily create default instances forced me to take a stab at a full dependency-injected approach. It's cleaner in this class, but I still get a bad feeling when dealing with our service-level Spring DI (especially in tests). I tried to clean things up a bit, including adding autowiring to one of our test classes (to reduce the churn when we add new dependencies) and fixing an awful bit of Spring config leakage between our unit and integration tests (see the change to build.gradle \u2013\u00a0that one really had me surprised).", "author": "gjuggler", "createdAt": "2020-01-26T01:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2MDg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc2MjMzNA==", "url": "https://github.com/all-of-us/workbench/pull/3016#discussion_r369762334", "bodyText": "What's the significance of adding this? Isn't this still just a collection of static utilities both before/after this change?", "author": "calbach", "createdAt": "2020-01-22T19:36:50Z", "path": "api/src/main/java/org/pmiops/workbench/auth/ServiceAccounts.java", "diffHunk": "@@ -7,11 +7,13 @@\n import com.google.auth.oauth2.GoogleCredentials;\n import java.io.IOException;\n import java.util.List;\n+import org.springframework.stereotype.Component;\n \n /**\n  * Handles functionality related to loading service account credentials and generating derived /\n  * impersonated credentials.\n  */\n+@Component", "originalCommit": "8a44f30151402bbed4d867cf437ae00247d1c19c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "url": "https://github.com/all-of-us/workbench/commit/fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "message": "PR feedback. Use DI for creds class, fix some Spring config & autowiring madness, use FakeClock in tests.", "committedDate": "2020-01-26T01:41:34Z", "type": "commit"}, {"oid": "fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "url": "https://github.com/all-of-us/workbench/commit/fa7fd619822e031e5b1fa12fe3ae7baa919863bd", "message": "PR feedback. Use DI for creds class, fix some Spring config & autowiring madness, use FakeClock in tests.", "committedDate": "2020-01-26T01:41:34Z", "type": "forcePushed"}, {"oid": "89bd6c45a8b0ff4ab7f4c78cf36ed64d441723a2", "url": "https://github.com/all-of-us/workbench/commit/89bd6c45a8b0ff4ab7f4c78cf36ed64d441723a2", "message": "Create a ServiceAccountContext within start-local-api.", "committedDate": "2020-01-27T19:36:16Z", "type": "commit"}]}