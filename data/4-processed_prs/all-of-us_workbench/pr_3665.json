{"pr_number": 3665, "pr_title": "[RISK=NO][RW-5065] Migrate additional route and add a guard", "pr_createdAt": "2020-06-12T16:14:08Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3665", "timeline": [{"oid": "88d9b267e9407e4f83f250ce3784e535a06e3c9f", "url": "https://github.com/all-of-us/workbench/commit/88d9b267e9407e4f83f250ce3784e535a06e3c9f", "message": "Working DUCC react router path", "committedDate": "2020-06-09T20:41:48Z", "type": "commit"}, {"oid": "0ca607a598892bbce14be8c9192a063a93240f20", "url": "https://github.com/all-of-us/workbench/commit/0ca607a598892bbce14be8c9192a063a93240f20", "message": "Functioning code with guard and redirect", "committedDate": "2020-06-12T14:12:20Z", "type": "commit"}, {"oid": "4589d5c02a075d714343d5dc4388ef16c5565bc3", "url": "https://github.com/all-of-us/workbench/commit/4589d5c02a075d714343d5dc4388ef16c5565bc3", "message": "Code Cleanup", "committedDate": "2020-06-12T14:26:49Z", "type": "commit"}, {"oid": "9846d1040b8fa17cda019144777da22cf9f19dd0", "url": "https://github.com/all-of-us/workbench/commit/9846d1040b8fa17cda019144777da22cf9f19dd0", "message": "Cleanup and types to atoms", "committedDate": "2020-06-12T15:02:20Z", "type": "commit"}, {"oid": "1a2799fe0c98f2576385f1bdf7c720edcf8fc14b", "url": "https://github.com/all-of-us/workbench/commit/1a2799fe0c98f2576385f1bdf7c720edcf8fc14b", "message": "Add typing to atoms", "committedDate": "2020-06-12T15:54:12Z", "type": "commit"}, {"oid": "2bc531c26a401b920fa15fb212f393f422e1794c", "url": "https://github.com/all-of-us/workbench/commit/2bc531c26a401b920fa15fb212f393f422e1794c", "message": "Fix linting issue", "committedDate": "2020-06-12T15:59:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTk3OA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439679978", "bodyText": "Hmm. Not new in this PR, but just checking around - it seems that our \"route not found\" behavior is pretty bad - just renders a blank page. I don't recall what the behavior was prior to the addition of this: I believe it was the same, worse, or it rerouted to the homepage. May want to track this in a ticket if you haven't already.", "author": "calbach", "createdAt": "2020-06-12T23:34:49Z", "path": "ui/src/app/app-routing.module.ts", "diffHunk": "@@ -339,11 +334,18 @@ const routes: Routes = [\n         path: 'workspaces/build',\n         component: WorkspaceEditComponent,\n         data: {title: 'Create Workspace', mode: WorkspaceEditMode.Create}\n+      },\n+      {\n+        path: '**',\n+        component: AppRouting,\n+        data:  {}\n       }\n     ]\n-  }, {\n+  },\n+  {\n     path: '**',", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NDQ2Ng==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441074466", "bodyText": "Added the ticket - thanks!", "author": "petesantos", "createdAt": "2020-06-16T18:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzE4Nw==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439683187", "bodyText": "Interesting, I was expecting the generic AuthStore to be inferred from the parameter type here, but it's possible the underlying React library is a bit lazy with its typing. Did you confirm that <AuthStore> is necessary here?", "author": "calbach", "createdAt": "2020-06-12T23:54:23Z", "path": "ui/src/app/app-routing.tsx", "diffHunk": "@@ -1,15 +1,36 @@\n import {Component as AComponent} from '@angular/core';\n-import {AppRoute, AppRouter} from 'app/components/app-router';\n+import {AppRoute, AppRouter, Guard, ProtectedRoutes, withFullHeight, withTitle} from 'app/components/app-router';\n+import {DataUserCodeOfConduct} from 'app/pages/profile/data-user-code-of-conduct';\n import { ReactWrapperBase } from 'app/utils';\n+import {authStore, AuthStore, useStore} from 'app/utils/stores';\n+import * as fp from 'lodash/fp';\n import * as React from 'react';\n import {CookiePolicyComponent} from './pages/cookie-policy';\n \n-export const AppRoutingComponent: React.FunctionComponent = () => <AppRouter>\n+\n+const signInGuard: Guard = {\n+  allowed: (): boolean => authStore.get().isSignedIn,\n+  redirectPath: '/login'\n+};\n+\n+const DUCC = fp.flow(withTitle, withFullHeight)(DataUserCodeOfConduct);\n+\n+export const AppRoutingComponent: React.FunctionComponent = () => {\n+  const {authLoaded = false} = useStore<AuthStore>(authStore);", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5NTMzOA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440195338", "bodyText": "<AuthStore> removed - thanks!", "author": "petesantos", "createdAt": "2020-06-15T13:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDIyNQ==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439684225", "bodyText": "nit: rm space?", "author": "calbach", "createdAt": "2020-06-13T00:01:10Z", "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {\n+  title?: string;\n+}\n+\n+export const routeDataStore = atom <RouteDataStore>({});", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTU1Mw==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439685553", "bodyText": "I think it makes sense and I like the symmetry of useStore, but seeing useState in a helper function is hurting my brain a bit. We can discuss this offline if it's faster, but:\nDo you happen to know the mechanism by which React associates this global call to a component? Is it just tracking a stack of render calls - and binds any useState call to the current component in that stack? Or setting aside the implementation details, is that the right mental model?\nI would probably add a method doc to this one to explain the intended usage, i.e. that it should only be called from a react function component (I believe)", "author": "calbach", "createdAt": "2020-06-13T00:09:38Z", "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {\n+  title?: string;\n+}\n+\n+export const routeDataStore = atom <RouteDataStore>({});\n+\n+export interface AuthStore {\n+  authLoaded: boolean;\n+  isSignedIn: boolean;\n+}\n+\n+export const authStore = atom<AuthStore>({authLoaded: false, isSignedIn: false});\n+\n+export function useStore<T>(theStore: Atom<T>) {\n+  const [value, setValue] = useState(theStore.get());", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4NjM1Ng==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440186356", "bodyText": "On the useState inside of useStore - I believe that is the standard pattern if you want your custom hook to run the render method of your component. Calling hooks from within hooks is an acceptable practice according to the rules of hooks(just to put your mind at ease). With some more exposure to hooks I think this will become clearer.\nI haven't looked at the implementation of useState, but you suggested sounds correct and is the right mental model. useState is a functional approach to setState\nI can add some docs to this. Ideally, any custom hook functions should be prefixed with \"use\" and there will be no functions in the codebase that are named use_Something_ that are not react hooks.  I thought about putting this in a separate file called \"hooks\" - we could then put all of our custom hooks in there. Would that be better/clearer than adding comments? I can still add comments describing what the hook does and the file could have a top level comment about how to use the hooks.", "author": "petesantos", "createdAt": "2020-06-15T13:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzMzEwMA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440333100", "bodyText": "Thanks, that doc link is very helpful. This all makes sense now.\nFWIW, I found some explanation of how it works - seems my guess is close enough: https://reactjs.org/docs/hooks-faq.html#how-does-react-associate-hook-calls-with-components", "author": "calbach", "createdAt": "2020-06-15T17:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjMyNA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439686324", "bodyText": "I looked at the useEffect docs. This line is still does not compute.\ntheStore is not a property or state, AFAICT. What does it mean to filter useEffect to only run when it \"changes\"? setValue might make some sense(?); my best guess is that it basically daisy-chains the above subscription setup to itself.\nCan you add a comment, or if there's a more general concept I'm missing - point me to the right docs?", "author": "calbach", "createdAt": "2020-06-13T00:15:18Z", "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {\n+  title?: string;\n+}\n+\n+export const routeDataStore = atom <RouteDataStore>({});\n+\n+export interface AuthStore {\n+  authLoaded: boolean;\n+  isSignedIn: boolean;\n+}\n+\n+export const authStore = atom<AuthStore>({authLoaded: false, isSignedIn: false});\n+\n+export function useStore<T>(theStore: Atom<T>) {\n+  const [value, setValue] = useState(theStore.get());\n+  useEffect(() => {\n+    return theStore.subscribe(v => setValue(v)).unsubscribe;\n+  }, [theStore, setValue]);", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIyMDg4MA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440220880", "bodyText": "If the store were to change (e.g. the store is passed into a child component as a prop from a parent component and the store changes) we would want the effect to run to:\n\nUnsubscribe from the previous store (cleanup) using the function returned in useEffect\nSubscribe to the new store\n\nOnce subscribed it will run setValue (setting the state) when the store changes, which will cause a re-render\nI removed setValue and will add some comments", "author": "petesantos", "createdAt": "2020-06-15T14:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MjU2OA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440352568", "bodyText": "Thanks, this makes more sense after reading the React Hooks docs through.\nLet me check my understanding:\n\ntheStore in all current use cases is not a prop or state, but this function should treat all incoming parameters as if they might be props\nPresumably the useEffect filter works on non-prop/state values. I'm imagining in this specific case where theStore is not a prop, [theStore] is equivalent to [] ?\nAccordingly, we expect this useEffect() to run once on initial mount, then never run again", "author": "calbach", "createdAt": "2020-06-15T18:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxNTMxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441615311", "bodyText": "Yes, useEffect will work on any value. There could be a case where there is a new value derived via a computation between state and props and only want to run the effect in that case. In the vast majority of cases this will run once. But in the event there are multiple stores of the same type, and a component swaps out the store in the hook, the proper cleanup (unsubscribe) and setup (subscribe) will take place for the newly designated store.", "author": "petesantos", "createdAt": "2020-06-17T15:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjUwNA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439686504", "bodyText": "Could you add some basic docs to these interfaces? Method-level docs are probably not needed given the simplicity", "author": "calbach", "createdAt": "2020-06-13T00:16:31Z", "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjgxNA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439686814", "bodyText": "nit: Do you need the div? Does Fragment not work here?", "author": "calbach", "createdAt": "2020-06-13T00:18:58Z", "path": "ui/src/app/components/app-router.tsx", "diffHunk": "@@ -1,26 +1,43 @@\n+import {navigate} from 'app/utils/navigation';\n+import {routeDataStore} from 'app/utils/stores';\n import * as fp from 'lodash/fp';\n import * as React from 'react';\n import { BrowserRouter, Link, Redirect, Route, Switch, useHistory, useLocation, useParams, useRouteMatch} from 'react-router-dom';\n \n const {Fragment} = React;\n \n-interface Guards {\n-  [index: number]: {\n-    checkGuard: () => boolean;\n-    redirectPath: string;\n-  };\n+export interface Guard {\n+  allowed: () => boolean;\n+  redirectPath: string;\n }\n \n export const usePath = () => {\n   const {path} = useRouteMatch();\n   return path;\n };\n \n+export const withTitle = WrappedComponent => ({title, ...props}) => {\n+  routeDataStore.set({title});\n+  return <WrappedComponent {...props}/>;\n+};\n+\n+export const withFullHeight = WrappedComponent => ({...props}) => {\n+  return <div style={{height: '100%'}}><WrappedComponent {...props} /></div>;\n+};\n+\n export const SubRoute = ({children}): React.ReactElement => <Switch>{children}</Switch>;\n export const AppRouter = ({children}): React.ReactElement => <BrowserRouter><SubRoute>{children}</SubRoute></BrowserRouter>;\n \n export const RouteLink = ({path, style = {}, children}): React.ReactElement => <Link style={{...style}} to={path}>{children}</Link>;\n \n+// To compensate for Angular, while keeping true to the declarative/compnentized nature of the router\n+// We will utilize a redirect component that uses the Angular navigation.\n+// Upon completing the migration this can be replaced with a react-router Redirect component\n+const NavRedirect = ({path}) => {\n+  navigate([path]);\n+  return <div/>;", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5ODUyNQ==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440198525", "bodyText": "replaced with return null", "author": "petesantos", "createdAt": "2020-06-15T14:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njk4OA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439686988", "bodyText": "Not a real word anyways, but spelling: componentized", "author": "calbach", "createdAt": "2020-06-13T00:20:20Z", "path": "ui/src/app/components/app-router.tsx", "diffHunk": "@@ -1,26 +1,43 @@\n+import {navigate} from 'app/utils/navigation';\n+import {routeDataStore} from 'app/utils/stores';\n import * as fp from 'lodash/fp';\n import * as React from 'react';\n import { BrowserRouter, Link, Redirect, Route, Switch, useHistory, useLocation, useParams, useRouteMatch} from 'react-router-dom';\n \n const {Fragment} = React;\n \n-interface Guards {\n-  [index: number]: {\n-    checkGuard: () => boolean;\n-    redirectPath: string;\n-  };\n+export interface Guard {\n+  allowed: () => boolean;\n+  redirectPath: string;\n }\n \n export const usePath = () => {\n   const {path} = useRouteMatch();\n   return path;\n };\n \n+export const withTitle = WrappedComponent => ({title, ...props}) => {\n+  routeDataStore.set({title});\n+  return <WrappedComponent {...props}/>;\n+};\n+\n+export const withFullHeight = WrappedComponent => ({...props}) => {\n+  return <div style={{height: '100%'}}><WrappedComponent {...props} /></div>;\n+};\n+\n export const SubRoute = ({children}): React.ReactElement => <Switch>{children}</Switch>;\n export const AppRouter = ({children}): React.ReactElement => <BrowserRouter><SubRoute>{children}</SubRoute></BrowserRouter>;\n \n export const RouteLink = ({path, style = {}, children}): React.ReactElement => <Link style={{...style}} to={path}>{children}</Link>;\n \n+// To compensate for Angular, while keeping true to the declarative/compnentized nature of the router", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Nzc4MA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439687780", "bodyText": "This gets killed after migrating off Angular right? Maybe leave a comment here so we can remember what to rip out afterwards.", "author": "calbach", "createdAt": "2020-06-13T00:25:38Z", "path": "ui/src/app/utils/stores.tsx", "diffHunk": "@@ -0,0 +1,23 @@\n+import {useEffect, useState} from 'react';\n+import {atom, Atom} from './subscribable';\n+\n+interface RouteDataStore {", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIwMTE0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440201142", "bodyText": "I am not certain on this one. It depends on how we specify title's and other data in a route. RouteDataStore could be expanded to house additional data, or we could use a different mechanism", "author": "petesantos", "createdAt": "2020-06-15T14:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Nzc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4OTEzNQ==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439689135", "bodyText": "I'm surprised the type system is OK with this. Should this have the more constrained method signature found in the interface?", "author": "calbach", "createdAt": "2020-06-13T00:34:14Z", "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {\n+  subscribe: (Function) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  return {\n+    subscribe: fn => {\n+      subscribers = fp.concat(subscribers, [fn]);\n+      return {\n+        unsubscribe: () => {\n+          subscribers = fp.without([fn], subscribers);\n+        }\n+      };\n+    },\n+    next: (...args) => {", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NTQyNQ==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440245425", "bodyText": "added typing", "author": "petesantos", "createdAt": "2020-06-15T15:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4OTEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MTY0OA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439691648", "bodyText": "Is this based on something else? There's some interesting design considerations here. Is this tailored for a particular constrained use case - or if not, do you have rationale on the following?\n\nWhether or not to immediately deliver the most recent element to new subscribers. For something like an event system, this wouldn't make sense - but for a store, it can make the initial connection boilerplate a bit more homogeneous (one subscribe() path, rather than a get + subscribe).\nSynchronous vs asynchronous handling on next(), i.e. current approach vs invoking subscribers in a setTimeout(, 0) to pop this out of the stack. This provides some encapsulation between the subscribers, and avoids dependency on synchronous next() behaviors.", "author": "calbach", "createdAt": "2020-06-13T00:40:47Z", "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {\n+  subscribe: (Function) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  return {\n+    subscribe: fn => {", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIzNDc5Mg==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440234792", "bodyText": "Returning the unsubscribe functions allows for the use of anonymous functions / being able to unsubscribe from them. I could combine these all into the atom and return the value as well on subscribe.\nThis is taken from Terra code that we created to allow local storage changes to be synced up using hooks. But prior to that the atoms and subscribe code were all in one function.\nI like the idea on making this async! I will play around with that.", "author": "petesantos", "createdAt": "2020-06-15T14:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MjI4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439692289", "bodyText": "This immediately throws if any of the subscribers throw. If you keep this synchronous per above, I would have some try/catch protection around each callback, since this is potentially a large list of mixed subscribers - an error in one should not be able to take down the whole subscribable.", "author": "calbach", "createdAt": "2020-06-13T00:46:38Z", "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+\n+export interface Subscribable<T> {\n+  subscribe: (Function) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  return {\n+    subscribe: fn => {\n+      subscribers = fp.concat(subscribers, [fn]);\n+      return {\n+        unsubscribe: () => {\n+          subscribers = fp.without([fn], subscribers);\n+        }\n+      };\n+    },\n+    next: (...args) => {\n+      fp.forEach(fn => fn(...args), subscribers);", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MjY3MA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r439692670", "bodyText": "Some simple unit tests around the Atom to codify some of its more nuanced behaviors could be nice: synchronous vs asynchronous behaviors, subscriptions, behavior on initial data seeding", "author": "calbach", "createdAt": "2020-06-13T00:50:13Z", "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,43 @@\n+import * as fp from 'lodash/fp';\n+", "originalCommit": "2bc531c26a401b920fa15fb212f393f422e1794c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NDYwMA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441074600", "bodyText": "Added tests", "author": "petesantos", "createdAt": "2020-06-16T18:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MjY3MA=="}], "type": "inlineReview"}, {"oid": "7b0e12427168bb9fdac8000b9505afc8ac44ee63", "url": "https://github.com/all-of-us/workbench/commit/7b0e12427168bb9fdac8000b9505afc8ac44ee63", "message": "Addressed feedback from PR", "committedDate": "2020-06-15T15:13:23Z", "type": "commit"}, {"oid": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10", "url": "https://github.com/all-of-us/workbench/commit/ce2d22b08991ee35378e71e3f25c13fe1aa2db10", "message": "Add comments", "committedDate": "2020-06-15T16:09:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNDcxMw==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440334713", "bodyText": "nice advanced typing", "author": "calbach", "createdAt": "2020-06-15T17:30:33Z", "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,58 @@\n+import * as fp from 'lodash/fp';\n+\n+/**\n+ * @name Subscribable\n+ * @description A container allowing components and functions to subscribe to changes in the container's contents\n+ * @function subscribe Add a subscription by passing a function\n+ * @function subscribe Send the new value to all subscribers\n+ **/\n+export interface Subscribable<T> {\n+  subscribe: (fn: (newValue?: T, oldValue?: T) => void) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+/** @name Atom\n+ * @description A container that can store a value to be accessed and subscribed to globally\n+ * @function get Returns the current value\n+ * @function set Sets the value and triggers all subscribed functions with the old/new values\n+ * @function subscribe Add a function to the subscribe list\n+ * @function reset Resets the value to the initial value\n+ */\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];", "originalCommit": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNTYxMw==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440425613", "bodyText": "nit: make a ticket for this and call it out in this comment.\nhopefully it won't last 12+ months and get culled \ud83d\ude42", "author": "als364", "createdAt": "2020-06-15T20:23:56Z", "path": "ui/src/app/components/app-router.tsx", "diffHunk": "@@ -1,26 +1,43 @@\n+import {navigate} from 'app/utils/navigation';\n+import {routeDataStore} from 'app/utils/stores';\n import * as fp from 'lodash/fp';\n import * as React from 'react';\n import { BrowserRouter, Link, Redirect, Route, Switch, useHistory, useLocation, useParams, useRouteMatch} from 'react-router-dom';\n \n const {Fragment} = React;\n \n-interface Guards {\n-  [index: number]: {\n-    checkGuard: () => boolean;\n-    redirectPath: string;\n-  };\n+export interface Guard {\n+  allowed: () => boolean;\n+  redirectPath: string;\n }\n \n export const usePath = () => {\n   const {path} = useRouteMatch();\n   return path;\n };\n \n+export const withTitle = WrappedComponent => ({title, ...props}) => {\n+  routeDataStore.set({title});\n+  return <WrappedComponent {...props}/>;\n+};\n+\n+export const withFullHeight = WrappedComponent => ({...props}) => {\n+  return <div style={{height: '100%'}}><WrappedComponent {...props} /></div>;\n+};\n+\n export const SubRoute = ({children}): React.ReactElement => <Switch>{children}</Switch>;\n export const AppRouter = ({children}): React.ReactElement => <BrowserRouter><SubRoute>{children}</SubRoute></BrowserRouter>;\n \n export const RouteLink = ({path, style = {}, children}): React.ReactElement => <Link style={{...style}} to={path}>{children}</Link>;\n \n+// To compensate for Angular, while keeping true to the declarative/componentized nature of the router\n+// We will utilize a redirect component that uses the Angular navigation.\n+// Upon completing the migration this can be replaced with a react-router Redirect component", "originalCommit": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxMTIzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441611239", "bodyText": "done - thanks", "author": "petesantos", "createdAt": "2020-06-17T14:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNTYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MzExNw==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440443117", "bodyText": "I believe this should be @function next", "author": "als364", "createdAt": "2020-06-15T20:58:34Z", "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,58 @@\n+import * as fp from 'lodash/fp';\n+\n+/**\n+ * @name Subscribable\n+ * @description A container allowing components and functions to subscribe to changes in the container's contents\n+ * @function subscribe Add a subscription by passing a function\n+ * @function subscribe Send the new value to all subscribers", "originalCommit": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2MDk5MA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440860990", "bodyText": "fixed - thanks", "author": "petesantos", "createdAt": "2020-06-16T13:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MzExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0NzY0OQ==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440447649", "bodyText": "I googled this pattern cause I hadn't heard it called 'atom' before. It looks like this is a clojurescript pattern, and that someone ported it to react. Do you think this port is worth using, or can our needs be served by something as simple as what you've implemented here?", "author": "als364", "createdAt": "2020-06-15T21:07:34Z", "path": "ui/src/app/utils/subscribable.tsx", "diffHunk": "@@ -0,0 +1,58 @@\n+import * as fp from 'lodash/fp';\n+\n+/**\n+ * @name Subscribable\n+ * @description A container allowing components and functions to subscribe to changes in the container's contents\n+ * @function subscribe Add a subscription by passing a function\n+ * @function subscribe Send the new value to all subscribers\n+ **/\n+export interface Subscribable<T> {\n+  subscribe: (fn: (newValue?: T, oldValue?: T) => void) => { unsubscribe: () => void};\n+  next: (newValue: T, oldValue: T) => void;\n+}\n+\n+/** @name Atom\n+ * @description A container that can store a value to be accessed and subscribed to globally\n+ * @function get Returns the current value\n+ * @function set Sets the value and triggers all subscribed functions with the old/new values\n+ * @function subscribe Add a function to the subscribe list\n+ * @function reset Resets the value to the initial value\n+ */\n+export interface Atom<T> {\n+  get: () => T;\n+  set: (value: T) => void;\n+  subscribe: Subscribable<T>['subscribe'];\n+  reset: () => void;\n+}\n+\n+export function subscribable<T>(): Subscribable<T> {\n+  let subscribers = [];\n+  type subscriber = ((newValue?: T, oldValue?: T) => void);\n+\n+  return {\n+    subscribe: fn => {\n+      subscribers = fp.concat(subscribers, [fn]);\n+      return {\n+        unsubscribe: () => {\n+          subscribers = fp.without([fn], subscribers);\n+        }\n+      };\n+    },\n+    next: (newValue?: T, oldValue?: T) => {\n+      fp.forEach((fn: subscriber) => setTimeout(() => fn(newValue, oldValue), 0), subscribers);\n+    }\n+  };\n+}\n+\n+// A simple state container inspired by clojure atoms.\n+export function atom<T>(initialValue: T): Atom<T> {", "originalCommit": "ce2d22b08991ee35378e71e3f25c13fe1aa2db10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2Njg1Ng==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r440866856", "bodyText": "That is really cool and good to know - thanks! I would prefer to keep the code as simple as possible and use the least powerful abstraction that we need for the task. If it turns out that we need more functionality, we can look into using react-atom. I do think this simple version can give us a lot of functionality in the code base", "author": "petesantos", "createdAt": "2020-06-16T13:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0NzY0OQ=="}], "type": "inlineReview"}, {"oid": "b32cc98e5d5ca7a597b5fed1ce8daccddd412d34", "url": "https://github.com/all-of-us/workbench/commit/b32cc98e5d5ca7a597b5fed1ce8daccddd412d34", "message": "Add subscribe test", "committedDate": "2020-06-16T14:04:46Z", "type": "commit"}, {"oid": "a8a7377fa351dc7e31a95986c1d225ed13e83313", "url": "https://github.com/all-of-us/workbench/commit/a8a7377fa351dc7e31a95986c1d225ed13e83313", "message": "Add atom tests", "committedDate": "2020-06-16T18:32:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1ODQ5OQ==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441158499", "bodyText": "nit: for the purposes of counting the invocations, I think starting with 0 would be more readable", "author": "calbach", "createdAt": "2020-06-16T21:41:25Z", "path": "ui/src/app/utils/subscribable.spec.tsx", "diffHunk": "@@ -0,0 +1,126 @@\n+import { atom } from './subscribable';\n+\n+export const delay = ms => {\n+  return new Promise(resolve => setTimeout(resolve, ms));\n+};\n+\n+const promiseComplete = () => {\n+  let resolveHandler;\n+  const promise = new Promise<void>((resolve) => {\n+    resolveHandler = value => value && resolve();\n+  });\n+  return {promise, resolveHandler};\n+};\n+\n+const makeSubscribeFn = (assertions): [() => Promise<void>, (newValue: any, oldValue: any) => Promise<{}>] => {\n+  const {promise, resolveHandler} = promiseComplete();\n+  const promiseHandler = (): Promise<void> => promise;\n+\n+  const subscribeFn = (newValue, oldValue) => new Promise((resolve) => {\n+    assertions.forEach(assertion => assertion(newValue, oldValue));\n+    resolveHandler(true);\n+    resolve();\n+  });\n+\n+  return [promiseHandler, subscribeFn];\n+};\n+\n+describe('atom', () => {\n+\n+  it('should initialize with a value', () => {\n+    const testAtom = atom({value: 1});\n+    expect(testAtom.get()).toEqual({value: 1});\n+  });\n+\n+  it('should set the value', () => {\n+    const testAtom = atom({value: 1});\n+    testAtom.set({value: 5});\n+    expect(testAtom.get()).toEqual({value: 5});\n+  });\n+\n+  it('should call a single subscribed function', async() => {\n+    const testAtom = atom({value: 1});\n+    const [complete, subscribeFn] = makeSubscribeFn([\n+      newValue => expect(newValue).toEqual({value: 10}),\n+      ({}, oldValue) => expect(oldValue).toEqual({value: 20})\n+    ]);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn);\n+    testAtom.set({value: 10});\n+\n+    await complete();\n+  });\n+\n+  it('should call a multiple subscribed functions with new and old values', async() => {\n+    const testAtom = atom({value: 1});\n+    const assertions = [\n+      newValue => expect(newValue).toEqual({value: 10}),\n+      ({}, oldValue) => expect(oldValue).toEqual({value: 20})\n+    ];\n+\n+    const [complete1, subscribeFn1] = makeSubscribeFn(assertions);\n+    const [complete2, subscribeFn2] = makeSubscribeFn(assertions);\n+    const [complete3, subscribeFn3] = makeSubscribeFn(assertions);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn1);\n+    testAtom.subscribe(subscribeFn2);\n+    testAtom.subscribe(subscribeFn3);\n+    testAtom.set({value: 10});\n+\n+    await complete1();\n+    await complete2();\n+    await complete3();\n+  });\n+\n+  it('should not call an unsubscribed function', async() => {\n+    const testAtom = atom({value: 1});\n+    let value = 1;", "originalCommit": "a8a7377fa351dc7e31a95986c1d225ed13e83313", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwODMyMw==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441608323", "bodyText": "done", "author": "petesantos", "createdAt": "2020-06-17T14:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1ODQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1OTMxMg==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441159312", "bodyText": "optional: one more test case which would be nice is to have one of the subscribers throw an error, and verify the others still succeed", "author": "calbach", "createdAt": "2020-06-16T21:43:15Z", "path": "ui/src/app/utils/subscribable.spec.tsx", "diffHunk": "@@ -0,0 +1,126 @@\n+import { atom } from './subscribable';\n+\n+export const delay = ms => {\n+  return new Promise(resolve => setTimeout(resolve, ms));\n+};\n+\n+const promiseComplete = () => {\n+  let resolveHandler;\n+  const promise = new Promise<void>((resolve) => {\n+    resolveHandler = value => value && resolve();\n+  });\n+  return {promise, resolveHandler};\n+};\n+\n+const makeSubscribeFn = (assertions): [() => Promise<void>, (newValue: any, oldValue: any) => Promise<{}>] => {\n+  const {promise, resolveHandler} = promiseComplete();\n+  const promiseHandler = (): Promise<void> => promise;\n+\n+  const subscribeFn = (newValue, oldValue) => new Promise((resolve) => {\n+    assertions.forEach(assertion => assertion(newValue, oldValue));\n+    resolveHandler(true);\n+    resolve();\n+  });\n+\n+  return [promiseHandler, subscribeFn];\n+};\n+\n+describe('atom', () => {\n+\n+  it('should initialize with a value', () => {\n+    const testAtom = atom({value: 1});\n+    expect(testAtom.get()).toEqual({value: 1});\n+  });\n+\n+  it('should set the value', () => {\n+    const testAtom = atom({value: 1});\n+    testAtom.set({value: 5});\n+    expect(testAtom.get()).toEqual({value: 5});\n+  });\n+\n+  it('should call a single subscribed function', async() => {\n+    const testAtom = atom({value: 1});\n+    const [complete, subscribeFn] = makeSubscribeFn([\n+      newValue => expect(newValue).toEqual({value: 10}),\n+      ({}, oldValue) => expect(oldValue).toEqual({value: 20})\n+    ]);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn);\n+    testAtom.set({value: 10});\n+\n+    await complete();\n+  });\n+\n+  it('should call a multiple subscribed functions with new and old values', async() => {\n+    const testAtom = atom({value: 1});\n+    const assertions = [\n+      newValue => expect(newValue).toEqual({value: 10}),\n+      ({}, oldValue) => expect(oldValue).toEqual({value: 20})\n+    ];\n+\n+    const [complete1, subscribeFn1] = makeSubscribeFn(assertions);\n+    const [complete2, subscribeFn2] = makeSubscribeFn(assertions);\n+    const [complete3, subscribeFn3] = makeSubscribeFn(assertions);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn1);\n+    testAtom.subscribe(subscribeFn2);\n+    testAtom.subscribe(subscribeFn3);\n+    testAtom.set({value: 10});\n+\n+    await complete1();\n+    await complete2();\n+    await complete3();\n+  });\n+\n+  it('should not call an unsubscribed function', async() => {\n+    const testAtom = atom({value: 1});\n+    let value = 1;\n+    const subscriber = [() => value += 1];\n+\n+    const [complete1, subscribeFn1] = makeSubscribeFn(subscriber);\n+    const [, subscribeFn2] = makeSubscribeFn(subscriber);\n+    const [complete3, subscribeFn3] = makeSubscribeFn(subscriber);\n+\n+    testAtom.set({value: 20});\n+    testAtom.subscribe(subscribeFn1);\n+\n+    const sub2 = testAtom.subscribe(subscribeFn2);\n+    sub2.unsubscribe();\n+\n+    testAtom.subscribe(subscribeFn3);\n+    testAtom.set({value: 10});\n+\n+    await complete1();\n+    await complete3();\n+    await delay(50);\n+\n+    expect(value).toBe(3);\n+  });\n+\n+  it('should not call any functions when all have unsubscribed', async() => {", "originalCommit": "a8a7377fa351dc7e31a95986c1d225ed13e83313", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwODQ0MA==", "url": "https://github.com/all-of-us/workbench/pull/3665#discussion_r441608440", "bodyText": "added", "author": "petesantos", "createdAt": "2020-06-17T14:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1OTMxMg=="}], "type": "inlineReview"}, {"oid": "03684490eb9b667f28793dc16582d0784a1a8148", "url": "https://github.com/all-of-us/workbench/commit/03684490eb9b667f28793dc16582d0784a1a8148", "message": "Add error handling and associated test", "committedDate": "2020-06-17T14:53:33Z", "type": "commit"}]}