{"pr_number": 3882, "pr_title": "[RW-5382][risk=no] Streaming BQ upload service", "pr_createdAt": "2020-08-14T15:05:50Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3882", "timeline": [{"oid": "895af7a75ee99915c5179fcaaff29b22836b67c0", "url": "https://github.com/all-of-us/workbench/commit/895af7a75ee99915c5179fcaaff29b22836b67c0", "message": "reporting upload via InsertAll streaming", "committedDate": "2020-08-14T16:25:15Z", "type": "forcePushed"}, {"oid": "ef60c5f52df557e889be8780cd24bd980d9c9f05", "url": "https://github.com/all-of-us/workbench/commit/ef60c5f52df557e889be8780cd24bd980d9c9f05", "message": "streaming bigquery upload for reporting", "committedDate": "2020-08-14T16:31:59Z", "type": "commit"}, {"oid": "ef60c5f52df557e889be8780cd24bd980d9c9f05", "url": "https://github.com/all-of-us/workbench/commit/ef60c5f52df557e889be8780cd24bd980d9c9f05", "message": "streaming bigquery upload for reporting", "committedDate": "2020-08-14T16:31:59Z", "type": "forcePushed"}, {"oid": "2e5abed1aa36940f2de448534a895663627f097a", "url": "https://github.com/all-of-us/workbench/commit/2e5abed1aa36940f2de448534a895663627f097a", "message": "transaction support and other fixes", "committedDate": "2020-08-14T20:50:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MTE0MA==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r470861140", "bodyText": "Sadly we can't do this in the DI, because the config isn't available at bootstrap time. So I'm always injecting dead code unless there's a runtime change to it.\nThough perhaps I could manual-wire it instead of using ctor injection. Not really worth that though.", "author": "jaycarlton", "createdAt": "2020-08-14T20:56:14Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/ReportingServiceImpl.java", "diffHunk": "@@ -1,24 +1,52 @@\n package org.pmiops.workbench.reporting;\n \n+import javax.inject.Provider;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n import org.pmiops.workbench.model.ReportingSnapshot;\n+import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n @Service\n public class ReportingServiceImpl implements ReportingService {\n \n-  private final ReportingUploadService reportingUploadService;\n+  private static enum UploadMethod {\n+    DML,\n+    STREAMING;\n+  }\n+\n   private final ReportingSnapshotService reportingSnapshotService;\n+  private final ReportingUploadService reportingUploadServiceDmlImpl;\n+  private final ReportingUploadService reportingUploadServiceStreamingImpl;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n \n   public ReportingServiceImpl(\n-      ReportingUploadService reportingUploadService,\n-      ReportingSnapshotService reportingSnapshotService) {\n-    this.reportingUploadService = reportingUploadService;\n+      @Qualifier(\"REPORTING_UPLOAD_SERVICE_DML_IMPL\")\n+          ReportingUploadService reportingUploadServiceDmlImpl,\n+      @Qualifier(\"REPORTING_UPLOAD_SERVICE_STREAMING_IMPL\")\n+          ReportingUploadService reportingUploadServiceStreamingImpl,\n+      ReportingSnapshotService reportingSnapshotService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.reportingUploadServiceDmlImpl = reportingUploadServiceDmlImpl;\n+    this.reportingUploadServiceStreamingImpl = reportingUploadServiceStreamingImpl;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n     this.reportingSnapshotService = reportingSnapshotService;\n   }\n \n   @Override\n   public ReportingJobResult takeAndUploadSnapshot() {\n     final ReportingSnapshot snapshot = reportingSnapshotService.takeSnapshot();\n-    return reportingUploadService.uploadSnapshot(snapshot);\n+    return getConfiguredUploadService().uploadSnapshot(snapshot);\n+  }\n+\n+  private ReportingUploadService getConfiguredUploadService() {\n+    final String uploadMethod = workbenchConfigProvider.get().reporting.uploadMethod;\n+    if (UploadMethod.DML.name().equals(uploadMethod)) {", "originalCommit": "2e5abed1aa36940f2de448534a895663627f097a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "58503b889a13878512ab4662590b0040e7d62901", "url": "https://github.com/all-of-us/workbench/commit/58503b889a13878512ab4662590b0040e7d62901", "message": "Merge branch 'master' into jaycarlrton/RW-5382", "committedDate": "2020-08-17T18:20:51Z", "type": "commit"}, {"oid": "cbc35a1557a0645bf557bd1bb0ac547fcf83cb03", "url": "https://github.com/all-of-us/workbench/commit/cbc35a1557a0645bf557bd1bb0ac547fcf83cb03", "message": "fix tests", "committedDate": "2020-08-17T23:14:38Z", "type": "commit"}, {"oid": "fb9f506952f31e1009577e8c2267ebc4ca4a63d3", "url": "https://github.com/all-of-us/workbench/commit/fb9f506952f31e1009577e8c2267ebc4ca4a63d3", "message": "spotless", "committedDate": "2020-08-17T23:15:15Z", "type": "commit"}, {"oid": "fcb7e507f23214e1644ca517cbf745795851cadd", "url": "https://github.com/all-of-us/workbench/commit/fcb7e507f23214e1644ca517cbf745795851cadd", "message": "fixed time conversion issue...again", "committedDate": "2020-08-18T13:52:26Z", "type": "commit"}, {"oid": "de86c9d58ca52be5ca65d9927cc248e9d289cb5f", "url": "https://github.com/all-of-us/workbench/commit/de86c9d58ca52be5ca65d9927cc248e9d289cb5f", "message": "fixed harder", "committedDate": "2020-08-18T14:18:03Z", "type": "commit"}, {"oid": "78645b98bc78544a161afa291c31814b08f384d2", "url": "https://github.com/all-of-us/workbench/commit/78645b98bc78544a161afa291c31814b08f384d2", "message": "spotless", "committedDate": "2020-08-18T14:18:24Z", "type": "commit"}, {"oid": "51c1be85cdabd1aa4592169fdfc4f7d2f195c132", "url": "https://github.com/all-of-us/workbench/commit/51c1be85cdabd1aa4592169fdfc4f7d2f195c132", "message": "try string rep", "committedDate": "2020-08-18T16:24:01Z", "type": "commit"}, {"oid": "9e5d7875d026f088a1733c8528178b25e4b89087", "url": "https://github.com/all-of-us/workbench/commit/9e5d7875d026f088a1733c8528178b25e4b89087", "message": "un-consolidate", "committedDate": "2020-08-18T17:21:00Z", "type": "commit"}, {"oid": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "url": "https://github.com/all-of-us/workbench/commit/8e99b18171e5ec807c6fab02c128388ef4d5363d", "message": "remaining configs [skip ci]", "committedDate": "2020-08-18T17:34:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ4NTkxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472485911", "bodyText": "this one is not used", "author": "jmthibault79", "createdAt": "2020-08-18T20:52:07Z", "path": "api/src/main/java/org/pmiops/workbench/cohortbuilder/util/QueryParameterValues.java", "diffHunk": "@@ -14,6 +17,18 @@\n public final class QueryParameterValues {\n   private static final int MICROSECONDS_IN_MILLISECOND = 1000;\n \n+  // For creating a Timestamp QueryParameterValue, use this formatter.\n+  // example error when using the RowToInsert version (below): \"Invalid format:\n+  // \"1989-02-17 00:00:00.000000\" is too short\".\n+  public static final DateTimeFormatter QPV_TIMESTAMP_FORMATTER =\n+      DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss.SSSSSSZZ\").withZone(ZoneOffset.UTC);\n+  // For parsing the string value of a timestamp QPV, use this formatter (with colon).\n+  public static final DateTimeFormatter QPV_TIMESTAMP_TO_STRING_FORMATTER =", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI5OTE0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473299142", "bodyText": "Yeah, I had a use for it but now I can't find it.", "author": "jaycarlton", "createdAt": "2020-08-19T20:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ4NTkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ4NjQ5OA==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472486498", "bodyText": "?", "author": "jmthibault79", "createdAt": "2020-08-18T20:53:15Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/ReportingJobResult.java", "diffHunk": "@@ -2,7 +2,6 @@\n \n public enum ReportingJobResult {\n   SUCCEEDED,\n-  ABORTED,", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NzI4Mg==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473187282", "bodyText": "This was just a placeholder. After the alpha delivery, I want to implement an actual error handling/reporting/mitigating strategy.", "author": "jaycarlton", "createdAt": "2020-08-19T17:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ4NjQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ4ODIxOA==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472488218", "bodyText": "Please add a comment about what this means", "author": "jmthibault79", "createdAt": "2020-08-18T20:56:27Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/ReportingServiceImpl.java", "diffHunk": "@@ -1,24 +1,52 @@\n package org.pmiops.workbench.reporting;\n \n+import javax.inject.Provider;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n import org.pmiops.workbench.model.ReportingSnapshot;\n+import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n @Service\n public class ReportingServiceImpl implements ReportingService {\n \n-  private final ReportingUploadService reportingUploadService;\n+  private static enum UploadMethod {\n+    DML,", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4ODA5NA==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473188094", "bodyText": "Sure. It's data manipulation language, aka an Insert/Update/Drop/Create, or everything except a query. I think BigQuery is the only place I've seen this term.", "author": "jaycarlton", "createdAt": "2020-08-19T17:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ4ODIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5MDA3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472490072", "bodyText": "Flagging this: needs review by someone more Spring savvy", "author": "jmthibault79", "createdAt": "2020-08-18T21:00:06Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/ReportingSnapshotServiceImpl.java", "diffHunk": "@@ -1,45 +1,68 @@\n package org.pmiops.workbench.reporting;\n \n+import com.google.common.base.Stopwatch;\n import java.time.Clock;\n import java.util.List;\n import java.util.Random;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n import org.pmiops.workbench.db.dao.UserService;\n import org.pmiops.workbench.db.model.DbUser;\n import org.pmiops.workbench.db.model.DbWorkspace;\n import org.pmiops.workbench.model.ReportingResearcher;\n import org.pmiops.workbench.model.ReportingSnapshot;\n import org.pmiops.workbench.model.ReportingWorkspace;\n import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n+import org.springframework.transaction.PlatformTransactionManager;\n+import org.springframework.transaction.support.TransactionTemplate;\n \n @Service\n public class ReportingSnapshotServiceImpl implements ReportingSnapshotService {\n+  private static final Logger log = Logger.getLogger(ReportingSnapshotServiceImpl.class.getName());\n \n   private final Clock clock;\n   private final ReportingMapper reportingMapper;\n-  private Random random;\n+  private final Random random;\n+  private final PlatformTransactionManager platformTransactionManager;\n+  private final Provider<Stopwatch> stopwatchProvider;\n   private final UserService userService;\n   private final WorkspaceService workspaceService;\n \n   public ReportingSnapshotServiceImpl(\n       Clock clock,\n       ReportingMapper reportingMapper,\n       Random random,\n+      @Qualifier(\"transactionManager\") PlatformTransactionManager platformTransactionManager,\n+      Provider<Stopwatch> stopwatchProvider,\n       UserService userService,\n       WorkspaceService workspaceService) {\n     this.clock = clock;\n     this.reportingMapper = reportingMapper;\n     this.random = random;\n+    this.platformTransactionManager = platformTransactionManager;\n+    this.stopwatchProvider = stopwatchProvider;\n     this.userService = userService;\n     this.workspaceService = workspaceService;\n   }\n \n   @Override\n   public ReportingSnapshot takeSnapshot() {\n-    return new ReportingSnapshot()\n-        .captureTimestamp(clock.millis())\n-        .researchers(getResearchers())\n-        .workspaces(getWorkspaces());\n+    final Stopwatch stopwatch = stopwatchProvider.get().start();\n+    final TransactionTemplate template = new TransactionTemplate(platformTransactionManager);", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4NTI2MA==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473185260", "bodyText": "I expect to revisit it when I do the perf testing ticket. I think it's going to be important to schedule a couple of these soon after the initial delivery if we can.\nIs there a  way to flag it as read-only if I don't use the template stuff?", "author": "jaycarlton", "createdAt": "2020-08-19T17:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5MDA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIxMDc4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473210789", "bodyText": "@Transactional(readOnly = true)", "author": "freemabd", "createdAt": "2020-08-19T17:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5MDA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5Mjc4Mg==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472492782", "bodyText": "nit: could you flip this to size > 0?  I find that more readable", "author": "jmthibault79", "createdAt": "2020-08-18T21:05:49Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/ReportingUploadServiceStreamingImpl.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.pmiops.workbench.reporting;\n+\n+import com.google.cloud.bigquery.BigQueryError;\n+import com.google.cloud.bigquery.InsertAllRequest;\n+import com.google.cloud.bigquery.InsertAllResponse;\n+import com.google.cloud.bigquery.TableId;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.api.BigQueryService;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.model.ReportingResearcher;\n+import org.pmiops.workbench.model.ReportingSnapshot;\n+import org.pmiops.workbench.model.ReportingWorkspace;\n+import org.pmiops.workbench.reporting.insertion.InsertAllRequestBuilder;\n+import org.pmiops.workbench.reporting.insertion.ResearcherParameter;\n+import org.pmiops.workbench.reporting.insertion.WorkspaceParameter;\n+import org.springframework.stereotype.Service;\n+\n+@Service(\"REPORTING_UPLOAD_SERVICE_STREAMING_IMPL\")\n+public class ReportingUploadServiceStreamingImpl implements ReportingUploadService {\n+  private static final Logger log =\n+      Logger.getLogger(ReportingUploadServiceStreamingImpl.class.getName());\n+  private static final InsertAllRequestBuilder<ReportingResearcher> researcherRequestBuilder =\n+      ResearcherParameter::values;\n+  private static final InsertAllRequestBuilder<ReportingWorkspace> workspaceRequestBuilder =\n+      WorkspaceParameter::values;\n+\n+  private final BigQueryService bigQueryService;\n+  private final Provider<WorkbenchConfig> configProvider;\n+  private final Provider<Stopwatch> stopwatchProvider;\n+\n+  public ReportingUploadServiceStreamingImpl(\n+      BigQueryService bigQueryService,\n+      Provider<WorkbenchConfig> configProvider,\n+      Provider<Stopwatch> stopwatchProvider) {\n+    this.bigQueryService = bigQueryService;\n+    this.configProvider = configProvider;\n+    this.stopwatchProvider = stopwatchProvider;\n+  }\n+\n+  @Override\n+  public ReportingJobResult uploadSnapshot(ReportingSnapshot reportingSnapshot) {\n+    final Stopwatch stopwatch = stopwatchProvider.get();\n+    final ImmutableMap.Builder<TableId, InsertAllResponse> responseMapBuilder =\n+        ImmutableMap.builder();\n+    for (InsertAllRequest request : getInsertAllRequests(reportingSnapshot)) {\n+      stopwatch.start();\n+      final InsertAllResponse currentResponse = bigQueryService.insertAll(request);\n+      responseMapBuilder.put(request.getTable(), currentResponse);\n+      stopwatch.stop();\n+      logDuration(\n+          stopwatch.elapsed(),\n+          String.format(\n+              \"Stream %d rows into %s\", request.getRows().size(), request.getTable().getTable()));\n+      stopwatch.reset();\n+    }\n+    return computeOverallResult(responseMapBuilder.build());\n+  }\n+\n+  public void logDuration(Duration duration, String description) {\n+    final long millis = duration.toMillis();\n+    log.info(String.format(\"%s: %d.%d seconds\", description, millis / 1000, millis % 1000));\n+  }\n+\n+  private List<InsertAllRequest> getInsertAllRequests(ReportingSnapshot reportingSnapshot) {\n+    final String projectId = configProvider.get().server.projectId;\n+    final String dataset = configProvider.get().reporting.dataset;\n+    final Map<String, Object> fixedValues =\n+        ImmutableMap.of(\"snapshot_timestamp\", reportingSnapshot.getCaptureTimestamp());\n+\n+    return ImmutableList.of(\n+            researcherRequestBuilder.build(\n+                TableId.of(projectId, dataset, \"researcher\"),\n+                reportingSnapshot.getResearchers(),\n+                fixedValues),\n+            workspaceRequestBuilder.build(\n+                TableId.of(projectId, dataset, \"workspace\"),\n+                reportingSnapshot.getWorkspaces(),\n+                fixedValues))\n+        .stream()\n+        .filter(r -> 0 < r.getRows().size())", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5OTkwMw==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472499903", "bodyText": "this name is misleading - there is one row per workspace.  This is not Workspace 1's rows.\nPlease also assert that there are 3 workspaces here.", "author": "jmthibault79", "createdAt": "2020-08-18T21:20:35Z", "path": "api/src/test/java/org/pmiops/workbench/reporting/ReportingUploadServiceTest.java", "diffHunk": "@@ -157,17 +197,54 @@ public void testUploadSnapshot_batchInserts() {\n                 .fakeSize(4444L)\n                 .creatorId(101L)));\n \n-    reportingUploadService.uploadSnapshot(largeSnapshot);\n+    reportingUploadServiceDmlImpl.uploadSnapshot(largeSnapshot);\n     verify(mockBigQueryService, times(6))\n         .executeQuery(queryJobConfigurationCaptor.capture(), anyLong());\n \n     final List<QueryJobConfiguration> jobs = queryJobConfigurationCaptor.getAllValues();\n     assertThat(jobs).hasSize(6);\n-    final int researcherColumnCount = 4;\n-    final int workspaceColumnCount = 5;\n \n-    assertThat(jobs.get(0).getNamedParameters()).hasSize(researcherColumnCount * 5 + 1);\n-    assertThat(jobs.get(4).getNamedParameters()).hasSize(researcherColumnCount + 1);\n-    assertThat(jobs.get(5).getNamedParameters()).hasSize(workspaceColumnCount + 1);\n+    assertThat(jobs.get(0).getNamedParameters()).hasSize(RESEARCHER_COLUMN_COUNT * 5 + 1);\n+    assertThat(jobs.get(4).getNamedParameters()).hasSize(RESEARCHER_COLUMN_COUNT + 1);\n+    assertThat(jobs.get(5).getNamedParameters()).hasSize(WORKSPACE_COLUMN_COUNT + 1);\n+\n+    final QueryParameterValue creationTime =\n+        jobs.get(5).getNamedParameters().get(\"creation_time__0\");\n+    assertThat(creationTime).isNotNull();\n+    final Instant instant = QueryParameterValues.timestampQpvToInstant(creationTime);\n+    assertThat((double) instant.toEpochMilli()).isWithin(500.0).of(THEN.toEpochMilli());\n+  }\n+\n+  @Test\n+  public void testUploadSnapshot_streaming() {\n+    final InsertAllResponse mockInsertAllResponse = mock(InsertAllResponse.class);\n+    doReturn(Collections.emptyMap()).when(mockInsertAllResponse).getInsertErrors();\n+\n+    doReturn(mockInsertAllResponse)\n+        .when(mockBigQueryService)\n+        .insertAll(any(InsertAllRequest.class));\n+    final ReportingJobResult result =\n+        reportingUploadServiceStreamingImpl.uploadSnapshot(reportingSnapshot);\n+    verify(mockBigQueryService, times(2)).insertAll(insertAllRequestCaptor.capture());\n+    final List<InsertAllRequest> requests = insertAllRequestCaptor.getAllValues();\n+\n+    assertThat(requests).hasSize(2);\n+\n+    final List<RowToInsert> researcherRows = requests.get(0).getRows();\n+    assertThat(researcherRows).hasSize(3);\n+    assertThat(researcherRows.get(0).getId()).hasLength(16);\n+    assertThat(researcherRows.get(0).getContent()).hasSize(RESEARCHER_COLUMN_COUNT + 1);\n+\n+    final List<RowToInsert> workspace1Rows = requests.get(1).getRows();", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMDQ4NA==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472500484", "bodyText": "should we test the streaming version of this?", "author": "jmthibault79", "createdAt": "2020-08-18T21:21:50Z", "path": "api/src/test/java/org/pmiops/workbench/reporting/ReportingUploadServiceTest.java", "diffHunk": "@@ -127,12 +161,18 @@ public void testUploadSnapshot() {\n \n     final String expandedQuery =\n         QueryParameterValues.formatQuery(QueryParameterValues.replaceNamedParameters(job0));\n-\n     assertThat(expandedQuery).containsMatch(\"INSERT\\\\s+INTO\");\n+\n+    assertThat(\n+            (double)\n+                timestampQpvToInstant(jobs.get(1).getNamedParameters().get(\"creation_time__0\"))\n+                    .toEpochMilli())\n+        .isWithin(500.0)\n+        .of(THEN.toEpochMilli());\n   }\n \n   @Test\n-  public void testUploadSnapshot_batchInserts() {\n+  public void testUploadSnapshot_dmlBatchInserts() {", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MTA2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473191063", "bodyText": "We do, right below. There's no manual batching with the stream approach though. The BQ client does that for us I'm assuming.", "author": "jaycarlton", "createdAt": "2020-08-19T17:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMDQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNzEwNg==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472517106", "bodyText": "What is the advantage of programmatic vs declarative transaction management in the case?", "author": "freemabd", "createdAt": "2020-08-18T21:58:56Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/ReportingSnapshotServiceImpl.java", "diffHunk": "@@ -1,45 +1,68 @@\n package org.pmiops.workbench.reporting;\n \n+import com.google.common.base.Stopwatch;\n import java.time.Clock;\n import java.util.List;\n import java.util.Random;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n import org.pmiops.workbench.db.dao.UserService;\n import org.pmiops.workbench.db.model.DbUser;\n import org.pmiops.workbench.db.model.DbWorkspace;\n import org.pmiops.workbench.model.ReportingResearcher;\n import org.pmiops.workbench.model.ReportingSnapshot;\n import org.pmiops.workbench.model.ReportingWorkspace;\n import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n+import org.springframework.transaction.PlatformTransactionManager;\n+import org.springframework.transaction.support.TransactionTemplate;\n \n @Service\n public class ReportingSnapshotServiceImpl implements ReportingSnapshotService {\n+  private static final Logger log = Logger.getLogger(ReportingSnapshotServiceImpl.class.getName());\n \n   private final Clock clock;\n   private final ReportingMapper reportingMapper;\n-  private Random random;\n+  private final Random random;\n+  private final PlatformTransactionManager platformTransactionManager;\n+  private final Provider<Stopwatch> stopwatchProvider;\n   private final UserService userService;\n   private final WorkspaceService workspaceService;\n \n   public ReportingSnapshotServiceImpl(\n       Clock clock,\n       ReportingMapper reportingMapper,\n       Random random,\n+      @Qualifier(\"transactionManager\") PlatformTransactionManager platformTransactionManager,\n+      Provider<Stopwatch> stopwatchProvider,\n       UserService userService,\n       WorkspaceService workspaceService) {\n     this.clock = clock;\n     this.reportingMapper = reportingMapper;\n     this.random = random;\n+    this.platformTransactionManager = platformTransactionManager;\n+    this.stopwatchProvider = stopwatchProvider;\n     this.userService = userService;\n     this.workspaceService = workspaceService;\n   }\n \n   @Override\n   public ReportingSnapshot takeSnapshot() {\n-    return new ReportingSnapshot()\n-        .captureTimestamp(clock.millis())\n-        .researchers(getResearchers())\n-        .workspaces(getWorkspaces());\n+    final Stopwatch stopwatch = stopwatchProvider.get().start();\n+    final TransactionTemplate template = new TransactionTemplate(platformTransactionManager);", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxMjAwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473312005", "bodyText": "It's nice to have an explicit transaction boundary. I haven't yet gotten to  the point where I trust @Transactional, but I may get there. I also didn't think I could set it to read only using the annotation initially, though that certainly appears doable.\nI  suppose I  could also do manual rollback or reporting of status, but I'm not sure how much sense that makes. Basically it's just reassuring to see something as important as a transaction have actual code describing it.\nSo no real justification I guess. I can convert back to @Transactional if that's the standard.", "author": "jaycarlton", "createdAt": "2020-08-19T20:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNzEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM0NTMwNg==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473345306", "bodyText": "I prefer to stay away from programmatic transaction management in most cases as it ties the code to transaction management logic. This seems like a pretty straight forward situation that is perfect for @Transactional.", "author": "freemabd", "createdAt": "2020-08-19T21:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNzEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyODMzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472528339", "bodyText": "Do we use this enum for anything? Recovering from bad states or is that coming in a future PR?", "author": "freemabd", "createdAt": "2020-08-18T22:27:33Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/ReportingJobResult.java", "diffHunk": "@@ -2,7 +2,6 @@\n \n public enum ReportingJobResult {", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MTA1MQ==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473181051", "bodyText": "Not yet. It's either coming out, or will be incorporated into a more sophisticated return type. I haven't decided whether to roll up exceptions and keep going or not. But I have an error handling/correcting story in the backlog.", "author": "jaycarlton", "createdAt": "2020-08-19T16:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyODMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM2NTE0Ng==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r472365146", "bodyText": "I had it set up where the second function was a function of the first one, but there's an inconsistency (or two) in how timestamps are expected to be formatted, so I had to separate them.", "author": "jaycarlton", "createdAt": "2020-08-18T17:31:49Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/insertion/WorkspaceParameter.java", "diffHunk": "@@ -1,25 +1,44 @@\n package org.pmiops.workbench.reporting.insertion;\n \n+import static org.pmiops.workbench.cohortbuilder.util.QueryParameterValues.QPV_TIMESTAMP_FORMATTER;\n+import static org.pmiops.workbench.cohortbuilder.util.QueryParameterValues.ROW_TO_INSERT_TIMESTAMP_FORMATTER;\n+\n import com.google.cloud.bigquery.QueryParameterValue;\n+import java.time.Instant;\n import java.util.function.Function;\n import org.pmiops.workbench.model.ReportingWorkspace;\n \n public enum WorkspaceParameter implements QueryParameterColumn<ReportingWorkspace> {\n-  WORKSPACE_ID(\"workspace_id\", w -> QueryParameterValue.int64(w.getWorkspaceId())),\n-  CREATOR_ID(\"creator_id\", w -> QueryParameterValue.int64(w.getCreatorId())),\n-  NAME(\"name\", w -> QueryParameterValue.string(w.getName())),\n-  FAKE_SIZE(\"fake_size\", w -> QueryParameterValue.int64(w.getFakeSize())),\n+  WORKSPACE_ID(\n+      \"workspace_id\",\n+      ReportingWorkspace::getWorkspaceId,\n+      w -> QueryParameterValue.int64(w.getWorkspaceId())),", "originalCommit": "9e5d7875d026f088a1733c8528178b25e4b89087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4MjQyNw==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473182427", "bodyText": "@jmthibault79 here is the streaming test. It's actually a bit harder to unit test, because not all of the conversions are documented (which gave me fits).", "author": "jaycarlton", "createdAt": "2020-08-19T16:57:37Z", "path": "api/src/test/java/org/pmiops/workbench/reporting/ReportingUploadServiceTest.java", "diffHunk": "@@ -157,17 +197,54 @@ public void testUploadSnapshot_batchInserts() {\n                 .fakeSize(4444L)\n                 .creatorId(101L)));\n \n-    reportingUploadService.uploadSnapshot(largeSnapshot);\n+    reportingUploadServiceDmlImpl.uploadSnapshot(largeSnapshot);\n     verify(mockBigQueryService, times(6))\n         .executeQuery(queryJobConfigurationCaptor.capture(), anyLong());\n \n     final List<QueryJobConfiguration> jobs = queryJobConfigurationCaptor.getAllValues();\n     assertThat(jobs).hasSize(6);\n-    final int researcherColumnCount = 4;\n-    final int workspaceColumnCount = 5;\n \n-    assertThat(jobs.get(0).getNamedParameters()).hasSize(researcherColumnCount * 5 + 1);\n-    assertThat(jobs.get(4).getNamedParameters()).hasSize(researcherColumnCount + 1);\n-    assertThat(jobs.get(5).getNamedParameters()).hasSize(workspaceColumnCount + 1);\n+    assertThat(jobs.get(0).getNamedParameters()).hasSize(RESEARCHER_COLUMN_COUNT * 5 + 1);\n+    assertThat(jobs.get(4).getNamedParameters()).hasSize(RESEARCHER_COLUMN_COUNT + 1);\n+    assertThat(jobs.get(5).getNamedParameters()).hasSize(WORKSPACE_COLUMN_COUNT + 1);\n+\n+    final QueryParameterValue creationTime =\n+        jobs.get(5).getNamedParameters().get(\"creation_time__0\");\n+    assertThat(creationTime).isNotNull();\n+    final Instant instant = QueryParameterValues.timestampQpvToInstant(creationTime);\n+    assertThat((double) instant.toEpochMilli()).isWithin(500.0).of(THEN.toEpochMilli());\n+  }\n+\n+  @Test\n+  public void testUploadSnapshot_streaming() {", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE4OTI4NQ==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473189285", "bodyText": "Note  I'm testing two different implementations of upload here. All this fanciness is really only necessary because my local DB doesn't have nearly as many rows as the Test DB, but I don't want to get into a one-off deployments. We can also compare test against Perf, for example.", "author": "jaycarlton", "createdAt": "2020-08-19T17:04:20Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/ReportingServiceImpl.java", "diffHunk": "@@ -1,24 +1,52 @@\n package org.pmiops.workbench.reporting;\n \n+import javax.inject.Provider;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n import org.pmiops.workbench.model.ReportingSnapshot;\n+import org.springframework.beans.factory.annotation.Qualifier;\n import org.springframework.stereotype.Service;\n \n @Service\n public class ReportingServiceImpl implements ReportingService {\n \n-  private final ReportingUploadService reportingUploadService;\n+  private static enum UploadMethod {\n+    DML,\n+    STREAMING;\n+  }\n+\n   private final ReportingSnapshotService reportingSnapshotService;\n+  private final ReportingUploadService reportingUploadServiceDmlImpl;\n+  private final ReportingUploadService reportingUploadServiceStreamingImpl;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n \n   public ReportingServiceImpl(\n-      ReportingUploadService reportingUploadService,\n-      ReportingSnapshotService reportingSnapshotService) {\n-    this.reportingUploadService = reportingUploadService;\n+      @Qualifier(\"REPORTING_UPLOAD_SERVICE_DML_IMPL\")", "originalCommit": "8e99b18171e5ec807c6fab02c128388ef4d5363d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0369524b76794f935e8ee47a377ece6734c020e3", "url": "https://github.com/all-of-us/workbench/commit/0369524b76794f935e8ee47a377ece6734c020e3", "message": "streaming upload implementation", "committedDate": "2020-08-19T20:19:32Z", "type": "commit"}, {"oid": "ad3348e289690b0211a7b2130227776b662c4ef1", "url": "https://github.com/all-of-us/workbench/commit/ad3348e289690b0211a7b2130227776b662c4ef1", "message": "fixup test", "committedDate": "2020-08-19T22:46:16Z", "type": "commit"}, {"oid": "258ed02210d974c789f7d7b9a73290ee1b4341a7", "url": "https://github.com/all-of-us/workbench/commit/258ed02210d974c789f7d7b9a73290ee1b4341a7", "message": "updates to sync with origin", "committedDate": "2020-08-19T22:57:48Z", "type": "commit"}, {"oid": "8e6d437302ce78bc27f154f294573a8c12644970", "url": "https://github.com/all-of-us/workbench/commit/8e6d437302ce78bc27f154f294573a8c12644970", "message": "remove unused import", "committedDate": "2020-08-19T23:01:13Z", "type": "commit"}, {"oid": "27b8d2693db465fbbf768675682740920e74ba68", "url": "https://github.com/all-of-us/workbench/commit/27b8d2693db465fbbf768675682740920e74ba68", "message": "Merge branch 'master' into jaycarlrton/RW-5382", "committedDate": "2020-08-19T23:01:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk5ODI3Mw==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r473998273", "bodyText": "dupe", "author": "jmthibault79", "createdAt": "2020-08-20T13:52:07Z", "path": "api/src/test/java/org/pmiops/workbench/reporting/ReportingUploadServiceTest.java", "diffHunk": "@@ -1,18 +1,31 @@\n package org.pmiops.workbench.reporting;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyLong;\n import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static org.pmiops.workbench.cohortbuilder.util.QueryParameterValues.timestampQpvToInstant;\n+import static org.pmiops.workbench.cohortbuilder.util.QueryParameterValues.timestampStringToInstant;\n \n-import com.google.cloud.bigquery.EmptyTableResult;\n+import com.google.cloud.bigquery.InsertAllRequest;", "originalCommit": "27b8d2693db465fbbf768675682740920e74ba68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b4feae65b5ce4a0dcf74d98c484de58e2c313d43", "url": "https://github.com/all-of-us/workbench/commit/b4feae65b5ce4a0dcf74d98c484de58e2c313d43", "message": "fix tests and stopwatch mocking", "committedDate": "2020-08-20T14:19:40Z", "type": "commit"}, {"oid": "439ba9e07b1ac91a1ae07741e91ebd8892975184", "url": "https://github.com/all-of-us/workbench/commit/439ba9e07b1ac91a1ae07741e91ebd8892975184", "message": "spotless", "committedDate": "2020-08-20T14:20:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyMjA4MA==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r474022080", "bodyText": "Per Spring documentation:\nMethod visibility and @Transactional\nWhen using proxies, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings.\nThe annotation needs to exist on method called from outside the proxy class. So the takeSnapshot method would be a candidate for the annotation.", "author": "freemabd", "createdAt": "2020-08-20T14:23:05Z", "path": "api/src/main/java/org/pmiops/workbench/reporting/ReportingSnapshotServiceImpl.java", "diffHunk": "@@ -1,59 +1,100 @@\n package org.pmiops.workbench.reporting;\n \n+import com.google.common.base.Stopwatch;\n import java.time.Clock;\n import java.util.List;\n import java.util.Random;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n import org.pmiops.workbench.db.dao.UserService;\n import org.pmiops.workbench.db.model.DbUser;\n import org.pmiops.workbench.db.model.DbWorkspace;\n-import org.pmiops.workbench.model.ReportingResearcher;\n import org.pmiops.workbench.model.ReportingSnapshot;\n import org.pmiops.workbench.model.ReportingWorkspace;\n+import org.pmiops.workbench.utils.LogFormatters;\n import org.pmiops.workbench.workspaces.WorkspaceService;\n import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Transactional;\n \n @Service\n public class ReportingSnapshotServiceImpl implements ReportingSnapshotService {\n+  private static final Logger log = Logger.getLogger(ReportingSnapshotServiceImpl.class.getName());\n \n   private final Clock clock;\n   private final ReportingMapper reportingMapper;\n-  private Random random;\n+  private final Random random;\n+  private final Provider<Stopwatch> stopwatchProvider;\n   private final UserService userService;\n   private final WorkspaceService workspaceService;\n \n+  // Define immutable value class to hold results of queries within a transaction. Mapping to\n+  // Reporting DTO classes will happen outside the transaction.\n+  private static class EntityBundle {\n+    private final List<DbUser> users;\n+    private final List<DbWorkspace> workspaces;\n+\n+    public EntityBundle(List<DbUser> users, List<DbWorkspace> workspaces) {\n+      this.users = users;\n+      this.workspaces = workspaces;\n+    }\n+\n+    public List<DbUser> getUsers() {\n+      return users;\n+    }\n+\n+    public List<DbWorkspace> getWorkspaces() {\n+      return workspaces;\n+    }\n+  }\n+\n   public ReportingSnapshotServiceImpl(\n       Clock clock,\n       ReportingMapper reportingMapper,\n       Random random,\n+      Provider<Stopwatch> stopwatchProvider,\n       UserService userService,\n       WorkspaceService workspaceService) {\n     this.clock = clock;\n     this.reportingMapper = reportingMapper;\n     this.random = random;\n+    this.stopwatchProvider = stopwatchProvider;\n     this.userService = userService;\n     this.workspaceService = workspaceService;\n   }\n \n   @Override\n   public ReportingSnapshot takeSnapshot() {\n-    return new ReportingSnapshot()\n-        .captureTimestamp(clock.millis())\n-        .researchers(getResearchers())\n-        .workspaces(getWorkspaces());\n-  }\n+    final EntityBundle entityBundle = getApplicationDbData();\n+    final Stopwatch stopwatch = stopwatchProvider.get().start();\n \n-  private List<ReportingResearcher> getResearchers() {\n-    final List<DbUser> users = userService.getAllUsers();\n-    return reportingMapper.toReportingResearcherList(users);\n+    final List<ReportingWorkspace> workspaces =\n+        reportingMapper.toReportingWorkspaceList(entityBundle.getWorkspaces());\n+    for (ReportingWorkspace model : workspaces) {\n+      model.setFakeSize(\n+          getFakeSize()); // TODO(jaycarlton): remove after initial query & view testing\n+    }\n+\n+    final ReportingSnapshot result =\n+        new ReportingSnapshot()\n+            .captureTimestamp(clock.millis())\n+            .researchers(reportingMapper.toReportingResearcherList(entityBundle.getUsers()))\n+            .workspaces(workspaces);\n+    stopwatch.stop();\n+    log.info(LogFormatters.duration(\"Conversion to ReportingSnapshot\", stopwatch.elapsed()));\n+    return result;\n   }\n \n-  private List<ReportingWorkspace> getWorkspaces() {\n+  // Retrieve all the data we need from the MySQL database in a single transaction for\n+  // consistency.\n+  @Transactional(readOnly = true)\n+  protected EntityBundle getApplicationDbData() {", "originalCommit": "27b8d2693db465fbbf768675682740920e74ba68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1NDc2NQ==", "url": "https://github.com/all-of-us/workbench/pull/3882#discussion_r474054765", "bodyText": "Oh ok. I was hoping to avoid the time to convert the entries extending the transaction any longer, but I bet that's negligible in practice.", "author": "jaycarlton", "createdAt": "2020-08-20T15:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyMjA4MA=="}], "type": "inlineReview"}, {"oid": "3778aecec5c53372b70a0c535613805d2c197e5b", "url": "https://github.com/all-of-us/workbench/commit/3778aecec5c53372b70a0c535613805d2c197e5b", "message": "Merge branch 'master' into jaycarlrton/RW-5382", "committedDate": "2020-08-20T15:05:54Z", "type": "commit"}, {"oid": "70d32945d23f22936cd0596835591657b327be39", "url": "https://github.com/all-of-us/workbench/commit/70d32945d23f22936cd0596835591657b327be39", "message": "put transaction on public method", "committedDate": "2020-08-20T15:18:40Z", "type": "commit"}]}