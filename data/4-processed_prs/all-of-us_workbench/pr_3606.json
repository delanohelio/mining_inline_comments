{"pr_number": 3606, "pr_title": "[risk=no][RW-4921] Audit Log Entry API", "pr_createdAt": "2020-05-20T14:52:56Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3606", "timeline": [{"oid": "947b794267e9aee534f26ead45eaea7601ad7ad4", "url": "https://github.com/all-of-us/workbench/commit/947b794267e9aee534f26ead45eaea7601ad7ad4", "message": "most of the types", "committedDate": "2020-05-20T14:51:59Z", "type": "commit"}, {"oid": "7a7dc3fc5696f77e27af01eb5b887a02c8fc7c40", "url": "https://github.com/all-of-us/workbench/commit/7a7dc3fc5696f77e27af01eb5b887a02c8fc7c40", "message": "first cut at querying", "committedDate": "2020-05-20T17:22:05Z", "type": "commit"}, {"oid": "283383d854b2a1def54a53ae54688b4bdf22e3bb", "url": "https://github.com/all-of-us/workbench/commit/283383d854b2a1def54a53ae54688b4bdf22e3bb", "message": "spotless", "committedDate": "2020-05-20T17:22:47Z", "type": "commit"}, {"oid": "7da66e72450e2bb08554323593a4275498f58ccc", "url": "https://github.com/all-of-us/workbench/commit/7da66e72450e2bb08554323593a4275498f58ccc", "message": "first working version", "committedDate": "2020-05-20T22:28:31Z", "type": "commit"}, {"oid": "09ab27c9e19d1635d4324f5d5442077b869ba7b8", "url": "https://github.com/all-of-us/workbench/commit/09ab27c9e19d1635d4324f5d5442077b869ba7b8", "message": "comment out", "committedDate": "2020-05-21T12:43:33Z", "type": "commit"}, {"oid": "8055fa186cfd307f91a95c3f7c5c601cd4ceb364", "url": "https://github.com/all-of-us/workbench/commit/8055fa186cfd307f91a95c3f7c5c601cd4ceb364", "message": "fix path [skip ci]", "committedDate": "2020-05-21T12:46:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzMTMwNg==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r428631306", "bodyText": "There's some duplication here, but it's because I can't guarantee we won't need to rename a table separately from the dataset or log. For example, adding a column to the JSON in the log means we technically need a new BQ schema for the table.", "author": "jaycarlton", "createdAt": "2020-05-21T12:50:42Z", "path": "api/config/config_local.json", "diffHunk": "@@ -105,7 +105,9 @@\n     \"enableEventDateModifier\": false\n   },\n   \"actionAudit\": {\n-    \"logName\": \"workbench-action-audit-local\"\n+    \"logName\": \"workbench-action-audit-local\",", "originalCommit": "8055fa186cfd307f91a95c3f7c5c601cd4ceb364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzMTkzMA==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r428631930", "bodyText": "I'm really close to shopping for a template engine for this. I'm already up to three ordered substitutions and I don't have any time constraints, ordering options, etc.", "author": "jaycarlton", "createdAt": "2020-05-21T12:52:01Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.pmiops.workbench.actionaudit;\n+\n+import com.google.cloud.bigquery.FieldValue;\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.QueryJobConfiguration;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.stream.StreamSupport;\n+import javax.annotation.Nullable;\n+import javax.inject.Provider;\n+import org.joda.time.Instant;\n+import org.pmiops.workbench.api.BigQueryService;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n+import org.pmiops.workbench.model.AuditLogEntriesResponse;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n+\n+  private BigQueryService bigQueryService;\n+  private Provider<WorkbenchConfig> workbenchConfigProvider;\n+  private WorkspaceService workspaceService;\n+  public static final String WORKSPACE_EVENTS_QUERY_STRING_FORMAT =", "originalCommit": "8055fa186cfd307f91a95c3f7c5c601cd4ceb364", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzODgxMw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r428638813", "bodyText": "Maybe look to https://cloud.google.com/bigquery/docs/parameterized-queries ? I think we use this on the CB side of the house, so there should be examples in our codebase (like this).", "author": "gjuggler", "createdAt": "2020-05-21T13:06:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzMTkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYzNTY1Nw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r428635657", "bodyText": "This is the first attempt at the more generic date & time handling. Maps to Joda DateTime in Java and Date in TypeScript.", "author": "jaycarlton", "createdAt": "2020-05-21T12:59:36Z", "path": "api/src/main/resources/workbench-api.yaml", "diffHunk": "@@ -7280,3 +7305,93 @@ definitions:\n         format: int64\n       conceptName:\n         type: string\n+  AuditLogEntriesResponse:\n+    type: object\n+    description: >\n+      Represents the results of a query into the audit dataset in BigQery without\n+      filtering or transformation. This response type is a stopgap until we develop\n+      high-level queries with a better semantic mapping to the concepts and rules\n+      governing them, which is why a freeform queryMetadata field is tolerable for\n+      now.\n+    required:\n+    - logEntries\n+    - queryMetadata\n+    properties:\n+      logEntries:\n+        type: array\n+        items:\n+          \"$ref\": \"#/definitions/AuditLogEntry\"\n+      queryMetadata:\n+        description: >\n+          Since the audit system uses SQL database IDs and the rest of hte API layer\n+          does not, it's helpful to return additional properties in order to assist\n+          the client in interpreting the results.\n+        type: object\n+        additionalProperties: true\n+  AuditLogEntry:\n+    description: >\n+      Representation of the BigQuery Audit Log entry, post-translation from Stackdriver logging.\n+      All fields are treated as optional here, as there are no non-null constraints in the BigQery\n+      dataset.\n+\n+      It's possible that due to some error now or in the past that some columns might not match\n+      their expected values, though we take pains to avoid that. Regardless, nothing in this type\n+      definition is stricter than the BigQuery schema.\n+    type: object\n+    properties:\n+      actionId:\n+        description: Unique ID for this action. Used for grouping similar events under a\n+          single action, though in this representation we're returning a straight list of rows.\n+        type: string\n+        format: uuid\n+      actionType:\n+        description: >\n+          Defines what action is taking place in this event. (There can be several ACTION_TYPEs\n+          in a single Action assigned to different events. String representation of the ActionType\n+          enum (not generated).\n+        type: string\n+      agentId:\n+        description: >\n+          ID for the Agent (typically a User). If there's a SQL table for this agent type,\n+          this this is the PK for that table (e.g. user_id).\n+        type: integer\n+        format: int64\n+      agentUsername:\n+        description: >\n+          Username of the user or administrator taking the action. This is the agent_email column\n+          in BigQuery.\n+        type: string\n+        format: email\n+      agentType:\n+        description: >\n+          A member of the org.pmiops.workbench.actionaudit.AgentType enum (not generated). Since\n+          this is typed as a string in BigQuery (and not constrained to that type), we don't try\n+          to narrow the type in the admin API.\n+        type: string\n+      eventTime:\n+        description: >\n+          Timestamp recorded at time of the event. Called timestamp in the BigQuery table.\n+        type: string\n+        format: date-time", "originalCommit": "8055fa186cfd307f91a95c3f7c5c601cd4ceb364", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9d71b7d0503470fedbbf794a40581942885f5fcb", "url": "https://github.com/all-of-us/workbench/commit/9d71b7d0503470fedbbf794a40581942885f5fcb", "message": "start on unit", "committedDate": "2020-05-21T15:52:15Z", "type": "commit"}, {"oid": "17a9c1f948e7d47b841dc00906a8d3c84f274b52", "url": "https://github.com/all-of-us/workbench/commit/17a9c1f948e7d47b841dc00906a8d3c84f274b52", "message": "cleanup", "committedDate": "2020-05-21T20:59:39Z", "type": "commit"}, {"oid": "991ad868ce4f8c686718fd48e0cd3266af0435d3", "url": "https://github.com/all-of-us/workbench/commit/991ad868ce4f8c686718fd48e0cd3266af0435d3", "message": "fix datetime comparison", "committedDate": "2020-05-21T21:40:38Z", "type": "commit"}, {"oid": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "url": "https://github.com/all-of-us/workbench/commit/244bf8a82376359e2e7c3a68afc03518f88f6aee", "message": "no result test", "committedDate": "2020-05-21T22:32:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIyMzc0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429223742", "bodyText": "Maybe add some validation for checking a max limit on amount of AuditLogEntry that can be requested to keep OOM errors from happening on GAE. My assumption is that these audit tables can become large over time.", "author": "freemabd", "createdAt": "2020-05-22T12:43:42Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.pmiops.workbench.actionaudit;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.QueryJobConfiguration;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.api.BigQueryService;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n+import org.pmiops.workbench.model.AuditLogEntriesResponse;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.utils.FieldValues;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n+\n+  private BigQueryService bigQueryService;\n+  private Provider<WorkbenchConfig> workbenchConfigProvider;\n+  private static final String WORKSPACE_EVENTS_QUERY_STRING_FORMAT =\n+      \"SELECT\\n\"\n+          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) as event_time,\\n\"\n+          + \"  jsonPayload.agent_type AS agent_type,\\n\"\n+          + \"  CAST(jsonPayload.agent_id AS INT64) AS agent_id,\\n\"\n+          + \"  jsonPayload.agent_email AS agent_username,\\n\"\n+          + \"  jsonPayload.action_id AS action_id,\\n\"\n+          + \"  jsonPayload.action_type AS action_type,\\n\"\n+          + \"  jsonPayload.target_type AS target_type,\\n\"\n+          + \"  CAST(jsonPayload.target_id AS INT64) AS target_id,\\n\"\n+          + \"  jsonPayload.target_property AS target_property,\\n\"\n+          + \"  jsonPayload.prev_value AS prev_value,\\n\"\n+          + \"  jsonPayload.new_value AS new_value\\n\"\n+          + \"FROM %s\\n\"\n+          + \"WHERE jsonPayload.target_id = %d AND\\n\"\n+          + \"  jsonPayload.target_type = 'WORKSPACE'\\n\"\n+          + \"ORDER BY event_time, agent_id, action_id\\n\"\n+          + \"LIMIT %d\";\n+\n+  public ActionAuditQueryServiceImpl(\n+      BigQueryService bigQueryService, Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.bigQueryService = bigQueryService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public AuditLogEntriesResponse queryEventsForWorkspace(long workspaceDatabaseId, long limit) {", "originalCommit": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NjMxNw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429486317", "bodyText": "You mean at the service level? Sure. Maybe 1000 would work. Beyond that we'd need pagination, which is simple here since it only grows by appending.\nAuditable events are relatively rare, and the ending should be restricted to admin users.", "author": "jaycarlton", "createdAt": "2020-05-22T23:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIyMzc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIyODE0OA==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429228148", "bodyText": "Would it be useful for the client to be able to request a different ordering? Maybe a date range of audit logs?", "author": "freemabd", "createdAt": "2020-05-22T12:53:04Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.pmiops.workbench.actionaudit;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.QueryJobConfiguration;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.api.BigQueryService;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n+import org.pmiops.workbench.model.AuditLogEntriesResponse;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.utils.FieldValues;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n+\n+  private BigQueryService bigQueryService;\n+  private Provider<WorkbenchConfig> workbenchConfigProvider;\n+  private static final String WORKSPACE_EVENTS_QUERY_STRING_FORMAT =\n+      \"SELECT\\n\"\n+          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) as event_time,\\n\"\n+          + \"  jsonPayload.agent_type AS agent_type,\\n\"\n+          + \"  CAST(jsonPayload.agent_id AS INT64) AS agent_id,\\n\"\n+          + \"  jsonPayload.agent_email AS agent_username,\\n\"\n+          + \"  jsonPayload.action_id AS action_id,\\n\"\n+          + \"  jsonPayload.action_type AS action_type,\\n\"\n+          + \"  jsonPayload.target_type AS target_type,\\n\"\n+          + \"  CAST(jsonPayload.target_id AS INT64) AS target_id,\\n\"\n+          + \"  jsonPayload.target_property AS target_property,\\n\"\n+          + \"  jsonPayload.prev_value AS prev_value,\\n\"\n+          + \"  jsonPayload.new_value AS new_value\\n\"\n+          + \"FROM %s\\n\"\n+          + \"WHERE jsonPayload.target_id = %d AND\\n\"\n+          + \"  jsonPayload.target_type = 'WORKSPACE'\\n\"\n+          + \"ORDER BY event_time, agent_id, action_id\\n\"", "originalCommit": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NTg5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429485897", "bodyText": "Definitely. The plan is to take in severe optional quiet params. I thought this was a reasonable stopping point until we design the UI. Happy to add them now though.", "author": "jaycarlton", "createdAt": "2020-05-22T23:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIyODE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzMjcwMw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429232703", "bodyText": "I would use a named parameter for any values injected from the client. We use the QueryParameterUtil  to help with this in CB land. Example: \n  \n    \n      workbench/api/src/main/java/org/pmiops/workbench/cohortbuilder/SearchGroupItemQueryBuilder.java\n    \n    \n         Line 401\n      in\n      c516872\n    \n    \n    \n    \n\n        \n          \n           QueryParameterUtil.addQueryParameterValue(", "author": "freemabd", "createdAt": "2020-05-22T13:02:34Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.pmiops.workbench.actionaudit;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.QueryJobConfiguration;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.api.BigQueryService;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n+import org.pmiops.workbench.model.AuditLogEntriesResponse;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.utils.FieldValues;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n+\n+  private BigQueryService bigQueryService;\n+  private Provider<WorkbenchConfig> workbenchConfigProvider;\n+  private static final String WORKSPACE_EVENTS_QUERY_STRING_FORMAT =\n+      \"SELECT\\n\"\n+          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) as event_time,\\n\"\n+          + \"  jsonPayload.agent_type AS agent_type,\\n\"\n+          + \"  CAST(jsonPayload.agent_id AS INT64) AS agent_id,\\n\"\n+          + \"  jsonPayload.agent_email AS agent_username,\\n\"\n+          + \"  jsonPayload.action_id AS action_id,\\n\"\n+          + \"  jsonPayload.action_type AS action_type,\\n\"\n+          + \"  jsonPayload.target_type AS target_type,\\n\"\n+          + \"  CAST(jsonPayload.target_id AS INT64) AS target_id,\\n\"\n+          + \"  jsonPayload.target_property AS target_property,\\n\"\n+          + \"  jsonPayload.prev_value AS prev_value,\\n\"\n+          + \"  jsonPayload.new_value AS new_value\\n\"\n+          + \"FROM %s\\n\"\n+          + \"WHERE jsonPayload.target_id = %d AND\\n\"", "originalCommit": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMzIwNg==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429503206", "bodyText": "Brilliant! I was wondering what those were for.", "author": "jaycarlton", "createdAt": "2020-05-23T01:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzMjcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzMzA3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429233072", "bodyText": "Nice. I like this pattern.", "author": "freemabd", "createdAt": "2020-05-22T13:03:17Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.pmiops.workbench.actionaudit;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.QueryJobConfiguration;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.api.BigQueryService;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n+import org.pmiops.workbench.model.AuditLogEntriesResponse;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.utils.FieldValues;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n+\n+  private BigQueryService bigQueryService;\n+  private Provider<WorkbenchConfig> workbenchConfigProvider;\n+  private static final String WORKSPACE_EVENTS_QUERY_STRING_FORMAT =\n+      \"SELECT\\n\"\n+          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) as event_time,\\n\"\n+          + \"  jsonPayload.agent_type AS agent_type,\\n\"\n+          + \"  CAST(jsonPayload.agent_id AS INT64) AS agent_id,\\n\"\n+          + \"  jsonPayload.agent_email AS agent_username,\\n\"\n+          + \"  jsonPayload.action_id AS action_id,\\n\"\n+          + \"  jsonPayload.action_type AS action_type,\\n\"\n+          + \"  jsonPayload.target_type AS target_type,\\n\"\n+          + \"  CAST(jsonPayload.target_id AS INT64) AS target_id,\\n\"\n+          + \"  jsonPayload.target_property AS target_property,\\n\"\n+          + \"  jsonPayload.prev_value AS prev_value,\\n\"\n+          + \"  jsonPayload.new_value AS new_value\\n\"\n+          + \"FROM %s\\n\"\n+          + \"WHERE jsonPayload.target_id = %d AND\\n\"\n+          + \"  jsonPayload.target_type = 'WORKSPACE'\\n\"\n+          + \"ORDER BY event_time, agent_id, action_id\\n\"\n+          + \"LIMIT %d\";\n+\n+  public ActionAuditQueryServiceImpl(\n+      BigQueryService bigQueryService, Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.bigQueryService = bigQueryService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public AuditLogEntriesResponse queryEventsForWorkspace(long workspaceDatabaseId, long limit) {\n+    final ActionAuditConfig actionAuditConfig = workbenchConfigProvider.get().actionAudit;\n+    final String fullyQualifiedTableName =\n+        String.format(\n+            \"`%s.%s.%s`\",\n+            workbenchConfigProvider.get().server.projectId,\n+            actionAuditConfig.bigQueryDataset,\n+            actionAuditConfig.bigQueryTable);\n+\n+    final String queryString =\n+        String.format(\n+            WORKSPACE_EVENTS_QUERY_STRING_FORMAT,\n+            fullyQualifiedTableName,\n+            workspaceDatabaseId,\n+            limit);\n+    final QueryJobConfiguration queryJobConfiguration =\n+        QueryJobConfiguration.newBuilder(queryString).setUseLegacySql(false).build();\n+\n+    final TableResult tableResult = bigQueryService.executeQuery(queryJobConfiguration);\n+\n+    // Transform all results on all pages.\n+    final List<AuditLogEntry> logEntries =\n+        StreamSupport.stream(tableResult.iterateAll().spliterator(), false)\n+            .map(this::fieldValueListToAditLogEntry)\n+            .collect(ImmutableList.toImmutableList());\n+\n+    final ImmutableMap<String, String> metadata =\n+        ImmutableMap.of(\n+            \"workspaceDatabaseId\", Long.toString(workspaceDatabaseId), \"query\", queryString);\n+\n+    return new AuditLogEntriesResponse().logEntries(logEntries).queryMetadata(metadata);\n+  }\n+\n+  private AuditLogEntry fieldValueListToAditLogEntry(FieldValueList row) {\n+    final AuditLogEntry entry = new AuditLogEntry();\n+    FieldValues.getString(row, \"action_id\").ifPresent(entry::setActionId);", "originalCommit": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzNDkzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429234939", "bodyText": "Nice. BigQueryService is doing something similar to this class. I think we could move this functionality into the BigQueryService and replace it's methods that are very similar, like getString(List row, int index), getBoolean(List row, int index).. etc.\n\n  \n    \n      workbench/api/src/main/java/org/pmiops/workbench/api/BigQueryService.java\n    \n    \n         Line 126\n      in\n      c516872\n    \n    \n    \n    \n\n        \n          \n           public String getString(List<FieldValue> row, int index) {", "author": "freemabd", "createdAt": "2020-05-22T13:07:26Z", "path": "api/src/main/java/org/pmiops/workbench/utils/FieldValues.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.pmiops.workbench.utils;\n+\n+import com.google.cloud.bigquery.FieldList;\n+import com.google.cloud.bigquery.FieldValue;\n+import com.google.cloud.bigquery.FieldValue.Attribute;\n+import com.google.cloud.bigquery.FieldValueList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.joda.time.DateTime;\n+\n+/** Utility class for working with FieldValueLists, FieldValues, and Fields */\n+public final class FieldValues {", "originalCommit": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NjYwNg==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429486606", "bodyText": "Yeah. I kinda like static helpers to live in a class named after the thing, and don't really expect static methods on services. But if you only need this when you already have BigQueryService, that makes sense too.", "author": "jaycarlton", "createdAt": "2020-05-22T23:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzNDkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQzNTE5OA==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r430435198", "bodyText": "I decided to stick with a utility class so that I can use the methods inside an enum class (which can't inject BigQueryService). There are no dependencies on BigQuery itself.\nHowever, I've pretty much abandoned my enum idea that would've required these be static. I put a TODO in to tackle this in the next go-round.", "author": "jaycarlton", "createdAt": "2020-05-26T14:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzNDkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzNjE4NQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429236185", "bodyText": "Is this method useful outside of ActionAuditQueryServiceTest? Otherwise i would move this and the method above into the test itself.", "author": "freemabd", "createdAt": "2020-05-22T13:10:09Z", "path": "api/src/main/java/org/pmiops/workbench/utils/FieldValues.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.pmiops.workbench.utils;\n+\n+import com.google.cloud.bigquery.FieldList;\n+import com.google.cloud.bigquery.FieldValue;\n+import com.google.cloud.bigquery.FieldValue.Attribute;\n+import com.google.cloud.bigquery.FieldValueList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.joda.time.DateTime;\n+\n+/** Utility class for working with FieldValueLists, FieldValues, and Fields */\n+public final class FieldValues {\n+\n+  public static final int MICROSECONDS_IN_MILLISECOND = 1000;\n+\n+  private FieldValues() {}\n+\n+  /** Return an Optional<FieldValue> which is empty if the value is null and present if not. */\n+  public static Optional<FieldValue> getOptional(FieldValueList row, String fieldName) {\n+    final FieldValue value = row.get(fieldName);\n+    if (value.isNull()) {\n+      return Optional.empty();\n+    } else {\n+      return Optional.of(value);\n+    }\n+  }\n+\n+  public static Optional<String> getString(FieldValueList row, String fieldName) {\n+    return FieldValues.getOptional(row, fieldName).map(FieldValue::getStringValue);\n+  }\n+\n+  public static Optional<Long> getLong(FieldValueList row, String fieldName) {\n+    return FieldValues.getOptional(row, fieldName).map(FieldValue::getLongValue);\n+  }\n+\n+  public static Optional<Long> getTimestampMicroseconds(FieldValueList row, String fieldName) {\n+    return FieldValues.getOptional(row, fieldName).map(FieldValue::getTimestampValue);\n+  }\n+\n+  public static Optional<DateTime> getDateTime(FieldValueList row, String fieldName) {\n+    return getTimestampMicroseconds(row, fieldName)\n+        .map(micro -> micro / MICROSECONDS_IN_MILLISECOND)\n+        .map(DateTime::new);\n+  }\n+\n+  public static FieldValue toPrimitiveFieldValue(Object value) {\n+    return FieldValue.of(Attribute.PRIMITIVE, value);\n+  }\n+\n+  public static FieldValueList buildFieldValueList(FieldList schemaFieldList, List<Object> values) {", "originalCommit": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NzExNA==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429487114", "bodyText": "Yes. It's useful anytime you want to construct a BQ result. I can make another utility class for these.", "author": "jaycarlton", "createdAt": "2020-05-22T23:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzNjE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzNjYwMQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429236601", "bodyText": "Could be private since nothing is accessing this method outside of this class.", "author": "freemabd", "createdAt": "2020-05-22T13:10:59Z", "path": "api/src/main/java/org/pmiops/workbench/utils/FieldValues.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.pmiops.workbench.utils;\n+\n+import com.google.cloud.bigquery.FieldList;\n+import com.google.cloud.bigquery.FieldValue;\n+import com.google.cloud.bigquery.FieldValue.Attribute;\n+import com.google.cloud.bigquery.FieldValueList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.joda.time.DateTime;\n+\n+/** Utility class for working with FieldValueLists, FieldValues, and Fields */\n+public final class FieldValues {\n+\n+  public static final int MICROSECONDS_IN_MILLISECOND = 1000;\n+\n+  private FieldValues() {}\n+\n+  /** Return an Optional<FieldValue> which is empty if the value is null and present if not. */\n+  public static Optional<FieldValue> getOptional(FieldValueList row, String fieldName) {\n+    final FieldValue value = row.get(fieldName);\n+    if (value.isNull()) {\n+      return Optional.empty();\n+    } else {\n+      return Optional.of(value);\n+    }\n+  }\n+\n+  public static Optional<String> getString(FieldValueList row, String fieldName) {\n+    return FieldValues.getOptional(row, fieldName).map(FieldValue::getStringValue);\n+  }\n+\n+  public static Optional<Long> getLong(FieldValueList row, String fieldName) {\n+    return FieldValues.getOptional(row, fieldName).map(FieldValue::getLongValue);\n+  }\n+\n+  public static Optional<Long> getTimestampMicroseconds(FieldValueList row, String fieldName) {\n+    return FieldValues.getOptional(row, fieldName).map(FieldValue::getTimestampValue);\n+  }\n+\n+  public static Optional<DateTime> getDateTime(FieldValueList row, String fieldName) {\n+    return getTimestampMicroseconds(row, fieldName)\n+        .map(micro -> micro / MICROSECONDS_IN_MILLISECOND)\n+        .map(DateTime::new);\n+  }\n+\n+  public static FieldValue toPrimitiveFieldValue(Object value) {", "originalCommit": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4Njg4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429486881", "bodyText": "I think it could be useful for testing. I'll annotate it visiblefortesting or make it private.", "author": "jaycarlton", "createdAt": "2020-05-22T23:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzNjYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzODY1OA==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429238658", "bodyText": "Also, since this reusable can we add methods for all the possible BQ sql types?", "author": "freemabd", "createdAt": "2020-05-22T13:15:07Z", "path": "api/src/main/java/org/pmiops/workbench/utils/FieldValues.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.pmiops.workbench.utils;\n+\n+import com.google.cloud.bigquery.FieldList;\n+import com.google.cloud.bigquery.FieldValue;\n+import com.google.cloud.bigquery.FieldValue.Attribute;\n+import com.google.cloud.bigquery.FieldValueList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.joda.time.DateTime;\n+\n+/** Utility class for working with FieldValueLists, FieldValues, and Fields */\n+public final class FieldValues {\n+\n+  public static final int MICROSECONDS_IN_MILLISECOND = 1000;\n+\n+  private FieldValues() {}\n+\n+  /** Return an Optional<FieldValue> which is empty if the value is null and present if not. */\n+  public static Optional<FieldValue> getOptional(FieldValueList row, String fieldName) {\n+    final FieldValue value = row.get(fieldName);\n+    if (value.isNull()) {\n+      return Optional.empty();\n+    } else {\n+      return Optional.of(value);\n+    }\n+  }\n+\n+  public static Optional<String> getString(FieldValueList row, String fieldName) {", "originalCommit": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4NjY5MQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r429486691", "bodyText": "If you give a mouse a \ud83c\udf6a...", "author": "jaycarlton", "createdAt": "2020-05-22T23:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIzODY1OA=="}], "type": "inlineReview"}, {"oid": "2dc97b1d64eb8aef54f926f245debfb2973efc27", "url": "https://github.com/all-of-us/workbench/commit/2dc97b1d64eb8aef54f926f245debfb2973efc27", "message": "add more methods", "committedDate": "2020-05-26T13:59:45Z", "type": "commit"}, {"oid": "e30da7e8e7c53a1c2f1726ec18099067823bf0cf", "url": "https://github.com/all-of-us/workbench/commit/e30da7e8e7c53a1c2f1726ec18099067823bf0cf", "message": "update description", "committedDate": "2020-05-26T14:12:58Z", "type": "commit"}, {"oid": "c1b76260834a181721fc33a502d12c49219d7837", "url": "https://github.com/all-of-us/workbench/commit/c1b76260834a181721fc33a502d12c49219d7837", "message": "test improvements", "committedDate": "2020-05-26T17:50:25Z", "type": "commit"}, {"oid": "179ae60005e7b90d3912ffb88838e0e8bed3538b", "url": "https://github.com/all-of-us/workbench/commit/179ae60005e7b90d3912ffb88838e0e8bed3538b", "message": "make more readable", "committedDate": "2020-05-26T19:32:27Z", "type": "commit"}, {"oid": "76857e11f40671678ead337e36b71453c3b75f11", "url": "https://github.com/all-of-us/workbench/commit/76857e11f40671678ead337e36b71453c3b75f11", "message": "docs and tests", "committedDate": "2020-05-26T19:49:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3MTIwMw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431171203", "bodyText": "Why use an enum rather than a series of string constants? Is this more or less just a way to semantically group this set of constants?", "author": "gjuggler", "createdAt": "2020-05-27T14:22:27Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.pmiops.workbench.actionaudit;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.QueryJobConfiguration;\n+import com.google.cloud.bigquery.QueryParameterValue;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import javax.inject.Provider;\n+import org.joda.time.DateTime;\n+import org.pmiops.workbench.api.BigQueryService;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n+import org.pmiops.workbench.model.AuditLogEntriesResponse;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.utils.FieldValues;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n+\n+  private static final int MICROSECONDS_IN_MILLISECOND = 1000;\n+\n+  enum Parameters {", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0NDYwMw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431344603", "bodyText": "Yes. Originally I was thinking we'd have all the column names as enum constants too and have some slick metadata to help. With ~5 parameters it's borderline helpful.", "author": "jaycarlton", "createdAt": "2020-05-27T18:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3MTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3Mjg2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431172867", "bodyText": "The database ID is one of the inputs to this method... it seems redundant / unnecessary to be returning that value.", "author": "gjuggler", "createdAt": "2020-05-27T14:24:32Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.pmiops.workbench.actionaudit;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.QueryJobConfiguration;\n+import com.google.cloud.bigquery.QueryParameterValue;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import javax.inject.Provider;\n+import org.joda.time.DateTime;\n+import org.pmiops.workbench.api.BigQueryService;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n+import org.pmiops.workbench.model.AuditLogEntriesResponse;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.utils.FieldValues;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n+\n+  private static final int MICROSECONDS_IN_MILLISECOND = 1000;\n+\n+  enum Parameters {\n+    LIMIT(\"limit\"),\n+    WORKSPACE_DB_ID(\"workspace_db_id\"),\n+    AFTER_INCLUSIVE(\"after_inclusive\"),\n+    BEFORE_EXCLUSIVE(\"before_exclusive\");\n+\n+    private String name;\n+\n+    Parameters(String name) {\n+      this.name = name;\n+    }\n+\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  private final BigQueryService bigQueryService;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n+\n+  private static final long MAX_QUERY_LIMIT = 1000L;\n+  // The table name can't be in a QueryParameterValue, so we substitute it with String.format()\n+  private static final String WORKSPACE_EVENTS_QUERY_STRING_FORMAT =\n+      \"SELECT\\n\"\n+          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) as event_time,\\n\"\n+          + \"  jsonPayload.agent_type AS agent_type,\\n\"\n+          + \"  CAST(jsonPayload.agent_id AS INT64) AS agent_id,\\n\"\n+          + \"  jsonPayload.agent_email AS agent_username,\\n\"\n+          + \"  jsonPayload.action_id AS action_id,\\n\"\n+          + \"  jsonPayload.action_type AS action_type,\\n\"\n+          + \"  jsonPayload.target_type AS target_type,\\n\"\n+          + \"  CAST(jsonPayload.target_id AS INT64) AS target_id,\\n\"\n+          + \"  jsonPayload.target_property AS target_property,\\n\"\n+          + \"  jsonPayload.prev_value AS prev_value,\\n\"\n+          + \"  jsonPayload.new_value AS new_value\\n\"\n+          + \"FROM %s\\n\"\n+          + \"WHERE jsonPayload.target_id = @workspace_db_id AND\\n\"\n+          + \"  jsonPayload.target_type = 'WORKSPACE' AND\\n\"\n+          + \"  @after_inclusive <= TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) AND\\n\"\n+          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) < @before_exclusive\\n\"\n+          + \"ORDER BY event_time, agent_id, action_id\\n\"\n+          + \"LIMIT @limit\";\n+\n+  public ActionAuditQueryServiceImpl(\n+      BigQueryService bigQueryService, Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.bigQueryService = bigQueryService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public AuditLogEntriesResponse queryEventsForWorkspace(\n+      long workspaceDatabaseId, long limit, DateTime afterInclusive, DateTime beforeExclusive) {\n+    final ActionAuditConfig actionAuditConfig = workbenchConfigProvider.get().actionAudit;\n+    final String fullyQualifiedTableName =\n+        String.format(\n+            \"`%s.%s.%s`\",\n+            workbenchConfigProvider.get().server.projectId,\n+            actionAuditConfig.bigQueryDataset,\n+            actionAuditConfig.bigQueryTable);\n+\n+    final String queryString =\n+        String.format(WORKSPACE_EVENTS_QUERY_STRING_FORMAT, fullyQualifiedTableName);\n+\n+    final QueryJobConfiguration queryJobConfiguration =\n+        QueryJobConfiguration.newBuilder(queryString)\n+            .setNamedParameters(\n+                ImmutableMap.of(\n+                    Parameters.WORKSPACE_DB_ID.getName(),\n+                        QueryParameterValue.int64(workspaceDatabaseId),\n+                    Parameters.LIMIT.getName(),\n+                        QueryParameterValue.int64(Math.max(limit, MAX_QUERY_LIMIT)),\n+                    Parameters.AFTER_INCLUSIVE.getName(),\n+                        QueryParameterValue.timestamp(\n+                            afterInclusive.getMillis() * MICROSECONDS_IN_MILLISECOND),\n+                    Parameters.BEFORE_EXCLUSIVE.getName(),\n+                        QueryParameterValue.timestamp(\n+                            beforeExclusive.getMillis() * MICROSECONDS_IN_MILLISECOND)))\n+            .build();\n+\n+    final TableResult tableResult = bigQueryService.executeQuery(queryJobConfiguration);\n+\n+    final List<AuditLogEntry> logEntries =\n+        StreamSupport.stream(tableResult.iterateAll().spliterator(), false)\n+            .map(this::fieldValueListToAditLogEntry)\n+            .collect(ImmutableList.toImmutableList());\n+\n+    final ImmutableMap<String, String> metadata =\n+        ImmutableMap.of(\n+            \"workspaceDatabaseId\", Long.toString(workspaceDatabaseId),", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0NTU3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431345571", "bodyText": "That's true, in that we could fill it in in the controller. But then I need one more type if I'm also going to return the query, or I need to mutate the returned value (which I guess is OK).", "author": "jaycarlton", "createdAt": "2020-05-27T18:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3Mjg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NDI2OA==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431174268", "bodyText": "Please document new config fields with a comment line. In particular it would be useful to note that these are not in any way connected with writing action audit logs, only with querying them. And maybe to include a pointer to the doc, RW ticket, etc. that describes how this dataset is populated.", "author": "gjuggler", "createdAt": "2020-05-27T14:26:13Z", "path": "api/src/main/java/org/pmiops/workbench/config/WorkbenchConfig.java", "diffHunk": "@@ -249,6 +249,8 @@ public String freeTierBillingAccountName() {\n \n   public static class ActionAuditConfig {\n     public String logName;\n+    public String bigQueryDataset;", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0NTk1Mg==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431345952", "bodyText": "That's a good point.  I forgot there was a place to hang comments.", "author": "jaycarlton", "createdAt": "2020-05-27T18:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NDI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE3NzI3Nw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431177277", "bodyText": "nit: I'm not sure the inclusive / exclusive wording is worth including here. It's a useful implementation note / comment on the API, but given that these audit events are not high-frequency, and the timestamp comparison is in milliseconds, the open / closed interval doesn't have much impact on usage.", "author": "gjuggler", "createdAt": "2020-05-27T14:29:26Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryService.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package org.pmiops.workbench.actionaudit;\n+\n+import org.joda.time.DateTime;\n+import org.pmiops.workbench.model.AuditLogEntriesResponse;\n+\n+public interface ActionAuditQueryService {\n+  AuditLogEntriesResponse queryEventsForWorkspace(\n+      long workspaceDatabaseId, long limit, DateTime afterInclusive, DateTime beforeExclusive);", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0NTY4NA==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431245684", "bodyText": "API design nit: it's probably more consistent and neater to treat the audit logs as a subcollection within the admin/workspaces/{workspaceNamespace}/ resource (similar to how we've done cloudStorageTraffic).\nI can see it going both ways, though \u2013\u00a0was there a strong reason to treat \"audit\" as the higher-level entry in the hierarchy?\n(Generally speaking, I'm trying to do my best to model after https://cloud.google.com/apis/design/resource_names where possible in new APIs and methods.)", "author": "gjuggler", "createdAt": "2020-05-27T15:46:14Z", "path": "api/src/main/resources/workbench-api.yaml", "diffHunk": "@@ -933,6 +933,55 @@ paths:\n           description: A list of workspaces\n           schema:\n             \"$ref\": \"#/definitions/WorkspaceListResponse\"\n+  \"/v1/admin/audit/workspace\":", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMzOTE3OQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431339179", "bodyText": "There could certainly be useful queries that involve both a user and a workspace (or various numbers of them). Though I don't know I've left room for that.", "author": "jaycarlton", "createdAt": "2020-05-27T17:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0NTY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg0MzQ4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431843489", "bodyText": "Makes sense, but it sounds a bit like YAGNI, as I don't know of any concrete use cases that would lead us to include such a query in the API.\nOn the balance, I think aligning with the existing collection hierarchy will be clearer and more consistent with existing API paths.", "author": "gjuggler", "createdAt": "2020-05-28T13:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0NTY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2MDU4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431860589", "bodyText": "That's fine I guess. I didn't want to be married to the namespace as the identifier though, which was the other reason for preferring query params.", "author": "jaycarlton", "createdAt": "2020-05-28T14:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0NTY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0NjQ3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431246475", "bodyText": "nit: remove first-person from description field.", "author": "gjuggler", "createdAt": "2020-05-27T15:47:17Z", "path": "api/src/main/resources/workbench-api.yaml", "diffHunk": "@@ -933,6 +933,55 @@ paths:\n           description: A list of workspaces\n           schema:\n             \"$ref\": \"#/definitions/WorkspaceListResponse\"\n+  \"/v1/admin/audit/workspace\":\n+    get:\n+      tags:\n+        - workspaceAdmin\n+      description: 'Fetch audit logs involving this workspace as either a subject or object.'\n+      operationId: getAuditLogEntries\n+      parameters:\n+        - name: workspaceNamespace\n+          in: query\n+          type: string\n+          required: true\n+          description: >\n+            Firecloud Namespace for the AoU workspace to be queried.\n+        - name: limit\n+          in: query\n+          type: integer\n+          required: false\n+          default: 100\n+          description: >\n+            Maximum number of entries to return, sorted by timestamp descending.\n+        - name: afterInclusive\n+          description: >\n+            Earliest time matched by the query (inclusive). Epoch millis.\n+\n+            Note that while Swagger allows a date-time formatted string query parameter,\n+            it appears Spring doesn't handle that well today. I ran into this issue:", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0NzQ2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431247463", "bodyText": "What does \"Declared as a string\" mean here? This is type: integer and format:int64. Is this a commentary on how Swagger-codegen handles this type of parameter? If so, is it related to the client side or the server side?", "author": "gjuggler", "createdAt": "2020-05-27T15:48:33Z", "path": "api/src/main/resources/workbench-api.yaml", "diffHunk": "@@ -933,6 +933,55 @@ paths:\n           description: A list of workspaces\n           schema:\n             \"$ref\": \"#/definitions/WorkspaceListResponse\"\n+  \"/v1/admin/audit/workspace\":\n+    get:\n+      tags:\n+        - workspaceAdmin\n+      description: 'Fetch audit logs involving this workspace as either a subject or object.'\n+      operationId: getAuditLogEntries\n+      parameters:\n+        - name: workspaceNamespace\n+          in: query\n+          type: string\n+          required: true\n+          description: >\n+            Firecloud Namespace for the AoU workspace to be queried.\n+        - name: limit\n+          in: query\n+          type: integer\n+          required: false\n+          default: 100\n+          description: >\n+            Maximum number of entries to return, sorted by timestamp descending.\n+        - name: afterInclusive\n+          description: >\n+            Earliest time matched by the query (inclusive). Epoch millis.\n+\n+            Note that while Swagger allows a date-time formatted string query parameter,\n+            it appears Spring doesn't handle that well today. I ran into this issue:\n+            https://github.com/swagger-api/swagger-codegen/issues/4113 and decided a long\n+            is good enough for now.\n+          in: query\n+          type: integer\n+          format: int64\n+          required: false\n+          default: 0\n+        - name: beforeExclusive\n+          description: >\n+             Upper bound on timestamp of most recent result (exclusive). Specified as milliseconds since Epoch\n+             (though declared as a string). Defaults to current timestamp.", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MDYwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431340605", "bodyText": "OK. I need to update this one. There's a Spring bug where it doesn't really handle string timestamps correctly, so I changed it back to a long but neglected to update the description.", "author": "jaycarlton", "createdAt": "2020-05-27T18:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0NzQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2OTc3NA==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431269774", "bodyText": "I'm generally not a fan of unspecified objects / fields in APIs. There really isn't too much additional cost in specifying field names and types, and IMO there's a huge benefit in API specificity.\nThere's also no other use of \"additionalProperties\" in this file, which suggests an argument by consistency, that we have a strong pattern to fully specify our API response objects.", "author": "gjuggler", "createdAt": "2020-05-27T16:15:51Z", "path": "api/src/main/resources/workbench-api.yaml", "diffHunk": "@@ -7280,3 +7329,95 @@ definitions:\n         format: int64\n       conceptName:\n         type: string\n+  AuditLogEntriesResponse:\n+    type: object\n+    description: >\n+      Represents the results of a query into the audit dataset in BigQery without\n+      filtering or transformation. This response type is a stopgap until we develop\n+      high-level queries with a better semantic mapping to the concepts and rules\n+      governing them, which is why a freeform queryMetadata field is tolerable for\n+      now.\n+    required:\n+    - logEntries\n+    - queryMetadata\n+    properties:\n+      logEntries:\n+        type: array\n+        items:\n+          \"$ref\": \"#/definitions/AuditLogEntry\"\n+      queryMetadata:", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MzgwNA==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431343804", "bodyText": "I generally agree. There's a historical problem here, because the audit system uses the DB id and the API does not.\nThe reason to do it here is to allow reusing the response object with several different kinds of queries. For example, the user query endpoint might take in a user ID, but the output is in terms of the database identifier.\nNow, in the special case of this query, the DB ID is easy to extract from the result set, since it only shows up in one column. In the case of hte User query, I'm probably going to include both rows where the user is the agent as well as the target, so it's not obvious which ID should be used.\nThe client will likely be interested in distinguishing which column is describing the user in question.\nNow, why not just have a databaseId field for both the user and the workspace (and others)? That gets you a little way down the road, but then you can easily have queries with more than one input (in principle).\nThe best solution not involving an arbitrary map is separate response types for each query type that look very similar but all contain a list of rows. That's cheap enough I suppose.\nThe balancing factor was that this was all going to be temporary until we built more high-level \"storytelling\" APIs for different types of things for different use cases. But that colud be a while.", "author": "jaycarlton", "createdAt": "2020-05-27T18:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2OTc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzODAwNg==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431838006", "bodyText": "I think I like the solution in your second to last paragraph best \u2013\u00a0separate out the user-and-workspace specific response types, but use a common AuditLogEntries data definition for each.", "author": "gjuggler", "createdAt": "2020-05-28T13:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI2OTc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3MjM3Ng==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431272376", "bodyText": "This comment might feel better placed in a design document or Jira ticket rather than API documentation.\nI'm not sure I fully understand why this is considered a stopgap \u2013\u00a0can you give any examples of higher-level queries or semantic mapping that you would want to build? From my viewpoint, it covers just about everything I would have imagined we'd want for the admin pages.", "author": "gjuggler", "createdAt": "2020-05-27T16:19:46Z", "path": "api/src/main/resources/workbench-api.yaml", "diffHunk": "@@ -7280,3 +7329,95 @@ definitions:\n         format: int64\n       conceptName:\n         type: string\n+  AuditLogEntriesResponse:\n+    type: object\n+    description: >\n+      Represents the results of a query into the audit dataset in BigQery without\n+      filtering or transformation. This response type is a stopgap until we develop", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3MjczOQ==", "url": "https://github.com/all-of-us/workbench/pull/3606#discussion_r431272739", "bodyText": "Thanks for the detailed documentation on these fields! Super helpful.", "author": "gjuggler", "createdAt": "2020-05-27T16:20:19Z", "path": "api/src/main/resources/workbench-api.yaml", "diffHunk": "@@ -7280,3 +7329,95 @@ definitions:\n         format: int64\n       conceptName:\n         type: string\n+  AuditLogEntriesResponse:\n+    type: object\n+    description: >\n+      Represents the results of a query into the audit dataset in BigQery without\n+      filtering or transformation. This response type is a stopgap until we develop\n+      high-level queries with a better semantic mapping to the concepts and rules\n+      governing them, which is why a freeform queryMetadata field is tolerable for\n+      now.\n+    required:\n+    - logEntries\n+    - queryMetadata\n+    properties:\n+      logEntries:\n+        type: array\n+        items:\n+          \"$ref\": \"#/definitions/AuditLogEntry\"\n+      queryMetadata:\n+        description: >\n+          Since the audit system uses SQL database IDs and the rest of hte API layer\n+          does not, it's helpful to return additional properties in order to assist\n+          the client in interpreting the results.\n+        type: object\n+        additionalProperties: true\n+  AuditLogEntry:\n+    description: >\n+      Representation of the BigQuery Audit Log entry, post-translation from Stackdriver logging.\n+      All fields are treated as optional here, as there are no non-null constraints in the BigQery\n+      dataset.\n+\n+      It's possible that due to some error now or in the past that some columns might not match\n+      their expected values, though we take pains to avoid that. Regardless, nothing in this type\n+      definition is stricter than the BigQuery schema.\n+    type: object\n+    properties:\n+      actionId:\n+        description: Unique ID for this action. Used for grouping similar events under a", "originalCommit": "76857e11f40671678ead337e36b71453c3b75f11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1612bd29ab7ecfe4b4190cecc78f27ccb54009b", "url": "https://github.com/all-of-us/workbench/commit/b1612bd29ab7ecfe4b4190cecc78f27ccb54009b", "message": "Merge branch 'master' into jaycarlton/RW-4921", "committedDate": "2020-05-27T18:46:08Z", "type": "commit"}, {"oid": "9c3e6993620f3d334569219163acfa7032985478", "url": "https://github.com/all-of-us/workbench/commit/9c3e6993620f3d334569219163acfa7032985478", "message": "comments", "committedDate": "2020-05-27T21:17:52Z", "type": "commit"}, {"oid": "991043e62ce222bd3ebd5cd70d94a1ed96f16070", "url": "https://github.com/all-of-us/workbench/commit/991043e62ce222bd3ebd5cd70d94a1ed96f16070", "message": "most of the recommendations", "committedDate": "2020-05-28T14:56:14Z", "type": "commit"}, {"oid": "b1188d90284767cfe44d339a0d06318cf9f9b346", "url": "https://github.com/all-of-us/workbench/commit/b1188d90284767cfe44d339a0d06318cf9f9b346", "message": "fixup formats", "committedDate": "2020-05-28T16:08:02Z", "type": "commit"}, {"oid": "085d5d1db8e450d189679e3f881af832a28d2516", "url": "https://github.com/all-of-us/workbench/commit/085d5d1db8e450d189679e3f881af832a28d2516", "message": "spotless", "committedDate": "2020-05-28T17:22:23Z", "type": "commit"}]}