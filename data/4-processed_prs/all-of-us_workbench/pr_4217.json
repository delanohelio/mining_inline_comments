{"pr_number": 4217, "pr_title": "[RW-5421][risk=no] Implement 'Delete Environment' button in runtime panel", "pr_createdAt": "2020-10-27T23:21:43Z", "pr_url": "https://github.com/all-of-us/workbench/pull/4217", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwNjE0NQ==", "url": "https://github.com/all-of-us/workbench/pull/4217#discussion_r513106145", "bodyText": "Curious about your thoughts on this. Ideally, we'd trigger a loading spinner at this point, then dispatch the delete/poll for recreation. Plumbing a promise out of setRuntimeStatus seems problematic, and I'm not sure whether it has the right side effects.\nAnother idea I had was perhaps to encode the state machine in this runtimepanel render function, e.g.\nif (deleting && runtime.status === Deleted) {\n  setDeleting(false);\n  setPanelContent(PanelContent.Customize);\n}\n\nreturn ...\n  {deleting && <SpinnerOverlay />}\n  ...;\n\nbut this also seems a bit difficult to follow.", "author": "calbach", "createdAt": "2020-10-28T00:16:25Z", "path": "ui/src/app/pages/analysis/runtime-panel.tsx", "diffHunk": "@@ -218,116 +285,131 @@ export const RuntimePanel = fp.flow(withCurrentWorkspace(), withCdrVersions())((\n   }\n \n   return <div data-test-id='runtime-panel'>\n-    <h3 style={styles.sectionHeader}>Cloud analysis environment</h3>\n+    <h3 style={{...styles.baseHeader, ...styles.sectionHeader}}>Cloud analysis environment</h3>\n     <div>\n       Your analysis environment consists of an application and compute resources.\n       Your cloud environment is unique to this workspace and not shared with other users.\n     </div>\n-    {/* TODO(RW-5419): Cost estimates go here. */}\n-    <div style={styles.controlSection}>\n-      {/* Recommended runtime: pick from default templates or change the image. */}\n-      <PopupTrigger side='bottom'\n-                    closeOnClick\n-                    content={\n-                      <React.Fragment>\n-                        {\n-                          fp.flow(\n-                            fp.filter(['displayName', 'General Analysis']),\n-                            fp.toPairs,\n-                            fp.map(([i, preset]) => {\n-                              return <MenuItem\n-                              style={styles.presetMenuItem}\n-                              key={i}\n-                              onClick={() => {\n-                                // renaming to avoid shadowing\n-                                const {runtimeTemplate} = preset;\n-                                const {presetDiskSize, presetMachineName} = fp.cond([\n-                                  [() => !!runtimeTemplate.gceConfig, ({gceConfig: {bootDiskSize, machineType}}) => ({\n-                                    presetDiskSize: bootDiskSize,\n-                                    presetMachineName: machineType\n-                                  })],\n-                                  [() => !!runtimeTemplate.dataprocConfig, ({dataprocConfig: {masterDiskSize, masterMachineType}}) => ({\n-                                    presetDiskSize: masterDiskSize,\n-                                    presetMachineName: masterMachineType\n-                                  })]\n-                                ])(runtimeTemplate);\n-                                const presetMachineType = fp.find(({name}) => name === presetMachineName, validLeonardoMachineTypes);\n+    {switchCase(panelContent,\n+      [PanelContent.Delete, () => <ConfirmDelete\n+        onConfirm={() => {\n+          setRuntimeStatus(RuntimeStatusRequest.Delete);", "originalCommit": "744a4878e1857b8a72c46d898d02528e144280ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwNjc0OQ==", "url": "https://github.com/all-of-us/workbench/pull/4217#discussion_r513106749", "bodyText": "I also don't necessary need to wait for the runtime status to change. It may just be sufficient to wait for the DeleteRuntime XHR to complete. But the answers seem like they are probably the same/ similar.", "author": "calbach", "createdAt": "2020-10-28T00:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwNjE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxNjUzNA==", "url": "https://github.com/all-of-us/workbench/pull/4217#discussion_r514616534", "bodyText": "The useRuntimeStatus hook could return something like:\n[{runtimeStatus: runtime.status, outstandingRequest: RuntimeStatusRequest}, setRuntimeStatus]\nThe hook would then update and trigger a render when a new state is requested, or when the store gets an update from the state. Do you think this would be too complex, or too much behavior for the hook to handle?", "author": "petesantos", "createdAt": "2020-10-29T23:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwNjE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMjUyOQ==", "url": "https://github.com/all-of-us/workbench/pull/4217#discussion_r514632529", "bodyText": "Hmm interesting. I think this could work - I don't think the complexity of the hook itself would be too much here. My main concern is that handling of the post-delete transition seems a little sketchy in any scenario where I can't write a straight-line: \"await x; then do y\". For example, adapting your suggestion I think I'd need something like this:\n// Assume that there was previously an outstanding request: since we're now deleting, we assume the pending deletion\n// request has completed and we initiate navigation away. \nif (!outstandingRequest && runtime.status === Deleting) {\n  setPanelContent(PanelContent.Customize);\n}\n\nreturn ...\n  {oustandingRequest && <SpinnerOverlay />}\n  ...;\n\n\nIt's not awful, but I am a bit worried about the substantial decoupling the navigation from the original click.", "author": "calbach", "createdAt": "2020-10-29T23:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwNjE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI3ODI5Ng==", "url": "https://github.com/all-of-us/workbench/pull/4217#discussion_r515278296", "bodyText": "I think I need a better understanding of the user flow. Right now I understand it as:\nClick Delete --> Waits for runtime deletion (spinner?) --> Views Create Runtime panel\nThe application looks like:\nClick Delete --> API Request: Delete (No spinner / difficult to know a \"transaction\" is taking place)  --> API Response: Deleting (spinner?) --> API Response: Deleted --> View Create Runtime panel\nIs this correct?\nA possible different approach - and I may be way off/missing something.\nI posted a similar thought in this ticket:\nIt feels clunky overall to try and manage the target state in the UI. It seems like we are inferring the true state of the \"transaction\" based on information have gathered from the user (e.g. \"they clicked the update button, the delete button, etc...\"). Would it be unreasonable to work with leo or to update our API's so that the concept of the transaction can be encoded into the server response? To be a bit more concrete - could we take the concept of the targetState and encode that into the server response?\nI feel this would allow us to create a somewhat more stateless and simpler approach to the problems we are running into. For instance:\nIn this case we would just set a busy flag until the target state has been reached / the \"transaction\" has completed. Even with refresh or navigation events we would be able to accurately determine the state and reflect that in the UI.", "author": "petesantos", "createdAt": "2020-10-30T17:50:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwNjE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIzNjEzMw==", "url": "https://github.com/all-of-us/workbench/pull/4217#discussion_r516236133", "bodyText": "I'll reply to your comment there, but lets completely separate that from this discussion. Here I'm trying to do something very simple: show a \"loading\" spinner while the DeleteRuntime fetch() is still pending, then change the panel after that completes.", "author": "calbach", "createdAt": "2020-11-02T20:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwNjE0NQ=="}], "type": "inlineReview"}, {"oid": "b72572370edb0bd12c01a25dad557746533914c7", "url": "https://github.com/all-of-us/workbench/commit/b72572370edb0bd12c01a25dad557746533914c7", "message": "Hide reset and style", "committedDate": "2020-11-04T01:18:28Z", "type": "forcePushed"}, {"oid": "f26d0437eea9a04c2bd34d3f29822d9adf9bad68", "url": "https://github.com/all-of-us/workbench/commit/f26d0437eea9a04c2bd34d3f29822d9adf9bad68", "message": "Hide reset and style", "committedDate": "2020-11-04T01:40:28Z", "type": "forcePushed"}, {"oid": "564728012c64f29d196e388433d6810ef6051fbc", "url": "https://github.com/all-of-us/workbench/commit/564728012c64f29d196e388433d6810ef6051fbc", "message": "lint / indent", "committedDate": "2020-11-05T21:13:56Z", "type": "forcePushed"}, {"oid": "979fbbd68953c56715b20fe782620740b9f5601a", "url": "https://github.com/all-of-us/workbench/commit/979fbbd68953c56715b20fe782620740b9f5601a", "message": "Delete Environment button", "committedDate": "2020-11-05T21:31:52Z", "type": "commit"}, {"oid": "979fbbd68953c56715b20fe782620740b9f5601a", "url": "https://github.com/all-of-us/workbench/commit/979fbbd68953c56715b20fe782620740b9f5601a", "message": "Delete Environment button", "committedDate": "2020-11-05T21:31:52Z", "type": "forcePushed"}, {"oid": "692d7a88b7d7de6bbe4b79bc5c4d67477b98ab51", "url": "https://github.com/all-of-us/workbench/commit/692d7a88b7d7de6bbe4b79bc5c4d67477b98ab51", "message": "stale comment", "committedDate": "2020-11-05T21:33:21Z", "type": "commit"}]}