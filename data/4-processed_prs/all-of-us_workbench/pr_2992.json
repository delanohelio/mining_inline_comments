{"pr_number": 2992, "pr_title": "[RW-2253] [risk=low] Add inbound API to handle SumoLogic egress alerts", "pr_createdAt": "2020-01-10T14:28:01Z", "pr_url": "https://github.com/all-of-us/workbench/pull/2992", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3MjEzNw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365372137", "bodyText": "FWIW, this interface and implementation don't need to be in Kotlin. Java classes can implement Kotlin interfaces and vice-versa. See UserServiceAuditor.java.", "author": "jaycarlton", "createdAt": "2020-01-10T18:34:51Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditor.kt", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+\n+interface SumoLogicAuditor {", "originalCommit": "9fb336e7a3ae0b034d938078d06a3087d28f6820", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQwODU4OQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365408589", "bodyText": "Woops \u2013 let's keep this between you and me :)\nI took it as a chance to try and get a bit more familiar with Kotlin before we need to make a team decision on whether or not to adopt it more widely. That's good to know it's not as infectious as I might have feared.", "author": "gjuggler", "createdAt": "2020-01-10T20:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3MjEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3NTY1Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365375653", "bodyText": "There are a couple of ways to do this, depending on what level of abstraction you want.\nIf you want commenting to be an action that someone can take, then we can make an ActionType of COMMENT, and apply it to any of the target types. We could even have a target type of ACTION and use the action's ID as the TARGET_ID.\nI'm hesitant to make a new column for comment, as it would mean different rows under the same Action could have different comments. That's not a problem per se, but it's difficult to enforce a consistent usage pattern when lots of folks are using the system, and querying might be icky.", "author": "jaycarlton", "createdAt": "2020-01-10T18:43:52Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,132 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {\n+        return ClusterController.clusterNameForUser(dbUser)\n+    }\n+\n+    /**\n+     * Converts the AoU-chosen cluster name into the actual VM name as reported by Google Cloud's\n+     * flow logs. Empirically, an \"-m\" suffix is added to the VM name.\n+     *\n+     * Note: this pattern may change if the Leo team switches to using raw VMs instead of Dataproc\n+     * clusters!\n+     */\n+    private fun dbUserToVmName(dbUser: DbUser): String {\n+        return dbUserToClusterName(dbUser) + \"-m\"\n+    }\n+\n+    override fun fireEgressEvent(event: EgressEvent) {\n+        // Load the workspace via the GCP project name\n+        val dbWorkspace = this.workspaceService.getByNamespace(event.projectName)\n+        if (dbWorkspace == null) {\n+            fireFailedToFindWorkspace(event)\n+            return\n+        }\n+        // Using service-level creds, load the FireCloud workspace ACLs to find all members\n+        // of the workspace. Then attempt to find the user who aligns with the named VM.\n+        val userRoles = workspaceService.getFirecloudUserRoles(dbWorkspace.workspaceNamespace,\n+                dbWorkspace.firecloudName)\n+        val vmOwner = userRoles\n+                .map { userDao.findUserByUsername(it.email) }\n+                .filter { dbUserToVmName(it).equals(event.vmName) }\n+                .firstOrNull()\n+\n+        var agentEmail = \"\"\n+        var agentId = 0L\n+        if (vmOwner != null) {\n+            agentEmail = vmOwner.username\n+            agentId = vmOwner.userId\n+        } else {\n+            // If the VM name doesn't match a user on the workspace, we'll still log an\n+            // event in the target workspace, but with nulled-out user info.\n+            logger.warning(String.format(\"Could not find a user for VM name %s in project %s\", event.vmName, event.projectName))\n+        }\n+\n+        actionAuditService.send(ActionAuditEvent(\n+                timestamp = clock.millis(),\n+                actionId = actionIdProvider.get(),\n+                actionType = ActionType.HIGH_EGRESS,\n+                agentType = AgentType.USER,\n+                agentId = agentId,\n+                agentEmailMaybe = agentEmail,\n+                targetType = TargetType.WORKSPACE,\n+                targetIdMaybe = dbWorkspace.workspaceId,\n+                // TODO: Maybe what would fit best here would be a \"comment\" field on the AcionAuditEvent and", "originalCommit": "9fb336e7a3ae0b034d938078d06a3087d28f6820", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQwOTg2OQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365409869", "bodyText": "Thanks \u2013 I guess the most pragmatic solution will be to call it an ActionType and tie two rows together by a single Action ID: one for the high-egress event, and one for the comment.\nI'd feel a little awkward to have to send two events for this, even though it's definitely just one event-plus-a-log-message. But I can wrap it in a helper function on the ActionAuditService, so it probably won't affect usage too much.", "author": "gjuggler", "createdAt": "2020-01-10T20:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3NTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ0MDA1OA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365440058", "bodyText": "PTAL at the latest commit \u2013\u00a0I took a stab at something like what I described above.", "author": "gjuggler", "createdAt": "2020-01-10T21:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3NTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3NjQ3NA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365376474", "bodyText": "I'd externalize the prefix all-of-us-. I don't know from this statement what its scope is.\nAlso, one pet peeve I have is that if we're using hyphens to delineate subparts of an identifier, then it should be allofus-. Likely way too late.", "author": "jaycarlton", "createdAt": "2020-01-10T18:45:51Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -272,7 +272,13 @@\n     return ResponseEntity.ok(new EmptyResponse());\n   }\n \n-  private static String clusterNameForUser(DbUser user) {\n+  /**\n+   * Returns a name for the VM / cluster to be created for a given user in the workspace.\n+   *\n+   * @param user\n+   * @return\n+   */\n+  public static String clusterNameForUser(DbUser user) {", "originalCommit": "9fb336e7a3ae0b034d938078d06a3087d28f6820", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQxMjYwNg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365412606", "bodyText": "What do you mean by externalize? Bump to a constant in this file, out to a separate class, or all the way out to WorkbenchConfig?\nI'm willing to find a separate class to home it in, to at least protect against circular dependencies.\nAnything more probably isn't worth the effort. We haven't changed this value for the ~lifetime of the project, so I don't think it's a particularly sensitive constant.", "author": "gjuggler", "createdAt": "2020-01-10T20:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3NjQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3NzI3Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365377277", "bodyText": "why are we screaming the parameter name?", "author": "jaycarlton", "createdAt": "2020-01-10T18:47:38Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";\n+\n+  private static final Logger log = Logger.getLogger(SumoLogicController.class.getName());\n+  private final SumoLogicAuditor sumoLogicAuditor;\n+  private final CloudStorageService cloudStorageService;\n+\n+  @Autowired\n+  SumoLogicController(SumoLogicAuditor sumoLogicAuditor, CloudStorageService cloudStorageService) {\n+    this.sumoLogicAuditor = sumoLogicAuditor;\n+    this.cloudStorageService = cloudStorageService;\n+  }\n+\n+  @Override\n+  public ResponseEntity<EmptyResponse> logEgressEvent(\n+      String X_API_KEY, EgressEventRequest request) {", "originalCommit": "9fb336e7a3ae0b034d938078d06a3087d28f6820", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQxMjkyNQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365412925", "bodyText": "Swagger-codegen is choosing the parameter naming here \u2013\u00a0it's based on what I used in the YAML file. It felt more appropriate to use the traditional UPPERCASE_HEADER casing over there, so... meh.", "author": "gjuggler", "createdAt": "2020-01-10T20:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3NzI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5ODI3Ng==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r365898276", "bodyText": "I see where you're going, and how something like this could be useful, but there are a couple of things that are of some concern:\n\nThe model doesn't really support multiple action types per actionId.\nA utility like this would naturally belong to the AuditActionEvent.Builder class, not this service.\nIt's ambiguous to me when this would be used. If we're capturing administrator comments, then that makes sense to me as a dedicated TargetProperty that can be added to whatever the administrator (agent) is doing (action). So from that standpoint, we don't need a global comment.\nIf it's for developers to add arbitrary strings, then things can start to get messy in a hurry. It will be tempting to just stuff things into a comment when you don't know where they would logically go in the schema. That's better than not having the information, but one of my original requirements was for a high degree of relational query-ability.\nIf we want to support stand-alone comment actions (independent of other events), then that's another action type (as you have here) with a target of whatever context the admin is looking at (user, workspace, etc).\nIf we decide to migrate some date that's in comments into a more structured form, that's really tough to do compared to more structured data.\nIt's not stable to take the first element from a Collection, since they're not ordered.", "author": "jaycarlton", "createdAt": "2020-01-13T16:27:06Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditService.kt", "diffHunk": "@@ -3,9 +3,18 @@ package org.pmiops.workbench.actionaudit\n import java.util.logging.Logger\n \n interface ActionAuditService {\n-    fun send(event: ActionAuditEvent)\n+    fun send(event: ActionAuditEvent) {\n+        send(setOf(event))\n+    }\n \n     fun send(events: Collection<ActionAuditEvent>)\n \n+    /**\n+     * Sends a collection of events plus an event with ActionType.COMMENT and the given comment\n+     * string as the newValueMaybe. The COMMENT action derives its other properties from the\n+     * first event from the original collection.", "originalCommit": "c5ccc982bdc8c4bb7b790470420fbda199e29007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY3MjUxNg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367672516", "bodyText": "Chatted offline \u2013 check out the latest commit for a different approach to this.", "author": "gjuggler", "createdAt": "2020-01-16T21:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5ODI3Ng=="}], "type": "inlineReview"}, {"oid": "52c7af7fed27b2c8a09e26b20466088693e1415c", "url": "https://github.com/all-of-us/workbench/commit/52c7af7fed27b2c8a09e26b20466088693e1415c", "message": "Add an API for receiving inbound SumoLogic events and logging action audit events.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "790ec977e86e666ffc0e04f512a523048de43e29", "url": "https://github.com/all-of-us/workbench/commit/790ec977e86e666ffc0e04f512a523048de43e29", "message": "Add API key authorization.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "dae6aa487c96c5394cdb688a7bb266cb5adfcf3b", "url": "https://github.com/all-of-us/workbench/commit/dae6aa487c96c5394cdb688a7bb266cb5adfcf3b", "message": "Fix formatting.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "365e14f7203f3d4ab5f41fa34183a6d4f50d3651", "url": "https://github.com/all-of-us/workbench/commit/365e14f7203f3d4ab5f41fa34183a6d4f50d3651", "message": "Rename API key filename for clarity.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "f34aa3f52653cae84a3daa307df94f04a5e07292", "url": "https://github.com/all-of-us/workbench/commit/f34aa3f52653cae84a3daa307df94f04a5e07292", "message": "Remove unnecessary import of non-test auditing beans.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "d2cb698da599d4d28afa82ceb6de3d6e15a8ef15", "url": "https://github.com/all-of-us/workbench/commit/d2cb698da599d4d28afa82ceb6de3d6e15a8ef15", "message": "Import the correct test config class.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "c72cfa2c4599920ea9d136cfd2073487f9ccac81", "url": "https://github.com/all-of-us/workbench/commit/c72cfa2c4599920ea9d136cfd2073487f9ccac81", "message": "Fix file formatting.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "8c166c21b74a92a1080adf56fb4c0a6afb4ebd63", "url": "https://github.com/all-of-us/workbench/commit/8c166c21b74a92a1080adf56fb4c0a6afb4ebd63", "message": "Add egress_mib_threshold to API signature.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "7003c938a6c25213150b493e053bcdb3a7810eb4", "url": "https://github.com/all-of-us/workbench/commit/7003c938a6c25213150b493e053bcdb3a7810eb4", "message": "Fix Swagger merge error.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "7d5f38eef661bbbaf621fa36b318dfbeb62ca7a1", "url": "https://github.com/all-of-us/workbench/commit/7d5f38eef661bbbaf621fa36b318dfbeb62ca7a1", "message": "Comments and refactors while previewing the diff in GitHub.", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "23aa92e0775fd299f88072cc207494a7da80cd5a", "url": "https://github.com/all-of-us/workbench/commit/23aa92e0775fd299f88072cc207494a7da80cd5a", "message": "Add controller tests", "committedDate": "2020-01-16T22:00:50Z", "type": "commit"}, {"oid": "ca91f87b0cf806ee4718f0c41cbf0e8861c34fff", "url": "https://github.com/all-of-us/workbench/commit/ca91f87b0cf806ee4718f0c41cbf0e8861c34fff", "message": "Change how comments are handled.", "committedDate": "2020-01-16T22:01:50Z", "type": "commit"}, {"oid": "9e06a78c3b05edc0697d8ce54b02246bba054435", "url": "https://github.com/all-of-us/workbench/commit/9e06a78c3b05edc0697d8ce54b02246bba054435", "message": "Add flag values to config JSON.", "committedDate": "2020-01-16T22:03:14Z", "type": "commit"}, {"oid": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "url": "https://github.com/all-of-us/workbench/commit/1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "message": "Change how high-egress events are logged to the audit system.", "committedDate": "2020-01-16T22:03:14Z", "type": "commit"}, {"oid": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "url": "https://github.com/all-of-us/workbench/commit/1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "message": "Change how high-egress events are logged to the audit system.", "committedDate": "2020-01-16T22:03:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NDYzMA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367684630", "bodyText": "Good catch. I guess it just silently, randomly, picked one of these before?", "author": "jaycarlton", "createdAt": "2020-01-16T22:32:41Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditConfig.kt", "diffHunk": "@@ -1,14 +0,0 @@\n-package org.pmiops.workbench.audit\n-\n-import com.google.cloud.logging.Logging\n-import com.google.cloud.logging.LoggingOptions\n-import org.springframework.context.annotation.Bean\n-import org.springframework.context.annotation.Configuration\n-\n-@Configuration\n-open class ActionAuditConfig {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NDkyMA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367684920", "bodyText": "Why do we need a separate clock bean at this level? I thought there was already one somewhere.", "author": "jaycarlton", "createdAt": "2020-01-16T22:33:29Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditSpringConfiguration.kt", "diffHunk": "@@ -21,4 +22,8 @@ open class ActionAuditSpringConfiguration {\n         get() {\n             return UUID.randomUUID().toString()\n         }\n+\n+    open val clock: Clock", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMTc3Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367721772", "bodyText": "Those are just in tests. Still, this kinda makes sense to me at a higher level, as I can't think of a reason we'd ever want them to diverge unintentionally.", "author": "jaycarlton", "createdAt": "2020-01-17T00:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NDkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MTc0NQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367961745", "bodyText": "Good catch \u2013 I don't remember exactly why I'd added this. Removing it now doesn't break anything, soo.... done", "author": "gjuggler", "createdAt": "2020-01-17T14:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NDkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NTY2Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367685662", "bodyText": "nit: I feel like naming this fireEgressViolationDetected () would make it clearer that this doesn't fire for every byte leaving the perimeter, and is reporting the detection of a calculated event, not a discrete thing that a user or the system did (as most or all of the other events do)? I think it's fine to leave the Event suffix off in these interfaces since that's pretty much implied.", "author": "jaycarlton", "createdAt": "2020-01-16T22:35:41Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditor.kt", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+\n+interface SumoLogicAuditor {\n+    // Decorates a Sumologic-reported egress event with Workbench metadata and\n+    // fires an audit event log in the target workspace.\n+    fun fireEgressEvent(event: EgressEvent)", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2Nzg2MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367967860", "bodyText": "I added some clarification to the comment. In line with the above principle, I'd like to keep \"EgressEvent\" as the core object name here. The overall context is that only high-egress events are being communicated from Sumo to the Workbench \u2013\u00a0I don't think it needs to be baked into the name necessarily.\n(I did think about renaming the core EgressEvent object to HighEgressEvent, but IMO in this case it doesn't add too much more clarity and starts to become a mouthful, e.g. HighEgressEventAuditorImpl is too many camel backs for me.)", "author": "gjuggler", "createdAt": "2020-01-17T14:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NjgwNw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367686807", "bodyText": "nit: I might rearrange the signature here and use an overload. I don't know if it's really a different situation when there are different reasons it didn't work. You could potentially merge the mini-schema to have a property for succeeded/failed and another for the error information.\nAlso, this is the only place where we're sending error information to the audit log, but since egress is so important, it may be worth it.", "author": "jaycarlton", "createdAt": "2020-01-16T22:38:57Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditor.kt", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+\n+interface SumoLogicAuditor {\n+    // Decorates a Sumologic-reported egress event with Workbench metadata and\n+    // fires an audit event log in the target workspace.\n+    fun fireEgressEvent(event: EgressEvent)\n+\n+    // Fires an audit event log tracking when a Sumologic-reported egress event\n+    // request could not successfully be parsed.\n+    fun fireFailedToParseEgressEvent(request: EgressEventRequest)\n+\n+    // Fires an audit event log tracking when a Sumologic-reported egress event\n+    // request did not have a valid API key.\n+    fun fireBadApiKeyEgressEvent(apiKey: String, request: EgressEventRequest)", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2ODQ2Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367968467", "bodyText": "I'll punt on merging the methods. The clarity of knowing exactly what situations are being logged is worth it I think, and the implementation avoids duplicating any code.\nI agree, it's somewhat unique to be logging errors here. But as I went through the controller implementation, I realized that we really, really don't want to be losing information about Sumo comms failures, or let them get buried in our debug logs.\nThe next step here would be to collect an event metric for each of these so we can alert on a non-zero rate of any of these types of events.", "author": "gjuggler", "createdAt": "2020-01-17T14:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NjgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NzIxNA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367687214", "bodyText": "I would name this EgressViolationAuditor or similar, as it doesn't necessarily directly depend on SumoLogic (in theory).", "author": "jaycarlton", "createdAt": "2020-01-16T22:39:57Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditor.kt", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+\n+interface SumoLogicAuditor {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2NDI2Ng==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367964266", "bodyText": "Per my comments above, I'll rename to EgressEventAuditor for consistency with the model class name.", "author": "gjuggler", "createdAt": "2020-01-17T14:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NzIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4ODA5OQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367688099", "bodyText": "nit: It feels a bit like feature envy to have this live here.", "author": "jaycarlton", "createdAt": "2020-01-16T22:42:32Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.TargetPropertyExtractor\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.exceptions.BadRequestException\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3NTgyMA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367975820", "bodyText": "I'm not quite sure what you mean here...", "author": "gjuggler", "createdAt": "2020-01-17T14:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4ODA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4ODcyNQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367688725", "bodyText": "nti: I'd make this suffix or string format a constant. As above, I think there are uses for this outside auditing and I'd put it either in the ClusterController or in a MapStruct mapper.", "author": "jaycarlton", "createdAt": "2020-01-16T22:44:26Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.TargetPropertyExtractor\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.exceptions.BadRequestException\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {\n+        return ClusterController.clusterNameForUser(dbUser)\n+    }\n+\n+    /**\n+     * Converts the AoU-chosen cluster name into the actual VM name as reported by Google Cloud's\n+     * flow logs. Empirically, an \"-m\" suffix is added to the VM name.\n+     *\n+     * Note: this pattern may change if the Leo team switches to using raw VMs instead of Dataproc\n+     * clusters!\n+     */\n+    private fun dbUserToVmName(dbUser: DbUser): String {\n+        return dbUserToClusterName(dbUser) + \"-m\"", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NTE2Ng==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367985166", "bodyText": "Good call re: the constant. This gave me an opportunity to clarify that this appears to be a dataproc-specific thing.\nI'll punt on pre-emptively extracting this outside of this class; it's simple enough for someone else to pluck it out if it does end up being needed elsewhere.", "author": "gjuggler", "createdAt": "2020-01-17T15:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4ODcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4ODk0Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367688947", "bodyText": "Is there a way we can track this down? I really hate to rely on it.\nBTW, Does Leo give us the ability to specify a different formula or additional metadata on clusters?", "author": "jaycarlton", "createdAt": "2020-01-16T22:45:10Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.TargetPropertyExtractor\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.exceptions.BadRequestException\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {\n+        return ClusterController.clusterNameForUser(dbUser)\n+    }\n+\n+    /**\n+     * Converts the AoU-chosen cluster name into the actual VM name as reported by Google Cloud's\n+     * flow logs. Empirically, an \"-m\" suffix is added to the VM name.", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3NjY3Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367976673", "bodyText": "I'm going to punt on this \u2013\u00a0I suspect it's due to the use of Dataproc, which creates a master node. I'd prefer to be empirical here and use what works without drilling down too far to try and fix something outside of our control. This comment should be enough of a breadcrumb for someone to jump off from. (Follow-up: based on a quick bit of Googling, e.g. https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/metadata, it seems this is a Dataproc thing.)", "author": "gjuggler", "createdAt": "2020-01-17T14:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4ODk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4OTE1Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367689157", "bodyText": "nit: you don't need this. in most situations.", "author": "jaycarlton", "createdAt": "2020-01-16T22:45:40Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.TargetPropertyExtractor\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.exceptions.BadRequestException\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {\n+        return ClusterController.clusterNameForUser(dbUser)\n+    }\n+\n+    /**\n+     * Converts the AoU-chosen cluster name into the actual VM name as reported by Google Cloud's\n+     * flow logs. Empirically, an \"-m\" suffix is added to the VM name.\n+     *\n+     * Note: this pattern may change if the Leo team switches to using raw VMs instead of Dataproc\n+     * clusters!\n+     */\n+    private fun dbUserToVmName(dbUser: DbUser): String {\n+        return dbUserToClusterName(dbUser) + \"-m\"\n+    }\n+\n+    override fun fireEgressEvent(event: EgressEvent) {\n+        // Load the workspace via the GCP project name\n+        val dbWorkspace = this.workspaceService.getByNamespace(event.projectName)", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NTY1MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367985650", "bodyText": "Thanks \u2013\u00a0old JS habits die hard. Done.", "author": "gjuggler", "createdAt": "2020-01-17T15:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4OTE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MTQwOA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367691408", "bodyText": "nit: You're free to leave out the optional arguments. It won't compile if any without defaults are unspecified. If you like having them for readability, that's fine too.", "author": "jaycarlton", "createdAt": "2020-01-16T22:52:53Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.TargetPropertyExtractor\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.exceptions.BadRequestException\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {\n+        return ClusterController.clusterNameForUser(dbUser)\n+    }\n+\n+    /**\n+     * Converts the AoU-chosen cluster name into the actual VM name as reported by Google Cloud's\n+     * flow logs. Empirically, an \"-m\" suffix is added to the VM name.\n+     *\n+     * Note: this pattern may change if the Leo team switches to using raw VMs instead of Dataproc\n+     * clusters!\n+     */\n+    private fun dbUserToVmName(dbUser: DbUser): String {\n+        return dbUserToClusterName(dbUser) + \"-m\"\n+    }\n+\n+    override fun fireEgressEvent(event: EgressEvent) {\n+        // Load the workspace via the GCP project name\n+        val dbWorkspace = this.workspaceService.getByNamespace(event.projectName)\n+        if (dbWorkspace == null) {\n+            // Failing to find a workspace is odd enough that we want to return a non-success\n+            // response at the API level. But it's also worth storing a permanent record of the\n+            // high-egress event by logging it without a workspace target.\n+            fireFailedToFindWorkspace(event)\n+            throw BadRequestException(String.format(\n+                    \"The workspace '%s' referred to by the given event is no longer active or never existed.\",\n+                    event.projectName))\n+        }\n+        // Using service-level creds, load the FireCloud workspace ACLs to find all members\n+        // of the workspace. Then attempt to find the user who aligns with the named VM.\n+        val userRoles = workspaceService.getFirecloudUserRoles(dbWorkspace.workspaceNamespace,\n+                dbWorkspace.firecloudName)\n+        val vmOwner = userRoles\n+                .map { userDao.findUserByUsername(it.email) }\n+                .filter { dbUserToVmName(it).equals(event.vmName) }\n+                .firstOrNull()\n+\n+        var agentEmail = \"\"\n+        var agentId = 0L\n+        if (vmOwner != null) {\n+            agentEmail = vmOwner.username\n+            agentId = vmOwner.userId\n+        } else {\n+            // If the VM name doesn't match a user on the workspace, we'll still log an\n+            // event in the target workspace, but with nulled-out user info.\n+            logger.warning(String.format(\"Could not find a user for VM name %s in project %s\", event.vmName, event.projectName))\n+        }\n+\n+        val actionId = actionIdProvider.get()\n+        fireEventSet(ActionAuditEvent(\n+                timestamp = clock.millis(),\n+                actionId = actionId,\n+                actionType = ActionType.HIGH_EGRESS,\n+                agentType = AgentType.USER,\n+                agentId = agentId,\n+                agentEmailMaybe = agentEmail,\n+                targetType = TargetType.WORKSPACE,\n+                targetIdMaybe = dbWorkspace.workspaceId\n+        ), event, null)\n+    }\n+\n+    override fun fireFailedToParseEgressEvent(request: EgressEventRequest) {\n+        fireEventSet(getGenericBaseEvent(), null, String.format(\n+                \"Failed to parse egress event JSON from SumoLogic. Field contents: %s\",\n+                request.eventsJsonArray))\n+    }\n+\n+    override fun fireBadApiKeyEgressEvent(apiKey: String, request: EgressEventRequest) {\n+        fireEventSet(getGenericBaseEvent(), null, String.format(\n+                \"Received bad API key from SumoLogic. Bad key: %s, full request: %s\",\n+                apiKey, request.toString()))\n+    }\n+\n+    private fun fireFailedToFindWorkspace(event: EgressEvent) {\n+        fireEventSet(getGenericBaseEvent(), event, String.format(\n+                \"Failed to find workspace for high-egress event: %s\",\n+                event.toString()))\n+    }\n+\n+    /**\n+     * Creates and fires a set of events derived from the given base event, incorporating audit rows\n+     * to record properties of the egress event and a human-readable comment. Either the egress event\n+     * or the comment may be null, in which case those row(s) won't be generated.\n+     */\n+    private fun fireEventSet(baseEvent: ActionAuditEvent, egressEvent: EgressEvent?, comment: String?) {\n+        var events = ArrayList<ActionAuditEvent>()\n+        if (egressEvent != null) {\n+            val propertyValues = TargetPropertyExtractor.getPropertyValuesByName(\n+                    EgressEventTargetProperty.values(), egressEvent)\n+            events.addAll(propertyValues.map {\n+                baseEvent.copy(\n+                        targetPropertyMaybe = it.key,\n+                        newValueMaybe = it.value)\n+            })\n+        }\n+        if (comment != null) {\n+            events.add(baseEvent.copy(\n+                    targetPropertyMaybe = EgressEventCommentTargetProperty.COMMENT.propertyName,\n+                    newValueMaybe = comment\n+            ))\n+        }\n+        actionAuditService.send(events)\n+    }\n+\n+    /**\n+     * Returns an ActionAuditEvent suitable for logging system-level error messages, e.g. when\n+     * an inbound high-egress event refers to an inactive workspace or when the request JSON\n+     * could not be successfully parsed.\n+     */\n+    private fun getGenericBaseEvent(): ActionAuditEvent {\n+        return ActionAuditEvent(\n+                timestamp = clock.millis(),\n+                actionId = actionIdProvider.get(),\n+                actionType = ActionType.HIGH_EGRESS,\n+                agentType = AgentType.SYSTEM,\n+                agentId = 0,\n+                agentEmailMaybe = null,", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0MzQwMg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367743402", "bodyText": "Also, you could return an ActionAuditEvent.Builder so you don't have to make a copy when adding things. To do the chaining you have to use .apply { }.", "author": "jaycarlton", "createdAt": "2020-01-17T02:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5MDExOA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367990118", "bodyText": "I do think it's slightly clearer to have them explicitly nulled out here.", "author": "gjuggler", "createdAt": "2020-01-17T15:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MTQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MjgyNQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367692825", "bodyText": "nit: I believe in other places the \"event set\" is just an \"action\" if that helps. It's not the best terminology.", "author": "jaycarlton", "createdAt": "2020-01-16T22:57:25Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.TargetPropertyExtractor\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.exceptions.BadRequestException\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {\n+        return ClusterController.clusterNameForUser(dbUser)\n+    }\n+\n+    /**\n+     * Converts the AoU-chosen cluster name into the actual VM name as reported by Google Cloud's\n+     * flow logs. Empirically, an \"-m\" suffix is added to the VM name.\n+     *\n+     * Note: this pattern may change if the Leo team switches to using raw VMs instead of Dataproc\n+     * clusters!\n+     */\n+    private fun dbUserToVmName(dbUser: DbUser): String {\n+        return dbUserToClusterName(dbUser) + \"-m\"\n+    }\n+\n+    override fun fireEgressEvent(event: EgressEvent) {\n+        // Load the workspace via the GCP project name\n+        val dbWorkspace = this.workspaceService.getByNamespace(event.projectName)\n+        if (dbWorkspace == null) {\n+            // Failing to find a workspace is odd enough that we want to return a non-success\n+            // response at the API level. But it's also worth storing a permanent record of the\n+            // high-egress event by logging it without a workspace target.\n+            fireFailedToFindWorkspace(event)\n+            throw BadRequestException(String.format(\n+                    \"The workspace '%s' referred to by the given event is no longer active or never existed.\",\n+                    event.projectName))\n+        }\n+        // Using service-level creds, load the FireCloud workspace ACLs to find all members\n+        // of the workspace. Then attempt to find the user who aligns with the named VM.\n+        val userRoles = workspaceService.getFirecloudUserRoles(dbWorkspace.workspaceNamespace,\n+                dbWorkspace.firecloudName)\n+        val vmOwner = userRoles\n+                .map { userDao.findUserByUsername(it.email) }\n+                .filter { dbUserToVmName(it).equals(event.vmName) }\n+                .firstOrNull()\n+\n+        var agentEmail = \"\"\n+        var agentId = 0L\n+        if (vmOwner != null) {\n+            agentEmail = vmOwner.username\n+            agentId = vmOwner.userId\n+        } else {\n+            // If the VM name doesn't match a user on the workspace, we'll still log an\n+            // event in the target workspace, but with nulled-out user info.\n+            logger.warning(String.format(\"Could not find a user for VM name %s in project %s\", event.vmName, event.projectName))\n+        }\n+\n+        val actionId = actionIdProvider.get()\n+        fireEventSet(ActionAuditEvent(\n+                timestamp = clock.millis(),\n+                actionId = actionId,\n+                actionType = ActionType.HIGH_EGRESS,\n+                agentType = AgentType.USER,\n+                agentId = agentId,\n+                agentEmailMaybe = agentEmail,\n+                targetType = TargetType.WORKSPACE,\n+                targetIdMaybe = dbWorkspace.workspaceId\n+        ), event, null)\n+    }\n+\n+    override fun fireFailedToParseEgressEvent(request: EgressEventRequest) {\n+        fireEventSet(getGenericBaseEvent(), null, String.format(\n+                \"Failed to parse egress event JSON from SumoLogic. Field contents: %s\",\n+                request.eventsJsonArray))\n+    }\n+\n+    override fun fireBadApiKeyEgressEvent(apiKey: String, request: EgressEventRequest) {\n+        fireEventSet(getGenericBaseEvent(), null, String.format(\n+                \"Received bad API key from SumoLogic. Bad key: %s, full request: %s\",\n+                apiKey, request.toString()))\n+    }\n+\n+    private fun fireFailedToFindWorkspace(event: EgressEvent) {\n+        fireEventSet(getGenericBaseEvent(), event, String.format(\n+                \"Failed to find workspace for high-egress event: %s\",\n+                event.toString()))\n+    }\n+\n+    /**\n+     * Creates and fires a set of events derived from the given base event, incorporating audit rows\n+     * to record properties of the egress event and a human-readable comment. Either the egress event\n+     * or the comment may be null, in which case those row(s) won't be generated.\n+     */\n+    private fun fireEventSet(baseEvent: ActionAuditEvent, egressEvent: EgressEvent?, comment: String?) {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0MzU1Ng==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367743556", "bodyText": "This helper (or one like it) is generally useful. I bet there's a way to have an ActionAuditEventBuilderListBuilder or something that could do all this ugly looping for you. So you'd specify the common columns and the property-{old, new}-value-pair map.\nI really need to make this maneuver more natural, as we keep finding more and more target properties.", "author": "jaycarlton", "createdAt": "2020-01-17T02:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MjgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0Nzg4Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367747882", "bodyText": "Also, please give a default to your optional parameters if applicable. So\nprivate fun fireEventSet(baseEvent: ActionAuditEvent, egressEvent: EgressEvent? = null, comment: String? = null) {", "author": "jaycarlton", "createdAt": "2020-01-17T02:51:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MjgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4ODIzOA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367988238", "bodyText": "I'll leave this as-is for now (aside from the default param values, I added those). It's a 15-line private helper function, easy to rip out and place somewhere else if it turns out to be a more broadly-usable pattern.", "author": "gjuggler", "createdAt": "2020-01-17T15:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5MjgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDIwMw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367694203", "bodyText": "nit: IYI You can do this wiht a .? and ?: chain. https://medium.com/tompee/idiomatic-kotlin-elvis-operator-d6f5639a5130", "author": "jaycarlton", "createdAt": "2020-01-16T23:01:46Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/targetproperties/EgressEventTargetProperty.kt", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.pmiops.workbench.actionaudit.targetproperties\n+\n+import io.opencensus.common.Timestamp\n+import org.pmiops.workbench.model.EgressEvent\n+\n+enum class EgressEventTargetProperty\n+constructor(\n+    override val propertyName: String,\n+    override val extractor: (EgressEvent) -> String?\n+) : ModelBackedTargetProperty<EgressEvent> {\n+    EGRESS_MIB(\"egress_mib\",\n+            { it.egressMib?.toString() }),\n+    TIME_WINDOW_START(\"time_window_start\",\n+            {\n+                if (it.timeWindowStart != null)", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0MDgxMA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368040810", "bodyText": "That works too, but I'll leave as-is since the end result is roughly equivalent.", "author": "gjuggler", "createdAt": "2020-01-17T17:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDMwMw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367694303", "bodyText": "nit EOF newline (spotless will catch I think)", "author": "jaycarlton", "createdAt": "2020-01-16T23:02:09Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/targetproperties/EgressEventTargetProperty.kt", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.pmiops.workbench.actionaudit.targetproperties\n+\n+import io.opencensus.common.Timestamp\n+import org.pmiops.workbench.model.EgressEvent\n+\n+enum class EgressEventTargetProperty\n+constructor(\n+    override val propertyName: String,\n+    override val extractor: (EgressEvent) -> String?\n+) : ModelBackedTargetProperty<EgressEvent> {\n+    EGRESS_MIB(\"egress_mib\",\n+            { it.egressMib?.toString() }),\n+    TIME_WINDOW_START(\"time_window_start\",\n+            {\n+                if (it.timeWindowStart != null)\n+                    Timestamp.fromMillis(it.timeWindowStart).toString()\n+                else \"[no time]\"\n+            }),\n+    TIME_WINDOW_DURATION(\"time_window_duration\",\n+            { it.timeWindowDuration?.toString() }),\n+    VM_NAME(\"vm_name\", { it.vmName });\n+}\n+\n+enum class EgressEventCommentTargetProperty\n+constructor(override val propertyName: String) : SimpleTargetProperty {\n+    COMMENT(\"comment\");\n+}", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0MjI4Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368042283", "bodyText": "Done", "author": "gjuggler", "createdAt": "2020-01-17T17:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDQ2Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367694463", "bodyText": "Thanks for structuring it this way.", "author": "jaycarlton", "createdAt": "2020-01-16T23:02:42Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/targetproperties/EgressEventTargetProperty.kt", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.pmiops.workbench.actionaudit.targetproperties\n+\n+import io.opencensus.common.Timestamp\n+import org.pmiops.workbench.model.EgressEvent\n+\n+enum class EgressEventTargetProperty\n+constructor(\n+    override val propertyName: String,\n+    override val extractor: (EgressEvent) -> String?\n+) : ModelBackedTargetProperty<EgressEvent> {\n+    EGRESS_MIB(\"egress_mib\",\n+            { it.egressMib?.toString() }),\n+    TIME_WINDOW_START(\"time_window_start\",\n+            {\n+                if (it.timeWindowStart != null)\n+                    Timestamp.fromMillis(it.timeWindowStart).toString()\n+                else \"[no time]\"\n+            }),\n+    TIME_WINDOW_DURATION(\"time_window_duration\",\n+            { it.timeWindowDuration?.toString() }),\n+    VM_NAME(\"vm_name\", { it.vmName });\n+}\n+\n+enum class EgressEventCommentTargetProperty\n+constructor(override val propertyName: String) : SimpleTargetProperty {\n+    COMMENT(\"comment\");", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0MTA5Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368041092", "bodyText": "Ack", "author": "gjuggler", "createdAt": "2020-01-17T17:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDY4MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367694680", "bodyText": "I'd make this a per-env property most likely. Can we simulate the events on Test and Local?", "author": "jaycarlton", "createdAt": "2020-01-16T23:03:26Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0Mzc2NA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368043764", "bodyText": "For all other files in the credentials bucket, the filename is constant across all environments. It would be inconsistent to break from that pattern.\n(Note: I am breaking with an existing pattern, where CloudStorageService houses the filename constants pointing to where each credential type lives. CH had made a point in my GoogleCredentials PR that that sort of stuff really doesn't belong in the cloud storage service \u2013\u00a0which I agree with!)", "author": "gjuggler", "createdAt": "2020-01-17T17:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NTA3Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367695077", "bodyText": "Should this just be a no-op with a warning?", "author": "jaycarlton", "createdAt": "2020-01-16T23:04:52Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";\n+\n+  private static final Logger log = Logger.getLogger(SumoLogicController.class.getName());\n+  private final SumoLogicAuditor sumoLogicAuditor;\n+  private final CloudStorageService cloudStorageService;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n+\n+  @Autowired\n+  SumoLogicController(\n+      SumoLogicAuditor sumoLogicAuditor,\n+      CloudStorageService cloudStorageService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.sumoLogicAuditor = sumoLogicAuditor;\n+    this.cloudStorageService = cloudStorageService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public ResponseEntity<EmptyResponse> logEgressEvent(\n+      String X_API_KEY, EgressEventRequest request) {\n+    if (!workbenchConfigProvider.get().featureFlags.enableSumoLogicEventHandling) {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMTM1Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367721352", "bodyText": "Nvm, it's a controller method, so this makes sense.", "author": "jaycarlton", "createdAt": "2020-01-17T00:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NTA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NTEzOA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367695138", "bodyText": "nit: check wrapping", "author": "jaycarlton", "createdAt": "2020-01-16T23:05:07Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";\n+\n+  private static final Logger log = Logger.getLogger(SumoLogicController.class.getName());\n+  private final SumoLogicAuditor sumoLogicAuditor;\n+  private final CloudStorageService cloudStorageService;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n+\n+  @Autowired\n+  SumoLogicController(\n+      SumoLogicAuditor sumoLogicAuditor,\n+      CloudStorageService cloudStorageService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.sumoLogicAuditor = sumoLogicAuditor;\n+    this.cloudStorageService = cloudStorageService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public ResponseEntity<EmptyResponse> logEgressEvent(\n+      String X_API_KEY, EgressEventRequest request) {\n+    if (!workbenchConfigProvider.get().featureFlags.enableSumoLogicEventHandling) {\n+      throw new BadRequestException(\"SumoLogic event handling is disabled in this environment.\");\n+    }\n+\n+    authorizeRequest(X_API_KEY, request);\n+\n+    try {\n+      // The \"eventsJsonArray\" field is a JSON-formatted array of EgressEvent JSON objects. Parse\n+      // this", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NDQ1OQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368044459", "bodyText": "Done. Spotless might have done something weird here.", "author": "gjuggler", "createdAt": "2020-01-17T17:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY5NTEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMjI4Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367722283", "bodyText": "What do you think about naming this more broadly as ExternalEventReportingController? If not, I'd still drop the SumoLogic and call it EgressViolationController or something, as above.", "author": "jaycarlton", "createdAt": "2020-01-17T00:49:04Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";\n+\n+  private static final Logger log = Logger.getLogger(SumoLogicController.class.getName());\n+  private final SumoLogicAuditor sumoLogicAuditor;\n+  private final CloudStorageService cloudStorageService;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n+\n+  @Autowired\n+  SumoLogicController(", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NDI2Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368044262", "bodyText": "I'd like to keep the name as-is. These API endpoints are specifically crafted for SumoLogic (e.g. the API signature would look different if we were accepting requests from some other service), so I think it's helpful for the controller name to reflect that connection point.", "author": "gjuggler", "createdAt": "2020-01-17T17:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMjI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMjc1NA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367722754", "bodyText": "as above, is this really only ever going to support sumologic, or could it work with other external technologies that detect egress events (not just thinking about Stackdriver here)?", "author": "jaycarlton", "createdAt": "2020-01-17T00:51:00Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -1085,6 +1085,34 @@ paths:\n           schema:\n             $ref: \"#/definitions/EmptyResponse\"\n \n+  /v1/admin/sumo/egressEvent:", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MzA3MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368053070", "bodyText": "I think it's fair to say that this API is designed to be SumoLogic-specific. If we build another system to ingest high-egress events, it would likely involve creating a distinct API signature (since so much of this structure was built around static structures from SumoLogic).", "author": "gjuggler", "createdAt": "2020-01-17T17:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMjc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMjk0Ng==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367722946", "bodyText": "nit: would 204 make more sense?", "author": "jaycarlton", "createdAt": "2020-01-17T00:51:55Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -1085,6 +1085,34 @@ paths:\n           schema:\n             $ref: \"#/definitions/EmptyResponse\"\n \n+  /v1/admin/sumo/egressEvent:\n+    post:\n+      tags:\n+        - sumoLogic\n+      description: >\n+        Registers an egress event detected by SumoLogic with the Workbench. Forwards the event\n+        to Stackdriver for recording and potential alerting.\n+      operationId: logEgressEvent\n+      security: []\n+      parameters:\n+        - in: body\n+          name: request\n+          description: Egress event request\n+          schema:\n+            $ref: \"#/definitions/EgressEventRequest\"\n+        - in: header\n+          name: X-API-KEY\n+          description: >\n+            Semi-secret API key sent by SumoLogic. This will be checked against the set of valid\n+            API keys stored in the per-environment credentials bucket.\n+          required: true\n+          type: string\n+      responses:\n+        200:", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NzYxNw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368057617", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-17T17:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMjk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMzYwMw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367723603", "bodyText": "Does this need to be an escaped string then, so it's not confused with the surrounding JSON? Is there a reason we didn't want to define SumoLogic's structure so we can have a typed array? On the one hand that breaks potentially if things change on their end, but on the other hand, it's probably going to break a couple levels downstream in that case.", "author": "jaycarlton", "createdAt": "2020-01-17T00:54:48Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -4011,3 +4039,50 @@ definitions:\n         description: >\n           A URL linking to an incident report where users can read more\n         type: string\n+\n+  EgressEventRequest:\n+    type: object\n+    properties:\n+      eventsJsonArray:\n+        type: string\n+        description: >\n+          A JSON string containing an array of JSON-encoded egress events. See the EgressEvent", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1ODIwNA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368058204", "bodyText": "SumoLogic passes this in as an escaped string. There's no way to change that. So I went with this hybrid approach, where the EgressEventRequest only takes a JSON string, but we have a separately-defined API model object representing the actual request contents. The controller (which has unit tests covering this) is responsible for parsing out the JSON into the array of API model objects.", "author": "gjuggler", "createdAt": "2020-01-17T17:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMzYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzODQ5OA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368138498", "bodyText": "Pretty much what I figured. Thanks.", "author": "jaycarlton", "createdAt": "2020-01-17T21:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyMzYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNDE4Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367724187", "bodyText": "nit: I'd break this out into a WorkbenchEnvironment enum for use elsewhere.\nInterestingly, this will be the first place all these are listed in one Java file. It feels a bit dangerous but I can't put my finger on why.", "author": "jaycarlton", "createdAt": "2020-01-17T00:57:09Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -4011,3 +4039,50 @@ definitions:\n         description: >\n           A URL linking to an incident report where users can read more\n         type: string\n+\n+  EgressEventRequest:\n+    type: object\n+    properties:\n+      eventsJsonArray:\n+        type: string\n+        description: >\n+          A JSON string containing an array of JSON-encoded egress events. See the EgressEvent\n+          definition for the expected schema of each event.\n+\n+  EgressEvent:\n+    type: object\n+    properties:\n+      environment:\n+        description: The AoU environment in which the high-egress event occurred.\n+        type: string\n+        enum:", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNDc1NA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367724754", "bodyText": "If it's a duration, then Epoch shouldn't enter into it, as long as the same starting point was used for both start and end times.", "author": "jaycarlton", "createdAt": "2020-01-17T00:59:26Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -4011,3 +4039,50 @@ definitions:\n         description: >\n           A URL linking to an incident report where users can read more\n         type: string\n+\n+  EgressEventRequest:\n+    type: object\n+    properties:\n+      eventsJsonArray:\n+        type: string\n+        description: >\n+          A JSON string containing an array of JSON-encoded egress events. See the EgressEvent\n+          definition for the expected schema of each event.\n+\n+  EgressEvent:\n+    type: object\n+    properties:\n+      environment:\n+        description: The AoU environment in which the high-egress event occurred.\n+        type: string\n+        enum:\n+          - test\n+          - perf\n+          - staging\n+          - stable\n+          - preprod\n+          - prod\n+      time_window_duration:\n+        description: >\n+          The duration of the time window during which the high-egress event occurred, in\n+          milliseconds since Unix Epoch.", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2MDgxNg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368060816", "bodyText": "Thanks \u2013\u00a0this description was way off mark. Done.", "author": "gjuggler", "createdAt": "2020-01-17T17:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNDc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNTIwNA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367725204", "bodyText": "nit: Maybe describe which kind of GCP project we're talking about here, as there are a lot of moving parts.", "author": "jaycarlton", "createdAt": "2020-01-17T01:01:21Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -4011,3 +4039,50 @@ definitions:\n         description: >\n           A URL linking to an incident report where users can read more\n         type: string\n+\n+  EgressEventRequest:\n+    type: object\n+    properties:\n+      eventsJsonArray:\n+        type: string\n+        description: >\n+          A JSON string containing an array of JSON-encoded egress events. See the EgressEvent\n+          definition for the expected schema of each event.\n+\n+  EgressEvent:\n+    type: object\n+    properties:\n+      environment:\n+        description: The AoU environment in which the high-egress event occurred.\n+        type: string\n+        enum:\n+          - test\n+          - perf\n+          - staging\n+          - stable\n+          - preprod\n+          - prod\n+      time_window_duration:\n+        description: >\n+          The duration of the time window during which the high-egress event occurred, in\n+          milliseconds since Unix Epoch.\n+        type: integer\n+        format: int64\n+      time_window_start:\n+        description: Beginning of the time window, in milliseconds since Epoch.\n+        type: integer\n+        format: int64\n+      egress_mib:\n+        description: The amount of egress detected during the window, in mebibytes (MiB).\n+        type: number\n+        format: double\n+      egress_mib_threshold:\n+        description: The threshold value for which this egress triggered an alert, in mebibytes (MiB).\n+        type: number\n+        format: double\n+      project_name:\n+        description: The Google Cloud project name, e.g. aou-rw-6b66533d. Always present.", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2MTA2OQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368061069", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-17T17:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNTQ2OQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367725469", "bodyText": "aside: if this will support other tools in the future, I wonder if you should have a field for the tool name (with a 1-element enum like jupyter). Maybe the vm_name would be a property on that. This is fine.", "author": "jaycarlton", "createdAt": "2020-01-17T01:02:29Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -4011,3 +4039,50 @@ definitions:\n         description: >\n           A URL linking to an incident report where users can read more\n         type: string\n+\n+  EgressEventRequest:\n+    type: object\n+    properties:\n+      eventsJsonArray:\n+        type: string\n+        description: >\n+          A JSON string containing an array of JSON-encoded egress events. See the EgressEvent\n+          definition for the expected schema of each event.\n+\n+  EgressEvent:\n+    type: object\n+    properties:\n+      environment:\n+        description: The AoU environment in which the high-egress event occurred.\n+        type: string\n+        enum:\n+          - test\n+          - perf\n+          - staging\n+          - stable\n+          - preprod\n+          - prod\n+      time_window_duration:\n+        description: >\n+          The duration of the time window during which the high-egress event occurred, in\n+          milliseconds since Unix Epoch.\n+        type: integer\n+        format: int64\n+      time_window_start:\n+        description: Beginning of the time window, in milliseconds since Epoch.\n+        type: integer\n+        format: int64\n+      egress_mib:\n+        description: The amount of egress detected during the window, in mebibytes (MiB).\n+        type: number\n+        format: double\n+      egress_mib_threshold:\n+        description: The threshold value for which this egress triggered an alert, in mebibytes (MiB).\n+        type: number\n+        format: double\n+      project_name:\n+        description: The Google Cloud project name, e.g. aou-rw-6b66533d. Always present.\n+        type: string\n+      vm_name:", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNjk5OA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367726998", "bodyText": "If you can, it's good to separate test from local, though I guess the latter can't be seen from sumologic. (There's a separate Audit log for Local, and separate Monitoring capabilities FWIW). If you're testing locally with curl, I'm not sure what happens. It should go to the local audit log.\nReally, each of these enums maps to a GCP project (and test & local map to the same one). I think this design assumes no splitting. It's a pet peeve of mine: seems like once we get enough round tuits, we should either support multiple envs per project everywhere, or we should split local into its own proper env so they're all 1:1.", "author": "jaycarlton", "createdAt": "2020-01-17T01:08:33Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -4011,3 +4039,50 @@ definitions:\n         description: >\n           A URL linking to an incident report where users can read more\n         type: string\n+\n+  EgressEventRequest:\n+    type: object\n+    properties:\n+      eventsJsonArray:\n+        type: string\n+        description: >\n+          A JSON string containing an array of JSON-encoded egress events. See the EgressEvent\n+          definition for the expected schema of each event.\n+\n+  EgressEvent:\n+    type: object\n+    properties:\n+      environment:\n+        description: The AoU environment in which the high-egress event occurred.\n+        type: string\n+        enum:\n+          - test", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1OTIwOA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368059208", "bodyText": "Yep \u2013\u00a0test & local will map to \"test\".", "author": "gjuggler", "createdAt": "2020-01-17T17:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNjk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNzQ2OQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367727469", "bodyText": "It would be nice to document (somewhere) these conventions and which ones are known contracts vs undocumented behavior. @blrubenstein pointed out that this VM name actually gets reused if we kill it and it comes back. This will make it difficult to distinguish between events happening to the same user, if I understand how this works. I may file a bug on that.", "author": "jaycarlton", "createdAt": "2020-01-17T01:10:49Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -4011,3 +4039,50 @@ definitions:\n         description: >\n           A URL linking to an incident report where users can read more\n         type: string\n+\n+  EgressEventRequest:\n+    type: object\n+    properties:\n+      eventsJsonArray:\n+        type: string\n+        description: >\n+          A JSON string containing an array of JSON-encoded egress events. See the EgressEvent\n+          definition for the expected schema of each event.\n+\n+  EgressEvent:\n+    type: object\n+    properties:\n+      environment:\n+        description: The AoU environment in which the high-egress event occurred.\n+        type: string\n+        enum:\n+          - test\n+          - perf\n+          - staging\n+          - stable\n+          - preprod\n+          - prod\n+      time_window_duration:\n+        description: >\n+          The duration of the time window during which the high-egress event occurred, in\n+          milliseconds since Unix Epoch.\n+        type: integer\n+        format: int64\n+      time_window_start:\n+        description: Beginning of the time window, in milliseconds since Epoch.\n+        type: integer\n+        format: int64\n+      egress_mib:\n+        description: The amount of egress detected during the window, in mebibytes (MiB).\n+        type: number\n+        format: double\n+      egress_mib_threshold:\n+        description: The threshold value for which this egress triggered an alert, in mebibytes (MiB).\n+        type: number\n+        format: double\n+      project_name:\n+        description: The Google Cloud project name, e.g. aou-rw-6b66533d. Always present.\n+        type: string\n+      vm_name:\n+        description: The name of the Jupyter VM which generated egress, e.g. all-of-us-260-m.", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2MzE0Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368063142", "bodyText": "I agree it's a bit messy the way we create things through Leonardo, but we're measuring things straight from GCP. We can & should continue to augment our system-level documentation, but it's not for this PR.", "author": "gjuggler", "createdAt": "2020-01-17T17:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyNzQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyODIzMA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367728230", "bodyText": "FWIW you don't have to specify prototype here, IIUC. The DI lookup doesn't consider whether or not it's a prototype.", "author": "jaycarlton", "createdAt": "2020-01-17T01:14:13Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/ActionAuditTestConfig.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import java.time.Clock;\n+import java.time.Instant;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.test.FakeClock;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.Scope;\n+\n+/** Common beans used by action audit test classes. */\n+@Configuration\n+public class ActionAuditTestConfig {\n+\n+  public static final Instant INSTANT = Instant.parse(\"2000-01-01T00:00:00.00Z\");\n+  public static final String ACTION_ID = \"9095d2f9-8db2-46c3-8f8e-4f90a62b457f\";\n+  public static final long ADMINISTRATOR_USER_ID = 222L;\n+  public static final String ADMINISTRATOR_EMAIL = \"admin@aou.biz\";\n+\n+  @Bean\n+  public static DbUser getUser() {\n+    final DbUser administrator = new DbUser();\n+    administrator.setUserId(ADMINISTRATOR_USER_ID);\n+    administrator.setUsername(ADMINISTRATOR_EMAIL);\n+    return administrator;\n+  }\n+\n+  @Bean(name = \"ACTION_ID\")\n+  @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MDAwMA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368090000", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-17T19:05:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyODIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcyODMyOQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367728329", "bodyText": "\ud83d\udc4f Love the consolidation!", "author": "jaycarlton", "createdAt": "2020-01-17T01:14:45Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/AuthDomainAuditorTest.java", "diffHunk": "@@ -16,67 +14,36 @@\n import org.pmiops.workbench.actionaudit.TargetType;\n import org.pmiops.workbench.actionaudit.targetproperties.AccountTargetProperty;\n import org.pmiops.workbench.actionaudit.targetproperties.values.AccountDisabledStatus;\n-import org.pmiops.workbench.db.model.DbUser;\n-import org.pmiops.workbench.test.FakeClock;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n import org.springframework.boot.test.context.TestConfiguration;\n import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Import;\n-import org.springframework.context.annotation.Scope;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n public class AuthDomainAuditorTest {\n \n   private static final long USER_ID = 101L;", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0MjM5MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367742390", "bodyText": "All the other entries are actions an agent takes directly. This one is a noun. I wonder it if would make sense to have a REPORT action, where EGRESS_LIMIT_EXCEEDED is a property value. That way you could query for all the reports the system flagged against a user or workspace.", "author": "jaycarlton", "createdAt": "2020-01-17T02:22:37Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionType.kt", "diffHunk": "@@ -10,5 +10,6 @@ enum class ActionType {\n     DUPLICATE_FROM,\n     DUPLICATE_TO,\n     COLLABORATE,\n-    DELETE\n+    DELETE,\n+    HIGH_EGRESS", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MzgyOQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367963829", "bodyText": "There are a number of naming-related suggestions in this round of review. My general attitude is that we should constrain the number of distinct terms in use, to limit the cognitive load on future maintainers of the codebase. While also optimizing for accuracy & conciseness.\nFor the action type, I'd actually say it should align with the EgressEvent term, which is the name I've given the core data model coming in from SumoLogic.\nMy instinct is that REPORT would be too generic to be useful here \u2013\u00a0there could be many types of activity that get bundled into that action type, which would limit its utility as a column to filter on.", "author": "gjuggler", "createdAt": "2020-01-17T14:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0MjM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0MTcwMQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368141701", "bodyText": "In reviewing this, I'm also reviewing hypothetical PRs in the future, and some of those are what's irking me. Not really fair to you I guess. I don't have the luxury of a real schema, so conventions are enforced by nagging.\nWhat about DETECT_EGRESS_VIOLATION? It aligns narrowly with this anomaly type and is still a present tense verb that makes sense with the target. (For purity, DETECT would be the action and VPC_EGRESS_VIOLATION would be the target, but that won't work well because the workspace needs to be the target.)\nThe other consideration is how we treat any future system-detected security or policy flags against a user or workspace. If it's a separate action for each one, that's OK, but might mean more bespoke querying. In other words, by choosing an action that matches your classes, you're tipping the scale such that there are going to be more actions to manage, which many not be a net loss in cognitive overhead.", "author": "jaycarlton", "createdAt": "2020-01-17T21:22:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0MjM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE4OTYyNw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368189627", "bodyText": "I'm willing to bite on the idea that consistency around verbs vs. nouns is important. How about DETECT_HIGH_EGRESS_EVENT?\nThis is edging towards too many word-tokens for comfort, but I think we'll survive it.", "author": "gjuggler", "createdAt": "2020-01-18T00:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0MjM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0MjI3OA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368242278", "bodyText": "That works, and balances out consistency with your other names.", "author": "jaycarlton", "createdAt": "2020-01-18T18:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0MjM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0Mzk1NQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367743955", "bodyText": "nit: use method reference this::handleEgressEvent.", "author": "jaycarlton", "createdAt": "2020-01-17T02:30:26Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";\n+\n+  private static final Logger log = Logger.getLogger(SumoLogicController.class.getName());\n+  private final SumoLogicAuditor sumoLogicAuditor;\n+  private final CloudStorageService cloudStorageService;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n+\n+  @Autowired\n+  SumoLogicController(\n+      SumoLogicAuditor sumoLogicAuditor,\n+      CloudStorageService cloudStorageService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.sumoLogicAuditor = sumoLogicAuditor;\n+    this.cloudStorageService = cloudStorageService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public ResponseEntity<EmptyResponse> logEgressEvent(\n+      String X_API_KEY, EgressEventRequest request) {\n+    if (!workbenchConfigProvider.get().featureFlags.enableSumoLogicEventHandling) {\n+      throw new BadRequestException(\"SumoLogic event handling is disabled in this environment.\");\n+    }\n+\n+    authorizeRequest(X_API_KEY, request);\n+\n+    try {\n+      // The \"eventsJsonArray\" field is a JSON-formatted array of EgressEvent JSON objects. Parse\n+      // this\n+      // out so we can work with each event as a model object.\n+      ObjectMapper mapper = new ObjectMapper();\n+      EgressEvent[] events = mapper.readValue(request.getEventsJsonArray(), EgressEvent[].class);\n+      Arrays.stream(events).forEach(event -> handleEgressEvent(event));", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NDYwMw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368044603", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-17T17:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0Mzk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NDMyNw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367744327", "bodyText": "Can we move this splitting logic into CloudStorageService and have it return a list for us?", "author": "jaycarlton", "createdAt": "2020-01-17T02:32:28Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";\n+\n+  private static final Logger log = Logger.getLogger(SumoLogicController.class.getName());\n+  private final SumoLogicAuditor sumoLogicAuditor;\n+  private final CloudStorageService cloudStorageService;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n+\n+  @Autowired\n+  SumoLogicController(\n+      SumoLogicAuditor sumoLogicAuditor,\n+      CloudStorageService cloudStorageService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.sumoLogicAuditor = sumoLogicAuditor;\n+    this.cloudStorageService = cloudStorageService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public ResponseEntity<EmptyResponse> logEgressEvent(\n+      String X_API_KEY, EgressEventRequest request) {\n+    if (!workbenchConfigProvider.get().featureFlags.enableSumoLogicEventHandling) {\n+      throw new BadRequestException(\"SumoLogic event handling is disabled in this environment.\");\n+    }\n+\n+    authorizeRequest(X_API_KEY, request);\n+\n+    try {\n+      // The \"eventsJsonArray\" field is a JSON-formatted array of EgressEvent JSON objects. Parse\n+      // this\n+      // out so we can work with each event as a model object.\n+      ObjectMapper mapper = new ObjectMapper();\n+      EgressEvent[] events = mapper.readValue(request.getEventsJsonArray(), EgressEvent[].class);\n+      Arrays.stream(events).forEach(event -> handleEgressEvent(event));\n+      return ResponseEntity.ok(new EmptyResponse());\n+    } catch (IOException e) {\n+      log.severe(\n+          String.format(\n+              \"Failed to parse SumoLogic egress event JSON: %s\", request.getEventsJsonArray()));\n+      log.severe(e.getMessage());\n+      this.sumoLogicAuditor.fireFailedToParseEgressEvent(request);\n+      throw new BadRequestException(\"Error parsing event details\");\n+    }\n+  }\n+\n+  /**\n+   * Reads the SumoLogic keys file to get the list of valid API key strings for inbound SumoLogic\n+   * requests.\n+   *\n+   * @return\n+   * @throws IOException\n+   */\n+  private List<String> getSumoLogicApiKeys() throws IOException {\n+    String apiKeys = cloudStorageService.getCredentialsBucketString(SUMOLOGIC_KEY_FILENAME);\n+    return Arrays.asList(apiKeys.split(\"[\\\\r\\\\n]+\"));", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NjY1Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368046653", "bodyText": "Meh \u2013\u00a0I think this is simple enough, and purpose-specific enough to this auth scheme, that it's reasonable to live here.", "author": "gjuggler", "createdAt": "2020-01-17T17:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NDMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NDQ2MQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367744461", "bodyText": "Should the key file name be configured per env?", "author": "jaycarlton", "createdAt": "2020-01-17T02:33:09Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";\n+\n+  private static final Logger log = Logger.getLogger(SumoLogicController.class.getName());\n+  private final SumoLogicAuditor sumoLogicAuditor;\n+  private final CloudStorageService cloudStorageService;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n+\n+  @Autowired\n+  SumoLogicController(\n+      SumoLogicAuditor sumoLogicAuditor,\n+      CloudStorageService cloudStorageService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.sumoLogicAuditor = sumoLogicAuditor;\n+    this.cloudStorageService = cloudStorageService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public ResponseEntity<EmptyResponse> logEgressEvent(\n+      String X_API_KEY, EgressEventRequest request) {\n+    if (!workbenchConfigProvider.get().featureFlags.enableSumoLogicEventHandling) {\n+      throw new BadRequestException(\"SumoLogic event handling is disabled in this environment.\");\n+    }\n+\n+    authorizeRequest(X_API_KEY, request);\n+\n+    try {\n+      // The \"eventsJsonArray\" field is a JSON-formatted array of EgressEvent JSON objects. Parse\n+      // this\n+      // out so we can work with each event as a model object.\n+      ObjectMapper mapper = new ObjectMapper();\n+      EgressEvent[] events = mapper.readValue(request.getEventsJsonArray(), EgressEvent[].class);\n+      Arrays.stream(events).forEach(event -> handleEgressEvent(event));\n+      return ResponseEntity.ok(new EmptyResponse());\n+    } catch (IOException e) {\n+      log.severe(\n+          String.format(\n+              \"Failed to parse SumoLogic egress event JSON: %s\", request.getEventsJsonArray()));\n+      log.severe(e.getMessage());\n+      this.sumoLogicAuditor.fireFailedToParseEgressEvent(request);\n+      throw new BadRequestException(\"Error parsing event details\");\n+    }\n+  }\n+\n+  /**\n+   * Reads the SumoLogic keys file to get the list of valid API key strings for inbound SumoLogic\n+   * requests.\n+   *\n+   * @return\n+   * @throws IOException\n+   */\n+  private List<String> getSumoLogicApiKeys() throws IOException {\n+    String apiKeys = cloudStorageService.getCredentialsBucketString(SUMOLOGIC_KEY_FILENAME);", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NjQzOQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368046439", "bodyText": "Nope \u2013\u00a0the creds bucket location is different for each env, but the filenames are constant for consistency.", "author": "gjuggler", "createdAt": "2020-01-17T17:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NDQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NTAwMg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367745002", "bodyText": "This feels kind of out of place here. I wonder if a stand-alone AouApiAuthService would make sense, both so we can reuse this logic for other tools or use cases, and more easily transition or enhance these endpoints to other auth schemes down the road.", "author": "jaycarlton", "createdAt": "2020-01-17T02:35:59Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";\n+\n+  private static final Logger log = Logger.getLogger(SumoLogicController.class.getName());\n+  private final SumoLogicAuditor sumoLogicAuditor;\n+  private final CloudStorageService cloudStorageService;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n+\n+  @Autowired\n+  SumoLogicController(\n+      SumoLogicAuditor sumoLogicAuditor,\n+      CloudStorageService cloudStorageService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.sumoLogicAuditor = sumoLogicAuditor;\n+    this.cloudStorageService = cloudStorageService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public ResponseEntity<EmptyResponse> logEgressEvent(\n+      String X_API_KEY, EgressEventRequest request) {\n+    if (!workbenchConfigProvider.get().featureFlags.enableSumoLogicEventHandling) {\n+      throw new BadRequestException(\"SumoLogic event handling is disabled in this environment.\");\n+    }\n+\n+    authorizeRequest(X_API_KEY, request);\n+\n+    try {\n+      // The \"eventsJsonArray\" field is a JSON-formatted array of EgressEvent JSON objects. Parse\n+      // this\n+      // out so we can work with each event as a model object.\n+      ObjectMapper mapper = new ObjectMapper();\n+      EgressEvent[] events = mapper.readValue(request.getEventsJsonArray(), EgressEvent[].class);\n+      Arrays.stream(events).forEach(event -> handleEgressEvent(event));\n+      return ResponseEntity.ok(new EmptyResponse());\n+    } catch (IOException e) {\n+      log.severe(\n+          String.format(\n+              \"Failed to parse SumoLogic egress event JSON: %s\", request.getEventsJsonArray()));\n+      log.severe(e.getMessage());\n+      this.sumoLogicAuditor.fireFailedToParseEgressEvent(request);\n+      throw new BadRequestException(\"Error parsing event details\");\n+    }\n+  }\n+\n+  /**\n+   * Reads the SumoLogic keys file to get the list of valid API key strings for inbound SumoLogic\n+   * requests.\n+   *\n+   * @return\n+   * @throws IOException\n+   */\n+  private List<String> getSumoLogicApiKeys() throws IOException {\n+    String apiKeys = cloudStorageService.getCredentialsBucketString(SUMOLOGIC_KEY_FILENAME);\n+    return Arrays.asList(apiKeys.split(\"[\\\\r\\\\n]+\"));\n+  }\n+\n+  /**\n+   * Authorizes an inbound EgressEventRequest with a given API key. If the API key is invalid, a\n+   * generic audit event is logged.\n+   *\n+   * @param apiKey\n+   * @param request\n+   */\n+  private void authorizeRequest(String apiKey, EgressEventRequest request) {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NzcwNg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368047706", "bodyText": "I generally try not to over-aggressively generalize things. It will be almost trivial to factor this out if & when it's needed elsewhere, and the whole controller is still quite small, so I don't think it's impacting maintainability.", "author": "gjuggler", "createdAt": "2020-01-17T17:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NTI4MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367745280", "bodyText": "Why not return a set? We don't want duplicates, don't rely on order, and are just using contains()", "author": "jaycarlton", "createdAt": "2020-01-17T02:37:43Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {\n+\n+  public static final String SUMOLOGIC_KEY_FILENAME = \"inbound-sumologic-keys.txt\";\n+\n+  private static final Logger log = Logger.getLogger(SumoLogicController.class.getName());\n+  private final SumoLogicAuditor sumoLogicAuditor;\n+  private final CloudStorageService cloudStorageService;\n+  private final Provider<WorkbenchConfig> workbenchConfigProvider;\n+\n+  @Autowired\n+  SumoLogicController(\n+      SumoLogicAuditor sumoLogicAuditor,\n+      CloudStorageService cloudStorageService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.sumoLogicAuditor = sumoLogicAuditor;\n+    this.cloudStorageService = cloudStorageService;\n+    this.workbenchConfigProvider = workbenchConfigProvider;\n+  }\n+\n+  @Override\n+  public ResponseEntity<EmptyResponse> logEgressEvent(\n+      String X_API_KEY, EgressEventRequest request) {\n+    if (!workbenchConfigProvider.get().featureFlags.enableSumoLogicEventHandling) {\n+      throw new BadRequestException(\"SumoLogic event handling is disabled in this environment.\");\n+    }\n+\n+    authorizeRequest(X_API_KEY, request);\n+\n+    try {\n+      // The \"eventsJsonArray\" field is a JSON-formatted array of EgressEvent JSON objects. Parse\n+      // this\n+      // out so we can work with each event as a model object.\n+      ObjectMapper mapper = new ObjectMapper();\n+      EgressEvent[] events = mapper.readValue(request.getEventsJsonArray(), EgressEvent[].class);\n+      Arrays.stream(events).forEach(event -> handleEgressEvent(event));\n+      return ResponseEntity.ok(new EmptyResponse());\n+    } catch (IOException e) {\n+      log.severe(\n+          String.format(\n+              \"Failed to parse SumoLogic egress event JSON: %s\", request.getEventsJsonArray()));\n+      log.severe(e.getMessage());\n+      this.sumoLogicAuditor.fireFailedToParseEgressEvent(request);\n+      throw new BadRequestException(\"Error parsing event details\");\n+    }\n+  }\n+\n+  /**\n+   * Reads the SumoLogic keys file to get the list of valid API key strings for inbound SumoLogic\n+   * requests.\n+   *\n+   * @return\n+   * @throws IOException\n+   */\n+  private List<String> getSumoLogicApiKeys() throws IOException {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NjI0Ng==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368046246", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-17T17:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NTI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NTk4Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367745983", "bodyText": "thinking out loud: I generally like to see dumb controllers that offload all the real work to services, but this is a special case where the auditor basically is the service.", "author": "jaycarlton", "createdAt": "2020-01-17T02:41:15Z", "path": "api/src/main/java/org/pmiops/workbench/api/SumoLogicController.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.pmiops.workbench.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import javax.inject.Provider;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.config.WorkbenchConfig;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.EmptyResponse;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+public class SumoLogicController implements SumoLogicApiDelegate {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0MjY2MQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368042661", "bodyText": "Agreed \u2013\u00a0the controller is less than 100 lines long, which is about where it should be for a simple authenticated request.", "author": "gjuggler", "createdAt": "2020-01-17T17:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NTk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NzA3Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367747077", "bodyText": "Note that since agentEmailMaybe is a String?, you can/should use null when you don't know the right value, instead of an empty string.\nBoth var and direct comparisons to null are rarely necessary. You can do val agentEmail: String = vmOwner?.username?: \"DEFAULT\" to avoid needing var.", "author": "jaycarlton", "createdAt": "2020-01-17T02:47:23Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.TargetPropertyExtractor\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.exceptions.BadRequestException\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {\n+        return ClusterController.clusterNameForUser(dbUser)\n+    }\n+\n+    /**\n+     * Converts the AoU-chosen cluster name into the actual VM name as reported by Google Cloud's\n+     * flow logs. Empirically, an \"-m\" suffix is added to the VM name.\n+     *\n+     * Note: this pattern may change if the Leo team switches to using raw VMs instead of Dataproc\n+     * clusters!\n+     */\n+    private fun dbUserToVmName(dbUser: DbUser): String {\n+        return dbUserToClusterName(dbUser) + \"-m\"\n+    }\n+\n+    override fun fireEgressEvent(event: EgressEvent) {\n+        // Load the workspace via the GCP project name\n+        val dbWorkspace = this.workspaceService.getByNamespace(event.projectName)\n+        if (dbWorkspace == null) {\n+            // Failing to find a workspace is odd enough that we want to return a non-success\n+            // response at the API level. But it's also worth storing a permanent record of the\n+            // high-egress event by logging it without a workspace target.\n+            fireFailedToFindWorkspace(event)\n+            throw BadRequestException(String.format(\n+                    \"The workspace '%s' referred to by the given event is no longer active or never existed.\",\n+                    event.projectName))\n+        }\n+        // Using service-level creds, load the FireCloud workspace ACLs to find all members\n+        // of the workspace. Then attempt to find the user who aligns with the named VM.\n+        val userRoles = workspaceService.getFirecloudUserRoles(dbWorkspace.workspaceNamespace,\n+                dbWorkspace.firecloudName)\n+        val vmOwner = userRoles\n+                .map { userDao.findUserByUsername(it.email) }\n+                .filter { dbUserToVmName(it).equals(event.vmName) }\n+                .firstOrNull()\n+\n+        var agentEmail = \"\"", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NzAxOA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367987018", "bodyText": "Thanks for the tips \u2013 I'll keep the if-else since I want to log a warning if the VM owner wasn't found.", "author": "gjuggler", "createdAt": "2020-01-17T15:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NzA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0ODE5Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367748193", "bodyText": "With the defaults set in the signature for fireEventSet, you can just do        fireEventSet(baseEvent = getGenericBaseEvent(), comment = String.format(...", "author": "jaycarlton", "createdAt": "2020-01-17T02:53:12Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.TargetPropertyExtractor\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.exceptions.BadRequestException\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {\n+        return ClusterController.clusterNameForUser(dbUser)\n+    }\n+\n+    /**\n+     * Converts the AoU-chosen cluster name into the actual VM name as reported by Google Cloud's\n+     * flow logs. Empirically, an \"-m\" suffix is added to the VM name.\n+     *\n+     * Note: this pattern may change if the Leo team switches to using raw VMs instead of Dataproc\n+     * clusters!\n+     */\n+    private fun dbUserToVmName(dbUser: DbUser): String {\n+        return dbUserToClusterName(dbUser) + \"-m\"\n+    }\n+\n+    override fun fireEgressEvent(event: EgressEvent) {\n+        // Load the workspace via the GCP project name\n+        val dbWorkspace = this.workspaceService.getByNamespace(event.projectName)\n+        if (dbWorkspace == null) {\n+            // Failing to find a workspace is odd enough that we want to return a non-success\n+            // response at the API level. But it's also worth storing a permanent record of the\n+            // high-egress event by logging it without a workspace target.\n+            fireFailedToFindWorkspace(event)\n+            throw BadRequestException(String.format(\n+                    \"The workspace '%s' referred to by the given event is no longer active or never existed.\",\n+                    event.projectName))\n+        }\n+        // Using service-level creds, load the FireCloud workspace ACLs to find all members\n+        // of the workspace. Then attempt to find the user who aligns with the named VM.\n+        val userRoles = workspaceService.getFirecloudUserRoles(dbWorkspace.workspaceNamespace,\n+                dbWorkspace.firecloudName)\n+        val vmOwner = userRoles\n+                .map { userDao.findUserByUsername(it.email) }\n+                .filter { dbUserToVmName(it).equals(event.vmName) }\n+                .firstOrNull()\n+\n+        var agentEmail = \"\"\n+        var agentId = 0L\n+        if (vmOwner != null) {\n+            agentEmail = vmOwner.username\n+            agentId = vmOwner.userId\n+        } else {\n+            // If the VM name doesn't match a user on the workspace, we'll still log an\n+            // event in the target workspace, but with nulled-out user info.\n+            logger.warning(String.format(\"Could not find a user for VM name %s in project %s\", event.vmName, event.projectName))\n+        }\n+\n+        val actionId = actionIdProvider.get()\n+        fireEventSet(ActionAuditEvent(\n+                timestamp = clock.millis(),\n+                actionId = actionId,\n+                actionType = ActionType.HIGH_EGRESS,\n+                agentType = AgentType.USER,\n+                agentId = agentId,\n+                agentEmailMaybe = agentEmail,\n+                targetType = TargetType.WORKSPACE,\n+                targetIdMaybe = dbWorkspace.workspaceId\n+        ), event, null)\n+    }\n+\n+    override fun fireFailedToParseEgressEvent(request: EgressEventRequest) {\n+        fireEventSet(getGenericBaseEvent(), null, String.format(\n+                \"Failed to parse egress event JSON from SumoLogic. Field contents: %s\",\n+                request.eventsJsonArray))\n+    }\n+\n+    override fun fireBadApiKeyEgressEvent(apiKey: String, request: EgressEventRequest) {\n+        fireEventSet(getGenericBaseEvent(), null, String.format(", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4NzYxNQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367987615", "bodyText": "Done", "author": "gjuggler", "createdAt": "2020-01-17T15:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0ODE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0OTU0Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367749543", "bodyText": "Kotlin trick: If we had multiple threads, then in some cases comment could change value in the block when using if but not when using the operator ?.let().\nSo I believe you can do comment?.let { events.add(baseEvent.copy( targetPropertyMaybe = EgressEventCommentTargetProperty.COMMENT.propertyName, newValueMaybe = comment )) } \nhttps://discuss.kotlinlang.org/t/let-vs-if-not-null/3542/6", "author": "jaycarlton", "createdAt": "2020-01-17T03:01:02Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorImpl.kt", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.pmiops.workbench.actionaudit.auditors\n+\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent\n+import org.pmiops.workbench.actionaudit.ActionAuditService\n+import org.pmiops.workbench.actionaudit.ActionType\n+import org.pmiops.workbench.actionaudit.AgentType\n+import org.pmiops.workbench.actionaudit.TargetType\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty\n+import org.pmiops.workbench.actionaudit.targetproperties.TargetPropertyExtractor\n+import org.pmiops.workbench.api.ClusterController\n+import org.pmiops.workbench.db.dao.UserDao\n+import org.pmiops.workbench.db.model.DbUser\n+import org.pmiops.workbench.exceptions.BadRequestException\n+import org.pmiops.workbench.model.EgressEvent\n+import org.pmiops.workbench.model.EgressEventRequest\n+import org.pmiops.workbench.workspaces.WorkspaceService\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.beans.factory.annotation.Qualifier\n+import org.springframework.stereotype.Service\n+import java.time.Clock\n+import java.util.logging.Logger\n+import javax.inject.Provider\n+\n+@Service\n+class SumoLogicAuditorImpl @Autowired\n+constructor(\n+    private val actionAuditService: ActionAuditService,\n+    private val workspaceService: WorkspaceService,\n+    private val userDao: UserDao,\n+    private val clock: Clock,\n+    @Qualifier(\"ACTION_ID\") private val actionIdProvider: Provider<String>\n+) : SumoLogicAuditor {\n+\n+    /**\n+     * Converts a DB-internal user ID to the corresponding VM name. Note: for now, we use the same\n+     * logic used by ClusterController, but if that logic changes, we may want to adapt this code\n+     * to support searching for VMs with both the older and newer naming scheme.\n+     */\n+    private fun dbUserToClusterName(dbUser: DbUser): String {\n+        return ClusterController.clusterNameForUser(dbUser)\n+    }\n+\n+    /**\n+     * Converts the AoU-chosen cluster name into the actual VM name as reported by Google Cloud's\n+     * flow logs. Empirically, an \"-m\" suffix is added to the VM name.\n+     *\n+     * Note: this pattern may change if the Leo team switches to using raw VMs instead of Dataproc\n+     * clusters!\n+     */\n+    private fun dbUserToVmName(dbUser: DbUser): String {\n+        return dbUserToClusterName(dbUser) + \"-m\"\n+    }\n+\n+    override fun fireEgressEvent(event: EgressEvent) {\n+        // Load the workspace via the GCP project name\n+        val dbWorkspace = this.workspaceService.getByNamespace(event.projectName)\n+        if (dbWorkspace == null) {\n+            // Failing to find a workspace is odd enough that we want to return a non-success\n+            // response at the API level. But it's also worth storing a permanent record of the\n+            // high-egress event by logging it without a workspace target.\n+            fireFailedToFindWorkspace(event)\n+            throw BadRequestException(String.format(\n+                    \"The workspace '%s' referred to by the given event is no longer active or never existed.\",\n+                    event.projectName))\n+        }\n+        // Using service-level creds, load the FireCloud workspace ACLs to find all members\n+        // of the workspace. Then attempt to find the user who aligns with the named VM.\n+        val userRoles = workspaceService.getFirecloudUserRoles(dbWorkspace.workspaceNamespace,\n+                dbWorkspace.firecloudName)\n+        val vmOwner = userRoles\n+                .map { userDao.findUserByUsername(it.email) }\n+                .filter { dbUserToVmName(it).equals(event.vmName) }\n+                .firstOrNull()\n+\n+        var agentEmail = \"\"\n+        var agentId = 0L\n+        if (vmOwner != null) {\n+            agentEmail = vmOwner.username\n+            agentId = vmOwner.userId\n+        } else {\n+            // If the VM name doesn't match a user on the workspace, we'll still log an\n+            // event in the target workspace, but with nulled-out user info.\n+            logger.warning(String.format(\"Could not find a user for VM name %s in project %s\", event.vmName, event.projectName))\n+        }\n+\n+        val actionId = actionIdProvider.get()\n+        fireEventSet(ActionAuditEvent(\n+                timestamp = clock.millis(),\n+                actionId = actionId,\n+                actionType = ActionType.HIGH_EGRESS,\n+                agentType = AgentType.USER,\n+                agentId = agentId,\n+                agentEmailMaybe = agentEmail,\n+                targetType = TargetType.WORKSPACE,\n+                targetIdMaybe = dbWorkspace.workspaceId\n+        ), event, null)\n+    }\n+\n+    override fun fireFailedToParseEgressEvent(request: EgressEventRequest) {\n+        fireEventSet(getGenericBaseEvent(), null, String.format(\n+                \"Failed to parse egress event JSON from SumoLogic. Field contents: %s\",\n+                request.eventsJsonArray))\n+    }\n+\n+    override fun fireBadApiKeyEgressEvent(apiKey: String, request: EgressEventRequest) {\n+        fireEventSet(getGenericBaseEvent(), null, String.format(\n+                \"Received bad API key from SumoLogic. Bad key: %s, full request: %s\",\n+                apiKey, request.toString()))\n+    }\n+\n+    private fun fireFailedToFindWorkspace(event: EgressEvent) {\n+        fireEventSet(getGenericBaseEvent(), event, String.format(\n+                \"Failed to find workspace for high-egress event: %s\",\n+                event.toString()))\n+    }\n+\n+    /**\n+     * Creates and fires a set of events derived from the given base event, incorporating audit rows\n+     * to record properties of the egress event and a human-readable comment. Either the egress event\n+     * or the comment may be null, in which case those row(s) won't be generated.\n+     */\n+    private fun fireEventSet(baseEvent: ActionAuditEvent, egressEvent: EgressEvent?, comment: String?) {\n+        var events = ArrayList<ActionAuditEvent>()\n+        if (egressEvent != null) {\n+            val propertyValues = TargetPropertyExtractor.getPropertyValuesByName(\n+                    EgressEventTargetProperty.values(), egressEvent)\n+            events.addAll(propertyValues.map {\n+                baseEvent.copy(\n+                        targetPropertyMaybe = it.key,\n+                        newValueMaybe = it.value)\n+            })\n+        }\n+        if (comment != null) {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4OTc2Ng==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367989766", "bodyText": "Interesting trick \u2013\u00a0I don't think it's necessary here though, unless there's something I missed.", "author": "gjuggler", "createdAt": "2020-01-17T15:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0OTU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0OTY5Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367749697", "bodyText": "I'd probably make an enum with these values or store them in per-env configs. In principle we could have separate Moodles, etc.", "author": "jaycarlton", "createdAt": "2020-01-17T03:01:57Z", "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "diffHunk": "@@ -36,7 +36,7 @@ public CloudStorageServiceImpl(Provider<WorkbenchConfig> configProvider) {\n \n   @Override\n   public String readInvitationKey() {\n-    return readCredentialsBucketString(\"invitation-key.txt\");\n+    return getCredentialsBucketString(\"invitation-key.txt\");", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0OTg5Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367749897", "bodyText": "Please return Optional<DbWorkspace> instead of using null.", "author": "jaycarlton", "createdAt": "2020-01-17T03:03:20Z", "path": "api/src/main/java/org/pmiops/workbench/workspaces/WorkspaceService.java", "diffHunk": "@@ -27,6 +27,10 @@\n \n   DbWorkspace get(String ns, String firecloudName);\n \n+  // Returns the requested workspace looked up by workspace namespace (aka billing project name).\n+  // Only active workspaces are searched. Returns null if no active workspace is found.\n+  DbWorkspace getByNamespace(String workspaceNamespace);", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MTI3MQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368051271", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-17T17:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0OTg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDA2MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367750060", "bodyText": "I believe you can return an optional here, if you do so in the Dao.", "author": "jaycarlton", "createdAt": "2020-01-17T03:04:21Z", "path": "api/src/main/java/org/pmiops/workbench/workspaces/WorkspaceServiceImpl.java", "diffHunk": "@@ -235,6 +235,12 @@ public DbWorkspace getRequired(String ns, String firecloudName) {\n     return workspace;\n   }\n \n+  @Override\n+  public DbWorkspace getByNamespace(String ns) {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MTkwMw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368051903", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-17T17:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDI2NQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367750265", "bodyText": "nit: UserRole could just define its own internal Comparator and implement Comparable so you don't need to do it below.", "author": "jaycarlton", "createdAt": "2020-01-17T03:05:39Z", "path": "api/src/main/java/org/pmiops/workbench/workspaces/WorkspaceServiceImpl.java", "diffHunk": "@@ -500,8 +506,10 @@ public DbWorkspace getWorkspaceEnforceAccessLevelAndSetCdrVersion(\n   }\n \n   @Override\n-  public List<UserRole> convertWorkspaceAclsToUserRoles(\n-      Map<String, FirecloudWorkspaceAccessEntry> rolesMap) {\n+  public List<UserRole> getFirecloudUserRoles(String workspaceNamespace, String firecloudName) {\n+    Map<String, FirecloudWorkspaceAccessEntry> rolesMap =\n+        getFirecloudWorkspaceAcls(workspaceNamespace, firecloudName);\n+", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDQ3NA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367750474", "bodyText": "nit: it helps to name maps like keyToValue", "author": "jaycarlton", "createdAt": "2020-01-17T03:06:55Z", "path": "api/src/main/java/org/pmiops/workbench/workspaces/WorkspaceServiceImpl.java", "diffHunk": "@@ -500,8 +506,10 @@ public DbWorkspace getWorkspaceEnforceAccessLevelAndSetCdrVersion(\n   }\n \n   @Override\n-  public List<UserRole> convertWorkspaceAclsToUserRoles(\n-      Map<String, FirecloudWorkspaceAccessEntry> rolesMap) {\n+  public List<UserRole> getFirecloudUserRoles(String workspaceNamespace, String firecloudName) {\n+    Map<String, FirecloudWorkspaceAccessEntry> rolesMap =", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MjQzNw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368052437", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-01-17T17:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDY4MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367750680", "bodyText": "Might make sense to give this a Name, and have another one for a regular user.", "author": "jaycarlton", "createdAt": "2020-01-17T03:08:03Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/ActionAuditTestConfig.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import java.time.Clock;\n+import java.time.Instant;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.test.FakeClock;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.Scope;\n+\n+/** Common beans used by action audit test classes. */\n+@Configuration\n+public class ActionAuditTestConfig {\n+\n+  public static final Instant INSTANT = Instant.parse(\"2000-01-01T00:00:00.00Z\");\n+  public static final String ACTION_ID = \"9095d2f9-8db2-46c3-8f8e-4f90a62b457f\";\n+  public static final long ADMINISTRATOR_USER_ID = 222L;\n+  public static final String ADMINISTRATOR_EMAIL = \"admin@aou.biz\";\n+\n+  @Bean\n+  public static DbUser getUser() {", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDc3Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367750772", "bodyText": "Oh, so that's how you do it. Neat.", "author": "jaycarlton", "createdAt": "2020-01-17T03:08:35Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/AuthDomainAuditorTest.java", "diffHunk": "@@ -16,67 +14,36 @@\n import org.pmiops.workbench.actionaudit.TargetType;\n import org.pmiops.workbench.actionaudit.targetproperties.AccountTargetProperty;\n import org.pmiops.workbench.actionaudit.targetproperties.values.AccountDisabledStatus;\n-import org.pmiops.workbench.db.model.DbUser;\n-import org.pmiops.workbench.test.FakeClock;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n import org.springframework.boot.test.context.TestConfiguration;\n import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Import;\n-import org.springframework.context.annotation.Scope;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n public class AuthDomainAuditorTest {\n \n   private static final long USER_ID = 101L;\n-  private static final long ADMINISTRATOR_USER_ID = 222L;\n-  private static final String ADMINISTRATOR_EMAIL = \"admin@aou.biz\";\n-  private static final Instant INSTANT = Instant.parse(\"2000-01-01T00:00:00.00Z\");\n-  private static final String ACTION_ID = \"9095d2f9-8db2-46c3-8f8e-4f90a62b457f\";\n-\n-  @Autowired private ActionAuditService mockActionAuditService;\n-\n-  @Captor private ArgumentCaptor<ActionAuditEvent> eventCaptor;\n \n   @Autowired private AuthDomainAuditor authDomainAuditAdapter;\n+  @MockBean private ActionAuditService mockActionAuditService;\n+  @Captor private ArgumentCaptor<ActionAuditEvent> eventCaptor;\n \n   @TestConfiguration\n-  @Import({AuthDomainAuditorImpl.class})\n-  @MockBean({ActionAuditService.class})\n-  static class Config {\n-    @Bean(name = \"ACTION_ID\")\n-    @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n-    public String getActionId() {\n-      return ACTION_ID;\n-    }\n-\n-    @Bean\n-    public DbUser getUser() {\n-      final DbUser administrator = new DbUser();\n-      administrator.setUserId(ADMINISTRATOR_USER_ID);\n-      administrator.setUsername(ADMINISTRATOR_EMAIL);\n-      return administrator;\n-    }\n-\n-    @Bean\n-    public Clock getClock() {\n-      return new FakeClock(INSTANT);\n-    }\n-  }\n+  @Import({AuthDomainAuditorImpl.class, ActionAuditTestConfig.class})", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDkwNw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367750907", "bodyText": "Cool. I didn't know about this version. I'd been using @Autowired even for the mocks and putting a @MockBean on the config class.", "author": "jaycarlton", "createdAt": "2020-01-17T03:09:22Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/AuthDomainAuditorTest.java", "diffHunk": "@@ -16,67 +14,36 @@\n import org.pmiops.workbench.actionaudit.TargetType;\n import org.pmiops.workbench.actionaudit.targetproperties.AccountTargetProperty;\n import org.pmiops.workbench.actionaudit.targetproperties.values.AccountDisabledStatus;\n-import org.pmiops.workbench.db.model.DbUser;\n-import org.pmiops.workbench.test.FakeClock;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n import org.springframework.boot.test.context.TestConfiguration;\n import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Import;\n-import org.springframework.context.annotation.Scope;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n public class AuthDomainAuditorTest {\n \n   private static final long USER_ID = 101L;\n-  private static final long ADMINISTRATOR_USER_ID = 222L;\n-  private static final String ADMINISTRATOR_EMAIL = \"admin@aou.biz\";\n-  private static final Instant INSTANT = Instant.parse(\"2000-01-01T00:00:00.00Z\");\n-  private static final String ACTION_ID = \"9095d2f9-8db2-46c3-8f8e-4f90a62b457f\";\n-\n-  @Autowired private ActionAuditService mockActionAuditService;\n-\n-  @Captor private ArgumentCaptor<ActionAuditEvent> eventCaptor;\n \n   @Autowired private AuthDomainAuditor authDomainAuditAdapter;\n+  @MockBean private ActionAuditService mockActionAuditService;", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MDM5OQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368090399", "bodyText": "Yeah, I think I only discovered this while digging into some Spring examples out on the internets. I think it's marginally cleaner this way.", "author": "gjuggler", "createdAt": "2020-01-17T19:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDkwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzODgwMw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368138803", "bodyText": "Yep, there's less duplication and you don't rely only on the name convention.", "author": "jaycarlton", "createdAt": "2020-01-17T21:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MDkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MTUzNQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367751535", "bodyText": "I was going to say, you can make these a bit shorter and avoid collecting by using allMatch(). But then your assertion failure message wouldn't be as clear. So keep it this way.", "author": "jaycarlton", "createdAt": "2020-01-17T03:12:51Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.ActionType;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty;\n+import org.pmiops.workbench.db.dao.UserDao;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class SumoLogicAuditorTest {\n+\n+  private static final long USER_ID = 1L;\n+  private static final String USER_EMAIL = \"user@researchallofus.org\";\n+  private static final long WORKSPACE_ID = 1L;\n+  private static final String WORKSPACE_NAMESPACE = \"aou-rw-test-c7dec260\";\n+  private static final String WORKSPACE_FIRECLOUD_NAME = \"mytestworkspacename\";\n+\n+  private static final String EGRESS_EVENT_PROJECT_NAME = WORKSPACE_NAMESPACE;\n+  private static final String EGRESS_EVENT_VM_NAME = \"all-of-us-\" + USER_ID + \"-m\";\n+\n+  // Pre-built data objects for test.\n+  private DbUser dbUser;\n+  private DbWorkspace dbWorkspace;\n+  private List<UserRole> firecloudUserRoles = new ArrayList<>();\n+\n+  @Autowired private SumoLogicAuditor sumoLogicAuditor;\n+\n+  @MockBean private ActionAuditService mockActionAuditService;\n+  @MockBean private WorkspaceService mockWorkspaceService;\n+  @MockBean private UserDao mockUserDao;\n+\n+  @Captor private ArgumentCaptor<Collection<ActionAuditEvent>> eventsCaptor;\n+\n+  @Rule public final ExpectedException exception = ExpectedException.none();\n+\n+  @Before\n+  public void setUp() {\n+    dbUser = new DbUser();\n+    dbUser.setUserId(USER_ID);\n+    dbUser.setUsername(USER_EMAIL);\n+    when(mockUserDao.findUserByUsername(USER_EMAIL)).thenReturn(dbUser);\n+\n+    dbWorkspace = new DbWorkspace();\n+    dbWorkspace.setWorkspaceId(WORKSPACE_ID);\n+    dbWorkspace.setWorkspaceNamespace(WORKSPACE_NAMESPACE);\n+    dbWorkspace.setFirecloudName(WORKSPACE_FIRECLOUD_NAME);\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(dbWorkspace);\n+    firecloudUserRoles.add(new UserRole().email(USER_EMAIL));\n+    when(mockWorkspaceService.getFirecloudUserRoles(WORKSPACE_NAMESPACE, WORKSPACE_FIRECLOUD_NAME))\n+        .thenReturn(firecloudUserRoles);\n+  }\n+\n+  Set<String> extractValuesFromEvents(\n+      Collection<ActionAuditEvent> events, Function<ActionAuditEvent, String> fn) {\n+    return events.stream().map(fn).collect(Collectors.toSet());\n+  }\n+\n+  @Test\n+  public void testFireEgressEvent() {\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent()\n+            .projectName(EGRESS_EVENT_PROJECT_NAME)\n+            .vmName(EGRESS_EVENT_VM_NAME)\n+            .timeWindowStart(0l)\n+            .egressMib(12.3));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Ensure all events have the expected set of constant fields.\n+    assertThat(events.stream().map(event -> event.getAgentType()).collect(Collectors.toSet()))\n+        .containsExactly(AgentType.USER);\n+    assertThat(events.stream().map(event -> event.getActionType()).collect(Collectors.toSet()))", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MTkyNw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367751927", "bodyText": "You can use method references like ActionAuditEvent::getEmailMaybe.", "author": "jaycarlton", "createdAt": "2020-01-17T03:15:17Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.ActionType;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty;\n+import org.pmiops.workbench.db.dao.UserDao;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class SumoLogicAuditorTest {\n+\n+  private static final long USER_ID = 1L;\n+  private static final String USER_EMAIL = \"user@researchallofus.org\";\n+  private static final long WORKSPACE_ID = 1L;\n+  private static final String WORKSPACE_NAMESPACE = \"aou-rw-test-c7dec260\";\n+  private static final String WORKSPACE_FIRECLOUD_NAME = \"mytestworkspacename\";\n+\n+  private static final String EGRESS_EVENT_PROJECT_NAME = WORKSPACE_NAMESPACE;\n+  private static final String EGRESS_EVENT_VM_NAME = \"all-of-us-\" + USER_ID + \"-m\";\n+\n+  // Pre-built data objects for test.\n+  private DbUser dbUser;\n+  private DbWorkspace dbWorkspace;\n+  private List<UserRole> firecloudUserRoles = new ArrayList<>();\n+\n+  @Autowired private SumoLogicAuditor sumoLogicAuditor;\n+\n+  @MockBean private ActionAuditService mockActionAuditService;\n+  @MockBean private WorkspaceService mockWorkspaceService;\n+  @MockBean private UserDao mockUserDao;\n+\n+  @Captor private ArgumentCaptor<Collection<ActionAuditEvent>> eventsCaptor;\n+\n+  @Rule public final ExpectedException exception = ExpectedException.none();\n+\n+  @Before\n+  public void setUp() {\n+    dbUser = new DbUser();\n+    dbUser.setUserId(USER_ID);\n+    dbUser.setUsername(USER_EMAIL);\n+    when(mockUserDao.findUserByUsername(USER_EMAIL)).thenReturn(dbUser);\n+\n+    dbWorkspace = new DbWorkspace();\n+    dbWorkspace.setWorkspaceId(WORKSPACE_ID);\n+    dbWorkspace.setWorkspaceNamespace(WORKSPACE_NAMESPACE);\n+    dbWorkspace.setFirecloudName(WORKSPACE_FIRECLOUD_NAME);\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(dbWorkspace);\n+    firecloudUserRoles.add(new UserRole().email(USER_EMAIL));\n+    when(mockWorkspaceService.getFirecloudUserRoles(WORKSPACE_NAMESPACE, WORKSPACE_FIRECLOUD_NAME))\n+        .thenReturn(firecloudUserRoles);\n+  }\n+\n+  Set<String> extractValuesFromEvents(\n+      Collection<ActionAuditEvent> events, Function<ActionAuditEvent, String> fn) {\n+    return events.stream().map(fn).collect(Collectors.toSet());\n+  }\n+\n+  @Test\n+  public void testFireEgressEvent() {\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent()\n+            .projectName(EGRESS_EVENT_PROJECT_NAME)\n+            .vmName(EGRESS_EVENT_VM_NAME)\n+            .timeWindowStart(0l)\n+            .egressMib(12.3));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Ensure all events have the expected set of constant fields.\n+    assertThat(events.stream().map(event -> event.getAgentType()).collect(Collectors.toSet()))\n+        .containsExactly(AgentType.USER);\n+    assertThat(events.stream().map(event -> event.getActionType()).collect(Collectors.toSet()))\n+        .containsExactly(ActionType.HIGH_EGRESS);\n+    assertThat(events.stream().map(event -> event.getAgentId()).collect(Collectors.toSet()))\n+        .containsExactly(USER_ID);\n+    assertThat(events.stream().map(event -> event.getAgentEmailMaybe()).collect(Collectors.toSet()))\n+        .containsExactly(USER_EMAIL);\n+    assertThat(events.stream().map(event -> event.getTargetIdMaybe()).collect(Collectors.toSet()))", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MTEyNw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368091127", "bodyText": "In this case, the lambda actually saves characters :)", "author": "gjuggler", "createdAt": "2020-01-17T19:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MTkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzOTY1MQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368139651", "bodyText": "But you gain an operator, and a scope, and lose at least half an abstraction level :/", "author": "jaycarlton", "createdAt": "2020-01-17T21:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MTkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MjMwNQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367752305", "bodyText": "You're doing enough of this that it could be helpful to have an assertion helper funciton in the parent class like assertContainsUniqueValue(Collection<T> objects, Function<T, U> extractor, U value); I Could use that in a few places as well.", "author": "jaycarlton", "createdAt": "2020-01-17T03:17:04Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.ActionType;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty;\n+import org.pmiops.workbench.db.dao.UserDao;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class SumoLogicAuditorTest {\n+\n+  private static final long USER_ID = 1L;\n+  private static final String USER_EMAIL = \"user@researchallofus.org\";\n+  private static final long WORKSPACE_ID = 1L;\n+  private static final String WORKSPACE_NAMESPACE = \"aou-rw-test-c7dec260\";\n+  private static final String WORKSPACE_FIRECLOUD_NAME = \"mytestworkspacename\";\n+\n+  private static final String EGRESS_EVENT_PROJECT_NAME = WORKSPACE_NAMESPACE;\n+  private static final String EGRESS_EVENT_VM_NAME = \"all-of-us-\" + USER_ID + \"-m\";\n+\n+  // Pre-built data objects for test.\n+  private DbUser dbUser;\n+  private DbWorkspace dbWorkspace;\n+  private List<UserRole> firecloudUserRoles = new ArrayList<>();\n+\n+  @Autowired private SumoLogicAuditor sumoLogicAuditor;\n+\n+  @MockBean private ActionAuditService mockActionAuditService;\n+  @MockBean private WorkspaceService mockWorkspaceService;\n+  @MockBean private UserDao mockUserDao;\n+\n+  @Captor private ArgumentCaptor<Collection<ActionAuditEvent>> eventsCaptor;\n+\n+  @Rule public final ExpectedException exception = ExpectedException.none();\n+\n+  @Before\n+  public void setUp() {\n+    dbUser = new DbUser();\n+    dbUser.setUserId(USER_ID);\n+    dbUser.setUsername(USER_EMAIL);\n+    when(mockUserDao.findUserByUsername(USER_EMAIL)).thenReturn(dbUser);\n+\n+    dbWorkspace = new DbWorkspace();\n+    dbWorkspace.setWorkspaceId(WORKSPACE_ID);\n+    dbWorkspace.setWorkspaceNamespace(WORKSPACE_NAMESPACE);\n+    dbWorkspace.setFirecloudName(WORKSPACE_FIRECLOUD_NAME);\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(dbWorkspace);\n+    firecloudUserRoles.add(new UserRole().email(USER_EMAIL));\n+    when(mockWorkspaceService.getFirecloudUserRoles(WORKSPACE_NAMESPACE, WORKSPACE_FIRECLOUD_NAME))\n+        .thenReturn(firecloudUserRoles);\n+  }\n+\n+  Set<String> extractValuesFromEvents(\n+      Collection<ActionAuditEvent> events, Function<ActionAuditEvent, String> fn) {\n+    return events.stream().map(fn).collect(Collectors.toSet());\n+  }\n+\n+  @Test\n+  public void testFireEgressEvent() {\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent()\n+            .projectName(EGRESS_EVENT_PROJECT_NAME)\n+            .vmName(EGRESS_EVENT_VM_NAME)\n+            .timeWindowStart(0l)\n+            .egressMib(12.3));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Ensure all events have the expected set of constant fields.\n+    assertThat(events.stream().map(event -> event.getAgentType()).collect(Collectors.toSet()))\n+        .containsExactly(AgentType.USER);\n+    assertThat(events.stream().map(event -> event.getActionType()).collect(Collectors.toSet()))\n+        .containsExactly(ActionType.HIGH_EGRESS);\n+    assertThat(events.stream().map(event -> event.getAgentId()).collect(Collectors.toSet()))", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MDg3Nw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368090877", "bodyText": "Yeah... I almost started doing that, but it only would have saved a \"bit\" of code, and would add indirection which has a cost on readability. I'll leave as-is, but I agree some helpers may be warranted if this grows in size.", "author": "gjuggler", "createdAt": "2020-01-17T19:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MjMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MjYwNQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367752605", "bodyText": "nit: for Java string comparisons, it's nice to put the known non-null string on the left so you can use .equals()", "author": "jaycarlton", "createdAt": "2020-01-17T03:18:36Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.ActionType;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty;\n+import org.pmiops.workbench.db.dao.UserDao;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class SumoLogicAuditorTest {\n+\n+  private static final long USER_ID = 1L;\n+  private static final String USER_EMAIL = \"user@researchallofus.org\";\n+  private static final long WORKSPACE_ID = 1L;\n+  private static final String WORKSPACE_NAMESPACE = \"aou-rw-test-c7dec260\";\n+  private static final String WORKSPACE_FIRECLOUD_NAME = \"mytestworkspacename\";\n+\n+  private static final String EGRESS_EVENT_PROJECT_NAME = WORKSPACE_NAMESPACE;\n+  private static final String EGRESS_EVENT_VM_NAME = \"all-of-us-\" + USER_ID + \"-m\";\n+\n+  // Pre-built data objects for test.\n+  private DbUser dbUser;\n+  private DbWorkspace dbWorkspace;\n+  private List<UserRole> firecloudUserRoles = new ArrayList<>();\n+\n+  @Autowired private SumoLogicAuditor sumoLogicAuditor;\n+\n+  @MockBean private ActionAuditService mockActionAuditService;\n+  @MockBean private WorkspaceService mockWorkspaceService;\n+  @MockBean private UserDao mockUserDao;\n+\n+  @Captor private ArgumentCaptor<Collection<ActionAuditEvent>> eventsCaptor;\n+\n+  @Rule public final ExpectedException exception = ExpectedException.none();\n+\n+  @Before\n+  public void setUp() {\n+    dbUser = new DbUser();\n+    dbUser.setUserId(USER_ID);\n+    dbUser.setUsername(USER_EMAIL);\n+    when(mockUserDao.findUserByUsername(USER_EMAIL)).thenReturn(dbUser);\n+\n+    dbWorkspace = new DbWorkspace();\n+    dbWorkspace.setWorkspaceId(WORKSPACE_ID);\n+    dbWorkspace.setWorkspaceNamespace(WORKSPACE_NAMESPACE);\n+    dbWorkspace.setFirecloudName(WORKSPACE_FIRECLOUD_NAME);\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(dbWorkspace);\n+    firecloudUserRoles.add(new UserRole().email(USER_EMAIL));\n+    when(mockWorkspaceService.getFirecloudUserRoles(WORKSPACE_NAMESPACE, WORKSPACE_FIRECLOUD_NAME))\n+        .thenReturn(firecloudUserRoles);\n+  }\n+\n+  Set<String> extractValuesFromEvents(\n+      Collection<ActionAuditEvent> events, Function<ActionAuditEvent, String> fn) {\n+    return events.stream().map(fn).collect(Collectors.toSet());\n+  }\n+\n+  @Test\n+  public void testFireEgressEvent() {\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent()\n+            .projectName(EGRESS_EVENT_PROJECT_NAME)\n+            .vmName(EGRESS_EVENT_VM_NAME)\n+            .timeWindowStart(0l)\n+            .egressMib(12.3));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Ensure all events have the expected set of constant fields.\n+    assertThat(events.stream().map(event -> event.getAgentType()).collect(Collectors.toSet()))\n+        .containsExactly(AgentType.USER);\n+    assertThat(events.stream().map(event -> event.getActionType()).collect(Collectors.toSet()))\n+        .containsExactly(ActionType.HIGH_EGRESS);\n+    assertThat(events.stream().map(event -> event.getAgentId()).collect(Collectors.toSet()))\n+        .containsExactly(USER_ID);\n+    assertThat(events.stream().map(event -> event.getAgentEmailMaybe()).collect(Collectors.toSet()))\n+        .containsExactly(USER_EMAIL);\n+    assertThat(events.stream().map(event -> event.getTargetIdMaybe()).collect(Collectors.toSet()))\n+        .containsExactly(WORKSPACE_ID);\n+\n+    // We should have distinct event rows with values from the egress event.\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventTargetProperty.EGRESS_MIB.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .collect(Collectors.toSet()))\n+        .containsExactly(\"12.3\");\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventTargetProperty.VM_NAME.getPropertyName())", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MTM4MQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368091381", "bodyText": "Ah, I always forget about that. Done.", "author": "gjuggler", "createdAt": "2020-01-17T19:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MjYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1Mjg4Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367752882", "bodyText": "This is kind of scary. I'd instead do a  .filter(Objects::nonNull) and assert that the set is empty.", "author": "jaycarlton", "createdAt": "2020-01-17T03:20:06Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.ActionType;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty;\n+import org.pmiops.workbench.db.dao.UserDao;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class SumoLogicAuditorTest {\n+\n+  private static final long USER_ID = 1L;\n+  private static final String USER_EMAIL = \"user@researchallofus.org\";\n+  private static final long WORKSPACE_ID = 1L;\n+  private static final String WORKSPACE_NAMESPACE = \"aou-rw-test-c7dec260\";\n+  private static final String WORKSPACE_FIRECLOUD_NAME = \"mytestworkspacename\";\n+\n+  private static final String EGRESS_EVENT_PROJECT_NAME = WORKSPACE_NAMESPACE;\n+  private static final String EGRESS_EVENT_VM_NAME = \"all-of-us-\" + USER_ID + \"-m\";\n+\n+  // Pre-built data objects for test.\n+  private DbUser dbUser;\n+  private DbWorkspace dbWorkspace;\n+  private List<UserRole> firecloudUserRoles = new ArrayList<>();\n+\n+  @Autowired private SumoLogicAuditor sumoLogicAuditor;\n+\n+  @MockBean private ActionAuditService mockActionAuditService;\n+  @MockBean private WorkspaceService mockWorkspaceService;\n+  @MockBean private UserDao mockUserDao;\n+\n+  @Captor private ArgumentCaptor<Collection<ActionAuditEvent>> eventsCaptor;\n+\n+  @Rule public final ExpectedException exception = ExpectedException.none();\n+\n+  @Before\n+  public void setUp() {\n+    dbUser = new DbUser();\n+    dbUser.setUserId(USER_ID);\n+    dbUser.setUsername(USER_EMAIL);\n+    when(mockUserDao.findUserByUsername(USER_EMAIL)).thenReturn(dbUser);\n+\n+    dbWorkspace = new DbWorkspace();\n+    dbWorkspace.setWorkspaceId(WORKSPACE_ID);\n+    dbWorkspace.setWorkspaceNamespace(WORKSPACE_NAMESPACE);\n+    dbWorkspace.setFirecloudName(WORKSPACE_FIRECLOUD_NAME);\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(dbWorkspace);\n+    firecloudUserRoles.add(new UserRole().email(USER_EMAIL));\n+    when(mockWorkspaceService.getFirecloudUserRoles(WORKSPACE_NAMESPACE, WORKSPACE_FIRECLOUD_NAME))\n+        .thenReturn(firecloudUserRoles);\n+  }\n+\n+  Set<String> extractValuesFromEvents(\n+      Collection<ActionAuditEvent> events, Function<ActionAuditEvent, String> fn) {\n+    return events.stream().map(fn).collect(Collectors.toSet());\n+  }\n+\n+  @Test\n+  public void testFireEgressEvent() {\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent()\n+            .projectName(EGRESS_EVENT_PROJECT_NAME)\n+            .vmName(EGRESS_EVENT_VM_NAME)\n+            .timeWindowStart(0l)\n+            .egressMib(12.3));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Ensure all events have the expected set of constant fields.\n+    assertThat(events.stream().map(event -> event.getAgentType()).collect(Collectors.toSet()))\n+        .containsExactly(AgentType.USER);\n+    assertThat(events.stream().map(event -> event.getActionType()).collect(Collectors.toSet()))\n+        .containsExactly(ActionType.HIGH_EGRESS);\n+    assertThat(events.stream().map(event -> event.getAgentId()).collect(Collectors.toSet()))\n+        .containsExactly(USER_ID);\n+    assertThat(events.stream().map(event -> event.getAgentEmailMaybe()).collect(Collectors.toSet()))\n+        .containsExactly(USER_EMAIL);\n+    assertThat(events.stream().map(event -> event.getTargetIdMaybe()).collect(Collectors.toSet()))\n+        .containsExactly(WORKSPACE_ID);\n+\n+    // We should have distinct event rows with values from the egress event.\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventTargetProperty.EGRESS_MIB.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .collect(Collectors.toSet()))\n+        .containsExactly(\"12.3\");\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventTargetProperty.VM_NAME.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .collect(Collectors.toSet()))\n+        .containsExactly(EGRESS_EVENT_VM_NAME);\n+  }\n+\n+  @Test\n+  public void testNoWorkspaceFound() {\n+    exception.expect(BadRequestException.class);\n+\n+    // When the workspace lookup doesn't succeed, the event is filed w/ a system agent and an\n+    // empty target ID.\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(null);\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent().projectName(EGRESS_EVENT_PROJECT_NAME).vmName(EGRESS_EVENT_VM_NAME));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Some of the properties should be nulled out, since we can't identify the target workspace\n+    // for the egress event.\n+    assertThat(events.stream().map(event -> event.getAgentId()).collect(Collectors.toSet()))\n+        .containsExactly(0);\n+    assertThat(events.stream().map(event -> event.getAgentEmailMaybe()).collect(Collectors.toSet()))\n+        .containsExactly((Object[]) null);", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MjUyNA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368092524", "bodyText": "Good idea \u2013\u00a0done.", "author": "gjuggler", "createdAt": "2020-01-17T19:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1Mjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MzA3Mw==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367753073", "bodyText": "nit: If the array isn't valid JSON, I would've expected a lower-level exception to be thrown first.", "author": "jaycarlton", "createdAt": "2020-01-17T03:21:06Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.ActionType;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty;\n+import org.pmiops.workbench.db.dao.UserDao;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class SumoLogicAuditorTest {\n+\n+  private static final long USER_ID = 1L;\n+  private static final String USER_EMAIL = \"user@researchallofus.org\";\n+  private static final long WORKSPACE_ID = 1L;\n+  private static final String WORKSPACE_NAMESPACE = \"aou-rw-test-c7dec260\";\n+  private static final String WORKSPACE_FIRECLOUD_NAME = \"mytestworkspacename\";\n+\n+  private static final String EGRESS_EVENT_PROJECT_NAME = WORKSPACE_NAMESPACE;\n+  private static final String EGRESS_EVENT_VM_NAME = \"all-of-us-\" + USER_ID + \"-m\";\n+\n+  // Pre-built data objects for test.\n+  private DbUser dbUser;\n+  private DbWorkspace dbWorkspace;\n+  private List<UserRole> firecloudUserRoles = new ArrayList<>();\n+\n+  @Autowired private SumoLogicAuditor sumoLogicAuditor;\n+\n+  @MockBean private ActionAuditService mockActionAuditService;\n+  @MockBean private WorkspaceService mockWorkspaceService;\n+  @MockBean private UserDao mockUserDao;\n+\n+  @Captor private ArgumentCaptor<Collection<ActionAuditEvent>> eventsCaptor;\n+\n+  @Rule public final ExpectedException exception = ExpectedException.none();\n+\n+  @Before\n+  public void setUp() {\n+    dbUser = new DbUser();\n+    dbUser.setUserId(USER_ID);\n+    dbUser.setUsername(USER_EMAIL);\n+    when(mockUserDao.findUserByUsername(USER_EMAIL)).thenReturn(dbUser);\n+\n+    dbWorkspace = new DbWorkspace();\n+    dbWorkspace.setWorkspaceId(WORKSPACE_ID);\n+    dbWorkspace.setWorkspaceNamespace(WORKSPACE_NAMESPACE);\n+    dbWorkspace.setFirecloudName(WORKSPACE_FIRECLOUD_NAME);\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(dbWorkspace);\n+    firecloudUserRoles.add(new UserRole().email(USER_EMAIL));\n+    when(mockWorkspaceService.getFirecloudUserRoles(WORKSPACE_NAMESPACE, WORKSPACE_FIRECLOUD_NAME))\n+        .thenReturn(firecloudUserRoles);\n+  }\n+\n+  Set<String> extractValuesFromEvents(\n+      Collection<ActionAuditEvent> events, Function<ActionAuditEvent, String> fn) {\n+    return events.stream().map(fn).collect(Collectors.toSet());\n+  }\n+\n+  @Test\n+  public void testFireEgressEvent() {\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent()\n+            .projectName(EGRESS_EVENT_PROJECT_NAME)\n+            .vmName(EGRESS_EVENT_VM_NAME)\n+            .timeWindowStart(0l)\n+            .egressMib(12.3));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Ensure all events have the expected set of constant fields.\n+    assertThat(events.stream().map(event -> event.getAgentType()).collect(Collectors.toSet()))\n+        .containsExactly(AgentType.USER);\n+    assertThat(events.stream().map(event -> event.getActionType()).collect(Collectors.toSet()))\n+        .containsExactly(ActionType.HIGH_EGRESS);\n+    assertThat(events.stream().map(event -> event.getAgentId()).collect(Collectors.toSet()))\n+        .containsExactly(USER_ID);\n+    assertThat(events.stream().map(event -> event.getAgentEmailMaybe()).collect(Collectors.toSet()))\n+        .containsExactly(USER_EMAIL);\n+    assertThat(events.stream().map(event -> event.getTargetIdMaybe()).collect(Collectors.toSet()))\n+        .containsExactly(WORKSPACE_ID);\n+\n+    // We should have distinct event rows with values from the egress event.\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventTargetProperty.EGRESS_MIB.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .collect(Collectors.toSet()))\n+        .containsExactly(\"12.3\");\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventTargetProperty.VM_NAME.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .collect(Collectors.toSet()))\n+        .containsExactly(EGRESS_EVENT_VM_NAME);\n+  }\n+\n+  @Test\n+  public void testNoWorkspaceFound() {\n+    exception.expect(BadRequestException.class);\n+\n+    // When the workspace lookup doesn't succeed, the event is filed w/ a system agent and an\n+    // empty target ID.\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(null);\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent().projectName(EGRESS_EVENT_PROJECT_NAME).vmName(EGRESS_EVENT_VM_NAME));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Some of the properties should be nulled out, since we can't identify the target workspace\n+    // for the egress event.\n+    assertThat(events.stream().map(event -> event.getAgentId()).collect(Collectors.toSet()))\n+        .containsExactly(0);\n+    assertThat(events.stream().map(event -> event.getAgentEmailMaybe()).collect(Collectors.toSet()))\n+        .containsExactly((Object[]) null);\n+    assertThat(events.stream().map(event -> event.getTargetIdMaybe()).collect(Collectors.toSet()))\n+        .containsExactly((Object[]) null);\n+\n+    // We expect to see an audit event row with a comment describing the issue encountered when\n+    // trying to handle the high-egress message.\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventCommentTargetProperty.COMMENT.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .findFirst()\n+                .get())\n+        .contains(\"Failed to find workspace\");\n+  }\n+\n+  @Test\n+  public void testFailedParsing() {\n+    // When the inbound request parsing fails, an event is logged at the system agent.\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(null);\n+    sumoLogicAuditor.fireFailedToParseEgressEvent(new EgressEventRequest().eventsJsonArray(\"asdf\"));", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MjY5Mg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368092692", "bodyText": "\ud83e\udd37\u200d\u2642", "author": "gjuggler", "createdAt": "2020-01-17T19:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MzA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEzOTIwNg==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368139206", "bodyText": "Except that your controller is passing it in internally, so this makes sense.", "author": "jaycarlton", "createdAt": "2020-01-17T21:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MzA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MzE5MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367753190", "bodyText": "nit: Oh, I'm used to seeing these at the top.", "author": "jaycarlton", "createdAt": "2020-01-17T03:21:44Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/SumoLogicAuditorTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.ActionType;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventCommentTargetProperty;\n+import org.pmiops.workbench.actionaudit.targetproperties.EgressEventTargetProperty;\n+import org.pmiops.workbench.db.dao.UserDao;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.workspaces.WorkspaceService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class SumoLogicAuditorTest {\n+\n+  private static final long USER_ID = 1L;\n+  private static final String USER_EMAIL = \"user@researchallofus.org\";\n+  private static final long WORKSPACE_ID = 1L;\n+  private static final String WORKSPACE_NAMESPACE = \"aou-rw-test-c7dec260\";\n+  private static final String WORKSPACE_FIRECLOUD_NAME = \"mytestworkspacename\";\n+\n+  private static final String EGRESS_EVENT_PROJECT_NAME = WORKSPACE_NAMESPACE;\n+  private static final String EGRESS_EVENT_VM_NAME = \"all-of-us-\" + USER_ID + \"-m\";\n+\n+  // Pre-built data objects for test.\n+  private DbUser dbUser;\n+  private DbWorkspace dbWorkspace;\n+  private List<UserRole> firecloudUserRoles = new ArrayList<>();\n+\n+  @Autowired private SumoLogicAuditor sumoLogicAuditor;\n+\n+  @MockBean private ActionAuditService mockActionAuditService;\n+  @MockBean private WorkspaceService mockWorkspaceService;\n+  @MockBean private UserDao mockUserDao;\n+\n+  @Captor private ArgumentCaptor<Collection<ActionAuditEvent>> eventsCaptor;\n+\n+  @Rule public final ExpectedException exception = ExpectedException.none();\n+\n+  @Before\n+  public void setUp() {\n+    dbUser = new DbUser();\n+    dbUser.setUserId(USER_ID);\n+    dbUser.setUsername(USER_EMAIL);\n+    when(mockUserDao.findUserByUsername(USER_EMAIL)).thenReturn(dbUser);\n+\n+    dbWorkspace = new DbWorkspace();\n+    dbWorkspace.setWorkspaceId(WORKSPACE_ID);\n+    dbWorkspace.setWorkspaceNamespace(WORKSPACE_NAMESPACE);\n+    dbWorkspace.setFirecloudName(WORKSPACE_FIRECLOUD_NAME);\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(dbWorkspace);\n+    firecloudUserRoles.add(new UserRole().email(USER_EMAIL));\n+    when(mockWorkspaceService.getFirecloudUserRoles(WORKSPACE_NAMESPACE, WORKSPACE_FIRECLOUD_NAME))\n+        .thenReturn(firecloudUserRoles);\n+  }\n+\n+  Set<String> extractValuesFromEvents(\n+      Collection<ActionAuditEvent> events, Function<ActionAuditEvent, String> fn) {\n+    return events.stream().map(fn).collect(Collectors.toSet());\n+  }\n+\n+  @Test\n+  public void testFireEgressEvent() {\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent()\n+            .projectName(EGRESS_EVENT_PROJECT_NAME)\n+            .vmName(EGRESS_EVENT_VM_NAME)\n+            .timeWindowStart(0l)\n+            .egressMib(12.3));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Ensure all events have the expected set of constant fields.\n+    assertThat(events.stream().map(event -> event.getAgentType()).collect(Collectors.toSet()))\n+        .containsExactly(AgentType.USER);\n+    assertThat(events.stream().map(event -> event.getActionType()).collect(Collectors.toSet()))\n+        .containsExactly(ActionType.HIGH_EGRESS);\n+    assertThat(events.stream().map(event -> event.getAgentId()).collect(Collectors.toSet()))\n+        .containsExactly(USER_ID);\n+    assertThat(events.stream().map(event -> event.getAgentEmailMaybe()).collect(Collectors.toSet()))\n+        .containsExactly(USER_EMAIL);\n+    assertThat(events.stream().map(event -> event.getTargetIdMaybe()).collect(Collectors.toSet()))\n+        .containsExactly(WORKSPACE_ID);\n+\n+    // We should have distinct event rows with values from the egress event.\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventTargetProperty.EGRESS_MIB.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .collect(Collectors.toSet()))\n+        .containsExactly(\"12.3\");\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventTargetProperty.VM_NAME.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .collect(Collectors.toSet()))\n+        .containsExactly(EGRESS_EVENT_VM_NAME);\n+  }\n+\n+  @Test\n+  public void testNoWorkspaceFound() {\n+    exception.expect(BadRequestException.class);\n+\n+    // When the workspace lookup doesn't succeed, the event is filed w/ a system agent and an\n+    // empty target ID.\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(null);\n+    sumoLogicAuditor.fireEgressEvent(\n+        new EgressEvent().projectName(EGRESS_EVENT_PROJECT_NAME).vmName(EGRESS_EVENT_VM_NAME));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    // Some of the properties should be nulled out, since we can't identify the target workspace\n+    // for the egress event.\n+    assertThat(events.stream().map(event -> event.getAgentId()).collect(Collectors.toSet()))\n+        .containsExactly(0);\n+    assertThat(events.stream().map(event -> event.getAgentEmailMaybe()).collect(Collectors.toSet()))\n+        .containsExactly((Object[]) null);\n+    assertThat(events.stream().map(event -> event.getTargetIdMaybe()).collect(Collectors.toSet()))\n+        .containsExactly((Object[]) null);\n+\n+    // We expect to see an audit event row with a comment describing the issue encountered when\n+    // trying to handle the high-egress message.\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventCommentTargetProperty.COMMENT.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .findFirst()\n+                .get())\n+        .contains(\"Failed to find workspace\");\n+  }\n+\n+  @Test\n+  public void testFailedParsing() {\n+    // When the inbound request parsing fails, an event is logged at the system agent.\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(null);\n+    sumoLogicAuditor.fireFailedToParseEgressEvent(new EgressEventRequest().eventsJsonArray(\"asdf\"));\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventCommentTargetProperty.COMMENT.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .findFirst()\n+                .get())\n+        .contains(\"Failed to parse egress event\");\n+  }\n+\n+  @Test\n+  public void testBadApiKey() {\n+    // When the inbound request parsing fails, an event is logged at the system agent.\n+    when(mockWorkspaceService.getByNamespace(WORKSPACE_NAMESPACE)).thenReturn(null);\n+    sumoLogicAuditor.fireBadApiKeyEgressEvent(\"ASDF\", new EgressEventRequest());\n+    verify(mockActionAuditService).send(eventsCaptor.capture());\n+    Collection<ActionAuditEvent> events = eventsCaptor.getValue();\n+\n+    assertThat(\n+            events.stream()\n+                .filter(\n+                    event ->\n+                        event.getTargetPropertyMaybe()\n+                            == EgressEventCommentTargetProperty.COMMENT.getPropertyName())\n+                .map(event -> event.getNewValueMaybe())\n+                .findFirst()\n+                .get())\n+        .contains(\"Received bad API key\");\n+  }\n+\n+  @TestConfiguration", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5Mjc4OA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368092788", "bodyText": "Yeah I don't know why these ended up down here... moved back up.", "author": "gjuggler", "createdAt": "2020-01-17T19:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MzE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MzU1MA==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r367753550", "bodyText": "nit: I'd use a Duration object and then call toSecionds() or w/e.", "author": "jaycarlton", "createdAt": "2020-01-17T03:23:59Z", "path": "api/src/test/java/org/pmiops/workbench/api/SumoLogicControllerTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.pmiops.workbench.api;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.actionaudit.auditors.SumoLogicAuditor;\n+import org.pmiops.workbench.exceptions.BadRequestException;\n+import org.pmiops.workbench.exceptions.UnauthorizedException;\n+import org.pmiops.workbench.google.CloudStorageService;\n+import org.pmiops.workbench.model.EgressEvent;\n+import org.pmiops.workbench.model.EgressEventRequest;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class SumoLogicControllerTest {\n+\n+  private static final String API_KEY = \"12345\";\n+\n+  @MockBean private SumoLogicAuditor sumoLogicAuditor;\n+  @MockBean private CloudStorageService cloudStorageService;\n+\n+  @Autowired private SumoLogicController sumoLogicController;\n+\n+  @Rule public final ExpectedException exception = ExpectedException.none();\n+\n+  private EgressEventRequest request;\n+  private EgressEvent event;\n+\n+  private ObjectMapper mapper = new ObjectMapper();\n+\n+  @TestConfiguration\n+  @Import({SumoLogicController.class})\n+  static class Configuration {}\n+\n+  @Before\n+  public void setUp() throws JsonProcessingException {\n+    event = new EgressEvent();\n+    event.setProjectName(\"aou-rw-test-c7dec260\");\n+    event.setEgressMibThreshold(100.0);\n+    event.setEgressMib(123.0);\n+    event.setEnvironment(EgressEvent.EnvironmentEnum.TEST);\n+    event.setTimeWindowDuration(300L);", "originalCommit": "1d0f988ad163b5075cfdb90f4febaba13db7d7c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5MzYwOQ==", "url": "https://github.com/all-of-us/workbench/pull/2992#discussion_r368093609", "bodyText": "Heh... it reads as a bit repetitive, but it does add clarity. Done.", "author": "gjuggler", "createdAt": "2020-01-17T19:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MzU1MA=="}], "type": "inlineReview"}, {"oid": "aa3b5cb2ff93e9a226ba95ce9a51579a336010e6", "url": "https://github.com/all-of-us/workbench/commit/aa3b5cb2ff93e9a226ba95ce9a51579a336010e6", "message": "Respond to PR comments.", "committedDate": "2020-01-17T19:20:00Z", "type": "commit"}, {"oid": "9d8ea4b28a248e9c24ab5d0017284f73daa2ff48", "url": "https://github.com/all-of-us/workbench/commit/9d8ea4b28a248e9c24ab5d0017284f73daa2ff48", "message": "Add a few extra class comments.", "committedDate": "2020-01-17T19:35:06Z", "type": "commit"}, {"oid": "ec5c28b6a82a3658d27bb00e7e8d0c666e48ae9c", "url": "https://github.com/all-of-us/workbench/commit/ec5c28b6a82a3658d27bb00e7e8d0c666e48ae9c", "message": "Rename high-egress action type.", "committedDate": "2020-01-19T16:42:52Z", "type": "commit"}]}