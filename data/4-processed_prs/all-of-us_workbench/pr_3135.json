{"pr_number": 3135, "pr_title": "[RW-2704][risk=low] Split up listCluster API and move initialization logic to the client-side.", "pr_createdAt": "2020-02-14T22:18:05Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3135", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY4MDU5MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r379680591", "bodyText": "Ideal REST semantics would have getCluster and createCluster return a Cluster directly rather than wrapping", "author": "calbach", "createdAt": "2020-02-14T22:55:01Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -583,88 +598,77 @@ paths:\n           schema:\n             $ref: '#/definitions/ErrorResponse'\n \n-  /v1/clusters/{billingProjectId}/{workspaceFirecloudName}:\n+  /v1/clusters/{workspaceNamespace}:\n     get:\n-      summary: List available notebook clusters\n+      summary: Get the user's workspace cluster.\n       description: >\n-        Returns the clusters available to the current user in the given billing project.\n-        Currently there is a single default cluster supported per billing project\n-        and this cluster should always either exist or be in the process of being\n-        initialized. In a future where researchers have more control over cluster\n-        creation, this endpoint would be extended to return all clusters.\n-      operationId: listClusters\n+        Returns the current user's cluster, if any, which has been created for the given workspace.\n+      operationId: getCluster\n       tags:\n         - cluster\n       parameters:\n-        - in: path\n-          name: billingProjectId\n-          description: The unique identifier of the Google Billing Project containing the clusters\n-          required: true\n-          type: string\n-        - in: path\n-          name: workspaceFirecloudName\n-          description: The firecloudName of the workspace whose notebook we're looking at\n-          required: true\n-          type: string\n+        - $ref: '#/parameters/workspaceNamespace'\n       responses:\n         200:\n-          description: The users cluster\n+          description: The cluster for this user and workspace.\n           schema:\n-            $ref: '#/definitions/DefaultClusterResponse'\n-        500:\n-          description: Internal Error\n+            $ref: '#/definitions/GetClusterResponse'\n+        404:\n+          description: No cluster exists for this user and workspace.\n           schema:\n             $ref: '#/definitions/ErrorResponse'\n-\n-  /v1/clusters/{clusterNamespace}/{clusterName}:\n+    post:\n+      summary: Create a workspace cluster.\n+      description: >\n+        Creates a new cluster for the current user in the given billing project. If a cluster already\n+        exists for the user in this billing project, a 409 conflict error is returned (even if the cluster\n+        is still initializing or is not in a ready state).\n+      operationId: createCluster\n+      tags:\n+        - cluster\n+      parameters:\n+        # TODO(RW-3697): Custom cluster creation params should be added as a body param here.\n+        - $ref: '#/parameters/workspaceNamespace'\n+      responses:\n+        200:\n+          description: Returns the cluster that was created for this user and workspace.\n+          schema:\n+            $ref: '#/definitions/CreateClusterResponse'", "originalCommit": "8762f7ac58e6a471f6cc1ec6c65a7396414906ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY4MDg1NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r379680855", "bodyText": "nice", "author": "calbach", "createdAt": "2020-02-14T22:56:02Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,136 @@\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+\n+interface ClusterInitializerOptions {\n+  workspaceNamespace: string;\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  abortSignal?: AbortSignal;\n+}\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const INITIALIZE_TIMEOUT_MS = 1000 * 60 * 20;\n+// While polling the get endpoint,\n+const INITIAL_POLLING_DELAY_MS = 2000;\n+const MAX_POLLING_DELAY_MS = 15000;\n+const MAX_CREATE_COUNT = 1;\n+const MAX_DELETE_COUNT = 1;\n+\n+export class ClusterInitializer {\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;", "originalCommit": "8762f7ac58e6a471f6cc1ec6c65a7396414906ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY4MzMzNA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r379683334", "bodyText": "Per ticket discussion, I might move this above the loop so it only happens on initialization - errors encountered later could always throw and require user intervention. I think this limits the risk of concurrent pollers causing cluster churn - delete is the only really problematic/destructive action here. The rest should be relatively safe for concurrent requests.", "author": "calbach", "createdAt": "2020-02-14T23:06:08Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,136 @@\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+\n+interface ClusterInitializerOptions {\n+  workspaceNamespace: string;\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  abortSignal?: AbortSignal;\n+}\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const INITIALIZE_TIMEOUT_MS = 1000 * 60 * 20;\n+// While polling the get endpoint,\n+const INITIAL_POLLING_DELAY_MS = 2000;\n+const MAX_POLLING_DELAY_MS = 15000;\n+const MAX_CREATE_COUNT = 1;\n+const MAX_DELETE_COUNT = 1;\n+\n+export class ClusterInitializer {\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+  private currentDelayMs = INITIAL_POLLING_DELAY_MS;\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private isInitializing = false;\n+  private initializeStartTime?: number;\n+  private currentCluster?: Cluster;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    const getClusterResponse = await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    return getClusterResponse.cluster;\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= MAX_CREATE_COUNT) {\n+      throw new Error('Reached max cluster create count');\n+    }\n+    const createClusterResponse = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return createClusterResponse.cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= MAX_DELETE_COUNT) {\n+      throw new Error('Reached max cluster delete count');\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  async initialize(): Promise<Cluster> {\n+    console.log('Initializing cluster', this.workspaceNamespace);\n+    if (this.isInitializing) {\n+      return Promise.reject('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = new Date().getTime();\n+\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    while (!this.isClusterRunning()) {\n+      if (this.abortSignal.aborted) {\n+        console.log('abortSignal received!');\n+        return Promise.reject('Request was aborted.');\n+      }\n+      if (new Date().getTime() - this.initializeStartTime > INITIALIZE_TIMEOUT_MS) {\n+        console.log('Took longer than max init timeout');\n+        return Promise.reject('Initialization attempt took longer than the max time allowed.');\n+      }\n+\n+      // Fetch the cluster and update status.\n+      try {\n+        console.log('Getting cluster');\n+        this.currentCluster = await this.getCluster();\n+        console.log('Cluster status', this.currentCluster.status);\n+        this.onStatusUpdate(this.currentCluster.status);\n+      } catch (e) {\n+        console.log('getCluster error', e);\n+        if (isAbortError(e)) {\n+          return Promise.reject();\n+        }\n+        // If we received a NOT_FOUND error, we need to create a cluster for this workspace.\n+        this.currentCluster = await this.createCluster();\n+      }\n+\n+      // Resolve the promise if this cluster is all set.\n+      if (this.isClusterRunning()) {\n+        console.log('Cluster is running, resolving promise');\n+        return this.currentCluster;\n+      }\n+\n+      if (this.isClusterStopped()) {\n+        console.log('Cluster is stopped, resuming');\n+        await this.resumeCluster();\n+      }\n+\n+      // If cluster is in error state, delete it so it can be re-created at the next poll loop.\n+      if (this.isClusterErrored()) {\n+        // TODO: report errors to Stackdriver here.\n+        console.log('Cluster error -- deleting for retry');\n+        await this.deleteCluster();", "originalCommit": "8762f7ac58e6a471f6cc1ec6c65a7396414906ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0NzIwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383547205", "bodyText": "Sorry, I owed you a reply on this one. I thought hard about treating delete cluster specially somehow, but ultimately I concluded that it was simpler & more readable, and arguably not too much more dangerous, to have it treated the same as our other state transitions. My hope is that the other guard rails (max initialization time, max delete count, max 500s) will help mitigate any potential out of control loops.", "author": "gjuggler", "createdAt": "2020-02-24T22:16:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY4MzMzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwMzA5NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384803094", "bodyText": "Yes makes sense, I surmised as much from the changes - thanks.", "author": "calbach", "createdAt": "2020-02-26T22:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY4MzMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY4NDA3Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r379684077", "bodyText": "Probably a  pre-emptive comment, but this should actually check for NOT_FOUND", "author": "calbach", "createdAt": "2020-02-14T23:09:27Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,136 @@\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+\n+interface ClusterInitializerOptions {\n+  workspaceNamespace: string;\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  abortSignal?: AbortSignal;\n+}\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const INITIALIZE_TIMEOUT_MS = 1000 * 60 * 20;\n+// While polling the get endpoint,\n+const INITIAL_POLLING_DELAY_MS = 2000;\n+const MAX_POLLING_DELAY_MS = 15000;\n+const MAX_CREATE_COUNT = 1;\n+const MAX_DELETE_COUNT = 1;\n+\n+export class ClusterInitializer {\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+  private currentDelayMs = INITIAL_POLLING_DELAY_MS;\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private isInitializing = false;\n+  private initializeStartTime?: number;\n+  private currentCluster?: Cluster;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    const getClusterResponse = await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    return getClusterResponse.cluster;\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= MAX_CREATE_COUNT) {\n+      throw new Error('Reached max cluster create count');\n+    }\n+    const createClusterResponse = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return createClusterResponse.cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= MAX_DELETE_COUNT) {\n+      throw new Error('Reached max cluster delete count');\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  async initialize(): Promise<Cluster> {\n+    console.log('Initializing cluster', this.workspaceNamespace);\n+    if (this.isInitializing) {\n+      return Promise.reject('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = new Date().getTime();\n+\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    while (!this.isClusterRunning()) {\n+      if (this.abortSignal.aborted) {\n+        console.log('abortSignal received!');\n+        return Promise.reject('Request was aborted.');\n+      }\n+      if (new Date().getTime() - this.initializeStartTime > INITIALIZE_TIMEOUT_MS) {\n+        console.log('Took longer than max init timeout');\n+        return Promise.reject('Initialization attempt took longer than the max time allowed.');\n+      }\n+\n+      // Fetch the cluster and update status.\n+      try {\n+        console.log('Getting cluster');\n+        this.currentCluster = await this.getCluster();\n+        console.log('Cluster status', this.currentCluster.status);\n+        this.onStatusUpdate(this.currentCluster.status);\n+      } catch (e) {\n+        console.log('getCluster error', e);\n+        if (isAbortError(e)) {\n+          return Promise.reject();\n+        }\n+        // If we received a NOT_FOUND error, we need to create a cluster for this workspace.", "originalCommit": "8762f7ac58e6a471f6cc1ec6c65a7396414906ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY4NTQ4NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r379685485", "bodyText": "One thing which isn't covered here yet is error retries. Since this is a very long polling cycle (expected to commonly be ~7-10m), would be ideal if this were resilient to the occasional transient 500. Using this package on the outgoing calls would probably suffice: \n  \n    \n      workbench/ui/src/app/utils/retry.tsx\n    \n    \n         Line 8\n      in\n      d86dead\n    \n    \n    \n    \n\n        \n          \n           export async function fetchAbortableRetry<T>(fetchFn: () => Promise<T>, timeoutMillis: number, maxRetries: number): Promise<T> { \n        \n    \n  \n\n\n(e.g. only fail the polling loop if the request fails X times in a row)", "author": "calbach", "createdAt": "2020-02-14T23:15:34Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,136 @@\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+\n+interface ClusterInitializerOptions {\n+  workspaceNamespace: string;\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  abortSignal?: AbortSignal;\n+}\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const INITIALIZE_TIMEOUT_MS = 1000 * 60 * 20;\n+// While polling the get endpoint,\n+const INITIAL_POLLING_DELAY_MS = 2000;\n+const MAX_POLLING_DELAY_MS = 15000;\n+const MAX_CREATE_COUNT = 1;\n+const MAX_DELETE_COUNT = 1;\n+\n+export class ClusterInitializer {\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+  private currentDelayMs = INITIAL_POLLING_DELAY_MS;\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private isInitializing = false;\n+  private initializeStartTime?: number;\n+  private currentCluster?: Cluster;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    const getClusterResponse = await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    return getClusterResponse.cluster;\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= MAX_CREATE_COUNT) {\n+      throw new Error('Reached max cluster create count');\n+    }\n+    const createClusterResponse = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return createClusterResponse.cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= MAX_DELETE_COUNT) {\n+      throw new Error('Reached max cluster delete count');\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  async initialize(): Promise<Cluster> {\n+    console.log('Initializing cluster', this.workspaceNamespace);\n+    if (this.isInitializing) {\n+      return Promise.reject('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = new Date().getTime();\n+\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    while (!this.isClusterRunning()) {", "originalCommit": "8762f7ac58e6a471f6cc1ec6c65a7396414906ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "67ab8fb211b1b76440cff340343c7a107903a87b", "url": "https://github.com/all-of-us/workbench/commit/67ab8fb211b1b76440cff340343c7a107903a87b", "message": "Fix ng lint error", "committedDate": "2020-02-21T15:27:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzEyOA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382647128", "bodyText": "nit: can the body of this function be pushed into the WorkspaceService, and have it return Optional<Cluster>?", "author": "jaycarlton", "createdAt": "2020-02-21T15:33:37Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMTM1NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383321355", "bodyText": "IMO it wouldn't be worth it. This controller is <10 lines (including wrapping!) which is way shorter than before, and very much in the spirit of https://github.com/all-of-us/workbench/blob/master/api/doc/code-structure.md#controllers.\n(And, upon reading that section again, I would probably disagree that 'controllers should contain no actual logic'. IMO, having some calls to well-factored access enforcement and validity checking service methods is more reasonably the scope of a controller than of a service.)", "author": "gjuggler", "createdAt": "2020-02-24T15:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3NTUxMw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384575513", "bodyText": "I can go along with that. I just haven't see much of a clean example of how to draw the line. If we're not really MVC, then I don't know what the \"C\" means.", "author": "jaycarlton", "createdAt": "2020-02-26T15:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0NzE3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382647175", "bodyText": "Nice. This is a good example of my preferred exception pattern: the service returns optional and the controller cries (optionally).", "author": "jaycarlton", "createdAt": "2020-02-21T15:33:42Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1MjI0Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382652243", "bodyText": "note to self: rename generated files in this package too so you don't have to do this.", "author": "jaycarlton", "createdAt": "2020-02-21T15:42:15Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n     workspaceService.enforceWorkspaceAccessLevel(\n-        billingProjectId, workspaceFirecloudName, WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(billingProjectId, workspaceFirecloudName);\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    DbUser user = this.userProvider.get();\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1MjY4Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382652682", "bodyText": "This logic could also live in WorkspaceService I think.", "author": "jaycarlton", "createdAt": "2020-02-21T15:42:54Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n     workspaceService.enforceWorkspaceAccessLevel(\n-        billingProjectId, workspaceFirecloudName, WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(billingProjectId, workspaceFirecloudName);\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    DbUser user = this.userProvider.get();\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.getCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()));\n \n-    String clusterName = clusterNameForUser(user);\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n+  }\n \n-    org.pmiops.workbench.notebooks.model.Cluster fcCluster;\n-    try {\n-      fcCluster = this.leonardoNotebooksClient.getCluster(billingProjectId, clusterName);\n-    } catch (NotFoundException e) {\n-      fcCluster =\n-          this.leonardoNotebooksClient.createCluster(\n-              billingProjectId, clusterName, workspaceFirecloudName);\n-    }\n+  @Override\n+  public ResponseEntity<Cluster> createCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMTk4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383321981", "bodyText": "It could, but I don't think it would provide any meaningful benefit to readability or maintenance.", "author": "gjuggler", "createdAt": "2020-02-24T15:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1MjY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1Mjk1MA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382652950", "bodyText": "nit: drop the this..", "author": "jaycarlton", "createdAt": "2020-02-21T15:43:17Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n     workspaceService.enforceWorkspaceAccessLevel(\n-        billingProjectId, workspaceFirecloudName, WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(billingProjectId, workspaceFirecloudName);\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    DbUser user = this.userProvider.get();\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.getCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()));\n \n-    String clusterName = clusterNameForUser(user);\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n+  }\n \n-    org.pmiops.workbench.notebooks.model.Cluster fcCluster;\n-    try {\n-      fcCluster = this.leonardoNotebooksClient.getCluster(billingProjectId, clusterName);\n-    } catch (NotFoundException e) {\n-      fcCluster =\n-          this.leonardoNotebooksClient.createCluster(\n-              billingProjectId, clusterName, workspaceFirecloudName);\n-    }\n+  @Override\n+  public ResponseEntity<Cluster> createCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    int retries = Optional.ofNullable(user.getClusterCreateRetries()).orElse(0);\n-    if (org.pmiops.workbench.notebooks.model.ClusterStatus.ERROR.equals(fcCluster.getStatus())) {\n-      if (retries <= 2) {\n-        this.userService.setClusterRetryCount(retries + 1);\n-        log.warning(\"Cluster has errored with logs: \");\n-        if (fcCluster.getErrors() != null) {\n-          for (ClusterError e : fcCluster.getErrors()) {\n-            log.warning(e.getErrorMessage());\n-          }\n-        }\n-        log.warning(\"Retrying cluster creation.\");\n-\n-        this.leonardoNotebooksClient.deleteCluster(billingProjectId, clusterName);\n-      }\n-    } else if (org.pmiops.workbench.notebooks.model.ClusterStatus.RUNNING.equals(\n-            fcCluster.getStatus())\n-        && retries != 0) {\n-      this.userService.setClusterRetryCount(0);\n-    }\n-    DefaultClusterResponse resp = new DefaultClusterResponse();\n-    resp.setDefaultCluster(TO_ALL_OF_US_CLUSTER.apply(fcCluster));\n-    return ResponseEntity.ok(resp);\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.createCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()), firecloudWorkspaceName);\n+\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n   }\n \n   @Override\n-  public ResponseEntity<EmptyResponse> deleteCluster(String projectName, String clusterName) {\n-    this.userService.setClusterRetryCount(0);\n-    this.leonardoNotebooksClient.deleteCluster(projectName, clusterName);\n+  public ResponseEntity<EmptyResponse> deleteCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+\n+    this.leonardoNotebooksClient.deleteCluster(", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMjI2OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383322268", "bodyText": "Oops. It gets hard switching between Typescript and Java sometimes...", "author": "gjuggler", "createdAt": "2020-02-24T15:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1Mjk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1NjEzNQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382656135", "bodyText": "It would be nice to simply add the firecloud cluster name to the DbUser as a transient/derived property, since it depends only on the user's id.", "author": "jaycarlton", "createdAt": "2020-02-21T15:48:43Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n     workspaceService.enforceWorkspaceAccessLevel(\n-        billingProjectId, workspaceFirecloudName, WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(billingProjectId, workspaceFirecloudName);\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    DbUser user = this.userProvider.get();\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.getCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()));\n \n-    String clusterName = clusterNameForUser(user);\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n+  }\n \n-    org.pmiops.workbench.notebooks.model.Cluster fcCluster;\n-    try {\n-      fcCluster = this.leonardoNotebooksClient.getCluster(billingProjectId, clusterName);\n-    } catch (NotFoundException e) {\n-      fcCluster =\n-          this.leonardoNotebooksClient.createCluster(\n-              billingProjectId, clusterName, workspaceFirecloudName);\n-    }\n+  @Override\n+  public ResponseEntity<Cluster> createCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    int retries = Optional.ofNullable(user.getClusterCreateRetries()).orElse(0);\n-    if (org.pmiops.workbench.notebooks.model.ClusterStatus.ERROR.equals(fcCluster.getStatus())) {\n-      if (retries <= 2) {\n-        this.userService.setClusterRetryCount(retries + 1);\n-        log.warning(\"Cluster has errored with logs: \");\n-        if (fcCluster.getErrors() != null) {\n-          for (ClusterError e : fcCluster.getErrors()) {\n-            log.warning(e.getErrorMessage());\n-          }\n-        }\n-        log.warning(\"Retrying cluster creation.\");\n-\n-        this.leonardoNotebooksClient.deleteCluster(billingProjectId, clusterName);\n-      }\n-    } else if (org.pmiops.workbench.notebooks.model.ClusterStatus.RUNNING.equals(\n-            fcCluster.getStatus())\n-        && retries != 0) {\n-      this.userService.setClusterRetryCount(0);\n-    }\n-    DefaultClusterResponse resp = new DefaultClusterResponse();\n-    resp.setDefaultCluster(TO_ALL_OF_US_CLUSTER.apply(fcCluster));\n-    return ResponseEntity.ok(resp);\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.createCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()), firecloudWorkspaceName);", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NjkzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382666939", "bodyText": "I'd make this final so the complier assures it's initialized exactly once.", "author": "jaycarlton", "createdAt": "2020-02-21T16:07:03Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n     workspaceService.enforceWorkspaceAccessLevel(\n-        billingProjectId, workspaceFirecloudName, WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(billingProjectId, workspaceFirecloudName);\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    DbUser user = this.userProvider.get();\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.getCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()));\n \n-    String clusterName = clusterNameForUser(user);\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n+  }\n \n-    org.pmiops.workbench.notebooks.model.Cluster fcCluster;\n-    try {\n-      fcCluster = this.leonardoNotebooksClient.getCluster(billingProjectId, clusterName);\n-    } catch (NotFoundException e) {\n-      fcCluster =\n-          this.leonardoNotebooksClient.createCluster(\n-              billingProjectId, clusterName, workspaceFirecloudName);\n-    }\n+  @Override\n+  public ResponseEntity<Cluster> createCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    int retries = Optional.ofNullable(user.getClusterCreateRetries()).orElse(0);\n-    if (org.pmiops.workbench.notebooks.model.ClusterStatus.ERROR.equals(fcCluster.getStatus())) {\n-      if (retries <= 2) {\n-        this.userService.setClusterRetryCount(retries + 1);\n-        log.warning(\"Cluster has errored with logs: \");\n-        if (fcCluster.getErrors() != null) {\n-          for (ClusterError e : fcCluster.getErrors()) {\n-            log.warning(e.getErrorMessage());\n-          }\n-        }\n-        log.warning(\"Retrying cluster creation.\");\n-\n-        this.leonardoNotebooksClient.deleteCluster(billingProjectId, clusterName);\n-      }\n-    } else if (org.pmiops.workbench.notebooks.model.ClusterStatus.RUNNING.equals(\n-            fcCluster.getStatus())\n-        && retries != 0) {\n-      this.userService.setClusterRetryCount(0);\n-    }\n-    DefaultClusterResponse resp = new DefaultClusterResponse();\n-    resp.setDefaultCluster(TO_ALL_OF_US_CLUSTER.apply(fcCluster));\n-    return ResponseEntity.ok(resp);\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.createCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()), firecloudWorkspaceName);\n+\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n   }\n \n   @Override\n-  public ResponseEntity<EmptyResponse> deleteCluster(String projectName, String clusterName) {\n-    this.userService.setClusterRetryCount(0);\n-    this.leonardoNotebooksClient.deleteCluster(projectName, clusterName);\n+  public ResponseEntity<EmptyResponse> deleteCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+\n+    this.leonardoNotebooksClient.deleteCluster(\n+        workspaceNamespace, clusterNameForUser(userProvider.get()));\n     return ResponseEntity.ok(new EmptyResponse());\n   }\n \n   @Override\n   public ResponseEntity<ClusterLocalizeResponse> localize(\n-      String projectName, String clusterName, ClusterLocalizeRequest body) {\n+      String workspaceNamespace, ClusterLocalizeRequest body) {\n+    DbWorkspace dbWorkspace = lookupWorkspace(workspaceNamespace);\n     workspaceService.enforceWorkspaceAccessLevel(\n-        body.getWorkspaceNamespace(), body.getWorkspaceId(), WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(body.getWorkspaceNamespace(), body.getWorkspaceId());\n+        dbWorkspace.getWorkspaceNamespace(),\n+        dbWorkspace.getFirecloudName(),\n+        WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(\n+        dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName());\n \n-    FirecloudWorkspace fcWorkspace;\n+    FirecloudWorkspace firecloudWorkspace;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMzc3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383323775", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T15:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NjkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2ODEwMw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382668103", "bodyText": "I'd make a helper method or service method for this bucket path determination. (If FirecloudWorkspace weren't generated, I'd put it there.)", "author": "jaycarlton", "createdAt": "2020-02-21T16:09:09Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n     workspaceService.enforceWorkspaceAccessLevel(\n-        billingProjectId, workspaceFirecloudName, WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(billingProjectId, workspaceFirecloudName);\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    DbUser user = this.userProvider.get();\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.getCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()));\n \n-    String clusterName = clusterNameForUser(user);\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n+  }\n \n-    org.pmiops.workbench.notebooks.model.Cluster fcCluster;\n-    try {\n-      fcCluster = this.leonardoNotebooksClient.getCluster(billingProjectId, clusterName);\n-    } catch (NotFoundException e) {\n-      fcCluster =\n-          this.leonardoNotebooksClient.createCluster(\n-              billingProjectId, clusterName, workspaceFirecloudName);\n-    }\n+  @Override\n+  public ResponseEntity<Cluster> createCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    int retries = Optional.ofNullable(user.getClusterCreateRetries()).orElse(0);\n-    if (org.pmiops.workbench.notebooks.model.ClusterStatus.ERROR.equals(fcCluster.getStatus())) {\n-      if (retries <= 2) {\n-        this.userService.setClusterRetryCount(retries + 1);\n-        log.warning(\"Cluster has errored with logs: \");\n-        if (fcCluster.getErrors() != null) {\n-          for (ClusterError e : fcCluster.getErrors()) {\n-            log.warning(e.getErrorMessage());\n-          }\n-        }\n-        log.warning(\"Retrying cluster creation.\");\n-\n-        this.leonardoNotebooksClient.deleteCluster(billingProjectId, clusterName);\n-      }\n-    } else if (org.pmiops.workbench.notebooks.model.ClusterStatus.RUNNING.equals(\n-            fcCluster.getStatus())\n-        && retries != 0) {\n-      this.userService.setClusterRetryCount(0);\n-    }\n-    DefaultClusterResponse resp = new DefaultClusterResponse();\n-    resp.setDefaultCluster(TO_ALL_OF_US_CLUSTER.apply(fcCluster));\n-    return ResponseEntity.ok(resp);\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.createCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()), firecloudWorkspaceName);\n+\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n   }\n \n   @Override\n-  public ResponseEntity<EmptyResponse> deleteCluster(String projectName, String clusterName) {\n-    this.userService.setClusterRetryCount(0);\n-    this.leonardoNotebooksClient.deleteCluster(projectName, clusterName);\n+  public ResponseEntity<EmptyResponse> deleteCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+\n+    this.leonardoNotebooksClient.deleteCluster(\n+        workspaceNamespace, clusterNameForUser(userProvider.get()));\n     return ResponseEntity.ok(new EmptyResponse());\n   }\n \n   @Override\n   public ResponseEntity<ClusterLocalizeResponse> localize(\n-      String projectName, String clusterName, ClusterLocalizeRequest body) {\n+      String workspaceNamespace, ClusterLocalizeRequest body) {\n+    DbWorkspace dbWorkspace = lookupWorkspace(workspaceNamespace);\n     workspaceService.enforceWorkspaceAccessLevel(\n-        body.getWorkspaceNamespace(), body.getWorkspaceId(), WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(body.getWorkspaceNamespace(), body.getWorkspaceId());\n+        dbWorkspace.getWorkspaceNamespace(),\n+        dbWorkspace.getFirecloudName(),\n+        WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(\n+        dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName());\n \n-    FirecloudWorkspace fcWorkspace;\n+    FirecloudWorkspace firecloudWorkspace;\n     try {\n-      fcWorkspace =\n+      firecloudWorkspace =\n           fireCloudService\n-              .getWorkspace(body.getWorkspaceNamespace(), body.getWorkspaceId())\n+              .getWorkspace(dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName())\n               .getWorkspace();\n     } catch (NotFoundException e) {\n       throw new NotFoundException(\n           String.format(\n               \"workspace %s/%s not found or not accessible\",\n-              body.getWorkspaceNamespace(), body.getWorkspaceId()));\n+              dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName()));\n     }\n-    DbCdrVersion cdrVersion =\n-        workspaceService\n-            .getRequired(body.getWorkspaceNamespace(), body.getWorkspaceId())\n-            .getCdrVersion();\n+    DbCdrVersion cdrVersion = dbWorkspace.getCdrVersion();\n \n     // For the common case where the notebook cluster matches the workspace\n     // namespace, simply name the directory as the workspace ID; else we\n     // include the namespace in the directory name to avoid possible conflicts\n     // in workspace IDs.\n-    String gcsNotebooksDir = \"gs://\" + fcWorkspace.getBucketName() + \"/notebooks\";\n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n-    long workspaceId =\n-        workspaceService\n-            .getRequired(body.getWorkspaceNamespace(), body.getWorkspaceId())\n-            .getWorkspaceId();\n+    String gcsNotebooksDir = \"gs://\" + firecloudWorkspace.getBucketName() + \"/notebooks\";", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNDQyOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383324429", "bodyText": "Not sure it's worthwhile here.", "author": "gjuggler", "createdAt": "2020-02-24T15:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2ODEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2OTk4NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382669984", "bodyText": "on ln 263, I was confused that notebook was the variable but it was appended to a string. notebookName might be better.\nAlso, it would be nice to have  userRecentResourceService expose a batch method for this, so you don't have to loop here. It's a bit odd to see a service getting called in a loop.", "author": "jaycarlton", "createdAt": "2020-02-21T16:12:35Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n     workspaceService.enforceWorkspaceAccessLevel(\n-        billingProjectId, workspaceFirecloudName, WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(billingProjectId, workspaceFirecloudName);\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    DbUser user = this.userProvider.get();\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.getCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()));\n \n-    String clusterName = clusterNameForUser(user);\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n+  }\n \n-    org.pmiops.workbench.notebooks.model.Cluster fcCluster;\n-    try {\n-      fcCluster = this.leonardoNotebooksClient.getCluster(billingProjectId, clusterName);\n-    } catch (NotFoundException e) {\n-      fcCluster =\n-          this.leonardoNotebooksClient.createCluster(\n-              billingProjectId, clusterName, workspaceFirecloudName);\n-    }\n+  @Override\n+  public ResponseEntity<Cluster> createCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    int retries = Optional.ofNullable(user.getClusterCreateRetries()).orElse(0);\n-    if (org.pmiops.workbench.notebooks.model.ClusterStatus.ERROR.equals(fcCluster.getStatus())) {\n-      if (retries <= 2) {\n-        this.userService.setClusterRetryCount(retries + 1);\n-        log.warning(\"Cluster has errored with logs: \");\n-        if (fcCluster.getErrors() != null) {\n-          for (ClusterError e : fcCluster.getErrors()) {\n-            log.warning(e.getErrorMessage());\n-          }\n-        }\n-        log.warning(\"Retrying cluster creation.\");\n-\n-        this.leonardoNotebooksClient.deleteCluster(billingProjectId, clusterName);\n-      }\n-    } else if (org.pmiops.workbench.notebooks.model.ClusterStatus.RUNNING.equals(\n-            fcCluster.getStatus())\n-        && retries != 0) {\n-      this.userService.setClusterRetryCount(0);\n-    }\n-    DefaultClusterResponse resp = new DefaultClusterResponse();\n-    resp.setDefaultCluster(TO_ALL_OF_US_CLUSTER.apply(fcCluster));\n-    return ResponseEntity.ok(resp);\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.createCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()), firecloudWorkspaceName);\n+\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n   }\n \n   @Override\n-  public ResponseEntity<EmptyResponse> deleteCluster(String projectName, String clusterName) {\n-    this.userService.setClusterRetryCount(0);\n-    this.leonardoNotebooksClient.deleteCluster(projectName, clusterName);\n+  public ResponseEntity<EmptyResponse> deleteCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+\n+    this.leonardoNotebooksClient.deleteCluster(\n+        workspaceNamespace, clusterNameForUser(userProvider.get()));\n     return ResponseEntity.ok(new EmptyResponse());\n   }\n \n   @Override\n   public ResponseEntity<ClusterLocalizeResponse> localize(\n-      String projectName, String clusterName, ClusterLocalizeRequest body) {\n+      String workspaceNamespace, ClusterLocalizeRequest body) {\n+    DbWorkspace dbWorkspace = lookupWorkspace(workspaceNamespace);\n     workspaceService.enforceWorkspaceAccessLevel(\n-        body.getWorkspaceNamespace(), body.getWorkspaceId(), WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(body.getWorkspaceNamespace(), body.getWorkspaceId());\n+        dbWorkspace.getWorkspaceNamespace(),\n+        dbWorkspace.getFirecloudName(),\n+        WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(\n+        dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName());\n \n-    FirecloudWorkspace fcWorkspace;\n+    FirecloudWorkspace firecloudWorkspace;\n     try {\n-      fcWorkspace =\n+      firecloudWorkspace =\n           fireCloudService\n-              .getWorkspace(body.getWorkspaceNamespace(), body.getWorkspaceId())\n+              .getWorkspace(dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName())\n               .getWorkspace();\n     } catch (NotFoundException e) {\n       throw new NotFoundException(\n           String.format(\n               \"workspace %s/%s not found or not accessible\",\n-              body.getWorkspaceNamespace(), body.getWorkspaceId()));\n+              dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName()));\n     }\n-    DbCdrVersion cdrVersion =\n-        workspaceService\n-            .getRequired(body.getWorkspaceNamespace(), body.getWorkspaceId())\n-            .getCdrVersion();\n+    DbCdrVersion cdrVersion = dbWorkspace.getCdrVersion();\n \n     // For the common case where the notebook cluster matches the workspace\n     // namespace, simply name the directory as the workspace ID; else we\n     // include the namespace in the directory name to avoid possible conflicts\n     // in workspace IDs.\n-    String gcsNotebooksDir = \"gs://\" + fcWorkspace.getBucketName() + \"/notebooks\";\n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n-    long workspaceId =\n-        workspaceService\n-            .getRequired(body.getWorkspaceNamespace(), body.getWorkspaceId())\n-            .getWorkspaceId();\n+    String gcsNotebooksDir = \"gs://\" + firecloudWorkspace.getBucketName() + \"/notebooks\";\n+    long workspaceId = dbWorkspace.getWorkspaceId();\n \n     body.getNotebookNames()\n         .forEach(\n             notebook ->\n                 userRecentResourceService.updateNotebookEntry(\n                     workspaceId, userProvider.get().getUserId(), gcsNotebooksDir + \"/\" + notebook));\n-    String workspacePath = body.getWorkspaceId();\n-    if (!projectName.equals(body.getWorkspaceNamespace())) {\n-      workspacePath =\n-          body.getWorkspaceNamespace()\n-              + FireCloudService.WORKSPACE_DELIMITER\n-              + body.getWorkspaceId();\n-    }\n \n+    String workspacePath = dbWorkspace.getFirecloudName();", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNDk0NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383324945", "bodyText": "Updated lambda var name.", "author": "gjuggler", "createdAt": "2020-02-24T15:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2OTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3MTMyNg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382671326", "bodyText": "I don't really know what localize means in this context, but I can see this method does a large number of things that are all important (although transaction management between service calls is potentially sloppy). It would be helpful for readability and testability to have a high-level comment and also break down the body into helper methods and service methods. (Can certainly come later)", "author": "jaycarlton", "createdAt": "2020-02-21T16:15:09Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n     workspaceService.enforceWorkspaceAccessLevel(\n-        billingProjectId, workspaceFirecloudName, WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(billingProjectId, workspaceFirecloudName);\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    DbUser user = this.userProvider.get();\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.getCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()));\n \n-    String clusterName = clusterNameForUser(user);\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n+  }\n \n-    org.pmiops.workbench.notebooks.model.Cluster fcCluster;\n-    try {\n-      fcCluster = this.leonardoNotebooksClient.getCluster(billingProjectId, clusterName);\n-    } catch (NotFoundException e) {\n-      fcCluster =\n-          this.leonardoNotebooksClient.createCluster(\n-              billingProjectId, clusterName, workspaceFirecloudName);\n-    }\n+  @Override\n+  public ResponseEntity<Cluster> createCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    int retries = Optional.ofNullable(user.getClusterCreateRetries()).orElse(0);\n-    if (org.pmiops.workbench.notebooks.model.ClusterStatus.ERROR.equals(fcCluster.getStatus())) {\n-      if (retries <= 2) {\n-        this.userService.setClusterRetryCount(retries + 1);\n-        log.warning(\"Cluster has errored with logs: \");\n-        if (fcCluster.getErrors() != null) {\n-          for (ClusterError e : fcCluster.getErrors()) {\n-            log.warning(e.getErrorMessage());\n-          }\n-        }\n-        log.warning(\"Retrying cluster creation.\");\n-\n-        this.leonardoNotebooksClient.deleteCluster(billingProjectId, clusterName);\n-      }\n-    } else if (org.pmiops.workbench.notebooks.model.ClusterStatus.RUNNING.equals(\n-            fcCluster.getStatus())\n-        && retries != 0) {\n-      this.userService.setClusterRetryCount(0);\n-    }\n-    DefaultClusterResponse resp = new DefaultClusterResponse();\n-    resp.setDefaultCluster(TO_ALL_OF_US_CLUSTER.apply(fcCluster));\n-    return ResponseEntity.ok(resp);\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.createCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()), firecloudWorkspaceName);\n+\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n   }\n \n   @Override\n-  public ResponseEntity<EmptyResponse> deleteCluster(String projectName, String clusterName) {\n-    this.userService.setClusterRetryCount(0);\n-    this.leonardoNotebooksClient.deleteCluster(projectName, clusterName);\n+  public ResponseEntity<EmptyResponse> deleteCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+\n+    this.leonardoNotebooksClient.deleteCluster(\n+        workspaceNamespace, clusterNameForUser(userProvider.get()));\n     return ResponseEntity.ok(new EmptyResponse());\n   }\n \n   @Override\n   public ResponseEntity<ClusterLocalizeResponse> localize(\n-      String projectName, String clusterName, ClusterLocalizeRequest body) {\n+      String workspaceNamespace, ClusterLocalizeRequest body) {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMzYxNQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383323615", "bodyText": "Reasonable critique, but I only really dug into this controller method to clean up the API surface, so I'll punt on this to avoid scope creep.", "author": "gjuggler", "createdAt": "2020-02-24T15:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3MTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NDM2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382674362", "bodyText": "Above @ line 284, I think we can have a better name than localizeMap, e.g. bucketPathToNotebookPath if I'm reading things right.", "author": "jaycarlton", "createdAt": "2020-02-21T16:20:35Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -306,7 +285,7 @@\n \n     // The Welder extension offers direct links to/from playground mode; write the AoU config file\n     // to both locations so notebooks will work in either directory.\n-    String aouConfigUri = aouConfigDataUri(fcWorkspace, cdrVersion, projectName);\n+    String aouConfigUri = aouConfigDataUri(firecloudWorkspace, cdrVersion, workspaceNamespace);", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NTY1OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382675659", "bodyText": "Can we rename targetDir to notebookLocalDir? Also, collecting lines 269-272 into a helper method would be nice.", "author": "jaycarlton", "createdAt": "2020-02-21T16:22:49Z", "path": "api/src/main/java/org/pmiops/workbench/api/ClusterController.java", "diffHunk": "@@ -186,115 +183,97 @@\n     return ResponseEntity.ok(clustersInProjectAffected);\n   }\n \n+  private DbWorkspace lookupWorkspace(String workspaceNamespace) throws NotFoundException {\n+    return workspaceService\n+        .getByNamespace(workspaceNamespace)\n+        .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+  }\n+\n   @Override\n-  public ResponseEntity<DefaultClusterResponse> listClusters(\n-      String billingProjectId, String workspaceFirecloudName) {\n-    if (billingProjectId == null) {\n-      throw new BadRequestException(\"Must specify billing project\");\n-    }\n+  public ResponseEntity<Cluster> getCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n     workspaceService.enforceWorkspaceAccessLevel(\n-        billingProjectId, workspaceFirecloudName, WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(billingProjectId, workspaceFirecloudName);\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    DbUser user = this.userProvider.get();\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.getCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()));\n \n-    String clusterName = clusterNameForUser(user);\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n+  }\n \n-    org.pmiops.workbench.notebooks.model.Cluster fcCluster;\n-    try {\n-      fcCluster = this.leonardoNotebooksClient.getCluster(billingProjectId, clusterName);\n-    } catch (NotFoundException e) {\n-      fcCluster =\n-          this.leonardoNotebooksClient.createCluster(\n-              billingProjectId, clusterName, workspaceFirecloudName);\n-    }\n+  @Override\n+  public ResponseEntity<Cluster> createCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(workspaceNamespace, firecloudWorkspaceName);\n \n-    int retries = Optional.ofNullable(user.getClusterCreateRetries()).orElse(0);\n-    if (org.pmiops.workbench.notebooks.model.ClusterStatus.ERROR.equals(fcCluster.getStatus())) {\n-      if (retries <= 2) {\n-        this.userService.setClusterRetryCount(retries + 1);\n-        log.warning(\"Cluster has errored with logs: \");\n-        if (fcCluster.getErrors() != null) {\n-          for (ClusterError e : fcCluster.getErrors()) {\n-            log.warning(e.getErrorMessage());\n-          }\n-        }\n-        log.warning(\"Retrying cluster creation.\");\n-\n-        this.leonardoNotebooksClient.deleteCluster(billingProjectId, clusterName);\n-      }\n-    } else if (org.pmiops.workbench.notebooks.model.ClusterStatus.RUNNING.equals(\n-            fcCluster.getStatus())\n-        && retries != 0) {\n-      this.userService.setClusterRetryCount(0);\n-    }\n-    DefaultClusterResponse resp = new DefaultClusterResponse();\n-    resp.setDefaultCluster(TO_ALL_OF_US_CLUSTER.apply(fcCluster));\n-    return ResponseEntity.ok(resp);\n+    org.pmiops.workbench.notebooks.model.Cluster firecloudCluster =\n+        leonardoNotebooksClient.createCluster(\n+            workspaceNamespace, clusterNameForUser(userProvider.get()), firecloudWorkspaceName);\n+\n+    return ResponseEntity.ok(TO_ALL_OF_US_CLUSTER.apply(firecloudCluster));\n   }\n \n   @Override\n-  public ResponseEntity<EmptyResponse> deleteCluster(String projectName, String clusterName) {\n-    this.userService.setClusterRetryCount(0);\n-    this.leonardoNotebooksClient.deleteCluster(projectName, clusterName);\n+  public ResponseEntity<EmptyResponse> deleteCluster(String workspaceNamespace) {\n+    String firecloudWorkspaceName = lookupWorkspace(workspaceNamespace).getFirecloudName();\n+    workspaceService.enforceWorkspaceAccessLevel(\n+        workspaceNamespace, firecloudWorkspaceName, WorkspaceAccessLevel.WRITER);\n+\n+    this.leonardoNotebooksClient.deleteCluster(\n+        workspaceNamespace, clusterNameForUser(userProvider.get()));\n     return ResponseEntity.ok(new EmptyResponse());\n   }\n \n   @Override\n   public ResponseEntity<ClusterLocalizeResponse> localize(\n-      String projectName, String clusterName, ClusterLocalizeRequest body) {\n+      String workspaceNamespace, ClusterLocalizeRequest body) {\n+    DbWorkspace dbWorkspace = lookupWorkspace(workspaceNamespace);\n     workspaceService.enforceWorkspaceAccessLevel(\n-        body.getWorkspaceNamespace(), body.getWorkspaceId(), WorkspaceAccessLevel.READER);\n-    workspaceService.validateActiveBilling(body.getWorkspaceNamespace(), body.getWorkspaceId());\n+        dbWorkspace.getWorkspaceNamespace(),\n+        dbWorkspace.getFirecloudName(),\n+        WorkspaceAccessLevel.WRITER);\n+    workspaceService.validateActiveBilling(\n+        dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName());\n \n-    FirecloudWorkspace fcWorkspace;\n+    FirecloudWorkspace firecloudWorkspace;\n     try {\n-      fcWorkspace =\n+      firecloudWorkspace =\n           fireCloudService\n-              .getWorkspace(body.getWorkspaceNamespace(), body.getWorkspaceId())\n+              .getWorkspace(dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName())\n               .getWorkspace();\n     } catch (NotFoundException e) {\n       throw new NotFoundException(\n           String.format(\n               \"workspace %s/%s not found or not accessible\",\n-              body.getWorkspaceNamespace(), body.getWorkspaceId()));\n+              dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName()));\n     }\n-    DbCdrVersion cdrVersion =\n-        workspaceService\n-            .getRequired(body.getWorkspaceNamespace(), body.getWorkspaceId())\n-            .getCdrVersion();\n+    DbCdrVersion cdrVersion = dbWorkspace.getCdrVersion();\n \n     // For the common case where the notebook cluster matches the workspace\n     // namespace, simply name the directory as the workspace ID; else we\n     // include the namespace in the directory name to avoid possible conflicts\n     // in workspace IDs.\n-    String gcsNotebooksDir = \"gs://\" + fcWorkspace.getBucketName() + \"/notebooks\";\n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n-    long workspaceId =\n-        workspaceService\n-            .getRequired(body.getWorkspaceNamespace(), body.getWorkspaceId())\n-            .getWorkspaceId();\n+    String gcsNotebooksDir = \"gs://\" + firecloudWorkspace.getBucketName() + \"/notebooks\";\n+    long workspaceId = dbWorkspace.getWorkspaceId();\n \n     body.getNotebookNames()\n         .forEach(\n             notebook ->\n                 userRecentResourceService.updateNotebookEntry(\n                     workspaceId, userProvider.get().getUserId(), gcsNotebooksDir + \"/\" + notebook));\n-    String workspacePath = body.getWorkspaceId();\n-    if (!projectName.equals(body.getWorkspaceNamespace())) {\n-      workspacePath =\n-          body.getWorkspaceNamespace()\n-              + FireCloudService.WORKSPACE_DELIMITER\n-              + body.getWorkspaceId();\n-    }\n \n+    String workspacePath = dbWorkspace.getFirecloudName();\n     String editDir = \"workspaces/\" + workspacePath;\n     String playgroundDir = \"workspaces_playground/\" + workspacePath;\n     String targetDir = body.getPlaygroundMode() ? playgroundDir : editDir;\n \n     leonardoNotebooksClient.createStorageLink(\n-        projectName,\n-        clusterName,\n+        workspaceNamespace,", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNTYxOA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383325618", "bodyText": "I'll defer to future work. No functional changes were made to localize, so I'd like to avoid doing too much bike-shedding here.", "author": "gjuggler", "createdAt": "2020-02-24T15:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NzM0Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382677346", "bodyText": "nit: maybe rename lambda variable to unusedContext. You can drop the parenthesis for single-arg lambdas FWIW.", "author": "jaycarlton", "createdAt": "2020-02-21T16:25:41Z", "path": "api/src/main/java/org/pmiops/workbench/notebooks/LeonardoNotebooksClientImpl.java", "diffHunk": "@@ -169,7 +171,12 @@ public void deleteCluster(String googleProject, String clusterName) {\n   @Override\n   public Cluster getCluster(String googleProject, String clusterName) {\n     ClusterApi clusterApi = clusterApiProvider.get();\n-    return retryHandler.run((context) -> clusterApi.getCluster(googleProject, clusterName));\n+    try {\n+      return retryHandler.runAndThrowChecked(\n+          (context) -> clusterApi.getCluster(googleProject, clusterName));", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjE4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383326189", "bodyText": "I'll prefer consistency with the rest of this file, leaving as-is.", "author": "gjuggler", "createdAt": "2020-02-24T15:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3NzM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3OTA5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382679097", "bodyText": "What do you think about either naming this getWorkspaceOrThrow() and/or adding a throws NotFoundException to the signature. @ericsong and I came to the compromise that doing this on service methods is a net win, even though you ordinarily don't declare runtime exceptions.", "author": "jaycarlton", "createdAt": "2020-02-21T16:28:45Z", "path": "api/src/main/java/org/pmiops/workbench/workspaces/WorkspaceService.java", "diffHunk": "@@ -33,6 +33,8 @@\n \n   List<WorkspaceResponse> getWorkspacesAndPublicWorkspaces();\n \n+  WorkspaceResponse getWorkspace(String workspaceNamespace);", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNzY5NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383327695", "bodyText": "Seems like a reasonable compromise. To canonize this convention, please make a PR to add this to code-structure.md and start linking to that section in code reviews.", "author": "gjuggler", "createdAt": "2020-02-24T15:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3OTA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MTA4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382681081", "bodyText": "at line 241 below, I'm surprised to see us throwing a WorkbenchException exception from the service level; in principle code that's not running in a REST stack at all should be able to call this method.", "author": "jaycarlton", "createdAt": "2020-02-21T16:32:17Z", "path": "api/src/main/java/org/pmiops/workbench/workspaces/WorkspaceServiceImpl.java", "diffHunk": "@@ -204,18 +204,32 @@ public DbWorkspace get(String ns, String firecloudName) {\n         .collect(Collectors.toList());\n   }\n \n+  @Transactional\n+  @Override\n+  public WorkspaceResponse getWorkspace(String workspaceNamespace) {\n+    DbWorkspace dbWorkspace =\n+        getByNamespace(workspaceNamespace)\n+            .orElseThrow(() -> new NotFoundException(\"Workspace not found: \" + workspaceNamespace));\n+    return getWorkspaceImpl(dbWorkspace);\n+  }\n+\n   @Transactional\n   @Override\n   public WorkspaceResponse getWorkspace(String workspaceNamespace, String workspaceId) {\n     DbWorkspace dbWorkspace = getRequired(workspaceNamespace, workspaceId);\n+    return getWorkspaceImpl(dbWorkspace);\n+  }\n \n+  private WorkspaceResponse getWorkspaceImpl(DbWorkspace dbWorkspace) {\n     FirecloudWorkspaceResponse fcResponse;\n     FirecloudWorkspace fcWorkspace;\n \n     WorkspaceResponse workspaceResponse = new WorkspaceResponse();\n \n     // This enforces access controls.\n-    fcResponse = fireCloudService.getWorkspace(workspaceNamespace, workspaceId);\n+    fcResponse =\n+        fireCloudService.getWorkspace(\n+            dbWorkspace.getWorkspaceNamespace(), dbWorkspace.getFirecloudName());", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMDA1OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383330059", "bodyText": "Is there anything in WorkbenchException that requires REST? My conceptual model is that WorkbenchExcxeption contains typed exceptions that can be thrown at the service level, and then we use @ResponseStatus annotations to allow our controller / web layer to appropriately map these exceptions to response codes.", "author": "gjuggler", "createdAt": "2020-02-24T15:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MTA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3ODI5MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384578291", "bodyText": "I was thinking @ericsong was leading the charge to get these out of the service level. Maybe I misunderstood.", "author": "jaycarlton", "createdAt": "2020-02-26T15:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MTA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MTg3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382681872", "bodyText": "It would help to indicate if this the firecloud workspace namespace or an AOU one.", "author": "jaycarlton", "createdAt": "2020-02-21T16:33:45Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -71,6 +71,21 @@ parameters:\n     format: int64\n     required: true\n     description: Data set ID\n+  workspaceNamespace:\n+    in: path\n+    name: workspaceNamespace\n+    type: string\n+    required: true\n+    description: The workspace namespace, aka Google Cloud project ID.", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMDM4Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383330383", "bodyText": "They are one and the same.", "author": "gjuggler", "createdAt": "2020-02-24T15:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MTg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MjM3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382682375", "bodyText": "looks like Is there an actual contract here, or are we in danger of making an assumption about how these are generated that could change on us?", "author": "jaycarlton", "createdAt": "2020-02-21T16:34:45Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -71,6 +71,21 @@ parameters:\n     format: int64\n     required: true\n     description: Data set ID\n+  workspaceNamespace:\n+    in: path\n+    name: workspaceNamespace\n+    type: string\n+    required: true\n+    description: The workspace namespace, aka Google Cloud project ID.\n+  workspaceId:\n+    in: path\n+    name: workspaceId\n+    type: string\n+    required: true\n+    description: >\n+      The workspace ID, aka the Firecloud workspace ID. This is actually an immutable string,\n+      which in AoU looks like a lower-cased concatenation of the workspace name when it was first", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMTE5NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383331194", "bodyText": "I'm providing helpful context to the reader / maintainer of this code. Not implying any contract.", "author": "gjuggler", "createdAt": "2020-02-24T15:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MjM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MzAzOA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382683038", "bodyText": "This may be way too late, but I'm wondering if \"cluster\" is a concept that should be leaked outside the server. I guess we have enough specialized UI around them that it's fine.", "author": "jaycarlton", "createdAt": "2020-02-21T16:35:52Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -583,88 +598,77 @@ paths:\n           schema:\n             $ref: '#/definitions/ErrorResponse'\n \n-  /v1/clusters/{billingProjectId}/{workspaceFirecloudName}:\n+  /v1/clusters/{workspaceNamespace}:", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMTM5MA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383331390", "bodyText": "This is effectively an internal-only API. Users never encounter the word cluster.", "author": "gjuggler", "createdAt": "2020-02-24T15:26:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MzAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NDQ5MA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382684490", "bodyText": "I guess I'm still confused on when this should be called in the lifecycle of the cluster. Is it during startup (i.e. is this the thing that gives users their files back?)  Maybe also replace \"localizes\" with \"copies\", unless there's some other translation happening.", "author": "jaycarlton", "createdAt": "2020-02-21T16:38:37Z", "path": "api/src/main/resources/workbench.yaml", "diffHunk": "@@ -583,88 +598,77 @@ paths:\n           schema:\n             $ref: '#/definitions/ErrorResponse'\n \n-  /v1/clusters/{billingProjectId}/{workspaceFirecloudName}:\n+  /v1/clusters/{workspaceNamespace}:\n     get:\n-      summary: List available notebook clusters\n+      summary: Get the user's workspace cluster.\n       description: >\n-        Returns the clusters available to the current user in the given billing project.\n-        Currently there is a single default cluster supported per billing project\n-        and this cluster should always either exist or be in the process of being\n-        initialized. In a future where researchers have more control over cluster\n-        creation, this endpoint would be extended to return all clusters.\n-      operationId: listClusters\n+        Returns the current user's cluster, if any, which has been created for the given workspace.\n+      operationId: getCluster\n       tags:\n         - cluster\n       parameters:\n-        - in: path\n-          name: billingProjectId\n-          description: The unique identifier of the Google Billing Project containing the clusters\n-          required: true\n-          type: string\n-        - in: path\n-          name: workspaceFirecloudName\n-          description: The firecloudName of the workspace whose notebook we're looking at\n-          required: true\n-          type: string\n+        - $ref: '#/parameters/workspaceNamespace'\n       responses:\n         200:\n-          description: The users cluster\n+          description: The cluster for this user and workspace.\n           schema:\n-            $ref: '#/definitions/DefaultClusterResponse'\n-        500:\n-          description: Internal Error\n+            $ref: '#/definitions/Cluster'\n+        404:\n+          description: No cluster exists for this user and workspace.\n           schema:\n             $ref: '#/definitions/ErrorResponse'\n-\n-  /v1/clusters/{clusterNamespace}/{clusterName}:\n+    post:\n+      summary: Create a workspace cluster.\n+      description: >\n+        Creates a new cluster for the current user in the given billing project. If a cluster already\n+        exists for the user in this billing project, a 409 conflict error is returned (even if the cluster\n+        is still initializing or is not in a ready state).\n+      operationId: createCluster\n+      tags:\n+        - cluster\n+      parameters:\n+        # TODO(RW-3697): Custom cluster creation params should be added as a body param here.\n+        - $ref: '#/parameters/workspaceNamespace'\n+      responses:\n+        200:\n+          description: Returns the cluster that was created for this user and workspace.\n+          schema:\n+            $ref: '#/definitions/Cluster'\n+        409:\n+          description: A cluster for this user and workspace already exists.\n+          schema:\n+            $ref: \"#/definitions/EmptyResponse\"\n+    # TODO(RW-3695): updateCluster should be added as a PATCH endpoint here.\n     delete:\n-      summary: Delete a cluster by name.\n+      summary: Delete a workspace cluster.\n       operationId: deleteCluster\n       tags:\n         - cluster\n       parameters:\n-        - in: path\n-          name: clusterNamespace\n-          description: clusterNamespace\n-          required: true\n-          type: string\n-        - in: path\n-          name: clusterName\n-          description: clusterName\n-          required: true\n-          type: string\n+        - $ref: '#/parameters/workspaceNamespace'\n       responses:\n         200:\n-          description: Deletion success\n+          description: Success\n           schema:\n             $ref: '#/definitions/EmptyResponse'\n-        500:\n-          description: Internal Error\n+        404:\n+          description: No cluster exists for this user and workspace.\n           schema:\n-            $ref: '#/definitions/ErrorResponse'\n+            $ref: \"#/definitions/ErrorResponse\"\n \n-  /v1/clusters/{clusterNamespace}/{clusterName}/localize:\n+  /v1/clusters/{workspaceNamespace}/localize:\n     post:\n-      summary: >\n-        Localize files from a workspace to notebook cluster. As a side-effect,\n+      summary: Localize files to the user's cluster.\n+      description: >\n+        Localizes files to the cluster for the current user and given workspace. As a side-effect,", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMTc2OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383331768", "bodyText": "This is where notebook files get copied to the VM so Jupyter can read them.", "author": "gjuggler", "createdAt": "2020-02-24T15:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NDQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MDI4Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384580283", "bodyText": "OK. Long term,  maybe there's a way for Leo to just grab these via a webhook or config value or something.", "author": "jaycarlton", "createdAt": "2020-02-26T15:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NDQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NTk0MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382685941", "bodyText": "This comment would be very useful in the code as well.", "author": "jaycarlton", "createdAt": "2020-02-21T16:41:19Z", "path": "api/src/test/java/org/pmiops/workbench/api/ClusterControllerTest.java", "diffHunk": "@@ -83,12 +84,17 @@\n @Transactional(propagation = Propagation.NOT_SUPPORTED)\n public class ClusterControllerTest {\n \n-  private static final String BILLING_PROJECT_ID = \"proj\";\n-  private static final String BILLING_PROJECT_ID_2 = \"proj2\";\n+  private static final String BILLING_PROJECT_ID = \"aou-rw-1234\";\n+  private static final String BILLING_PROJECT_ID_2 = \"aou-rw-5678\";\n   // a workspace's namespace is always its billing project ID\n   private static final String WORKSPACE_NS = BILLING_PROJECT_ID;\n-  private static final String WORKSPACE_ID = \"wsid\";\n-  private static final String WORKSPACE_NAME = \"wsn\";\n+  // Workspace ID is also known as firecloud_name. This identifier is generated by", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMjc1Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383332752", "bodyText": "I added it to the workbench.yaml parameters definition description, which feels like the most centralized place where this lives. Maybe it could go on the DB model class as well, but we tend to not have as much comment type stuff over there.", "author": "gjuggler", "createdAt": "2020-02-24T15:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NjM2MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382686361", "bodyText": "nit: I like to name mocked members with a mock prefix, especially for large test classes.", "author": "jaycarlton", "createdAt": "2020-02-21T16:42:02Z", "path": "api/src/test/java/org/pmiops/workbench/api/ClusterControllerTest.java", "diffHunk": "@@ -148,14 +144,19 @@ Random random() {\n \n   @Captor private ArgumentCaptor<Map<String, String>> mapCaptor;\n \n-  @Autowired ClusterAuditor clusterAuditor;\n-  @Autowired LeonardoNotebooksClient notebookService;\n-  @Autowired FireCloudService fireCloudService;\n+  @MockBean AdminActionHistoryDao adminActionHistoryDao;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMzA2Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383333066", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T15:29:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NjM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NjgwNA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382686804", "bodyText": "Is this name intentional? Looks like there's a separate org.pmiops.workbench.notebooks.NotebooksService.", "author": "jaycarlton", "createdAt": "2020-02-21T16:42:49Z", "path": "api/src/test/java/org/pmiops/workbench/api/ClusterControllerTest.java", "diffHunk": "@@ -148,14 +144,19 @@ Random random() {\n \n   @Captor private ArgumentCaptor<Map<String, String>> mapCaptor;\n \n-  @Autowired ClusterAuditor clusterAuditor;\n-  @Autowired LeonardoNotebooksClient notebookService;\n-  @Autowired FireCloudService fireCloudService;\n+  @MockBean AdminActionHistoryDao adminActionHistoryDao;\n+  @MockBean ClusterAuditor clusterAuditor;\n+  @MockBean ComplianceService complianceService;\n+  @MockBean DirectoryService directoryService;\n+  @MockBean FireCloudService fireCloudService;\n+  @MockBean LeonardoNotebooksClient notebookService;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzMzg5Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383333896", "bodyText": "Changed.", "author": "gjuggler", "createdAt": "2020-02-24T15:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NjgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY5MDk2OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382690968", "bodyText": "Do we still need the first doThrow if we're going to verify that the method that does the throwing isn't called? Here and below.", "author": "jaycarlton", "createdAt": "2020-02-21T16:50:22Z", "path": "api/src/test/java/org/pmiops/workbench/api/ClusterControllerTest.java", "diffHunk": "@@ -505,96 +490,89 @@ public void testLocalize() {\n   public void testLocalize_playgroundMode() {\n     ClusterLocalizeRequest req =\n         new ClusterLocalizeRequest()\n-            .workspaceNamespace(WORKSPACE_NS)\n-            .workspaceId(WORKSPACE_ID)\n             .notebookNames(ImmutableList.of(\"foo.ipynb\"))\n             .playgroundMode(true);\n     stubGetWorkspace(WORKSPACE_NS, WORKSPACE_ID, LOGGED_IN_USER_EMAIL);\n-    ClusterLocalizeResponse resp =\n-        clusterController.localize(BILLING_PROJECT_ID, \"cluster\", req).getBody();\n-    assertThat(resp.getClusterLocalDirectory()).isEqualTo(\"workspaces_playground/wsid\");\n-    verify(notebookService).localize(eq(BILLING_PROJECT_ID), eq(\"cluster\"), mapCaptor.capture());\n+    ClusterLocalizeResponse resp = clusterController.localize(BILLING_PROJECT_ID, req).getBody();\n+    assertThat(resp.getClusterLocalDirectory()).isEqualTo(\"workspaces_playground/myfirstworkspace\");\n+    verify(notebookService)\n+        .localize(eq(BILLING_PROJECT_ID), eq(getClusterName()), mapCaptor.capture());\n     Map<String, String> localizeMap = mapCaptor.getValue();\n     assertThat(localizeMap.keySet())\n         .containsExactly(\n-            \"workspaces_playground/wsid/foo.ipynb\",\n-            \"workspaces_playground/wsid/.all_of_us_config.json\",\n-            \"workspaces/wsid/.all_of_us_config.json\");\n+            \"workspaces_playground/myfirstworkspace/foo.ipynb\",\n+            \"workspaces_playground/myfirstworkspace/.all_of_us_config.json\",\n+            \"workspaces/myfirstworkspace/.all_of_us_config.json\");\n     assertThat(localizeMap)\n         .containsEntry(\n-            \"workspaces_playground/wsid/foo.ipynb\", \"gs://workspace-bucket/notebooks/foo.ipynb\");\n+            \"workspaces_playground/myfirstworkspace/foo.ipynb\",\n+            \"gs://workspace-bucket/notebooks/foo.ipynb\");\n   }\n \n   @Test\n   public void testLocalize_differentNamespace() {\n     ClusterLocalizeRequest req =\n         new ClusterLocalizeRequest()\n-            .workspaceNamespace(WORKSPACE_NS)\n-            .workspaceId(WORKSPACE_ID)\n             .notebookNames(ImmutableList.of(\"foo.ipynb\"))\n             .playgroundMode(false);\n     stubGetWorkspace(WORKSPACE_NS, WORKSPACE_ID, LOGGED_IN_USER_EMAIL);\n-    ClusterLocalizeResponse resp =\n-        clusterController.localize(\"other-proj\", \"cluster\", req).getBody();\n-    verify(notebookService).localize(eq(\"other-proj\"), eq(\"cluster\"), mapCaptor.capture());\n+    stubGetWorkspace(\"other-proj\", \"myotherworkspace\", LOGGED_IN_USER_EMAIL);\n+    ClusterLocalizeResponse resp = clusterController.localize(\"other-proj\", req).getBody();\n+    verify(notebookService).localize(eq(\"other-proj\"), eq(getClusterName()), mapCaptor.capture());\n \n     Map<String, String> localizeMap = mapCaptor.getValue();\n     assertThat(localizeMap.keySet())\n         .containsExactly(\n-            \"workspaces/proj__wsid/foo.ipynb\",\n-            \"workspaces/proj__wsid/.all_of_us_config.json\",\n-            \"workspaces_playground/proj__wsid/.all_of_us_config.json\");\n+            \"workspaces/myotherworkspace/foo.ipynb\",\n+            \"workspaces/myotherworkspace/.all_of_us_config.json\",\n+            \"workspaces_playground/myotherworkspace/.all_of_us_config.json\");\n     assertThat(localizeMap)\n         .containsEntry(\n-            \"workspaces/proj__wsid/foo.ipynb\", \"gs://workspace-bucket/notebooks/foo.ipynb\");\n-    assertThat(resp.getClusterLocalDirectory()).isEqualTo(\"workspaces/proj__wsid\");\n+            \"workspaces/myotherworkspace/foo.ipynb\", \"gs://workspace-bucket/notebooks/foo.ipynb\");\n+    assertThat(resp.getClusterLocalDirectory()).isEqualTo(\"workspaces/myotherworkspace\");\n     JSONObject aouJson =\n-        dataUriToJson(localizeMap.get(\"workspaces/proj__wsid/.all_of_us_config.json\"));\n+        dataUriToJson(localizeMap.get(\"workspaces/myotherworkspace/.all_of_us_config.json\"));\n     assertThat(aouJson.getString(\"BILLING_CLOUD_PROJECT\")).isEqualTo(\"other-proj\");\n   }\n \n   @Test\n   public void testLocalize_noNotebooks() {\n     ClusterLocalizeRequest req = new ClusterLocalizeRequest();\n-    req.setWorkspaceNamespace(WORKSPACE_NS);\n-    req.setWorkspaceId(WORKSPACE_ID);\n     req.setPlaygroundMode(false);\n     stubGetWorkspace(WORKSPACE_NS, WORKSPACE_ID, LOGGED_IN_USER_EMAIL);\n-    ClusterLocalizeResponse resp =\n-        clusterController.localize(BILLING_PROJECT_ID, \"cluster\", req).getBody();\n-    verify(notebookService).localize(eq(BILLING_PROJECT_ID), eq(\"cluster\"), mapCaptor.capture());\n+    ClusterLocalizeResponse resp = clusterController.localize(BILLING_PROJECT_ID, req).getBody();\n+    verify(notebookService)\n+        .localize(eq(BILLING_PROJECT_ID), eq(getClusterName()), mapCaptor.capture());\n \n     // Config files only.\n     Map<String, String> localizeMap = mapCaptor.getValue();\n     assertThat(localizeMap.keySet())\n         .containsExactly(\n-            \"workspaces_playground/wsid/.all_of_us_config.json\",\n-            \"workspaces/wsid/.all_of_us_config.json\");\n-    assertThat(resp.getClusterLocalDirectory()).isEqualTo(\"workspaces/wsid\");\n+            \"workspaces_playground/myfirstworkspace/.all_of_us_config.json\",\n+            \"workspaces/myfirstworkspace/.all_of_us_config.json\");\n+    assertThat(resp.getClusterLocalDirectory()).isEqualTo(\"workspaces/myfirstworkspace\");\n   }\n \n   @Test\n-  public void listCluster_validateActiveBilling() {\n+  public void GetCluster_validateActiveBilling() {\n     doThrow(ForbiddenException.class)\n         .when(workspaceService)\n         .validateActiveBilling(WORKSPACE_NS, WORKSPACE_ID);\n \n-    assertThrows(\n-        ForbiddenException.class, () -> clusterController.listClusters(WORKSPACE_NS, WORKSPACE_ID));\n+    assertThrows(ForbiddenException.class, () -> clusterController.getCluster(WORKSPACE_NS));\n   }\n \n   @Test\n-  public void listCluster_validateActiveBilling_checkAccessFirst() {\n+  public void getCluster_validateActiveBilling_checkAccessFirst() {\n     doThrow(ForbiddenException.class)\n         .when(workspaceService)\n         .validateActiveBilling(WORKSPACE_NS, WORKSPACE_ID);\n \n     doThrow(ForbiddenException.class)\n         .when(workspaceService)\n-        .enforceWorkspaceAccessLevel(WORKSPACE_NS, WORKSPACE_ID, WorkspaceAccessLevel.READER);\n+        .enforceWorkspaceAccessLevel(WORKSPACE_NS, WORKSPACE_ID, WorkspaceAccessLevel.WRITER);\n \n-    assertThrows(\n-        ForbiddenException.class, () -> clusterController.listClusters(WORKSPACE_NS, WORKSPACE_ID));\n+    assertThrows(ForbiddenException.class, () -> clusterController.getCluster(WORKSPACE_NS));\n     verify(workspaceService, never()).validateActiveBilling(anyString(), anyString());", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0MzU2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383343562", "bodyText": "Good catch \u2013\u00a0fixed.", "author": "gjuggler", "createdAt": "2020-02-24T15:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY5MDk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwMDQ4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382700481", "bodyText": "Why wouldn't we return a Promise<Cluster>?", "author": "jaycarlton", "createdAt": "2020-02-21T17:08:25Z", "path": "ui/src/app/pages/analysis/interactive-notebook.tsx", "diffHunk": "@@ -170,35 +169,14 @@ export const InteractiveNotebook = fp.flow(withUrlParams(), withCurrentWorkspace\n       this.aborter.abort();\n     }\n \n-    private runCluster(onClusterReady: Function): void {\n-      const retry = () => {\n-        this.runClusterTimer = setTimeout(() => this.runCluster(onClusterReady), 5000);\n-      };\n-\n-      clusterApi().listClusters(this.props.urlParams.ns, this.props.urlParams.wsid, {\n-        signal: this.aborter.signal\n-      }).then((body) => {\n-          const cluster = body.defaultCluster;\n-          this.setState({clusterStatus: cluster.status});\n-\n-          if (cluster.status === ClusterStatus.Stopped) {\n-            notebooksClusterApi()\n-              .startCluster(cluster.clusterNamespace, cluster.clusterName);\n-          }\n-\n-          if (cluster.status === ClusterStatus.Running) {\n-            onClusterReady();\n-          } else {\n-            retry();\n-          }\n-        })\n-        .catch((e: Error) => {\n-          if (isAbortError(e)) {\n-            return;\n-          }\n-          // TODO(RW-3097): Backoff, or don't retry forever.\n-          retry();\n-        });\n+    private async runCluster(onClusterReady: Function): Promise<void> {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0NDgzMQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383344831", "bodyText": "Because whoever calls this function doesn't need a return value. This is leaf component code; it's often less critical that the API looks & feels like a well-factored library, since methods tend to be kicked off by user interactions.", "author": "gjuggler", "createdAt": "2020-02-24T15:47:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwMDQ4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MjE2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384582163", "bodyText": "Ok, so instead of runCluster(ready).then(onClusterReady(value)), it's all captured in the callback. Failure just goes to the aborter.signal method", "author": "jaycarlton", "createdAt": "2020-02-26T15:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwMDQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwMTAzMQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382701031", "bodyText": "Could you make a set of in-progress statuses and just do  inProgressStatuses.contains(status)? Also, I don't understand how stopped is in-progress. That seems counter-intuitive.\nFrom the code in onClusterStatusUpdate(), it seems like a better name might be isClusterInitialized().", "author": "jaycarlton", "createdAt": "2020-02-21T17:09:31Z", "path": "ui/src/app/pages/analysis/notebook-redirect.tsx", "diffHunk": "@@ -239,10 +238,10 @@ export const NotebookRedirect = fp.flow(withUserProfile(), withCurrentWorkspace(\n       };\n     }\n \n-    private isClusterInProgress(cluster: Cluster): boolean {\n-      return cluster.status === ClusterStatus.Starting ||\n-        cluster.status === ClusterStatus.Stopping ||\n-        cluster.status === ClusterStatus.Stopped;\n+    private isClusterInProgress(status: ClusterStatus): boolean {\n+      return status === ClusterStatus.Starting ||", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0Njg4NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383346884", "bodyText": "I tried to be minimally invasive with my changes here, to avoid risking unnecessary breakages in this component.\nI'll rename this to \"isClusterInitInProgress\" which is probably more accurate.\nThe reason STOPPED is part of this check, is that when a cluster is STOPPED, our init logic will automatically call .resumeCluster to kick it back into RUNNING state.", "author": "gjuggler", "createdAt": "2020-02-24T15:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwMTAzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4NDQxMw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384584413", "bodyText": "OK. Another thing to look at is whether a switch makes more sense when you're dealing with bundles of enum values.", "author": "jaycarlton", "createdAt": "2020-02-26T15:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwMTAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwMjI5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382702297", "bodyText": "question: I thought there was a shorthand for this situation akin to method references in Java? Or do we just have to do this to get the this right?", "author": "jaycarlton", "createdAt": "2020-02-21T17:12:14Z", "path": "ui/src/app/pages/analysis/notebook-redirect.tsx", "diffHunk": "@@ -308,54 +301,26 @@ export const NotebookRedirect = fp.flow(withUserProfile(), withCurrentWorkspace(\n       this.aborter.abort();\n     }\n \n+    onClusterStatusUpdate(status: ClusterStatus) {\n+      if (this.isClusterInProgress(status)) {\n+        this.incrementProgress(Progress.Resuming);\n+      } else {\n+        this.incrementProgress(Progress.Initializing);\n+      }\n+    }\n+\n     // check the cluster's status: if it's Running we can connect the notebook to it\n     // otherwise we need to start polling\n     private async initializeClusterStatusChecking(billingProjectId) {\n       this.incrementProgress(Progress.Unknown);\n-      try {\n-        const cluster = await this.getDefaultCluster(billingProjectId);\n-        if (cluster.status === ClusterStatus.Running) {\n-          await this.connectToRunningCluster(cluster);\n-        } else {\n-          if (this.isClusterInProgress(cluster)) {\n-            this.incrementProgress(Progress.Resuming);\n-          } else {\n-            this.incrementProgress(Progress.Initializing);\n-          }\n-\n-          this.pollTimer = setTimeout(() => this.pollForRunningCluster(billingProjectId), clusterPollingTimeoutMillis);\n-        }\n-      } catch (error) {\n-        if (!isAbortError(error)) {\n-          reportError(error);\n-          this.setState({showErrorModal: true});\n-          throw error;\n-        }\n-      }\n-    }\n \n-    private async pollForRunningCluster(billingProjectId) {\n-      try {\n-        const cluster = await this.getDefaultCluster(billingProjectId);\n-        if (cluster.status === ClusterStatus.Running) {\n-          await this.connectToRunningCluster(cluster);\n-        } else {\n-          // re-start cluster if stopped, and try again in the next polling interval\n-          if (cluster.status === ClusterStatus.Stopped) {\n-            await this.clusterRetry(() => notebooksClusterApi().startCluster(\n-              cluster.clusterNamespace, cluster.clusterName, {signal: this.aborter.signal}));\n-          }\n-\n-          // TODO(RW-3097): Backoff, or don't retry forever.\n-          this.pollTimer = setTimeout(() => this.pollForRunningCluster(billingProjectId), clusterPollingTimeoutMillis);\n-        }\n-      } catch (error) {\n-        if (!isAbortError(error)) {\n-          reportError(error);\n-          this.setState({showErrorModal: true});\n-          throw error;\n-        }\n-      }\n+      const initializer = new ClusterInitializer({\n+        workspaceNamespace: billingProjectId,\n+        onStatusUpdate: (status) => this.onClusterStatusUpdate(status),", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0NzU1MA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383347550", "bodyText": "Yes, you always need the arrow function for 'this'  to get propagated correctly.", "author": "gjuggler", "createdAt": "2020-02-24T15:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwMjI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNDEyOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382704129", "bodyText": "Why not use ClusterStatus.Unknown? I get surprised by null enum variables.", "author": "jaycarlton", "createdAt": "2020-02-21T17:16:06Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;\n \n   constructor(props) {\n     super(props);\n \n     this.state = {\n-      cluster: null,\n+      clusterStatus: null,", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0ODU3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383348572", "bodyText": "A null value here actually means there is no cluster available at the moment \u2013\u00a0see L121 which handles this case.\nClusterStatus.UNKNOWN is a signal from Leo that their system doesn't know the state of a cluster \u2013 which is a different case that we apparently don't care too much about handling.", "author": "gjuggler", "createdAt": "2020-02-24T15:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNDEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNTAxOA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382705018", "bodyText": "Some logging might help here, to indicate what steps have been successfully executed. I don't know how that fits into our overall client logging strategy.\nIt'd be nice too if we could associate the initializer with a UUID or something on the backend for logging traceability.", "author": "jaycarlton", "createdAt": "2020-02-21T17:18:07Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;\n \n   constructor(props) {\n     super(props);\n \n     this.state = {\n-      cluster: null,\n+      clusterStatus: null,\n+      isPollingCluster: true,\n       resetClusterPending: false,\n       resetClusterModal: false,\n-      clusterDeletionFailure: true,\n+      resetClusterFailure: true,\n     };\n   }\n \n   componentDidMount() {\n-    this.pollCluster(this.props.billingProjectId);\n+    this.createClusterInitializer(false);\n+  }\n+\n+  async createClusterInitializer(allowClusterActions: boolean) {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNTcxOA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382705718", "bodyText": "again, I don't understand why clusterStatus should ever be null, unless unknown is more specific than I was thinking.", "author": "jaycarlton", "createdAt": "2020-02-21T17:19:33Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;\n \n   constructor(props) {\n     super(props);\n \n     this.state = {\n-      cluster: null,\n+      clusterStatus: null,\n+      isPollingCluster: true,\n       resetClusterPending: false,\n       resetClusterModal: false,\n-      clusterDeletionFailure: true,\n+      resetClusterFailure: true,\n     };\n   }\n \n   componentDidMount() {\n-    this.pollCluster(this.props.billingProjectId);\n+    this.createClusterInitializer(false);\n+  }\n+\n+  async createClusterInitializer(allowClusterActions: boolean) {\n+    const maxActionCount = allowClusterActions ? 1 : 0;\n+\n+    // Kick off an initializer which will poll for cluster status.\n+    this.initializer = new ClusterInitializer({\n+      workspaceNamespace: this.props.workspaceNamespace,\n+      onStatusUpdate: (clusterStatus: ClusterStatus) => {\n+        if (this.aborter.signal.aborted) {\n+          // IF we've been unmounted, don't try to update state.\n+          return;\n+        }\n+        this.setState({\n+          clusterStatus: clusterStatus,\n+        });\n+      },\n+      abortSignal: this.aborter.signal,\n+      // For the reset button, we never want to affect the cluster state. With the maxFooCount set\n+      // to zero, the initializer will reject the promise when it reaches a non-transitional state.\n+      maxDeleteCount: maxActionCount,\n+      maxCreateCount: maxActionCount,\n+      maxResumeCount: maxActionCount,\n+    });\n+\n+    try {\n+      this.setState({isPollingCluster: true, clusterStatus: null});", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNjQ1MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382706451", "bodyText": "Is ClusterInitializer more of a general ClusterUpdater?", "author": "jaycarlton", "createdAt": "2020-02-21T17:21:15Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;\n \n   constructor(props) {\n     super(props);\n \n     this.state = {\n-      cluster: null,\n+      clusterStatus: null,\n+      isPollingCluster: true,\n       resetClusterPending: false,\n       resetClusterModal: false,\n-      clusterDeletionFailure: true,\n+      resetClusterFailure: true,\n     };\n   }\n \n   componentDidMount() {\n-    this.pollCluster(this.props.billingProjectId);\n+    this.createClusterInitializer(false);\n+  }\n+\n+  async createClusterInitializer(allowClusterActions: boolean) {\n+    const maxActionCount = allowClusterActions ? 1 : 0;\n+\n+    // Kick off an initializer which will poll for cluster status.\n+    this.initializer = new ClusterInitializer({", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0OTE1MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383349151", "bodyText": "Not really. It has a specific set of actions directed towards auto-initializing a cluster into a running state.", "author": "gjuggler", "createdAt": "2020-02-24T15:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNjQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNjgyNw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382706827", "bodyText": "what are we doing with the exception if it's not a ClusterInitializationFailedError?", "author": "jaycarlton", "createdAt": "2020-02-21T17:22:02Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;\n \n   constructor(props) {\n     super(props);\n \n     this.state = {\n-      cluster: null,\n+      clusterStatus: null,\n+      isPollingCluster: true,\n       resetClusterPending: false,\n       resetClusterModal: false,\n-      clusterDeletionFailure: true,\n+      resetClusterFailure: true,\n     };\n   }\n \n   componentDidMount() {\n-    this.pollCluster(this.props.billingProjectId);\n+    this.createClusterInitializer(false);\n+  }\n+\n+  async createClusterInitializer(allowClusterActions: boolean) {\n+    const maxActionCount = allowClusterActions ? 1 : 0;\n+\n+    // Kick off an initializer which will poll for cluster status.\n+    this.initializer = new ClusterInitializer({\n+      workspaceNamespace: this.props.workspaceNamespace,\n+      onStatusUpdate: (clusterStatus: ClusterStatus) => {\n+        if (this.aborter.signal.aborted) {\n+          // IF we've been unmounted, don't try to update state.\n+          return;\n+        }\n+        this.setState({\n+          clusterStatus: clusterStatus,\n+        });\n+      },\n+      abortSignal: this.aborter.signal,\n+      // For the reset button, we never want to affect the cluster state. With the maxFooCount set\n+      // to zero, the initializer will reject the promise when it reaches a non-transitional state.\n+      maxDeleteCount: maxActionCount,\n+      maxCreateCount: maxActionCount,\n+      maxResumeCount: maxActionCount,\n+    });\n+\n+    try {\n+      this.setState({isPollingCluster: true, clusterStatus: null});\n+      await this.initializer.run();\n+      this.setState({isPollingCluster: false});\n+    } catch (e) {\n+      if (this.aborter.signal.aborted) {\n+        return;\n+      }\n+      if (e instanceof ClusterInitializationFailedError) {\n+        this.setState({clusterStatus: e.cluster ? e.cluster.status : null});\n+      }\n+      this.setState({", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNzU0Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383417547", "bodyText": "Good point \u2013 I added a reportError call which logs unexpected exceptions to stackdriver.", "author": "gjuggler", "createdAt": "2020-02-24T17:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwNjgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MTE5MA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382751190", "bodyText": "So this corresponds to closing the window with the page hosting the button?", "author": "jaycarlton", "createdAt": "2020-02-21T18:59:19Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;\n \n   constructor(props) {\n     super(props);\n \n     this.state = {\n-      cluster: null,\n+      clusterStatus: null,\n+      isPollingCluster: true,\n       resetClusterPending: false,\n       resetClusterModal: false,\n-      clusterDeletionFailure: true,\n+      resetClusterFailure: true,\n     };\n   }\n \n   componentDidMount() {\n-    this.pollCluster(this.props.billingProjectId);\n+    this.createClusterInitializer(false);\n+  }\n+\n+  async createClusterInitializer(allowClusterActions: boolean) {\n+    const maxActionCount = allowClusterActions ? 1 : 0;\n+\n+    // Kick off an initializer which will poll for cluster status.\n+    this.initializer = new ClusterInitializer({\n+      workspaceNamespace: this.props.workspaceNamespace,\n+      onStatusUpdate: (clusterStatus: ClusterStatus) => {\n+        if (this.aborter.signal.aborted) {\n+          // IF we've been unmounted, don't try to update state.\n+          return;\n+        }\n+        this.setState({\n+          clusterStatus: clusterStatus,\n+        });\n+      },\n+      abortSignal: this.aborter.signal,\n+      // For the reset button, we never want to affect the cluster state. With the maxFooCount set\n+      // to zero, the initializer will reject the promise when it reaches a non-transitional state.\n+      maxDeleteCount: maxActionCount,\n+      maxCreateCount: maxActionCount,\n+      maxResumeCount: maxActionCount,\n+    });\n+\n+    try {\n+      this.setState({isPollingCluster: true, clusterStatus: null});\n+      await this.initializer.run();\n+      this.setState({isPollingCluster: false});\n+    } catch (e) {\n+      if (this.aborter.signal.aborted) {\n+        return;\n+      }\n+      if (e instanceof ClusterInitializationFailedError) {\n+        this.setState({clusterStatus: e.cluster ? e.cluster.status : null});\n+      }\n+      this.setState({\n+        isPollingCluster: false\n+      });\n+    }\n   }\n \n   componentWillUnmount() {\n-    if (this.pollClusterTimer) {\n-      clearTimeout(this.pollClusterTimer);\n+    this.aborter.abort();", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxNzkzMg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383417932", "bodyText": "This corresponds to the user navigating to some other page or component (remember we're in a single-page app world). React will call componentWillUnmount when this happens, and we trigger our aborter signal to cancel any outstanding ajax requests.", "author": "gjuggler", "createdAt": "2020-02-24T17:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MTE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4ODA4Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384588087", "bodyText": "Is ChromeOS a single page yet?\nCool. Do we not need/care to track why we call abort?", "author": "jaycarlton", "createdAt": "2020-02-26T15:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MTE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MTk3OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382751979", "bodyText": "question: Why do you need a div here but not in the prior branch?", "author": "jaycarlton", "createdAt": "2020-02-21T19:01:05Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;\n \n   constructor(props) {\n     super(props);\n \n     this.state = {\n-      cluster: null,\n+      clusterStatus: null,\n+      isPollingCluster: true,\n       resetClusterPending: false,\n       resetClusterModal: false,\n-      clusterDeletionFailure: true,\n+      resetClusterFailure: true,\n     };\n   }\n \n   componentDidMount() {\n-    this.pollCluster(this.props.billingProjectId);\n+    this.createClusterInitializer(false);\n+  }\n+\n+  async createClusterInitializer(allowClusterActions: boolean) {\n+    const maxActionCount = allowClusterActions ? 1 : 0;\n+\n+    // Kick off an initializer which will poll for cluster status.\n+    this.initializer = new ClusterInitializer({\n+      workspaceNamespace: this.props.workspaceNamespace,\n+      onStatusUpdate: (clusterStatus: ClusterStatus) => {\n+        if (this.aborter.signal.aborted) {\n+          // IF we've been unmounted, don't try to update state.\n+          return;\n+        }\n+        this.setState({\n+          clusterStatus: clusterStatus,\n+        });\n+      },\n+      abortSignal: this.aborter.signal,\n+      // For the reset button, we never want to affect the cluster state. With the maxFooCount set\n+      // to zero, the initializer will reject the promise when it reaches a non-transitional state.\n+      maxDeleteCount: maxActionCount,\n+      maxCreateCount: maxActionCount,\n+      maxResumeCount: maxActionCount,\n+    });\n+\n+    try {\n+      this.setState({isPollingCluster: true, clusterStatus: null});\n+      await this.initializer.run();\n+      this.setState({isPollingCluster: false});\n+    } catch (e) {\n+      if (this.aborter.signal.aborted) {\n+        return;\n+      }\n+      if (e instanceof ClusterInitializationFailedError) {\n+        this.setState({clusterStatus: e.cluster ? e.cluster.status : null});\n+      }\n+      this.setState({\n+        isPollingCluster: false\n+      });\n+    }\n   }\n \n   componentWillUnmount() {\n-    if (this.pollClusterTimer) {\n-      clearTimeout(this.pollClusterTimer);\n+    this.aborter.abort();\n+  }\n+\n+  private createTooltip(content: React.ReactFragment, children: React.ReactFragment): React.ReactFragment {\n+    return <TooltipTrigger content={content} side='right'>\n+      {children}\n+    </TooltipTrigger>;\n+  }\n+\n+  private createButton(label: string, enabled: boolean, callback: () => void): React.ReactFragment {\n+    return <Button disabled={!enabled}\n+                 onClick={callback}\n+                 data-test-id='reset-notebook-button'\n+                 type='secondary'>\n+    {label}\n+    </Button>;\n+  }\n+\n+  createButtonAndLabel(): (React.ReactFragment) {\n+    if (this.state.isPollingCluster) {\n+      const tooltipContent = <div>\n+        Your notebook server is still being provisioned. <br/>\n+        (detailed status: {this.state.clusterStatus})\n+      </div>;\n+      return this.createTooltip(\n+        tooltipContent,\n+        this.createButton(RESTART_LABEL, false, null));\n+    } else if (this.state.clusterStatus === null) {\n+      // If the initializer has completed and the status is null, it means that\n+      // a cluster doesn't exist for this workspace.\n+      return this.createTooltip(\n+        'You have not yet created a notebook server for this workspace.',\n+        this.createButton(CREATE_LABEL, true, () => this.createOrResetCluster()));\n+    } else {\n+      // We usually reach this state if the cluster is at a \"terminal\" status and the initializer has\n+      // completed. This may be ClusterStatus.Stopped, ClusterStatus.Running, ClusterStatus.Error,\n+      // etc.\n+      const tooltipContent = <div>", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyMTA1Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383421053", "bodyText": "Opening the  enters us into JSX template mode, which lets me use the {this.state.clusterStatus} variable interpolation more easily. I could have opted for an ES6 template literal like Your server is in the following state: ${this.state.clusterStatus} but this approach felt more inline with our default use of JSX.", "author": "gjuggler", "createdAt": "2020-02-24T17:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MTk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4NzA4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384587081", "bodyText": "OK, as long as the tooltip doesn't care.", "author": "jaycarlton", "createdAt": "2020-02-26T15:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MTk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1Mjg4Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382752886", "bodyText": "nit: typically I like to have properties that are active-high, like resetClusterSuccess. That may not be a win here though.", "author": "jaycarlton", "createdAt": "2020-02-21T19:03:09Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -109,41 +175,24 @@ export class ResetClusterButton extends React.Component<Props, State> {\n     this.setState({\n       resetClusterPending: false,\n       resetClusterModal: true,\n-      clusterDeletionFailure: false\n+      resetClusterFailure: false", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyMTUwNg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383421506", "bodyText": "This is a boolean capturing when an error occurs and showing UI material conditionally on the existence of an error. It's a very common pattern in UI state to have a true-on-failure flag to aid with this.", "author": "gjuggler", "createdAt": "2020-02-24T17:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1Mjg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MzU3Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382753576", "bodyText": "Maybe a comment here to say why you're calling delete in a createOrReset method. Is that just how you do a reset?", "author": "jaycarlton", "createdAt": "2020-02-21T19:04:39Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -109,41 +175,24 @@ export class ResetClusterButton extends React.Component<Props, State> {\n     this.setState({\n       resetClusterPending: false,\n       resetClusterModal: true,\n-      clusterDeletionFailure: false\n+      resetClusterFailure: false\n     });\n   }\n \n-  resetCluster(): void {\n-    this.setState({ resetClusterPending: true });\n-\n-    const clusterBillingProjectId = this.state.cluster.clusterNamespace;\n-    clusterApi().deleteCluster(this.state.cluster.clusterNamespace, this.state.cluster.clusterName)\n-      .then(() => {\n-        this.setState({cluster: null, resetClusterPending: false, resetClusterModal: false});\n-        this.pollCluster(clusterBillingProjectId);\n-      })\n-      .catch(() => {\n-        this.setState({resetClusterPending: false, clusterDeletionFailure: true});\n-      });\n-  }\n+  async createOrResetCluster(): Promise<void> {\n+    try {\n+      this.setState({resetClusterPending: true});\n+      if (this.state.clusterStatus === null) {\n+        await clusterApi().createCluster(this.props.workspaceNamespace);\n+      } else {\n+        await clusterApi().deleteCluster(this.props.workspaceNamespace);", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyMTc5NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383421795", "bodyText": "Yeah, the naming is a bit off but this is the reset branch.", "author": "gjuggler", "createdAt": "2020-02-24T17:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MzU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NDIxMA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382754210", "bodyText": "Do they not have little helper or something to conditionally show an element so you don't need the !!?", "author": "jaycarlton", "createdAt": "2020-02-21T19:05:54Z", "path": "ui/src/app/pages/workspace/workspace-about.tsx", "diffHunk": "@@ -241,8 +241,7 @@ export const WorkspaceAbout = fp.flow(withUserProfile(), withUrlParams(), withCd\n               fp.capitalize(workspace.dataAccessLevel.toString()) : 'Loading...'}</div>\n           </div>\n           {!!this.workspaceClusterBillingProjectId() &&\n-            <ResetClusterButton billingProjectId={this.workspaceClusterBillingProjectId()}\n-                                workspaceFirecloudName={this.state.workspace.id}/>}\n+            <ResetClusterButton workspaceNamespace={this.workspaceClusterBillingProjectId()}/>}", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyMjM4NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383422384", "bodyText": "This is the most commonly used pattern in our codebase to conditionally show an element. Ideally it's based on a call to a boolean method. The !! is just a sort of hacky javascript way of interpreting a non-boolean expression as a boolean.", "author": "gjuggler", "createdAt": "2020-02-24T17:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NjEzNA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382756134", "bodyText": "why is this commented out?\nThis feels a bit sophisticated for test code, but I guess when asyncs are involved, it gets tricky.", "author": "jaycarlton", "createdAt": "2020-02-21T19:10:02Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3MjE2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383472167", "bodyText": "Turns out this was unnecessary. Removed.", "author": "gjuggler", "createdAt": "2020-02-24T19:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NjEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NjkyMg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382756922", "bodyText": "Some comments here on how this all works would be helpful. It looks like it waits on my promise and sets a settled property if it finishes. There's an await on top of another await, so that the test timer and background timers can both go?", "author": "jaycarlton", "createdAt": "2020-02-21T19:11:46Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3MzQwMA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383473400", "bodyText": "Added some method comments. Yes, it gets tricky...", "author": "gjuggler", "createdAt": "2020-02-24T19:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NjkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3MTk2NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382771965", "bodyText": "Where's the part where this initializer is set up not to talk to the real service?", "author": "jaycarlton", "createdAt": "2020-02-21T19:45:02Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NjM0NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383446344", "bodyText": "The calls to registerApiClient(foo, new FooStub()) in the setUp method.", "author": "gjuggler", "createdAt": "2020-02-24T18:47:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3MTk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3Mzc2MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382773761", "bodyText": "this is redundant I think if you're going to expect the whole array.", "author": "jaycarlton", "createdAt": "2020-02-21T19:48:47Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3Njk5Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383476996", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T19:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3Mzc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3Njg1NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382776855", "bodyText": "nit: IJ tells me you can drop the workspaceNamespace parameter if it's unused.", "author": "jaycarlton", "createdAt": "2020-02-21T19:55:23Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should give up after too many server errors', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    for (let i = 0; i < 10; i++) {\n+      mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4NjI4OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383486288", "bodyText": "I think it's worth including \u2014 inasmuch as unit tests are documentation of API surfaces, it would be confusing to not see these here.", "author": "gjuggler", "createdAt": "2020-02-24T20:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3Njg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3ODM2NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382778364", "bodyText": "cluster is unused", "author": "jaycarlton", "createdAt": "2020-02-21T19:58:44Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3Njk0Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383476943", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T19:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3ODM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3OTIwNw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382779207", "bodyText": "nit: these mockGetClusterCalls() invocations might be readable with a helper lambda/method like baseWith(s: ClusterStatus): Cluster. So\n{...baseCluster, status: ClusterStatus.Starting} becomes baseWith(ClusterStatus.Starting).\nIt's just a lot of ...baseCluster, but I'm sure some of that distraction is culture shock.", "author": "jaycarlton", "createdAt": "2020-02-21T20:00:36Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3NDkxNw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383474917", "bodyText": "Using Partial in the mockGetClusterCalls method saved the day. Thanks for flagging this.", "author": "gjuggler", "createdAt": "2020-02-24T19:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3OTIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4MDc3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382780771", "bodyText": "nit: I wonder if there's a way to visually separate the setup from the punchline in these longer tests. The code under test is almost an afterthought in terms of how little space it takes up.", "author": "jaycarlton", "createdAt": "2020-02-21T20:04:19Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3NzMyOA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383477328", "bodyText": "That's what the extra newlines are for. Most unit tests have three stanzas: setup, execution, and assertions. This one follows that pattern, though the stanzas are differently sized.", "author": "gjuggler", "createdAt": "2020-02-24T19:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4MDc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4MTY0NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382781645", "bodyText": "nit: if we don't need to assert anything on the initializer, might as well inline it.", "author": "jaycarlton", "createdAt": "2020-02-21T20:06:33Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4NTY3OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383485679", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T20:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4MTY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4MjU4Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382782587", "bodyText": "nit: I looked for a mockImplementationNTimes() but didn't see anything. It might not hurt to write your own if you need to do this in more than one place.", "author": "jaycarlton", "createdAt": "2020-02-21T20:08:52Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should give up after too many server errors', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    for (let i = 0; i < 10; i++) {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4MjgyNg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382782826", "bodyText": "How do you detect if the expected error wasn't thrown? Here and below.", "author": "jaycarlton", "createdAt": "2020-02-21T20:09:24Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should give up after too many server errors', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    for (let i = 0; i < 10; i++) {\n+      mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+        throw new Response(null, {status: 503});\n+      });\n+    }\n+\n+    const initializer = createInitializer();\n+\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4Njc2NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383486765", "bodyText": "The expect.assertions(1) ensures that at least one expect call must be made.", "author": "gjuggler", "createdAt": "2020-02-24T20:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4MjgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NDExOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382784119", "bodyText": "I think you can use mockReturnValueOnce or mockResolvedValue or one of the other helpers for these common cases.", "author": "jaycarlton", "createdAt": "2020-02-21T20:12:25Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should give up after too many server errors', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    for (let i = 0; i < 10; i++) {\n+      mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+        throw new Response(null, {status: 503});\n+      });\n+    }\n+\n+    const initializer = createInitializer();\n+\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {\n+      expect(error.message).toMatch(/max server error count/i);\n+    });\n+  });\n+\n+    it('Should timeout after max delay', async() => {\n+    mockGetCluster.mockImplementation(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Starting};\n+    });\n+\n+    // There's some nuance / awkwardness to this test: the ClusterInitializer uses Date.now() to get\n+    // the current timestamp, but Jest doesn't support fake clock functionality (see\n+    // https://github.com/facebook/jest/issues/2684). So we just set a very quick timeout here to\n+    // ensure the threshold is reached after a couple polling loops.\n+    const initializer = createInitializer({overallTimeout: 30});\n+\n+    // Tell Jest that we plan to have 1 assertion. This ensures that the test won't\n+    // pass if the promise fails.\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {\n+      expect(error.message).toMatch(/max time allowed/i);\n+    });\n+  });\n+\n+  it('Should reject promise after abort signal', async() => {\n+    mockGetCluster.mockImplementation(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Starting};\n+    });\n+    const aborter = new AbortController();\n+    const initializer = createInitializer({\n+      abortSignal: aborter.signal\n+    });\n+\n+    const initializePromise = runInitializerAndTimers(initializer);\n+\n+    // Wait a reasonably-short amount of time, at least one polling delay period, before sending\n+    // an abort signal.\n+    await new Promise(resolve => setTimeout(resolve, 20));\n+    aborter.abort();\n+\n+    expect.assertions(1);\n+    return initializePromise.catch(error => {\n+      expect(error.message).toMatch(/aborted/i);\n+    });\n+  });\n+\n+  it('Should respect the maxDeleteCount option', async() => {\n+    // Mock out getCluster API responses which simulate a cluster in an error state, which is then\n+    // reset, but ends up in an error state again. This scenario should warrant two deleteCluster\n+    // calls, but the initializer is configured to max out at 1 and should return an error.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Error},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementation(async(workspaceNamespace) => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NDY5NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382784694", "bodyText": "nit: mockRejectedValueOnce() looks like a more succinct way to do this.", "author": "jaycarlton", "createdAt": "2020-02-21T20:13:50Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should give up after too many server errors', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    for (let i = 0; i < 10; i++) {\n+      mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+        throw new Response(null, {status: 503});", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUzODAyNw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383538027", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T21:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NTIzNA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382785234", "bodyText": "If we can't change the clock, can we at least exert some more control over the timers?", "author": "jaycarlton", "createdAt": "2020-02-21T20:15:15Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should give up after too many server errors', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    for (let i = 0; i < 10; i++) {\n+      mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+        throw new Response(null, {status: 503});\n+      });\n+    }\n+\n+    const initializer = createInitializer();\n+\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {\n+      expect(error.message).toMatch(/max server error count/i);\n+    });\n+  });\n+\n+    it('Should timeout after max delay', async() => {\n+    mockGetCluster.mockImplementation(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Starting};\n+    });\n+\n+    // There's some nuance / awkwardness to this test: the ClusterInitializer uses Date.now() to get\n+    // the current timestamp, but Jest doesn't support fake clock functionality (see\n+    // https://github.com/facebook/jest/issues/2684). So we just set a very quick timeout here to\n+    // ensure the threshold is reached after a couple polling loops.\n+    const initializer = createInitializer({overallTimeout: 30});\n+\n+    // Tell Jest that we plan to have 1 assertion. This ensures that the test won't\n+    // pass if the promise fails.\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4NzE4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383487181", "bodyText": "Not sure what this is getting at. I tried my best to explain in the comment, there's not really any other way around this AFAICT.", "author": "gjuggler", "createdAt": "2020-02-24T20:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NTIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NTk4NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382785984", "bodyText": "Maybe make a helper out of these two lines, like a doAfter(fn, timeoutMillis)?", "author": "jaycarlton", "createdAt": "2020-02-21T20:17:04Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should give up after too many server errors', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    for (let i = 0; i < 10; i++) {\n+      mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+        throw new Response(null, {status: 503});\n+      });\n+    }\n+\n+    const initializer = createInitializer();\n+\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {\n+      expect(error.message).toMatch(/max server error count/i);\n+    });\n+  });\n+\n+    it('Should timeout after max delay', async() => {\n+    mockGetCluster.mockImplementation(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Starting};\n+    });\n+\n+    // There's some nuance / awkwardness to this test: the ClusterInitializer uses Date.now() to get\n+    // the current timestamp, but Jest doesn't support fake clock functionality (see\n+    // https://github.com/facebook/jest/issues/2684). So we just set a very quick timeout here to\n+    // ensure the threshold is reached after a couple polling loops.\n+    const initializer = createInitializer({overallTimeout: 30});\n+\n+    // Tell Jest that we plan to have 1 assertion. This ensures that the test won't\n+    // pass if the promise fails.\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {\n+      expect(error.message).toMatch(/max time allowed/i);\n+    });\n+  });\n+\n+  it('Should reject promise after abort signal', async() => {\n+    mockGetCluster.mockImplementation(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Starting};\n+    });\n+    const aborter = new AbortController();\n+    const initializer = createInitializer({\n+      abortSignal: aborter.signal\n+    });\n+\n+    const initializePromise = runInitializerAndTimers(initializer);\n+\n+    // Wait a reasonably-short amount of time, at least one polling delay period, before sending\n+    // an abort signal.\n+    await new Promise(resolve => setTimeout(resolve, 20));", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4NzU0Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383487547", "bodyText": "That would basically obfuscate what async Javascript makes easy to read...", "author": "gjuggler", "createdAt": "2020-02-24T20:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5NTc3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384595772", "bodyText": "It's not obfuscating if you kill 4 keywords and 2 scopes in a one-liner: {await, new, promise, setTimeout, fat arrow}. It's only easy to read if you like reading JS. \ud83d\ude09", "author": "jaycarlton", "createdAt": "2020-02-26T16:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4Njk2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382786962", "bodyText": "Hmm, I don't see where return values of the it statements are checked. It actually looks like the return type for it is void.", "author": "jaycarlton", "createdAt": "2020-02-21T20:19:35Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should give up after too many server errors', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    for (let i = 0; i < 10; i++) {\n+      mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+        throw new Response(null, {status: 503});\n+      });\n+    }\n+\n+    const initializer = createInitializer();\n+\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {\n+      expect(error.message).toMatch(/max server error count/i);\n+    });\n+  });\n+\n+    it('Should timeout after max delay', async() => {\n+    mockGetCluster.mockImplementation(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Starting};\n+    });\n+\n+    // There's some nuance / awkwardness to this test: the ClusterInitializer uses Date.now() to get\n+    // the current timestamp, but Jest doesn't support fake clock functionality (see\n+    // https://github.com/facebook/jest/issues/2684). So we just set a very quick timeout here to\n+    // ensure the threshold is reached after a couple polling loops.\n+    const initializer = createInitializer({overallTimeout: 30});\n+\n+    // Tell Jest that we plan to have 1 assertion. This ensures that the test won't\n+    // pass if the promise fails.\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {\n+      expect(error.message).toMatch(/max time allowed/i);\n+    });\n+  });\n+\n+  it('Should reject promise after abort signal', async() => {\n+    mockGetCluster.mockImplementation(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Starting};\n+    });\n+    const aborter = new AbortController();\n+    const initializer = createInitializer({\n+      abortSignal: aborter.signal\n+    });\n+\n+    const initializePromise = runInitializerAndTimers(initializer);\n+\n+    // Wait a reasonably-short amount of time, at least one polling delay period, before sending\n+    // an abort signal.\n+    await new Promise(resolve => setTimeout(resolve, 20));\n+    aborter.abort();\n+\n+    expect.assertions(1);\n+    return initializePromise.catch(error => {\n+      expect(error.message).toMatch(/aborted/i);\n+    });\n+  });\n+\n+  it('Should respect the maxDeleteCount option', async() => {\n+    // Mock out getCluster API responses which simulate a cluster in an error state, which is then\n+    // reset, but ends up in an error state again. This scenario should warrant two deleteCluster\n+    // calls, but the initializer is configured to max out at 1 and should return an error.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Error},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementation(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockCreateCluster.mockImplementation(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+\n+    const initializer = createInitializer({maxDeleteCount: 1});\n+\n+    expect.assertions(2);\n+    return runInitializerAndTimers(initializer).catch(error => {\n+      expect(mockDeleteCluster).toHaveBeenCalledTimes(1);\n+      expect(error.message).toMatch(/max cluster delete count/i);\n+    });\n+  });\n+\n+  it('Should respect the maxCreateCount option', async() => {\n+    // Ensure that the initializer won't take action on a NOT_FOUND cluster if the maxCreateCount\n+    // is set to disallow create requests.\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    const initializer = createInitializer({maxCreateCount: 0});\n+    return runInitializerAndTimers(initializer).catch(error => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4ODUxOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383488519", "bodyText": "This was a bit of async JS weirdness. For async tests you actually need to return a Promise that Jest will then wait on; instead of that, I'm switching back to using a try / catch statement with an inner 'await foo' expression which effectively does the same thing.\nAsync javascript is pretty mind-bending, but we use it heavily. Worth reading up on at some point. MDN is one of the best sources: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function", "author": "gjuggler", "createdAt": "2020-02-24T20:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4Njk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NzUxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382787511", "bodyText": "It would be simpler to have a version that takes in an array of statuses, since the base cluster props seem to be used everywhere.", "author": "jaycarlton", "createdAt": "2020-02-21T20:20:56Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NjA5OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383446099", "bodyText": "Hmm, that's a good point. I'm hesitant to make the API only depend on status, but I'll definitely remove the repeated use of ...baseCluster.", "author": "gjuggler", "createdAt": "2020-02-24T18:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NzUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4ODA4Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382788083", "bodyText": "Can you use this Duration class? https://nodes.duniter.io/typescript/duniter/typedoc/interfaces/moment.duration.html", "author": "jaycarlton", "createdAt": "2020-02-21T20:22:16Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MDc5OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383490799", "bodyText": "Not worth it here, IMO.", "author": "gjuggler", "createdAt": "2020-02-24T20:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4ODA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4OTE4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382789181", "bodyText": "Is it not desirable to call it in that situation, or just not feasible for some reason?", "author": "jaycarlton", "createdAt": "2020-02-21T20:25:07Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5NjE4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383496189", "bodyText": "Actually \u2013\u00a0it's probably better for this to be called with a null value when cluster not found. Updated the comment, code & test.", "author": "gjuggler", "createdAt": "2020-02-24T20:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4OTE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4OTMzMw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382789333", "bodyText": "nit: these could all be Durations as well", "author": "jaycarlton", "createdAt": "2020-02-21T20:25:32Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4OTU2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382789562", "bodyText": "Is this like an event sink?", "author": "jaycarlton", "createdAt": "2020-02-21T20:25:58Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUyODgxNA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383528814", "bodyText": "It's a web API, see https://developer.mozilla.org/en-US/docs/Web/API/AbortController", "author": "gjuggler", "createdAt": "2020-02-24T21:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4OTU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MDMxOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382790319", "bodyText": "question: How much of this class is cluster-specific versus something that could be reused for another long-running operation?", "author": "jaycarlton", "createdAt": "2020-02-21T20:27:53Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUyODk1OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383528958", "bodyText": "Very much cluster-specific.", "author": "gjuggler", "createdAt": "2020-02-24T21:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MDMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MTEzMw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382791133", "bodyText": "FWIW, I think you can just do this.overallTimeout = this.overallTimeout || DEFAULT_OVERALL_TIMEOUT. Have to be careful with builtins though.\n(nit): Also, I'd probably invert the condition so you're checking  == null, just to avoid negation wherever possible.\nFinally, there's got to be some kind of builtin notion of a class/struct property with a default value.", "author": "jaycarlton", "createdAt": "2020-02-21T20:30:01Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUzOTM5NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383539395", "bodyText": "I found something a bit more concise than what I'd had, hopefully without reducing readability.", "author": "gjuggler", "createdAt": "2020-02-24T21:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MTEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MjU0NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382792545", "bodyText": "So if I'm reading this right, we increment before the await is complete? Is that what we want? Maybe it's really more of a createAttemptCount.", "author": "jaycarlton", "createdAt": "2020-02-21T20:33:35Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0MjExOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383542119", "bodyText": "More JS async stuff.\u00a0createCount is incremented after the createCluster API call is completed.", "author": "gjuggler", "createdAt": "2020-02-24T22:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MjU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5OTU0Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384599546", "bodyText": "\ud83e\udd26\u200d\u2642 right.", "author": "jaycarlton", "createdAt": "2020-02-26T16:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MjU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MjgxOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382792819", "bodyText": "nit: seems odd that we get a Cluster back on create but not on resume.", "author": "jaycarlton", "createdAt": "2020-02-21T20:34:15Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MzM0OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382793348", "bodyText": "should this have an is prefix like the other predicates?", "author": "jaycarlton", "createdAt": "2020-02-21T20:35:41Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0MjU2NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383542564", "bodyText": "Renamed to hasTooManyServerErrors", "author": "gjuggler", "createdAt": "2020-02-24T22:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5MzM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5NjI0OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382796249", "bodyText": "So that's interesing. resolve and reject are magically piped into the promise's callback's arguments, and the output of resolve is a Cluster?", "author": "jaycarlton", "createdAt": "2020-02-21T20:42:52Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {\n+    return this.serverErrorCount > this.maxServerErrorCount;\n+  }\n+\n+  /**\n+   * Runs the cluster intiailizer flow.\n+   *\n+   * The strategy here is to poll the getCluster endpoint for cluster status, waiting for the\n+   * cluster to reach the ready state (ClusterStatus.Running) or an error state which can be\n+   * recovered from. Action will be taken where possible: a stopped cluster will trigger a call to\n+   * startCluster, a nonexistent cluster will trigger a call to createCluster, and an errored\n+   * cluster will trigger a call to deleteCluster in an attempt to retry cluster creation.\n+   *\n+   * @return A Promise which resolves with a Cluster or rejects with a\n+   * ClusterInitializationFailedError, which holds a message and the current Cluster object (if one\n+   * existed at the time of failure).\n+   */\n+  public async run(): Promise<Cluster> {\n+    if (this.isInitializing) {\n+      throw new Error('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = Date.now();\n+\n+    return new Promise((resolve, reject) => {\n+      this.resolve = resolve;\n+      this.reject = reject as (error: Error) => {};\n+      this.poll();\n+    }) as Promise<Cluster>;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0MzA1Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383543052", "bodyText": "resolve is a function which takes a Cluster as its argument. I'm doing something a little funky here to provide a Promise-based API for implementation code which uses a non-promise-based polling mechanism with setTimeout.", "author": "gjuggler", "createdAt": "2020-02-24T22:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5NjI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5NzQ3Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382797476", "bodyText": "nit: maybe indicate the max time and the elapsed time in the message.", "author": "jaycarlton", "createdAt": "2020-02-21T20:45:48Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {\n+    return this.serverErrorCount > this.maxServerErrorCount;\n+  }\n+\n+  /**\n+   * Runs the cluster intiailizer flow.\n+   *\n+   * The strategy here is to poll the getCluster endpoint for cluster status, waiting for the\n+   * cluster to reach the ready state (ClusterStatus.Running) or an error state which can be\n+   * recovered from. Action will be taken where possible: a stopped cluster will trigger a call to\n+   * startCluster, a nonexistent cluster will trigger a call to createCluster, and an errored\n+   * cluster will trigger a call to deleteCluster in an attempt to retry cluster creation.\n+   *\n+   * @return A Promise which resolves with a Cluster or rejects with a\n+   * ClusterInitializationFailedError, which holds a message and the current Cluster object (if one\n+   * existed at the time of failure).\n+   */\n+  public async run(): Promise<Cluster> {\n+    if (this.isInitializing) {\n+      throw new Error('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = Date.now();\n+\n+    return new Promise((resolve, reject) => {\n+      this.resolve = resolve;\n+      this.reject = reject as (error: Error) => {};\n+      this.poll();\n+    }) as Promise<Cluster>;\n+  }\n+\n+  private async poll() {\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    //\n+    // Certain cluster states require active intervention, such as deleting or resuming the cluster;\n+    // these are handled within the the polling loop.\n+    if (this.abortSignal && this.abortSignal.aborted) {\n+      // We'll bail out early if an abort signal was triggered while waiting for the poll cycle.\n+      return this.reject(\n+        new ClusterInitializationFailedError('Request was aborted.', this.currentCluster));\n+    }\n+    if (Date.now() - this.initializeStartTime > this.overallTimeout) {\n+      return this.reject(\n+        new ClusterInitializationFailedError(", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5NzkwOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382797909", "bodyText": "nit: breaking this chunk out into a checkTimeout method could make poll() shorter and raise its abstraction level a bit.", "author": "jaycarlton", "createdAt": "2020-02-21T20:46:51Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {\n+    return this.serverErrorCount > this.maxServerErrorCount;\n+  }\n+\n+  /**\n+   * Runs the cluster intiailizer flow.\n+   *\n+   * The strategy here is to poll the getCluster endpoint for cluster status, waiting for the\n+   * cluster to reach the ready state (ClusterStatus.Running) or an error state which can be\n+   * recovered from. Action will be taken where possible: a stopped cluster will trigger a call to\n+   * startCluster, a nonexistent cluster will trigger a call to createCluster, and an errored\n+   * cluster will trigger a call to deleteCluster in an attempt to retry cluster creation.\n+   *\n+   * @return A Promise which resolves with a Cluster or rejects with a\n+   * ClusterInitializationFailedError, which holds a message and the current Cluster object (if one\n+   * existed at the time of failure).\n+   */\n+  public async run(): Promise<Cluster> {\n+    if (this.isInitializing) {\n+      throw new Error('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = Date.now();\n+\n+    return new Promise((resolve, reject) => {\n+      this.resolve = resolve;\n+      this.reject = reject as (error: Error) => {};\n+      this.poll();\n+    }) as Promise<Cluster>;\n+  }\n+\n+  private async poll() {\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    //\n+    // Certain cluster states require active intervention, such as deleting or resuming the cluster;\n+    // these are handled within the the polling loop.\n+    if (this.abortSignal && this.abortSignal.aborted) {\n+      // We'll bail out early if an abort signal was triggered while waiting for the poll cycle.\n+      return this.reject(\n+        new ClusterInitializationFailedError('Request was aborted.', this.currentCluster));\n+    }\n+    if (Date.now() - this.initializeStartTime > this.overallTimeout) {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0NTgxNw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383545817", "bodyText": "I tried this, but it got a bit trickier than I'd like due to the control flow implications (e.g. I need to return early if the timeout was encountered, so there's always going to be some conditional in this main polling method no matter what).", "author": "gjuggler", "createdAt": "2020-02-24T22:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5NzkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5ODI0OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382798248", "bodyText": "nit: is this a void function?", "author": "jaycarlton", "createdAt": "2020-02-21T20:47:38Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {\n+    return this.serverErrorCount > this.maxServerErrorCount;\n+  }\n+\n+  /**\n+   * Runs the cluster intiailizer flow.\n+   *\n+   * The strategy here is to poll the getCluster endpoint for cluster status, waiting for the\n+   * cluster to reach the ready state (ClusterStatus.Running) or an error state which can be\n+   * recovered from. Action will be taken where possible: a stopped cluster will trigger a call to\n+   * startCluster, a nonexistent cluster will trigger a call to createCluster, and an errored\n+   * cluster will trigger a call to deleteCluster in an attempt to retry cluster creation.\n+   *\n+   * @return A Promise which resolves with a Cluster or rejects with a\n+   * ClusterInitializationFailedError, which holds a message and the current Cluster object (if one\n+   * existed at the time of failure).\n+   */\n+  public async run(): Promise<Cluster> {\n+    if (this.isInitializing) {\n+      throw new Error('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = Date.now();\n+\n+    return new Promise((resolve, reject) => {\n+      this.resolve = resolve;\n+      this.reject = reject as (error: Error) => {};\n+      this.poll();\n+    }) as Promise<Cluster>;\n+  }\n+\n+  private async poll() {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0NDMzNA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383544334", "bodyText": "Yes. I don't usually bother annotating every void function with void. IMO it doesn't add too much value, but I'm willing to be convinced otherwise.", "author": "gjuggler", "createdAt": "2020-02-24T22:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5ODI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYwMDI4Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384600283", "bodyText": "That's fine. I wrote this before I sussed out how the callbacks work, and wondered why we didn't need the result of the poll operation.", "author": "jaycarlton", "createdAt": "2020-02-26T16:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5ODI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5ODU4NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382798585", "bodyText": "Why not have getCluster() call onStatusUpdate() itself?", "author": "jaycarlton", "createdAt": "2020-02-21T20:48:29Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {\n+    return this.serverErrorCount > this.maxServerErrorCount;\n+  }\n+\n+  /**\n+   * Runs the cluster intiailizer flow.\n+   *\n+   * The strategy here is to poll the getCluster endpoint for cluster status, waiting for the\n+   * cluster to reach the ready state (ClusterStatus.Running) or an error state which can be\n+   * recovered from. Action will be taken where possible: a stopped cluster will trigger a call to\n+   * startCluster, a nonexistent cluster will trigger a call to createCluster, and an errored\n+   * cluster will trigger a call to deleteCluster in an attempt to retry cluster creation.\n+   *\n+   * @return A Promise which resolves with a Cluster or rejects with a\n+   * ClusterInitializationFailedError, which holds a message and the current Cluster object (if one\n+   * existed at the time of failure).\n+   */\n+  public async run(): Promise<Cluster> {\n+    if (this.isInitializing) {\n+      throw new Error('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = Date.now();\n+\n+    return new Promise((resolve, reject) => {\n+      this.resolve = resolve;\n+      this.reject = reject as (error: Error) => {};\n+      this.poll();\n+    }) as Promise<Cluster>;\n+  }\n+\n+  private async poll() {\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    //\n+    // Certain cluster states require active intervention, such as deleting or resuming the cluster;\n+    // these are handled within the the polling loop.\n+    if (this.abortSignal && this.abortSignal.aborted) {\n+      // We'll bail out early if an abort signal was triggered while waiting for the poll cycle.\n+      return this.reject(\n+        new ClusterInitializationFailedError('Request was aborted.', this.currentCluster));\n+    }\n+    if (Date.now() - this.initializeStartTime > this.overallTimeout) {\n+      return this.reject(\n+        new ClusterInitializationFailedError(\n+          'Initialization attempt took longer than the max time allowed.',\n+          this.currentCluster));\n+    }\n+\n+    // Fetch the current cluster status, with some graceful error handling for NOT_FOUND response\n+    // and abort signals.\n+    try {\n+      this.currentCluster = await this.getCluster();", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0NjQ5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383546497", "bodyText": "I think it's easier to follow when all of the status updates are happening in the main poll method.", "author": "gjuggler", "createdAt": "2020-02-24T22:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5ODU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5OTAzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382799039", "bodyText": "Ideally Leo would expose info on recently deleted clusters (say for 7 days) so that we don't need to guess.", "author": "jaycarlton", "createdAt": "2020-02-21T20:49:41Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {\n+    return this.serverErrorCount > this.maxServerErrorCount;\n+  }\n+\n+  /**\n+   * Runs the cluster intiailizer flow.\n+   *\n+   * The strategy here is to poll the getCluster endpoint for cluster status, waiting for the\n+   * cluster to reach the ready state (ClusterStatus.Running) or an error state which can be\n+   * recovered from. Action will be taken where possible: a stopped cluster will trigger a call to\n+   * startCluster, a nonexistent cluster will trigger a call to createCluster, and an errored\n+   * cluster will trigger a call to deleteCluster in an attempt to retry cluster creation.\n+   *\n+   * @return A Promise which resolves with a Cluster or rejects with a\n+   * ClusterInitializationFailedError, which holds a message and the current Cluster object (if one\n+   * existed at the time of failure).\n+   */\n+  public async run(): Promise<Cluster> {\n+    if (this.isInitializing) {\n+      throw new Error('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = Date.now();\n+\n+    return new Promise((resolve, reject) => {\n+      this.resolve = resolve;\n+      this.reject = reject as (error: Error) => {};\n+      this.poll();\n+    }) as Promise<Cluster>;\n+  }\n+\n+  private async poll() {\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    //\n+    // Certain cluster states require active intervention, such as deleting or resuming the cluster;\n+    // these are handled within the the polling loop.\n+    if (this.abortSignal && this.abortSignal.aborted) {\n+      // We'll bail out early if an abort signal was triggered while waiting for the poll cycle.\n+      return this.reject(\n+        new ClusterInitializationFailedError('Request was aborted.', this.currentCluster));\n+    }\n+    if (Date.now() - this.initializeStartTime > this.overallTimeout) {\n+      return this.reject(\n+        new ClusterInitializationFailedError(\n+          'Initialization attempt took longer than the max time allowed.',\n+          this.currentCluster));\n+    }\n+\n+    // Fetch the current cluster status, with some graceful error handling for NOT_FOUND response\n+    // and abort signals.\n+    try {\n+      this.currentCluster = await this.getCluster();\n+      this.onStatusUpdate(this.currentCluster.status);\n+    } catch (e) {\n+      if (isAbortError(e)) {\n+        return this.reject(\n+          new ClusterInitializationFailedError('Abort signal received during cluster API call',\n+            this.currentCluster));\n+      } else if (this.isNotFoundError(e)) {\n+        // A not-found error is somewhat expected, if a cluster has recently been deleted or", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwMTkwNg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384801906", "bodyText": "It does expose that information via getClusters?includeDeleted=true. However, whether or not it was deleted is irrelevant here. In either situation we're going to create a new cluster.", "author": "calbach", "createdAt": "2020-02-26T22:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5OTAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5OTI5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382799297", "bodyText": "nit: exposing a property for the full cluster path/fqn would be cleaner than doing it here I think.", "author": "jaycarlton", "createdAt": "2020-02-21T20:50:28Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {\n+    return this.serverErrorCount > this.maxServerErrorCount;\n+  }\n+\n+  /**\n+   * Runs the cluster intiailizer flow.\n+   *\n+   * The strategy here is to poll the getCluster endpoint for cluster status, waiting for the\n+   * cluster to reach the ready state (ClusterStatus.Running) or an error state which can be\n+   * recovered from. Action will be taken where possible: a stopped cluster will trigger a call to\n+   * startCluster, a nonexistent cluster will trigger a call to createCluster, and an errored\n+   * cluster will trigger a call to deleteCluster in an attempt to retry cluster creation.\n+   *\n+   * @return A Promise which resolves with a Cluster or rejects with a\n+   * ClusterInitializationFailedError, which holds a message and the current Cluster object (if one\n+   * existed at the time of failure).\n+   */\n+  public async run(): Promise<Cluster> {\n+    if (this.isInitializing) {\n+      throw new Error('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = Date.now();\n+\n+    return new Promise((resolve, reject) => {\n+      this.resolve = resolve;\n+      this.reject = reject as (error: Error) => {};\n+      this.poll();\n+    }) as Promise<Cluster>;\n+  }\n+\n+  private async poll() {\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    //\n+    // Certain cluster states require active intervention, such as deleting or resuming the cluster;\n+    // these are handled within the the polling loop.\n+    if (this.abortSignal && this.abortSignal.aborted) {\n+      // We'll bail out early if an abort signal was triggered while waiting for the poll cycle.\n+      return this.reject(\n+        new ClusterInitializationFailedError('Request was aborted.', this.currentCluster));\n+    }\n+    if (Date.now() - this.initializeStartTime > this.overallTimeout) {\n+      return this.reject(\n+        new ClusterInitializationFailedError(\n+          'Initialization attempt took longer than the max time allowed.',\n+          this.currentCluster));\n+    }\n+\n+    // Fetch the current cluster status, with some graceful error handling for NOT_FOUND response\n+    // and abort signals.\n+    try {\n+      this.currentCluster = await this.getCluster();\n+      this.onStatusUpdate(this.currentCluster.status);\n+    } catch (e) {\n+      if (isAbortError(e)) {\n+        return this.reject(\n+          new ClusterInitializationFailedError('Abort signal received during cluster API call',\n+            this.currentCluster));\n+      } else if (this.isNotFoundError(e)) {\n+        // A not-found error is somewhat expected, if a cluster has recently been deleted or\n+        // hasn't been created yet.\n+        this.currentCluster = null;\n+      } else {\n+        this.handleUnknownError(e);\n+        if (this.tooManyServerErrors()) {\n+          return this.reject(\n+            new ExceededErrorCountError('Reached max server error count', this.currentCluster));\n+        }\n+      }\n+    }\n+\n+    // Attempt to take the appropriate next action given the current cluster status.\n+    try {\n+      if (this.currentCluster === null) {\n+        await this.createCluster();\n+      } else if (this.isClusterStopped()) {\n+        await this.resumeCluster();\n+      } else if (this.isClusterErrored()) {\n+        // If cluster is in error state, delete it so it can be re-created at the next poll loop.\n+        reportError(\n+          `Cluster ${this.currentCluster.clusterNamespace}/${this.currentCluster.clusterName}` +", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5OTY2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382799662", "bodyText": "nit: do we already have backoff delay programmed someplace? Seems odd for it to live here.", "author": "jaycarlton", "createdAt": "2020-02-21T20:51:18Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {\n+    return this.serverErrorCount > this.maxServerErrorCount;\n+  }\n+\n+  /**\n+   * Runs the cluster intiailizer flow.\n+   *\n+   * The strategy here is to poll the getCluster endpoint for cluster status, waiting for the\n+   * cluster to reach the ready state (ClusterStatus.Running) or an error state which can be\n+   * recovered from. Action will be taken where possible: a stopped cluster will trigger a call to\n+   * startCluster, a nonexistent cluster will trigger a call to createCluster, and an errored\n+   * cluster will trigger a call to deleteCluster in an attempt to retry cluster creation.\n+   *\n+   * @return A Promise which resolves with a Cluster or rejects with a\n+   * ClusterInitializationFailedError, which holds a message and the current Cluster object (if one\n+   * existed at the time of failure).\n+   */\n+  public async run(): Promise<Cluster> {\n+    if (this.isInitializing) {\n+      throw new Error('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = Date.now();\n+\n+    return new Promise((resolve, reject) => {\n+      this.resolve = resolve;\n+      this.reject = reject as (error: Error) => {};\n+      this.poll();\n+    }) as Promise<Cluster>;\n+  }\n+\n+  private async poll() {\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    //\n+    // Certain cluster states require active intervention, such as deleting or resuming the cluster;\n+    // these are handled within the the polling loop.\n+    if (this.abortSignal && this.abortSignal.aborted) {\n+      // We'll bail out early if an abort signal was triggered while waiting for the poll cycle.\n+      return this.reject(\n+        new ClusterInitializationFailedError('Request was aborted.', this.currentCluster));\n+    }\n+    if (Date.now() - this.initializeStartTime > this.overallTimeout) {\n+      return this.reject(\n+        new ClusterInitializationFailedError(\n+          'Initialization attempt took longer than the max time allowed.',\n+          this.currentCluster));\n+    }\n+\n+    // Fetch the current cluster status, with some graceful error handling for NOT_FOUND response\n+    // and abort signals.\n+    try {\n+      this.currentCluster = await this.getCluster();\n+      this.onStatusUpdate(this.currentCluster.status);\n+    } catch (e) {\n+      if (isAbortError(e)) {\n+        return this.reject(\n+          new ClusterInitializationFailedError('Abort signal received during cluster API call',\n+            this.currentCluster));\n+      } else if (this.isNotFoundError(e)) {\n+        // A not-found error is somewhat expected, if a cluster has recently been deleted or\n+        // hasn't been created yet.\n+        this.currentCluster = null;\n+      } else {\n+        this.handleUnknownError(e);\n+        if (this.tooManyServerErrors()) {\n+          return this.reject(\n+            new ExceededErrorCountError('Reached max server error count', this.currentCluster));\n+        }\n+      }\n+    }\n+\n+    // Attempt to take the appropriate next action given the current cluster status.\n+    try {\n+      if (this.currentCluster === null) {\n+        await this.createCluster();\n+      } else if (this.isClusterStopped()) {\n+        await this.resumeCluster();\n+      } else if (this.isClusterErrored()) {\n+        // If cluster is in error state, delete it so it can be re-created at the next poll loop.\n+        reportError(\n+          `Cluster ${this.currentCluster.clusterNamespace}/${this.currentCluster.clusterName}` +\n+          ` has reached an ERROR status.`);\n+        await this.deleteCluster();\n+      } else if (this.isClusterRunning()) {\n+        // We've reached the goal - resolve the Promise.\n+        return this.resolve(this.currentCluster);\n+      }\n+    } catch (e) {\n+      if (isAbortError(e)) {\n+        return this.reject(\n+          new ClusterInitializationFailedError('Abort signal received during cluster API call',\n+          this.currentCluster));\n+      } else if (e instanceof ExceededActionCountError) {\n+        // This is a signal that we should hard-abort the polling loop due to reaching the max\n+        // number of delete or create actions allowed.\n+        return this.reject(e);\n+      } else {\n+        this.handleUnknownError(e);\n+        if (this.tooManyServerErrors()) {\n+          return this.reject(\n+            new ExceededErrorCountError('Reached max server error count', this.currentCluster));\n+        }\n+      }\n+    }\n+\n+    setTimeout(() => this.poll(), this.currentDelay);", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0ODEyOA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383548128", "bodyText": "We have some stuff over here http://github.com/all-of-us/workbench/blob/67ab8fb211b1b76440cff340343c7a107903a87b/ui/src/app/utils/retry.tsx#L69-L69 but nothing which fit this use case. Trying to generalize this would have caused more maintenance overhead than inlining the two lines to increment exponential decay.", "author": "gjuggler", "createdAt": "2020-02-24T22:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5OTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYwMzAyNw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384603027", "bodyText": "OK, but there's also a lot of maintenance overhead if we have multiple, slightly inconsistent ways of doing basic things like retrying.", "author": "jaycarlton", "createdAt": "2020-02-26T16:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc5OTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgwMDAyNg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382800026", "bodyText": "nit: fwiw I think the parentheses help here.", "author": "jaycarlton", "createdAt": "2020-02-21T20:52:10Z", "path": "ui/src/app/utils/errors.tsx", "diffHunk": "@@ -29,7 +29,7 @@ export function reportError(err: Error) {\n \n /** Returns true if the given error is an AbortError, as used in fetch() aborts. */\n export function isAbortError(e: Error) {\n-  return (e instanceof DOMException) && e.name === 'AbortError';\n+  return e instanceof DOMException && e.name === 'AbortError';", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2NTM0NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382765344", "bodyText": "nit: looking at this interface, I'm wondering whether it is worth exposing this class at all. Seems like a static helper like initializeCluster({ ... }); might restrict the API surface a bit more clearly, since the current API is basically: create instance, call run() exactly once.", "author": "calbach", "createdAt": "2020-02-21T19:30:27Z", "path": "ui/src/app/pages/analysis/interactive-notebook.tsx", "diffHunk": "@@ -170,35 +169,14 @@ export const InteractiveNotebook = fp.flow(withUrlParams(), withCurrentWorkspace\n       this.aborter.abort();\n     }\n \n-    private runCluster(onClusterReady: Function): void {\n-      const retry = () => {\n-        this.runClusterTimer = setTimeout(() => this.runCluster(onClusterReady), 5000);\n-      };\n-\n-      clusterApi().listClusters(this.props.urlParams.ns, this.props.urlParams.wsid, {\n-        signal: this.aborter.signal\n-      }).then((body) => {\n-          const cluster = body.defaultCluster;\n-          this.setState({clusterStatus: cluster.status});\n-\n-          if (cluster.status === ClusterStatus.Stopped) {\n-            notebooksClusterApi()\n-              .startCluster(cluster.clusterNamespace, cluster.clusterName);\n-          }\n-\n-          if (cluster.status === ClusterStatus.Running) {\n-            onClusterReady();\n-          } else {\n-            retry();\n-          }\n-        })\n-        .catch((e: Error) => {\n-          if (isAbortError(e)) {\n-            return;\n-          }\n-          // TODO(RW-3097): Backoff, or don't retry forever.\n-          retry();\n-        });\n+    private async runCluster(onClusterReady: Function): Promise<void> {\n+      const initializer = new ClusterInitializer({", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0NDE5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383344197", "bodyText": "Sure, I can take a stab at that. I ended up modeling this as a static method on ClusterInitializer rather than a separately-exported function. LMK if you feel it looks out of place and we should really only export a wrapper function.", "author": "gjuggler", "createdAt": "2020-02-24T15:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2NTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2NzI3Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382767273", "bodyText": "Why do we need to hold this reference?", "author": "calbach", "createdAt": "2020-02-21T19:34:42Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3MDE3OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382770179", "bodyText": "opt: this may be a more direct way of checking: \n  \n    \n      workbench/ui/src/app/utils/errors.tsx\n    \n    \n         Line 31\n      in\n      f1d264a\n    \n    \n    \n    \n\n        \n          \n           export function isAbortError(e: Error) {", "author": "calbach", "createdAt": "2020-02-21T19:41:10Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;\n \n   constructor(props) {\n     super(props);\n \n     this.state = {\n-      cluster: null,\n+      clusterStatus: null,\n+      isPollingCluster: true,\n       resetClusterPending: false,\n       resetClusterModal: false,\n-      clusterDeletionFailure: true,\n+      resetClusterFailure: true,\n     };\n   }\n \n   componentDidMount() {\n-    this.pollCluster(this.props.billingProjectId);\n+    this.createClusterInitializer(false);\n+  }\n+\n+  async createClusterInitializer(allowClusterActions: boolean) {\n+    const maxActionCount = allowClusterActions ? 1 : 0;\n+\n+    // Kick off an initializer which will poll for cluster status.\n+    this.initializer = new ClusterInitializer({\n+      workspaceNamespace: this.props.workspaceNamespace,\n+      onStatusUpdate: (clusterStatus: ClusterStatus) => {\n+        if (this.aborter.signal.aborted) {\n+          // IF we've been unmounted, don't try to update state.\n+          return;\n+        }\n+        this.setState({\n+          clusterStatus: clusterStatus,\n+        });\n+      },\n+      abortSignal: this.aborter.signal,\n+      // For the reset button, we never want to affect the cluster state. With the maxFooCount set\n+      // to zero, the initializer will reject the promise when it reaches a non-transitional state.\n+      maxDeleteCount: maxActionCount,\n+      maxCreateCount: maxActionCount,\n+      maxResumeCount: maxActionCount,\n+    });\n+\n+    try {\n+      this.setState({isPollingCluster: true, clusterStatus: null});\n+      await this.initializer.run();\n+      this.setState({isPollingCluster: false});\n+    } catch (e) {\n+      if (this.aborter.signal.aborted) {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM1MjM0NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383352344", "bodyText": "I think I'd originally had that, but the awkward thing here is that the ClusterInitializer captures its own AbortError and throws a more generic initialization failure error (\n  \n    \n      workbench/ui/src/app/utils/cluster-initializer.tsx\n    \n    \n         Line 246\n      in\n      67ab8fb\n    \n    \n    \n    \n\n        \n          \n           if (isAbortError(e)) { \n        \n    \n  \n\n).\nI'll attempt to clarify this by doubling-down on the error subclassing approach, with a more specific \"abort error\" thrown from the initializer.", "author": "gjuggler", "createdAt": "2020-02-24T15:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3MDE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MzA5NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382863094", "bodyText": "I think this language is slightly misleading, I would suggest:\n\"You do not currently have an active notebook server for this workspace.\"", "author": "calbach", "createdAt": "2020-02-22T00:19:50Z", "path": "ui/src/app/pages/analysis/reset-cluster-button.tsx", "diffHunk": "@@ -26,55 +19,128 @@ const styles = {\n };\n \n export interface Props {\n-  billingProjectId: string;\n-  workspaceFirecloudName: string;\n+  workspaceNamespace: string;\n }\n \n interface State {\n-  cluster: Cluster;\n+  clusterStatus?: ClusterStatus;\n+  isPollingCluster: boolean;\n   resetClusterPending: boolean;\n   resetClusterModal: boolean;\n-  clusterDeletionFailure: boolean;\n+  resetClusterFailure: boolean;\n }\n \n export class ResetClusterButton extends React.Component<Props, State> {\n-\n-  private pollClusterTimer: NodeJS.Timer;\n+  private aborter = new AbortController();\n+  private initializer?: ClusterInitializer;\n \n   constructor(props) {\n     super(props);\n \n     this.state = {\n-      cluster: null,\n+      clusterStatus: null,\n+      isPollingCluster: true,\n       resetClusterPending: false,\n       resetClusterModal: false,\n-      clusterDeletionFailure: true,\n+      resetClusterFailure: true,\n     };\n   }\n \n   componentDidMount() {\n-    this.pollCluster(this.props.billingProjectId);\n+    this.createClusterInitializer(false);\n+  }\n+\n+  async createClusterInitializer(allowClusterActions: boolean) {\n+    const maxActionCount = allowClusterActions ? 1 : 0;\n+\n+    // Kick off an initializer which will poll for cluster status.\n+    this.initializer = new ClusterInitializer({\n+      workspaceNamespace: this.props.workspaceNamespace,\n+      onStatusUpdate: (clusterStatus: ClusterStatus) => {\n+        if (this.aborter.signal.aborted) {\n+          // IF we've been unmounted, don't try to update state.\n+          return;\n+        }\n+        this.setState({\n+          clusterStatus: clusterStatus,\n+        });\n+      },\n+      abortSignal: this.aborter.signal,\n+      // For the reset button, we never want to affect the cluster state. With the maxFooCount set\n+      // to zero, the initializer will reject the promise when it reaches a non-transitional state.\n+      maxDeleteCount: maxActionCount,\n+      maxCreateCount: maxActionCount,\n+      maxResumeCount: maxActionCount,\n+    });\n+\n+    try {\n+      this.setState({isPollingCluster: true, clusterStatus: null});\n+      await this.initializer.run();\n+      this.setState({isPollingCluster: false});\n+    } catch (e) {\n+      if (this.aborter.signal.aborted) {\n+        return;\n+      }\n+      if (e instanceof ClusterInitializationFailedError) {\n+        this.setState({clusterStatus: e.cluster ? e.cluster.status : null});\n+      }\n+      this.setState({\n+        isPollingCluster: false\n+      });\n+    }\n   }\n \n   componentWillUnmount() {\n-    if (this.pollClusterTimer) {\n-      clearTimeout(this.pollClusterTimer);\n+    this.aborter.abort();\n+  }\n+\n+  private createTooltip(content: React.ReactFragment, children: React.ReactFragment): React.ReactFragment {\n+    return <TooltipTrigger content={content} side='right'>\n+      {children}\n+    </TooltipTrigger>;\n+  }\n+\n+  private createButton(label: string, enabled: boolean, callback: () => void): React.ReactFragment {\n+    return <Button disabled={!enabled}\n+                 onClick={callback}\n+                 data-test-id='reset-notebook-button'\n+                 type='secondary'>\n+    {label}\n+    </Button>;\n+  }\n+\n+  createButtonAndLabel(): (React.ReactFragment) {\n+    if (this.state.isPollingCluster) {\n+      const tooltipContent = <div>\n+        Your notebook server is still being provisioned. <br/>\n+        (detailed status: {this.state.clusterStatus})\n+      </div>;\n+      return this.createTooltip(\n+        tooltipContent,\n+        this.createButton(RESTART_LABEL, false, null));\n+    } else if (this.state.clusterStatus === null) {\n+      // If the initializer has completed and the status is null, it means that\n+      // a cluster doesn't exist for this workspace.\n+      return this.createTooltip(\n+        'You have not yet created a notebook server for this workspace.',", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQxODE3Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383418176", "bodyText": "Good point \u2013 done. (I assume this is mostly because we leave no clusters behind when we run the periodic reset-everything cron.)", "author": "gjuggler", "createdAt": "2020-02-24T17:51:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2Mzg0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382863842", "bodyText": "uncomment?", "author": "calbach", "createdAt": "2020-02-22T00:24:05Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NjEwOQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382866109", "bodyText": "This seems like a really busy wait. Lets say the promise never completes - does Jest terminate the test case at some point?", "author": "calbach", "createdAt": "2020-02-22T00:37:52Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NjY2OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383446669", "bodyText": "Jest will usually kill a test after 5 seconds, but your comment motivated me to kick the tires a bit, and I was able to create some nasty scenarios where the infinite loop wouldn't terminate. So I added some extra paranoia here with a default max # of iterations.", "author": "gjuggler", "createdAt": "2020-02-24T18:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NjEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NjQ5Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382866496", "bodyText": "opt: Putting this logic into a fake service might be ideal (e.g. in memory clientside fake which transitions to the expected state after a call to start()), but there's definitely a lot of complexity here w.r.t. the asynchronous nature of the state transitions. What you have is probably reasonable.", "author": "calbach", "createdAt": "2020-02-22T00:40:39Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3NDcwNw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383474707", "bodyText": "Yeah, My gut feeling was that this is much more thorough testing than we used to have, and much less effort than building a proper fake :)", "author": "gjuggler", "createdAt": "2020-02-24T19:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NjQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NjgxNw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382866817", "bodyText": "opt nit: I would probably not use mocks unless required. In this case you could just push to an array from the callback and compare the results.", "author": "calbach", "createdAt": "2020-02-22T00:42:45Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3Njc5Ng==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383476796", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T19:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2Njg5NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382866895", "bodyText": "nit: seems redundant with the next line (you'd probably also prefer to see the error report from the next line, rather than this one)", "author": "calbach", "createdAt": "2020-02-22T00:43:11Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NzIxMA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382867210", "bodyText": "nit: Should -> should here and below", "author": "calbach", "createdAt": "2020-02-22T00:45:03Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3NzY4OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383477688", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T19:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NzUxOA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382867518", "bodyText": "Hmm.. I'm not following - why not just await here?", "author": "calbach", "createdAt": "2020-02-22T00:46:53Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const mockFn = jest.fn();\n+    const initializer = createInitializer({\n+      onStatusUpdate: mockFn\n+    });\n+\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockFn.mock.calls.length).toEqual(3);\n+    expect(mockFn.mock.calls).toEqual([\n+      [ClusterStatus.Stopped],\n+      [ClusterStatus.Starting],\n+      [ClusterStatus.Running]]\n+    );\n+  });\n+\n+  it('should create cluster if it is initially nonexistent', async() => {\n+    mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should delete cluster if in an error state', async() => {\n+    // A cluster in an error state should trigger a deletion request.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Error},\n+    ]);\n+    mockDeleteCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {};\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+      {...baseCluster, status: ClusterStatus.Deleting},\n+    ]);\n+    // After some period of \"deleting\" status, we expect the cluster to become nonexistent...\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 404});\n+    });\n+    // which should trigger a creation request...\n+    mockCreateCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      return {...baseCluster, status: ClusterStatus.Creating};\n+    });\n+    // and eventually give us a good cluster.\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(mockDeleteCluster).toHaveBeenCalled();\n+    expect(mockCreateCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should recover from intermittent 500s', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+      throw new Response(null, {status: 503});\n+    });\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Running},\n+    ]);\n+\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('Should give up after too many server errors', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Creating},\n+    ]);\n+    for (let i = 0; i < 10; i++) {\n+      mockGetCluster.mockImplementationOnce(async(workspaceNamespace) => {\n+        throw new Response(null, {status: 503});\n+      });\n+    }\n+\n+    const initializer = createInitializer();\n+\n+    expect.assertions(1);\n+    return runInitializerAndTimers(initializer).catch(error => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4NjkxMw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383486913", "bodyText": "Yeah \u2013 a try / catch works just as well here and is probably more clear. I updated here and below.", "author": "gjuggler", "createdAt": "2020-02-24T20:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NzczMA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382867730", "bodyText": "It would be good if one of these test cases had repeated Starting/Stopping/Creating entries. Seeing a status update on each check is unlikely to ever happen", "author": "calbach", "createdAt": "2020-02-22T00:48:36Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      // Here is where we expect, chronologically, a call to startCluster. The next two\n+      // cluster statuses mock out what we might expect to see after that call.\n+      {...baseCluster, status: ClusterStatus.Starting},\n+      {...baseCluster, status: ClusterStatus.Running}\n+    ]);\n+    const initializer = createInitializer();\n+    const cluster = await runInitializerAndTimers(initializer);\n+    expect(mockStartCluster).toHaveBeenCalled();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should call callback with cluster status', async() => {\n+    mockGetClusterCalls([\n+      {...baseCluster, status: ClusterStatus.Stopped},\n+      {...baseCluster, status: ClusterStatus.Starting},", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3NjI5OQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383476299", "bodyText": "Good point, I sprinkled this into this case and the prior one.", "author": "gjuggler", "createdAt": "2020-02-24T19:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2NzczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2Nzg1MA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382867850", "bodyText": "May be worth covering Stopping here, or in addition to this case", "author": "calbach", "createdAt": "2020-02-22T00:49:31Z", "path": "ui/src/app/utils/cluster-initializer.spec.tsx", "diffHunk": "@@ -0,0 +1,305 @@\n+import * as React from 'react';\n+\n+import {notebooksClusterApi, registerApiClient as registerApiClientNotebooks} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi, registerApiClient} from 'app/services/swagger-fetch-clients';\n+import {ClusterInitializer} from 'app/utils/cluster-initializer';\n+import {ClusterInitializerOptions} from 'app/utils/cluster-initializer';\n+import {Cluster} from 'generated/fetch';\n+import {ClusterStatus} from 'generated/fetch';\n+import {ClusterApi} from 'generated/fetch/api';\n+import SpyInstance = jest.SpyInstance;\n+import expect = jest.Expect;\n+import {ClusterApi as NotebooksClusterApi} from 'notebooks-generated/fetch';\n+import {ClusterApiStub} from 'testing/stubs/cluster-api-stub';\n+import {NotebooksClusterApiStub} from 'testing/stubs/notebooks-cluster-api-stub';\n+\n+let mockGetCluster: SpyInstance;\n+let mockCreateCluster: SpyInstance;\n+let mockDeleteCluster: SpyInstance;\n+let mockStartCluster: SpyInstance;\n+\n+const baseCluster: Cluster = {\n+  clusterName: 'aou-rw-3',\n+  clusterNamespace: 'aou-rw-12345',\n+  status: ClusterStatus.Running\n+};\n+\n+describe('ClusterInitializer', () => {\n+\n+  beforeEach(() => {\n+    jest.useFakeTimers();\n+\n+    registerApiClient(ClusterApi, new ClusterApiStub());\n+    registerApiClientNotebooks(NotebooksClusterApi, new NotebooksClusterApiStub());\n+\n+    mockGetCluster = jest.spyOn(clusterApi(), 'getCluster');\n+    mockCreateCluster = jest.spyOn(clusterApi(), 'createCluster');\n+    mockDeleteCluster = jest.spyOn(clusterApi(), 'deleteCluster');\n+    mockStartCluster = jest.spyOn(notebooksClusterApi(), 'startCluster');\n+  });\n+\n+  afterEach(() => {\n+    jest.useRealTimers();\n+    jest.clearAllMocks();\n+  });\n+\n+  const mockGetClusterCalls = (responses: Array<Cluster>) => {\n+    for (const response of responses) {\n+      mockGetCluster.mockImplementationOnce((workspaceNamespace) => {\n+        return response;\n+      });\n+    }\n+  };\n+\n+  const createInitializer = (options?: Partial<ClusterInitializerOptions>): ClusterInitializer => {\n+    return new ClusterInitializer({\n+      workspaceNamespace: 'aou-rw-12345',\n+      ...options,\n+    });\n+  };\n+\n+  const runTimersUntilSettled = async(p: Promise<any>) => {\n+    let isSettled = false;\n+    p.then(() => isSettled = true).catch((e) => {\n+      isSettled = true;\n+      // Re-throw the error.\n+      // throw e;\n+    });\n+    while (!isSettled) {\n+      await new Promise(setImmediate);\n+      jest.runAllTimers();\n+    }\n+  };\n+\n+  const runInitializerAndTimers = async(initializer: ClusterInitializer): Promise<Cluster> => {\n+    const clusterPromise = initializer.run();\n+    await runTimersUntilSettled(clusterPromise);\n+    return await clusterPromise;\n+  };\n+\n+  it('should resolve promise if cluster is in ready state', async() => {\n+    // This tests the simplest case of the initializer. No polling necessary.\n+    mockGetClusterCalls([baseCluster]);\n+    const initializer = createInitializer();\n+    const cluster = await initializer.run();\n+    expect(cluster.status).toEqual(ClusterStatus.Running);\n+  });\n+\n+  it('should resume cluster if it is initially stopped', async() => {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ3NDE1OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383474158", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T19:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2Nzg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2ODA4Mw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382868083", "bodyText": "The X_COUNT consts are not related to transient 500s", "author": "calbach", "createdAt": "2020-02-22T00:51:17Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MDY3OA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383490678", "bodyText": "Whoops \u2013\u00a0fixed.", "author": "gjuggler", "createdAt": "2020-02-24T20:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2ODA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2ODIxMg==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382868212", "bodyText": "Why?", "author": "calbach", "createdAt": "2020-02-22T00:52:12Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MjAyMw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383492023", "bodyText": "Oops \u2013 at some point I'd had a pointer to the annoying Typescript bug that makes this necessary (and caused me quite some consternation while testing). Added it back in.", "author": "gjuggler", "createdAt": "2020-02-24T20:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2ODIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2ODg3NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382868874", "bodyText": "In Typescript you can just do constructor(private readonly cluster?: Cluster) and remove the rest of the instance property boilerplate", "author": "calbach", "createdAt": "2020-02-22T00:56:35Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5Mzk1Nw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383493957", "bodyText": "Done.", "author": "gjuggler", "createdAt": "2020-02-24T20:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2ODg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MDM4MA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382870380", "bodyText": "I'm not sure I agree with this statement. We've conceptually merged several Leo concepts into one within the AoU product, primarily on account of product decisions to avoid exposing the inner workings of the cluster state. This creates some impedance mismatches which generates complexity here. For example, we don't really expose the fact that a cluster can become paused, or that it can become deleted. If we decided to surface these things (as Terra UI probably does), it would create less business logic here.\n\nPolling cannot be removed, unless cluster creation is redesigned and made instantaneous somehow. Even if we pushed the maximum amount of logic into Leo, the operation is fundamentally asynchronous.\nLogic around when to create/start/stop a cluster at the request of a user needs to live at the product level.\n\"recreate this cluster\" could potentially be a Leo operation, but since we customize Leo clusters anyways, we probably want a hand in recreating clusters anyways.\n\nThe other avenue we could explore would be to say that Leo should not have an error state, but ultimately some cluster creations will fail regardless of how many retries Leo adds. So I do think a product-level cluster error state is still a necessity.", "author": "calbach", "createdAt": "2020-02-22T01:08:02Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUzMTQ1MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383531451", "bodyText": "Good points all around \u2014 but I still feel that if Leo had an async API which was effectively \"Create or reuse a cluster with config X, for project Y and user Z, and get it to a running state\", it would be heavily used by both Terra and AoU, since to both of these UIs it's effectively a means to an end (which is to have a Jupyter notebook running in my browser).", "author": "gjuggler", "createdAt": "2020-02-24T21:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MDM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5ODY0NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384598645", "bodyText": "Yeah, the less we know about the underlying clusters the better. We shouldn't know whether we have a new or existing cluster ideally (provided we can supply config).", "author": "jaycarlton", "createdAt": "2020-02-26T16:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MDM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MDcyOA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382870728", "bodyText": "5 seems reasonable for consecutive errors, but might be a bit low for global error count during the polling cycle. May want to make this distinction.", "author": "calbach", "createdAt": "2020-02-22T01:10:35Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MTQ3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383491471", "bodyText": "I'm wary of adding too much more complexity without letting this settle in for awhile. Okay if I bump to 10 and call it a day?", "author": "gjuggler", "createdAt": "2020-02-24T20:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MDcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MDkzMw==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382870933", "bodyText": "opt nit: probably wouldn't put trailing punctuation in my error messages, though I don't know we have any real conventions/guidelines on this.", "author": "calbach", "createdAt": "2020-02-22T01:12:09Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;\n+  // The latest cluster retrieved from getCluster. If the last getCluster call returned a NOT_FOUND\n+  // response, this will be null.\n+  private currentCluster?: Cluster;\n+\n+  // Properties to control the initialization and promise resolution flow.\n+  //\n+  // Tracks whether the .run() method has been called yet on this class. Each instance is only\n+  // allowed to be used for one initialization flow.\n+  private isInitializing = false;\n+  // The resolve and reject function from the promise returned from the call to .run(). We use a\n+  // deferred-style approach in this class, which allows us to provide a Promise-based API on the\n+  // .run() method, but to call the resolve() or reject() method from anywhere in this class.\n+  private resolve: (cluster?: Cluster | PromiseLike<Cluster>) => void;\n+  private reject: (error: Error) => void;\n+\n+  constructor(options: ClusterInitializerOptions) {\n+    this.workspaceNamespace = options.workspaceNamespace;\n+    this.onStatusUpdate = options.onStatusUpdate ? options.onStatusUpdate : () => {};\n+    this.abortSignal = options.abortSignal;\n+    this.currentDelay = options.initialPollingDelay != null ? options.initialPollingDelay : DEFAULT_INITIAL_POLLING_DELAY;\n+    this.maxDelay = options.maxPollingDelay != null ? options.maxPollingDelay : DEFAULT_MAX_POLLING_DELAY;\n+    this.overallTimeout = options.overallTimeout != null ? options.overallTimeout : DEFAULT_OVERALL_TIMEOUT;\n+    this.maxCreateCount = options.maxCreateCount != null ? options.maxCreateCount : DEFAULT_MAX_CREATE_COUNT;\n+    this.maxDeleteCount = options.maxDeleteCount != null ? options.maxDeleteCount : DEFAULT_MAX_DELETE_COUNT;\n+    this.maxResumeCount = options.maxResumeCount != null ? options.maxResumeCount : DEFAULT_MAX_RESUME_COUNT;\n+    this.maxServerErrorCount = options.maxServerErrorCount != null ? options.maxServerErrorCount : DEFAULT_MAX_SERVER_ERROR_COUNT;\n+  }\n+\n+  private async getCluster(): Promise<Cluster> {\n+    return await clusterApi().getCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+  }\n+\n+  private async createCluster(): Promise<Cluster> {\n+    if (this.createCount >= this.maxCreateCount) {\n+      throw new ExceededActionCountError('Reached max cluster create count', this.currentCluster);\n+    }\n+    const cluster = await clusterApi().createCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.createCount++;\n+    return cluster;\n+  }\n+\n+  private async resumeCluster(): Promise<void> {\n+    if (this.resumeCount >= this.maxResumeCount) {\n+      throw new ExceededActionCountError('Reached max cluster resume count', this.currentCluster);\n+    }\n+    await notebooksClusterApi().startCluster(\n+      this.currentCluster.clusterNamespace, this.currentCluster.clusterName, {signal: this.abortSignal});\n+    this.resumeCount++;\n+  }\n+\n+  private async deleteCluster(): Promise<void> {\n+    if (this.deleteCount >= this.maxDeleteCount) {\n+      throw new ExceededActionCountError('Reached max cluster delete count', this.currentCluster);\n+    }\n+    await clusterApi().deleteCluster(this.workspaceNamespace, {signal: this.abortSignal});\n+    this.deleteCount++;\n+  }\n+\n+  private isClusterRunning(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Running;\n+  }\n+\n+  private isClusterStopped(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Stopped;\n+  }\n+\n+  private isClusterErrored(): boolean {\n+    return this.currentCluster && this.currentCluster.status === ClusterStatus.Error;\n+  }\n+\n+  private isNotFoundError(e: any): boolean {\n+    // Our Swagger-generated APIs throw an error of type Response on a non-success status code.\n+    return e instanceof Response && e.status === 404;\n+  }\n+\n+  private handleUnknownError(e: any) {\n+    if (e instanceof Response && e.status >= 500 && e.status < 600) {\n+      this.serverErrorCount++;\n+    }\n+    reportError(e);\n+  }\n+\n+  private tooManyServerErrors(): boolean {\n+    return this.serverErrorCount > this.maxServerErrorCount;\n+  }\n+\n+  /**\n+   * Runs the cluster intiailizer flow.\n+   *\n+   * The strategy here is to poll the getCluster endpoint for cluster status, waiting for the\n+   * cluster to reach the ready state (ClusterStatus.Running) or an error state which can be\n+   * recovered from. Action will be taken where possible: a stopped cluster will trigger a call to\n+   * startCluster, a nonexistent cluster will trigger a call to createCluster, and an errored\n+   * cluster will trigger a call to deleteCluster in an attempt to retry cluster creation.\n+   *\n+   * @return A Promise which resolves with a Cluster or rejects with a\n+   * ClusterInitializationFailedError, which holds a message and the current Cluster object (if one\n+   * existed at the time of failure).\n+   */\n+  public async run(): Promise<Cluster> {\n+    if (this.isInitializing) {\n+      throw new Error('Initialization is already in progress');\n+    }\n+    this.initializeStartTime = Date.now();\n+\n+    return new Promise((resolve, reject) => {\n+      this.resolve = resolve;\n+      this.reject = reject as (error: Error) => {};\n+      this.poll();\n+    }) as Promise<Cluster>;\n+  }\n+\n+  private async poll() {\n+    // Overall strategy: continue polling the get-cluster endpoint, with capped exponential backoff,\n+    // until we either reach our goal state (a RUNNING cluster) or run up against the overall\n+    // timeout threshold.\n+    //\n+    // Certain cluster states require active intervention, such as deleting or resuming the cluster;\n+    // these are handled within the the polling loop.\n+    if (this.abortSignal && this.abortSignal.aborted) {\n+      // We'll bail out early if an abort signal was triggered while waiting for the poll cycle.\n+      return this.reject(\n+        new ClusterInitializationFailedError('Request was aborted.', this.currentCluster));", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0NDQ3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r383544475", "bodyText": "Ack \u2013\u00a0done.", "author": "gjuggler", "createdAt": "2020-02-24T22:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MDkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3MTgzNA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r382871834", "bodyText": "Per my other comment - some of these properties could be made final or eliminated if we just had a single entrypoint for initializing the cluster (rather than the two phase create object-> run once)", "author": "calbach", "createdAt": "2020-02-22T01:20:33Z", "path": "ui/src/app/utils/cluster-initializer.tsx", "diffHunk": "@@ -0,0 +1,301 @@\n+import {notebooksClusterApi} from 'app/services/notebooks-swagger-fetch-clients';\n+import {clusterApi} from 'app/services/swagger-fetch-clients';\n+import {isAbortError, reportError} from 'app/utils/errors';\n+import {Cluster, ClusterStatus} from 'generated/fetch';\n+\n+// We're only willing to wait 20 minutes total for a cluster to initialize. After that we return\n+// a rejected promise no matter what.\n+const DEFAULT_OVERALL_TIMEOUT = 1000 * 60 * 20;\n+const DEFAULT_INITIAL_POLLING_DELAY = 2000;\n+const DEFAULT_MAX_POLLING_DELAY = 15000;\n+// By default, we're willing to retry twice on each of the state-modifying API calls, to allow\n+// for transient 500s.\n+const DEFAULT_MAX_CREATE_COUNT = 2;\n+const DEFAULT_MAX_DELETE_COUNT = 2;\n+const DEFAULT_MAX_RESUME_COUNT = 2;\n+const DEFAULT_MAX_SERVER_ERROR_COUNT = 5;\n+\n+export class ClusterInitializationFailedError extends Error {\n+  public readonly cluster: Cluster;\n+\n+  constructor(message: string, cluster?: Cluster) {\n+    super(message);\n+    Object.setPrototypeOf(this, ClusterInitializationFailedError.prototype);\n+\n+    this.name = 'ClusterInitializationFailedError';\n+    this.cluster = cluster;\n+  }\n+}\n+\n+export class ExceededActionCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededActionCountError.prototype);\n+\n+    this.name = 'ExceededActionCountError';\n+  }\n+}\n+\n+export class ExceededErrorCountError extends ClusterInitializationFailedError {\n+  constructor(message, cluster?: Cluster) {\n+    super(message, cluster);\n+    Object.setPrototypeOf(this, ExceededErrorCountError.prototype);\n+\n+    this.name = 'ExceededErrorCountError';\n+  }\n+}\n+\n+export interface ClusterInitializerOptions {\n+  // Core options. Most callers should provide these.\n+  //\n+  // The workspace namespace to initialize a cluster for.\n+  workspaceNamespace: string;\n+  // Callback which is called every time the cluster updates its status. This callback is *not*\n+  // called when no cluster is found.\n+  onStatusUpdate?: (ClusterStatus) => void;\n+  // An optional abort signal which allows the caller to abort the initialization process, including\n+  // cancelling any outstanding Ajax requests.\n+  abortSignal?: AbortSignal;\n+\n+  // Override options. These options all have sensible defaults, but may be overridden for testing\n+  // or special scenarios (such as an initialization flow which should not take any actions).\n+  initialPollingDelay?: number;\n+  maxPollingDelay?: number;\n+  overallTimeout?: number;\n+  maxCreateCount?: number;\n+  maxDeleteCount?: number;\n+  maxResumeCount?: number;\n+  maxServerErrorCount?: number;\n+}\n+\n+/**\n+ * A controller class implementing client-side logic to initialize a Leonardo cluster. This class\n+ * will continue to poll the getCluster endpoint, taking certain actions as required to nudge the\n+ * cluster towards a running state, and will eventually resolve the Promise with a running cluster,\n+ * or otherwise reject it with information about the failure mode.\n+ *\n+ * This is an unusually heavyweight controller class on the client side. It's worth noting a couple\n+ * reasons why we ended up with this design:\n+ *  - Cluster initialization can take up to 10 minutes, which is beyond the scope of a single\n+ *    App Engine server-side request timeout. To reliably implement this control on the server side\n+ *    would likely require new database persistence, tasks queues, and additional APIs in order to\n+ *    provide the client with status updates.\n+ *  - Ultimately, we might expect this type of functionality (\"Get me a cluster for workspace X and\n+ *    bring it to a running state\") to exist as part of the Leonardo application. So rather than\n+ *    build our own server-side equivalent, we adopted a client-side solution as a holdover.\n+ */\n+export class ClusterInitializer {\n+  // Core properties for interacting with the caller and the cluster APIs.\n+  private workspaceNamespace: string;\n+  private onStatusUpdate: (ClusterStatus) => void;\n+  private abortSignal?: AbortSignal;\n+\n+  // Properties to track & control the polling loop. We use a capped exponential backoff strategy\n+  // and a series of \"maxFoo\" limits to ensure the initialization flow doesn't get out of control.\n+  private currentDelay: number;\n+  private maxDelay: number;\n+  private overallTimeout: number;\n+  private maxCreateCount: number;\n+  private maxDeleteCount: number;\n+  private maxResumeCount: number;\n+  private maxServerErrorCount: number;\n+\n+  // Properties to track progress, actions taken, and errors encountered.\n+  private createCount = 0;\n+  private deleteCount = 0;\n+  private resumeCount = 0;\n+  private serverErrorCount = 0;\n+  private initializeStartTime?: number;", "originalCommit": "67ab8fb211b1b76440cff340343c7a107903a87b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "103042c8e06f54110dedea5a6bfcdf00a9581244", "url": "https://github.com/all-of-us/workbench/commit/103042c8e06f54110dedea5a6bfcdf00a9581244", "message": "Spotless formatting and test fix.", "committedDate": "2020-02-25T00:54:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4OTIyMQ==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r384689221", "bodyText": "nit: Ignore if this has already been discussed to death elsewhere, but not a big fan of this static import. In general I don't love them outside of tests and in this case it's not saving much space below", "author": "calbach", "createdAt": "2020-02-26T18:44:07Z", "path": "api/src/main/java/org/pmiops/workbench/notebooks/LeonardoNotebooksClientImpl.java", "diffHunk": "@@ -1,5 +1,7 @@\n package org.pmiops.workbench.notebooks;\n \n+import static org.pmiops.workbench.exceptions.ExceptionUtils.convertNotebookException;", "originalCommit": "14fa860ca82691244feed76bd673637fde97f834", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MDY3NA==", "url": "https://github.com/all-of-us/workbench/pull/3135#discussion_r385350674", "bodyText": "Hah \u2013\u00a0I'm a blind slave to IntelliJ, and they put the \"import static...\" option above the \"quality usage of...\" so I chose the first one. Fixed!", "author": "gjuggler", "createdAt": "2020-02-27T20:21:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4OTIyMQ=="}], "type": "inlineReview"}, {"oid": "6a26dd3385a17a0789b2a5787619730d24a46b3b", "url": "https://github.com/all-of-us/workbench/commit/6a26dd3385a17a0789b2a5787619730d24a46b3b", "message": "Work in progress on API refactor and unified client-side polling / init flow.", "committedDate": "2020-02-27T21:42:15Z", "type": "commit"}, {"oid": "2bf95e8e8167997a64b03013de5a05e7a2fec55b", "url": "https://github.com/all-of-us/workbench/commit/2bf95e8e8167997a64b03013de5a05e7a2fec55b", "message": "WIP fleshing out cluster retry loop.", "committedDate": "2020-02-27T21:42:15Z", "type": "commit"}, {"oid": "62b03f76c31daeeb8813946b027b9f640d825531", "url": "https://github.com/all-of-us/workbench/commit/62b03f76c31daeeb8813946b027b9f640d825531", "message": "Add and fix unit & controller tests.", "committedDate": "2020-02-27T21:45:44Z", "type": "commit"}, {"oid": "9d3001eb19cc33c064a30c2e631b87dfaf4172c2", "url": "https://github.com/all-of-us/workbench/commit/9d3001eb19cc33c064a30c2e631b87dfaf4172c2", "message": "A few more text fixes.", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "0587b2a25033549a79f9f3c3b27333696c9dd48d", "url": "https://github.com/all-of-us/workbench/commit/0587b2a25033549a79f9f3c3b27333696c9dd48d", "message": "Incorporate initializer into reset-cluster-button, use jest.fakeTimers, add more tests.", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "0fa7a7ace873ebda6e8e0c3b1c7af4d701b22953", "url": "https://github.com/all-of-us/workbench/commit/0fa7a7ace873ebda6e8e0c3b1c7af4d701b22953", "message": "Fix API tests.", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "87439e193b8fc63633d093c578a133035a85b008", "url": "https://github.com/all-of-us/workbench/commit/87439e193b8fc63633d093c578a133035a85b008", "message": "Add some class comments.", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "e84ca222bb9d8addeb3f0a5044adc0cda94d26fe", "url": "https://github.com/all-of-us/workbench/commit/e84ca222bb9d8addeb3f0a5044adc0cda94d26fe", "message": "Fix ng lint error", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "3bc2e4be30a4e8b941de45252aab07c9d3a4e3d5", "url": "https://github.com/all-of-us/workbench/commit/3bc2e4be30a4e8b941de45252aab07c9d3a4e3d5", "message": "PR feedback.", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "4b21497759abbd113bcdf7138238658eb1cc9c8d", "url": "https://github.com/all-of-us/workbench/commit/4b21497759abbd113bcdf7138238658eb1cc9c8d", "message": "Spotless formatting and test fix.", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "560306b75cc0d0b7454c416e4b9c74a9e6fb78dd", "url": "https://github.com/all-of-us/workbench/commit/560306b75cc0d0b7454c416e4b9c74a9e6fb78dd", "message": "Fix ts lint", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "59a604b90d0ea938cdaebdda0eae7ea9cce8790e", "url": "https://github.com/all-of-us/workbench/commit/59a604b90d0ea938cdaebdda0eae7ea9cce8790e", "message": "Revert unintentional change to DataSetController (bad rebase).", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "cf112c33a516c89764e860451bc56e4e4b5c93d6", "url": "https://github.com/all-of-us/workbench/commit/cf112c33a516c89764e860451bc56e4e4b5c93d6", "message": "Final PR feedback.", "committedDate": "2020-02-27T21:45:45Z", "type": "commit"}, {"oid": "cf112c33a516c89764e860451bc56e4e4b5c93d6", "url": "https://github.com/all-of-us/workbench/commit/cf112c33a516c89764e860451bc56e4e4b5c93d6", "message": "Final PR feedback.", "committedDate": "2020-02-27T21:45:45Z", "type": "forcePushed"}]}