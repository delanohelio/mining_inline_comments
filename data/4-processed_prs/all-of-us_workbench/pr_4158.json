{"pr_number": 4158, "pr_title": "[risk=no] Better logging for fetch() errors", "pr_createdAt": "2020-10-14T03:58:34Z", "pr_url": "https://github.com/all-of-us/workbench/pull/4158", "timeline": [{"oid": "57ae42aff3a97a75660dbaa514951ba0dd06dbad", "url": "https://github.com/all-of-us/workbench/commit/57ae42aff3a97a75660dbaa514951ba0dd06dbad", "message": "Better logging for fetch() errors", "committedDate": "2020-10-14T03:57:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyNTY4MQ==", "url": "https://github.com/all-of-us/workbench/pull/4158#discussion_r504725681", "bodyText": "Does changing this to async have any impacts that would be relevant - like changing the order that the error messages appear in, in the log?", "author": "petesantos", "createdAt": "2020-10-14T14:30:46Z", "path": "ui/src/app/services/error-reporter.service.ts", "diffHunk": "@@ -31,26 +31,33 @@ export class ErrorReporterService extends ErrorHandler {\n     });\n   }\n \n-  handleError(error: any) {\n-    // Always log to console regardless of whether Stackdriver is enabled.\n-    super.handleError(error);\n-    if (!this.stackdriverReporter) {\n+  /**\n+   * Unwrap to avoid vague top-level errors like: \"Promise rejected: {}\". This method\n+   * mutates the incoming error in order to allow preservation of the original stack trace.\n+   */\n+  private async expandErrorMessage(error: any): Promise<any> {\n+    if (!error.rejection || !(error.rejection instanceof Response)) {\n       return;\n     }\n \n-\n-    // We want to avoid sending XHR errors to stackdriver because they should\n-    // already be being logged by the API with the stacktrace and information\n-    // we care about.\n-\n-    // xhrError is set to true by the interceptor. The rejection piece handles\n-    // return values from promises that error out.\n-    if (error.rejection && error.rejection.xhrError) {\n+    const httpResp = error.rejection;\n+    const prefix = `${httpResp.status} @ ${httpResp.url}`;\n+    if (httpResp.bodyUsed) {\n+      error.message = prefix;\n       return;\n     }\n-    // The check on xhrError explicitly handles error values that are returned from direct\n-    // api errors, rather than promises.\n-    if (error.xhrError) {\n+    const json = JSON.stringify(await httpResp.json());\n+    error.message = `${prefix}: ${json}`;\n+    return;\n+  }\n+\n+  async handleError(error: any) {", "originalCommit": "57ae42aff3a97a75660dbaa514951ba0dd06dbad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzOTM4Ng==", "url": "https://github.com/all-of-us/workbench/pull/4158#discussion_r505039386", "bodyText": "Good question. I don't think it's a problem here, my reasoning follows:\n\nThis particular methods gets triggered when an error hits the top of the stack (or at least, top of the Angular harness). So at this point, we're outside of our normal code flow.\nBecause this also gets hit when an error is thrown, it's also not likely that we're depending on two errors coming in from one logical piece of code - to the point where we'd care about the order\n\nPractically speaking, I don't think the order typically matters, and this is purely for manual debugging anyways. The response body on an error also should not be streaming in or anything, from any typical service. I expect in all cases that promise will resolve immediately (though this still affects the flow control).", "author": "calbach", "createdAt": "2020-10-14T22:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyNTY4MQ=="}], "type": "inlineReview"}]}