{"pr_number": 4346, "pr_title": "[RW-5921][risk=no] Lazy runtime initialization should pick accurate configuration", "pr_createdAt": "2020-12-02T23:19:39Z", "pr_url": "https://github.com/all-of-us/workbench/pull/4346", "timeline": [{"oid": "7fab5f0cfee5a82ad652cc97f66210f11f715290", "url": "https://github.com/all-of-us/workbench/commit/7fab5f0cfee5a82ad652cc97f66210f11f715290", "message": "add test case", "committedDate": "2020-12-02T21:24:03Z", "type": "commit"}, {"oid": "62a6f76d6361d4703f8bd4d6efbd04e0d2dbcff9", "url": "https://github.com/all-of-us/workbench/commit/62a6f76d6361d4703f8bd4d6efbd04e0d2dbcff9", "message": "add impl", "committedDate": "2020-12-02T22:42:43Z", "type": "commit"}, {"oid": "f8ab30a87453571211588b37c37045aa7ac23438", "url": "https://github.com/all-of-us/workbench/commit/f8ab30a87453571211588b37c37045aa7ac23438", "message": "syntax", "committedDate": "2020-12-02T23:18:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0OTI1OA==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r534549258", "bodyText": "I'm pretty sure this does what I want but I don't really understand how it works. Can someone explain to me why this works but await LeoRuntimeInitializer..... does not?", "author": "ericsong", "createdAt": "2020-12-02T23:20:22Z", "path": "ui/src/app/utils/leo-runtime-initializer.spec.tsx", "diffHunk": "@@ -163,6 +163,31 @@ describe('RuntimeInitializer', () => {\n     expect(runtime.status).toEqual(RuntimeStatus.Running);\n   });\n \n+  it('should lazily create user\\'s most runtime if a valid one exists', async() => {\n+    serverConfigStore.next({gsuiteDomain: 'researchallofus.org', enableCustomRuntimes: true});\n+    mockGetRuntime.mockImplementation(namespace => {\n+      return {\n+        ...defaultRuntime(),\n+        gceConfig: {\n+          diskSize: 777,\n+          machineType: 'n1-standard-16'\n+        },\n+        status: RuntimeStatus.Deleted\n+      }; });\n+\n+    LeoRuntimeInitializer.initialize({\n+      workspaceNamespace: workspaceNamespace,\n+    });\n+    await new Promise(setImmediate);", "originalCommit": "f8ab30a87453571211588b37c37045aa7ac23438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU1MjI1MA==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r534552250", "bodyText": "We're using fake timers in this test. The LeoRuntimeInitializer uses setTimeout() to do the polling, which means it won't terminate unless we tick the timers. see the helper function runInitializerAndTimers which handles this properly, you may want to use that here.", "author": "calbach", "createdAt": "2020-12-02T23:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0OTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU2NDQ3NA==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r534564474", "bodyText": "Also, as to why this await new Promise(setImmediate) appeared to work: what this does is allow the call stack to resolve for any calbacks/promises that are pending. In this case, I expect this gives the first call to getRuntime in the initializer a chance to return and be processed, which may be enough to satisfy your test constraints.", "author": "calbach", "createdAt": "2020-12-02T23:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0OTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI3NzE0NQ==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535277145", "bodyText": "I see. thanks for the explanation. I actually did start out by using runInitializerAndTimers but I only wanted it to resolve once and not make the subsequent calls to poll which is why I was looking for an alternative.", "author": "ericsong", "createdAt": "2020-12-03T14:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0OTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU2NDYwNg==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535564606", "bodyText": "ack, you can also do await waitForTick with is effectively achieving the same thing and is more standard to use in our tests", "author": "calbach", "createdAt": "2020-12-03T20:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0OTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxMjkxOA==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535712918", "bodyText": "the existing functions look like they take in a wrapper component but I don't think we actually have one in these tests", "author": "ericsong", "createdAt": "2020-12-03T23:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0OTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU2MzIxMw==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r534563213", "bodyText": "See TODO/comment above (and you can remove the TODO part). Ideally the logic here would be the same as you added on the create panel: if the deleted runtime has one of the preset configuration types, use that as the target (instead of whatever we got from the backend). This makes the behavior symmetric to opening the create panel, where we want to snap to the latest \"preset\", rather than whatever the preset happened to be when the user last used the system.\nNote: this won't matter much for now as we don't expect the presets to change, but later when we start allowing configuration of docker image versions, this will be important so people don't unintentionally stuck on old versions.", "author": "calbach", "createdAt": "2020-12-02T23:56:07Z", "path": "ui/src/app/utils/leo-runtime-initializer.tsx", "diffHunk": "@@ -204,7 +202,15 @@ export class LeoRuntimeInitializer {\n       // - the user's most recent UserOverride config, if any\n       // - (maybe) the user's most recently selected preset, if any\n       // - general analysis\n-      runtime = {...runtimePresets.generalAnalysis.runtimeTemplate};\n+\n+      if (this.currentRuntime && this.currentRuntime.status === RuntimeStatus.Deleted) {", "originalCommit": "f8ab30a87453571211588b37c37045aa7ac23438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI3NDk3Mw==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535274973", "bodyText": "Right - made that change and added a test case", "author": "ericsong", "createdAt": "2020-12-03T14:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU2MzIxMw=="}], "type": "inlineReview"}, {"oid": "ee8bc3e378ca5db1bf43d3fbc2d50d8432db7c5b", "url": "https://github.com/all-of-us/workbench/commit/ee8bc3e378ca5db1bf43d3fbc2d50d8432db7c5b", "message": "use latest preset values during lazy instantiation", "committedDate": "2020-12-03T14:27:37Z", "type": "commit"}, {"oid": "1beedf060a9d80b182869c6d1440a41ce06b763f", "url": "https://github.com/all-of-us/workbench/commit/1beedf060a9d80b182869c6d1440a41ce06b763f", "message": "syntax", "committedDate": "2020-12-03T14:31:06Z", "type": "commit"}, {"oid": "31f8be1fa94d4875ea21a0fc8e687df71f3ec6e5", "url": "https://github.com/all-of-us/workbench/commit/31f8be1fa94d4875ea21a0fc8e687df71f3ec6e5", "message": "fix case that relies on runtime being undefined for create panel", "committedDate": "2020-12-03T17:22:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU1NTE4Mw==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535555183", "bodyText": "rm", "author": "calbach", "createdAt": "2020-12-03T20:13:16Z", "path": "ui/src/app/pages/analysis/runtime-panel.tsx", "diffHunk": "@@ -791,6 +790,8 @@ export const RuntimePanel = fp.flow(\n       () => PanelContent.Create],\n     [() => true, () => PanelContent.Customize]\n   ])([currentRuntime, status]);\n+  console.log(currentRuntime);", "originalCommit": "31f8be1fa94d4875ea21a0fc8e687df71f3ec6e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU1NjM1NQ==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535556355", "bodyText": "Unnecessary && check as newRuntime cannot be null at this point", "author": "calbach", "createdAt": "2020-12-03T20:14:19Z", "path": "ui/src/app/utils/runtime-presets.ts", "diffHunk": "@@ -29,3 +30,26 @@ export const runtimePresets: {\n     }\n   }\n };\n+\n+export const applyPresetOverride = (runtime) => {\n+  if (!runtime) {\n+    return runtime;\n+  }\n+\n+  const newRuntime = {...runtime};\n+\n+  // if runtime configuration type is a default, override its config with preset values\n+  // The Deleted check is so that we only update the user's runtime to the latest preset values\n+  // after they delete their runtime (ex. not while its actively in use).\n+  if (newRuntime && newRuntime.status === RuntimeStatus.Deleted) {", "originalCommit": "31f8be1fa94d4875ea21a0fc8e687df71f3ec6e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU1NjYxOQ==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535556619", "bodyText": "nit: indent", "author": "calbach", "createdAt": "2020-12-03T20:14:33Z", "path": "ui/src/app/utils/runtime-presets.ts", "diffHunk": "@@ -29,3 +30,26 @@ export const runtimePresets: {\n     }\n   }\n };\n+\n+export const applyPresetOverride = (runtime) => {\n+  if (!runtime) {\n+    return runtime;\n+  }\n+\n+  const newRuntime = {...runtime};\n+\n+  // if runtime configuration type is a default, override its config with preset values\n+  // The Deleted check is so that we only update the user's runtime to the latest preset values\n+  // after they delete their runtime (ex. not while its actively in use).\n+  if (newRuntime && newRuntime.status === RuntimeStatus.Deleted) {\n+    const runtimePresetKey = fp.keys(runtimePresets)\n+    .find(key => runtimePresets[key].runtimeTemplate.configurationType === newRuntime.configurationType);", "originalCommit": "31f8be1fa94d4875ea21a0fc8e687df71f3ec6e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU1NzU5Mg==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535557592", "bodyText": "revert", "author": "calbach", "createdAt": "2020-12-03T20:15:30Z", "path": "ui/src/app/utils/runtime-utils.tsx", "diffHunk": "@@ -282,7 +281,7 @@ export const useRuntimeStatus = (currentWorkspaceNamespace): [\n             resolutionCondition: (r) => resolutionCondition(r)\n           });\n         } catch (e) {\n-          // ExceededActionCountError is expected, as we exceed our create limit of 0.\n+          // gxceededActionCountError is expected, as we exceed our create limit of 0.", "originalCommit": "31f8be1fa94d4875ea21a0fc8e687df71f3ec6e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTU2MjMxOA==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535562318", "bodyText": "IMO this business logic belongs outside of this helper function. I realize this may result in some small duplication, but the separation of responsibilities is clearer if the caller only calls applyPresetOverride in cases where it actually wants to apply a presetOverride. Otherwise you probably need a super verbose method name to convey the semantics accurately.", "author": "calbach", "createdAt": "2020-12-03T20:19:42Z", "path": "ui/src/app/utils/runtime-presets.ts", "diffHunk": "@@ -29,3 +30,26 @@ export const runtimePresets: {\n     }\n   }\n };\n+\n+export const applyPresetOverride = (runtime) => {\n+  if (!runtime) {\n+    return runtime;\n+  }\n+\n+  const newRuntime = {...runtime};\n+\n+  // if runtime configuration type is a default, override its config with preset values\n+  // The Deleted check is so that we only update the user's runtime to the latest preset values\n+  // after they delete their runtime (ex. not while its actively in use).\n+  if (newRuntime && newRuntime.status === RuntimeStatus.Deleted) {", "originalCommit": "31f8be1fa94d4875ea21a0fc8e687df71f3ec6e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "92800581784e7ac1dc7de43f5a9ca5a2630f854a", "url": "https://github.com/all-of-us/workbench/commit/92800581784e7ac1dc7de43f5a9ca5a2630f854a", "message": "code review feedback", "committedDate": "2020-12-03T22:59:56Z", "type": "commit"}, {"oid": "534d18e908f58dd0a07ffefed181163de26130bf", "url": "https://github.com/all-of-us/workbench/commit/534d18e908f58dd0a07ffefed181163de26130bf", "message": "lint", "committedDate": "2020-12-03T23:01:31Z", "type": "commit"}, {"oid": "dcfa6caef4d1132b07663a51516655073f7511e1", "url": "https://github.com/all-of-us/workbench/commit/dcfa6caef4d1132b07663a51516655073f7511e1", "message": "remove deleted check", "committedDate": "2020-12-03T23:06:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxNDI2MQ==", "url": "https://github.com/all-of-us/workbench/pull/4346#discussion_r535714261", "bodyText": "your comment about factoring out the business logic made me realize that I could probably just remove that check here.\nIn most cases the status will be Deleted at this point but even in the case where it isn't, I feel like it probably makes sense to create the currentRuntime (w/ the preset override) instead of defaulting to the General Analysis template.", "author": "ericsong", "createdAt": "2020-12-03T23:10:52Z", "path": "ui/src/app/utils/leo-runtime-initializer.tsx", "diffHunk": "@@ -196,16 +194,16 @@ export class LeoRuntimeInitializer {\n       throw new ExceededActionCountError(\n         `Reached max runtime create count (${this.maxCreateCount})`, this.currentRuntime);\n     }\n+\n     let runtime: Runtime;\n     if (serverConfigStore.getValue().enableCustomRuntimes && this.targetRuntime) {\n       runtime = this.targetRuntime;\n+    } else if (this.currentRuntime) {", "originalCommit": "dcfa6caef4d1132b07663a51516655073f7511e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}