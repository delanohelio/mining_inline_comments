{"pr_number": 3159, "pr_title": "[risk=no]refactor StorageEnumsTest and CommonStorageEnumsTest", "pr_createdAt": "2020-02-19T22:58:18Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3159", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NjYzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r381596639", "bodyText": "required explicitly enumerating the maps in data() above", "author": "jmthibault79", "createdAt": "2020-02-19T22:59:29Z", "path": "common-api/src/test/java/org/pmiops/workbench/db/model/CommonStorageEnumsTest.java", "diffHunk": "@@ -4,103 +4,86 @@\n import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n-import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-import org.pmiops.workbench.model.DataAccessLevel;\n import org.pmiops.workbench.model.Domain;\n \n-@RunWith(Parameterized.class)\n public class CommonStorageEnumsTest {\n-  @Parameters(name = \"{0}\")\n-  public static Object[][] data() {\n-    return new Object[][] {\n-      {\n-        DataAccessLevel.class.getSimpleName(),\n-        DataAccessLevel.values(),\n-        (Function<Short, DataAccessLevel>) CommonStorageEnums::dataAccessLevelFromStorage,\n-        (Function<DataAccessLevel, Short>) CommonStorageEnums::dataAccessLevelToStorage\n-      },\n-      {\n-        Domain.class.getSimpleName(),\n-        Domain.values(),\n-        (Function<Short, Domain>) CommonStorageEnums::domainFromStorage,\n-        (Function<Domain, Short>) CommonStorageEnums::domainToStorage\n-      }\n-    };\n-  }\n-\n-  @Parameter() public String description;\n-\n-  @Parameter(1)\n-  public Enum<?>[] enumValues;\n-\n-  @Parameter(2)\n-  public Function<Short, Enum<?>> fromStorage;\n-\n-  @Parameter(3)\n-  public Function<Enum<?>, Short> toStorage;\n-\n-  @Test\n-  public void testBijectiveStorageMapping() {", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5Njk1Mw==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r381596953", "bodyText": "This was the bug in #3131 - also needed to check for domainToDomainId", "author": "jmthibault79", "createdAt": "2020-02-19T23:00:14Z", "path": "common-api/src/test/java/org/pmiops/workbench/db/model/CommonStorageEnumsTest.java", "diffHunk": "@@ -4,103 +4,86 @@\n import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n-import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-import org.pmiops.workbench.model.DataAccessLevel;\n import org.pmiops.workbench.model.Domain;\n \n-@RunWith(Parameterized.class)\n public class CommonStorageEnumsTest {\n-  @Parameters(name = \"{0}\")\n-  public static Object[][] data() {\n-    return new Object[][] {\n-      {\n-        DataAccessLevel.class.getSimpleName(),\n-        DataAccessLevel.values(),\n-        (Function<Short, DataAccessLevel>) CommonStorageEnums::dataAccessLevelFromStorage,\n-        (Function<DataAccessLevel, Short>) CommonStorageEnums::dataAccessLevelToStorage\n-      },\n-      {\n-        Domain.class.getSimpleName(),\n-        Domain.values(),\n-        (Function<Short, Domain>) CommonStorageEnums::domainFromStorage,\n-        (Function<Domain, Short>) CommonStorageEnums::domainToStorage\n-      }\n-    };\n-  }\n-\n-  @Parameter() public String description;\n-\n-  @Parameter(1)\n-  public Enum<?>[] enumValues;\n-\n-  @Parameter(2)\n-  public Function<Short, Enum<?>> fromStorage;\n-\n-  @Parameter(3)\n-  public Function<Enum<?>, Short> toStorage;\n-\n-  @Test\n-  public void testBijectiveStorageMapping() {\n-    for (Enum<?> v : enumValues) {\n-      Short storageValue = toStorage.apply(v);\n-      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n-      assertThat(v).isEqualTo(fromStorage.apply(storageValue));\n-    }\n-  }\n \n   // domain ID is stringly-typed so special-case this\n \n   @Test\n-  public void testDomainIdBijectiveStorageMapping() {\n+  public void test_domainId() {\n     for (Domain v : Domain.values()) {\n       String storageValue = CommonStorageEnums.domainToDomainId(v);\n       assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n       assertThat(v).isEqualTo(CommonStorageEnums.domainIdToDomain(storageValue));\n     }\n   }\n \n-  // copied from api/StorageEnumsTest because the above tests are not comprehensive\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : CommonStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n-\n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n-\n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : CommonStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n-\n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n-\n-      // stringly typed map - test with testDomainIdBijectiveStorageMapping instead\n-      if (enumToShort.getName().equals(\"domainIdToDomain\")) {", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5OTM2MA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r381599360", "bodyText": "This is not my dark magic - it's a copy-paste.", "author": "jmthibault79", "createdAt": "2020-02-19T23:06:23Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -3,40 +3,68 @@\n import static com.google.common.truth.Truth.assertThat;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  @Test\n+  public void test_noMissingMapEntries() throws Exception {\n+    final Set<Class> enumClasses = getEnumerationClasses();\n+    final Collection<Method> methods = Arrays.asList(DbStorageEnums.class.getDeclaredMethods());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+    // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+    final Map<Class, Method> toStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(firstMethodParameter(m)))\n+            .collect(Collectors.toMap(this::firstMethodParameter, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+    // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+    final Map<Class, Method> fromStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(m.getReturnType()))\n+            .collect(Collectors.toMap(Method::getReturnType, m -> m));\n \n+    for (Class enumClass : enumClasses) {\n+      final Method toStorage = toStorageMethods.get(enumClass);\n+      final Method fromStorage = fromStorageMethods.get(enumClass);\n       for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+        Short shortVal = (Short) toStorage.invoke(null, e);\n \n         assertThat(shortVal).named(enumClass.getName() + \":\" + e.toString()).isNotNull();\n-        assertThat(shortToEnum.invoke(null, shortVal)).isEqualTo(e);\n+        assertThat(fromStorage.invoke(null, shortVal)).isEqualTo(e);\n       }\n     }\n   }\n+\n+  /**\n+   * Retrieve all Enum classes in DbStorageEnums\n+   *\n+   * <p>our convention for BiMaps in DbStorageEnums is <Enum, Short> so we retrieve the first\n+   * parameterized type\n+   *\n+   * @return\n+   */\n+  private Set<Class> getEnumerationClasses() {\n+    return Stream.of(DbStorageEnums.class.getDeclaredFields())\n+        .filter(f -> f.getType().equals(BiMap.class))\n+        .map(\n+            f ->\n+                (Class)\n+                    ((ParameterizedType) f.getAnnotatedType().getType())", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMTQxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382101411", "bodyText": "Can you generify it so that it takes in either a type parameter or argument for the enum class to be harvested?\nI'd like to see some more comments on why it has to be copied and what each chunk is doing.", "author": "jaycarlton", "createdAt": "2020-02-20T16:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5OTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjEzMA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382096130", "bodyText": "This is nifty. I might need a little more detail in the comments (especially if my reflection is rusty).\nThinking out loud, I wonder if you could refactor the Enums classes such that each matching pair of to & from methods just has the same name across the board. E.g. they could all inherit from something like\ninterface EnumMappable<T extends Enum<T>> {\n  T toEnum(Short short);\n  short toStorage(T enum);\n}", "author": "jaycarlton", "createdAt": "2020-02-20T16:02:09Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -3,40 +3,68 @@\n import static com.google.common.truth.Truth.assertThat;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  @Test\n+  public void test_noMissingMapEntries() throws Exception {\n+    final Set<Class> enumClasses = getEnumerationClasses();\n+    final Collection<Method> methods = Arrays.asList(DbStorageEnums.class.getDeclaredMethods());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+    // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+    final Map<Class, Method> toStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(firstMethodParameter(m)))\n+            .collect(Collectors.toMap(this::firstMethodParameter, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+    // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+    final Map<Class, Method> fromStorageMethods =", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NzU5Mw==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382097593", "bodyText": "Can you make an identifier for null in this case, like STATIC?\nI'm confused about what e is here. Maybe enumEntry or enumVal would help.", "author": "jaycarlton", "createdAt": "2020-02-20T16:04:36Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -3,40 +3,68 @@\n import static com.google.common.truth.Truth.assertThat;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  @Test\n+  public void test_noMissingMapEntries() throws Exception {\n+    final Set<Class> enumClasses = getEnumerationClasses();\n+    final Collection<Method> methods = Arrays.asList(DbStorageEnums.class.getDeclaredMethods());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+    // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+    final Map<Class, Method> toStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(firstMethodParameter(m)))\n+            .collect(Collectors.toMap(this::firstMethodParameter, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+    // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+    final Map<Class, Method> fromStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(m.getReturnType()))\n+            .collect(Collectors.toMap(Method::getReturnType, m -> m));\n \n+    for (Class enumClass : enumClasses) {\n+      final Method toStorage = toStorageMethods.get(enumClass);\n+      final Method fromStorage = fromStorageMethods.get(enumClass);\n       for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+        Short shortVal = (Short) toStorage.invoke(null, e);", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5OTYyNA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382099624", "bodyText": "This might be a place where making a local lambda makes things cleaner. E.g. Function<Short, enumClass> fromStorage = storageValue -> fromStorage.invoke(null, storageValue); The invoke null takes a while to get used to.", "author": "jaycarlton", "createdAt": "2020-02-20T16:07:57Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -3,40 +3,68 @@\n import static com.google.common.truth.Truth.assertThat;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  @Test\n+  public void test_noMissingMapEntries() throws Exception {\n+    final Set<Class> enumClasses = getEnumerationClasses();\n+    final Collection<Method> methods = Arrays.asList(DbStorageEnums.class.getDeclaredMethods());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+    // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+    final Map<Class, Method> toStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(firstMethodParameter(m)))\n+            .collect(Collectors.toMap(this::firstMethodParameter, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+    // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+    final Map<Class, Method> fromStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(m.getReturnType()))\n+            .collect(Collectors.toMap(Method::getReturnType, m -> m));\n \n+    for (Class enumClass : enumClasses) {\n+      final Method toStorage = toStorageMethods.get(enumClass);\n+      final Method fromStorage = fromStorageMethods.get(enumClass);\n       for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+        Short shortVal = (Short) toStorage.invoke(null, e);\n \n         assertThat(shortVal).named(enumClass.getName() + \":\" + e.toString()).isNotNull();\n-        assertThat(shortToEnum.invoke(null, shortVal)).isEqualTo(e);\n+        assertThat(fromStorage.invoke(null, shortVal)).isEqualTo(e);", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMjI1OA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382102258", "bodyText": "How do we test the reverse direction? I.e. how do we know we don't have shorts written to the db someplace that don't map back to an enum value?", "author": "jaycarlton", "createdAt": "2020-02-20T16:12:15Z", "path": "common-api/src/test/java/org/pmiops/workbench/db/model/CommonStorageEnumsTest.java", "diffHunk": "@@ -4,103 +4,86 @@\n import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n-import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-import org.pmiops.workbench.model.DataAccessLevel;\n import org.pmiops.workbench.model.Domain;\n \n-@RunWith(Parameterized.class)\n public class CommonStorageEnumsTest {\n-  @Parameters(name = \"{0}\")\n-  public static Object[][] data() {\n-    return new Object[][] {\n-      {\n-        DataAccessLevel.class.getSimpleName(),\n-        DataAccessLevel.values(),\n-        (Function<Short, DataAccessLevel>) CommonStorageEnums::dataAccessLevelFromStorage,\n-        (Function<DataAccessLevel, Short>) CommonStorageEnums::dataAccessLevelToStorage\n-      },\n-      {\n-        Domain.class.getSimpleName(),\n-        Domain.values(),\n-        (Function<Short, Domain>) CommonStorageEnums::domainFromStorage,\n-        (Function<Domain, Short>) CommonStorageEnums::domainToStorage\n-      }\n-    };\n-  }\n-\n-  @Parameter() public String description;\n-\n-  @Parameter(1)\n-  public Enum<?>[] enumValues;\n-\n-  @Parameter(2)\n-  public Function<Short, Enum<?>> fromStorage;\n-\n-  @Parameter(3)\n-  public Function<Enum<?>, Short> toStorage;\n-\n-  @Test\n-  public void testBijectiveStorageMapping() {\n-    for (Enum<?> v : enumValues) {\n-      Short storageValue = toStorage.apply(v);\n-      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n-      assertThat(v).isEqualTo(fromStorage.apply(storageValue));\n-    }\n-  }\n \n   // domain ID is stringly-typed so special-case this\n \n   @Test\n-  public void testDomainIdBijectiveStorageMapping() {\n+  public void test_domainId() {", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYxMzg0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382613842", "bodyText": "I guess by virtue of them being in a bimap it's not a problem, but the test shouldn't know that.", "author": "jaycarlton", "createdAt": "2020-02-21T14:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMjI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMzA2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382103063", "bodyText": "Maybe this is really getFirstParameterType()?", "author": "jaycarlton", "createdAt": "2020-02-20T16:13:28Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -3,40 +3,68 @@\n import static com.google.common.truth.Truth.assertThat;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  @Test\n+  public void test_noMissingMapEntries() throws Exception {\n+    final Set<Class> enumClasses = getEnumerationClasses();\n+    final Collection<Method> methods = Arrays.asList(DbStorageEnums.class.getDeclaredMethods());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+    // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+    final Map<Class, Method> toStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(firstMethodParameter(m)))\n+            .collect(Collectors.toMap(this::firstMethodParameter, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+    // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+    final Map<Class, Method> fromStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(m.getReturnType()))\n+            .collect(Collectors.toMap(Method::getReturnType, m -> m));\n \n+    for (Class enumClass : enumClasses) {\n+      final Method toStorage = toStorageMethods.get(enumClass);\n+      final Method fromStorage = fromStorageMethods.get(enumClass);\n       for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+        Short shortVal = (Short) toStorage.invoke(null, e);\n \n         assertThat(shortVal).named(enumClass.getName() + \":\" + e.toString()).isNotNull();\n-        assertThat(shortToEnum.invoke(null, shortVal)).isEqualTo(e);\n+        assertThat(fromStorage.invoke(null, shortVal)).isEqualTo(e);\n       }\n     }\n   }\n+\n+  /**\n+   * Retrieve all Enum classes in DbStorageEnums\n+   *\n+   * <p>our convention for BiMaps in DbStorageEnums is <Enum, Short> so we retrieve the first\n+   * parameterized type\n+   *\n+   * @return\n+   */\n+  private Set<Class> getEnumerationClasses() {\n+    return Stream.of(DbStorageEnums.class.getDeclaredFields())\n+        .filter(f -> f.getType().equals(BiMap.class))\n+        .map(\n+            f ->\n+                (Class)\n+                    ((ParameterizedType) f.getAnnotatedType().getType())\n+                        .getActualTypeArguments()[0])\n+        .collect(Collectors.toSet());\n+  }\n+\n+  // convenience method describing what is retrieved here\n+  private Class firstMethodParameter(Method method) {", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMzQxMA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382103410", "bodyText": "\"strongly\"?", "author": "jaycarlton", "createdAt": "2020-02-20T16:14:01Z", "path": "common-api/src/test/java/org/pmiops/workbench/db/model/CommonStorageEnumsTest.java", "diffHunk": "@@ -4,103 +4,86 @@\n import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n-import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-import org.pmiops.workbench.model.DataAccessLevel;\n import org.pmiops.workbench.model.Domain;\n \n-@RunWith(Parameterized.class)\n public class CommonStorageEnumsTest {\n-  @Parameters(name = \"{0}\")\n-  public static Object[][] data() {\n-    return new Object[][] {\n-      {\n-        DataAccessLevel.class.getSimpleName(),\n-        DataAccessLevel.values(),\n-        (Function<Short, DataAccessLevel>) CommonStorageEnums::dataAccessLevelFromStorage,\n-        (Function<DataAccessLevel, Short>) CommonStorageEnums::dataAccessLevelToStorage\n-      },\n-      {\n-        Domain.class.getSimpleName(),\n-        Domain.values(),\n-        (Function<Short, Domain>) CommonStorageEnums::domainFromStorage,\n-        (Function<Domain, Short>) CommonStorageEnums::domainToStorage\n-      }\n-    };\n-  }\n-\n-  @Parameter() public String description;\n-\n-  @Parameter(1)\n-  public Enum<?>[] enumValues;\n-\n-  @Parameter(2)\n-  public Function<Short, Enum<?>> fromStorage;\n-\n-  @Parameter(3)\n-  public Function<Enum<?>, Short> toStorage;\n-\n-  @Test\n-  public void testBijectiveStorageMapping() {\n-    for (Enum<?> v : enumValues) {\n-      Short storageValue = toStorage.apply(v);\n-      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n-      assertThat(v).isEqualTo(fromStorage.apply(storageValue));\n-    }\n-  }\n \n   // domain ID is stringly-typed so special-case this\n \n   @Test\n-  public void testDomainIdBijectiveStorageMapping() {\n+  public void test_domainId() {\n     for (Domain v : Domain.values()) {\n       String storageValue = CommonStorageEnums.domainToDomainId(v);\n       assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n       assertThat(v).isEqualTo(CommonStorageEnums.domainIdToDomain(storageValue));\n     }\n   }\n \n-  // copied from api/StorageEnumsTest because the above tests are not comprehensive\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : CommonStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n-\n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n-\n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : CommonStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n-\n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n-\n-      // stringly typed map - test with testDomainIdBijectiveStorageMapping instead\n-      if (enumToShort.getName().equals(\"domainIdToDomain\")) {\n-        continue;\n-      }\n+  // this is a copy of StorageEnumsTest.test_noMissingMapEntries()\n \n+  @Test\n+  public void test_noMissingMapEntries() throws Exception {\n+    final Set<Class> enumClasses = getEnumerationClasses();\n+    final Collection<Method> methods = Arrays.asList(CommonStorageEnums.class.getDeclaredMethods());\n+\n+    // e.g. public static Short domainToStorage(Domain domain)\n+    final Map<Class, Method> toStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(firstMethodParameter(m)))\n+            // domainToDomainId is stringly typed - test with test_domainId", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzNzMwMQ==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382237301", "bodyText": "no, it's typed as a string", "author": "jmthibault79", "createdAt": "2020-02-20T20:22:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMzQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYxMzMyMg==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382613322", "bodyText": "This is a sign that we're trying too hard I think.", "author": "jaycarlton", "createdAt": "2020-02-21T14:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMzQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwNDQ2NA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382104464", "bodyText": "This test is extremely tightly tied to the implementation of the class. Ideally we capture enough of the functionality that migrating to something cleaner is easier. If we hold on too tightly, this could actually slow us down a bit.", "author": "jaycarlton", "createdAt": "2020-02-20T16:15:42Z", "path": "common-api/src/test/java/org/pmiops/workbench/db/model/CommonStorageEnumsTest.java", "diffHunk": "@@ -4,103 +4,86 @@\n import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n-import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-import org.pmiops.workbench.model.DataAccessLevel;\n import org.pmiops.workbench.model.Domain;\n \n-@RunWith(Parameterized.class)\n public class CommonStorageEnumsTest {\n-  @Parameters(name = \"{0}\")\n-  public static Object[][] data() {\n-    return new Object[][] {\n-      {\n-        DataAccessLevel.class.getSimpleName(),\n-        DataAccessLevel.values(),\n-        (Function<Short, DataAccessLevel>) CommonStorageEnums::dataAccessLevelFromStorage,\n-        (Function<DataAccessLevel, Short>) CommonStorageEnums::dataAccessLevelToStorage\n-      },\n-      {\n-        Domain.class.getSimpleName(),\n-        Domain.values(),\n-        (Function<Short, Domain>) CommonStorageEnums::domainFromStorage,\n-        (Function<Domain, Short>) CommonStorageEnums::domainToStorage\n-      }\n-    };\n-  }\n-\n-  @Parameter() public String description;\n-\n-  @Parameter(1)\n-  public Enum<?>[] enumValues;\n-\n-  @Parameter(2)\n-  public Function<Short, Enum<?>> fromStorage;\n-\n-  @Parameter(3)\n-  public Function<Enum<?>, Short> toStorage;\n-\n-  @Test\n-  public void testBijectiveStorageMapping() {\n-    for (Enum<?> v : enumValues) {\n-      Short storageValue = toStorage.apply(v);\n-      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n-      assertThat(v).isEqualTo(fromStorage.apply(storageValue));\n-    }\n-  }\n \n   // domain ID is stringly-typed so special-case this\n \n   @Test\n-  public void testDomainIdBijectiveStorageMapping() {\n+  public void test_domainId() {\n     for (Domain v : Domain.values()) {\n       String storageValue = CommonStorageEnums.domainToDomainId(v);\n       assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n       assertThat(v).isEqualTo(CommonStorageEnums.domainIdToDomain(storageValue));\n     }\n   }\n \n-  // copied from api/StorageEnumsTest because the above tests are not comprehensive\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : CommonStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n-\n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n-\n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : CommonStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n-\n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n-\n-      // stringly typed map - test with testDomainIdBijectiveStorageMapping instead\n-      if (enumToShort.getName().equals(\"domainIdToDomain\")) {\n-        continue;\n-      }\n+  // this is a copy of StorageEnumsTest.test_noMissingMapEntries()\n \n+  @Test\n+  public void test_noMissingMapEntries() throws Exception {\n+    final Set<Class> enumClasses = getEnumerationClasses();\n+    final Collection<Method> methods = Arrays.asList(CommonStorageEnums.class.getDeclaredMethods());\n+\n+    // e.g. public static Short domainToStorage(Domain domain)\n+    final Map<Class, Method> toStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(firstMethodParameter(m)))\n+            // domainToDomainId is stringly typed - test with test_domainId\n+            .filter(m -> !m.getName().equals(\"domainToDomainId\"))", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwNDY2NQ==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382104665", "bodyText": "Can we name this enumClassToToStorageMethod?", "author": "jaycarlton", "createdAt": "2020-02-20T16:16:03Z", "path": "common-api/src/test/java/org/pmiops/workbench/db/model/CommonStorageEnumsTest.java", "diffHunk": "@@ -4,103 +4,86 @@\n import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n-import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-import org.pmiops.workbench.model.DataAccessLevel;\n import org.pmiops.workbench.model.Domain;\n \n-@RunWith(Parameterized.class)\n public class CommonStorageEnumsTest {\n-  @Parameters(name = \"{0}\")\n-  public static Object[][] data() {\n-    return new Object[][] {\n-      {\n-        DataAccessLevel.class.getSimpleName(),\n-        DataAccessLevel.values(),\n-        (Function<Short, DataAccessLevel>) CommonStorageEnums::dataAccessLevelFromStorage,\n-        (Function<DataAccessLevel, Short>) CommonStorageEnums::dataAccessLevelToStorage\n-      },\n-      {\n-        Domain.class.getSimpleName(),\n-        Domain.values(),\n-        (Function<Short, Domain>) CommonStorageEnums::domainFromStorage,\n-        (Function<Domain, Short>) CommonStorageEnums::domainToStorage\n-      }\n-    };\n-  }\n-\n-  @Parameter() public String description;\n-\n-  @Parameter(1)\n-  public Enum<?>[] enumValues;\n-\n-  @Parameter(2)\n-  public Function<Short, Enum<?>> fromStorage;\n-\n-  @Parameter(3)\n-  public Function<Enum<?>, Short> toStorage;\n-\n-  @Test\n-  public void testBijectiveStorageMapping() {\n-    for (Enum<?> v : enumValues) {\n-      Short storageValue = toStorage.apply(v);\n-      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n-      assertThat(v).isEqualTo(fromStorage.apply(storageValue));\n-    }\n-  }\n \n   // domain ID is stringly-typed so special-case this\n \n   @Test\n-  public void testDomainIdBijectiveStorageMapping() {\n+  public void test_domainId() {\n     for (Domain v : Domain.values()) {\n       String storageValue = CommonStorageEnums.domainToDomainId(v);\n       assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n       assertThat(v).isEqualTo(CommonStorageEnums.domainIdToDomain(storageValue));\n     }\n   }\n \n-  // copied from api/StorageEnumsTest because the above tests are not comprehensive\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : CommonStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n-\n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n-\n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : CommonStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n-\n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n-\n-      // stringly typed map - test with testDomainIdBijectiveStorageMapping instead\n-      if (enumToShort.getName().equals(\"domainIdToDomain\")) {\n-        continue;\n-      }\n+  // this is a copy of StorageEnumsTest.test_noMissingMapEntries()\n \n+  @Test\n+  public void test_noMissingMapEntries() throws Exception {\n+    final Set<Class> enumClasses = getEnumerationClasses();\n+    final Collection<Method> methods = Arrays.asList(CommonStorageEnums.class.getDeclaredMethods());\n+\n+    // e.g. public static Short domainToStorage(Domain domain)\n+    final Map<Class, Method> toStorageMethods =", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwNTQyMg==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382105422", "bodyText": "Is it worth even fiddling with common-api if it's about to get reabsorbed?", "author": "jaycarlton", "createdAt": "2020-02-20T16:17:14Z", "path": "common-api/src/test/java/org/pmiops/workbench/db/model/CommonStorageEnumsTest.java", "diffHunk": "@@ -4,103 +4,86 @@\n import static com.google.common.truth.Truth.assertWithMessage;", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzNzg2NA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382237864", "bodyText": "Perhaps it wasn't when I messed with it last week.  But now that I've done so, I have broken it and hence this fix.  Oh well.", "author": "jmthibault79", "createdAt": "2020-02-20T20:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwNTQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYxMjk2OA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382612968", "bodyText": "Can we just move (F6 in IJ) all the public methods from CommonStorageEnums to DbStorageEnums and delete CommonStorageEnums?", "author": "jaycarlton", "createdAt": "2020-02-21T14:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwNTQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYzMTE4Ng==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382631186", "bodyText": "no.  they are in common-api.", "author": "jmthibault79", "createdAt": "2020-02-21T15:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwNTQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwNjQ1MQ==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382106451", "bodyText": "I really feel like this test knows too much about the implementation. I should ideally be able to go in and change out how we map things and the test cases should still pass if I've done it correctly. If the test expects biMap, that won't be true.", "author": "jaycarlton", "createdAt": "2020-02-20T16:18:59Z", "path": "common-api/src/test/java/org/pmiops/workbench/db/model/CommonStorageEnumsTest.java", "diffHunk": "@@ -4,103 +4,86 @@\n import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n-import java.util.function.Function;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameter;\n-import org.junit.runners.Parameterized.Parameters;\n-import org.pmiops.workbench.model.DataAccessLevel;\n import org.pmiops.workbench.model.Domain;\n \n-@RunWith(Parameterized.class)\n public class CommonStorageEnumsTest {\n-  @Parameters(name = \"{0}\")\n-  public static Object[][] data() {\n-    return new Object[][] {\n-      {\n-        DataAccessLevel.class.getSimpleName(),\n-        DataAccessLevel.values(),\n-        (Function<Short, DataAccessLevel>) CommonStorageEnums::dataAccessLevelFromStorage,\n-        (Function<DataAccessLevel, Short>) CommonStorageEnums::dataAccessLevelToStorage\n-      },\n-      {\n-        Domain.class.getSimpleName(),\n-        Domain.values(),\n-        (Function<Short, Domain>) CommonStorageEnums::domainFromStorage,\n-        (Function<Domain, Short>) CommonStorageEnums::domainToStorage\n-      }\n-    };\n-  }\n-\n-  @Parameter() public String description;\n-\n-  @Parameter(1)\n-  public Enum<?>[] enumValues;\n-\n-  @Parameter(2)\n-  public Function<Short, Enum<?>> fromStorage;\n-\n-  @Parameter(3)\n-  public Function<Enum<?>, Short> toStorage;\n-\n-  @Test\n-  public void testBijectiveStorageMapping() {\n-    for (Enum<?> v : enumValues) {\n-      Short storageValue = toStorage.apply(v);\n-      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n-      assertThat(v).isEqualTo(fromStorage.apply(storageValue));\n-    }\n-  }\n \n   // domain ID is stringly-typed so special-case this\n \n   @Test\n-  public void testDomainIdBijectiveStorageMapping() {\n+  public void test_domainId() {\n     for (Domain v : Domain.values()) {\n       String storageValue = CommonStorageEnums.domainToDomainId(v);\n       assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n       assertThat(v).isEqualTo(CommonStorageEnums.domainIdToDomain(storageValue));\n     }\n   }\n \n-  // copied from api/StorageEnumsTest because the above tests are not comprehensive\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : CommonStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n-\n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n-\n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : CommonStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n-\n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n-\n-      // stringly typed map - test with testDomainIdBijectiveStorageMapping instead\n-      if (enumToShort.getName().equals(\"domainIdToDomain\")) {\n-        continue;\n-      }\n+  // this is a copy of StorageEnumsTest.test_noMissingMapEntries()\n \n+  @Test\n+  public void test_noMissingMapEntries() throws Exception {\n+    final Set<Class> enumClasses = getEnumerationClasses();\n+    final Collection<Method> methods = Arrays.asList(CommonStorageEnums.class.getDeclaredMethods());\n+\n+    // e.g. public static Short domainToStorage(Domain domain)\n+    final Map<Class, Method> toStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(firstMethodParameter(m)))\n+            // domainToDomainId is stringly typed - test with test_domainId\n+            .filter(m -> !m.getName().equals(\"domainToDomainId\"))\n+            .collect(Collectors.toMap(this::firstMethodParameter, m -> m));\n+\n+    // e.g. public static Domain domainFromStorage(Short domain)\n+    final Map<Class, Method> fromStorageMethods =\n+        methods.stream()\n+            .filter(m -> enumClasses.contains(m.getReturnType()))\n+            // domainToDomainId is stringly typed - test with test_domainId\n+            .filter(m -> !m.getName().equals(\"domainIdToDomain\"))\n+            .collect(Collectors.toMap(Method::getReturnType, m -> m));\n+\n+    for (Class enumClass : enumClasses) {\n+      final Method toStorage = toStorageMethods.get(enumClass);\n+      final Method fromStorage = fromStorageMethods.get(enumClass);\n       for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+        Short shortVal = (Short) toStorage.invoke(null, e);\n \n         assertThat(shortVal).named(enumClass.getName() + \":\" + e.toString()).isNotNull();\n-        assertThat(shortToEnum.invoke(null, shortVal)).isEqualTo(e);\n+        assertThat(fromStorage.invoke(null, shortVal)).isEqualTo(e);\n       }\n     }\n   }\n+\n+  /**\n+   * Retrieve all Enum classes in CommonStorageEnums\n+   *\n+   * <p>our convention for BiMaps in CommonStorageEnums is <Enum, Short> so we retrieve the first", "originalCommit": "cb74f6fbe52cd6f77f2e86ed7e394aee1c8293de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8f779255f1785151ca20dc31dc9b87dfc0327d0d", "url": "https://github.com/all-of-us/workbench/commit/8f779255f1785151ca20dc31dc9b87dfc0327d0d", "message": "refactor StorageEnumsTest and CommonStorageEnumsTest", "committedDate": "2020-02-21T15:10:49Z", "type": "commit"}, {"oid": "8f779255f1785151ca20dc31dc9b87dfc0327d0d", "url": "https://github.com/all-of-us/workbench/commit/8f779255f1785151ca20dc31dc9b87dfc0327d0d", "message": "refactor StorageEnumsTest and CommonStorageEnumsTest", "committedDate": "2020-02-21T15:10:49Z", "type": "forcePushed"}, {"oid": "63d72a2b2e748ac724152d31f1ac108f2b069fe6", "url": "https://github.com/all-of-us/workbench/commit/63d72a2b2e748ac724152d31f1ac108f2b069fe6", "message": "lint", "committedDate": "2020-02-21T15:13:16Z", "type": "commit"}, {"oid": "d1d283bb50a1cf55f47f15d1370b6b58ba50e789", "url": "https://github.com/all-of-us/workbench/commit/d1d283bb50a1cf55f47f15d1370b6b58ba50e789", "message": "comment fix", "committedDate": "2020-02-21T15:13:49Z", "type": "commit"}, {"oid": "31815dd38be5ab7247929732ea984e650d879735", "url": "https://github.com/all-of-us/workbench/commit/31815dd38be5ab7247929732ea984e650d879735", "message": "rm CommonStorageEnumsTest", "committedDate": "2020-02-21T21:55:59Z", "type": "commit"}, {"oid": "ccf8e4aa348b31cd70fd2be4d1baf0eb48a569cc", "url": "https://github.com/all-of-us/workbench/commit/ccf8e4aa348b31cd70fd2be4d1baf0eb48a569cc", "message": "arraysToSet() to make it pretty", "committedDate": "2020-02-21T22:01:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNTQ1Mw==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382825453", "bodyText": "nit: Iterables.concat might be easier, but this is fine", "author": "jaycarlton", "createdAt": "2020-02-21T21:58:35Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -1,42 +1,117 @@\n package org.pmiops.workbench.db.model;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n+import org.pmiops.workbench.model.Domain;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n+  private final Object INDICATES_STATIC_METHOD = null;\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  final Set<Class> enumClasses = getEnumerationClasses();\n+  final Set<Method> methods =\n+      Stream.of(\n+              DbStorageEnums.class.getDeclaredMethods(),\n+              CommonStorageEnums.class.getDeclaredMethods())\n+          .flatMap(Stream::of)", "originalCommit": "31815dd38be5ab7247929732ea984e650d879735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyOTY0OA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382829648", "bodyText": "These are old-school [ ] arrays so concat can't handle them", "author": "jmthibault79", "createdAt": "2020-02-21T22:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNTQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNTYzMw==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382825633", "bodyText": "nit:  looks like this comment got detached", "author": "jaycarlton", "createdAt": "2020-02-21T21:59:09Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -1,42 +1,117 @@\n package org.pmiops.workbench.db.model;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n+import org.pmiops.workbench.model.Domain;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n+  private final Object INDICATES_STATIC_METHOD = null;\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  final Set<Class> enumClasses = getEnumerationClasses();\n+  final Set<Method> methods =\n+      Stream.of(\n+              DbStorageEnums.class.getDeclaredMethods(),\n+              CommonStorageEnums.class.getDeclaredMethods())\n+          .flatMap(Stream::of)\n+          .collect(Collectors.toSet());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+  // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+  final Map<Class, Method> enumClassToStorageMethod =\n+      methods.stream()\n+          // domainToDomainId is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainToDomainId\"))\n+          .filter(m -> enumClasses.contains(firstMethodParameterType(m)))\n+          .collect(Collectors.toMap(this::firstMethodParameterType, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+  // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+  final Map<Type, Method> storageMethodToEnumClass =\n+      methods.stream()\n+          // domainIdToDomain is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainIdToDomain\"))\n+          .filter(m -> enumClasses.contains(m.getReturnType()))\n+          .collect(Collectors.toMap(Method::getReturnType, m -> m));\n \n-      for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+  // special-case test for domain ID round trip", "originalCommit": "31815dd38be5ab7247929732ea984e650d879735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNjAwMg==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382826002", "bodyText": "nit: I'd put v on the right, since it's the known quantity and not the experimental quantity.", "author": "jaycarlton", "createdAt": "2020-02-21T22:00:13Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -1,42 +1,117 @@\n package org.pmiops.workbench.db.model;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n+import org.pmiops.workbench.model.Domain;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n+  private final Object INDICATES_STATIC_METHOD = null;\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  final Set<Class> enumClasses = getEnumerationClasses();\n+  final Set<Method> methods =\n+      Stream.of(\n+              DbStorageEnums.class.getDeclaredMethods(),\n+              CommonStorageEnums.class.getDeclaredMethods())\n+          .flatMap(Stream::of)\n+          .collect(Collectors.toSet());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+  // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+  final Map<Class, Method> enumClassToStorageMethod =\n+      methods.stream()\n+          // domainToDomainId is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainToDomainId\"))\n+          .filter(m -> enumClasses.contains(firstMethodParameterType(m)))\n+          .collect(Collectors.toMap(this::firstMethodParameterType, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+  // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+  final Map<Type, Method> storageMethodToEnumClass =\n+      methods.stream()\n+          // domainIdToDomain is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainIdToDomain\"))\n+          .filter(m -> enumClasses.contains(m.getReturnType()))\n+          .collect(Collectors.toMap(Method::getReturnType, m -> m));\n \n-      for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+  // special-case test for domain ID round trip\n+\n+  @Test\n+  public void test_domainId() {\n+    for (Domain v : Domain.values()) {\n+      String storageValue = CommonStorageEnums.domainToDomainId(v);\n+      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n+      assertThat(v).isEqualTo(CommonStorageEnums.domainIdToDomain(storageValue));", "originalCommit": "31815dd38be5ab7247929732ea984e650d879735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgzMDI0Mw==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382830243", "bodyText": "ok", "author": "jmthibault79", "createdAt": "2020-02-21T22:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNjAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNjU3Nw==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382826577", "bodyText": "nit: might be easier to read if you break it into the method lookup and invocation.", "author": "jaycarlton", "createdAt": "2020-02-21T22:01:39Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -1,42 +1,117 @@\n package org.pmiops.workbench.db.model;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n+import org.pmiops.workbench.model.Domain;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n+  private final Object INDICATES_STATIC_METHOD = null;\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  final Set<Class> enumClasses = getEnumerationClasses();\n+  final Set<Method> methods =\n+      Stream.of(\n+              DbStorageEnums.class.getDeclaredMethods(),\n+              CommonStorageEnums.class.getDeclaredMethods())\n+          .flatMap(Stream::of)\n+          .collect(Collectors.toSet());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+  // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+  final Map<Class, Method> enumClassToStorageMethod =\n+      methods.stream()\n+          // domainToDomainId is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainToDomainId\"))\n+          .filter(m -> enumClasses.contains(firstMethodParameterType(m)))\n+          .collect(Collectors.toMap(this::firstMethodParameterType, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+  // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+  final Map<Type, Method> storageMethodToEnumClass =\n+      methods.stream()\n+          // domainIdToDomain is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainIdToDomain\"))\n+          .filter(m -> enumClasses.contains(m.getReturnType()))\n+          .collect(Collectors.toMap(Method::getReturnType, m -> m));\n \n-      for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+  // special-case test for domain ID round trip\n+\n+  @Test\n+  public void test_domainId() {\n+    for (Domain v : Domain.values()) {\n+      String storageValue = CommonStorageEnums.domainToDomainId(v);\n+      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n+      assertThat(v).isEqualTo(CommonStorageEnums.domainIdToDomain(storageValue));\n+    }\n+  }\n \n-        assertThat(shortVal).named(enumClass.getName() + \":\" + e.toString()).isNotNull();\n-        assertThat(shortToEnum.invoke(null, shortVal)).isEqualTo(e);\n+  @Test\n+  public void test_noMissingMapEntries() throws InvocationTargetException, IllegalAccessException {\n+    for (final Class enumClass : enumClasses) {\n+      for (final Object enumValue : enumClass.getEnumConstants()) {\n+        Short shortValue = enumToStorage(enumValue, enumClass);\n+        assertThat(shortValue).named(enumClass.getName() + \":\" + enumValue.toString()).isNotNull();\n+        assertThat(storageToEnum(shortValue, enumClass)).isEqualTo(enumValue);\n       }\n     }\n   }\n+\n+  private Short enumToStorage(Object enumValue, Class enumClass)\n+      throws InvocationTargetException, IllegalAccessException {\n+    final Object returnValue =\n+        enumClassToStorageMethod.get(enumClass).invoke(INDICATES_STATIC_METHOD, enumValue);\n+    assertThat(returnValue instanceof Short).isTrue();\n+    return (Short) returnValue;\n+  }\n+\n+  private Object storageToEnum(Short shortValue, Class enumClass)\n+      throws InvocationTargetException, IllegalAccessException {\n+    return storageMethodToEnumClass.get(enumClass).invoke(INDICATES_STATIC_METHOD, shortValue);", "originalCommit": "31815dd38be5ab7247929732ea984e650d879735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgzMDg4Nw==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382830887", "bodyText": "ok", "author": "jmthibault79", "createdAt": "2020-02-21T22:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNjU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNjgyNA==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382826824", "bodyText": "nit: you might (later) also look for bimaps that don't have these properties and make noise, but I think it's ok.", "author": "jaycarlton", "createdAt": "2020-02-21T22:02:25Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -1,42 +1,117 @@\n package org.pmiops.workbench.db.model;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n+import org.pmiops.workbench.model.Domain;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n+  private final Object INDICATES_STATIC_METHOD = null;\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  final Set<Class> enumClasses = getEnumerationClasses();\n+  final Set<Method> methods =\n+      Stream.of(\n+              DbStorageEnums.class.getDeclaredMethods(),\n+              CommonStorageEnums.class.getDeclaredMethods())\n+          .flatMap(Stream::of)\n+          .collect(Collectors.toSet());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+  // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+  final Map<Class, Method> enumClassToStorageMethod =\n+      methods.stream()\n+          // domainToDomainId is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainToDomainId\"))\n+          .filter(m -> enumClasses.contains(firstMethodParameterType(m)))\n+          .collect(Collectors.toMap(this::firstMethodParameterType, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+  // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+  final Map<Type, Method> storageMethodToEnumClass =\n+      methods.stream()\n+          // domainIdToDomain is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainIdToDomain\"))\n+          .filter(m -> enumClasses.contains(m.getReturnType()))\n+          .collect(Collectors.toMap(Method::getReturnType, m -> m));\n \n-      for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+  // special-case test for domain ID round trip\n+\n+  @Test\n+  public void test_domainId() {\n+    for (Domain v : Domain.values()) {\n+      String storageValue = CommonStorageEnums.domainToDomainId(v);\n+      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n+      assertThat(v).isEqualTo(CommonStorageEnums.domainIdToDomain(storageValue));\n+    }\n+  }\n \n-        assertThat(shortVal).named(enumClass.getName() + \":\" + e.toString()).isNotNull();\n-        assertThat(shortToEnum.invoke(null, shortVal)).isEqualTo(e);\n+  @Test\n+  public void test_noMissingMapEntries() throws InvocationTargetException, IllegalAccessException {\n+    for (final Class enumClass : enumClasses) {\n+      for (final Object enumValue : enumClass.getEnumConstants()) {\n+        Short shortValue = enumToStorage(enumValue, enumClass);\n+        assertThat(shortValue).named(enumClass.getName() + \":\" + enumValue.toString()).isNotNull();\n+        assertThat(storageToEnum(shortValue, enumClass)).isEqualTo(enumValue);\n       }\n     }\n   }\n+\n+  private Short enumToStorage(Object enumValue, Class enumClass)\n+      throws InvocationTargetException, IllegalAccessException {\n+    final Object returnValue =\n+        enumClassToStorageMethod.get(enumClass).invoke(INDICATES_STATIC_METHOD, enumValue);\n+    assertThat(returnValue instanceof Short).isTrue();\n+    return (Short) returnValue;\n+  }\n+\n+  private Object storageToEnum(Short shortValue, Class enumClass)\n+      throws InvocationTargetException, IllegalAccessException {\n+    return storageMethodToEnumClass.get(enumClass).invoke(INDICATES_STATIC_METHOD, shortValue);\n+  }\n+\n+  /**\n+   * Retrieve all Enum classes in DbStorageEnums and CommonStorageEnums\n+   *\n+   * <p>our convention for BiMaps in DbStorageEnums/CommonStorageEnums is <Enum, Short> so we\n+   * retrieve the first parameterized type", "originalCommit": "31815dd38be5ab7247929732ea984e650d879735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgyNzI5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3159#discussion_r382827297", "bodyText": "nit: ordinarily I don't expect statements with side effects inside a map call. It's OK here.", "author": "jaycarlton", "createdAt": "2020-02-21T22:03:45Z", "path": "api/src/test/java/org/pmiops/workbench/db/model/StorageEnumsTest.java", "diffHunk": "@@ -1,42 +1,117 @@\n package org.pmiops.workbench.db.model;\n \n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n \n import com.google.common.collect.BiMap;\n-import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Test;\n+import org.pmiops.workbench.model.Domain;\n \n public class StorageEnumsTest {\n-  @Test\n-  public void noMissingMapEntries() throws Exception {\n-    for (Field f : DbStorageEnums.class.getDeclaredFields()) {\n-      if (f.getType() != BiMap.class) {\n-        continue;\n-      }\n+  private final Object INDICATES_STATIC_METHOD = null;\n \n-      Class enumClass =\n-          (Class) ((ParameterizedType) f.getAnnotatedType().getType()).getActualTypeArguments()[0];\n+  final Set<Class> enumClasses = getEnumerationClasses();\n+  final Set<Method> methods =\n+      Stream.of(\n+              DbStorageEnums.class.getDeclaredMethods(),\n+              CommonStorageEnums.class.getDeclaredMethods())\n+          .flatMap(Stream::of)\n+          .collect(Collectors.toSet());\n \n-      Method enumToShort = null;\n-      Method shortToEnum = null;\n-      for (Method m : DbStorageEnums.class.getDeclaredMethods()) {\n-        if (m.getParameterTypes()[0].equals(enumClass)) {\n-          enumToShort = m;\n-        }\n+  // e.g. public static Short reviewStatusToStorage(ReviewStatus s)\n+  final Map<Class, Method> enumClassToStorageMethod =\n+      methods.stream()\n+          // domainToDomainId is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainToDomainId\"))\n+          .filter(m -> enumClasses.contains(firstMethodParameterType(m)))\n+          .collect(Collectors.toMap(this::firstMethodParameterType, m -> m));\n \n-        if (m.getReturnType().equals(enumClass)) {\n-          shortToEnum = m;\n-        }\n-      }\n+  // e.g. public static ReviewStatus reviewStatusFromStorage(Short s)\n+  final Map<Type, Method> storageMethodToEnumClass =\n+      methods.stream()\n+          // domainIdToDomain is stringly typed - test with test_domainId\n+          .filter(m -> !m.getName().equals(\"domainIdToDomain\"))\n+          .filter(m -> enumClasses.contains(m.getReturnType()))\n+          .collect(Collectors.toMap(Method::getReturnType, m -> m));\n \n-      for (Object e : enumClass.getEnumConstants()) {\n-        Short shortVal = (Short) enumToShort.invoke(null, e);\n+  // special-case test for domain ID round trip\n+\n+  @Test\n+  public void test_domainId() {\n+    for (Domain v : Domain.values()) {\n+      String storageValue = CommonStorageEnums.domainToDomainId(v);\n+      assertWithMessage(\"unmapped enum value: \" + v).that(storageValue).isNotNull();\n+      assertThat(v).isEqualTo(CommonStorageEnums.domainIdToDomain(storageValue));\n+    }\n+  }\n \n-        assertThat(shortVal).named(enumClass.getName() + \":\" + e.toString()).isNotNull();\n-        assertThat(shortToEnum.invoke(null, shortVal)).isEqualTo(e);\n+  @Test\n+  public void test_noMissingMapEntries() throws InvocationTargetException, IllegalAccessException {\n+    for (final Class enumClass : enumClasses) {\n+      for (final Object enumValue : enumClass.getEnumConstants()) {\n+        Short shortValue = enumToStorage(enumValue, enumClass);\n+        assertThat(shortValue).named(enumClass.getName() + \":\" + enumValue.toString()).isNotNull();\n+        assertThat(storageToEnum(shortValue, enumClass)).isEqualTo(enumValue);\n       }\n     }\n   }\n+\n+  private Short enumToStorage(Object enumValue, Class enumClass)\n+      throws InvocationTargetException, IllegalAccessException {\n+    final Object returnValue =\n+        enumClassToStorageMethod.get(enumClass).invoke(INDICATES_STATIC_METHOD, enumValue);\n+    assertThat(returnValue instanceof Short).isTrue();\n+    return (Short) returnValue;\n+  }\n+\n+  private Object storageToEnum(Short shortValue, Class enumClass)\n+      throws InvocationTargetException, IllegalAccessException {\n+    return storageMethodToEnumClass.get(enumClass).invoke(INDICATES_STATIC_METHOD, shortValue);\n+  }\n+\n+  /**\n+   * Retrieve all Enum classes in DbStorageEnums and CommonStorageEnums\n+   *\n+   * <p>our convention for BiMaps in DbStorageEnums/CommonStorageEnums is <Enum, Short> so we\n+   * retrieve the first parameterized type\n+   *\n+   * @return\n+   */\n+  private Set<Class> getEnumerationClasses() {\n+    return Stream.of(\n+            DbStorageEnums.class.getDeclaredFields(), CommonStorageEnums.class.getDeclaredFields())\n+        .flatMap(Stream::of)\n+        .filter(field -> field.getType().equals(BiMap.class))\n+        .map(\n+            field -> {\n+              // gets the specific BiMap type including annotations\n+              final Type biMapType = field.getAnnotatedType().getType();\n+\n+              // need a ParameterizedType to access the type arguments\n+              assertThat(biMapType instanceof ParameterizedType).isTrue();", "originalCommit": "31815dd38be5ab7247929732ea984e650d879735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dcfc6a779b70c115b30964a5d6166f27e078ec29", "url": "https://github.com/all-of-us/workbench/commit/dcfc6a779b70c115b30964a5d6166f27e078ec29", "message": "PR comments", "committedDate": "2020-02-21T22:13:34Z", "type": "commit"}]}