{"pr_number": 1145, "pr_title": "New baseline-class-uniqueness.lock file allows incremental adoption", "pr_createdAt": "2020-01-07T15:54:18Z", "pr_url": "https://github.com/palantir/gradle-baseline/pull/1145", "timeline": [{"oid": "9331a712897492ef4626840ccd6f91431384161c", "url": "https://github.com/palantir/gradle-baseline/commit/9331a712897492ef4626840ccd6f91431384161c", "message": "mvp BaselineClassUniquenessLockPlugin", "committedDate": "2020-01-07T13:31:23Z", "type": "commit"}, {"oid": "a1e2eb08a8db3aef3aceb4e825659e22ce668ad6", "url": "https://github.com/palantir/gradle-baseline/commit/a1e2eb08a8db3aef3aceb4e825659e22ce668ad6", "message": "Nicer lockfile format", "committedDate": "2020-01-07T13:49:50Z", "type": "commit"}, {"oid": "b3ea88856d64a3ee6fe210cc7bf24f06e608a74e", "url": "https://github.com/palantir/gradle-baseline/commit/b3ea88856d64a3ee6fe210cc7bf24f06e608a74e", "message": "More concise if there's only one configuration", "committedDate": "2020-01-07T13:52:33Z", "type": "commit"}, {"oid": "df143b8137c248a1a1b7479006c00f46872ce419", "url": "https://github.com/palantir/gradle-baseline/commit/df143b8137c248a1a1b7479006c00f46872ce419", "message": "Nicer lockfile if everything passes", "committedDate": "2020-01-07T14:04:58Z", "type": "commit"}, {"oid": "c0e97c041751a65166d5369c1f4c3c3c84adc26c", "url": "https://github.com/palantir/gradle-baseline/commit/c0e97c041751a65166d5369c1f4c3c3c84adc26c", "message": "Get rid of version numbers", "committedDate": "2020-01-07T14:25:03Z", "type": "commit"}, {"oid": "c866962618ff4a7ce0a4a51261c75a6612e3c5be", "url": "https://github.com/palantir/gradle-baseline/commit/c866962618ff4a7ce0a4a51261c75a6612e3c5be", "message": "File doesn't exist if there are no problems", "committedDate": "2020-01-07T15:01:04Z", "type": "commit"}, {"oid": "b5c0689e0284444a86847dc58ffbd00dcd5fe609", "url": "https://github.com/palantir/gradle-baseline/commit/b5c0689e0284444a86847dc58ffbd00dcd5fe609", "message": "Factor out ClassUniquenessLockTask", "committedDate": "2020-01-07T15:17:45Z", "type": "commit"}, {"oid": "efac5145ecfce51b25605082b4b525ec4be1d02a", "url": "https://github.com/palantir/gradle-baseline/commit/efac5145ecfce51b25605082b4b525ec4be1d02a", "message": "Merge into the original plugin", "committedDate": "2020-01-07T15:24:21Z", "type": "commit"}, {"oid": "7f8419bab4dd9bf91f487577c9f3f4b0e99867d3", "url": "https://github.com/palantir/gradle-baseline/commit/7f8419bab4dd9bf91f487577c9f3f4b0e99867d3", "message": "Why not make it a cacheable task", "committedDate": "2020-01-07T15:34:23Z", "type": "commit"}, {"oid": "e478bc36556c980c48e7a003cd0065a113cb4a9b", "url": "https://github.com/palantir/gradle-baseline/commit/e478bc36556c980c48e7a003cd0065a113cb4a9b", "message": "Checkstyle", "committedDate": "2020-01-07T15:34:58Z", "type": "commit"}, {"oid": "0d09ffd4b6057cbb1cd38fba3fada2d3e6577ec0", "url": "https://github.com/palantir/gradle-baseline/commit/0d09ffd4b6057cbb1cd38fba3fada2d3e6577ec0", "message": "Appease validatePlugins", "committedDate": "2020-01-07T16:03:34Z", "type": "commit"}, {"oid": "234d8a35441f6bc38f07d0526a72727b59efaa8c", "url": "https://github.com/palantir/gradle-baseline/commit/234d8a35441f6bc38f07d0526a72727b59efaa8c", "message": "Mention task name in the README", "committedDate": "2020-01-07T16:13:25Z", "type": "commit"}, {"oid": "623a7555290d05e764fd5282369c78f96bebfd7a", "url": "https://github.com/palantir/gradle-baseline/commit/623a7555290d05e764fd5282369c78f96bebfd7a", "message": "Add generated changelog entries", "committedDate": "2020-01-07T16:13:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NjEyMA==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363846120", "bodyText": "just string is fine", "author": "dansanduleac", "createdAt": "2020-01-07T16:53:42Z", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/BaselineClassUniquenessPlugin.java", "diffHunk": "@@ -17,27 +17,37 @@\n package com.palantir.baseline.plugins;\n \n import com.palantir.baseline.plugins.rules.BaselineClassUniquenessRule;\n+import com.palantir.baseline.tasks.ClassUniquenessLockTask;\n import org.gradle.api.Project;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.language.base.plugins.LifecycleBasePlugin;\n \n /**\n- * This plugin is similar to https://github.com/nebula-plugins/gradle-lint-plugin/wiki/Duplicate-Classes-Rule\n- * but goes one step further and actually hashes any identically named classfiles to figure out if they're\n- * <i>completely</i> identical (and therefore safely interchangeable).\n+ * This plugin is similar to https://github.com/nebula-plugins/gradle-lint-plugin/wiki/Duplicate-Classes-Rule but goes\n+ * one step further and actually hashes any identically named classfiles to figure out if they're <i>completely</i>\n+ * identical (and therefore safely interchangeable).\n  *\n- * The task only fails if it finds classes which have the same name but different implementations.\n+ * <p>The task only fails if it finds classes which have the same name but different implementations.\n  */\n public class BaselineClassUniquenessPlugin extends AbstractBaselinePlugin {\n     @Override\n     public final void apply(Project project) {\n-        BaselineClassUniquenessRule rule = new BaselineClassUniquenessRule(project);\n+        TaskProvider<ClassUniquenessLockTask> lockTask =\n+                project.getTasks().register(\"checkClassUniquenessLock\", ClassUniquenessLockTask.class);\n+        project.getPlugins().apply(LifecycleBasePlugin.class);\n+        project.getTasks().getByName(LifecycleBasePlugin.CHECK_TASK_NAME).dependsOn(lockTask);\n \n+        // TODO(dfox): is this 'rule' redundant now? maybe replace it with a kinda strict mode?\n+        BaselineClassUniquenessRule rule = new BaselineClassUniquenessRule(project);\n         project.getTasks().addRule(rule);\n \n         project.getPlugins().withId(\"java\", plugin -> {\n+            lockTask.configure(t -> t.configurations.add(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME));\n+\n             String checkRuntimeClasspathTask = \"checkRuntimeClasspathClassUniqueness\";\n             rule.apply(checkRuntimeClasspathTask);\n-            project.getTasks().getByName(\"check\")\n-                    .dependsOn(project.getTasks().getByName(checkRuntimeClasspathTask));\n+            project.getTasks().getByName(\"check\").dependsOn(project.getTasks().getByName(checkRuntimeClasspathTask));", "originalCommit": "623a7555290d05e764fd5282369c78f96bebfd7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NjcyMQ==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363846721", "bodyText": "let's get rid of the rule", "author": "dansanduleac", "createdAt": "2020-01-07T16:54:58Z", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/BaselineClassUniquenessPlugin.java", "diffHunk": "@@ -17,27 +17,37 @@\n package com.palantir.baseline.plugins;\n \n import com.palantir.baseline.plugins.rules.BaselineClassUniquenessRule;\n+import com.palantir.baseline.tasks.ClassUniquenessLockTask;\n import org.gradle.api.Project;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.language.base.plugins.LifecycleBasePlugin;\n \n /**\n- * This plugin is similar to https://github.com/nebula-plugins/gradle-lint-plugin/wiki/Duplicate-Classes-Rule\n- * but goes one step further and actually hashes any identically named classfiles to figure out if they're\n- * <i>completely</i> identical (and therefore safely interchangeable).\n+ * This plugin is similar to https://github.com/nebula-plugins/gradle-lint-plugin/wiki/Duplicate-Classes-Rule but goes\n+ * one step further and actually hashes any identically named classfiles to figure out if they're <i>completely</i>\n+ * identical (and therefore safely interchangeable).\n  *\n- * The task only fails if it finds classes which have the same name but different implementations.\n+ * <p>The task only fails if it finds classes which have the same name but different implementations.\n  */\n public class BaselineClassUniquenessPlugin extends AbstractBaselinePlugin {\n     @Override\n     public final void apply(Project project) {\n-        BaselineClassUniquenessRule rule = new BaselineClassUniquenessRule(project);\n+        TaskProvider<ClassUniquenessLockTask> lockTask =\n+                project.getTasks().register(\"checkClassUniquenessLock\", ClassUniquenessLockTask.class);\n+        project.getPlugins().apply(LifecycleBasePlugin.class);\n+        project.getTasks().getByName(LifecycleBasePlugin.CHECK_TASK_NAME).dependsOn(lockTask);\n \n+        // TODO(dfox): is this 'rule' redundant now? maybe replace it with a kinda strict mode?\n+        BaselineClassUniquenessRule rule = new BaselineClassUniquenessRule(project);", "originalCommit": "623a7555290d05e764fd5282369c78f96bebfd7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0ODgzNw==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363848837", "bodyText": "I think we may want to provide a different message if new duplicates appear vs when problems are fixed, or mention here that it's dangerous to have duplicate classes on the classpath and explain why it's worth spending time to fix.\nOtherwise I think folks will see \"run X to update locks\" and they'll ./X.", "author": "carterkozak", "createdAt": "2020-01-07T16:59:10Z", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/tasks/ClassUniquenessLockTask.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.baseline.tasks;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Task;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.provider.SetProperty;\n+import org.gradle.api.specs.Spec;\n+import org.gradle.api.tasks.CacheableTask;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.util.GFileUtils;\n+\n+@CacheableTask\n+@SuppressWarnings(\"VisibilityModifier\")\n+public class ClassUniquenessLockTask extends DefaultTask {\n+\n+    // not marking this as an Input, because we want to re-run if the *contents* of a configuration changes\n+    private final File lockFile;\n+    public final SetProperty<String> configurations;\n+\n+    public ClassUniquenessLockTask() {\n+        this.configurations = getProject().getObjects().setProperty(String.class);\n+        this.lockFile = getProject().file(\"baseline-class-uniqueness.lock\");\n+        onlyIf(new Spec<Task>() {\n+            @Override\n+            public boolean isSatisfiedBy(Task task) {\n+                return !configurations.get().isEmpty();\n+            }\n+        });\n+    }\n+\n+    /**\n+     * This method exists purely for up-to-dateness purposes - we want to re-run if the contents of a configuration\n+     * changes.\n+     */\n+    @Input\n+    public final Map<String, ImmutableList<String>> getContentsOfAllConfigurations() {\n+        return configurations.get().stream().collect(Collectors.toMap(Function.identity(), name -> {\n+            Configuration configuration = getProject().getConfigurations().getByName(name);\n+            return configuration.getIncoming().getResolutionResult().getAllComponents().stream()\n+                    .map(resolvedComponentResult -> resolvedComponentResult.getModuleVersion().toString())\n+                    .collect(ImmutableList.toImmutableList()); // Gradle requires this to be Serializable\n+        }));\n+    }\n+\n+    @OutputFile\n+    public final File getLockFile() {\n+        return lockFile;\n+    }\n+\n+    @TaskAction\n+    public final void doIt() {\n+        Map<String, Optional<String>> resultsByConfiguration = configurations.get().stream()\n+                .collect(Collectors.toMap(Function.identity(), configurationName -> {\n+                    ClassUniquenessAnalyzer analyzer = new ClassUniquenessAnalyzer(getProject().getLogger());\n+                    Configuration configuration = getProject().getConfigurations().getByName(configurationName);\n+                    analyzer.analyzeConfiguration(configuration);\n+                    Collection<Set<ModuleVersionIdentifier>> problemJars = analyzer.getDifferingProblemJars();\n+\n+                    if (problemJars.isEmpty()) {\n+                        return Optional.empty();\n+                    }\n+\n+                    StringBuilder stringBuilder = new StringBuilder();\n+                    // TODO(dfox): ensure we iterate through problemJars in a stable order\n+                    for (Set<ModuleVersionIdentifier> clashingJars : problemJars) {\n+                        stringBuilder\n+                                .append(clashingJars.stream()\n+                                        .map(mvi -> mvi.getGroup() + \":\" + mvi.getName())\n+                                        .sorted()\n+                                        .collect(Collectors.joining(\", \", \"[\", \"]\")))\n+                                .append('\\n');\n+\n+                        analyzer.getDifferingSharedClassesInProblemJars(clashingJars).stream()\n+                                .sorted()\n+                                .forEach(className -> {\n+                                    stringBuilder.append(\"  - \");\n+                                    stringBuilder.append(className);\n+                                    stringBuilder.append('\\n');\n+                                });\n+                    }\n+                    return Optional.of(stringBuilder.toString());\n+                }));\n+\n+        boolean conflictsFound = resultsByConfiguration.values().stream().anyMatch(Optional::isPresent);\n+        if (!conflictsFound) {\n+            // this is desirable because if means if people apply the plugin to lots of projects which are already\n+            // compliant, they don't get loads of noisy lockfiles created.\n+            ensureLockfileDoesNotExist();\n+        } else {\n+            StringBuilder stringBuilder = new StringBuilder();\n+            stringBuilder.append(\"# Run ./gradlew checkClassUniquenessLock --write-locks to update this file\\n\\n\");\n+            // TODO(dfox): make configuration order stable!\n+            resultsByConfiguration.forEach((configuration, contents) -> {\n+                if (contents.isPresent()) {\n+                    stringBuilder.append(\"## \").append(configuration).append(\"\\n\");\n+                    stringBuilder.append(contents.get());\n+                }\n+            });\n+            ensureLockfileContains(stringBuilder.toString());\n+        }\n+    }\n+\n+    private void ensureLockfileContains(String expected) {\n+        if (getProject().getGradle().getStartParameter().isWriteDependencyLocks()) {\n+            GFileUtils.writeFile(expected, lockFile);\n+            getLogger().lifecycle(\"Updated {}\", getProject().getRootDir().toPath().relativize(lockFile.toPath()));\n+        } else {\n+            String onDisk = GFileUtils.readFile(lockFile);\n+            if (!onDisk.equals(expected)) {\n+                throw new GradleException(lockFile\n+                        + \" is out of date, please run `./gradlew \"\n+                        + \"checkClassUniquenessLock --write-locks` to update this file\");", "originalCommit": "623a7555290d05e764fd5282369c78f96bebfd7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "468acacb9de0932d6bdd81d4e0b31e0a1a3c74b7", "url": "https://github.com/palantir/gradle-baseline/commit/468acacb9de0932d6bdd81d4e0b31e0a1a3c74b7", "message": "Delete rule entirely", "committedDate": "2020-01-07T17:16:29Z", "type": "commit"}, {"oid": "691150e756888d81e4ddd1afcac324e493e37994", "url": "https://github.com/palantir/gradle-baseline/commit/691150e756888d81e4ddd1afcac324e493e37994", "message": "Rename to simplify", "committedDate": "2020-01-07T17:16:29Z", "type": "commit"}, {"oid": "72a5deebb91d6233f660befad337cd3c671e60da", "url": "https://github.com/palantir/gradle-baseline/commit/72a5deebb91d6233f660befad337cd3c671e60da", "message": "Might as well just store configurations", "committedDate": "2020-01-07T17:20:03Z", "type": "commit"}, {"oid": "cc64ddbadb59d4c63a3934359fd89239dc3838fd", "url": "https://github.com/palantir/gradle-baseline/commit/cc64ddbadb59d4c63a3934359fd89239dc3838fd", "message": "Check in an example of the lockfile", "committedDate": "2020-01-07T17:29:51Z", "type": "commit"}, {"oid": "f34a748050010b3e29ddf2590ba527da51c69b99", "url": "https://github.com/palantir/gradle-baseline/commit/f34a748050010b3e29ddf2590ba527da51c69b99", "message": "Include 'Danger!' in the lockfile", "committedDate": "2020-01-07T17:34:10Z", "type": "commit"}, {"oid": "f34a748050010b3e29ddf2590ba527da51c69b99", "url": "https://github.com/palantir/gradle-baseline/commit/f34a748050010b3e29ddf2590ba527da51c69b99", "message": "Include 'Danger!' in the lockfile", "committedDate": "2020-01-07T17:34:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2MzMzMg==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363863332", "bodyText": "We're losing the ability to easily verify the class uniqueness on different configurations. This could be valuable when running tests since you could inadvertently test with different classes than what exists at runtime.", "author": "ferozco", "createdAt": "2020-01-07T17:31:57Z", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/BaselineClassUniquenessPlugin.java", "diffHunk": "@@ -16,28 +16,30 @@\n \n package com.palantir.baseline.plugins;\n \n-import com.palantir.baseline.plugins.rules.BaselineClassUniquenessRule;\n+import com.palantir.baseline.tasks.CheckClassUniquenessLockTask;\n import org.gradle.api.Project;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.language.base.plugins.LifecycleBasePlugin;\n \n /**\n- * This plugin is similar to https://github.com/nebula-plugins/gradle-lint-plugin/wiki/Duplicate-Classes-Rule\n- * but goes one step further and actually hashes any identically named classfiles to figure out if they're\n- * <i>completely</i> identical (and therefore safely interchangeable).\n+ * This plugin is similar to https://github.com/nebula-plugins/gradle-lint-plugin/wiki/Duplicate-Classes-Rule but goes\n+ * one step further and actually hashes any identically named classfiles to figure out if they're <i>completely</i>\n+ * identical (and therefore safely interchangeable).\n  *\n- * The task only fails if it finds classes which have the same name but different implementations.\n+ * <p>The task only fails if it finds classes which have the same name but different implementations.\n  */\n public class BaselineClassUniquenessPlugin extends AbstractBaselinePlugin {\n     @Override\n     public final void apply(Project project) {\n-        BaselineClassUniquenessRule rule = new BaselineClassUniquenessRule(project);\n-\n-        project.getTasks().addRule(rule);\n+        TaskProvider<CheckClassUniquenessLockTask> lockTask =\n+                project.getTasks().register(\"checkClassUniqueness\", CheckClassUniquenessLockTask.class);\n+        project.getPlugins().apply(LifecycleBasePlugin.class);\n+        project.getTasks().getByName(LifecycleBasePlugin.CHECK_TASK_NAME).dependsOn(lockTask);\n \n         project.getPlugins().withId(\"java\", plugin -> {\n-            String checkRuntimeClasspathTask = \"checkRuntimeClasspathClassUniqueness\";\n-            rule.apply(checkRuntimeClasspathTask);\n-            project.getTasks().getByName(\"check\")\n-                    .dependsOn(project.getTasks().getByName(checkRuntimeClasspathTask));\n+            lockTask.configure(t -> t.configurations.add(", "originalCommit": "72a5deebb91d6233f660befad337cd3c671e60da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2Nzk1OA==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363867958", "bodyText": "I actually preserved this functionality because I remember @raiju specifically added it, you just have to add the configurations you want as per:\ncheckClassUniqueness {\n  configurations.add project.configurations.myConf\n}\nThen they'll be analyzed and will appear in the lockfile", "author": "iamdanfox", "createdAt": "2020-01-07T17:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2MzMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NTUxMg==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363865512", "bodyText": "you might want to copy https://github.com/palantir/metric-schema/blob/develop/gradle-metric-schema/src/main/java/com/palantir/metric/schema/gradle/MetricSchemaMarkdownPlugin.java#L46 so that ./gradlew --write-locks also updates the lockfile", "author": "ferozco", "createdAt": "2020-01-07T17:37:24Z", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/plugins/BaselineClassUniquenessPlugin.java", "diffHunk": "@@ -16,28 +16,30 @@\n \n package com.palantir.baseline.plugins;\n \n-import com.palantir.baseline.plugins.rules.BaselineClassUniquenessRule;\n+import com.palantir.baseline.tasks.CheckClassUniquenessLockTask;\n import org.gradle.api.Project;\n+import org.gradle.api.plugins.JavaPlugin;\n+import org.gradle.api.tasks.TaskProvider;\n+import org.gradle.language.base.plugins.LifecycleBasePlugin;\n \n /**\n- * This plugin is similar to https://github.com/nebula-plugins/gradle-lint-plugin/wiki/Duplicate-Classes-Rule\n- * but goes one step further and actually hashes any identically named classfiles to figure out if they're\n- * <i>completely</i> identical (and therefore safely interchangeable).\n+ * This plugin is similar to https://github.com/nebula-plugins/gradle-lint-plugin/wiki/Duplicate-Classes-Rule but goes\n+ * one step further and actually hashes any identically named classfiles to figure out if they're <i>completely</i>\n+ * identical (and therefore safely interchangeable).\n  *\n- * The task only fails if it finds classes which have the same name but different implementations.\n+ * <p>The task only fails if it finds classes which have the same name but different implementations.\n  */\n public class BaselineClassUniquenessPlugin extends AbstractBaselinePlugin {\n     @Override\n     public final void apply(Project project) {\n-        BaselineClassUniquenessRule rule = new BaselineClassUniquenessRule(project);\n-\n-        project.getTasks().addRule(rule);\n+        TaskProvider<CheckClassUniquenessLockTask> lockTask =\n+                project.getTasks().register(\"checkClassUniqueness\", CheckClassUniquenessLockTask.class);\n+        project.getPlugins().apply(LifecycleBasePlugin.class);\n+        project.getTasks().getByName(LifecycleBasePlugin.CHECK_TASK_NAME).dependsOn(lockTask);\n \n         project.getPlugins().withId(\"java\", plugin -> {\n-            String checkRuntimeClasspathTask = \"checkRuntimeClasspathClassUniqueness\";\n-            rule.apply(checkRuntimeClasspathTask);\n-            project.getTasks().getByName(\"check\")\n-                    .dependsOn(project.getTasks().getByName(checkRuntimeClasspathTask));\n+            lockTask.configure(t -> t.configurations.add(", "originalCommit": "f34a748050010b3e29ddf2590ba527da51c69b99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2ODUzOQ==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363868539", "bodyText": "I was a bit torn about this, because all our other --write-locks operations are pretty fast, but this one involves actually unpacking every single jar in your classpath. On the one hand a single entrypoint is quite nice, but also I think we really want people to acknowledge these and make a conscious decision to fix or not fix.", "author": "iamdanfox", "createdAt": "2020-01-07T17:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NTUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg4MzQ1Mg==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363883452", "bodyText": "ya fair enough, my concern is that not having it linked to --write-locks will block excavators since the lockfile will not automatically be updated", "author": "ferozco", "createdAt": "2020-01-07T18:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NTUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg5MDczNA==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363890734", "bodyText": "Ok I've just copied and pasted that in so that ./gradlew --write-locks will run it.  Will make our excavators simpler, but it might make local dev a bit slower", "author": "iamdanfox", "createdAt": "2020-01-07T18:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NTUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NjAxOQ==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363866019", "bodyText": "shouldn't the contents only change if a dependency on the configuration changes?", "author": "ferozco", "createdAt": "2020-01-07T17:38:34Z", "path": "gradle-baseline-java/src/main/groovy/com/palantir/baseline/tasks/CheckClassUniquenessLockTask.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.baseline.tasks;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.Task;\n+import org.gradle.api.artifacts.Configuration;\n+import org.gradle.api.artifacts.ModuleVersionIdentifier;\n+import org.gradle.api.provider.SetProperty;\n+import org.gradle.api.specs.Spec;\n+import org.gradle.api.tasks.CacheableTask;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.OutputFile;\n+import org.gradle.api.tasks.TaskAction;\n+import org.gradle.util.GFileUtils;\n+\n+@CacheableTask\n+public class CheckClassUniquenessLockTask extends DefaultTask {\n+\n+    private static final String HEADER = \"# Danger! Multiple jars contain identically named classes. This may \"\n+            + \"cause different behaviour depending on classpath ordering.\\n\"\n+            + \"# Run ./gradlew checkClassUniqueness --write-locks to update this file\\n\\n\";\n+\n+    // not marking this as an Input, because we want to re-run if the *contents* of a configuration changes", "originalCommit": "f34a748050010b3e29ddf2590ba527da51c69b99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2ODc3Mw==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363868773", "bodyText": "Configurations are not Serializable, so I can't just mark a list of them as an @Input.", "author": "iamdanfox", "createdAt": "2020-01-07T17:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NjAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg4Mjc4MQ==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363882781", "bodyText": "you can take the configuration as an input by annotating it with @classpath", "author": "ferozco", "createdAt": "2020-01-07T18:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NjAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg4NTYzNA==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363885634", "bodyText": "I think that @classpath annotation would work if I had just a single configuration, but in order to preserve the ability to analyze multiple configurations, I don't have just one single configuration here but a bunch of them?", "author": "iamdanfox", "createdAt": "2020-01-07T18:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NjAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg5MjAyNw==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363892027", "bodyText": "Instead of storing a set of configurations could you create a single configuration which extends from all of the provided configurations", "author": "ferozco", "createdAt": "2020-01-07T18:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NjAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg5MjkxOQ==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363892919", "bodyText": "I dunno, it seems that has a slight risk of false positives... e.g. if we're analyzing two configurations foo and bar and we move a jar from foo -> bar.  In the big clobbered configuration there would be no change, but actually I would expect the lockfile to change.", "author": "iamdanfox", "createdAt": "2020-01-07T18:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NjAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg5NDIzOA==", "url": "https://github.com/palantir/gradle-baseline/pull/1145#discussion_r363894238", "bodyText": "ok no big deal", "author": "ferozco", "createdAt": "2020-01-07T18:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2NjAxOQ=="}], "type": "inlineReview"}, {"oid": "8a17aecc9dc95a484b2114acf33d65099a18af32", "url": "https://github.com/palantir/gradle-baseline/commit/8a17aecc9dc95a484b2114acf33d65099a18af32", "message": "Don't always recreate", "committedDate": "2020-01-07T17:49:04Z", "type": "commit"}]}