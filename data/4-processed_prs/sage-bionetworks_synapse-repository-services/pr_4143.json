{"pr_number": 4143, "pr_title": "PLFM-6299: Process access approval revocations", "pr_createdAt": "2020-07-20T22:07:43Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143", "timeline": [{"oid": "ae73eebb6ca29aa26f1f7441d4a0c5962a652252", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/ae73eebb6ca29aa26f1f7441d4a0c5962a652252", "message": "PLFM-6299: Initial skeleton to send access revocation notifications", "committedDate": "2020-07-20T22:02:12Z", "type": "commit"}, {"oid": "bbbdd35e6d3c28e18829c6413a65ce2c91a3412c", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/bbbdd35e6d3c28e18829c6413a65ce2c91a3412c", "message": "PLFM-6299: Added new manager to handle features status", "committedDate": "2020-07-20T22:02:23Z", "type": "commit"}, {"oid": "073cd1504df724483d8b1ba235b1acdd2b2c7199", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/073cd1504df724483d8b1ba235b1acdd2b2c7199", "message": "PLFM-6299: Refactor to use the feature status manager", "committedDate": "2020-07-20T22:02:23Z", "type": "commit"}, {"oid": "a3ffd4fec5f9c6d2dd6f183492a78f67004500b3", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a3ffd4fec5f9c6d2dd6f183492a78f67004500b3", "message": "PLFM-6299: SenOn from long to timestamp", "committedDate": "2020-07-20T23:12:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc3NDQ3OA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r457774478", "bodyText": "is this needed?", "author": "john-hill", "createdAt": "2020-07-21T01:01:12Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/dataaccess/AccessApprovalNotificationManagerImpl.java", "diffHunk": "@@ -0,0 +1,300 @@\n+package org.sagebionetworks.repo.manager.dataaccess;\r\n+\r\n+import java.io.IOException;\r\n+import java.time.Instant;\r\n+import java.time.temporal.ChronoUnit;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.logging.log4j.LogManager;\r\n+import org.apache.logging.log4j.Logger;\r\n+import org.sagebionetworks.repo.manager.MessageManager;\r\n+import org.sagebionetworks.repo.manager.UserManager;\r\n+import org.sagebionetworks.repo.manager.dataaccess.notifications.DataAccessNotificationBuilder;\r\n+import org.sagebionetworks.repo.manager.feature.FeatureManager;\r\n+import org.sagebionetworks.repo.manager.file.FileHandleManager;\r\n+import org.sagebionetworks.repo.manager.stack.ProdDetector;\r\n+import org.sagebionetworks.repo.model.AccessApproval;\r\n+import org.sagebionetworks.repo.model.AccessApprovalDAO;\r\n+import org.sagebionetworks.repo.model.AccessRequirement;\r\n+import org.sagebionetworks.repo.model.AccessRequirementDAO;\r\n+import org.sagebionetworks.repo.model.ApprovalState;\r\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\r\n+import org.sagebionetworks.repo.model.ManagedACTAccessRequirement;\r\n+import org.sagebionetworks.repo.model.ObjectType;\r\n+import org.sagebionetworks.repo.model.UserInfo;\r\n+import org.sagebionetworks.repo.model.dataaccess.DataAccessNotificationType;\r\n+import org.sagebionetworks.repo.model.dbo.dao.dataaccess.DataAccessNotificationDao;\r\n+import org.sagebionetworks.repo.model.dbo.feature.Feature;\r\n+import org.sagebionetworks.repo.model.message.BroadcastMessageDao;\r\n+import org.sagebionetworks.repo.model.message.ChangeMessage;\r\n+import org.sagebionetworks.repo.model.message.ChangeType;\r\n+import org.sagebionetworks.repo.model.message.MessageToUser;\r\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\r\n+import org.sagebionetworks.util.ValidateArgument;\r\n+import org.sagebionetworks.workers.util.aws.message.RecoverableMessageException;\r\n+import org.springframework.beans.factory.annotation.Autowired;\r\n+import org.springframework.stereotype.Service;\r\n+\r\n+@Service\r\n+public class AccessApprovalNotificationManagerImpl implements AccessApprovalNotificationManager {\r\n+\t\r\n+\tprivate static final Logger LOG = LogManager.getLogger(AccessApprovalNotificationManagerImpl.class);\r\n+\r\n+\t// TODO: Notifications configuration should be stored in the DB, including the resend timeout and\r\n+\t// eventually the reminder period so that it can be changed later if needed in the DB\r\n+\t\r\n+\t// Do not re-send another notification if one was sent already within the last 7 days\r\n+\tprivate static final long REVOKED_RESEND_TIMEOUT_DAYS = 7;\r\n+\t\r\n+\t// Do not process a change message if it's older than 24 hours\r\n+\tprivate static final long CHANGE_TIMEOUT_HOURS = 24;\r\n+\t\r\n+\t// Fake id for messages to that are not actually created\r\n+\tprivate static final long NO_MESSAGE_TO_USER = -1;\r\n+\r\n+\tprivate BroadcastMessageDao broadcastMessageDao;\r\n+\tprivate UserManager userManager;\r\n+\tprivate DataAccessNotificationDao notificationDao;\r\n+\tprivate AccessApprovalDAO accessApprovalDao;\r\n+\tprivate AccessRequirementDAO accessRequirementDao;\r\n+\tprivate FileHandleManager fileHandleManager;\r\n+\tprivate MessageManager messageManager;\r\n+\tprivate FeatureManager featureManager;\r\n+\tprivate ProdDetector prodDetector;\r\n+\r\n+\tprivate Map<DataAccessNotificationType, DataAccessNotificationBuilder> notificationBuilders;\r\n+\r\n+\t@Autowired\r\n+\tpublic AccessApprovalNotificationManagerImpl(\r\n+\t\t\tfinal UserManager userManager, \r\n+\t\t\tfinal BroadcastMessageDao broadcastMessageDao,\r\n+\t\t\tfinal DataAccessNotificationDao notificationDao, \r\n+\t\t\tfinal AccessApprovalDAO accessApprovalDao,\r\n+\t\t\tfinal AccessRequirementDAO accessRequirementDao, \r\n+\t\t\tfinal FileHandleManager fileHandleManager,\r\n+\t\t\tfinal MessageManager messageManager, \r\n+\t\t\tfinal FeatureManager featureTesting,\r\n+\t\t\tfinal ProdDetector prodDetector) {\r\n+\t\tthis.broadcastMessageDao = broadcastMessageDao;\r\n+\t\tthis.userManager = userManager;\r\n+\t\tthis.notificationDao = notificationDao;\r\n+\t\tthis.accessApprovalDao = accessApprovalDao;\r\n+\t\tthis.accessRequirementDao = accessRequirementDao;\r\n+\t\tthis.fileHandleManager = fileHandleManager;\r\n+\t\tthis.messageManager = messageManager;\r\n+\t\tthis.featureManager = featureTesting;\r\n+\t\tthis.prodDetector = prodDetector;\r\n+\t}\r\n+\r\n+\t@Autowired(required = false)\r\n+\tpublic void configureDataAccessNotificationBuilders(List<DataAccessNotificationBuilder> builders) {\r\n+\t\tnotificationBuilders = new HashMap<>(DataAccessNotificationType.values().length);\r\n+\r\n+\t\tfor (DataAccessNotificationBuilder builder : builders) {\r\n+\t\t\tfor (DataAccessNotificationType supportedType : builder.supportedTypes()) {\r\n+\t\t\t\tif (notificationBuilders.containsKey(supportedType)) {\r\n+\t\t\t\t\tthrow new IllegalStateException(\r\n+\t\t\t\t\t\t\t\"A notification builder for type \" + supportedType + \" is already registred.\");\r\n+\t\t\t\t}\r\n+\t\t\t\tnotificationBuilders.put(supportedType, builder);\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\t@WriteTransaction\r\n+\tpublic void processAccessApprovalChange(ChangeMessage message) throws RecoverableMessageException {\r\n+\t\tValidateArgument.required(message, \"The change message\");\r\n+\r\n+\t\t// Should we process this change?\r\n+\t\tif (discardChangeMessage(message)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Register the change as processed so that is not processed again (changes are sent multiple times)\r\n+\t\tbroadcastMessageDao.setBroadcast(message.getChangeNumber());\r\n+\t\t\r\n+\t\tAccessApproval approval = accessApprovalDao.get(message.getObjectId());\r\n+\r\n+\t\tUserInfo recipient = getRecipientForRevocation(approval);\r\n+\r\n+\t\t// Should we process this approval change?\r\n+\t\tif (discardAccessApproval(approval, recipient)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\r\n+\t\t// Send the notification\r\n+\t\tsendNotification(DataAccessNotificationType.REVOCATION, approval, recipient);\r\n+\t}\r\n+\r\n+\tboolean discardChangeMessage(ChangeMessage change) {\r\n+\t\t\r\n+\t\t// Check if it's an ACCESS_APPROVAL message\r\n+\t\tif (!ObjectType.ACCESS_APPROVAL.equals(change.getObjectType())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Process only UPDATES\r\n+\t\tif (!ChangeType.UPDATE.equals(change.getChangeType())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Discard old changes\r\n+\t\tif (change.getTimestamp().toInstant().isBefore(Instant.now().minus(CHANGE_TIMEOUT_HOURS, ChronoUnit.HOURS))) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\r\n+\t\t// Check if the message was already processed\r\n+\t\tif (broadcastMessageDao.wasBroadcast(change.getChangeNumber())) {\r", "originalCommit": "a3ffd4fec5f9c6d2dd6f183492a78f67004500b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4MzcxMg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r457783712", "bodyText": "this cannot be increased without adding additional race condition logic to the worker", "author": "john-hill", "createdAt": "2020-07-21T01:33:55Z", "path": "services/workers/src/main/resources/dataaccess-worker-spb.xml", "diffHunk": "@@ -44,4 +44,42 @@\n \t\t<property name=\"repeatInterval\" value=\"30000\" />\r\n \t</bean>\r\n \t\r\n+\t<!-- This worker will process change messages from access approvals in order to send a notification if needed -->\r\n+\t<bean id=\"accessApprovalRevokedNotificationWorker\" class=\"org.sagebionetworks.dataaccess.workers.AccessApprovalRevokedNotificationWorker\" scope=\"singleton\" />\r\n+\t\r\n+\t<bean id=\"accessApprovalRevokedNotificationTrigger\" class=\"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\"\r\n+\t\tscope=\"singleton\">\r\n+\t\t<property name=\"jobDetail\">\r\n+\t\t\t<bean\r\n+\t\t\t\tclass=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">\r\n+\t\t\t\t<property name=\"targetObject\">\r\n+\t\t\t\t\t<bean\r\n+\t\t\t\t\t\tclass=\"org.sagebionetworks.asynchronous.workers.changes.ChangeMessageDrivenWorkerStack\">\r\n+\t\t\t\t\t\t<constructor-arg index=\"0\" ref=\"countingSemaphore\" />\r\n+\t\t\t\t\t\t<constructor-arg index=\"1\" ref=\"awsSQSClient\" />\r\n+\t\t\t\t\t\t<constructor-arg index=\"2\">\r\n+\t\t\t\t\t\t\t<bean\r\n+\t\t\t\t\t\t\t\tclass=\"org.sagebionetworks.asynchronous.workers.changes.ChangeMessageDrivenWorkerStackConfig\">\r\n+\t\t\t\t\t\t\t\t<property name=\"runner\" ref=\"accessApprovalRevokedNotificationWorker\" />\r\n+\t\t\t\t\t\t\t\t<property name=\"semaphoreLockKey\" value=\"accessApprovalRevokedNotificationWorker\" />\r\n+\t\t\t\t\t\t\t\t<property name=\"semaphoreMaxLockCount\" value=\"1\" />\r", "originalCommit": "a3ffd4fec5f9c6d2dd6f183492a78f67004500b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4NjczOQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r457786739", "bodyText": "if not prod and test user and feature enable still needs to work", "author": "john-hill", "createdAt": "2020-07-21T01:45:08Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/dataaccess/AccessApprovalNotificationManagerImpl.java", "diffHunk": "@@ -0,0 +1,300 @@\n+package org.sagebionetworks.repo.manager.dataaccess;\r\n+\r\n+import java.io.IOException;\r\n+import java.time.Instant;\r\n+import java.time.temporal.ChronoUnit;\r\n+import java.util.Collections;\r\n+import java.util.Date;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.logging.log4j.LogManager;\r\n+import org.apache.logging.log4j.Logger;\r\n+import org.sagebionetworks.repo.manager.MessageManager;\r\n+import org.sagebionetworks.repo.manager.UserManager;\r\n+import org.sagebionetworks.repo.manager.dataaccess.notifications.DataAccessNotificationBuilder;\r\n+import org.sagebionetworks.repo.manager.feature.FeatureManager;\r\n+import org.sagebionetworks.repo.manager.file.FileHandleManager;\r\n+import org.sagebionetworks.repo.manager.stack.ProdDetector;\r\n+import org.sagebionetworks.repo.model.AccessApproval;\r\n+import org.sagebionetworks.repo.model.AccessApprovalDAO;\r\n+import org.sagebionetworks.repo.model.AccessRequirement;\r\n+import org.sagebionetworks.repo.model.AccessRequirementDAO;\r\n+import org.sagebionetworks.repo.model.ApprovalState;\r\n+import org.sagebionetworks.repo.model.AuthorizationConstants.BOOTSTRAP_PRINCIPAL;\r\n+import org.sagebionetworks.repo.model.ManagedACTAccessRequirement;\r\n+import org.sagebionetworks.repo.model.ObjectType;\r\n+import org.sagebionetworks.repo.model.UserInfo;\r\n+import org.sagebionetworks.repo.model.dataaccess.DataAccessNotificationType;\r\n+import org.sagebionetworks.repo.model.dbo.dao.dataaccess.DataAccessNotificationDao;\r\n+import org.sagebionetworks.repo.model.dbo.feature.Feature;\r\n+import org.sagebionetworks.repo.model.message.BroadcastMessageDao;\r\n+import org.sagebionetworks.repo.model.message.ChangeMessage;\r\n+import org.sagebionetworks.repo.model.message.ChangeType;\r\n+import org.sagebionetworks.repo.model.message.MessageToUser;\r\n+import org.sagebionetworks.repo.transactions.WriteTransaction;\r\n+import org.sagebionetworks.util.ValidateArgument;\r\n+import org.sagebionetworks.workers.util.aws.message.RecoverableMessageException;\r\n+import org.springframework.beans.factory.annotation.Autowired;\r\n+import org.springframework.stereotype.Service;\r\n+\r\n+@Service\r\n+public class AccessApprovalNotificationManagerImpl implements AccessApprovalNotificationManager {\r\n+\t\r\n+\tprivate static final Logger LOG = LogManager.getLogger(AccessApprovalNotificationManagerImpl.class);\r\n+\r\n+\t// TODO: Notifications configuration should be stored in the DB, including the resend timeout and\r\n+\t// eventually the reminder period so that it can be changed later if needed in the DB\r\n+\t\r\n+\t// Do not re-send another notification if one was sent already within the last 7 days\r\n+\tprivate static final long REVOKED_RESEND_TIMEOUT_DAYS = 7;\r\n+\t\r\n+\t// Do not process a change message if it's older than 24 hours\r\n+\tprivate static final long CHANGE_TIMEOUT_HOURS = 24;\r\n+\t\r\n+\t// Fake id for messages to that are not actually created\r\n+\tprivate static final long NO_MESSAGE_TO_USER = -1;\r\n+\r\n+\tprivate BroadcastMessageDao broadcastMessageDao;\r\n+\tprivate UserManager userManager;\r\n+\tprivate DataAccessNotificationDao notificationDao;\r\n+\tprivate AccessApprovalDAO accessApprovalDao;\r\n+\tprivate AccessRequirementDAO accessRequirementDao;\r\n+\tprivate FileHandleManager fileHandleManager;\r\n+\tprivate MessageManager messageManager;\r\n+\tprivate FeatureManager featureManager;\r\n+\tprivate ProdDetector prodDetector;\r\n+\r\n+\tprivate Map<DataAccessNotificationType, DataAccessNotificationBuilder> notificationBuilders;\r\n+\r\n+\t@Autowired\r\n+\tpublic AccessApprovalNotificationManagerImpl(\r\n+\t\t\tfinal UserManager userManager, \r\n+\t\t\tfinal BroadcastMessageDao broadcastMessageDao,\r\n+\t\t\tfinal DataAccessNotificationDao notificationDao, \r\n+\t\t\tfinal AccessApprovalDAO accessApprovalDao,\r\n+\t\t\tfinal AccessRequirementDAO accessRequirementDao, \r\n+\t\t\tfinal FileHandleManager fileHandleManager,\r\n+\t\t\tfinal MessageManager messageManager, \r\n+\t\t\tfinal FeatureManager featureTesting,\r\n+\t\t\tfinal ProdDetector prodDetector) {\r\n+\t\tthis.broadcastMessageDao = broadcastMessageDao;\r\n+\t\tthis.userManager = userManager;\r\n+\t\tthis.notificationDao = notificationDao;\r\n+\t\tthis.accessApprovalDao = accessApprovalDao;\r\n+\t\tthis.accessRequirementDao = accessRequirementDao;\r\n+\t\tthis.fileHandleManager = fileHandleManager;\r\n+\t\tthis.messageManager = messageManager;\r\n+\t\tthis.featureManager = featureTesting;\r\n+\t\tthis.prodDetector = prodDetector;\r\n+\t}\r\n+\r\n+\t@Autowired(required = false)\r\n+\tpublic void configureDataAccessNotificationBuilders(List<DataAccessNotificationBuilder> builders) {\r\n+\t\tnotificationBuilders = new HashMap<>(DataAccessNotificationType.values().length);\r\n+\r\n+\t\tfor (DataAccessNotificationBuilder builder : builders) {\r\n+\t\t\tfor (DataAccessNotificationType supportedType : builder.supportedTypes()) {\r\n+\t\t\t\tif (notificationBuilders.containsKey(supportedType)) {\r\n+\t\t\t\t\tthrow new IllegalStateException(\r\n+\t\t\t\t\t\t\t\"A notification builder for type \" + supportedType + \" is already registred.\");\r\n+\t\t\t\t}\r\n+\t\t\t\tnotificationBuilders.put(supportedType, builder);\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t}\r\n+\r\n+\t@Override\r\n+\t@WriteTransaction\r\n+\tpublic void processAccessApprovalChange(ChangeMessage message) throws RecoverableMessageException {\r\n+\t\tValidateArgument.required(message, \"The change message\");\r\n+\r\n+\t\t// Should we process this change?\r\n+\t\tif (discardChangeMessage(message)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Register the change as processed so that is not processed again (changes are sent multiple times)\r\n+\t\tbroadcastMessageDao.setBroadcast(message.getChangeNumber());\r\n+\t\t\r\n+\t\tAccessApproval approval = accessApprovalDao.get(message.getObjectId());\r\n+\r\n+\t\tUserInfo recipient = getRecipientForRevocation(approval);\r\n+\r\n+\t\t// Should we process this approval change?\r\n+\t\tif (discardAccessApproval(approval, recipient)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\r\n+\t\t// Send the notification\r\n+\t\tsendNotification(DataAccessNotificationType.REVOCATION, approval, recipient);\r\n+\t}\r\n+\r\n+\tboolean discardChangeMessage(ChangeMessage change) {\r\n+\t\t\r\n+\t\t// Check if it's an ACCESS_APPROVAL message\r\n+\t\tif (!ObjectType.ACCESS_APPROVAL.equals(change.getObjectType())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Process only UPDATES\r\n+\t\tif (!ChangeType.UPDATE.equals(change.getChangeType())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Discard old changes\r\n+\t\tif (change.getTimestamp().toInstant().isBefore(Instant.now().minus(CHANGE_TIMEOUT_HOURS, ChronoUnit.HOURS))) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\r\n+\t\t// Check if the message was already processed\r\n+\t\tif (broadcastMessageDao.wasBroadcast(change.getChangeNumber())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn false;\r\n+\t}\r\n+\t\r\n+\tboolean discardAccessApproval(AccessApproval approval, UserInfo recipient) {\r\n+\t\t// Do not process approvals that are not revoked\r\n+\t\tif (!ApprovalState.REVOKED.equals(approval.getState())) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\tfinal Long requirementId = approval.getRequirementId();\r\n+\t\t\r\n+\t\tString accessRequirementType = accessRequirementDao.getConcreteType(requirementId.toString());\r\n+\r\n+\t\t// Does not process notifications for non-managed access requirements\r\n+\t\tif (!ManagedACTAccessRequirement.class.getName().equals(accessRequirementType)) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\r\n+\t\t// Check if a revocation was already sent to the user for this requirement\r\n+\t\tOptional<Instant> sent = notificationDao.getSentOn(DataAccessNotificationType.REVOCATION, requirementId, recipient.getId());\r\n+\r\n+\t\tif (sent.isPresent()) {\r\n+\r\n+\t\t\tInstant sentOn = sent.get();\r\n+\t\t\tInstant approvalModifiedOn = approval.getModifiedOn().toInstant();\r\n+\r\n+\t\t\t// If it was sent after the approval modification then it was already processed\r\n+\t\t\tif (sentOn.isAfter(approvalModifiedOn)) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\t// The approval was modified after the notification was sent (e.g. the user was added back and revoked again)\r\n+\t\t\t// We do not want to re-send another notification if the last one for the same approval was within the last week\r\n+\t\t\tif (sentOn.isAfter(approvalModifiedOn.minus(REVOKED_RESEND_TIMEOUT_DAYS, ChronoUnit.DAYS))) {\r\n+\t\t\t\treturn true;\r\n+\t\t\t}\r\n+\r\n+\t\t}\r\n+\r\n+\t\t// We need to check if an APPROVED access approval exists already for the same access requirement, in such a case\r\n+\t\t// there is no need to send a notification as the user is still considered APPROVED\r\n+\t\tif (!accessApprovalDao.listApprovalsByAccessor(requirementId.toString(), recipient.getId().toString()).isEmpty()) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\tvoid sendNotification(DataAccessNotificationType notificationType, AccessApproval approval, UserInfo recipient) throws RecoverableMessageException {\r\n+\t\tLong messageId;\r\n+\t\tInstant sentOn;\r\n+\t\t\r\n+\t\tif (deliverMessage(approval, recipient)) {\r\n+\t\t\tMessageToUser messageToUser = sendMessageToUser(notificationType, approval, recipient);\r\n+\t\t\tmessageId = Long.valueOf(messageToUser.getId());\r\n+\t\t\tsentOn = messageToUser.getCreatedOn().toInstant();\r\n+\t\t} else {\r\n+\t\t\t// We do not deliver, but we still want to record the notification to avoid re-processing it\r\n+\t\t\tLOG.warn(\"{} notification (AR: {}, Recipient: {}, AP: {}) will not be delivered\", notificationType, approval.getRequirementId(), recipient.getId(), approval.getId());\r\n+\t\t\tmessageId = NO_MESSAGE_TO_USER;\r\n+\t\t\tsentOn = Instant.now();\r\n+\t\t}\r\n+\t\t\r\n+\t\tnotificationDao.registerNotification(notificationType, approval.getRequirementId(), recipient.getId(), approval.getId(), messageId, sentOn);\r\n+\t\r\n+\t}\r\n+\t\r\n+\tMessageToUser sendMessageToUser(DataAccessNotificationType notificationType, AccessApproval approval, UserInfo recipient) {\r\n+\r\n+\t\tDataAccessNotificationBuilder notificationBuidler = getNotificationBuilder(notificationType);\r\n+\t\t\r\n+\t\tAccessRequirement accessRequirement = accessRequirementDao.get(approval.getRequirementId().toString());\r\n+\t\t\r\n+\t\tif (!(accessRequirement instanceof ManagedACTAccessRequirement)) {\r\n+\t\t\tthrow new IllegalStateException(\"Cannot sent a notification for a non managed access requirement\");\r\n+\t\t}\r\n+\t\t\r\n+\t\tManagedACTAccessRequirement managedAccessRequriement = (ManagedACTAccessRequirement) accessRequirement;\r\n+\r\n+\t\tUserInfo notificationsSender = getNotificationsSender();\r\n+\t\t\r\n+\t\tString sender = notificationsSender.getId().toString();\r\n+\t\tString messageBody = notificationBuidler.buildMessageBody(managedAccessRequriement, approval);\r\n+\t\tString mimeType = notificationBuidler.getMimeType();\r\n+\t\tString subject = notificationBuidler.buildSubject(managedAccessRequriement, approval);\r\n+\t\tString fileHandleId = storeNotificationBody(sender, messageBody, mimeType);\r\n+\r\n+\t\tMessageToUser message = new MessageToUser();\r\n+\r\n+\t\tmessage.setSubject(subject);\r\n+\t\tmessage.setCreatedBy(sender);\r\n+\t\tmessage.setIsNotificationMessage(false);\r\n+\t\tmessage.setWithUnsubscribeLink(false);\r\n+\t\tmessage.setWithProfileSettingLink(false);\r\n+\t\tmessage.setFileHandleId(fileHandleId);\r\n+\t\tmessage.setRecipients(Collections.singleton(recipient.getId().toString()));\r\n+\r\n+\t\tboolean overrideNotificationSettings = true;\r\n+\r\n+\t\treturn messageManager.createMessage(notificationsSender, message, overrideNotificationSettings);\r\n+\t}\r\n+\t\r\n+\tUserInfo getNotificationsSender() {\r\n+\t\treturn userManager.getUserInfo(BOOTSTRAP_PRINCIPAL.DATA_ACCESS_NOTFICATIONS_SENDER.getPrincipalId());\r\n+\t}\r\n+\r\n+\tboolean deliverMessage(AccessApproval approval, UserInfo recipient) throws RecoverableMessageException {\r\n+\t\t// Checks if the feature is enabled first for the given recipient\r\n+\t\tif (featureManager.isFeatureEnabledForUser(Feature.DATA_ACCESS_RENEWALS, recipient)) {\r\n+\t\t\treturn true;\r\n+\t\t}\r\n+\t\t\r\n+\t\t// Once the feature is enabled we can process the notification only on production as we do not want\r\n+\t\t// to send duplicated messages from prod/staging\r\n+\t\treturn prodDetector.isProductionStack().orElseThrow(() -> \r\n+\t\t\tnew RecoverableMessageException(\"Cannot detect current stack\")\r", "originalCommit": "a3ffd4fec5f9c6d2dd6f183492a78f67004500b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bbc053a6bf8152b1717afe49c96fe6261f27aba6", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/bbc053a6bf8152b1717afe49c96fe6261f27aba6", "message": "PLFM-6299: Fix for potential rare race condition", "committedDate": "2020-07-21T07:52:14Z", "type": "commit"}, {"oid": "1fedce4275873888f767ded155998869112a2992", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/1fedce4275873888f767ded155998869112a2992", "message": "PLFM-6299: Improve documentation", "committedDate": "2020-07-21T16:43:00Z", "type": "commit"}, {"oid": "e26f9e76d837d7e0c91b6f9a87f22c4ec0cc106d", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e26f9e76d837d7e0c91b6f9a87f22c4ec0cc106d", "message": "PLFM-6299: Complete unit test for manager layer", "committedDate": "2020-07-21T21:00:41Z", "type": "commit"}, {"oid": "756d8bcde841065a51d0a995ea80fbf2f3cb5dd8", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/756d8bcde841065a51d0a995ea80fbf2f3cb5dd8", "message": "PLFM-6299: Check for the access type of the AR", "committedDate": "2020-07-21T21:43:37Z", "type": "commit"}, {"oid": "8b8b7ad40bd7d8aa91fdc04bdca642136d4d4192", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/8b8b7ad40bd7d8aa91fdc04bdca642136d4d4192", "message": "PLFM-6299: Add revoke notification message builder", "committedDate": "2020-07-22T00:43:39Z", "type": "commit"}, {"oid": "102463313862b020ae34b79dc385ba2a8259b77d", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/102463313862b020ae34b79dc385ba2a8259b77d", "message": "PLFM-6299: Fix missing hashCode & equals", "committedDate": "2020-07-22T02:14:49Z", "type": "commit"}, {"oid": "82143a82deb59ba4b21a4d9489c3d87899739983", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/82143a82deb59ba4b21a4d9489c3d87899739983", "message": "PLFM-6299: List submissions by submitter", "committedDate": "2020-07-22T03:10:55Z", "type": "commit"}, {"oid": "462fa26b880eb3204739c29c51d08bffb180257d", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/462fa26b880eb3204739c29c51d08bffb180257d", "message": "PLFM-6299: Needs to fetch the submission of an approval", "committedDate": "2020-07-22T04:29:21Z", "type": "forcePushed"}, {"oid": "a7f1d3f9778cca6e4240d344f7a85d5eeb872cbf", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a7f1d3f9778cca6e4240d344f7a85d5eeb872cbf", "message": "PLFM-6299: Needs to fetch the submission of an approval", "committedDate": "2020-07-22T04:49:48Z", "type": "commit"}, {"oid": "a7f1d3f9778cca6e4240d344f7a85d5eeb872cbf", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a7f1d3f9778cca6e4240d344f7a85d5eeb872cbf", "message": "PLFM-6299: Needs to fetch the submission of an approval", "committedDate": "2020-07-22T04:49:48Z", "type": "forcePushed"}, {"oid": "ac83259426564043433dbbac1a4dfcc6cfe0df2d", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/ac83259426564043433dbbac1a4dfcc6cfe0df2d", "message": "PLFM-6299: The message id is not nullable", "committedDate": "2020-07-22T16:31:01Z", "type": "commit"}, {"oid": "cacaa0ffb03f202bf116e56670dfdbd9aa79be65", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/cacaa0ffb03f202bf116e56670dfdbd9aa79be65", "message": "Revert \"PLFM-6299: Needs to fetch the submission of an approval\"\n\nThis reverts commit a7f1d3f9778cca6e4240d344f7a85d5eeb872cbf.\n\nRevert \"PLFM-6299: List submissions by submitter\"\n\nThis reverts commit 82143a82deb59ba4b21a4d9489c3d87899739983.", "committedDate": "2020-07-22T16:37:34Z", "type": "commit"}, {"oid": "de2080b97ee68a9639e96e6eca51b8d27e0c5720", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/de2080b97ee68a9639e96e6eca51b8d27e0c5720", "message": "Added VelocityEngine as an exposed bean", "committedDate": "2020-07-22T17:23:14Z", "type": "commit"}, {"oid": "710ddd54c3f6ae519b8b8c0362a2cbcd6f3ed29c", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/710ddd54c3f6ae519b8b8c0362a2cbcd6f3ed29c", "message": "Email display name from first/last OR username", "committedDate": "2020-07-22T18:35:02Z", "type": "commit"}, {"oid": "e32aeef0bc10702f39d894ae6221d48ee4249923", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e32aeef0bc10702f39d894ae6221d48ee4249923", "message": "PLFM-6299: Switched to using velocity for email templates", "committedDate": "2020-07-22T18:48:08Z", "type": "commit"}, {"oid": "a7ac997a5d266ef5eafae61e85313e001f98eafe", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a7ac997a5d266ef5eafae61e85313e001f98eafe", "message": "PLFM-6299: Split notification and auto-revoke features", "committedDate": "2020-07-22T18:53:50Z", "type": "commit"}, {"oid": "3b500dd24a3023f3201bc0967588814fddb36ea7", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/3b500dd24a3023f3201bc0967588814fddb36ea7", "message": "PLFM-6299: Added integration test for notification worker", "committedDate": "2020-07-22T19:49:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1NjE1MA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r459056150", "bodyText": "better name", "author": "john-hill", "createdAt": "2020-07-22T20:14:37Z", "path": "lib/lib-auto-generated/src/main/resources/schema/org/sagebionetworks/repo/model/dataaccess/DataAccessNotificationType.json", "diffHunk": "@@ -0,0 +1,18 @@\n+{\r\n+\t\"description\": \"Enumeration with the type of notification sent for data access approvals\",\r\n+    \"type\": \"string\",\r\n+    \"enum\": [\r\n+        {\r\n+            \"name\": \"RENEWAL_REMINDER_1\",\r", "originalCommit": "3b500dd24a3023f3201bc0967588814fddb36ea7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1MzgwMA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r459153800", "bodyText": "load from a file.", "author": "john-hill", "createdAt": "2020-07-23T00:17:59Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/dataaccess/notifications/AccessRevokedNotificationBuilderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.sagebionetworks.repo.manager.dataaccess.notifications;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.assertEquals;\r\n+import static org.mockito.ArgumentMatchers.any;\r\n+import static org.mockito.Mockito.when;\r\n+\r\n+import org.apache.commons.lang3.StringUtils;\r\n+import org.apache.velocity.app.VelocityEngine;\r\n+import org.junit.jupiter.api.BeforeEach;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.jupiter.api.extension.ExtendWith;\r\n+import org.mockito.Mock;\r\n+import org.mockito.junit.jupiter.MockitoExtension;\r\n+import org.sagebionetworks.repo.manager.UserProfileManager;\r\n+import org.sagebionetworks.repo.model.AccessApproval;\r\n+import org.sagebionetworks.repo.model.ManagedACTAccessRequirement;\r\n+import org.sagebionetworks.repo.model.UserInfo;\r\n+import org.sagebionetworks.repo.model.UserProfile;\r\n+import org.springframework.beans.factory.annotation.Autowired;\r\n+import org.springframework.test.context.ContextConfiguration;\r\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\r\n+\r\n+@ExtendWith(value = {SpringExtension.class, MockitoExtension.class})\r\n+@ContextConfiguration(\"classpath:test-context.xml\")\r\n+public class AccessRevokedNotificationBuilderIntegrationTest {\r\n+\t\r\n+\t@Autowired\r\n+\tprivate VelocityEngine velocity;\r\n+\t\r\n+\tprivate AccessRevokedNotificationBuilder builder;\r\n+\t\r\n+\t// We mock all this as we only want to test the final template output\r\n+\t@Mock\r\n+\tprivate UserProfileManager profileManager;\r\n+\t@Mock\r\n+\tprivate UserProfile mockProfile;\r\n+\t@Mock\r\n+\tprivate ManagedACTAccessRequirement accessRequirement;\r\n+\t@Mock\r\n+\tprivate AccessApproval approval;\r\n+\t@Mock\r\n+\tprivate UserInfo recipient;\r\n+\t\r\n+\t@BeforeEach\r\n+\tpublic void before() {\r\n+\t\tbuilder = new AccessRevokedNotificationBuilder(profileManager, velocity);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testBuildMessageBodyWithDescription() {\r\n+\t\t\r\n+\t\tLong recipientId = 4567L;\r\n+\t\tLong requirementId = 1234L;\r\n+\t\tString requirementDescription = \"Some Dataset\";\r\n+\t\tString firstName = \"First\";\r\n+\t\tString lastName = \"Second\";\r\n+\t\t\r\n+\t\twhen(recipient.getId()).thenReturn(recipientId);\r\n+\t\twhen(profileManager.getUserProfile(any())).thenReturn(mockProfile);\r\n+\t\twhen(mockProfile.getFirstName()).thenReturn(firstName);\r\n+\t\twhen(mockProfile.getLastName()).thenReturn(lastName);\r\n+\t\twhen(accessRequirement.getId()).thenReturn(requirementId);\r\n+\t\twhen(accessRequirement.getDescription()).thenReturn(requirementDescription);\r\n+\t\t\r\n+\t\tString expected = \"<html>\"\r", "originalCommit": "3b500dd24a3023f3201bc0967588814fddb36ea7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE1NDM1Ng==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4143#discussion_r459154356", "bodyText": "remove", "author": "john-hill", "createdAt": "2020-07-23T00:20:13Z", "path": "services/workers/src/main/java/org/sagebionetworks/dataaccess/workers/AccessApprovalRevokedNotificationWorker.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.sagebionetworks.dataaccess.workers;\r\n+\r\n+import org.apache.logging.log4j.LogManager;\r\n+import org.apache.logging.log4j.Logger;\r\n+import org.sagebionetworks.asynchronous.workers.changes.ChangeMessageDrivenRunner;\r\n+import org.sagebionetworks.common.util.progress.ProgressCallback;\r\n+import org.sagebionetworks.repo.manager.dataaccess.AccessApprovalNotificationManager;\r\n+import org.sagebionetworks.repo.manager.feature.FeatureManager;\r\n+import org.sagebionetworks.repo.model.ObjectType;\r\n+import org.sagebionetworks.repo.model.dbo.feature.Feature;\r\n+import org.sagebionetworks.repo.model.message.ChangeMessage;\r\n+import org.sagebionetworks.workers.util.aws.message.RecoverableMessageException;\r\n+import org.springframework.beans.factory.annotation.Autowired;\r\n+\r\n+/**\r\n+ * Worker that process {@link ObjectType#ACCESS_APPROVAL} changes to send\r\n+ * revocation notifications\r\n+ * \r\n+ * @author Marco Marasca\r\n+ *\r\n+ */\r\n+public class AccessApprovalRevokedNotificationWorker implements ChangeMessageDrivenRunner {\r\n+\r\n+\tprivate static final Logger LOG = LogManager.getLogger(AccessApprovalRevokedNotificationWorker.class);\r\n+\r\n+\tprivate AccessApprovalNotificationManager notificationManager;\r\n+\tprivate FeatureManager featureManager;\r\n+\r\n+\t@Autowired\r\n+\tpublic AccessApprovalRevokedNotificationWorker(final AccessApprovalNotificationManager notificationManager,\r\n+\t\t\tfinal FeatureManager featureManager) {\r\n+\t\tthis.notificationManager = notificationManager;\r\n+\t\tthis.featureManager = featureManager;\r\n+\t}\r\n+\r\n+\t@Override\r\n+\tpublic void run(ProgressCallback progressCallback, ChangeMessage message)\r\n+\t\t\tthrows RecoverableMessageException, Exception {\r\n+\t\t\r\n+\t\t// Feature not yet enabled\r\n+\t\tif (!featureManager.isFeatureEnabled(Feature.DATA_ACCESS_NOTIFICATIONS)) {\r\n+\t\t\treturn;\r\n+\t\t}\r\n+\t\t\r\n+\t\ttry {\r\n+\t\t\tnotificationManager.processAccessApprovalChange(message);\r\n+\t\t} catch (RecoverableMessageException e) {\r\n+\t\t\tSystem.out.println(\"Recoverable...\" + e.getMessage());\r", "originalCommit": "3b500dd24a3023f3201bc0967588814fddb36ea7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}