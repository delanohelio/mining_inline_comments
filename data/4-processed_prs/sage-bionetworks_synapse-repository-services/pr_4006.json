{"pr_number": 4006, "pr_title": "PLFM-5170 VI", "pr_createdAt": "2020-04-17T14:39:02Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006", "timeline": [{"oid": "b8683f6263bae017a015ed75cdc6dd9a27ab154c", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/b8683f6263bae017a015ed75cdc6dd9a27ab154c", "message": "PLFM-5170-VI", "committedDate": "2020-04-12T17:09:03Z", "type": "commit"}, {"oid": "fbd8f322fd99eff1cb4151e7fccc9afeb1701752", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/fbd8f322fd99eff1cb4151e7fccc9afeb1701752", "message": "PLFM-5170-VI", "committedDate": "2020-04-12T22:26:04Z", "type": "commit"}, {"oid": "935600bbe524434dcd88f2c54289bbc3888fe08a", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/935600bbe524434dcd88f2c54289bbc3888fe08a", "message": "PLFM-5170-VI", "committedDate": "2020-04-12T23:42:02Z", "type": "commit"}, {"oid": "5864c2c2e0505bddbb2b589959ef9486d025fd2a", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/5864c2c2e0505bddbb2b589959ef9486d025fd2a", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T00:52:40Z", "type": "commit"}, {"oid": "645edad753ca98ebdf549bd26db72219ec890043", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/645edad753ca98ebdf549bd26db72219ec890043", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T02:21:22Z", "type": "commit"}, {"oid": "77d014f99cd00dee2269a28e7b052824615203d6", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/77d014f99cd00dee2269a28e7b052824615203d6", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T03:54:47Z", "type": "commit"}, {"oid": "415bea710399c98002d17972b92b1d06b0f4ff02", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/415bea710399c98002d17972b92b1d06b0f4ff02", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T04:32:03Z", "type": "commit"}, {"oid": "95451d1c0916c16a7a84088850ec8b44eee4c72c", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/95451d1c0916c16a7a84088850ec8b44eee4c72c", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T13:42:57Z", "type": "commit"}, {"oid": "0b037152ef979a7a8147b876f012c734b29ca93c", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/0b037152ef979a7a8147b876f012c734b29ca93c", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T14:31:49Z", "type": "commit"}, {"oid": "6a10275affb25c530aeb108b2a9f8d3354809da2", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/6a10275affb25c530aeb108b2a9f8d3354809da2", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T15:45:26Z", "type": "commit"}, {"oid": "2fcc23b1b6b0681d47b6fe6aaa4d5be4f62a6029", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/2fcc23b1b6b0681d47b6fe6aaa4d5be4f62a6029", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T15:52:58Z", "type": "commit"}, {"oid": "f2c25f3acfec2da550d7f60728fea28d4600e056", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f2c25f3acfec2da550d7f60728fea28d4600e056", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T16:13:28Z", "type": "commit"}, {"oid": "007939f0b45dc43bd9b3b091aa4bc6ea7318e2da", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/007939f0b45dc43bd9b3b091aa4bc6ea7318e2da", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T18:21:45Z", "type": "commit"}, {"oid": "5b8aee56faf854b6b75d1aaa7985b4ff15a47f93", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/5b8aee56faf854b6b75d1aaa7985b4ff15a47f93", "message": "PLFM-5170-VI", "committedDate": "2020-04-13T23:41:47Z", "type": "commit"}, {"oid": "a90fb69a1c6b9e29ef9f82fdb796ddb6bef031c9", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a90fb69a1c6b9e29ef9f82fdb796ddb6bef031c9", "message": "PLFM-5170-VI", "committedDate": "2020-04-14T00:46:41Z", "type": "commit"}, {"oid": "e7134ca0408a3b82363a792dfbc40074d477299a", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e7134ca0408a3b82363a792dfbc40074d477299a", "message": "PLFM-5170-VI", "committedDate": "2020-04-14T01:05:55Z", "type": "commit"}, {"oid": "efd74196282fac9cd927a0f45405bce3e402b11a", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/efd74196282fac9cd927a0f45405bce3e402b11a", "message": "PLFM-5170-VI", "committedDate": "2020-04-14T02:40:16Z", "type": "commit"}, {"oid": "b545fbca2880c823a03fdc1c5f48013bd4db0eb8", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/b545fbca2880c823a03fdc1c5f48013bd4db0eb8", "message": "PLFM-5170-VI", "committedDate": "2020-04-14T18:05:26Z", "type": "commit"}, {"oid": "a9c91e3e34e005c98c256ba0eba00cbb8b1e7cd7", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a9c91e3e34e005c98c256ba0eba00cbb8b1e7cd7", "message": "PLFM-5170-VI", "committedDate": "2020-04-14T23:32:07Z", "type": "commit"}, {"oid": "ce77e62f89ab8759d8068b05c47e0a33f9952476", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/ce77e62f89ab8759d8068b05c47e0a33f9952476", "message": "PLFM-5170-VI", "committedDate": "2020-04-14T23:40:36Z", "type": "commit"}, {"oid": "9d8a20c5e7dd4d2e9206455fd4d8f37286b325fc", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/9d8a20c5e7dd4d2e9206455fd4d8f37286b325fc", "message": "PLFM-5170-VI", "committedDate": "2020-04-15T00:53:34Z", "type": "commit"}, {"oid": "7b4536f7d7c6015d14eb39580dbc26922caa4508", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/7b4536f7d7c6015d14eb39580dbc26922caa4508", "message": "PLFM-5170-VI", "committedDate": "2020-04-15T01:06:17Z", "type": "commit"}, {"oid": "740da20a59df34411c758663646dc7a9e44c91c1", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/740da20a59df34411c758663646dc7a9e44c91c1", "message": "PLFM-5170-VI", "committedDate": "2020-04-15T01:12:45Z", "type": "commit"}, {"oid": "0eda9b50653d0c4bbbb26b68a3813fd930d0553e", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/0eda9b50653d0c4bbbb26b68a3813fd930d0553e", "message": "PLFM-5170-VI", "committedDate": "2020-04-15T01:17:44Z", "type": "commit"}, {"oid": "8f632954aebba8f0c5940da54ad89b8a0c3ba2f7", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/8f632954aebba8f0c5940da54ad89b8a0c3ba2f7", "message": "PLFM-5170-VI", "committedDate": "2020-04-15T01:44:48Z", "type": "commit"}, {"oid": "f96bbb2c819605ec712a5c6abac4379b2c2be7de", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f96bbb2c819605ec712a5c6abac4379b2c2be7de", "message": "PLFM-5170-VI", "committedDate": "2020-04-17T14:37:59Z", "type": "commit"}, {"oid": "3900d19b24665180b7149ff38b32e1b314fae499", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/3900d19b24665180b7149ff38b32e1b314fae499", "message": "PLFM-5170-VI", "committedDate": "2020-04-17T14:48:38Z", "type": "commit"}, {"oid": "d15e52c920bc6b87b0362bdfb20032070657c0db", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/d15e52c920bc6b87b0362bdfb20032070657c0db", "message": "PLFM-5170-VI", "committedDate": "2020-04-17T17:49:36Z", "type": "commit"}, {"oid": "56e69b637c8277cfd24afcd58c21a8ca739d8959", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/56e69b637c8277cfd24afcd58c21a8ca739d8959", "message": "PLFM-5170-VI", "committedDate": "2020-04-17T17:58:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNDQxMQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410424411", "bodyText": "If the token is invalid it should return a 403", "author": "marcomarasca", "createdAt": "2020-04-17T19:23:02Z", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.sagebionetworks.auth.HttpAuthUtil;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+/*\n+ * For requests which require authentication (have a 'userId' parameter) and are not anonymous, \n+ * the scope in the access token is compared to the scope in the RequiredScope annotation \n+ * (default to full scope) and 403 status is returned if the required scope is not present.\n+ */\n+public class OAuthScopeInterceptor implements HandlerInterceptor {\n+\n+\t/*\n+\t * If a handler is not annotated with RequiredScope then, by default, it requires the following\n+\t */\n+\tprivate static final Set<OAuthScope> DEFAULT_SCOPES;\n+\tstatic {\n+\t\tDEFAULT_SCOPES = new HashSet<OAuthScope>(Arrays.asList(OAuthScope.values()));\n+\t\tDEFAULT_SCOPES.remove(OAuthScope.openid);\n+\t}\n+\n+\tprivate static final String ERROR_MESSAGE_PREFIX  = \"Request lacks scope(s) required by this service: \";\n+\t\n+\t@Autowired\n+\tprivate OIDCTokenHelper oidcTokenHelper;\n+\t\n+\tpublic static boolean hasUserIdParameterOrAccessTokenHeader(HandlerMethod handlerMethod) {\n+\t\tfor (MethodParameter methodParameter : handlerMethod.getMethodParameters()) {\n+\t\t\tRequestParam requestParam = methodParameter.getParameterAnnotation(RequestParam.class);\n+\t\t\tif (requestParam!=null && requestParam.value().equals(AuthorizationConstants.USER_ID_PARAM)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tRequestHeader requestHeader = methodParameter.getParameterAnnotation(RequestHeader.class);\n+\t\t\tif (requestHeader!=null && requestHeader.value().equals(SYNAPSE_AUTHORIZATION_HEADER_NAME)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\tpublic static boolean isAnonymous(HttpServletRequest request) {\n+\t\tString userIdRequestParameter = request.getParameter(AuthorizationConstants.USER_ID_PARAM);\n+\t\treturn userIdRequestParameter == null ||\n+\t\t\t\tAuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId()\n+\t\t\t\t\t.equals(Long.parseLong(userIdRequestParameter));\n+\t}\n+\n+\t@Override\n+\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+\t\t\tthrows Exception {\n+\t\t\n+\t\t// anonymous requests do not need to have scope checked, they have the same \n+\t\t// access that unauthenticated requests have\n+\t\tif (isAnonymous(request)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tSet<String> missingScopes = new TreeSet<String>();\n+\t\t{\n+\t\t\t// if no scopes are specified by an annotation on the method, then we use these defaults\n+\t\t\tSet<OAuthScope> requiredScopes = new TreeSet<OAuthScope>(DEFAULT_SCOPES);\n+\t\t\t\n+\t\t\tif (!(handler instanceof HandlerMethod)) {\n+\t\t\t\tthrow new IllegalStateException(\"Ths HandlerInterceptor should only be applied to HandlerMethods, but this handler is a \"+handler.getClass());\n+\t\t\t}\n+\t\t\t\n+\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n+\n+\t\t\t// if no 'userId' parameter or access token header then this is \n+\t\t\t// not an authenticated request, and no scope is required\n+\t\t\tif (!hasUserIdParameterOrAccessTokenHeader(handlerMethod)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tRequiredScope requiredScopeAnnotation = handlerMethod.getMethodAnnotation(RequiredScope.class);\n+\t\t\tif (requiredScopeAnnotation != null) {\n+\t\t\t\trequiredScopes = new HashSet<OAuthScope>(Arrays.asList(requiredScopeAnnotation.value()));\n+\t\t\t}\n+\n+\t\t\tList<OAuthScope> requestScopes = Collections.EMPTY_LIST;\n+\t\t\tString synapseAuthorizationHeader = request.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\t\tString accessToken = HttpAuthUtil.getBearerTokenFromAuthorizationHeader(synapseAuthorizationHeader);\n+\t\t\tif (accessToken!=null) {\n+\t\t\t\tJwt<JwsHeader, Claims> jwt = oidcTokenHelper.parseJWT(accessToken);", "originalCommit": "56e69b637c8277cfd24afcd58c21a8ca739d8959", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNjE4MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410426181", "bodyText": "We can compute the missing scopes when needed to build the error message and we can check on the requiredScopes.isEmpty() instead at line 121", "author": "marcomarasca", "createdAt": "2020-04-17T19:26:49Z", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.sagebionetworks.auth.HttpAuthUtil;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+/*\n+ * For requests which require authentication (have a 'userId' parameter) and are not anonymous, \n+ * the scope in the access token is compared to the scope in the RequiredScope annotation \n+ * (default to full scope) and 403 status is returned if the required scope is not present.\n+ */\n+public class OAuthScopeInterceptor implements HandlerInterceptor {\n+\n+\t/*\n+\t * If a handler is not annotated with RequiredScope then, by default, it requires the following\n+\t */\n+\tprivate static final Set<OAuthScope> DEFAULT_SCOPES;\n+\tstatic {\n+\t\tDEFAULT_SCOPES = new HashSet<OAuthScope>(Arrays.asList(OAuthScope.values()));\n+\t\tDEFAULT_SCOPES.remove(OAuthScope.openid);\n+\t}\n+\n+\tprivate static final String ERROR_MESSAGE_PREFIX  = \"Request lacks scope(s) required by this service: \";\n+\t\n+\t@Autowired\n+\tprivate OIDCTokenHelper oidcTokenHelper;\n+\t\n+\tpublic static boolean hasUserIdParameterOrAccessTokenHeader(HandlerMethod handlerMethod) {\n+\t\tfor (MethodParameter methodParameter : handlerMethod.getMethodParameters()) {\n+\t\t\tRequestParam requestParam = methodParameter.getParameterAnnotation(RequestParam.class);\n+\t\t\tif (requestParam!=null && requestParam.value().equals(AuthorizationConstants.USER_ID_PARAM)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tRequestHeader requestHeader = methodParameter.getParameterAnnotation(RequestHeader.class);\n+\t\t\tif (requestHeader!=null && requestHeader.value().equals(SYNAPSE_AUTHORIZATION_HEADER_NAME)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\tpublic static boolean isAnonymous(HttpServletRequest request) {\n+\t\tString userIdRequestParameter = request.getParameter(AuthorizationConstants.USER_ID_PARAM);\n+\t\treturn userIdRequestParameter == null ||\n+\t\t\t\tAuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId()\n+\t\t\t\t\t.equals(Long.parseLong(userIdRequestParameter));\n+\t}\n+\n+\t@Override\n+\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+\t\t\tthrows Exception {\n+\t\t\n+\t\t// anonymous requests do not need to have scope checked, they have the same \n+\t\t// access that unauthenticated requests have\n+\t\tif (isAnonymous(request)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tSet<String> missingScopes = new TreeSet<String>();\n+\t\t{\n+\t\t\t// if no scopes are specified by an annotation on the method, then we use these defaults\n+\t\t\tSet<OAuthScope> requiredScopes = new TreeSet<OAuthScope>(DEFAULT_SCOPES);\n+\t\t\t\n+\t\t\tif (!(handler instanceof HandlerMethod)) {\n+\t\t\t\tthrow new IllegalStateException(\"Ths HandlerInterceptor should only be applied to HandlerMethods, but this handler is a \"+handler.getClass());\n+\t\t\t}\n+\t\t\t\n+\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n+\n+\t\t\t// if no 'userId' parameter or access token header then this is \n+\t\t\t// not an authenticated request, and no scope is required\n+\t\t\tif (!hasUserIdParameterOrAccessTokenHeader(handlerMethod)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tRequiredScope requiredScopeAnnotation = handlerMethod.getMethodAnnotation(RequiredScope.class);\n+\t\t\tif (requiredScopeAnnotation != null) {\n+\t\t\t\trequiredScopes = new HashSet<OAuthScope>(Arrays.asList(requiredScopeAnnotation.value()));\n+\t\t\t}\n+\n+\t\t\tList<OAuthScope> requestScopes = Collections.EMPTY_LIST;\n+\t\t\tString synapseAuthorizationHeader = request.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\t\tString accessToken = HttpAuthUtil.getBearerTokenFromAuthorizationHeader(synapseAuthorizationHeader);\n+\t\t\tif (accessToken!=null) {\n+\t\t\t\tJwt<JwsHeader, Claims> jwt = oidcTokenHelper.parseJWT(accessToken);\n+\t\t\t\trequestScopes = ClaimsJsonUtil.getScopeFromClaims(jwt.getBody());\n+\t\t\t}\n+\n+\t\t\trequiredScopes.removeAll(requestScopes);\n+\t\t\tfor (OAuthScope scope: requiredScopes) {\n+\t\t\t\tmissingScopes.add(scope.name());", "originalCommit": "56e69b637c8277cfd24afcd58c21a8ca739d8959", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNjYwNg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410426606", "bodyText": "We could use the String.join", "author": "marcomarasca", "createdAt": "2020-04-17T19:27:50Z", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/OAuthScopeInterceptor.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.sagebionetworks.auth.HttpAuthUtil;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+import org.springframework.web.servlet.HandlerInterceptor;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+\n+/*\n+ * For requests which require authentication (have a 'userId' parameter) and are not anonymous, \n+ * the scope in the access token is compared to the scope in the RequiredScope annotation \n+ * (default to full scope) and 403 status is returned if the required scope is not present.\n+ */\n+public class OAuthScopeInterceptor implements HandlerInterceptor {\n+\n+\t/*\n+\t * If a handler is not annotated with RequiredScope then, by default, it requires the following\n+\t */\n+\tprivate static final Set<OAuthScope> DEFAULT_SCOPES;\n+\tstatic {\n+\t\tDEFAULT_SCOPES = new HashSet<OAuthScope>(Arrays.asList(OAuthScope.values()));\n+\t\tDEFAULT_SCOPES.remove(OAuthScope.openid);\n+\t}\n+\n+\tprivate static final String ERROR_MESSAGE_PREFIX  = \"Request lacks scope(s) required by this service: \";\n+\t\n+\t@Autowired\n+\tprivate OIDCTokenHelper oidcTokenHelper;\n+\t\n+\tpublic static boolean hasUserIdParameterOrAccessTokenHeader(HandlerMethod handlerMethod) {\n+\t\tfor (MethodParameter methodParameter : handlerMethod.getMethodParameters()) {\n+\t\t\tRequestParam requestParam = methodParameter.getParameterAnnotation(RequestParam.class);\n+\t\t\tif (requestParam!=null && requestParam.value().equals(AuthorizationConstants.USER_ID_PARAM)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tRequestHeader requestHeader = methodParameter.getParameterAnnotation(RequestHeader.class);\n+\t\t\tif (requestHeader!=null && requestHeader.value().equals(SYNAPSE_AUTHORIZATION_HEADER_NAME)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\tpublic static boolean isAnonymous(HttpServletRequest request) {\n+\t\tString userIdRequestParameter = request.getParameter(AuthorizationConstants.USER_ID_PARAM);\n+\t\treturn userIdRequestParameter == null ||\n+\t\t\t\tAuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId()\n+\t\t\t\t\t.equals(Long.parseLong(userIdRequestParameter));\n+\t}\n+\n+\t@Override\n+\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n+\t\t\tthrows Exception {\n+\t\t\n+\t\t// anonymous requests do not need to have scope checked, they have the same \n+\t\t// access that unauthenticated requests have\n+\t\tif (isAnonymous(request)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tSet<String> missingScopes = new TreeSet<String>();\n+\t\t{\n+\t\t\t// if no scopes are specified by an annotation on the method, then we use these defaults\n+\t\t\tSet<OAuthScope> requiredScopes = new TreeSet<OAuthScope>(DEFAULT_SCOPES);\n+\t\t\t\n+\t\t\tif (!(handler instanceof HandlerMethod)) {\n+\t\t\t\tthrow new IllegalStateException(\"Ths HandlerInterceptor should only be applied to HandlerMethods, but this handler is a \"+handler.getClass());\n+\t\t\t}\n+\t\t\t\n+\t\t\tHandlerMethod handlerMethod = (HandlerMethod) handler;\n+\n+\t\t\t// if no 'userId' parameter or access token header then this is \n+\t\t\t// not an authenticated request, and no scope is required\n+\t\t\tif (!hasUserIdParameterOrAccessTokenHeader(handlerMethod)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tRequiredScope requiredScopeAnnotation = handlerMethod.getMethodAnnotation(RequiredScope.class);\n+\t\t\tif (requiredScopeAnnotation != null) {\n+\t\t\t\trequiredScopes = new HashSet<OAuthScope>(Arrays.asList(requiredScopeAnnotation.value()));\n+\t\t\t}\n+\n+\t\t\tList<OAuthScope> requestScopes = Collections.EMPTY_LIST;\n+\t\t\tString synapseAuthorizationHeader = request.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\t\tString accessToken = HttpAuthUtil.getBearerTokenFromAuthorizationHeader(synapseAuthorizationHeader);\n+\t\t\tif (accessToken!=null) {\n+\t\t\t\tJwt<JwsHeader, Claims> jwt = oidcTokenHelper.parseJWT(accessToken);\n+\t\t\t\trequestScopes = ClaimsJsonUtil.getScopeFromClaims(jwt.getBody());\n+\t\t\t}\n+\n+\t\t\trequiredScopes.removeAll(requestScopes);\n+\t\t\tfor (OAuthScope scope: requiredScopes) {\n+\t\t\t\tmissingScopes.add(scope.name());\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (missingScopes.isEmpty()) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\tStringBuilder sb = new StringBuilder(ERROR_MESSAGE_PREFIX);\n+\t\tboolean first = true;\n+\t\tfor (String missingScope : missingScopes) {\n+\t\t\tif (first) first=false; else sb.append(\", \");", "originalCommit": "56e69b637c8277cfd24afcd58c21a8ca739d8959", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNjg2NQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410426865", "bodyText": "We can add some documentation to the annotation", "author": "marcomarasca", "createdAt": "2020-04-17T19:28:24Z", "path": "services/repository/src/main/java/org/sagebionetworks/repo/web/controller/RequiredScope.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.sagebionetworks.repo.web.controller;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+\n+@Retention(RUNTIME)", "originalCommit": "56e69b637c8277cfd24afcd58c21a8ca739d8959", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTMzMA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4006#discussion_r410435330", "bodyText": "Add test for the invalid token case, see the interceptor comment", "author": "marcomarasca", "createdAt": "2020-04-17T19:46:51Z", "path": "services/repository/src/test/java/org/sagebionetworks/repo/web/OAuthScopeInterceptorTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+package org.sagebionetworks.repo.web;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.sagebionetworks.repo.model.AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.manager.oauth.ClaimsJsonUtil;\n+import org.sagebionetworks.repo.manager.oauth.OIDCTokenHelper;\n+import org.sagebionetworks.repo.model.AuthorizationConstants;\n+import org.sagebionetworks.repo.model.oauth.OAuthScope;\n+import org.sagebionetworks.repo.web.controller.RequiredScope;\n+import org.springframework.core.MethodParameter;\n+import org.springframework.web.bind.annotation.RequestHeader;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import org.springframework.web.method.HandlerMethod;\n+\n+import io.jsonwebtoken.Claims;\n+import io.jsonwebtoken.JwsHeader;\n+import io.jsonwebtoken.Jwt;\n+import io.jsonwebtoken.impl.DefaultClaims;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OAuthScopeInterceptorTest {\n+\n+\t@Mock\n+\tprivate OIDCTokenHelper mockOidcTokenHelper;\n+\n+\t@InjectMocks\n+\tprivate OAuthScopeInterceptor oauthScopeInterceptor;\n+\t\n+\t@Mock\n+\tprivate HttpServletRequest mockRequest; \n+\t\n+\t@Mock\n+\tprivate HttpServletResponse mockResponse; \n+\t\n+\t@Mock\n+\tprivate HandlerMethod mockHandler;\n+\t\n+\t@Mock\n+\tprivate MethodParameter mockUserIdParameter;\n+\t\n+\t@Mock\n+\tprivate MethodParameter mockAccessTokenHeader;\n+\t\n+\t@Mock\n+\tprivate Jwt<JwsHeader, Claims> mockJwt;\n+\t\n+\t@Mock\n+\tprivate RequestParam mockRequestParam;\n+\t\n+\t@Mock\n+\tprivate RequestHeader mockRequestHeader;\n+\t\n+\tprivate static final String USER_ID = \"100001\";\n+\tprivate static final String ACCESS_TOKEN = \"access-token\";\n+\t\n+\tprivate static RequiredScope createRequiredScopeAnnotation(final OAuthScope[] scopes) {\n+\t\treturn new RequiredScope() {\n+\t\t\t@Override\n+\t\t\tpublic Class<? extends Annotation> annotationType() {return RequiredScope.class;}\n+\t\t\t@Override\n+\t\t\tpublic OAuthScope[] value() {return scopes;}\n+\t\t};\n+\t}\n+\t\n+\tprivate static Claims createClaimsForScope(final OAuthScope[] scopes) {\n+\t\tDefaultClaims result = new DefaultClaims();\n+\t\tClaimsJsonUtil.addAccessClaims( Arrays.asList(scopes), \n+\t\t\t\tCollections.EMPTY_MAP, result);\n+\t\treturn result;\n+\t}\n+\t\n+\t@BeforeEach\n+\tvoid before() {\n+\t}\n+\t\n+\t// mock an annotated method with a userId parameter\n+\tprivate void mockRequiredScopeAnnotation() {\n+\t\tRequiredScope requiredScopeAnnotation = createRequiredScopeAnnotation(OAuthScope.values());\n+\t\twhen(mockHandler.getMethodAnnotation(RequiredScope.class)).thenReturn(requiredScopeAnnotation);\n+\t}\n+\t\t\n+\tprivate void mockRequestIdParam() {\n+\t\twhen(mockRequestParam.value()).thenReturn( AuthorizationConstants.USER_ID_PARAM);\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {mockUserIdParameter});\n+\t\twhen(mockUserIdParameter.getParameterAnnotation(RequestParam.class)).thenReturn(mockRequestParam);\n+\t}\n+\t\n+\tprivate void mockRequest(String userId, String accessToken) {\n+\t\tif (accessToken!=null) {\n+\t\t\twhen(mockRequest.getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME)).thenReturn(\"Bearer \"+accessToken);\n+\t\t}\n+\t\twhen(mockRequest.getParameter(AuthorizationConstants.USER_ID_PARAM)).thenReturn(userId); \t\n+\t}\n+\t\n+\tprivate void mockAccessToken(OAuthScope[] scopes) {\n+\t\twhen(mockOidcTokenHelper.parseJWT(ACCESS_TOKEN)).thenReturn(mockJwt);\n+\t\twhen(mockJwt.getBody()).thenReturn(createClaimsForScope(scopes));\t\t\n+\t}\n+\t\n+\tprivate OutputStream mockResponse() throws IOException {\n+\t\tByteArrayOutputStream os = new ByteArrayOutputStream();\n+\t\twhen(mockResponse.getWriter()).thenReturn(new PrintWriter(os));\n+\t\treturn os;\n+\t}\n+\t\n+\t@Test\n+\tvoid testHasUserIdParameterOrAccessTokenHeader_withUserId() {\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {mockUserIdParameter});\n+\t\twhen(mockUserIdParameter.getParameterAnnotation(RequestParam.class)).thenReturn(mockRequestParam);\n+\t\twhen(mockRequestParam.value()).thenReturn( AuthorizationConstants.USER_ID_PARAM);\n+\n+\t\t// method under test\n+\t\tassertTrue(OAuthScopeInterceptor.hasUserIdParameterOrAccessTokenHeader(mockHandler));\n+\t}\n+\t\n+\t@Test\n+\tvoid testHasUserIdParameterOrAccessTokenHeader_withAccessToken() {\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {mockAccessTokenHeader});\n+\t\twhen(mockAccessTokenHeader.getParameterAnnotation(RequestParam.class)).thenReturn(null);\n+\t\twhen(mockAccessTokenHeader.getParameterAnnotation(RequestHeader.class)).thenReturn(mockRequestHeader);\n+\t\twhen(mockRequestHeader.value()).thenReturn( AuthorizationConstants.SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\n+\t\t// method under test\n+\t\tassertTrue(OAuthScopeInterceptor.hasUserIdParameterOrAccessTokenHeader(mockHandler));\n+\t}\n+\t\n+\t@Test\n+\tvoid testHasUserIdParameterOrAccessTokenHeader_Nothing() {\n+\t\twhen(mockHandler.getMethodParameters()).thenReturn(new MethodParameter[] {});\n+\t\t// method under test\n+\t\tassertFalse(OAuthScopeInterceptor.hasUserIdParameterOrAccessTokenHeader(mockHandler));\n+\t}\n+\t\n+\t@Test\n+\tvoid testIsAnonymous_anonymousId() {\n+\t\twhen(mockRequest.getParameter(AuthorizationConstants.USER_ID_PARAM)).\n+\t\t\tthenReturn(AuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId().toString());\n+\t\tassertTrue(OAuthScopeInterceptor.isAnonymous(mockRequest));\n+\t}\n+\t\n+\t@Test\n+\tvoid testIsAnonymous_missingId() {\n+\t\tassertTrue(OAuthScopeInterceptor.isAnonymous(mockRequest));\n+\t}\n+\t\n+\t@Test\n+\tvoid testIsAnonymous_NOT_anonymous() {\n+\t\twhen(mockRequest.getParameter(AuthorizationConstants.USER_ID_PARAM)).thenReturn(\"123\");\n+\t\tassertFalse(OAuthScopeInterceptor.isAnonymous(mockRequest));\n+\t}\n+\t\n+\t@Test\n+\tvoid testPrehandleAnonymous() throws Exception {\n+\t\tmockRequest(AuthorizationConstants.BOOTSTRAP_PRINCIPAL.ANONYMOUS_USER.getPrincipalId().toString(), null);// anonymous, no access token\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t\t\n+\t\tverify(mockRequest, never()).getHeader(anyString());\n+\t\tverify(mockHandler, never()).getMethodAnnotation(any());\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleAnonymous_handlerWrongType() throws Exception {\n+\t\tmockRequest(\"123\", null);// NOT anonymous\n+\t\t\n+\t\t// method under test\n+\t\tassertThrows(IllegalStateException.class, \n+\t\t\t\t() -> {oauthScopeInterceptor.preHandle(mockRequest, mockResponse, String.class);\n+\t\t});\n+\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleNoUserIdORAccessTokenParameter() throws Exception {\n+\t\tmockRequest(null, null);// anonymous, no access token\n+\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleHappyCase() throws Exception {\n+\t\tmockRequiredScopeAnnotation();\n+\t\tmockRequestIdParam();\n+\t\tmockRequest(USER_ID, ACCESS_TOKEN);// NOT anonymous\t\n+\t\tmockAccessToken(OAuthScope.values());\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t\t\n+\t\tverify(mockHandler).getMethodAnnotation(RequiredScope.class);\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\tverify(mockOidcTokenHelper).parseJWT(ACCESS_TOKEN);\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleNoScopeAnnotation() throws Exception {\n+\t\twhen(mockHandler.getMethodAnnotation(RequiredScope.class)).thenReturn(null);\n+\t\tmockRequestIdParam();\n+\t\tmockRequest(USER_ID, ACCESS_TOKEN);// NOT anonymous\t\n+\t\tmockAccessToken(OAuthScope.values());\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertTrue(result);\n+\t\t\n+\t\tverify(mockHandler).getMethodAnnotation(RequiredScope.class);\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\tverify(mockOidcTokenHelper).parseJWT(ACCESS_TOKEN);\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleInsufficentScope() throws Exception {\n+\t\tmockRequiredScopeAnnotation();\n+\t\tmockRequestIdParam();\n+\t\t\n+\t\tmockRequest(USER_ID, ACCESS_TOKEN);// NOT anonymous\t\n+\t\tmockAccessToken(new OAuthScope[] {OAuthScope.view});\n+\t\tOutputStream os = mockResponse();\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertFalse(result);\n+\t\t\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\n+\t\tassertEquals(\"{\\\"reason\\\":\\\"Request lacks scope(s) required by this service: download, modify, openid\\\"}\\n\", os.toString());\n+\t\t\n+\t}\n+\n+\t@Test\n+\tvoid testPrehandleNoAccessToken() throws Exception {\n+\t\tmockRequiredScopeAnnotation();\n+\t\tmockRequestIdParam();\n+\t\t\n+\t\tmockRequest(USER_ID, null);// NOT anonymous, no access token\n+\t\tOutputStream os = mockResponse();\n+\t\t\n+\t\t// method under test\n+\t\tboolean result = oauthScopeInterceptor.preHandle(mockRequest, mockResponse, mockHandler);\n+\t\t\n+\t\tassertFalse(result);\n+\n+\t\tassertEquals(\"{\\\"reason\\\":\\\"Request lacks scope(s) required by this service: download, modify, openid, view\\\"}\\n\",  os.toString());\n+\t\t\n+\t\tverify(mockRequest).getHeader(SYNAPSE_AUTHORIZATION_HEADER_NAME);\n+\t\tverify(mockOidcTokenHelper, never()).parseJWT(anyString());\n+\t\tverify(mockHandler).getMethodAnnotation(RequiredScope.class);\n+\t}", "originalCommit": "56e69b637c8277cfd24afcd58c21a8ca739d8959", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}