{"pr_number": 4031, "pr_title": "Plfm 6161 c", "pr_createdAt": "2020-05-01T22:56:02Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4031", "timeline": [{"oid": "a0d84c8f68206c7700756d05ad902d76d3d72264", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a0d84c8f68206c7700756d05ad902d76d3d72264", "message": "started schema transltor", "committedDate": "2020-04-30T02:01:19Z", "type": "commit"}, {"oid": "41de2afa72f6946494a28253a1f6854487ca0dc0", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/41de2afa72f6946494a28253a1f6854487ca0dc0", "message": "use LinkedHashMaps in JsonSchema property serialization and more transation", "committedDate": "2020-04-30T20:29:54Z", "type": "commit"}, {"oid": "2b309eeaa5989649cb383e19d90e58237f6e548b", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/2b309eeaa5989649cb383e19d90e58237f6e548b", "message": "support for loading recursive schemas from the classpath", "committedDate": "2020-05-01T22:52:51Z", "type": "commit"}, {"oid": "88ba0e351b6189960de9a62808be04e1af7b6f6a", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/88ba0e351b6189960de9a62808be04e1af7b6f6a", "message": "test fix", "committedDate": "2020-05-02T01:06:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc5NjY5NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4031#discussion_r418796694", "bodyText": "We could probably try to use its interface", "author": "marcomarasca", "createdAt": "2020-05-02T00:45:03Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/SchemaTranslator.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import java.io.IOException;\n+\n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n+import org.sagebionetworks.schema.ObjectSchema;\n+import org.sagebionetworks.schema.ObjectSchemaImpl;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+\n+public interface SchemaTranslator {\n+\t\n+\t/**\n+\t * Load an ObjectSchemaImpl from the auto-generated project via the classpath.\n+\t * \n+\t * @param id The ID of the schema to load. For example to load the schema for a\n+\t *           FileEntity use: \"org.sagebionetworks.repo.model.FileEntity\"\n+\t * @return\n+\t * @throws IOException\n+\t * @throws JSONObjectAdapterException\n+\t */\n+\tObjectSchemaImpl loadSchemaFromClasspath(String id);", "originalCommit": "2b309eeaa5989649cb383e19d90e58237f6e548b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgwMjYzOA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4031#discussion_r418802638", "bodyText": "You could iterate on the entrySet", "author": "marcomarasca", "createdAt": "2020-05-02T00:58:00Z", "path": "services/repository-managers/src/main/java/org/sagebionetworks/repo/manager/schema/SchemaTranslatorImp.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.StringWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n+import org.sagebionetworks.repo.model.schema.Type;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.ObjectSchema;\n+import org.sagebionetworks.schema.ObjectSchemaImpl;\n+import org.sagebionetworks.schema.TYPE;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+import org.sagebionetworks.schema.adapter.org.json.EntityFactory;\n+import org.sagebionetworks.util.ValidateArgument;\n+import org.springframework.stereotype.Component;\n+\n+@Component\n+public class SchemaTranslatorImp implements SchemaTranslator {\n+\n+\tpublic static final String CURRENT_$SCHEMA = \"http://json-schema.org/draft-07/schema#\";\n+\tpublic static final String DELIMITER = \"/\";\n+\tpublic static final String SYNAPSE_ORGANIZATION_NAME = \"org.sagebionetworks\";\n+\n+\t@Override\n+\tpublic ObjectSchemaImpl loadSchemaFromClasspath(String id) {\n+\t\tValidateArgument.required(id, \"id\");\n+\t\tString fileName = \"schema/\" + id.replaceAll(\"\\\\.\", DELIMITER) + \".json\";\n+\t\ttry (InputStream input = SynapseSchemaBootstrapImpl.class.getClassLoader().getResourceAsStream(fileName);) {\n+\t\t\tif (input == null) {\n+\t\t\t\tthrow new NotFoundException(\"Cannot find: '\" + fileName + \"' on the classpath\");\n+\t\t\t}\n+\t\t\tStringWriter writer = new StringWriter();\n+\t\t\tIOUtils.copy(input, writer, StandardCharsets.UTF_8);\n+\t\t\tString jsonString = writer.toString();\n+\t\t\tObjectSchemaImpl schema = EntityFactory.createEntityFromJSONString(jsonString, ObjectSchemaImpl.class);\n+\t\t\tif (schema.getId() == null) {\n+\t\t\t\tschema.setId(id);\n+\t\t\t}\n+\t\t\treturn schema;\n+\t\t} catch (IOException | JSONObjectAdapterException e) {\n+\t\t\tthrow new IllegalStateException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Convert from the ID used internally to the external $id. For example,\n+\t * 'org.sagebionetworks.repo.model.FileEntity' becomes\n+\t * 'org.sagebionetworks/repo.model.FileEntity'\n+\t * \n+\t * @param id\n+\t * @return\n+\t */\n+\tpublic String convertFromInternalIdToExternalId(String id) {\n+\t\tif (id == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tif (!id.startsWith(SYNAPSE_ORGANIZATION_NAME)) {\n+\t\t\tthrow new IllegalArgumentException(\"Id has an unknown organization name: '\" + id + \"'\");\n+\t\t}\n+\t\tString schemaName = id.substring(SYNAPSE_ORGANIZATION_NAME.length() + 1);\n+\t\tStringJoiner joiner = new StringJoiner(DELIMITER);\n+\t\tjoiner.add(SYNAPSE_ORGANIZATION_NAME);\n+\t\tjoiner.add(schemaName);\n+\t\treturn joiner.toString();\n+\t}\n+\n+\t/**\n+\t * Translate an array of ObjectSchema to a list of JsonSchema\n+\t * \n+\t * @param array\n+\t * @return\n+\t */\n+\tpublic List<JsonSchema> translateArray(ObjectSchema[] array) {\n+\t\tif (array == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tList<JsonSchema> newList = new ArrayList<JsonSchema>(array.length);\n+\t\tfor (ObjectSchema sub : array) {\n+\t\t\tnewList.add(translate(sub));\n+\t\t}\n+\t\treturn newList;\n+\t}\n+\n+\t/**\n+\t * Convert the ObjectSchema types to JsonSchema types.\n+\t * @param type\n+\t * @return\n+\t */\n+\tpublic Type translateType(TYPE type) {\n+\t\tif (type == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tswitch (type) {\n+\t\tcase STRING:\n+\t\t\treturn Type.string;\n+\t\tcase INTEGER:\n+\t\tcase NUMBER:\n+\t\t\treturn Type.number;\n+\t\tcase ARRAY:\n+\t\t\treturn Type.array;\n+\t\tcase BOOLEAN:\n+\t\t\treturn Type._boolean;\n+\t\tcase NULL:\n+\t\t\treturn Type._null;\n+\t\tcase OBJECT:\n+\t\tcase INTERFACE:\n+\t\t\treturn Type.object;\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"There is no translation for type: '\"+type.name()+\"'\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Translate from a map of ObjectSchema to a Map\n+\t * \n+\t * @param inputMap\n+\t * @return\n+\t */\n+\tpublic LinkedHashMap<String, JsonSchema> translateMap(Map<String, ObjectSchema> inputMap) {\n+\t\tif (inputMap == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tLinkedHashMap<String, JsonSchema> resultMap = new LinkedHashMap<String, JsonSchema>(inputMap.size());\n+\t\tfor (String key : inputMap.keySet()) {", "originalCommit": "2b309eeaa5989649cb383e19d90e58237f6e548b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgwMzc1MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4031#discussion_r418803751", "bodyText": "You might want to remove this unused reference", "author": "marcomarasca", "createdAt": "2020-05-02T01:00:28Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/SchemaTranslatorImplTest.java", "diffHunk": "@@ -0,0 +1,394 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.model.FileEntity;\n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n+import org.sagebionetworks.repo.model.schema.Type;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.LinkDescription;\n+import org.sagebionetworks.schema.ObjectSchema;\n+import org.sagebionetworks.schema.ObjectSchemaImpl;\n+import org.sagebionetworks.schema.TYPE;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+\n+import com.google.common.collect.Lists;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class SchemaTranslatorImplTest {\n+\n+\t@InjectMocks\n+\tSchemaTranslatorImp translator;\n+\t\n+\tSchemaTranslatorImp spyTranslator;", "originalCommit": "2b309eeaa5989649cb383e19d90e58237f6e548b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgwNTU3OA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4031#discussion_r418805578", "bodyText": "Shouldn't this fail?", "author": "marcomarasca", "createdAt": "2020-05-02T01:04:52Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/SchemaTranslatorImplTest.java", "diffHunk": "@@ -0,0 +1,394 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.model.FileEntity;\n+import org.sagebionetworks.repo.model.schema.JsonSchema;\n+import org.sagebionetworks.repo.model.schema.Type;\n+import org.sagebionetworks.repo.web.NotFoundException;\n+import org.sagebionetworks.schema.FORMAT;\n+import org.sagebionetworks.schema.LinkDescription;\n+import org.sagebionetworks.schema.ObjectSchema;\n+import org.sagebionetworks.schema.ObjectSchemaImpl;\n+import org.sagebionetworks.schema.TYPE;\n+import org.sagebionetworks.schema.adapter.JSONObjectAdapterException;\n+\n+import com.google.common.collect.Lists;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class SchemaTranslatorImplTest {\n+\n+\t@InjectMocks\n+\tSchemaTranslatorImp translator;\n+\t\n+\tSchemaTranslatorImp spyTranslator;\n+\t\n+\t@Test\n+\tpublic void testLoadSchemaFromClasspath() throws IOException, JSONObjectAdapterException {\n+\t\tString fileEntityId = FileEntity.class.getName();\n+\t\t// call under test\n+\t\tObjectSchemaImpl schema = translator.loadSchemaFromClasspath(fileEntityId);\n+\t\tassertNotNull(schema);\n+\t\tassertEquals(fileEntityId, schema.getId());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testLoadSchemaFromClasspathWithNotFound() throws IOException, JSONObjectAdapterException {\n+\t\tString id = \"does.not.exist\";\n+\t\tString message = assertThrows(NotFoundException.class, () -> {\n+\t\t\ttranslator.loadSchemaFromClasspath(id);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Cannot find: 'schema/does/not/exist.json' on the classpath\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testLoadSchemaFromClasspathWithNullId() {\n+\t\tString id = null;\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\ttranslator.loadSchemaFromClasspath(id);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testConvertFromInternalIdToExternalId() {\n+\t\tString internalId = \"org.sagebionetworks.repo.model.FileEntity\";\n+\t\t// call under test\n+\t\tString externalId = translator.convertFromInternalIdToExternalId(internalId);\n+\t\tassertEquals(\"org.sagebionetworks/repo.model.FileEntity\", externalId);\n+\t}\n+\n+\t@Test\n+\tpublic void testConvertFromInternalIdToExternalIdWithUknownOrganization() {\n+\t\tString internalId = \"org.unknown.repo.model.FileEntity\";\n+\t\tString message = assertThrows(IllegalArgumentException.class, () -> {\n+\t\t\ttranslator.convertFromInternalIdToExternalId(internalId);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"Id has an unknown organization name: 'org.unknown.repo.model.FileEntity'\", message);\n+\t}\n+\n+\t@Test\n+\tpublic void testConvertFromInternalIdToExternalIdWithNullId() {\n+\t\tString internalId = null;\n+\t\t// call under test\n+\t\tString externalId = translator.convertFromInternalIdToExternalId(internalId);\n+\t\tassertNull(externalId);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateArray() {\n+\t\tObjectSchemaImpl one = new ObjectSchemaImpl();\n+\t\tone.setId(\"org.sagebionetworks.one\");\n+\t\tObjectSchemaImpl two = new ObjectSchemaImpl();\n+\t\ttwo.setId(\"org.sagebionetworks.two\");\n+\t\tObjectSchema[] array = new ObjectSchema[] {one, two};\n+\t\t// Call under test\n+\t\tList<JsonSchema> result = translator.translateArray(array);\n+\t\tassertNotNull(result);\n+\t\tassertEquals(2, result.size());\n+\t\tassertEquals(\"org.sagebionetworks/one\", result.get(0).get$id());\n+\t\tassertEquals(\"org.sagebionetworks/two\", result.get(1).get$id());\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateArrayWithNullArray() {\n+\t\tObjectSchema[] array = null;\n+\t\t// Call under test\n+\t\tList<JsonSchema> result = translator.translateArray(array);\n+\t\tassertNull(result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithString() {\n+\t\tTYPE input = TYPE.STRING;\n+\t\t// call under test\n+\t\tType result = translator.translateType(input);\n+\t\tassertEquals(Type.string, result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithArray() {\n+\t\tTYPE input = TYPE.ARRAY;\n+\t\t// call under test\n+\t\tType result = translator.translateType(input);\n+\t\tassertEquals(Type.array, result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithNumber() {\n+\t\tTYPE input = TYPE.NUMBER;\n+\t\t// call under test\n+\t\tType result = translator.translateType(input);\n+\t\tassertEquals(Type.number, result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithInteger() {\n+\t\tTYPE input = TYPE.INTEGER;\n+\t\t// call under test\n+\t\tType result = translator.translateType(input);\n+\t\tassertEquals(Type.number, result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithBoolean() {\n+\t\tTYPE input = TYPE.BOOLEAN;\n+\t\t// call under test\n+\t\tType result = translator.translateType(input);\n+\t\tassertEquals(Type._boolean, result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithNull() {\n+\t\tTYPE input = TYPE.NULL;\n+\t\t// call under test\n+\t\tType result = translator.translateType(input);\n+\t\tassertEquals(Type._null, result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithObject() {\n+\t\tTYPE input = TYPE.OBJECT;\n+\t\t// call under test\n+\t\tType result = translator.translateType(input);\n+\t\tassertEquals(Type.object, result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithInterface() {\n+\t\tTYPE input = TYPE.INTERFACE;\n+\t\t// call under test\n+\t\tType result = translator.translateType(input);\n+\t\tassertEquals(Type.object, result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithAny() {\n+\t\tTYPE input = TYPE.ANY;\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\ttranslator.translateType(input);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"There is no translation for type: 'ANY'\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithMap() {\n+\t\tTYPE input = TYPE.MAP;\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\ttranslator.translateType(input);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"There is no translation for type: 'MAP'\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithTupleArrayMap() {\n+\t\tTYPE input = TYPE.TUPLE_ARRAY_MAP;\n+\t\tString message = assertThrows(IllegalArgumentException.class, ()->{\n+\t\t\ttranslator.translateType(input);\n+\t\t}).getMessage();\n+\t\tassertEquals(\"There is no translation for type: 'TUPLE_ARRAY_MAP'\", message);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateTypeWithNullType() {\n+\t\tTYPE input = null;\n+\t\t// call under test\n+\t\tType result = translator.translateType(input);\n+\t\tassertNull(result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateMap() {\n+\t\tObjectSchemaImpl one = new ObjectSchemaImpl(TYPE.STRING);\n+\t\tone.setDescription(\"one\");\n+\t\tObjectSchemaImpl two = new ObjectSchemaImpl(TYPE.NUMBER);\n+\t\ttwo.setDescription(\"two\");\n+\t\tObjectSchemaImpl three = new ObjectSchemaImpl(TYPE.BOOLEAN);\n+\t\tthree.setDescription(\"three\");\n+\t\tMap<String, ObjectSchema> inputMap = new LinkedHashMap<String, ObjectSchema>(3);\n+\t\tinputMap.put(\"one\", one);\n+\t\tinputMap.put(\"two\", two);\n+\t\tinputMap.put(\"three\", three);\n+\t\t\n+\t\t// Call under test\n+\t\tLinkedHashMap<String, JsonSchema> result = translator.translateMap(inputMap);\n+\t\tassertNotNull(result);\n+\t\t// The order must match the order of the input\n+\t\tList<String> keyOrder = new LinkedList<String>();\n+\t\tfor(String key: result.keySet()) {\n+\t\t\tkeyOrder.add(key);\n+\t\t}\n+\t\tassertEquals(Lists.newArrayList(\"one\",\"two\",\"three\"), keyOrder);\n+\t\tassertNotNull(result.get(\"one\"));\n+\t\tassertEquals(\"one\", result.get(\"one\").getDescription());\n+\t\tassertNotNull(result.get(\"two\"));\n+\t\tassertEquals(\"two\", result.get(\"two\").getDescription());\n+\t\tassertNotNull(result.get(\"three\"));\n+\t\tassertEquals(\"three\", result.get(\"three\").getDescription());\n+\t}\n+\t\n+\t\n+\t@Test\n+\tpublic void testTranslateMapWithNull() {\n+\t\tMap<String, ObjectSchema> inputMap = null;\n+\t\t// Call under test\n+\t\tLinkedHashMap<String, JsonSchema> result = translator.translateMap(inputMap);\n+\t\tassertNull(result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateFormat() {\n+\t\tFORMAT format = FORMAT.DATE_TIME;\n+\t\t// call under test\n+\t\tString result = translator.translateFormat(format);\n+\t\tassertEquals(FORMAT.DATE_TIME.getJSONValue(), result);\n+\t}\n+\t\n+\t@Test\n+\tpublic void testTranslateFormtWithNull() {\n+\t\tFORMAT format = null;\n+\t\t// call under test\n+\t\tString result = translator.translateFormat(format);\n+\t\tassertEquals(FORMAT.DATE_TIME.getJSONValue(), result);", "originalCommit": "2b309eeaa5989649cb383e19d90e58237f6e548b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgwODUxMw==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4031#discussion_r418808513", "bodyText": "We might want to add a test where the references create a circular dependency (e.g. loop)", "author": "marcomarasca", "createdAt": "2020-05-02T01:12:03Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/schema/SynapseSchemaBootstrapImplTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package org.sagebionetworks.repo.manager.schema;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.sagebionetworks.repo.manager.UserManager;\n+import org.sagebionetworks.schema.ObjectSchemaImpl;\n+import org.sagebionetworks.schema.TYPE;\n+\n+import com.google.common.collect.Lists;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class SynapseSchemaBootstrapImplTest {\n+\n+\t@Mock\n+\tprivate JsonSchemaManager mockJsonSchemaManager;\n+\n+\t@Mock\n+\tprivate UserManager mockUserManager;\n+\t\n+\t@Mock\n+\tSchemaTranslator mockTranslator;\n+\n+\t@InjectMocks\n+\tprivate SynapseSchemaBootstrapImpl bootstrap;\n+\t\n+\tObjectSchemaImpl objectSchema;\n+\t\n+\t@BeforeEach\n+\tpublic void before() {\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testLoadAllSchemasAndReferences() {\n+\t\t// One is a leaf\n+\t\tObjectSchemaImpl one = new ObjectSchemaImpl(TYPE.STRING);\n+\t\tone.setId(\"one\");\n+\t\t\n+\t\tObjectSchemaImpl refToOne = new ObjectSchemaImpl();\n+\t\trefToOne.setRef(one.getId());\n+\t\t\n+\t\t// two depends on one\n+\t\tObjectSchemaImpl two = new ObjectSchemaImpl(TYPE.ARRAY);\n+\t\ttwo.setId(\"two\");\n+\t\ttwo.setItems(refToOne);\n+\t\t\n+\t\tObjectSchemaImpl refToTwo = new ObjectSchemaImpl();\n+\t\trefToTwo.setRef(two.getId());\n+\t\t\n+\t\t// Three depends on two\n+\t\tObjectSchemaImpl three = new ObjectSchemaImpl(TYPE.OBJECT);\n+\t\tthree.setId(\"three\");\n+\t\tthree.setImplements(new ObjectSchemaImpl[] {refToTwo});\n+\t\t\n+\t\t// For depends on one\n+\t\tObjectSchemaImpl four = new ObjectSchemaImpl(TYPE.OBJECT);\n+\t\tfour.setId(\"four\");\n+\t\tfour.setImplements(new ObjectSchemaImpl[] {refToOne});\n+\t\t\n+\t\twhen(mockTranslator.loadSchemaFromClasspath(one.getId())).thenReturn(one);\n+\t\twhen(mockTranslator.loadSchemaFromClasspath(two.getId())).thenReturn(two);\n+\t\twhen(mockTranslator.loadSchemaFromClasspath(three.getId())).thenReturn(three);\n+\t\twhen(mockTranslator.loadSchemaFromClasspath(four.getId())).thenReturn(four);\n+\t\t\n+\t\t// loading three and four should trigger the load of all four.\n+\t\tList<String> rootIds = Lists.newArrayList(three.getId(), four.getId());\n+\t\t// call under test\n+\t\tList<ObjectSchemaImpl> results = bootstrap.loadAllSchemasAndReferences(rootIds);\n+\t\tassertNotNull(results);\n+\t\tassertEquals(4, results.size());\n+\t\t// Each dependency must come before the schema which depends on it.\n+\t\tassertEquals(one, results.get(0));\n+\t\tassertEquals(two, results.get(1));\t\n+\t\tassertEquals(three, results.get(2));\t\n+\t\tassertEquals(four, results.get(3));\t\n+\t}", "originalCommit": "2b309eeaa5989649cb383e19d90e58237f6e548b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c23166407d8fefb5a0cf5c9d7e5fdbac31625fbf", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/c23166407d8fefb5a0cf5c9d7e5fdbac31625fbf", "message": "fixed nodeDao test assumed order and added test for schema order", "committedDate": "2020-05-04T22:24:43Z", "type": "commit"}, {"oid": "650a96300aa51c954d3029a4c36134bbdc27e03c", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/650a96300aa51c954d3029a4c36134bbdc27e03c", "message": "seems order was only maintined becuase the keys where in alpahbetical order", "committedDate": "2020-05-04T23:21:54Z", "type": "commit"}, {"oid": "12160c05c8b82f5467f5595cac6143d876cb3889", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/12160c05c8b82f5467f5595cac6143d876cb3889", "message": "merge develop", "committedDate": "2020-05-05T19:50:44Z", "type": "commit"}]}