{"pr_number": 4148, "pr_title": "PLFM-6220: Data access renewal reminders", "pr_createdAt": "2020-07-28T18:45:03Z", "pr_url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4148", "timeline": [{"oid": "7b1515c6a2a7c874e1bad2d1f5a0663694ca0006", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/7b1515c6a2a7c874e1bad2d1f5a0663694ca0006", "message": "PLFM-6220: Added method to check if a submitter has an approval in the future", "committedDate": "2020-07-28T02:40:56Z", "type": "commit"}, {"oid": "3f926a2269c5c009452fdee539aaab7f4ddd2516", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/3f926a2269c5c009452fdee539aaab7f4ddd2516", "message": "PLFM-6220: Logic for sending reminders", "committedDate": "2020-07-28T02:40:56Z", "type": "commit"}, {"oid": "7382aa33df7a496e2858904be0350045f23f35bd", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/7382aa33df7a496e2858904be0350045f23f35bd", "message": "PLFM-6299: Check approvals count rather than fetching", "committedDate": "2020-07-28T02:40:57Z", "type": "commit"}, {"oid": "f35111d5082a95166906c801f231e54824d17921", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/f35111d5082a95166906c801f231e54824d17921", "message": "PLFM-6220: Fetch the list of unprocessed reminders for the day", "committedDate": "2020-07-28T02:40:57Z", "type": "commit"}, {"oid": "a85fa8b7004f5e2510c459f23172be80f3464259", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/a85fa8b7004f5e2510c459f23172be80f3464259", "message": "PLFM-6220: Additional tests", "committedDate": "2020-07-28T02:40:57Z", "type": "commit"}, {"oid": "e072461279a500f1a654ff0f900b989a923b7c01", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/e072461279a500f1a654ff0f900b989a923b7c01", "message": "PLFM-6220: Added worker to process data access reminders", "committedDate": "2020-07-28T03:00:02Z", "type": "commit"}, {"oid": "77189ca46d284deafe3768e39394960d9c73363c", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/77189ca46d284deafe3768e39394960d9c73363c", "message": "PLFM-6220: Templates for data access reminders", "committedDate": "2020-07-28T18:44:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwNzk4NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4148#discussion_r461907984", "bodyText": "ROW_NUMBER()", "author": "brucehoff", "createdAt": "2020-07-28T21:55:27Z", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/dao/dataaccess/DataAccessNotificationDaoImpl.java", "diffHunk": "@@ -24,6 +30,42 @@\n \t\t\t+ SqlConstants.COL_DATA_ACCESS_NOTIFICATION_TYPE + \" = ?\" + \" AND \"\r\n \t\t\t+ SqlConstants.COL_DATA_ACCESS_NOTIFICATION_REQUIREMENT_ID + \" = ?\" + \" AND \"\r\n \t\t\t+ SqlConstants.COL_DATA_ACCESS_NOTIFICATION_RECIPIENT_ID + \" = ?\";\r\n+\t\r\n+\t// WITH EXPIRING_APPROVALS AS (\r\n+\t// \tSELECT ID, ROW_NUMBER OVER (PARTITION BY REQUIREMENT_ID, SUBMITTER_ID ORDER BY EXPIRED_ON DESC) AS APPROVAL_N \r", "originalCommit": "77189ca46d284deafe3768e39394960d9c73363c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkwODg3NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4148#discussion_r461908874", "bodyText": "update comment", "author": "brucehoff", "createdAt": "2020-07-28T21:56:29Z", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/dao/dataaccess/DataAccessNotificationDaoImpl.java", "diffHunk": "@@ -24,6 +30,42 @@\n \t\t\t+ SqlConstants.COL_DATA_ACCESS_NOTIFICATION_TYPE + \" = ?\" + \" AND \"\r\n \t\t\t+ SqlConstants.COL_DATA_ACCESS_NOTIFICATION_REQUIREMENT_ID + \" = ?\" + \" AND \"\r\n \t\t\t+ SqlConstants.COL_DATA_ACCESS_NOTIFICATION_RECIPIENT_ID + \" = ?\";\r\n+\t\r\n+\t// WITH EXPIRING_APPROVALS AS (\r\n+\t// \tSELECT ID, ROW_NUMBER OVER (PARTITION BY REQUIREMENT_ID, SUBMITTER_ID ORDER BY EXPIRED_ON DESC) AS APPROVAL_N \r\n+\t// \tFROM ACCESS_APPROVAL WHERE EXPIRED_ON >= ? AND EXPIRED_ON < ? AND STATE = 'APPROVED' AND SUBMITTER_ID = ACCESSOR_ID\r\n+\t// ) \r\n+\t// SELECT DISTINCT(A.ID) FROM EXPIRING_APPROVALS A LEFT JOIN DATA_ACCESS_NOTIFICATION N \r\n+\t// ON ( A.ID = N.ACCESS_APPROVAL_ID AND N.NOTIFICATION_TYPE = ? AND N.SENT_ON >= ? AND N.SENT_ON < ?) \r\n+\t// WHERE A.APPROVAL_N = 1 AND N.ID IS NULL LIMIT ?\t\r\n+\tprivate static final String SQL_SELECT_APPROVALS_FOR_UNSENT_SUBMITTER = \"WITH EXPIRING_APPROVALS AS (\"\r\n+\t\t\t+ \" SELECT \" + SqlConstants.COL_ACCESS_APPROVAL_ID + \",\"\r\n+\t\t\t// Provide a ranking over requirement and submitter so that only the most relevant approval is taken into account\r\n+\t\t\t+ \" ROW_NUMBER() OVER (PARTITION BY \" + SqlConstants.COL_ACCESS_APPROVAL_REQUIREMENT_ID + \", \" + SqlConstants.COL_ACCESS_APPROVAL_SUBMITTER_ID\r\n+\t\t\t+ \" ORDER BY \" + SqlConstants.COL_ACCESS_APPROVAL_EXPIRED_ON + \" DESC) AS APPROVAL_N\"\r\n+\t\t\t+ \" FROM \" + SqlConstants.TABLE_ACCESS_APPROVAL\r\n+\t\t\t// Filter by expiration date\r\n+\t\t\t+ \" WHERE \" + SqlConstants.COL_ACCESS_APPROVAL_EXPIRED_ON + \" >= ?\"\r\n+\t\t\t+ \" AND \" + SqlConstants.COL_ACCESS_APPROVAL_EXPIRED_ON + \" < ?\"\r\n+\t\t\t+ \" AND \" + SqlConstants.COL_ACCESS_APPROVAL_STATE + \" = '\" + ApprovalState.APPROVED + \"'\"\r\n+\t\t\t// Only submitters\r\n+\t\t\t+ \" AND \" + SqlConstants.COL_ACCESS_APPROVAL_SUBMITTER_ID + \" = \" + SqlConstants.COL_ACCESS_APPROVAL_ACCESSOR_ID\r\n+\t\t\t+ \")\"\r\n+\t\t\t+ \" SELECT DISTINCT(A.\" + SqlConstants.COL_ACCESS_APPROVAL_ID + \") FROM EXPIRING_APPROVALS A\"\r\n+\t\t\t// Left join on the submitter\r", "originalCommit": "77189ca46d284deafe3768e39394960d9c73363c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkxNTgwMg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4148#discussion_r461915802", "bodyText": "assert that result is correct", "author": "brucehoff", "createdAt": "2020-07-28T22:05:20Z", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/dao/dataaccess/DataAccessNotificationDaoImplTest.java", "diffHunk": "@@ -398,20 +397,221 @@ public void testValidateForStorageWithNoSentOn() {\n \t\t\r\n \t\tassertEquals(\"The sent on is required.\", errorMessage);\r\n \t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testListSubmitterApprovalsForUnSentReminder() {\r\n+\t\t\r\n+\t\tDataAccessNotificationType notificationType = DataAccessNotificationType.FIRST_RENEWAL_REMINDER;\r\n+\t\tAccessRequirement requirement = createManagedAR();\r\n+\t\t\r\n+\t\tLocalDate today = LocalDate.now(ZoneOffset.UTC);\r\n+\t\tLocalDate expirationDate = today.plus(notificationType.getReminderPeriod());\r\n+\r\n+\t\t// The approval is expiring according to the reminder period\r\n+\t\tAccessApproval approval = createApproval(requirement, expirationDate.atStartOfDay(ZoneOffset.UTC).toInstant());\r\n+\t\t\r\n+\t\tint limit = 100;\r\n+\t\t\r\n+\t\tList<Long> expected = Arrays.asList(approval.getId());\r\n+\t\t\r\n+\t\t// Call under test\r\n+\t\tList<Long> result = notificationDao.listSubmmiterApprovalsForUnSentReminder(notificationType, today, limit);\r\n+\t\t\r", "originalCommit": "77189ca46d284deafe3768e39394960d9c73363c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "16e02a507452ab374b0d5a17399530a572806552", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/16e02a507452ab374b0d5a17399530a572806552", "message": "PLFM-6220: Better documentation for magic query", "committedDate": "2020-07-28T23:16:13Z", "type": "commit"}, {"oid": "c1f946bad5c2af840d847ce0e9aa533b07fada13", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/c1f946bad5c2af840d847ce0e9aa533b07fada13", "message": "PLFM-6220: Re-wording for reminders", "committedDate": "2020-07-28T23:16:47Z", "type": "commit"}, {"oid": "87f3d264ff920130d0221f38d207c5d948afe4aa", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/87f3d264ff920130d0221f38d207c5d948afe4aa", "message": "PLFM-6220: Improve magic query to exclude non-expiring, future approvals", "committedDate": "2020-07-29T07:21:50Z", "type": "commit"}, {"oid": "801dd434e31463205fc387d28845935e21fd290b", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/commit/801dd434e31463205fc387d28845935e21fd290b", "message": "PLFM-6220: Increase frequency and batch size of reminders worker", "committedDate": "2020-07-29T15:51:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkxNjY3NA==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4148#discussion_r461916674", "bodyText": "// call under test", "author": "brucehoff", "createdAt": "2020-07-28T22:06:26Z", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/dao/dataaccess/DataAccessNotificationDaoImplTest.java", "diffHunk": "@@ -398,20 +397,221 @@ public void testValidateForStorageWithNoSentOn() {\n \t\t\r\n \t\tassertEquals(\"The sent on is required.\", errorMessage);\r\n \t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testListSubmitterApprovalsForUnSentReminder() {\r\n+\t\t\r\n+\t\tDataAccessNotificationType notificationType = DataAccessNotificationType.FIRST_RENEWAL_REMINDER;\r\n+\t\tAccessRequirement requirement = createManagedAR();\r\n+\t\t\r\n+\t\tLocalDate today = LocalDate.now(ZoneOffset.UTC);\r\n+\t\tLocalDate expirationDate = today.plus(notificationType.getReminderPeriod());\r\n+\r\n+\t\t// The approval is expiring according to the reminder period\r\n+\t\tAccessApproval approval = createApproval(requirement, expirationDate.atStartOfDay(ZoneOffset.UTC).toInstant());\r\n+\t\t\r\n+\t\tint limit = 100;\r\n+\t\t\r\n+\t\tList<Long> expected = Arrays.asList(approval.getId());\r\n+\t\t\r\n+\t\t// Call under test\r\n+\t\tList<Long> result = notificationDao.listSubmmiterApprovalsForUnSentReminder(notificationType, today, limit);\r\n+\t\t\r\n+\t\t// Now simulates a notification sent today\r\n+\t\tnotificationDao.create(newNotification(notificationType, requirement, approval, today.atStartOfDay(ZoneOffset.UTC).toInstant(), -1L));\r\n+\t\t\r\n+\t\texpected = Collections.emptyList();\r\n+\t\tresult = notificationDao.listSubmmiterApprovalsForUnSentReminder(notificationType, today, limit);\r", "originalCommit": "77189ca46d284deafe3768e39394960d9c73363c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkxOTMwNQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4148#discussion_r461919305", "bodyText": "redundant", "author": "brucehoff", "createdAt": "2020-07-28T22:09:58Z", "path": "lib/jdomodels/src/test/java/org/sagebionetworks/repo/model/dbo/dao/dataaccess/DataAccessNotificationDaoImplTest.java", "diffHunk": "@@ -398,20 +397,221 @@ public void testValidateForStorageWithNoSentOn() {\n \t\t\r\n \t\tassertEquals(\"The sent on is required.\", errorMessage);\r\n \t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testListSubmitterApprovalsForUnSentReminder() {\r\n+\t\t\r\n+\t\tDataAccessNotificationType notificationType = DataAccessNotificationType.FIRST_RENEWAL_REMINDER;\r\n+\t\tAccessRequirement requirement = createManagedAR();\r\n+\t\t\r\n+\t\tLocalDate today = LocalDate.now(ZoneOffset.UTC);\r\n+\t\tLocalDate expirationDate = today.plus(notificationType.getReminderPeriod());\r\n+\r\n+\t\t// The approval is expiring according to the reminder period\r\n+\t\tAccessApproval approval = createApproval(requirement, expirationDate.atStartOfDay(ZoneOffset.UTC).toInstant());\r\n+\t\t\r\n+\t\tint limit = 100;\r\n+\t\t\r\n+\t\tList<Long> expected = Arrays.asList(approval.getId());\r\n+\t\t\r\n+\t\t// Call under test\r\n+\t\tList<Long> result = notificationDao.listSubmmiterApprovalsForUnSentReminder(notificationType, today, limit);\r\n+\t\t\r\n+\t\t// Now simulates a notification sent today\r\n+\t\tnotificationDao.create(newNotification(notificationType, requirement, approval, today.atStartOfDay(ZoneOffset.UTC).toInstant(), -1L));\r\n+\t\t\r\n+\t\texpected = Collections.emptyList();\r\n+\t\tresult = notificationDao.listSubmmiterApprovalsForUnSentReminder(notificationType, today, limit);\r\n+\t\t\r\n+\t\tassertEquals(expected, result);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testListSubmitterApprovalsForUnSentReminderWithExisting() {\r", "originalCommit": "77189ca46d284deafe3768e39394960d9c73363c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ2ODk5MQ==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4148#discussion_r462468991", "bodyText": "consider changing A to AE, or some other distinct name", "author": "brucehoff", "createdAt": "2020-07-29T17:32:58Z", "path": "lib/jdomodels/src/main/java/org/sagebionetworks/repo/model/dbo/dao/dataaccess/DataAccessNotificationDaoImpl.java", "diffHunk": "@@ -20,10 +39,80 @@\n @Repository\r\n public class DataAccessNotificationDaoImpl implements DataAccessNotificationDao {\r\n \r\n-\tprivate static final String SQL_FIND = \"SELECT * FROM \" + SqlConstants.TABLE_DATA_ACCESS_NOTIFICATION + \" WHERE \"\r\n-\t\t\t+ SqlConstants.COL_DATA_ACCESS_NOTIFICATION_TYPE + \" = ?\" + \" AND \"\r\n-\t\t\t+ SqlConstants.COL_DATA_ACCESS_NOTIFICATION_REQUIREMENT_ID + \" = ?\" + \" AND \"\r\n-\t\t\t+ SqlConstants.COL_DATA_ACCESS_NOTIFICATION_RECIPIENT_ID + \" = ?\";\r\n+\tprivate static final String SQL_FIND = \"SELECT * FROM \" + TABLE_DATA_ACCESS_NOTIFICATION\r\n+\t\t\t+ \" WHERE \" + COL_DATA_ACCESS_NOTIFICATION_TYPE + \" = ?\" \r\n+\t\t\t+ \" AND \" + COL_DATA_ACCESS_NOTIFICATION_REQUIREMENT_ID + \" = ?\" \r\n+\t\t\t+ \" AND \" + COL_DATA_ACCESS_NOTIFICATION_RECIPIENT_ID + \" = ?\";\r\n+\t\r\n+\t// We want all the access approvals for submitters (submitter == accessor) whose expiration date is in a \r\n+\t// given range (e.g. on a specific day) for which a notification of a given type WAS NOT sent within a\r\n+\t// given range (e.g. on a specific day). Additionally we need to make sure that we do not include approvals\r\n+\t// for which other approval exist with the same requirement and submitter that do not expire (expiredOn = 0)\r\n+\t// or that expire in the future.\r\n+\t//\r\n+\t// For example: If today I'm trying to process all the approvals that expire 30 days from now, I want to get back\r\n+\t// the list of approvals whose expiration date is 30 days (today + 30) excluding those approvals that have a notification\r\n+\t// of the same type that was sent today.\r\n+\t\r\n+\t/*\r\n+\t WITH EXPIRING_APPROVALS AS (\r\n+\t \t\tSELECT * FROM ACCESS_APPROVAL \r\n+\t\t\tWHERE EXPIRED_ON >= ? AND EXPIRED_ON < ? \r\n+\t \t\tAND STATE = 'APPROVED' AND SUBMITTER_ID = ACCESSOR_ID\r\n+\t ),\r\n+\t EXPIRED_APPROVALS AS (\r\n+\t \t\tSELECT E.* FROM EXPIRING_APPROVALS E LEFT JOIN ACCESS_APPROVAL A ON (\r\n+\t\t\t\tE.REQUIREMENT_ID = A.REQUIREMENT_ID \r\n+\t\t\t\tAND E.SUBMITTER_ID = A.SUBMITTER_ID \r\n+\t\t\t\tAND E.ACCESSOR_ID = A.ACCESSOR_ID \r\n+\t\t\t\tAND E.STATE = A.STATE \r\n+\t\t\t\tAND (A.EXPIRED_ON = 0 OR A.EXPIRED_ON > E.EXPIRED_ON) \r\n+\t\t\t) WHERE A.ID IS NULL\r\n+\t )\r\n+\t SELECT DISTINCT(A.ID) FROM EXPIRED_APPROVALS A LEFT JOIN DATA_ACCESS_NOTIFICATION N ON (\r", "originalCommit": "801dd434e31463205fc387d28845935e21fd290b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNTQwMg==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4148#discussion_r462625402", "bodyText": "epxpiresOn -> expiresOn (typo)", "author": "brucehoff", "createdAt": "2020-07-29T22:25:48Z", "path": "services/repository-managers/src/test/java/org/sagebionetworks/repo/manager/dataaccess/notifications/AccessReminderNotificationBuilderIntegrationTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.sagebionetworks.repo.manager.dataaccess.notifications;\r\n+\r\n+import static org.junit.jupiter.api.Assertions.assertEquals;\r\n+import static org.mockito.ArgumentMatchers.any;\r\n+import static org.mockito.Mockito.when;\r\n+\r\n+import java.io.IOException;\r\n+import java.time.LocalDate;\r\n+import java.time.ZoneOffset;\r\n+import java.util.Date;\r\n+\r\n+import org.apache.velocity.app.VelocityEngine;\r\n+import org.junit.jupiter.api.BeforeEach;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.jupiter.api.extension.ExtendWith;\r\n+import org.mockito.Mock;\r\n+import org.mockito.junit.jupiter.MockitoExtension;\r\n+import org.sagebionetworks.repo.manager.UserProfileManager;\r\n+import org.sagebionetworks.repo.model.AccessApproval;\r\n+import org.sagebionetworks.repo.model.ManagedACTAccessRequirement;\r\n+import org.sagebionetworks.repo.model.UserInfo;\r\n+import org.sagebionetworks.repo.model.UserProfile;\r\n+import org.sagebionetworks.repo.model.dbo.dao.TestUtils;\r\n+import org.springframework.beans.factory.annotation.Autowired;\r\n+import org.springframework.test.context.ContextConfiguration;\r\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\r\n+\r\n+@ExtendWith(value = {SpringExtension.class, MockitoExtension.class})\r\n+@ContextConfiguration(\"classpath:test-context.xml\")\r\n+public class AccessReminderNotificationBuilderIntegrationTest {\r\n+\t\r\n+\t@Autowired\r\n+\tprivate VelocityEngine velocity;\r\n+\t\r\n+\tprivate AccessReminderNotificationBuilder builder;\r\n+\t\r\n+\t// We mock all this as we only want to test the final template output\r\n+\t@Mock\r\n+\tprivate UserProfileManager profileManager;\r\n+\t@Mock\r\n+\tprivate UserProfile mockProfile;\r\n+\t@Mock\r\n+\tprivate ManagedACTAccessRequirement accessRequirement;\r\n+\t@Mock\r\n+\tprivate AccessApproval approval;\r\n+\t@Mock\r\n+\tprivate UserInfo recipient;\r\n+\t\r\n+\t@BeforeEach\r\n+\tpublic void before() {\r\n+\t\tbuilder = new AccessReminderNotificationBuilder(profileManager, velocity);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testBuildMessageBodyWithDescription() throws IOException {\r\n+\t\t\r\n+\t\tLong recipientId = 4567L;\r\n+\t\tLong requirementId = 1234L;\r\n+\t\tString requirementDescription = \"Some Dataset\";\r\n+\t\tString firstName = \"First\";\r\n+\t\tString lastName = \"Second\";\r\n+\t\tDate epxpiresOn = Date.from(LocalDate.of(2020, 7, 27).atStartOfDay(ZoneOffset.UTC).toInstant());\r", "originalCommit": "801dd434e31463205fc387d28845935e21fd290b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzNTc4Ng==", "url": "https://github.com/Sage-Bionetworks/Synapse-Repository-Services/pull/4148#discussion_r462635786", "bodyText": "make the failure go first (2L,1L)", "author": "brucehoff", "createdAt": "2020-07-29T22:53:49Z", "path": "services/workers/src/test/java/org/sagebionetworks/dataaccess/workers/AccessApprovalReminderNotificationWorkerUnitTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.sagebionetworks.dataaccess.workers;\r\n+\r\n+import static org.mockito.ArgumentMatchers.any;\r\n+import static org.mockito.ArgumentMatchers.anyInt;\r\n+import static org.mockito.ArgumentMatchers.anyLong;\r\n+import static org.mockito.ArgumentMatchers.eq;\r\n+import static org.mockito.Mockito.doNothing;\r\n+import static org.mockito.Mockito.doThrow;\r\n+import static org.mockito.Mockito.verify;\r\n+import static org.mockito.Mockito.verifyZeroInteractions;\r\n+import static org.mockito.Mockito.when;\r\n+\r\n+import java.util.Arrays;\r\n+import java.util.List;\r\n+\r\n+import org.apache.logging.log4j.Logger;\r\n+import org.junit.jupiter.api.AfterEach;\r\n+import org.junit.jupiter.api.BeforeEach;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.jupiter.api.extension.ExtendWith;\r\n+import org.mockito.InjectMocks;\r\n+import org.mockito.Mock;\r\n+import org.mockito.junit.jupiter.MockitoExtension;\r\n+import org.sagebionetworks.LoggerProvider;\r\n+import org.sagebionetworks.common.util.progress.ProgressCallback;\r\n+import org.sagebionetworks.repo.manager.dataaccess.AccessApprovalNotificationManager;\r\n+import org.sagebionetworks.repo.manager.feature.FeatureManager;\r\n+import org.sagebionetworks.repo.model.dbo.dao.dataaccess.DataAccessNotificationType;\r\n+import org.sagebionetworks.repo.model.dbo.feature.Feature;\r\n+\r\n+@ExtendWith(MockitoExtension.class)\r\n+public class AccessApprovalReminderNotificationWorkerUnitTest {\r\n+\r\n+\t@Mock\r\n+\tprivate FeatureManager mockFeatureManager;\r\n+\t\r\n+\t@Mock\r\n+\tprivate AccessApprovalNotificationManager mockNotificationManager;\r\n+\t\r\n+\t@Mock\r\n+\tprivate LoggerProvider mockLoggerProvider;\r\n+\t\r\n+\t@InjectMocks\r\n+\tprivate AccessApprovalReminderNotificationWorker worker;\r\n+\t\r\n+\t@Mock\r\n+\tprivate ProgressCallback mockCallback;\r\n+\t\r\n+\t@Mock\r\n+\tprivate Logger mockLogger;\r\n+\t\r\n+\t@BeforeEach\r\n+\tpublic void before() {\r\n+\t\twhen(mockLoggerProvider.getLogger(any())).thenReturn(mockLogger);\r\n+\t\tworker.configureLogger(mockLoggerProvider);\r\n+\t}\r\n+\t\r\n+\t@AfterEach\r\n+\tpublic void after() {\r\n+\t\tverify(mockLoggerProvider).getLogger(AccessApprovalReminderNotificationWorker.class.getName());\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testRunWithFeatureDisabled() throws Exception {\r\n+\t\t\r\n+\t\tboolean featureEnabled = false;\r\n+\t\t\r\n+\t\twhen(mockFeatureManager.isFeatureEnabled(any())).thenReturn(featureEnabled);\r\n+\t\t\r\n+\t\t// Call under test\r\n+\t\tworker.run(mockCallback);\r\n+\t\t\r\n+\t\tverify(mockFeatureManager).isFeatureEnabled(Feature.DATA_ACCESS_NOTIFICATIONS);\r\n+\t\tverifyZeroInteractions(mockNotificationManager);\r\n+\t\tverifyZeroInteractions(mockLogger);\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testRun() throws Exception {\r\n+\t\t\r\n+\t\tboolean featureEnabled = true;\r\n+\t\t\r\n+\t\tList<Long> approvals = Arrays.asList(1L, 2L);\r\n+\t\t\r\n+\t\twhen(mockFeatureManager.isFeatureEnabled(any())).thenReturn(featureEnabled);\r\n+\t\twhen(mockNotificationManager.listSubmitterApprovalsForUnsentReminder(any(), anyInt())).thenReturn(approvals);\r\n+\t\t\r\n+\t\t// Call under test\r\n+\t\tworker.run(mockCallback);\r\n+\t\t\r\n+\t\tverify(mockFeatureManager).isFeatureEnabled(Feature.DATA_ACCESS_NOTIFICATIONS);\r\n+\t\t\r\n+\t\tfor (DataAccessNotificationType type : DataAccessNotificationType.values()) {\r\n+\t\t\tif (!type.isReminder()) {\r\n+\t\t\t\tcontinue;\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tverify(mockNotificationManager).listSubmitterApprovalsForUnsentReminder(type, AccessApprovalReminderNotificationWorker.BATCH_SIZE);\r\n+\t\t\t\r\n+\t\t\tfor (Long id : approvals) {\r\n+\t\t\t\tverify(mockNotificationManager).processAccessApproval(type, id);\r\n+\t\t\t}\r\n+\t\t\t\r\n+\t\t\tverify(mockLogger).info(eq(\"Sucessfully processed {} reminders (Type: {}, Errored: {}, Time: {} ms).\"), eq(approvals.size()), eq(type), eq(0), anyLong());\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t@Test\r\n+\tpublic void testRunWithFailingApproval() throws Exception {\r\n+\t\t\r\n+\t\tboolean featureEnabled = true;\r\n+\t\t\r\n+\t\tList<Long> approvals = Arrays.asList(1L, 2L);\r", "originalCommit": "801dd434e31463205fc387d28845935e21fd290b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}