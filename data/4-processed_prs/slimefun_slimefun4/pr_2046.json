{"pr_number": 2046, "pr_title": "Enchantment Rune", "pr_createdAt": "2020-06-25T19:37:49Z", "pr_url": "https://github.com/Slimefun/Slimefun4/pull/2046", "timeline": [{"oid": "07224cc7d5a76493574eef4a57661dc57c1cbe32", "url": "https://github.com/Slimefun/Slimefun4/commit/07224cc7d5a76493574eef4a57661dc57c1cbe32", "message": "Added Enchantment Rune.\n\nAdded Enchantment Rune that applies a random enchantment on items.\nWorks similar to Soulbound Rune.", "committedDate": "2020-06-24T13:28:35Z", "type": "commit"}, {"oid": "e1fc23c265ced97b7d40dbf66e20a225c17513be", "url": "https://github.com/Slimefun/Slimefun4/commit/e1fc23c265ced97b7d40dbf66e20a225c17513be", "message": "Fixed an import dis-organisation.", "committedDate": "2020-06-24T18:27:27Z", "type": "commit"}, {"oid": "f54b2771110a7aa5ff36463a293130060f6f169c", "url": "https://github.com/Slimefun/Slimefun4/commit/f54b2771110a7aa5ff36463a293130060f6f169c", "message": "Merge branch 'master' of https://github.com/LinoxGH/Slimefun4 into EnchRune\n\n\u0001 Conflicts:\n\u0001\tsrc/main/java/io/github/thebusybiscuit/slimefun4/implementation/SlimefunItems.java\n\u0001\tsrc/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/ResearchSetup.java\n\u0001\tsrc/main/resources/languages/researches_en.yml", "committedDate": "2020-06-25T19:35:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0ODM3NQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446048375", "bodyText": "This is a rather bad approach to this. It would be much better to loop through all Enchantments and split them based on the .canEnchant() method or so to sort it based on items.", "author": "TheBusyBiscuit", "createdAt": "2020-06-26T08:38:15Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+\n+    private static final Enchantment[] helmEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.OXYGEN, Enchantment.WATER_WORKER, Enchantment.THORNS, Enchantment.PROTECTION_PROJECTILE, Enchantment.PROTECTION_FIRE, Enchantment.PROTECTION_ENVIRONMENTAL, Enchantment.PROTECTION_EXPLOSIONS};\n+    private static final Enchantment[] chestLeggingsEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.THORNS, Enchantment.PROTECTION_PROJECTILE, Enchantment.PROTECTION_FIRE, Enchantment.PROTECTION_ENVIRONMENTAL, Enchantment.PROTECTION_EXPLOSIONS};\n+    private static final Enchantment[] bootsEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.FROST_WALKER, Enchantment.PROTECTION_FALL, Enchantment.DEPTH_STRIDER, Enchantment.THORNS, Enchantment.PROTECTION_PROJECTILE, Enchantment.PROTECTION_FIRE, Enchantment.PROTECTION_ENVIRONMENTAL, Enchantment.PROTECTION_EXPLOSIONS};\n+\n+    private static final Enchantment[] swordEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.FIRE_ASPECT, Enchantment.LOOT_BONUS_MOBS, Enchantment.KNOCKBACK, Enchantment.SWEEPING_EDGE, Enchantment.DAMAGE_ALL, Enchantment.DAMAGE_ARTHROPODS, Enchantment.DAMAGE_UNDEAD};\n+    private static final Enchantment[] tridentEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.IMPALING, Enchantment.CHANNELING, Enchantment.LOYALTY, Enchantment.RIPTIDE};\n+    private static Enchantment[] crossbowEnch;\n+    private static final Enchantment[] bowEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.ARROW_DAMAGE, Enchantment.ARROW_FIRE, Enchantment.ARROW_INFINITE, Enchantment.ARROW_KNOCKBACK};\n+\n+    private static final Enchantment[] axeEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.DIG_SPEED, Enchantment.LOOT_BONUS_BLOCKS, Enchantment.SILK_TOUCH, Enchantment.DAMAGE_ALL, Enchantment.DAMAGE_UNDEAD, Enchantment.DAMAGE_ARTHROPODS};\n+    private static final Enchantment[] toolEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.DIG_SPEED, Enchantment.LOOT_BONUS_BLOCKS, Enchantment.SILK_TOUCH};\n+    private static final Enchantment[] shearEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.DIG_SPEED};\n+    private static final Enchantment[] fishRodEnch = {Enchantment.MENDING, Enchantment.DURABILITY, Enchantment.LURE, Enchantment.LUCK};\n+    private static final Enchantment[] otherItemsEnch = {Enchantment.MENDING, Enchantment.DURABILITY};", "originalCommit": "f54b2771110a7aa5ff36463a293130060f6f169c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA5NzgzMA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446097830", "bodyText": "oh I forgot about that method lol", "author": "LinoxGH", "createdAt": "2020-06-26T10:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0ODM3NQ=="}], "type": "inlineReview"}, {"oid": "9176d795c88a404f5dd87a59ab73ac10c9d8fff3", "url": "https://github.com/Slimefun/Slimefun4/commit/9176d795c88a404f5dd87a59ab73ac10c9d8fff3", "message": "Merge branch 'master' of https://github.com/TheBusyBiscuit/Slimefun4 into EnchRune", "committedDate": "2020-06-26T10:28:45Z", "type": "commit"}, {"oid": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "url": "https://github.com/Slimefun/Slimefun4/commit/eb2bbae0c986691229fd0fcb069af8f3737d4151", "message": "Did the requested changes.", "committedDate": "2020-06-26T10:31:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTM4MA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679380", "bodyText": "I wouldn't really have a seperate research for this, these two can easily share the same research.\nBesides... why glass anyway?", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:55:46Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/setup/ResearchSetup.java", "diffHunk": "@@ -267,6 +267,8 @@ public static void setupResearches() {\n         register(\"advanced_industrial_miner\", 98, \"Better Mining\", 36, SlimefunItems.ADVANCED_INDUSTRIAL_MINER);\n         register(\"magical_zombie_pills\", 257, \"De-Zombification\", 22, SlimefunItems.MAGICAL_ZOMBIE_PILLS);\n         register(\"auto_brewer\", 258, \"Industrial Brewery\", 30, SlimefunItems.AUTO_BREWER);\n+        register(\"enchantment_rune\", 259, \"Ancient Enchanting\", 24, SlimefunItems.ENCHANTMENT_RUNE);\n+        register(\"magical_glass\", 260, \"Magical See-Through\", 5, SlimefunItems.MAGICAL_GLASS);", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4MDQ3Mw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446680473", "bodyText": "I wanted players to spend some xp using flask of knowledges but even 9 wouldn't be enough so I added this.", "author": "LinoxGH", "createdAt": "2020-06-28T18:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTQ5Ng==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679496", "bodyText": "Please do not use abbreviations like this.\nThis is a nightmare maintenance-wise. Name your methods accordingly, like getApplicableEnchantments.\nAnd not findEnchArr...", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:57:06Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);\n+\n+            if (target.getAmount() == 1) {\n+                e.setCancelled(true);\n+\n+                // This lightning is just an effect, it deals no damage.\n+                l.getWorld().strikeLightningEffect(l);\n+\n+                Slimefun.runSync(() -> {\n+                    // Being sure entities are still valid and not picked up or whatsoever.\n+                    if (item.isValid() && entity.isValid() && target.getAmount() == 1) {\n+\n+                        l.getWorld().createExplosion(l, 0);\n+                        l.getWorld().playSound(l, Sound.ENTITY_GENERIC_EXPLODE, 0.3F, 1);\n+\n+                        entity.remove();\n+                        item.remove();\n+                        l.getWorld().dropItemNaturally(l, target);\n+\n+                        SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.success\", true);\n+                    }\n+                }, 10L);\n+            }\n+            else {\n+                SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.fail\", true);\n+            }\n+        }\n+    }\n+\n+    private Enchantment[] findEnchArr(Material type) {", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTUzMw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679533", "bodyText": "This can (and probably should) be done using a ternary operator.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:57:36Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);\n+\n+            if (target.getAmount() == 1) {\n+                e.setCancelled(true);\n+\n+                // This lightning is just an effect, it deals no damage.\n+                l.getWorld().strikeLightningEffect(l);\n+\n+                Slimefun.runSync(() -> {\n+                    // Being sure entities are still valid and not picked up or whatsoever.\n+                    if (item.isValid() && entity.isValid() && target.getAmount() == 1) {\n+\n+                        l.getWorld().createExplosion(l, 0);\n+                        l.getWorld().playSound(l, Sound.ENTITY_GENERIC_EXPLODE, 0.3F, 1);\n+\n+                        entity.remove();\n+                        item.remove();\n+                        l.getWorld().dropItemNaturally(l, target);\n+\n+                        SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.success\", true);\n+                    }\n+                }, 10L);\n+            }\n+            else {\n+                SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.fail\", true);\n+            }\n+        }\n+    }\n+\n+    private Enchantment[] findEnchArr(Material type) {\n+        Enchantment[] enchArr = applicableEnchs.get(type);\n+        if (enchArr == null) enchArr = new Enchantment[0];\n+        return enchArr;", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTU5MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679591", "bodyText": "Please write out your variable names...\nAbbreviations make it hard to maintain later down the line.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:58:09Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTYxNw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679617", "bodyText": "This should be an EnumMap, not a HashMap.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:58:31Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTYyNw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679627", "bodyText": "All of this can be reduced to a single line:\ngetOrDefault", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T17:58:47Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);\n+\n+            if (target.getAmount() == 1) {\n+                e.setCancelled(true);\n+\n+                // This lightning is just an effect, it deals no damage.\n+                l.getWorld().strikeLightningEffect(l);\n+\n+                Slimefun.runSync(() -> {\n+                    // Being sure entities are still valid and not picked up or whatsoever.\n+                    if (item.isValid() && entity.isValid() && target.getAmount() == 1) {\n+\n+                        l.getWorld().createExplosion(l, 0);\n+                        l.getWorld().playSound(l, Sound.ENTITY_GENERIC_EXPLODE, 0.3F, 1);\n+\n+                        entity.remove();\n+                        item.remove();\n+                        l.getWorld().dropItemNaturally(l, target);\n+\n+                        SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.success\", true);\n+                    }\n+                }, 10L);\n+            }\n+            else {\n+                SlimefunPlugin.getLocal().sendMessage(p, \"messages.enchantment-rune.fail\", true);\n+            }\n+        }\n+    }\n+\n+    private Enchantment[] findEnchArr(Material type) {\n+        Enchantment[] enchArr = applicableEnchs.get(type);\n+        if (enchArr == null) enchArr = new Enchantment[0];\n+        return enchArr;", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTc2NQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679765", "bodyText": "Why are you storing this as a variable here? I don't see this index used anywhere else.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T18:00:09Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTg0NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679844", "bodyText": "Should probably choose a little more magical sound effect and visual than a quote: GENERIC_SPLODE...", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T18:00:57Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);\n+\n+            if (target.getAmount() == 1) {\n+                e.setCancelled(true);\n+\n+                // This lightning is just an effect, it deals no damage.\n+                l.getWorld().strikeLightningEffect(l);\n+\n+                Slimefun.runSync(() -> {\n+                    // Being sure entities are still valid and not picked up or whatsoever.\n+                    if (item.isValid() && entity.isValid() && target.getAmount() == 1) {\n+\n+                        l.getWorld().createExplosion(l, 0);\n+                        l.getWorld().playSound(l, Sound.ENTITY_GENERIC_EXPLODE, 0.3F, 1);", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTkyOA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679928", "bodyText": "Should also check for conflicts, since you wouldn't want to enchant a Silk Touch with Fortune.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T18:01:49Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchs.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            Enchantment[] enchArr = findEnchArr(target.getType());\n+            if (enchArr.length == 0) return;\n+            int enchIndex = ThreadLocalRandom.current().nextInt(enchArr.length);\n+            Enchantment ench = enchArr[enchIndex];\n+\n+            int level = 1;\n+            if (ench.getMaxLevel() != 1) level = ThreadLocalRandom.current().nextInt(ench.getMaxLevel() + 1);\n+\n+            target.addEnchantment(ench, level);", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY3OTk1MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446679951", "bodyText": "Also always declare with base types, Map.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T18:02:13Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final HashMap<Material, Enchantment[]> applicableEnchs = new HashMap<>();", "originalCommit": "eb2bbae0c986691229fd0fcb069af8f3737d4151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e55e2690e78067bf2615ec5926f5878c6ed1317b", "url": "https://github.com/Slimefun/Slimefun4/commit/e55e2690e78067bf2615ec5926f5878c6ed1317b", "message": "Did the requested changes.", "committedDate": "2020-06-28T19:06:35Z", "type": "commit"}, {"oid": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "url": "https://github.com/Slimefun/Slimefun4/commit/27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "message": "Fixed a little bug.", "committedDate": "2020-06-28T19:09:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODc0MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446688741", "bodyText": "No need for the rather unncessary and expensive call with the ItemStack here, you can just use this here.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:30:06Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODkwMw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446688903", "bodyText": "You could save yourself this Array to ArrayList conversion if you directly stored a List in your Map", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:31:35Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentSet = Arrays.asList(applicableEnchantments.getOrDefault(target.getType(), new Enchantment[0]));", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODkzNw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446688937", "bodyText": "You should use .isEmpty() here", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:31:57Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentSet = Arrays.asList(applicableEnchantments.getOrDefault(target.getType(), new Enchantment[0]));\n+            if (enchantmentSet.size() == 0) return;", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4OTA2NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446689064", "bodyText": "This would result in concurrent modification. Use an Iterator instead.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:33:14Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentSet = Arrays.asList(applicableEnchantments.getOrDefault(target.getType(), new Enchantment[0]));\n+            if (enchantmentSet.size() == 0) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            for (Enchantment enchantment : enchantmentSet) {\n+                for (Enchantment itemEnchantment : target.getEnchantments().keySet()) {\n+                    if (enchantment == itemEnchantment) enchantmentSet.remove(enchantment);", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4OTE4OA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446689188", "bodyText": "Also you are missing conflicting enchantments", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T19:34:29Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunItems;\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, Enchantment[]> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            Set<Enchantment> enchSet = new HashSet<>();\n+            for (Enchantment ench : Enchantment.values()) {\n+                if (ench.canEnchantItem(new ItemStack(mat))) enchSet.add(ench);\n+            }\n+            applicableEnchantments.put(mat, enchSet.toArray(new Enchantment[0]));\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, SlimefunItems.ENCHANTMENT_RUNE, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentSet = Arrays.asList(applicableEnchantments.getOrDefault(target.getType(), new Enchantment[0]));\n+            if (enchantmentSet.size() == 0) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            for (Enchantment enchantment : enchantmentSet) {", "originalCommit": "27ba744fe5ce0d42aa5f42ab4cdebdcb7e8a587e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "url": "https://github.com/Slimefun/Slimefun4/commit/5c7accbbe8a4d3377ae9bada48de126e189d2202", "message": "Did the requested changes + a fix.", "committedDate": "2020-06-28T20:46:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5NjU3MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446696571", "bodyText": "This will remove it from the actual List stored inside your Map, so you should copy the List before modifying it in any way.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T20:49:36Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            if (enchantmentList.isEmpty()) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            enchantmentList.removeIf(enchantment -> target.getEnchantments().containsKey(enchantment));", "originalCommit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5NjY3Mg==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446696672", "bodyText": "Hmmm, well you are returning anyway when the list is empty...\nSo you could just do a simple get and do a null check instead of creating a new ArrayList and then immediately discarding it.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T20:50:32Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            if (enchantmentList.isEmpty()) return;", "originalCommit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5Njc1NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446696754", "bodyText": "Should probably also send a failure message if no enchantment was applicable.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T20:51:19Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            if (enchantmentList.isEmpty()) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            enchantmentList.removeIf(enchantment -> target.getEnchantments().containsKey(enchantment));\n+            if (enchantmentList.isEmpty()) return;", "originalCommit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5Njc4MA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446696780", "bodyText": "Also still missing the conflict check.", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T20:51:38Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> enchantmentList = applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>());\n+            if (enchantmentList.isEmpty()) return;\n+\n+            //Removing the enchantments that the item already has from enchantmentSet\n+            enchantmentList.removeIf(enchantment -> target.getEnchantments().containsKey(enchantment));", "originalCommit": "5c7accbbe8a4d3377ae9bada48de126e189d2202", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjcwMzk2OQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446703969", "bodyText": "I don't understand ehat you mean by conflict check.", "author": "LinoxGH", "createdAt": "2020-06-28T22:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5Njc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjcwOTgyNA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446709824", "bodyText": "Enchantments can have conflicts, like I explained earlier.\nSilk Touch and Fortune are incompatible for example, there is also a method to check for this: Enchantment#conflictsWith(...)", "author": "TheBusyBiscuit", "createdAt": "2020-06-28T23:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY5Njc4MA=="}], "type": "inlineReview"}, {"oid": "28b5d545da8f958ceaa9949e5eef9a92564be3f2", "url": "https://github.com/Slimefun/Slimefun4/commit/28b5d545da8f958ceaa9949e5eef9a92564be3f2", "message": "Did some requested change.", "committedDate": "2020-06-28T21:56:38Z", "type": "commit"}, {"oid": "833b2d3943b1f843ab26b51bbf6d145f85951ec3", "url": "https://github.com/Slimefun/Slimefun4/commit/833b2d3943b1f843ab26b51bbf6d145f85951ec3", "message": "Did another requested change.", "committedDate": "2020-06-28T22:11:01Z", "type": "commit"}, {"oid": "942bf436bbbb934a7975eb923b604286f9458499", "url": "https://github.com/Slimefun/Slimefun4/commit/942bf436bbbb934a7975eb923b604286f9458499", "message": "Did another requested change.", "committedDate": "2020-06-29T07:02:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg4Mjk5NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2046#discussion_r446882994", "bodyText": "You are creating two new ArrayLists here.\nPlease only use .get(), do a null check and then copy. Otherwise you are just creating a wasteful List, which you then copy and then discard both. This is really inefficient.", "author": "TheBusyBiscuit", "createdAt": "2020-06-29T10:09:56Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/magical/EnchantmentRune.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package io.github.thebusybiscuit.slimefun4.implementation.items.magical;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.bukkit.Location;\n+import org.bukkit.Material;\n+import org.bukkit.Particle;\n+import org.bukkit.Sound;\n+import org.bukkit.enchantments.Enchantment;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Item;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.player.PlayerDropItemEvent;\n+import org.bukkit.inventory.ItemStack;\n+\n+import me.mrCookieSlime.Slimefun.Lists.RecipeType;\n+import me.mrCookieSlime.Slimefun.Objects.Category;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SimpleSlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.Objects.handlers.ItemDropHandler;\n+import me.mrCookieSlime.Slimefun.SlimefunPlugin;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n+\n+/**\n+ * This {@link SlimefunItem} allows you to enchant any enchantable {@link ItemStack} with a random\n+ * {@link Enchantment}. It is also one of the very few utilisations of {@link ItemDropHandler}.\n+ *\n+ * @author Linox\n+ *\n+ * @see ItemDropHandler\n+ * @see Enchantment\n+ *\n+ */\n+public class EnchantmentRune extends SimpleSlimefunItem<ItemDropHandler> {\n+\n+    private static final double RANGE = 1.5;\n+    private final Map<Material, List<Enchantment>> applicableEnchantments = new EnumMap<>(Material.class);\n+\n+    public EnchantmentRune(Category category, SlimefunItemStack item, RecipeType recipeType, ItemStack[] recipe) {\n+        super(category, item, recipeType, recipe);\n+\n+        for (Material mat : Material.values()) {\n+            List<Enchantment> enchantments = new ArrayList<>();\n+            for (Enchantment enchantment : Enchantment.values()) {\n+                if (enchantment == Enchantment.BINDING_CURSE || enchantment == Enchantment.VANISHING_CURSE) continue;\n+                if (enchantment.canEnchantItem(new ItemStack(mat))) enchantments.add(enchantment);\n+            }\n+            applicableEnchantments.put(mat, enchantments);\n+        }\n+    }\n+\n+    @Override\n+    public ItemDropHandler getItemHandler() {\n+        return (e, p, item) -> {\n+            if (isItem(item.getItemStack())) {\n+\n+                if (!Slimefun.hasUnlocked(p, this, true)) {\n+                    return true;\n+                }\n+\n+                Slimefun.runSync(() -> activate(p, e, item), 20L);\n+\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private void activate(Player p, PlayerDropItemEvent e, Item item) {\n+        // Being sure the entity is still valid and not picked up or whatsoever.\n+        if (!item.isValid()) {\n+            return;\n+        }\n+\n+        Location l = item.getLocation();\n+        Collection<Entity> entites = l.getWorld().getNearbyEntities(l, RANGE, RANGE, RANGE, this::findCompatibleItem);\n+        Optional<Entity> optional = entites.stream().findFirst();\n+\n+        if (optional.isPresent()) {\n+            Item entity = (Item) optional.get();\n+            ItemStack target = entity.getItemStack();\n+\n+            List<Enchantment> applicableEnchantmentList = new ArrayList<>(applicableEnchantments.getOrDefault(target.getType(), new ArrayList<>()));\n+            if (applicableEnchantmentList.isEmpty()) {", "originalCommit": "942bf436bbbb934a7975eb923b604286f9458499", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b6112e272867516383c48831fa1dd9990b45c97b", "url": "https://github.com/Slimefun/Slimefun4/commit/b6112e272867516383c48831fa1dd9990b45c97b", "message": "Did a requested change.", "committedDate": "2020-06-29T11:45:27Z", "type": "commit"}]}