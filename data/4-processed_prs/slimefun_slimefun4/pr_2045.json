{"pr_number": 2045, "pr_title": "Explosive Bow Area of Effect", "pr_createdAt": "2020-06-25T19:19:53Z", "pr_url": "https://github.com/Slimefun/Slimefun4/pull/2045", "timeline": [{"oid": "e016ea11803274e4ebe30727b5d8df026c73aaa1", "url": "https://github.com/Slimefun/Slimefun4/commit/e016ea11803274e4ebe30727b5d8df026c73aaa1", "message": "Explosive Bow Functionality Changed.\n\nExplosive Bow now deals an area of effect.", "committedDate": "2020-06-25T19:13:24Z", "type": "commit"}, {"oid": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "url": "https://github.com/Slimefun/Slimefun4/commit/1a8ff9c5111994036ba82884af831b6d4613b0e9", "message": "Merge branch 'master' of https://github.com/LinoxGH/Slimefun4 into ExplosiveBowChange", "committedDate": "2020-06-25T19:16:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMDM0NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446520344", "bodyText": "You should just negate it and include this in the if-statement above.", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T12:35:04Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/listeners/SlimefunBowListener.java", "diffHunk": "@@ -69,6 +70,7 @@ public void onArrowHit(ProjectileHitEvent e) {\n     @EventHandler\n     public void onArrowSuccessfulHit(EntityDamageByEntityEvent e) {\n         if (e.getDamager() instanceof Arrow && e.getEntity() instanceof LivingEntity) {\n+            if (e.getCause() == EntityDamageEvent.DamageCause.ENTITY_EXPLOSION) return;", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMDQyOA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446520428", "bodyText": "Never use == when comparing doubles, due to floating point errors, this is a very unreliable operation.\nYou should instead do sth like distance <= 0.05 or so.", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T12:35:56Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,67 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<>(\"explosion-range\", 3);\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity);\n+            for (Entity entity : entites) {\n+                if (entity.isValid() && entity instanceof LivingEntity) {\n+                    LivingEntity entityL = (LivingEntity) entity;\n+\n+                    double distance = entityL.getLocation().distance(n.getLocation());\n+                    double damage = calculateDamage(distance, e.getDamage());\n+\n+                    Vector distanceVector = entityL.getLocation().toVector().subtract(n.getLocation().toVector());\n+                    distanceVector.setY(distanceVector.getY() + 0.6D);\n+                    Vector entityVelocity = entityL.getVelocity();\n+                    Vector knockback = entityVelocity.add(distanceVector.normalize().multiply((int) (e.getDamage() / Math.round(damage))));\n+                    entityL.setVelocity(knockback);\n+\n+                    entityL.getWorld().spawnParticle(Particle.EXPLOSION_LARGE, entityL.getLocation(), 1);\n+                    entityL.getWorld().playSound(entityL.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+\n+                    if (!entityL.getUniqueId().equals(n.getUniqueId())) {\n+                        entityL.damage(damage);\n+                        EntityDamageByEntityEvent damageEvent = new EntityDamageByEntityEvent(e.getDamager(), entityL, EntityDamageEvent.DamageCause.ENTITY_EXPLOSION, damage);\n+                        Bukkit.getPluginManager().callEvent(damageEvent);\n+                    }\n+                }\n+            }\n         };\n     }\n \n+    private double calculateDamage(double distance, double ogDamage) {\n+\n+        if (distance == 0D) return ogDamage;", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMDQzNw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446520437", "bodyText": "The name \"ogDamage\" seems rather un-intuitive.", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T12:36:13Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,67 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<>(\"explosion-range\", 3);\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity);\n+            for (Entity entity : entites) {\n+                if (entity.isValid() && entity instanceof LivingEntity) {\n+                    LivingEntity entityL = (LivingEntity) entity;\n+\n+                    double distance = entityL.getLocation().distance(n.getLocation());\n+                    double damage = calculateDamage(distance, e.getDamage());\n+\n+                    Vector distanceVector = entityL.getLocation().toVector().subtract(n.getLocation().toVector());\n+                    distanceVector.setY(distanceVector.getY() + 0.6D);\n+                    Vector entityVelocity = entityL.getVelocity();\n+                    Vector knockback = entityVelocity.add(distanceVector.normalize().multiply((int) (e.getDamage() / Math.round(damage))));\n+                    entityL.setVelocity(knockback);\n+\n+                    entityL.getWorld().spawnParticle(Particle.EXPLOSION_LARGE, entityL.getLocation(), 1);\n+                    entityL.getWorld().playSound(entityL.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+\n+                    if (!entityL.getUniqueId().equals(n.getUniqueId())) {\n+                        entityL.damage(damage);\n+                        EntityDamageByEntityEvent damageEvent = new EntityDamageByEntityEvent(e.getDamager(), entityL, EntityDamageEvent.DamageCause.ENTITY_EXPLOSION, damage);\n+                        Bukkit.getPluginManager().callEvent(damageEvent);\n+                    }\n+                }\n+            }\n         };\n     }\n \n+    private double calculateDamage(double distance, double ogDamage) {", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMDUzNw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446520537", "bodyText": "Why are you doing this?\nAlso seems quite wasteful to round it and then compare it with ==, should instead use a threshold.\nOr since you seem to want to always have at least a damage of 1 you can just use Math.max(1, damage) instead.", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T12:37:31Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,67 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<>(\"explosion-range\", 3);\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity);\n+            for (Entity entity : entites) {\n+                if (entity.isValid() && entity instanceof LivingEntity) {\n+                    LivingEntity entityL = (LivingEntity) entity;\n+\n+                    double distance = entityL.getLocation().distance(n.getLocation());\n+                    double damage = calculateDamage(distance, e.getDamage());\n+\n+                    Vector distanceVector = entityL.getLocation().toVector().subtract(n.getLocation().toVector());\n+                    distanceVector.setY(distanceVector.getY() + 0.6D);\n+                    Vector entityVelocity = entityL.getVelocity();\n+                    Vector knockback = entityVelocity.add(distanceVector.normalize().multiply((int) (e.getDamage() / Math.round(damage))));\n+                    entityL.setVelocity(knockback);\n+\n+                    entityL.getWorld().spawnParticle(Particle.EXPLOSION_LARGE, entityL.getLocation(), 1);\n+                    entityL.getWorld().playSound(entityL.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+\n+                    if (!entityL.getUniqueId().equals(n.getUniqueId())) {\n+                        entityL.damage(damage);\n+                        EntityDamageByEntityEvent damageEvent = new EntityDamageByEntityEvent(e.getDamager(), entityL, EntityDamageEvent.DamageCause.ENTITY_EXPLOSION, damage);\n+                        Bukkit.getPluginManager().callEvent(damageEvent);\n+                    }\n+                }\n+            }\n         };\n     }\n \n+    private double calculateDamage(double distance, double ogDamage) {\n+\n+        if (distance == 0D) return ogDamage;\n+        double damage = ogDamage - Math.pow((distance / range.getValue()), 2.5);\n+        if (Math.round(damage) == 0D) damage += 1D;", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMDY2Mw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446520663", "bodyText": "This \"instanceof LivingEntity\" check is redundant, you are already doing this in the Predicate above.", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T12:37:57Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,67 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<>(\"explosion-range\", 3);\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity);\n+            for (Entity entity : entites) {\n+                if (entity.isValid() && entity instanceof LivingEntity) {", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMDgyMw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446520823", "bodyText": "Also this .IsValid() method should be moved to the Predicate", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T12:38:22Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,67 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<>(\"explosion-range\", 3);\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity);\n+            for (Entity entity : entites) {\n+                if (entity.isValid() && entity instanceof LivingEntity) {", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMTA1Mw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446521053", "bodyText": ".distance() is a rather expensive operation and not really needed for this purpose, should rather use .distanceSquared() and then calculate the damage based on that.", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T12:38:56Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,67 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<>(\"explosion-range\", 3);\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity);\n+            for (Entity entity : entites) {\n+                if (entity.isValid() && entity instanceof LivingEntity) {\n+                    LivingEntity entityL = (LivingEntity) entity;\n+\n+                    double distance = entityL.getLocation().distance(n.getLocation());", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyNjQyNQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446526425", "bodyText": "I have no idea how can I use squared distance instead", "author": "LinoxGH", "createdAt": "2020-06-27T13:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMTI1MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446521251", "bodyText": "Why are you rounding the damage here?", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T12:39:24Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,67 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<>(\"explosion-range\", 3);\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity);\n+            for (Entity entity : entites) {\n+                if (entity.isValid() && entity instanceof LivingEntity) {\n+                    LivingEntity entityL = (LivingEntity) entity;\n+\n+                    double distance = entityL.getLocation().distance(n.getLocation());\n+                    double damage = calculateDamage(distance, e.getDamage());\n+\n+                    Vector distanceVector = entityL.getLocation().toVector().subtract(n.getLocation().toVector());\n+                    distanceVector.setY(distanceVector.getY() + 0.6D);\n+                    Vector entityVelocity = entityL.getVelocity();\n+                    Vector knockback = entityVelocity.add(distanceVector.normalize().multiply((int) (e.getDamage() / Math.round(damage))));", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyNTQ3NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446525474", "bodyText": "Because a double value can be infinite, and from what I've heard doing equations with those cause problems(exceptions).", "author": "LinoxGH", "createdAt": "2020-06-27T13:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMTI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyNTcyNg==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446525726", "bodyText": "You are already performing a min operation on that, so this being infinite is infinitely impossible.", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T13:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMTI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMTQ4MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446521481", "bodyText": "This check should probably happen wayyyyyyyy earlier. Best would be in the Predicate itself.", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T12:39:53Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,67 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<>(\"explosion-range\", 3);\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity);\n+            for (Entity entity : entites) {\n+                if (entity.isValid() && entity instanceof LivingEntity) {\n+                    LivingEntity entityL = (LivingEntity) entity;\n+\n+                    double distance = entityL.getLocation().distance(n.getLocation());\n+                    double damage = calculateDamage(distance, e.getDamage());\n+\n+                    Vector distanceVector = entityL.getLocation().toVector().subtract(n.getLocation().toVector());\n+                    distanceVector.setY(distanceVector.getY() + 0.6D);\n+                    Vector entityVelocity = entityL.getVelocity();\n+                    Vector knockback = entityVelocity.add(distanceVector.normalize().multiply((int) (e.getDamage() / Math.round(damage))));\n+                    entityL.setVelocity(knockback);\n+\n+                    entityL.getWorld().spawnParticle(Particle.EXPLOSION_LARGE, entityL.getLocation(), 1);\n+                    entityL.getWorld().playSound(entityL.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+\n+                    if (!entityL.getUniqueId().equals(n.getUniqueId())) {", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUzMzU4Nw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446533587", "bodyText": "Nah it shouldn't because we want knockback and explosion effect for the main target too.", "author": "LinoxGH", "createdAt": "2020-06-27T14:44:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyMTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUyNTc3NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446525774", "bodyText": "Also should probably override the validation method for this, since we don't want negative or zero ranges.", "author": "TheBusyBiscuit", "createdAt": "2020-06-27T13:15:41Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,67 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<>(\"explosion-range\", 3);", "originalCommit": "1a8ff9c5111994036ba82884af831b6d4613b0e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "558d069a331793cc226901b8230eb2e6a95c853b", "url": "https://github.com/Slimefun/Slimefun4/commit/558d069a331793cc226901b8230eb2e6a95c853b", "message": "Did the requested changes + improvements.", "committedDate": "2020-06-27T14:45:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTI2Nw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446585267", "bodyText": "This is a boxed int, null check needed.", "author": "WalshyDev", "createdAt": "2020-06-28T01:02:11Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,70 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<Integer>(\"explosion-range\", 3) {\n+        @Override\n+        public boolean validateInput(Integer input) {\n+            return input > 0;", "originalCommit": "558d069a331793cc226901b8230eb2e6a95c853b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTM2Mw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446585363", "bodyText": "Explosion particle for every entity in the AOE? Surely this should just be in the actual centre.", "author": "WalshyDev", "createdAt": "2020-06-28T01:04:04Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,70 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<Integer>(\"explosion-range\", 3) {\n+        @Override\n+        public boolean validateInput(Integer input) {\n+            return input > 0;\n+        }\n+    };\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity && entity.isValid());\n+            for (Entity entity : entites) {\n+                LivingEntity entityL = (LivingEntity) entity;\n+\n+                Vector distanceVector = entityL.getLocation().toVector().subtract(n.getLocation().toVector());\n+                distanceVector.setY(distanceVector.getY() + 0.6D);\n+                Vector entityVelocity = entityL.getVelocity();\n+\n+                double distanceSquared = distanceVector.lengthSquared();\n+                double damage = calculateDamage(distanceSquared, e.getDamage());\n+\n+                Vector knockback = entityVelocity.add(distanceVector.normalize().multiply((int) (e.getDamage() / damage)));\n+                entityL.setVelocity(knockback);\n+\n+                entityL.getWorld().spawnParticle(Particle.EXPLOSION_LARGE, entityL.getLocation(), 1);", "originalCommit": "558d069a331793cc226901b8230eb2e6a95c853b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTU3MA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446585570", "bodyText": "Can you rename this \"n\" variable. It's very nondescript.", "author": "WalshyDev", "createdAt": "2020-06-28T01:07:06Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,70 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<Integer>(\"explosion-range\", 3) {\n+        @Override\n+        public boolean validateInput(Integer input) {\n+            return input > 0;\n+        }\n+    };\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {", "originalCommit": "558d069a331793cc226901b8230eb2e6a95c853b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTY2Mg==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446585662", "bodyText": "This is a cancellable event. Also, like most events, this is a pre-damage event not post. So, move the damage down, make sure it isn't cancelled and then make sure the damage is actually correct.", "author": "WalshyDev", "createdAt": "2020-06-28T01:08:59Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,70 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<Integer>(\"explosion-range\", 3) {\n+        @Override\n+        public boolean validateInput(Integer input) {\n+            return input > 0;\n+        }\n+    };\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity && entity.isValid());\n+            for (Entity entity : entites) {\n+                LivingEntity entityL = (LivingEntity) entity;\n+\n+                Vector distanceVector = entityL.getLocation().toVector().subtract(n.getLocation().toVector());\n+                distanceVector.setY(distanceVector.getY() + 0.6D);\n+                Vector entityVelocity = entityL.getVelocity();\n+\n+                double distanceSquared = distanceVector.lengthSquared();\n+                double damage = calculateDamage(distanceSquared, e.getDamage());\n+\n+                Vector knockback = entityVelocity.add(distanceVector.normalize().multiply((int) (e.getDamage() / damage)));\n+                entityL.setVelocity(knockback);\n+\n+                entityL.getWorld().spawnParticle(Particle.EXPLOSION_LARGE, entityL.getLocation(), 1);\n+                entityL.getWorld().playSound(entityL.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+\n+                if (!entityL.getUniqueId().equals(n.getUniqueId())) {\n+                    entityL.damage(damage);\n+                    EntityDamageByEntityEvent damageEvent = new EntityDamageByEntityEvent(e.getDamager(), entityL, EntityDamageEvent.DamageCause.ENTITY_EXPLOSION, damage);", "originalCommit": "558d069a331793cc226901b8230eb2e6a95c853b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTQ4Mg==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446591482", "bodyText": "I'm not sure I understand this fully. Can you elaborate a little?", "author": "LinoxGH", "createdAt": "2020-06-28T02:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTY3OQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446591679", "bodyText": "If a plugin wants to change the damage or even cancel then this is what should happen. Right now you aren't letting this happen.\nYou need to fire event, check if cancelled, if not, then damage(e.getDamage());", "author": "WalshyDev", "createdAt": "2020-06-28T02:41:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTY3Mw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2045#discussion_r446585673", "bodyText": "Empty line.", "author": "WalshyDev", "createdAt": "2020-06-28T01:09:09Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/weapons/ExplosiveBow.java", "diffHunk": "@@ -1,28 +1,70 @@\n package io.github.thebusybiscuit.slimefun4.implementation.items.weapons;\n \n+import org.bukkit.Bukkit;\n+import org.bukkit.Particle;\n import org.bukkit.Sound;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.LivingEntity;\n+import org.bukkit.event.entity.EntityDamageByEntityEvent;\n+import org.bukkit.event.entity.EntityDamageEvent;\n import org.bukkit.inventory.ItemStack;\n import org.bukkit.util.Vector;\n \n+import io.github.thebusybiscuit.slimefun4.api.items.ItemSetting;\n import me.mrCookieSlime.Slimefun.Objects.Category;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BowShootHandler;\n import me.mrCookieSlime.Slimefun.api.SlimefunItemStack;\n \n+import java.util.Collection;\n+\n public class ExplosiveBow extends SlimefunBow {\n \n+    private final ItemSetting<Integer> range = new ItemSetting<Integer>(\"explosion-range\", 3) {\n+        @Override\n+        public boolean validateInput(Integer input) {\n+            return input > 0;\n+        }\n+    };\n+\n     public ExplosiveBow(Category category, SlimefunItemStack item, ItemStack[] recipe) {\n         super(category, item, recipe);\n+        addItemSetting(range);\n     }\n \n     @Override\n     public BowShootHandler onShoot() {\n         return (e, n) -> {\n-            Vector vector = n.getVelocity();\n-            vector.setY(0.6);\n-            n.setVelocity(vector);\n-            n.getWorld().createExplosion(n.getLocation(), 0F);\n-            n.getWorld().playSound(n.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+            Collection<Entity> entites = n.getWorld().getNearbyEntities(n.getLocation(), range.getValue(), range.getValue(), range.getValue(), entity -> entity instanceof LivingEntity && entity.isValid());\n+            for (Entity entity : entites) {\n+                LivingEntity entityL = (LivingEntity) entity;\n+\n+                Vector distanceVector = entityL.getLocation().toVector().subtract(n.getLocation().toVector());\n+                distanceVector.setY(distanceVector.getY() + 0.6D);\n+                Vector entityVelocity = entityL.getVelocity();\n+\n+                double distanceSquared = distanceVector.lengthSquared();\n+                double damage = calculateDamage(distanceSquared, e.getDamage());\n+\n+                Vector knockback = entityVelocity.add(distanceVector.normalize().multiply((int) (e.getDamage() / damage)));\n+                entityL.setVelocity(knockback);\n+\n+                entityL.getWorld().spawnParticle(Particle.EXPLOSION_LARGE, entityL.getLocation(), 1);\n+                entityL.getWorld().playSound(entityL.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);\n+\n+                if (!entityL.getUniqueId().equals(n.getUniqueId())) {\n+                    entityL.damage(damage);\n+                    EntityDamageByEntityEvent damageEvent = new EntityDamageByEntityEvent(e.getDamager(), entityL, EntityDamageEvent.DamageCause.ENTITY_EXPLOSION, damage);\n+                    Bukkit.getPluginManager().callEvent(damageEvent);\n+                }\n+            }\n         };\n     }\n \n+    private double calculateDamage(double distanceSquared, double originalDamage) {\n+", "originalCommit": "558d069a331793cc226901b8230eb2e6a95c853b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f3d21daf6a65703812ada0b082a5a02e36f906f9", "url": "https://github.com/Slimefun/Slimefun4/commit/f3d21daf6a65703812ada0b082a5a02e36f906f9", "message": "Did the requested changes.", "committedDate": "2020-06-28T02:38:49Z", "type": "commit"}, {"oid": "d7ba054befffd980a495d262120f12f3c3d9516c", "url": "https://github.com/Slimefun/Slimefun4/commit/d7ba054befffd980a495d262120f12f3c3d9516c", "message": "Removed unused imports.", "committedDate": "2020-06-28T02:39:32Z", "type": "commit"}, {"oid": "911ee2340f5c782f0022b6a37b3ae66e45e630d5", "url": "https://github.com/Slimefun/Slimefun4/commit/911ee2340f5c782f0022b6a37b3ae66e45e630d5", "message": "Did a requested change.", "committedDate": "2020-06-28T11:22:15Z", "type": "commit"}]}