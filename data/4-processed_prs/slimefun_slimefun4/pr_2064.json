{"pr_number": 2064, "pr_title": "Changes to performance, added a proper Lag Profiler", "pr_createdAt": "2020-06-30T17:41:40Z", "pr_url": "https://github.com/Slimefun/Slimefun4/pull/2064", "timeline": [{"oid": "0aa99df8c2db0830c2fe10cd0ad1dc51c9c6c986", "url": "https://github.com/Slimefun/Slimefun4/commit/0aa99df8c2db0830c2fe10cd0ad1dc51c9c6c986", "message": "Performance optimization", "committedDate": "2020-06-30T14:44:50Z", "type": "commit"}, {"oid": "d82b66a842cd03788a1247b945cb60de832bee7d", "url": "https://github.com/Slimefun/Slimefun4/commit/d82b66a842cd03788a1247b945cb60de832bee7d", "message": "Added a better profiler", "committedDate": "2020-06-30T17:36:55Z", "type": "commit"}, {"oid": "a4197fe5dde16d257098ee9fff8af8b7deefa235", "url": "https://github.com/Slimefun/Slimefun4/commit/a4197fe5dde16d257098ee9fff8af8b7deefa235", "message": "A couple of performance and memory optimizations", "committedDate": "2020-06-30T19:31:55Z", "type": "commit"}, {"oid": "1016b5fc76d30bf0733f7fb09c0ba6925825dce8", "url": "https://github.com/Slimefun/Slimefun4/commit/1016b5fc76d30bf0733f7fb09c0ba6925825dce8", "message": "Added better summaries, ratings + more performance improvements", "committedDate": "2020-07-01T16:20:34Z", "type": "commit"}, {"oid": "ef7624dde9a214b88c81d977b6593ece126decb3", "url": "https://github.com/Slimefun/Slimefun4/commit/ef7624dde9a214b88c81d977b6593ece126decb3", "message": "Performance improvement for ChestTerminal", "committedDate": "2020-07-01T18:39:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5Njk5MA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2064#discussion_r448696990", "bodyText": "You know you can send \\n in chat right? You don't need to send 30 messages. 1 message with \\n.\nIt's great. M", "author": "WalshyDev", "createdAt": "2020-07-02T01:22:37Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/services/profiler/PerformanceSummary.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package io.github.thebusybiscuit.slimefun4.core.services.profiler;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.utils.ChatUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.NumberUtils;\n+import net.md_5.bungee.api.ChatColor;\n+import net.md_5.bungee.api.chat.HoverEvent;\n+import net.md_5.bungee.api.chat.TextComponent;\n+\n+class PerformanceSummary {\n+\n+    // The threshold at which a Block or Chunk is significant enough to appear in /sf timings\n+    private static final int VISIBILITY_THRESHOLD = 275_000;\n+\n+    // A minecraft server tick is 50ms and Slimefun ticks are stretched across\n+    // two ticks (sync and async blocks), so we use 100ms as a reference here\n+    static final int MAX_TICK_DURATION = 100;\n+\n+    private final SlimefunProfiler profiler;\n+    private final PerformanceRating rating;\n+    private final long totalElapsedTime;\n+    private final int totalTickedBlocks;\n+\n+    private final Map<String, Long> chunks;\n+    private final Map<String, Long> items;\n+\n+    PerformanceSummary(SlimefunProfiler profiler, long totalElapsedTime, int totalTickedBlocks) {\n+        this.profiler = profiler;\n+        this.rating = profiler.getPerformance();\n+        this.totalElapsedTime = totalElapsedTime;\n+        this.totalTickedBlocks = totalTickedBlocks;\n+\n+        chunks = profiler.getByChunk();\n+        items = profiler.getByItem();\n+    }\n+\n+    public void send(CommandSender sender) {\n+        sender.sendMessage(\"\");\n+        sender.sendMessage(ChatColor.GREEN + \"===== Slimefun Lag Profiler =====\");\n+        sender.sendMessage(ChatColors.color(\"&6Total: &e\" + NumberUtils.getAsMillis(totalElapsedTime)));\n+        sender.sendMessage(ChatColors.color(\"&6Performance: \" + getPerformanceRating()));\n+        sender.sendMessage(ChatColors.color(\"&6Active Chunks: &e\" + chunks.size()));\n+        sender.sendMessage(ChatColors.color(\"&6Active Blocks: &e\" + totalTickedBlocks));\n+        sender.sendMessage(\"\");\n+\n+        summarizeTimings(\"Chunks\", sender, entry -> {\n+            int count = profiler.getBlocksOfId(entry.getKey());\n+            String time = NumberUtils.getAsMillis(entry.getValue());\n+\n+            if (count > 1) {\n+                String average = NumberUtils.getAsMillis(entry.getValue() / count);\n+\n+                return entry.getKey() + \" - \" + count + \"x (\" + time + \", \" + average + \" avg/block)\";\n+            }\n+            else {\n+                return entry.getKey() + \" - \" + count + \"x (\" + time + ')';\n+            }\n+        }, items.entrySet().stream());\n+\n+        sender.sendMessage(\"\");\n+\n+        summarizeTimings(\"Blocks\", sender, entry -> {\n+            int count = profiler.getBlocksInChunk(entry.getKey());\n+            String time = NumberUtils.getAsMillis(entry.getValue());\n+\n+            return entry.getKey() + \" - \" + count + \"x (\" + time + \")\";\n+        }, chunks.entrySet().stream());\n+    }\n+\n+    private void summarizeTimings(String prefix, CommandSender sender, Function<Map.Entry<String, Long>, String> formatter, Stream<Map.Entry<String, Long>> stream) {\n+        List<Entry<String, Long>> results = stream.sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())).collect(Collectors.toList());\n+\n+        if (sender instanceof Player) {\n+            TextComponent component = new TextComponent(prefix);\n+            component.setColor(ChatColor.GOLD);\n+\n+            TextComponent hoverComponent = new TextComponent(\"\\n   Hover for more details...\");\n+            hoverComponent.setColor(ChatColor.GRAY);\n+            hoverComponent.setItalic(true);\n+            StringBuilder builder = new StringBuilder();\n+            int hidden = 0;\n+\n+            for (Map.Entry<String, Long> entry : results) {\n+                if (entry.getValue() > VISIBILITY_THRESHOLD) {\n+                    builder.append(\"\\n&e\").append(formatter.apply(entry));\n+                }\n+                else {\n+                    hidden++;\n+                }\n+            }\n+\n+            builder.append(\"\\n\\n&c+ &6\").append(hidden).append(\" more\");\n+            hoverComponent.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, TextComponent.fromLegacyText(ChatColors.color(builder.toString()))));\n+\n+            component.addExtra(hoverComponent);\n+            sender.spigot().sendMessage(component);\n+        }\n+        else {\n+            int hidden = 0;\n+\n+            sender.sendMessage(ChatColor.GOLD + prefix);\n+\n+            for (Map.Entry<String, Long> entry : results) {\n+                if (entry.getValue() > VISIBILITY_THRESHOLD) {\n+                    sender.sendMessage(\"  \" + ChatColor.stripColor(formatter.apply(entry)));\n+                }\n+                else {\n+                    hidden++;\n+                }\n+            }\n+\n+            sender.sendMessage(\"+ \" + hidden + \" more\");", "originalCommit": "ef7624dde9a214b88c81d977b6593ece126decb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5NzIzNQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2064#discussion_r448697235", "bodyText": "Should null check, anytime you encounter a boxed value you always have to null check.", "author": "WalshyDev", "createdAt": "2020-07-02T01:23:37Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/services/profiler/PerformanceRating.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package io.github.thebusybiscuit.slimefun4.core.services.profiler;\n+\n+import java.util.function.Predicate;\n+\n+import org.bukkit.ChatColor;\n+\n+/**\n+ * This enum is used to quantify Slimefun's performance impact. This way we can assign a\n+ * \"grade\" to each timings report and also use this for metrics collection.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see SlimefunProfiler\n+ *\n+ */\n+public enum PerformanceRating implements Predicate<Float> {\n+\n+    // Thresholds might change in the future!\n+\n+    UNKNOWN(ChatColor.WHITE, -1),\n+\n+    GOOD(ChatColor.DARK_GREEN, 10),\n+    FINE(ChatColor.DARK_GREEN, 20),\n+    OKAY(ChatColor.GREEN, 30),\n+    MODERATE(ChatColor.YELLOW, 55),\n+    SEVERE(ChatColor.RED, 85),\n+    HURTFUL(ChatColor.DARK_RED, Float.MAX_VALUE);\n+\n+    private final ChatColor color;\n+    private final float threshold;\n+\n+    PerformanceRating(ChatColor color, float threshold) {\n+        this.color = color;\n+        this.threshold = threshold;\n+    }\n+\n+    @Override\n+    public boolean test(Float value) {\n+        return value <= threshold;", "originalCommit": "ef7624dde9a214b88c81d977b6593ece126decb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5NzQ5Mw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2064#discussion_r448697493", "bodyText": "\\n is your friend", "author": "WalshyDev", "createdAt": "2020-07-02T01:24:37Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/services/profiler/PerformanceSummary.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package io.github.thebusybiscuit.slimefun4.core.services.profiler;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.utils.ChatUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.NumberUtils;\n+import net.md_5.bungee.api.ChatColor;\n+import net.md_5.bungee.api.chat.HoverEvent;\n+import net.md_5.bungee.api.chat.TextComponent;\n+\n+class PerformanceSummary {\n+\n+    // The threshold at which a Block or Chunk is significant enough to appear in /sf timings\n+    private static final int VISIBILITY_THRESHOLD = 275_000;\n+\n+    // A minecraft server tick is 50ms and Slimefun ticks are stretched across\n+    // two ticks (sync and async blocks), so we use 100ms as a reference here\n+    static final int MAX_TICK_DURATION = 100;\n+\n+    private final SlimefunProfiler profiler;\n+    private final PerformanceRating rating;\n+    private final long totalElapsedTime;\n+    private final int totalTickedBlocks;\n+\n+    private final Map<String, Long> chunks;\n+    private final Map<String, Long> items;\n+\n+    PerformanceSummary(SlimefunProfiler profiler, long totalElapsedTime, int totalTickedBlocks) {\n+        this.profiler = profiler;\n+        this.rating = profiler.getPerformance();\n+        this.totalElapsedTime = totalElapsedTime;\n+        this.totalTickedBlocks = totalTickedBlocks;\n+\n+        chunks = profiler.getByChunk();\n+        items = profiler.getByItem();\n+    }\n+\n+    public void send(CommandSender sender) {\n+        sender.sendMessage(\"\");\n+        sender.sendMessage(ChatColor.GREEN + \"===== Slimefun Lag Profiler =====\");\n+        sender.sendMessage(ChatColors.color(\"&6Total: &e\" + NumberUtils.getAsMillis(totalElapsedTime)));\n+        sender.sendMessage(ChatColors.color(\"&6Performance: \" + getPerformanceRating()));\n+        sender.sendMessage(ChatColors.color(\"&6Active Chunks: &e\" + chunks.size()));\n+        sender.sendMessage(ChatColors.color(\"&6Active Blocks: &e\" + totalTickedBlocks));\n+        sender.sendMessage(\"\");", "originalCommit": "ef7624dde9a214b88c81d977b6593ece126decb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg3MDI5Nw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2064#discussion_r448870297", "bodyText": "Yeah not gonna convert this one really. Having a StringBuilder for this would just be extremely ugly here.", "author": "TheBusyBiscuit", "createdAt": "2020-07-02T09:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5NzQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5Nzk2OQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2064#discussion_r448697969", "bodyText": "Quite cumbersome to have this in one line", "author": "WalshyDev", "createdAt": "2020-07-02T01:26:26Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/services/profiler/PerformanceSummary.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package io.github.thebusybiscuit.slimefun4.core.services.profiler;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.utils.ChatUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.NumberUtils;\n+import net.md_5.bungee.api.ChatColor;\n+import net.md_5.bungee.api.chat.HoverEvent;\n+import net.md_5.bungee.api.chat.TextComponent;\n+\n+class PerformanceSummary {\n+\n+    // The threshold at which a Block or Chunk is significant enough to appear in /sf timings\n+    private static final int VISIBILITY_THRESHOLD = 275_000;\n+\n+    // A minecraft server tick is 50ms and Slimefun ticks are stretched across\n+    // two ticks (sync and async blocks), so we use 100ms as a reference here\n+    static final int MAX_TICK_DURATION = 100;\n+\n+    private final SlimefunProfiler profiler;\n+    private final PerformanceRating rating;\n+    private final long totalElapsedTime;\n+    private final int totalTickedBlocks;\n+\n+    private final Map<String, Long> chunks;\n+    private final Map<String, Long> items;\n+\n+    PerformanceSummary(SlimefunProfiler profiler, long totalElapsedTime, int totalTickedBlocks) {\n+        this.profiler = profiler;\n+        this.rating = profiler.getPerformance();\n+        this.totalElapsedTime = totalElapsedTime;\n+        this.totalTickedBlocks = totalTickedBlocks;\n+\n+        chunks = profiler.getByChunk();\n+        items = profiler.getByItem();\n+    }\n+\n+    public void send(CommandSender sender) {\n+        sender.sendMessage(\"\");\n+        sender.sendMessage(ChatColor.GREEN + \"===== Slimefun Lag Profiler =====\");\n+        sender.sendMessage(ChatColors.color(\"&6Total: &e\" + NumberUtils.getAsMillis(totalElapsedTime)));\n+        sender.sendMessage(ChatColors.color(\"&6Performance: \" + getPerformanceRating()));\n+        sender.sendMessage(ChatColors.color(\"&6Active Chunks: &e\" + chunks.size()));\n+        sender.sendMessage(ChatColors.color(\"&6Active Blocks: &e\" + totalTickedBlocks));\n+        sender.sendMessage(\"\");\n+\n+        summarizeTimings(\"Chunks\", sender, entry -> {\n+            int count = profiler.getBlocksOfId(entry.getKey());\n+            String time = NumberUtils.getAsMillis(entry.getValue());\n+\n+            if (count > 1) {\n+                String average = NumberUtils.getAsMillis(entry.getValue() / count);\n+\n+                return entry.getKey() + \" - \" + count + \"x (\" + time + \", \" + average + \" avg/block)\";\n+            }\n+            else {\n+                return entry.getKey() + \" - \" + count + \"x (\" + time + ')';\n+            }\n+        }, items.entrySet().stream());\n+\n+        sender.sendMessage(\"\");\n+\n+        summarizeTimings(\"Blocks\", sender, entry -> {\n+            int count = profiler.getBlocksInChunk(entry.getKey());\n+            String time = NumberUtils.getAsMillis(entry.getValue());\n+\n+            return entry.getKey() + \" - \" + count + \"x (\" + time + \")\";\n+        }, chunks.entrySet().stream());\n+    }\n+\n+    private void summarizeTimings(String prefix, CommandSender sender, Function<Map.Entry<String, Long>, String> formatter, Stream<Map.Entry<String, Long>> stream) {\n+        List<Entry<String, Long>> results = stream.sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())).collect(Collectors.toList());\n+\n+        if (sender instanceof Player) {\n+            TextComponent component = new TextComponent(prefix);\n+            component.setColor(ChatColor.GOLD);\n+\n+            TextComponent hoverComponent = new TextComponent(\"\\n   Hover for more details...\");\n+            hoverComponent.setColor(ChatColor.GRAY);\n+            hoverComponent.setItalic(true);\n+            StringBuilder builder = new StringBuilder();\n+            int hidden = 0;\n+\n+            for (Map.Entry<String, Long> entry : results) {\n+                if (entry.getValue() > VISIBILITY_THRESHOLD) {\n+                    builder.append(\"\\n&e\").append(formatter.apply(entry));\n+                }\n+                else {\n+                    hidden++;\n+                }\n+            }\n+\n+            builder.append(\"\\n\\n&c+ &6\").append(hidden).append(\" more\");\n+            hoverComponent.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, TextComponent.fromLegacyText(ChatColors.color(builder.toString()))));\n+\n+            component.addExtra(hoverComponent);\n+            sender.spigot().sendMessage(component);\n+        }\n+        else {\n+            int hidden = 0;\n+\n+            sender.sendMessage(ChatColor.GOLD + prefix);\n+\n+            for (Map.Entry<String, Long> entry : results) {\n+                if (entry.getValue() > VISIBILITY_THRESHOLD) {\n+                    sender.sendMessage(\"  \" + ChatColor.stripColor(formatter.apply(entry)));\n+                }\n+                else {\n+                    hidden++;\n+                }\n+            }\n+\n+            sender.sendMessage(\"+ \" + hidden + \" more\");\n+        }\n+    }\n+\n+    private String getPerformanceRating() {\n+        StringBuilder builder = new StringBuilder();\n+\n+        float percentage = Math.round(((((totalElapsedTime / 1000000.0) * 100.0F) / MAX_TICK_DURATION) * 100.0F) / 100.0F);", "originalCommit": "ef7624dde9a214b88c81d977b6593ece126decb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5ODYyNQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2064#discussion_r448698625", "bodyText": "*also enables", "author": "WalshyDev", "createdAt": "2020-07-02T01:29:07Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/services/profiler/SlimefunProfiler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package io.github.thebusybiscuit.slimefun4.core.services.profiler;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Level;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Chunk;\n+import org.bukkit.Location;\n+import org.bukkit.Server;\n+import org.bukkit.block.Block;\n+import org.bukkit.command.CommandSender;\n+\n+import io.github.thebusybiscuit.cscorelib2.blocks.BlockPosition;\n+import io.github.thebusybiscuit.slimefun4.api.SlimefunAddon;\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunPlugin;\n+import io.github.thebusybiscuit.slimefun4.implementation.tasks.TickerTask;\n+import io.github.thebusybiscuit.slimefun4.utils.NumberUtils;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+\n+/**\n+ * The {@link SlimefunProfiler} works closely to the {@link TickerTask} and is responsible for\n+ * monitoring that task.\n+ * It collects timings data for any ticked {@link Block} and the corresponding {@link SlimefunItem}.\n+ * This allows developers to identify laggy {@link SlimefunItem SlimefunItems} or {@link SlimefunAddon SlimefunAddons}.\n+ * But it also enabled Server Admins to locate lag-inducing areas on the {@link Server}.", "originalCommit": "ef7624dde9a214b88c81d977b6593ece126decb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcwMTI0Nw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2064#discussion_r448701247", "bodyText": "This is supposed to be Blocks and the other Chunks.\nThis is doing avg/block", "author": "WalshyDev", "createdAt": "2020-07-02T01:38:52Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/services/profiler/PerformanceSummary.java", "diffHunk": "@@ -0,0 +1,157 @@\n+package io.github.thebusybiscuit.slimefun4.core.services.profiler;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+\n+import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.slimefun4.utils.ChatUtils;\n+import io.github.thebusybiscuit.slimefun4.utils.NumberUtils;\n+import net.md_5.bungee.api.ChatColor;\n+import net.md_5.bungee.api.chat.HoverEvent;\n+import net.md_5.bungee.api.chat.TextComponent;\n+\n+class PerformanceSummary {\n+\n+    // The threshold at which a Block or Chunk is significant enough to appear in /sf timings\n+    private static final int VISIBILITY_THRESHOLD = 275_000;\n+\n+    // A minecraft server tick is 50ms and Slimefun ticks are stretched across\n+    // two ticks (sync and async blocks), so we use 100ms as a reference here\n+    static final int MAX_TICK_DURATION = 100;\n+\n+    private final SlimefunProfiler profiler;\n+    private final PerformanceRating rating;\n+    private final long totalElapsedTime;\n+    private final int totalTickedBlocks;\n+\n+    private final Map<String, Long> chunks;\n+    private final Map<String, Long> items;\n+\n+    PerformanceSummary(SlimefunProfiler profiler, long totalElapsedTime, int totalTickedBlocks) {\n+        this.profiler = profiler;\n+        this.rating = profiler.getPerformance();\n+        this.totalElapsedTime = totalElapsedTime;\n+        this.totalTickedBlocks = totalTickedBlocks;\n+\n+        chunks = profiler.getByChunk();\n+        items = profiler.getByItem();\n+    }\n+\n+    public void send(CommandSender sender) {\n+        sender.sendMessage(\"\");\n+        sender.sendMessage(ChatColor.GREEN + \"===== Slimefun Lag Profiler =====\");\n+        sender.sendMessage(ChatColors.color(\"&6Total: &e\" + NumberUtils.getAsMillis(totalElapsedTime)));\n+        sender.sendMessage(ChatColors.color(\"&6Performance: \" + getPerformanceRating()));\n+        sender.sendMessage(ChatColors.color(\"&6Active Chunks: &e\" + chunks.size()));\n+        sender.sendMessage(ChatColors.color(\"&6Active Blocks: &e\" + totalTickedBlocks));\n+        sender.sendMessage(\"\");\n+\n+        summarizeTimings(\"Chunks\", sender, entry -> {", "originalCommit": "ef7624dde9a214b88c81d977b6593ece126decb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcwMTg1Mg==", "url": "https://github.com/Slimefun/Slimefun4/pull/2064#discussion_r448701852", "bodyText": "Again this in the one line looks really cumbersome. Also the fact it's used in at least 2 places means this should probably be a util method.\nWould make this clearer and avoid human error which is definitely possible for something like this.", "author": "WalshyDev", "createdAt": "2020-07-02T01:41:02Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/core/services/profiler/SlimefunProfiler.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package io.github.thebusybiscuit.slimefun4.core.services.profiler;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Level;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Chunk;\n+import org.bukkit.Location;\n+import org.bukkit.Server;\n+import org.bukkit.block.Block;\n+import org.bukkit.command.CommandSender;\n+\n+import io.github.thebusybiscuit.cscorelib2.blocks.BlockPosition;\n+import io.github.thebusybiscuit.slimefun4.api.SlimefunAddon;\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunPlugin;\n+import io.github.thebusybiscuit.slimefun4.implementation.tasks.TickerTask;\n+import io.github.thebusybiscuit.slimefun4.utils.NumberUtils;\n+import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n+import me.mrCookieSlime.Slimefun.api.Slimefun;\n+\n+/**\n+ * The {@link SlimefunProfiler} works closely to the {@link TickerTask} and is responsible for\n+ * monitoring that task.\n+ * It collects timings data for any ticked {@link Block} and the corresponding {@link SlimefunItem}.\n+ * This allows developers to identify laggy {@link SlimefunItem SlimefunItems} or {@link SlimefunAddon SlimefunAddons}.\n+ * But it also enabled Server Admins to locate lag-inducing areas on the {@link Server}.\n+ * \n+ * @author TheBusyBiscuit\n+ * \n+ * @see TickerTask\n+ *\n+ */\n+public class SlimefunProfiler {\n+\n+    private final ExecutorService executor = Executors.newFixedThreadPool(3);\n+    private final AtomicBoolean running = new AtomicBoolean(false);\n+    private final AtomicInteger queued = new AtomicInteger(0);\n+\n+    private long totalElapsedTime;\n+\n+    private final Map<ProfiledBlock, Long> timings = new ConcurrentHashMap<>();\n+    private final Queue<CommandSender> requests = new ConcurrentLinkedQueue<>();\n+\n+    /**\n+     * This method starts the profiling, data from previous runs will be cleared.\n+     */\n+    public void start() {\n+        running.set(true);\n+        queued.set(0);\n+        timings.clear();\n+    }\n+\n+    /**\n+     * This method starts a new profiler entry.\n+     * \n+     * @return A timestamp, best fed back into {@link #closeEntry(Location, SlimefunItem, long)}\n+     */\n+    public long newEntry() {\n+        if (!running.get()) {\n+            return 0;\n+        }\n+\n+        queued.incrementAndGet();\n+        return System.nanoTime();\n+    }\n+\n+    /**\n+     * This method closes a previously started entry.\n+     * Make sure to call {@link #newEntry()} to get the timestamp in advance.\n+     * \n+     * @param l\n+     *            The {@link Location} of our {@link Block}\n+     * @param item\n+     *            The {@link SlimefunItem} at this {@link Location}\n+     * @param timestamp\n+     *            The timestamp marking the start of this entry, you can retrieve it using {@link #newEntry()}\n+     */\n+    public void closeEntry(Location l, SlimefunItem item, long timestamp) {\n+        if (timestamp == 0) {\n+            return;\n+        }\n+\n+        long elapsedTime = System.nanoTime() - timestamp;\n+\n+        executor.execute(() -> {\n+            ProfiledBlock block = new ProfiledBlock(new BlockPosition(l), item);\n+            timings.put(block, elapsedTime);\n+            queued.decrementAndGet();\n+        });\n+    }\n+\n+    /**\n+     * This stops the profiling.\n+     */\n+    public void stop() {\n+        running.set(false);\n+\n+        if (SlimefunPlugin.instance == null || !SlimefunPlugin.instance.isEnabled()) {\n+            // Slimefun has been disabled\n+            return;\n+        }\n+\n+        // Since we got more than one Thread in our pool, blocking this one is completely fine\n+        executor.execute(() -> {\n+\n+            // Wait for all timing results to come in\n+            while (queued.get() > 0 && !running.get()) {\n+                try {\n+                    Thread.sleep(1);\n+                }\n+                catch (InterruptedException e) {\n+                    Slimefun.getLogger().log(Level.SEVERE, \"A waiting Thread was interrupted\", e);\n+                    Thread.currentThread().interrupt();\n+                }\n+            }\n+\n+            if (running.get()) {\n+                // Looks like the next profiling has already started, abort!\n+                return;\n+            }\n+\n+            totalElapsedTime = timings.values().stream().mapToLong(Long::longValue).sum();\n+\n+            if (!requests.isEmpty()) {\n+                PerformanceSummary summary = new PerformanceSummary(this, totalElapsedTime, timings.size());\n+                Iterator<CommandSender> iterator = requests.iterator();\n+\n+                while (iterator.hasNext()) {\n+                    summary.send(iterator.next());\n+                    iterator.remove();\n+                }\n+            }\n+        });\n+\n+    }\n+\n+    /**\n+     * This method requests a summary for the given {@link CommandSender}.\n+     * The summary will be sent upon the next available moment in time.\n+     * \n+     * @param sender\n+     *            The {@link CommandSender} who shall receive this summary.\n+     */\n+    public void requestSummary(CommandSender sender) {\n+        requests.add(sender);\n+    }\n+\n+    protected Map<String, Long> getByItem() {\n+        Map<String, Long> map = new HashMap<>();\n+\n+        for (Map.Entry<ProfiledBlock, Long> entry : timings.entrySet()) {\n+            map.merge(entry.getKey().getId(), entry.getValue(), Long::sum);\n+        }\n+\n+        return map;\n+    }\n+\n+    protected Map<String, Long> getByChunk() {\n+        Map<String, Long> map = new HashMap<>();\n+\n+        for (Map.Entry<ProfiledBlock, Long> entry : timings.entrySet()) {\n+            String world = entry.getKey().getPosition().getWorld().getName();\n+            int x = entry.getKey().getPosition().getChunkX();\n+            int z = entry.getKey().getPosition().getChunkZ();\n+\n+            map.merge(world + \" (\" + x + ',' + z + ')', entry.getValue(), Long::sum);\n+        }\n+\n+        return map;\n+    }\n+\n+    protected int getBlocksInChunk(String chunk) {\n+        int blocks = 0;\n+\n+        for (ProfiledBlock block : timings.keySet()) {\n+            String world = block.getPosition().getWorld().getName();\n+            int x = block.getPosition().getChunkX();\n+            int z = block.getPosition().getChunkZ();\n+\n+            if (chunk.equals(world + \" (\" + x + ',' + z + ')')) {\n+                blocks++;\n+            }\n+        }\n+\n+        return blocks;\n+    }\n+\n+    protected int getBlocksOfId(String id) {\n+        int blocks = 0;\n+\n+        for (ProfiledBlock block : timings.keySet()) {\n+            if (block.getId().equals(id)) {\n+                blocks++;\n+            }\n+        }\n+\n+        return blocks;\n+    }\n+\n+    /**\n+     * This method returns the current {@link PerformanceRating}.\n+     * \n+     * @return The current performance grade\n+     */\n+    public PerformanceRating getPerformance() {\n+        float percentage = Math.round(((((totalElapsedTime / 1000000.0) * 100.0F) / PerformanceSummary.MAX_TICK_DURATION) * 100.0F) / 100.0F);", "originalCommit": "ef7624dde9a214b88c81d977b6593ece126decb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcwMjI3Ng==", "url": "https://github.com/Slimefun/Slimefun4/pull/2064#discussion_r448702276", "bodyText": "Thank god this mess is gone", "author": "WalshyDev", "createdAt": "2020-07-02T01:42:37Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/tasks/TickerTask.java", "diffHunk": "@@ -1,70 +1,38 @@\n package io.github.thebusybiscuit.slimefun4.implementation.tasks;\n \n-import java.util.AbstractMap;\n-import java.util.Comparator;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n import java.util.Map;\n-import java.util.Map.Entry;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.function.Function;\n import java.util.logging.Level;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n import org.bukkit.Bukkit;\n-import org.bukkit.ChatColor;\n-import org.bukkit.Chunk;\n import org.bukkit.Location;\n import org.bukkit.Material;\n+import org.bukkit.World;\n import org.bukkit.block.Block;\n-import org.bukkit.command.CommandSender;\n-import org.bukkit.entity.Player;\n \n-import io.github.thebusybiscuit.cscorelib2.chat.ChatColors;\n+import io.github.thebusybiscuit.cscorelib2.blocks.BlockPosition;\n import io.github.thebusybiscuit.slimefun4.api.ErrorReport;\n import io.github.thebusybiscuit.slimefun4.implementation.SlimefunPlugin;\n-import io.github.thebusybiscuit.slimefun4.utils.NumberUtils;\n import io.github.thebusybiscuit.slimefun4.utils.PatternUtils;\n+import me.mrCookieSlime.CSCoreLibPlugin.Configuration.Config;\n import me.mrCookieSlime.Slimefun.Objects.SlimefunItem.SlimefunItem;\n import me.mrCookieSlime.Slimefun.Objects.handlers.BlockTicker;\n import me.mrCookieSlime.Slimefun.api.BlockStorage;\n import me.mrCookieSlime.Slimefun.api.Slimefun;\n-import net.md_5.bungee.api.chat.HoverEvent;\n-import net.md_5.bungee.api.chat.TextComponent;\n \n public class TickerTask implements Runnable {\n \n-    private static final int VISIBILITY_THRESHOLD = 225_000;\n-\n     private final Set<BlockTicker> tickers = new HashSet<>();\n \n     // These are \"Queues\" of blocks that need to be removed or moved\n-    private final ConcurrentMap<Location, Location> movingQueue = new ConcurrentHashMap<>();\n-    private final ConcurrentMap<Location, Boolean> deletionQueue = new ConcurrentHashMap<>();\n-\n-    private final ConcurrentMap<Location, Integer> buggedBlocks = new ConcurrentHashMap<>();\n-\n-    private final ConcurrentMap<Location, Long> blockTimings = new ConcurrentHashMap<>();\n-    private final ConcurrentMap<String, Integer> machineCount = new ConcurrentHashMap<>();\n-    private final ConcurrentMap<String, Long> machineTimings = new ConcurrentHashMap<>();\n-\n-    private final ConcurrentMap<String, Long> chunkTimings = new ConcurrentHashMap<>();\n-    private final ConcurrentMap<String, Integer> chunkItemCount = new ConcurrentHashMap<>();\n-    private final Set<String> skippedChunks = new HashSet<>();", "originalCommit": "ef7624dde9a214b88c81d977b6593ece126decb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "697b1733591d9ba6681aa8a09ec7c77dc421c886", "url": "https://github.com/Slimefun/Slimefun4/commit/697b1733591d9ba6681aa8a09ec7c77dc421c886", "message": "Refactoring", "committedDate": "2020-07-02T09:26:38Z", "type": "commit"}, {"oid": "8cbaf14d2eaff2ca27ba6b32c08179f844e65ecf", "url": "https://github.com/Slimefun/Slimefun4/commit/8cbaf14d2eaff2ca27ba6b32c08179f844e65ecf", "message": "Merge branch 'master' of https://github.com/TheBusyBiscuit/Slimefun4\ninto feature/profiler\n\nConflicts:\n\tCHANGELOG.md", "committedDate": "2020-07-02T09:51:38Z", "type": "commit"}, {"oid": "f233657fbd93aa549627ce65a059f80fdf94a817", "url": "https://github.com/Slimefun/Slimefun4/commit/f233657fbd93aa549627ce65a059f80fdf94a817", "message": "Merge branch 'master' of https://github.com/TheBusyBiscuit/Slimefun4 into feature/profiler", "committedDate": "2020-07-02T10:51:55Z", "type": "commit"}, {"oid": "172a2c47fb4ddc6fff3f5cdab6cef1d82afd7d86", "url": "https://github.com/Slimefun/Slimefun4/commit/172a2c47fb4ddc6fff3f5cdab6cef1d82afd7d86", "message": "Added a directional cache to Cargo Nodes, should improve performance", "committedDate": "2020-07-02T16:04:26Z", "type": "commit"}]}