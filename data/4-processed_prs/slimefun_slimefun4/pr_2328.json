{"pr_number": 2328, "pr_title": "Programmable Android Optimization: Infinite Block Generators", "pr_createdAt": "2020-09-15T09:14:48Z", "pr_url": "https://github.com/Slimefun/Slimefun4/pull/2328", "timeline": [{"oid": "816e9004ca3a76673c79f52b0f87aa96364e891c", "url": "https://github.com/Slimefun/Slimefun4/commit/816e9004ca3a76673c79f52b0f87aa96364e891c", "message": "Added the enum", "committedDate": "2020-09-15T08:58:28Z", "type": "commit"}, {"oid": "eeff9411a35f865c71889dd87eb4a84affe10745", "url": "https://github.com/Slimefun/Slimefun4/commit/eeff9411a35f865c71889dd87eb4a84affe10745", "message": "Implemented this for androids", "committedDate": "2020-09-15T09:09:15Z", "type": "commit"}, {"oid": "11c0faf376014a8105d7f42e7da54f868e08c69b", "url": "https://github.com/Slimefun/Slimefun4/commit/11c0faf376014a8105d7f42e7da54f868e08c69b", "message": "Updated changelog", "committedDate": "2020-09-15T09:43:05Z", "type": "commit"}, {"oid": "2810019dbe67b892f540c1b2c171929509980003", "url": "https://github.com/Slimefun/Slimefun4/commit/2810019dbe67b892f540c1b2c171929509980003", "message": "Visual improvements + config setting for event calling", "committedDate": "2020-09-15T10:08:30Z", "type": "commit"}, {"oid": "1a7de82c4556de698110b35982529f35346eb7d3", "url": "https://github.com/Slimefun/Slimefun4/commit/1a7de82c4556de698110b35982529f35346eb7d3", "message": "Added Unit Tests", "committedDate": "2020-09-15T17:42:52Z", "type": "commit"}, {"oid": "2b062da47a9d54eb1f125e23009c034179021c36", "url": "https://github.com/Slimefun/Slimefun4/commit/2b062da47a9d54eb1f125e23009c034179021c36", "message": "Default changed to false", "committedDate": "2020-09-15T17:44:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg5NDU5Mw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r488894593", "bodyText": "Are we not checking if drops fit anymore? Old code had a if (menu.fits(drop, getOutputSlots())) check, I don't see why we would skip it", "author": "Sfiguz7", "createdAt": "2020-09-15T18:55:36Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/items/androids/MinerAndroid.java", "diffHunk": "@@ -106,4 +99,23 @@ protected void moveAndDig(Block b, BlockMenu menu, BlockFace face, Block block)\n         }\n     }\n \n+    @ParametersAreNonnullByDefault\n+    private void breakBlock(BlockMenu menu, Collection<ItemStack> drops, Block block) {\n+        // Push our drops to the inventory\n+        for (ItemStack drop : drops) {", "originalCommit": "2b062da47a9d54eb1f125e23009c034179021c36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg5NzE1NA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r488897154", "bodyText": "I intentionally removed it because it seemed redundant. When we push items that dont fit, nothing really happens.\nSo checking if items don't fit and then simply doing nothing instead kinda leads to the same outcome anyway. That's why I removed it.", "author": "TheBusyBiscuit", "createdAt": "2020-09-15T18:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg5NDU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzU5Nw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r488907597", "bodyText": "Can't seem to link to this line so I'm just commenting, these two arguments. I'm not sure how Unit Tests handle args but if water and lava refer to the same BlockFace you get no ValidCobblestoneGenerator\nEDIT: of course the same would apply below", "author": "Sfiguz7", "createdAt": "2020-09-15T19:16:40Z", "path": "src/test/java/io/github/thebusybiscuit/slimefun4/testing/tests/utils/TestInfiniteBlockGenerators.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package io.github.thebusybiscuit.slimefun4.testing.tests.utils;\n+\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.event.block.BlockFromToEvent;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import be.seeseemelk.mockbukkit.MockBukkit;\n+import be.seeseemelk.mockbukkit.ServerMock;\n+import be.seeseemelk.mockbukkit.WorldMock;\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunPlugin;\n+import io.github.thebusybiscuit.slimefun4.utils.InfiniteBlockGenerator;\n+\n+class TestInfiniteBlockGenerators {\n+\n+    private static ServerMock server;\n+\n+    @BeforeAll\n+    public static void load() {\n+        server = MockBukkit.mock();\n+        MockBukkit.load(SlimefunPlugin.class);\n+    }\n+\n+    @AfterAll\n+    public static void unload() {\n+        MockBukkit.unmock();\n+    }\n+\n+    @Test\n+    @DisplayName(\"Test if invalid Cobblestone generators are ignored\")\n+    void testInvalidCobblestoneGenerator() {\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.STONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.COBBLESTONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block, false));\n+\n+        block.setType(Material.COBBLESTONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.COBBLESTONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block, false));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(value = \"provideFaces\")\n+    @DisplayName(\"Test if a Cobblestone Generator can be detected\")\n+    void testValidCobblestoneGenerator(BlockFace water, BlockFace lava) {", "originalCommit": "2b062da47a9d54eb1f125e23009c034179021c36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwODc3OQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r488908779", "bodyText": "There is a not-equals check for the arguments. Look at the annotations, they point to \"provideFaces\", a method found further down. There is a .filter() for this exact case.", "author": "TheBusyBiscuit", "createdAt": "2020-09-15T19:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzU5Nw=="}], "type": "inlineReview"}, {"oid": "775275c6613a8b954a5e21a2c86fa5fe9b54312a", "url": "https://github.com/Slimefun/Slimefun4/commit/775275c6613a8b954a5e21a2c86fa5fe9b54312a", "message": "Merge branch 'master' into performance/cobblestone", "committedDate": "2020-09-29T18:59:10Z", "type": "commit"}, {"oid": "9605ed4d1f8632d68c5664007f13d044d8ba7938", "url": "https://github.com/Slimefun/Slimefun4/commit/9605ed4d1f8632d68c5664007f13d044d8ba7938", "message": "Merge branch 'master' into performance/cobblestone", "committedDate": "2020-10-02T12:51:18Z", "type": "commit"}, {"oid": "43284f1534bad0f3efb860d43d7a6a12690618ea", "url": "https://github.com/Slimefun/Slimefun4/commit/43284f1534bad0f3efb860d43d7a6a12690618ea", "message": "Merge branch 'master' into performance/cobblestone", "committedDate": "2020-10-08T14:19:03Z", "type": "commit"}, {"oid": "d63d6189a937540fc564c3844a017cce685251d4", "url": "https://github.com/Slimefun/Slimefun4/commit/d63d6189a937540fc564c3844a017cce685251d4", "message": "Merge branch 'master' into performance/cobblestone", "committedDate": "2020-10-10T11:49:10Z", "type": "commit"}, {"oid": "b07a54d51545533f97b353c60161dc64a3d830ea", "url": "https://github.com/Slimefun/Slimefun4/commit/b07a54d51545533f97b353c60161dc64a3d830ea", "message": "Merge branch 'master' of https://github.com/Slimefun/Slimefun4.git into performance/cobblestone", "committedDate": "2020-12-10T11:04:48Z", "type": "commit"}, {"oid": "eac09eea9eea71ba6aadbc7d38ede96c9948b410", "url": "https://github.com/Slimefun/Slimefun4/commit/eac09eea9eea71ba6aadbc7d38ede96c9948b410", "message": "Switched to BlockFormEvent", "committedDate": "2020-12-10T11:11:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI4MDU1OA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548280558", "bodyText": "variable is never used", "author": "svr333", "createdAt": "2020-12-23T22:06:06Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/listeners/BlockPhysicsListener.java", "diffHunk": "@@ -84,6 +84,7 @@ public void onPistonRetract(BlockPistonRetractEvent e) {\n     @EventHandler(ignoreCancelled = true)\n     public void onLiquidFlow(BlockFromToEvent e) {\n         Block block = e.getToBlock();\n+        Material type = block.getType();", "originalCommit": "eac09eea9eea71ba6aadbc7d38ede96c9948b410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI4MDcyOQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548280729", "bodyText": "or you forgot to replace block.getType() here, either one works", "author": "svr333", "createdAt": "2020-12-23T22:06:25Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/implementation/listeners/BlockPhysicsListener.java", "diffHunk": "@@ -84,6 +84,7 @@ public void onPistonRetract(BlockPistonRetractEvent e) {\n     @EventHandler(ignoreCancelled = true)\n     public void onLiquidFlow(BlockFromToEvent e) {\n         Block block = e.getToBlock();\n+        Material type = block.getType();\n \n         // Check if this Material can be destroyed by fluids\n         if (SlimefunTag.FLUID_SENSITIVE_MATERIALS.isTagged(block.getType())) {", "originalCommit": "eac09eea9eea71ba6aadbc7d38ede96c9948b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU1NjIwNg==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548556206", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (SlimefunTag.FLUID_SENSITIVE_MATERIALS.isTagged(block.getType())) {\n          \n          \n            \n                    if (SlimefunTag.FLUID_SENSITIVE_MATERIALS.isTagged(type)) {", "author": "TheBusyBiscuit", "createdAt": "2020-12-24T15:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI4MDcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI5MzQwNw==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548293407", "bodyText": "naming wise I feel like InfiniteBlockGenerator#checkForAt(Block b) would fit better than InfiniteBlockGenerator#test(Block b)", "author": "svr333", "createdAt": "2020-12-23T22:24:35Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/utils/InfiniteBlockGenerator.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package io.github.thebusybiscuit.slimefun4.utils;\n+\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import javax.annotation.ParametersAreNonnullByDefault;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.block.BlockState;\n+import org.bukkit.event.block.BlockFormEvent;\n+\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.androids.MinerAndroid;\n+import io.papermc.lib.PaperLib;\n+\n+/**\n+ * This enum holds various ways of infinite block generators.\n+ * The most prominent member of these is the standard Cobblestone Generator.\n+ * We use this enum for performance optimizations for the {@link MinerAndroid}.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+public enum InfiniteBlockGenerator implements Predicate<Block> {\n+\n+    /**\n+     * Your standard Cobblestone Generator with flowing lava and water.\n+     */\n+    COBBLESTONE_GENERATOR(\"COBBLESTONE\"),\n+\n+    /**\n+     * When lava flows onto a stationary water block it generates normal stone.\n+     */\n+    STONE_GENERATOR(\"STONE\"),\n+\n+    /**\n+     * The Basalt Generator (1.16+ only) allows you to generate infinite Basalt!\n+     */\n+    BASALT_GENERATOR(\"BASALT\");\n+\n+    public static final InfiniteBlockGenerator[] values = values();\n+    private static final BlockFace[] sameLevelFaces = { BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST };\n+\n+    private final Material material;\n+\n+    InfiniteBlockGenerator(@Nonnull String type) {\n+        this.material = Material.matchMaterial(type);\n+    }\n+\n+    /**\n+     * This returns the generated {@link Material} of this {@link InfiniteBlockGenerator}.\n+     * This method can return null if the associated {@link Material} is not available in the current\n+     * {@link MinecraftVersion}.\n+     * \n+     * @return The generated {@link Material} or null\n+     */\n+    @Nullable\n+    public Material getGeneratedMaterial() {\n+        return material;\n+    }\n+\n+    /**\n+     * Similar to {@link #test(Block)} this tests whether this {@link InfiniteBlockGenerator}\n+     * exists at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     * \n+     * @return Whether this {@link InfiniteBlockGenerator} exists at the given {@link Block}\n+     */\n+    @Override\n+    public boolean test(@Nonnull Block b) {", "originalCommit": "eac09eea9eea71ba6aadbc7d38ede96c9948b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU1NjQxMg==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548556412", "bodyText": "This method is overridden, as this is a Predicate implementation.", "author": "TheBusyBiscuit", "createdAt": "2020-12-24T15:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI5MzQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNTE0MQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548305141", "bodyText": "Public method so Validate#notNull here? Or am I still getting this wrong xD", "author": "svr333", "createdAt": "2020-12-23T22:44:03Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/utils/InfiniteBlockGenerator.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package io.github.thebusybiscuit.slimefun4.utils;\n+\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import javax.annotation.ParametersAreNonnullByDefault;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.block.BlockState;\n+import org.bukkit.event.block.BlockFormEvent;\n+\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.androids.MinerAndroid;\n+import io.papermc.lib.PaperLib;\n+\n+/**\n+ * This enum holds various ways of infinite block generators.\n+ * The most prominent member of these is the standard Cobblestone Generator.\n+ * We use this enum for performance optimizations for the {@link MinerAndroid}.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+public enum InfiniteBlockGenerator implements Predicate<Block> {\n+\n+    /**\n+     * Your standard Cobblestone Generator with flowing lava and water.\n+     */\n+    COBBLESTONE_GENERATOR(\"COBBLESTONE\"),\n+\n+    /**\n+     * When lava flows onto a stationary water block it generates normal stone.\n+     */\n+    STONE_GENERATOR(\"STONE\"),\n+\n+    /**\n+     * The Basalt Generator (1.16+ only) allows you to generate infinite Basalt!\n+     */\n+    BASALT_GENERATOR(\"BASALT\");\n+\n+    public static final InfiniteBlockGenerator[] values = values();\n+    private static final BlockFace[] sameLevelFaces = { BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST };\n+\n+    private final Material material;\n+\n+    InfiniteBlockGenerator(@Nonnull String type) {\n+        this.material = Material.matchMaterial(type);\n+    }\n+\n+    /**\n+     * This returns the generated {@link Material} of this {@link InfiniteBlockGenerator}.\n+     * This method can return null if the associated {@link Material} is not available in the current\n+     * {@link MinecraftVersion}.\n+     * \n+     * @return The generated {@link Material} or null\n+     */\n+    @Nullable\n+    public Material getGeneratedMaterial() {\n+        return material;\n+    }\n+\n+    /**\n+     * Similar to {@link #test(Block)} this tests whether this {@link InfiniteBlockGenerator}\n+     * exists at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     * \n+     * @return Whether this {@link InfiniteBlockGenerator} exists at the given {@link Block}\n+     */\n+    @Override\n+    public boolean test(@Nonnull Block b) {\n+        Validate.notNull(b, \"Block cannot be null!\");\n+\n+        /*\n+         * This will eliminate non-matching base materials If we\n+         * are on a version without Basalt, it will be null here and not match.\n+         */\n+        if (b.getType() == getGeneratedMaterial()) {\n+            switch (this) {\n+            case COBBLESTONE_GENERATOR:\n+                return hasSurroundingMaterials(b, Material.WATER, Material.LAVA);\n+            case STONE_GENERATOR:\n+                if (b.getRelative(BlockFace.UP).getType() == Material.LAVA) {\n+                    return hasSurroundingMaterials(b, Material.WATER);\n+                } else {\n+                    return false;\n+                }\n+            case BASALT_GENERATOR:\n+                if (b.getRelative(BlockFace.DOWN).getType() == Material.SOUL_SOIL) {\n+                    return hasSurroundingMaterials(b, Material.LAVA, Material.BLUE_ICE);\n+                } else {\n+                    return false;\n+                }\n+            default:\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @ParametersAreNonnullByDefault\n+    private boolean hasSurroundingMaterials(Block b, Material... materials) {\n+        Validate.notNull(b, \"The Block cannot be null!\");\n+        Validate.notEmpty(materials, \"Materials need to have a size of at least one!\");\n+\n+        boolean[] matches = new boolean[materials.length];\n+        int count = 0;\n+\n+        for (BlockFace face : sameLevelFaces) {\n+            Block neighbour = b.getRelative(face);\n+            Material neighbourType = neighbour.getType();\n+\n+            for (int i = 0; i < materials.length; i++) {\n+                if (neighbourType == materials[i] && !matches[i]) {\n+                    matches[i] = true;\n+                    count++;\n+                    break;\n+                }\n+            }\n+\n+            if (count == materials.length) {\n+                return true;\n+            }\n+        }\n+\n+        return count == materials.length;\n+    }\n+\n+    /**\n+     * This method calls a {@link BlockFormEvent} for this {@link InfiniteBlockGenerator}.\n+     * There are a few plugins who catch these events to inject custom {@link Material Materials} into\n+     * Cobblestone Generators, so we wanna give them the oppurtunity to catch this as well.\n+     * \n+     * @param from\n+     *            The {@link Block} where our liquid is coming from.\n+     * @param to\n+     *            The {@link Block} our liquid has flown to / solidified at.\n+     * \n+     * @return Our called {@link BlockFormEvent}\n+     */\n+    @Nonnull\n+    public BlockFormEvent callEvent(@Nonnull Block block) {\n+        BlockState state = PaperLib.getBlockState(block, false).getState();\n+        BlockFormEvent event = new BlockFormEvent(block, state);\n+        Bukkit.getPluginManager().callEvent(event);\n+        return event;\n+    }", "originalCommit": "eac09eea9eea71ba6aadbc7d38ede96c9948b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU1NjYxNQ==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548556615", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public BlockFormEvent callEvent(@Nonnull Block block) {\n          \n          \n            \n                    BlockState state = PaperLib.getBlockState(block, false).getState();\n          \n          \n            \n                    BlockFormEvent event = new BlockFormEvent(block, state);\n          \n          \n            \n                    Bukkit.getPluginManager().callEvent(event);\n          \n          \n            \n                    return event;\n          \n          \n            \n                }\n          \n          \n            \n                public BlockFormEvent callEvent(@Nonnull Block block) {\n          \n          \n            \n                    Validate.notNull(block, \"The Block cannot be null!\");\n          \n          \n            \n                    BlockState state = PaperLib.getBlockState(block, false).getState();\n          \n          \n            \n                    BlockFormEvent event = new BlockFormEvent(block, state);\n          \n          \n            \n                    Bukkit.getPluginManager().callEvent(event);\n          \n          \n            \n                    return event;\n          \n          \n            \n                }", "author": "TheBusyBiscuit", "createdAt": "2020-12-24T15:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNTE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNzg2MA==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548307860", "bodyText": "extra empty line", "author": "svr333", "createdAt": "2020-12-23T22:54:45Z", "path": "src/test/java/io/github/thebusybiscuit/slimefun4/testing/tests/utils/TestInfiniteBlockGenerators.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package io.github.thebusybiscuit.slimefun4.testing.tests.utils;\n+\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.event.block.BlockFormEvent;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import be.seeseemelk.mockbukkit.MockBukkit;\n+import be.seeseemelk.mockbukkit.ServerMock;\n+import be.seeseemelk.mockbukkit.WorldMock;\n+import io.github.thebusybiscuit.slimefun4.implementation.SlimefunPlugin;\n+import io.github.thebusybiscuit.slimefun4.utils.InfiniteBlockGenerator;\n+\n+class TestInfiniteBlockGenerators {\n+\n+    private static ServerMock server;\n+\n+    @BeforeAll\n+    public static void load() {\n+        server = MockBukkit.mock();\n+        MockBukkit.load(SlimefunPlugin.class);\n+    }\n+\n+    @AfterAll\n+    public static void unload() {\n+        MockBukkit.unmock();\n+    }\n+\n+    @Test\n+    @DisplayName(\"Test if invalid Cobblestone generators are ignored\")\n+    void testInvalidCobblestoneGenerator() {\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.STONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.COBBLESTONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.setType(Material.COBBLESTONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.COBBLESTONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(value = \"provideFaces\")\n+    @DisplayName(\"Test if a Cobblestone Generator can be detected\")\n+    void testValidCobblestoneGenerator(BlockFace water, BlockFace lava) {\n+        InfiniteBlockGenerator generator = InfiniteBlockGenerator.COBBLESTONE_GENERATOR;\n+\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.COBBLESTONE);\n+        block.getRelative(water).setType(Material.WATER);\n+        block.getRelative(lava).setType(Material.LAVA);\n+\n+        Assertions.assertTrue(generator.test(block));\n+        Assertions.assertNotNull(generator.callEvent(block));\n+\n+        server.getPluginManager().assertEventFired(BlockFormEvent.class);\n+        server.getPluginManager().clearEvents();\n+\n+        Assertions.assertEquals(generator, InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @Test\n+    @DisplayName(\"Test if invalid Basalt generators are ignored\")\n+    void testInvalidBasaltGenerator() {\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.COBBLESTONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.BASALT_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.setType(Material.BASALT);\n+        Assertions.assertFalse(InfiniteBlockGenerator.BASALT_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.getRelative(BlockFace.DOWN).setType(Material.SOUL_SOIL);\n+        Assertions.assertFalse(InfiniteBlockGenerator.BASALT_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(value = \"provideFaces\")\n+    @DisplayName(\"Test if a Basalt Generator can be detected\")\n+    void testValidBasaltGenerator(BlockFace ice, BlockFace lava) {\n+        InfiniteBlockGenerator generator = InfiniteBlockGenerator.BASALT_GENERATOR;\n+\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.BASALT);\n+        block.getRelative(BlockFace.DOWN).setType(Material.SOUL_SOIL);\n+        block.getRelative(ice).setType(Material.BLUE_ICE);\n+        block.getRelative(lava).setType(Material.LAVA);\n+\n+        Assertions.assertTrue(generator.test(block));\n+        Assertions.assertNotNull(generator.callEvent(block));\n+\n+        server.getPluginManager().assertEventFired(BlockFormEvent.class);\n+        server.getPluginManager().clearEvents();\n+\n+        Assertions.assertEquals(generator, InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @Test\n+    @DisplayName(\"Test if invalid Stone generators are ignored\")\n+    void testInvalidStoneGenerator() {\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.COBBLESTONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.STONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.setType(Material.STONE);\n+        Assertions.assertFalse(InfiniteBlockGenerator.STONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+\n+        block.getRelative(BlockFace.UP).setType(Material.LAVA);\n+        Assertions.assertFalse(InfiniteBlockGenerator.STONE_GENERATOR.test(block));\n+        Assertions.assertNull(InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(value = BlockFace.class, names = { \"NORTH\", \"EAST\", \"SOUTH\", \"WEST\" })\n+    @DisplayName(\"Test if a Stone Generator can be detected\")\n+    void testValidStoneGenerator(BlockFace water) {\n+        InfiniteBlockGenerator generator = InfiniteBlockGenerator.STONE_GENERATOR;\n+\n+        World world = new WorldMock();\n+        Block block = world.getBlockAt(0, 100, 0);\n+\n+        block.setType(Material.STONE);\n+        block.getRelative(BlockFace.UP).setType(Material.LAVA);\n+        block.getRelative(water).setType(Material.WATER);\n+\n+        Assertions.assertTrue(generator.test(block));\n+        Assertions.assertNotNull(generator.callEvent(block));\n+\n+        server.getPluginManager().assertEventFired(BlockFormEvent.class);\n+        server.getPluginManager().clearEvents();\n+\n+        Assertions.assertEquals(generator, InfiniteBlockGenerator.findAt(block));\n+    }\n+\n+    private static Stream<Arguments> provideFaces() {\n+        BlockFace[] faces = { BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST };\n+        Stream<BlockFace> stream = Arrays.stream(faces);\n+        return stream.flatMap(a -> Arrays.stream(faces).filter(b -> a != b).map(b -> Arguments.of(a, b)));\n+    }\n+", "originalCommit": "eac09eea9eea71ba6aadbc7d38ede96c9948b410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU1NjY4Ng==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548556686", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "author": "TheBusyBiscuit", "createdAt": "2020-12-24T15:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMwNzg2MA=="}], "type": "inlineReview"}, {"oid": "2199fb2cd0da3f6c58d2692d25abccf4c88b4d92", "url": "https://github.com/Slimefun/Slimefun4/commit/2199fb2cd0da3f6c58d2692d25abccf4c88b4d92", "message": "Update src/main/java/io/github/thebusybiscuit/slimefun4/implementation/listeners/BlockPhysicsListener.java", "committedDate": "2020-12-24T15:15:47Z", "type": "commit"}, {"oid": "e88682c13b629f4459d6ba4ed71919b9dbea8f7a", "url": "https://github.com/Slimefun/Slimefun4/commit/e88682c13b629f4459d6ba4ed71919b9dbea8f7a", "message": "Update src/main/java/io/github/thebusybiscuit/slimefun4/utils/InfiniteBlockGenerator.java", "committedDate": "2020-12-24T15:17:20Z", "type": "commit"}, {"oid": "9725d63cf048d2419547205ff9e82b63a2acf454", "url": "https://github.com/Slimefun/Slimefun4/commit/9725d63cf048d2419547205ff9e82b63a2acf454", "message": "Update src/test/java/io/github/thebusybiscuit/slimefun4/testing/tests/utils/TestInfiniteBlockGenerators.java", "committedDate": "2020-12-24T15:17:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODYwODQxMg==", "url": "https://github.com/Slimefun/Slimefun4/pull/2328#discussion_r548608412", "bodyText": "Suggested change", "author": "svr333", "createdAt": "2020-12-24T16:41:36Z", "path": "src/main/java/io/github/thebusybiscuit/slimefun4/utils/InfiniteBlockGenerator.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package io.github.thebusybiscuit.slimefun4.utils;\n+\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import javax.annotation.ParametersAreNonnullByDefault;\n+\n+import org.apache.commons.lang.Validate;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.block.Block;\n+import org.bukkit.block.BlockFace;\n+import org.bukkit.block.BlockState;\n+import org.bukkit.event.block.BlockFormEvent;\n+\n+import io.github.thebusybiscuit.slimefun4.api.MinecraftVersion;\n+import io.github.thebusybiscuit.slimefun4.implementation.items.androids.MinerAndroid;\n+import io.papermc.lib.PaperLib;\n+\n+/**\n+ * This enum holds various ways of infinite block generators.\n+ * The most prominent member of these is the standard Cobblestone Generator.\n+ * We use this enum for performance optimizations for the {@link MinerAndroid}.\n+ * \n+ * @author TheBusyBiscuit\n+ *\n+ */\n+public enum InfiniteBlockGenerator implements Predicate<Block> {\n+\n+    /**\n+     * Your standard Cobblestone Generator with flowing lava and water.\n+     */\n+    COBBLESTONE_GENERATOR(\"COBBLESTONE\"),\n+\n+    /**\n+     * When lava flows onto a stationary water block it generates normal stone.\n+     */\n+    STONE_GENERATOR(\"STONE\"),\n+\n+    /**\n+     * The Basalt Generator (1.16+ only) allows you to generate infinite Basalt!\n+     */\n+    BASALT_GENERATOR(\"BASALT\");\n+\n+    public static final InfiniteBlockGenerator[] values = values();\n+    private static final BlockFace[] sameLevelFaces = { BlockFace.NORTH, BlockFace.EAST, BlockFace.SOUTH, BlockFace.WEST };\n+\n+    private final Material material;\n+\n+    InfiniteBlockGenerator(@Nonnull String type) {\n+        this.material = Material.matchMaterial(type);\n+    }\n+\n+    /**\n+     * This returns the generated {@link Material} of this {@link InfiniteBlockGenerator}.\n+     * This method can return null if the associated {@link Material} is not available in the current\n+     * {@link MinecraftVersion}.\n+     * \n+     * @return The generated {@link Material} or null\n+     */\n+    @Nullable\n+    public Material getGeneratedMaterial() {\n+        return material;\n+    }\n+\n+    /**\n+     * Similar to {@link #test(Block)} this tests whether this {@link InfiniteBlockGenerator}\n+     * exists at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     * \n+     * @return Whether this {@link InfiniteBlockGenerator} exists at the given {@link Block}\n+     */\n+    @Override\n+    public boolean test(@Nonnull Block b) {\n+        Validate.notNull(b, \"Block cannot be null!\");\n+\n+        /*\n+         * This will eliminate non-matching base materials If we\n+         * are on a version without Basalt, it will be null here and not match.\n+         */\n+        if (b.getType() == getGeneratedMaterial()) {\n+            switch (this) {\n+            case COBBLESTONE_GENERATOR:\n+                return hasSurroundingMaterials(b, Material.WATER, Material.LAVA);\n+            case STONE_GENERATOR:\n+                if (b.getRelative(BlockFace.UP).getType() == Material.LAVA) {\n+                    return hasSurroundingMaterials(b, Material.WATER);\n+                } else {\n+                    return false;\n+                }\n+            case BASALT_GENERATOR:\n+                if (b.getRelative(BlockFace.DOWN).getType() == Material.SOUL_SOIL) {\n+                    return hasSurroundingMaterials(b, Material.LAVA, Material.BLUE_ICE);\n+                } else {\n+                    return false;\n+                }\n+            default:\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    @ParametersAreNonnullByDefault\n+    private boolean hasSurroundingMaterials(Block b, Material... materials) {\n+        Validate.notNull(b, \"The Block cannot be null!\");\n+        Validate.notEmpty(materials, \"Materials need to have a size of at least one!\");\n+\n+        boolean[] matches = new boolean[materials.length];\n+        int count = 0;\n+\n+        for (BlockFace face : sameLevelFaces) {\n+            Block neighbour = b.getRelative(face);\n+            Material neighbourType = neighbour.getType();\n+\n+            for (int i = 0; i < materials.length; i++) {\n+                if (neighbourType == materials[i] && !matches[i]) {\n+                    matches[i] = true;\n+                    count++;\n+                    break;\n+                }\n+            }\n+\n+            if (count == materials.length) {\n+                return true;\n+            }\n+        }\n+\n+        return count == materials.length;\n+    }\n+\n+    /**\n+     * This method calls a {@link BlockFormEvent} for this {@link InfiniteBlockGenerator}.\n+     * There are a few plugins who catch these events to inject custom {@link Material Materials} into\n+     * Cobblestone Generators, so we wanna give them the oppurtunity to catch this as well.\n+     * \n+     * @param from\n+     *            The {@link Block} where our liquid is coming from.\n+     * @param to\n+     *            The {@link Block} our liquid has flown to / solidified at.\n+     * \n+     * @return Our called {@link BlockFormEvent}\n+     */\n+    @Nonnull\n+    public BlockFormEvent callEvent(@Nonnull Block block) {\n+        Validate.notNull(block, \"The Block cannot be null!\");\n+        BlockState state = PaperLib.getBlockState(block, false).getState();\n+        BlockFormEvent event = new BlockFormEvent(block, state);\n+        Bukkit.getPluginManager().callEvent(event);\n+        return event;\n+    }\n+\n+    /**\n+     * This will attempt to find an {@link InfiniteBlockGenerator} at the given {@link Block}.\n+     * \n+     * @param b\n+     *            The {@link Block}\n+     * \n+     * @return An {@link InfiniteBlockGenerator} or null if none was found.\n+     */\n+    @Nullable\n+    public static InfiniteBlockGenerator findAt(@Nonnull Block b) {\n+        Validate.notNull(b, \"Cannot find a generator without a Location!\");\n+\n+        for (InfiniteBlockGenerator generator : values) {\n+            if (generator.test(b)) {\n+                return generator;\n+            }\n+        }\n+\n+        return null;\n+    }\n+", "originalCommit": "9725d63cf048d2419547205ff9e82b63a2acf454", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c53837a0de1f3dfd2005233595d39fb88414689b", "url": "https://github.com/Slimefun/Slimefun4/commit/c53837a0de1f3dfd2005233595d39fb88414689b", "message": "Remove redundant whiteline", "committedDate": "2020-12-24T16:43:11Z", "type": "commit"}, {"oid": "e773e68b4a8b48c7561dd48f2dbd6bf5322d7bfc", "url": "https://github.com/Slimefun/Slimefun4/commit/e773e68b4a8b48c7561dd48f2dbd6bf5322d7bfc", "message": "Merge branch 'master' into performance/cobblestone", "committedDate": "2021-01-06T19:24:54Z", "type": "commit"}, {"oid": "c92ba89d9aecbf385ccb2b511296cf93b9a44feb", "url": "https://github.com/Slimefun/Slimefun4/commit/c92ba89d9aecbf385ccb2b511296cf93b9a44feb", "message": "Merge branch 'master' into performance/cobblestone", "committedDate": "2021-01-11T12:58:21Z", "type": "commit"}, {"oid": "43109ab2d39625b534329b1bf78e4dbb781013ec", "url": "https://github.com/Slimefun/Slimefun4/commit/43109ab2d39625b534329b1bf78e4dbb781013ec", "message": "Merge branch 'master' into performance/cobblestone", "committedDate": "2021-01-14T10:16:39Z", "type": "commit"}, {"oid": "ffef8350b113305f50a01cf59633cf4f511a1c73", "url": "https://github.com/Slimefun/Slimefun4/commit/ffef8350b113305f50a01cf59633cf4f511a1c73", "message": "Merge branch 'master' into performance/cobblestone", "committedDate": "2021-01-18T21:18:02Z", "type": "commit"}]}