{"pr_number": 1424, "pr_title": "documentation for attributes", "pr_createdAt": "2020-07-13T19:22:27Z", "pr_url": "https://github.com/kframework/k/pull/1424", "timeline": [{"oid": "3de6656fe83383ba35a49a3c86b5c93947ca16c1", "url": "https://github.com/kframework/k/commit/3de6656fe83383ba35a49a3c86b5c93947ca16c1", "message": "documentation", "committedDate": "2020-07-13T19:21:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5MzcxMw==", "url": "https://github.com/kframework/k/pull/1424#discussion_r453893713", "bodyText": "I would remove this sentence about --gen-glr-parser flag. It makes it sound like the purpose of this flag is for returning all ambiguous parses, which is not the purpose of that flag. Instead say that K will print out the ambiguous parses and the user must fix it by adding brackets where needed or changing their grammar.", "author": "ehildenb", "createdAt": "2020-07-13T19:52:33Z", "path": "pending-documentation.md", "diffHunk": "@@ -276,16 +277,193 @@ syntax Pgm ::= underbar(NameWithUnderbar)\n \n ### `unused` attribute\n \n-K will warn you if you declare a symbol that is not used in any of the rules of your\n-definition. Sometimes this is intentional, however; in this case, you can suppress the\n-warning by adding the `unused` attribute to the production or cell.\n+K will warn you if you declare a symbol that is not used in any of the rules of\n+your definition. Sometimes this is intentional, however; in this case, you can\n+suppress the warning by adding the `unused` attribute to the production or\n+cell.\n \n ```\n syntax Foo ::= foo() [unused]\n \n configuration <foo unused=\"\"> .K </foo>\n ```\n \n+### Symbol priority and associativity\n+\n+Unlike most other parser generators, K combines the task of parsing with AST\n+generation. A production declared with the `syntax` keyword in K is both a\n+piece of syntax used when parsing, and a symbol that is used when rewriting.\n+As a result, it is generally convenient to describe expression grammars using\n+priority and associativity declarations rather than explicitly transforming\n+your grammar into a series of nonterminals, one for each level of operator\n+precedence. Thus, for example, a simple grammar for addition and multiplication\n+will look like this:\n+\n+```k\n+syntax Exp ::= Exp \"*\" Exp\n+             | Exp \"+\" Exp\n+```\n+\n+However, this grammar is ambiguous. The term `x+y*z` might refer to `x+(y*z)`\n+or to `(x+y)*z`. In order to differentiate this, we introduce a partial\n+ordering between productions known as priority. A symbol \"has tighter priority\"\n+than another symbol if the first symbol can appear under the second, but the\n+second cannot appear under the first without a bracket. For example, in \n+traditional arithmetic, multiplication has tighter priority than addition,\n+which means that `x+y*z` cannot parse as `(x+y)*z` because the addition\n+operator would appear directly beneath the multiplication, which is forbidden\n+by the priority filter.\n+\n+Priority is applied individually to each possible ambiguous parse of a term. It\n+then either accepts or rejects that parse. If there is only a single remaining\n+parse (after all the other disambiguation steps have happened), this is the\n+parse that is chosen. If all the parses were rejected, it is a parse error. If\n+multiple parses remain, they might be resolved by further disambiguation such\n+as via the `prefer` and `avoid` attributes, but if multiple parses remain after\n+disambiguation finishes, this is an ambiguous parse error, indicating there is\n+not a unique parse for that  term. In this case, you can get all possible\n+parses that were valid by means of the `--gen-glr-parser` command line flag.", "originalCommit": "3de6656fe83383ba35a49a3c86b5c93947ca16c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5NDQ0Mg==", "url": "https://github.com/kframework/k/pull/1424#discussion_r453894442", "bodyText": "I would have one of these examples be left, and the other right, to show that you can use both.", "author": "ehildenb", "createdAt": "2020-07-13T19:54:04Z", "path": "pending-documentation.md", "diffHunk": "@@ -276,16 +277,193 @@ syntax Pgm ::= underbar(NameWithUnderbar)\n \n ### `unused` attribute\n \n-K will warn you if you declare a symbol that is not used in any of the rules of your\n-definition. Sometimes this is intentional, however; in this case, you can suppress the\n-warning by adding the `unused` attribute to the production or cell.\n+K will warn you if you declare a symbol that is not used in any of the rules of\n+your definition. Sometimes this is intentional, however; in this case, you can\n+suppress the warning by adding the `unused` attribute to the production or\n+cell.\n \n ```\n syntax Foo ::= foo() [unused]\n \n configuration <foo unused=\"\"> .K </foo>\n ```\n \n+### Symbol priority and associativity\n+\n+Unlike most other parser generators, K combines the task of parsing with AST\n+generation. A production declared with the `syntax` keyword in K is both a\n+piece of syntax used when parsing, and a symbol that is used when rewriting.\n+As a result, it is generally convenient to describe expression grammars using\n+priority and associativity declarations rather than explicitly transforming\n+your grammar into a series of nonterminals, one for each level of operator\n+precedence. Thus, for example, a simple grammar for addition and multiplication\n+will look like this:\n+\n+```k\n+syntax Exp ::= Exp \"*\" Exp\n+             | Exp \"+\" Exp\n+```\n+\n+However, this grammar is ambiguous. The term `x+y*z` might refer to `x+(y*z)`\n+or to `(x+y)*z`. In order to differentiate this, we introduce a partial\n+ordering between productions known as priority. A symbol \"has tighter priority\"\n+than another symbol if the first symbol can appear under the second, but the\n+second cannot appear under the first without a bracket. For example, in \n+traditional arithmetic, multiplication has tighter priority than addition,\n+which means that `x+y*z` cannot parse as `(x+y)*z` because the addition\n+operator would appear directly beneath the multiplication, which is forbidden\n+by the priority filter.\n+\n+Priority is applied individually to each possible ambiguous parse of a term. It\n+then either accepts or rejects that parse. If there is only a single remaining\n+parse (after all the other disambiguation steps have happened), this is the\n+parse that is chosen. If all the parses were rejected, it is a parse error. If\n+multiple parses remain, they might be resolved by further disambiguation such\n+as via the `prefer` and `avoid` attributes, but if multiple parses remain after\n+disambiguation finishes, this is an ambiguous parse error, indicating there is\n+not a unique parse for that  term. In this case, you can get all possible\n+parses that were valid by means of the `--gen-glr-parser` command line flag.\n+Usually, however, this indicates a problem in your grammar.\n+\n+Priority is specified in K grammars by means of one of two different\n+mechanisms. The first, and simplest, simply replaces the `|` operator in a \n+sequence of K productions with the `>` operator. This operator indicates that\n+everything prior to the `>` operator (including transitively) binds tighter\n+than what comes after. For example, a more complete grammar for simple\n+arithmetic might be:\n+\n+```k\n+syntax Exp ::= Exp \"*\" Exp\n+             | Exp \"/\" Exp\n+             > Exp \"+\" Exp\n+             | Exp \"-\" Exp\n+```\n+\n+This indicates that multiplication and division bind tigher than addition\n+and subtraction, but that there is no relationship in priority between\n+multiplication and division.\n+\n+As you may have noticed, this grammar is also ambiguous. `x*y/z` might refer to\n+`x*(y/z)` or to `(x*y)/z`. Indeed, if we removed division and subtraction\n+entirely, the grammar would still be ambiguous: `x*y*z` might parse as\n+`x*(y*z)`, or as `(x*y)*z`. To resolve this, we introduce another feature:\n+associativity. Roughly, asssociativity tells us how symbols are allowed to nest\n+within other symbols with the same priority. If a set of symbols is left\n+associative, then symbols in that set cannot appear as the rightmost child\n+of other symbols in that set. If a set of symbols is right associative, then\n+symbols in that set cannot appear as the leftmost child of other symbols in\n+that set. Finally, if a set of symbols is non-associative, then symbols\n+in that set cannot appear as the rightmost or leftmost child of other symbols\n+in that set. For example, in the above example, if addition and subtraction\n+are left associative, then `x+y+z` will parse as `(x+y)+`z and `x+y-z` will\n+parse as `(x+y)-z` (because the other parse will have been rejected).\n+\n+You might notice that this seems to apply only to binary infix operators. In\n+fact, the real behavior is slightly more complicated. Priority and\n+associativity (for technical reasons that go beyond the scope of this document)\n+really only apply when the rightmost or leftmost item in a production is a\n+nonterminal. If the rightmost nonterminal is followed by a terminal (or\n+respectively the leftmost preceded), priority and associativity do not apply.\n+Thus we can generalize these concepts to arbitrary context-free grammars.\n+\n+Associativity is specified in K grammars by means of one of two different\n+mechanisms. The first, and simplest, adds the associativity of a priority block\n+of symbols prior to that block. For example, we can remove the remaining\n+ambiguities in the above grammar like so:\n+\n+```k\n+syntax Exp ::= left:\n+               Exp \"*\" Exp\n+             | Exp \"/\" Exp\n+             > left:\n+               Exp \"+\" Exp\n+             | Exp \"-\" Exp\n+```", "originalCommit": "3de6656fe83383ba35a49a3c86b5c93947ca16c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5NTY5Mw==", "url": "https://github.com/kframework/k/pull/1424#discussion_r453895693", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here `foo(0)` is defined explicitly as 0. Any other integer yields the integer\n          \n          \n            \n            1. In particular, the second rule above will only be tried after the first\n          \n          \n            \n            Here `foo(0)` is defined explicitly as `0`. Any other integer yields the integer\n          \n          \n            \n            `1`. In particular, the second rule above will only be tried after the first", "author": "ehildenb", "createdAt": "2020-07-13T19:56:25Z", "path": "pending-documentation.md", "diffHunk": "@@ -1213,6 +1391,72 @@ Here we know that `foo(I +Int 1)` will return an Int, but the return sort of\n `foo` is `Exp`. So we project the result into the `Int` sort so that it can\n be placed as the child of a `bar`.\n \n+### `owise` and `priority` attributes.\n+\n+Sometimes, it is simply not convenient to explicitly describe every\n+single negative case under which a rule should **not** apply. Instead,\n+we simply wish to say that a rule should only apply after some other set of\n+rules have been tried. K introduces two different attributes that can be\n+added to rules which will automatically generate the necessary matching\n+conditions in a manner which is performant for concrete execution (indeed,\n+it generally outperforms during concrete execution code where the conditions\n+are written explicitly).\n+\n+The first is the `owise` attribute. Very roughly, rules without an attribute\n+indicating their priority apply first, followed by rules with the `owise`\n+attribute only if all the other rules have been tried and failed. For example,\n+consider the following function:\n+\n+```k\n+syntax Int ::= foo(Int) [function]\n+rule foo(0) => 0\n+rule foo(_) => 1 [owise]\n+```\n+\n+Here `foo(0)` is defined explicitly as 0. Any other integer yields the integer\n+1. In particular, the second rule above will only be tried after the first", "originalCommit": "3de6656fe83383ba35a49a3c86b5c93947ca16c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5NjU5MQ==", "url": "https://github.com/kframework/k/pull/1424#discussion_r453896591", "bodyText": "I would remove the \"Counterintuitively\", and instead say something to the effect that \"rules are tried in increasing order of priority, starting at priority 0 and ending at priority 200\". It's only counterintuitive when you think of the number as how \"prioritous\" a rule is, instead of \"where the rule goes in teh priority list\".", "author": "ehildenb", "createdAt": "2020-07-13T19:57:55Z", "path": "pending-documentation.md", "diffHunk": "@@ -1213,6 +1391,72 @@ Here we know that `foo(I +Int 1)` will return an Int, but the return sort of\n `foo` is `Exp`. So we project the result into the `Int` sort so that it can\n be placed as the child of a `bar`.\n \n+### `owise` and `priority` attributes.\n+\n+Sometimes, it is simply not convenient to explicitly describe every\n+single negative case under which a rule should **not** apply. Instead,\n+we simply wish to say that a rule should only apply after some other set of\n+rules have been tried. K introduces two different attributes that can be\n+added to rules which will automatically generate the necessary matching\n+conditions in a manner which is performant for concrete execution (indeed,\n+it generally outperforms during concrete execution code where the conditions\n+are written explicitly).\n+\n+The first is the `owise` attribute. Very roughly, rules without an attribute\n+indicating their priority apply first, followed by rules with the `owise`\n+attribute only if all the other rules have been tried and failed. For example,\n+consider the following function:\n+\n+```k\n+syntax Int ::= foo(Int) [function]\n+rule foo(0) => 0\n+rule foo(_) => 1 [owise]\n+```\n+\n+Here `foo(0)` is defined explicitly as 0. Any other integer yields the integer\n+1. In particular, the second rule above will only be tried after the first\n+rule has been shown not to apply.\n+\n+This is because the first rule has a lower number assigned for its priority\n+than the second rule. In practice, each rule in your semantics is implicitly\n+or explicitly assigned a numerical priority. Counterintuitively, numbers which\n+are lower correspond to **higher** priority, i.e., they will be tried first.\n+", "originalCommit": "3de6656fe83383ba35a49a3c86b5c93947ca16c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5NjcyNg==", "url": "https://github.com/kframework/k/pull/1424#discussion_r453896726", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The number 200 is not chosen at random. In fact, when you use the `owise`\n          \n          \n            \n            attribute, what you are doing is implicitly setting the priority of the rule\n          \n          \n            \n            to 200. This has a couple of implications:\n          \n          \n            \n            The number `200` is not chosen at random. In fact, when you use the `owise`\n          \n          \n            \n            attribute, what you are doing is implicitly setting the priority of the rule\n          \n          \n            \n            to `200`. This has a couple of implications:", "author": "ehildenb", "createdAt": "2020-07-13T19:58:09Z", "path": "pending-documentation.md", "diffHunk": "@@ -1213,6 +1391,72 @@ Here we know that `foo(I +Int 1)` will return an Int, but the return sort of\n `foo` is `Exp`. So we project the result into the `Int` sort so that it can\n be placed as the child of a `bar`.\n \n+### `owise` and `priority` attributes.\n+\n+Sometimes, it is simply not convenient to explicitly describe every\n+single negative case under which a rule should **not** apply. Instead,\n+we simply wish to say that a rule should only apply after some other set of\n+rules have been tried. K introduces two different attributes that can be\n+added to rules which will automatically generate the necessary matching\n+conditions in a manner which is performant for concrete execution (indeed,\n+it generally outperforms during concrete execution code where the conditions\n+are written explicitly).\n+\n+The first is the `owise` attribute. Very roughly, rules without an attribute\n+indicating their priority apply first, followed by rules with the `owise`\n+attribute only if all the other rules have been tried and failed. For example,\n+consider the following function:\n+\n+```k\n+syntax Int ::= foo(Int) [function]\n+rule foo(0) => 0\n+rule foo(_) => 1 [owise]\n+```\n+\n+Here `foo(0)` is defined explicitly as 0. Any other integer yields the integer\n+1. In particular, the second rule above will only be tried after the first\n+rule has been shown not to apply.\n+\n+This is because the first rule has a lower number assigned for its priority\n+than the second rule. In practice, each rule in your semantics is implicitly\n+or explicitly assigned a numerical priority. Counterintuitively, numbers which\n+are lower correspond to **higher** priority, i.e., they will be tried first.\n+\n+You can specify the priority of a rule with the `priority` attribute. For\n+example, I could equivalently write the second rule above as:\n+\n+```k\n+rule foo(_) => 1 [priority(200)]\n+```\n+\n+The number 200 is not chosen at random. In fact, when you use the `owise`\n+attribute, what you are doing is implicitly setting the priority of the rule\n+to 200. This has a couple of implications:", "originalCommit": "3de6656fe83383ba35a49a3c86b5c93947ca16c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5NjgyMA==", "url": "https://github.com/kframework/k/pull/1424#discussion_r453896820", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Rules with priority higher than 200 apply **after** all rules with the \n          \n          \n            \n               `owise` attribute have been tried.\n          \n          \n            \n            2. Rules with priority higher than `200` apply **after** all rules with the \n          \n          \n            \n               `owise` attribute have been tried.", "author": "ehildenb", "createdAt": "2020-07-13T19:58:21Z", "path": "pending-documentation.md", "diffHunk": "@@ -1213,6 +1391,72 @@ Here we know that `foo(I +Int 1)` will return an Int, but the return sort of\n `foo` is `Exp`. So we project the result into the `Int` sort so that it can\n be placed as the child of a `bar`.\n \n+### `owise` and `priority` attributes.\n+\n+Sometimes, it is simply not convenient to explicitly describe every\n+single negative case under which a rule should **not** apply. Instead,\n+we simply wish to say that a rule should only apply after some other set of\n+rules have been tried. K introduces two different attributes that can be\n+added to rules which will automatically generate the necessary matching\n+conditions in a manner which is performant for concrete execution (indeed,\n+it generally outperforms during concrete execution code where the conditions\n+are written explicitly).\n+\n+The first is the `owise` attribute. Very roughly, rules without an attribute\n+indicating their priority apply first, followed by rules with the `owise`\n+attribute only if all the other rules have been tried and failed. For example,\n+consider the following function:\n+\n+```k\n+syntax Int ::= foo(Int) [function]\n+rule foo(0) => 0\n+rule foo(_) => 1 [owise]\n+```\n+\n+Here `foo(0)` is defined explicitly as 0. Any other integer yields the integer\n+1. In particular, the second rule above will only be tried after the first\n+rule has been shown not to apply.\n+\n+This is because the first rule has a lower number assigned for its priority\n+than the second rule. In practice, each rule in your semantics is implicitly\n+or explicitly assigned a numerical priority. Counterintuitively, numbers which\n+are lower correspond to **higher** priority, i.e., they will be tried first.\n+\n+You can specify the priority of a rule with the `priority` attribute. For\n+example, I could equivalently write the second rule above as:\n+\n+```k\n+rule foo(_) => 1 [priority(200)]\n+```\n+\n+The number 200 is not chosen at random. In fact, when you use the `owise`\n+attribute, what you are doing is implicitly setting the priority of the rule\n+to 200. This has a couple of implications:\n+\n+1. Multiple rules with the owise attribute all have the same priority and thus\n+   can apply in any order.\n+2. Rules with priority higher than 200 apply **after** all rules with the \n+   `owise` attribute have been tried.", "originalCommit": "3de6656fe83383ba35a49a3c86b5c93947ca16c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "004b2736de0d34f896c9ed9c2396087d0d4be689", "url": "https://github.com/kframework/k/commit/004b2736de0d34f896c9ed9c2396087d0d4be689", "message": "review fixes", "committedDate": "2020-07-14T16:25:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4MzkyNg==", "url": "https://github.com/kframework/k/pull/1424#discussion_r454483926", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            the rightmost on top. Addition and subtrasction are right associative, which \n          \n          \n            \n            the rightmost on top. Addition and subtraction are right associative, which", "author": "ehildenb", "createdAt": "2020-07-14T16:27:31Z", "path": "pending-documentation.md", "diffHunk": "@@ -276,16 +277,195 @@ syntax Pgm ::= underbar(NameWithUnderbar)\n \n ### `unused` attribute\n \n-K will warn you if you declare a symbol that is not used in any of the rules of your\n-definition. Sometimes this is intentional, however; in this case, you can suppress the\n-warning by adding the `unused` attribute to the production or cell.\n+K will warn you if you declare a symbol that is not used in any of the rules of\n+your definition. Sometimes this is intentional, however; in this case, you can\n+suppress the warning by adding the `unused` attribute to the production or\n+cell.\n \n ```\n syntax Foo ::= foo() [unused]\n \n configuration <foo unused=\"\"> .K </foo>\n ```\n \n+### Symbol priority and associativity\n+\n+Unlike most other parser generators, K combines the task of parsing with AST\n+generation. A production declared with the `syntax` keyword in K is both a\n+piece of syntax used when parsing, and a symbol that is used when rewriting.\n+As a result, it is generally convenient to describe expression grammars using\n+priority and associativity declarations rather than explicitly transforming\n+your grammar into a series of nonterminals, one for each level of operator\n+precedence. Thus, for example, a simple grammar for addition and multiplication\n+will look like this:\n+\n+```k\n+syntax Exp ::= Exp \"*\" Exp\n+             | Exp \"+\" Exp\n+```\n+\n+However, this grammar is ambiguous. The term `x+y*z` might refer to `x+(y*z)`\n+or to `(x+y)*z`. In order to differentiate this, we introduce a partial\n+ordering between productions known as priority. A symbol \"has tighter priority\"\n+than another symbol if the first symbol can appear under the second, but the\n+second cannot appear under the first without a bracket. For example, in \n+traditional arithmetic, multiplication has tighter priority than addition,\n+which means that `x+y*z` cannot parse as `(x+y)*z` because the addition\n+operator would appear directly beneath the multiplication, which is forbidden\n+by the priority filter.\n+\n+Priority is applied individually to each possible ambiguous parse of a term. It\n+then either accepts or rejects that parse. If there is only a single remaining\n+parse (after all the other disambiguation steps have happened), this is the\n+parse that is chosen. If all the parses were rejected, it is a parse error. If\n+multiple parses remain, they might be resolved by further disambiguation such\n+as via the `prefer` and `avoid` attributes, but if multiple parses remain after\n+disambiguation finishes, this is an ambiguous parse error, indicating there is\n+not a unique parse for that term. In the vast majority of cases, this is\n+an error and indicates that you ought to either change your grammar or add\n+brackets to the term in question. \n+\n+Priority is specified in K grammars by means of one of two different\n+mechanisms. The first, and simplest, simply replaces the `|` operator in a \n+sequence of K productions with the `>` operator. This operator indicates that\n+everything prior to the `>` operator (including transitively) binds tighter\n+than what comes after. For example, a more complete grammar for simple\n+arithmetic might be:\n+\n+```k\n+syntax Exp ::= Exp \"*\" Exp\n+             | Exp \"/\" Exp\n+             > Exp \"+\" Exp\n+             | Exp \"-\" Exp\n+```\n+\n+This indicates that multiplication and division bind tigher than addition\n+and subtraction, but that there is no relationship in priority between\n+multiplication and division.\n+\n+As you may have noticed, this grammar is also ambiguous. `x*y/z` might refer to\n+`x*(y/z)` or to `(x*y)/z`. Indeed, if we removed division and subtraction\n+entirely, the grammar would still be ambiguous: `x*y*z` might parse as\n+`x*(y*z)`, or as `(x*y)*z`. To resolve this, we introduce another feature:\n+associativity. Roughly, asssociativity tells us how symbols are allowed to nest\n+within other symbols with the same priority. If a set of symbols is left\n+associative, then symbols in that set cannot appear as the rightmost child\n+of other symbols in that set. If a set of symbols is right associative, then\n+symbols in that set cannot appear as the leftmost child of other symbols in\n+that set. Finally, if a set of symbols is non-associative, then symbols\n+in that set cannot appear as the rightmost or leftmost child of other symbols\n+in that set. For example, in the above example, if addition and subtraction\n+are left associative, then `x+y+z` will parse as `(x+y)+`z and `x+y-z` will\n+parse as `(x+y)-z` (because the other parse will have been rejected).\n+\n+You might notice that this seems to apply only to binary infix operators. In\n+fact, the real behavior is slightly more complicated. Priority and\n+associativity (for technical reasons that go beyond the scope of this document)\n+really only apply when the rightmost or leftmost item in a production is a\n+nonterminal. If the rightmost nonterminal is followed by a terminal (or\n+respectively the leftmost preceded), priority and associativity do not apply.\n+Thus we can generalize these concepts to arbitrary context-free grammars.\n+\n+Associativity is specified in K grammars by means of one of two different\n+mechanisms. The first, and simplest, adds the associativity of a priority block\n+of symbols prior to that block. For example, we can remove the remaining\n+ambiguities in the above grammar like so:\n+\n+```k\n+syntax Exp ::= left:\n+               Exp \"*\" Exp\n+             | Exp \"/\" Exp\n+             > right:\n+               Exp \"+\" Exp\n+             | Exp \"-\" Exp\n+```\n+\n+This indicates that multiplication and division are left-associative, ie, after\n+symbols with higher priority are parsed as innermost, symbols are nested with\n+the rightmost on top. Addition and subtrasction are right associative, which ", "originalCommit": "004b2736de0d34f896c9ed9c2396087d0d4be689", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "71b2557092b288119dbb109116173dbfff983a59", "url": "https://github.com/kframework/k/commit/71b2557092b288119dbb109116173dbfff983a59", "message": "Update pending-documentation.md", "committedDate": "2020-07-14T16:28:03Z", "type": "commit"}, {"oid": "5f4825b5174d6a366118c9c2f8cd87cc25e065b8", "url": "https://github.com/kframework/k/commit/5f4825b5174d6a366118c9c2f8cd87cc25e065b8", "message": "Merge branch 'master' into doc", "committedDate": "2020-07-14T17:50:50Z", "type": "commit"}]}