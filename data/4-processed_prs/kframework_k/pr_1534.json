{"pr_number": 1534, "pr_title": "Resolve overloads in bison parser", "pr_createdAt": "2020-09-01T16:34:47Z", "pr_url": "https://github.com/kframework/k/pull/1534", "timeline": [{"oid": "4ed670d395122af1a267e186ca15f2b8d87ac20f", "url": "https://github.com/kframework/k/commit/4ed670d395122af1a267e186ca15f2b8d87ac20f", "message": "remove special code for normalization", "committedDate": "2020-09-01T16:31:17Z", "type": "commit"}, {"oid": "915ae8105900ec86aa4afc5b7ed39ba1a736b004", "url": "https://github.com/kframework/k/commit/915ae8105900ec86aa4afc5b7ed39ba1a736b004", "message": "add function to construct injection symbol dynamically", "committedDate": "2020-09-01T16:31:29Z", "type": "commit"}, {"oid": "a48373b2c7cfff8397b992abee303308405aaa6e", "url": "https://github.com/kframework/k/commit/a48373b2c7cfff8397b992abee303308405aaa6e", "message": "include string.h", "committedDate": "2020-09-01T16:31:42Z", "type": "commit"}, {"oid": "5f7b5f4a8bb0d43a51c73b667a698ed4ace90869", "url": "https://github.com/kframework/k/commit/5f7b5f4a8bb0d43a51c73b667a698ed4ace90869", "message": "double injection compaction in parser", "committedDate": "2020-09-01T16:32:04Z", "type": "commit"}, {"oid": "8dec887cb5020823319a9f670da05080d10c9ce8", "url": "https://github.com/kframework/k/commit/8dec887cb5020823319a9f670da05080d10c9ce8", "message": "overload compaction in parser", "committedDate": "2020-09-01T16:32:18Z", "type": "commit"}, {"oid": "ac05bc57dea6b085bae2be1a9652c0576b234e08", "url": "https://github.com/kframework/k/commit/ac05bc57dea6b085bae2be1a9652c0576b234e08", "message": "add test", "committedDate": "2020-09-01T16:32:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyNzkxOQ==", "url": "https://github.com/kframework/k/pull/1534#discussion_r482427919", "bodyText": "Half joking: How about caching the lengths, then:\n  strcpy(strcpy(strcpy(strcpy(strcpy(symbol, prefix) + len(prefix), lesser) + len(lesser), infix) + len(infix), greater) + len(greater), suffix);", "author": "virgil-serbanuta", "createdAt": "2020-09-02T20:35:25Z", "path": "k-distribution/include/kframework/cparser/main.c", "diffHunk": "@@ -77,6 +61,20 @@ bool equalsNode(node *x0, node *x1) {\n   }\n }\n \n+char *injSymbol(char *lesser, char *greater) {\n+  char *prefix = \"inj{\";\n+  char *infix = \", \";\n+  char *suffix = \"}\";\n+  size_t len = strlen(prefix) + strlen(suffix) + strlen(lesser) + strlen(greater) + strlen(infix) + 1;\n+  char *symbol = malloc(len);\n+  strcpy(symbol, prefix);", "originalCommit": "ac05bc57dea6b085bae2be1a9652c0576b234e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ5OTUzMg==", "url": "https://github.com/kframework/k/pull/1534#discussion_r482499532", "bodyText": "I assume that \"less\" means \"included in\", i.e. here lesserSort is included in greaterSort and lesser's sort is included in greater's, right?", "author": "virgil-serbanuta", "createdAt": "2020-09-02T21:39:13Z", "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "diffHunk": "@@ -215,6 +217,83 @@ private static void encode(Sort sort, StringBuilder sb) {\n     sb.append(\"_\");\n   }\n \n+  private static void appendOverloadCondition(StringBuilder bison, Module module, Production greater, Production lesser, List<Integer> nts) {\n+    bison.append(\"true\");\n+    for (int i = 0; i < nts.size(); i++) {\n+      boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+      if (!hasSameSort) {\n+        bison.append(\" && strncmp($\").append(nts.get(i)).append(\".nterm->symbol, \\\"inj{\\\", 4) == 0 && (false\");\n+        Sort greaterSort = lesser.nonterminals().apply(i).sort();\n+        for (Sort lesserSort : iterable(module.subsorts().elements())) {\n+          if (module.subsorts().lessThanEq(lesserSort, greaterSort)) {", "originalCommit": "ac05bc57dea6b085bae2be1a9652c0576b234e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEzMzA0Mg==", "url": "https://github.com/kframework/k/pull/1534#discussion_r483133042", "bodyText": "A <= B in this context means either A = B, or A is a subsort of B.", "author": "dwightguth", "createdAt": "2020-09-03T17:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ5OTUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUxNjI2NA==", "url": "https://github.com/kframework/k/pull/1534#discussion_r482516264", "bodyText": "Would this work if there are multiple terminals? I.e. wouldn't origChild be redeclared in the same block?", "author": "virgil-serbanuta", "createdAt": "2020-09-02T21:59:51Z", "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "diffHunk": "@@ -215,6 +217,83 @@ private static void encode(Sort sort, StringBuilder sb) {\n     sb.append(\"_\");\n   }\n \n+  private static void appendOverloadCondition(StringBuilder bison, Module module, Production greater, Production lesser, List<Integer> nts) {\n+    bison.append(\"true\");\n+    for (int i = 0; i < nts.size(); i++) {\n+      boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+      if (!hasSameSort) {\n+        bison.append(\" && strncmp($\").append(nts.get(i)).append(\".nterm->symbol, \\\"inj{\\\", 4) == 0 && (false\");\n+        Sort greaterSort = lesser.nonterminals().apply(i).sort();\n+        for (Sort lesserSort : iterable(module.subsorts().elements())) {\n+          if (module.subsorts().lessThanEq(lesserSort, greaterSort)) {\n+            bison.append(\" || strcmp($\").append(nts.get(i)).append(\".nterm->children[0]->sort, \\\"\");\n+            encodeKore(lesserSort, bison);\n+            bison.append(\"\\\") == 0\");\n+          }\n+        }\n+        bison.append(\")\");\n+      }\n+    }\n+  }\n+\n+  private static void appendOverloadChecks(StringBuilder bison, Module module, Production greater, List<Integer> nts, boolean hasLocation) {\n+    for (Production lesser : iterable(module.overloads().elements())) {\n+      if (module.overloads().lessThan(lesser, greater)) {\n+        bison.append(\"  if (\");\n+        appendOverloadCondition(bison, module, greater, lesser, nts);\n+        bison.append(\") {\\n\" +\n+            \"    n->symbol =\\\"\");\n+        encodeKore(lesser.klabel().get(), bison);\n+        bison.append(\"\\\";\\n\" +\n+            \"    n->sort = \\\"\");\n+        encodeKore(lesser.sort(), bison);\n+        boolean hasLesserLocation = module.sortAttributesFor().get(lesser.sort().head()).getOrElse(() -> Att.empty()).contains(\"locations\");\n+        bison.append(\"\\\";\\n\" +\n+            \"    n->hasLocation = \" + (hasLesserLocation ? \"1\" : \"0\") + \";\\n\");\n+        for (int i = 0; i < nts.size(); i++) {\n+          boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+          if (hasSameSort) {\n+            bison.append(\n+                \"    n->children[\").append(i).append(\"] = $\").append(nts.get(i)).append(\".nterm;\\n\");\n+          } else {\n+            bison.append(\n+                \"    node *origChild = $\").append(nts.get(i)).append(\".nterm;\\n\" +", "originalCommit": "ac05bc57dea6b085bae2be1a9652c0576b234e08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzMzE0MA==", "url": "https://github.com/kframework/k/pull/1534#discussion_r482533140", "bodyText": "This is a repeated if( ... ) { ... } else section, which means that only the first lesser production that passes the test is processed. Why is it good enough to use only the first one?", "author": "virgil-serbanuta", "createdAt": "2020-09-02T22:21:40Z", "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "diffHunk": "@@ -215,6 +217,83 @@ private static void encode(Sort sort, StringBuilder sb) {\n     sb.append(\"_\");\n   }\n \n+  private static void appendOverloadCondition(StringBuilder bison, Module module, Production greater, Production lesser, List<Integer> nts) {\n+    bison.append(\"true\");\n+    for (int i = 0; i < nts.size(); i++) {\n+      boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+      if (!hasSameSort) {\n+        bison.append(\" && strncmp($\").append(nts.get(i)).append(\".nterm->symbol, \\\"inj{\\\", 4) == 0 && (false\");\n+        Sort greaterSort = lesser.nonterminals().apply(i).sort();\n+        for (Sort lesserSort : iterable(module.subsorts().elements())) {\n+          if (module.subsorts().lessThanEq(lesserSort, greaterSort)) {\n+            bison.append(\" || strcmp($\").append(nts.get(i)).append(\".nterm->children[0]->sort, \\\"\");\n+            encodeKore(lesserSort, bison);\n+            bison.append(\"\\\") == 0\");\n+          }\n+        }\n+        bison.append(\")\");\n+      }\n+    }\n+  }\n+\n+  private static void appendOverloadChecks(StringBuilder bison, Module module, Production greater, List<Integer> nts, boolean hasLocation) {\n+    for (Production lesser : iterable(module.overloads().elements())) {\n+      if (module.overloads().lessThan(lesser, greater)) {\n+        bison.append(\"  if (\");", "originalCommit": "ac05bc57dea6b085bae2be1a9652c0576b234e08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0MzkzNQ==", "url": "https://github.com/kframework/k/pull/1534#discussion_r483143935", "bodyText": "This is a good catch; I meant to topologically sort the entries, but forgot. This should be fixed now; because of the topological sorting, a lesser overload will always appear before a greater overload, so we will always end up choosing an overload such that there is no lesser overload than the overload we chose that would also satisfy the constraints. As a result, any remaining ambiguities will be real ambiguities.", "author": "dwightguth", "createdAt": "2020-09-03T17:31:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzMzE0MA=="}], "type": "inlineReview"}, {"oid": "54acab70db8a53b209b72b6f01fb5a339b83655b", "url": "https://github.com/kframework/k/commit/54acab70db8a53b209b72b6f01fb5a339b83655b", "message": "add another test", "committedDate": "2020-09-03T17:20:56Z", "type": "commit"}, {"oid": "239001ea4290bcd38a5c0d34a18eba0471a456bf", "url": "https://github.com/kframework/k/commit/239001ea4290bcd38a5c0d34a18eba0471a456bf", "message": "fix bug involving scoping of local variables in C bison code", "committedDate": "2020-09-03T17:21:06Z", "type": "commit"}, {"oid": "e0aeefd79b260a5c28251e244a86ff54ed5d2273", "url": "https://github.com/kframework/k/commit/e0aeefd79b260a5c28251e244a86ff54ed5d2273", "message": "add test", "committedDate": "2020-09-03T17:30:17Z", "type": "commit"}, {"oid": "c73b5dde7238e69d2622f326ae0232431b6b45b1", "url": "https://github.com/kframework/k/commit/c73b5dde7238e69d2622f326ae0232431b6b45b1", "message": "topologically sort overloads", "committedDate": "2020-09-03T17:30:22Z", "type": "commit"}, {"oid": "d7261491f4aebd7a078aaf086c4766b8ba00b97f", "url": "https://github.com/kframework/k/commit/d7261491f4aebd7a078aaf086c4766b8ba00b97f", "message": "Merge branch 'master' into overload", "committedDate": "2020-09-03T21:00:33Z", "type": "commit"}, {"oid": "deaba24333324f4de3d0970fc1c2727981c13a74", "url": "https://github.com/kframework/k/commit/deaba24333324f4de3d0970fc1c2727981c13a74", "message": "Merge branch 'master' into overload", "committedDate": "2020-09-03T23:49:42Z", "type": "commit"}]}