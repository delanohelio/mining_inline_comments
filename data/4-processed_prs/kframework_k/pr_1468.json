{"pr_number": 1468, "pr_title": "Update documentation of concrete and symbolic attributes", "pr_createdAt": "2020-07-29T16:57:01Z", "pr_url": "https://github.com/kframework/k/pull/1468", "timeline": [{"oid": "3ba5196eee254171737d586fbc6195ba47ec1923", "url": "https://github.com/kframework/k/commit/3ba5196eee254171737d586fbc6195ba47ec1923", "message": "Update documentation of concrete and symbolic attributes", "committedDate": "2020-07-29T16:56:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MDQ5MA==", "url": "https://github.com/kframework/k/pull/1468#discussion_r462450490", "bodyText": "Is it currently an error to specify both simplification and concrete/symbolic? If not, can we open an issue for that and add it to the backlog?", "author": "ehildenb", "createdAt": "2020-07-29T17:02:24Z", "path": "pending-documentation.md", "diffHunk": "@@ -1157,45 +1198,31 @@ rule X +Int (Y +Int Z) => (X +Int Z) +Int Y\n    andBool #isVariable(Y)\n ```\n \n-### `simplification` attribute (Haskell backend)\n-\n-The simplification attribute identifies axioms that are useful for simplifying\n-configurations, without being part of the main semantics. When a rule is tagged\n-as `simplification`, the Haskell backend will only apply that rule if:\n+### `concrete` and `symbolic` attributes (Haskell backend)\n \n--   the rule lhs _matches_ the subterm of interest, and\n--   the side condition has no remainder given the current top-level predicate\n-    (that is, the current top-level predicate _implies_ the side condition of\n-    the rule).\n+Sometimes you only want a rule to apply if some or all arguments are concrete\n+(not symbolic). This is done with the `concrete` attribute. Conversely, the\n+`symbolic` attribute will allow a rule to apply only when some arguments are not\n+concrete. These attributes should only be given with the `simplification`\n+attribute.", "originalCommit": "3ba5196eee254171737d586fbc6195ba47ec1923", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMTI4OA==", "url": "https://github.com/kframework/k/pull/1468#discussion_r462521288", "bodyText": "Added #1470", "author": "ttuegel", "createdAt": "2020-07-29T19:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MDQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MDk3NQ==", "url": "https://github.com/kframework/k/pull/1468#discussion_r462450975", "bodyText": "I think use a better example, which won't cause an infinite loop if you can. Just a minor annoyance on my part.", "author": "ehildenb", "createdAt": "2020-07-29T17:03:15Z", "path": "pending-documentation.md", "diffHunk": "@@ -1157,45 +1198,31 @@ rule X +Int (Y +Int Z) => (X +Int Z) +Int Y\n    andBool #isVariable(Y)\n ```\n \n-### `simplification` attribute (Haskell backend)\n-\n-The simplification attribute identifies axioms that are useful for simplifying\n-configurations, without being part of the main semantics. When a rule is tagged\n-as `simplification`, the Haskell backend will only apply that rule if:\n+### `concrete` and `symbolic` attributes (Haskell backend)\n \n--   the rule lhs _matches_ the subterm of interest, and\n--   the side condition has no remainder given the current top-level predicate\n-    (that is, the current top-level predicate _implies_ the side condition of\n-    the rule).\n+Sometimes you only want a rule to apply if some or all arguments are concrete\n+(not symbolic). This is done with the `concrete` attribute. Conversely, the\n+`symbolic` attribute will allow a rule to apply only when some arguments are not\n+concrete. These attributes should only be given with the `simplification`\n+attribute.\n \n-Note that the `simplification` attribute can be applied to _any_ rule, not just\n-function rules, and that `simplification` rules are tried _before_ rules from\n-the semantic definition.\n-\n-For example, for the following definition:\n+For example, the following will only re-associate terms when all arguments\n+are concrete:", "originalCommit": "3ba5196eee254171737d586fbc6195ba47ec1923", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMDQxMw==", "url": "https://github.com/kframework/k/pull/1468#discussion_r462520413", "bodyText": "I don't see why this will cause a loop. It is the same example used for the Java backend. Anyway, I took two examples from INT-SYMBOLIC-KORE instead, as I thought that would be more productive.", "author": "ttuegel", "createdAt": "2020-07-29T19:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MDk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MTI2NQ==", "url": "https://github.com/kframework/k/pull/1468#discussion_r462451265", "bodyText": "I thought we supported something like concrete(X, Y), symbolic(Z) instead of having them all be separate?", "author": "ehildenb", "createdAt": "2020-07-29T17:03:44Z", "path": "pending-documentation.md", "diffHunk": "@@ -1157,45 +1198,31 @@ rule X +Int (Y +Int Z) => (X +Int Z) +Int Y\n    andBool #isVariable(Y)\n ```\n \n-### `simplification` attribute (Haskell backend)\n-\n-The simplification attribute identifies axioms that are useful for simplifying\n-configurations, without being part of the main semantics. When a rule is tagged\n-as `simplification`, the Haskell backend will only apply that rule if:\n+### `concrete` and `symbolic` attributes (Haskell backend)\n \n--   the rule lhs _matches_ the subterm of interest, and\n--   the side condition has no remainder given the current top-level predicate\n-    (that is, the current top-level predicate _implies_ the side condition of\n-    the rule).\n+Sometimes you only want a rule to apply if some or all arguments are concrete\n+(not symbolic). This is done with the `concrete` attribute. Conversely, the\n+`symbolic` attribute will allow a rule to apply only when some arguments are not\n+concrete. These attributes should only be given with the `simplification`\n+attribute.\n \n-Note that the `simplification` attribute can be applied to _any_ rule, not just\n-function rules, and that `simplification` rules are tried _before_ rules from\n-the semantic definition.\n-\n-For example, for the following definition:\n+For example, the following will only re-associate terms when all arguments\n+are concrete:\n \n ```k\n-    syntax WordStack ::= Int \":\" WordStack | \".WordStack\"\n-    syntax Int ::= sizeWordStack    ( WordStack       ) [function]\n-                 | sizeWordStackAux ( WordStack , Int ) [function]\n- // --------------------------------------------------------------\n-    rule sizeWordStack(WS) => sizeWordStackAux(WS, 0)\n-\n-    rule sizeWordStackAux(.WordStack, N) => N\n-    rule sizeWordStackAux(W : WS    , N) => sizeWordStackAux(WS, N +Int 1)\n+rule X +Int (Y +Int Z) => (X +Int Y) +Int Z [simplification, concrete]\n ```\n \n-We might add the following simplification lemma:\n+And the following rules will only re-associate terms when it will end up\n+grouping concrete sub-terms:\n \n ```k\n-    rule sizeWordStackAux(WS, N) => N +Int sizeWordStackAux(WS, 0)\n-      requires N =/=Int 0\n-      [simplification]\n-```\n+rule X +Int (Y +Int Z) => (X +Int Y) +Int Z\n+  [simplification, concrete(X), concrete(Y), symbolic(Z)]", "originalCommit": "3ba5196eee254171737d586fbc6195ba47ec1923", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NDU0Ng==", "url": "https://github.com/kframework/k/pull/1468#discussion_r462454546", "bodyText": "Yes, looking at domains.k we do support grouping them. Let's use the grouped version, to encourage better styling for people.", "author": "ehildenb", "createdAt": "2020-07-29T17:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MTI2NQ=="}], "type": "inlineReview"}, {"oid": "4824c272274a78751155e54feea2b381dd5a2132", "url": "https://github.com/kframework/k/commit/4824c272274a78751155e54feea2b381dd5a2132", "message": "Use list syntax for concrete attribute", "committedDate": "2020-07-29T18:53:26Z", "type": "commit"}, {"oid": "7d489c84cb472eacbd97825e0f9f464217e1579b", "url": "https://github.com/kframework/k/commit/7d489c84cb472eacbd97825e0f9f464217e1579b", "message": "Take +Int simplification rules from INT-SYMBOLIC", "committedDate": "2020-07-29T18:59:56Z", "type": "commit"}, {"oid": "e39caa857a9260a775f1eccd734dac865f12d144", "url": "https://github.com/kframework/k/commit/e39caa857a9260a775f1eccd734dac865f12d144", "message": "Merge branch 'master' into doc--haskell-concrete", "committedDate": "2020-07-29T20:04:45Z", "type": "commit"}]}