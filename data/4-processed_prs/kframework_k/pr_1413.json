{"pr_number": 1413, "pr_title": "map-symbolic-tests: update assignment specs to have an explicit RHS", "pr_createdAt": "2020-07-10T05:07:43Z", "pr_url": "https://github.com/kframework/k/pull/1413", "timeline": [{"oid": "21a6c05f5abdc7a5b11bb2657075943d14b61ebb", "url": "https://github.com/kframework/k/commit/21a6c05f5abdc7a5b11bb2657075943d14b61ebb", "message": "align the commented out rule", "committedDate": "2020-07-10T04:37:50Z", "type": "commit"}, {"oid": "ca73a1701a0f98d929b11d1492abf671d4ae6720", "url": "https://github.com/kframework/k/commit/ca73a1701a0f98d929b11d1492abf671d4ae6720", "message": "assignment: add explicit RHS of spec", "committedDate": "2020-07-10T04:37:50Z", "type": "commit"}, {"oid": "7d38381c8013dd644f62030dadcda0afec1c33fd", "url": "https://github.com/kframework/k/commit/7d38381c8013dd644f62030dadcda0afec1c33fd", "message": "gen-test assignment", "committedDate": "2020-07-10T04:37:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyNTk4Mg==", "url": "https://github.com/kframework/k/pull/1413#discussion_r452625982", "bodyText": "I'd like to have the RHS of this spec to be #False, but the java backend couldn't parse it.  .Map should be not bad, because it is unlikely to be proved accidentally.", "author": "daejunpark", "createdAt": "2020-07-10T05:14:54Z", "path": "k-distribution/tests/regression-new/map-symbolic-tests/assignment", "diffHunk": "@@ -1,31 +1,31 @@\n-rule <k> assignment ( .Map [ x <- 3 ] ) => . </k>\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k>\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Y in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool notBool Y in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool notBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool notBool Y in_keys(MAP) andBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z  ==K Y andBool Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool Z  ==K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X andBool Y in_keys(MAP) andBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X andBool notBool Y in_keys(MAP) andBool notBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X andBool X in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X andBool notBool X in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z =/=K Y andBool Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z  ==K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z  ==K Y\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z =/=K Y\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z =/=K Y andBool Z =/=K X\n-rule <k> assignment ( (X:MyId |-> 3 1 |-> 4) [ 0 <- 5 ] ) => . </k> requires X =/=K 1\n-rule <k> assignment ( (X:MyId |-> 4) [ X <- 3 ] ) => . </k>\n-rule <k> assignment ( (X:MyId |-> 3 y |-> 4) [ x <- 5 ] ) => . </k> requires X =/=K y\n-rule <k> assignment ( (       X:MyId   |-> BAL_TO:Int       Y:MyId   |-> BAL_FROM:Int MAP:Map ) [       Y   <- BAL_FROM -Int 30 ] ) => . </k> requires       X   =/=K       Y\n-rule <k> assignment ( ( foo ( X:MyId ) |-> BAL_TO:Int foo ( Y:MyId ) |-> BAL_FROM:Int MAP:Map ) [ foo ( Y ) <- BAL_FROM -Int 30 ] ) => . </k> requires       X   =/=K       Y\n-rule <k> assignment ( ( foo ( X:MyId ) |-> BAL_TO:Int foo ( Y:MyId ) |-> BAL_FROM:Int MAP:Map ) [ foo ( Y ) <- BAL_FROM -Int 30 ] ) => . </k> requires foo ( X ) =/=K foo ( Y )\n+rule <k> assignment ( .Map [ x <- 3 ] ) => assignmentResult ( x |-> 3 )  </k>\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP  X |-> 1 ) [ Y <- 2 ] [ Z <- 3 ] )   </k>\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP [ Y <- 2 ]  X |-> 1 ) [ Z <- 3 ] )   </k> requires Y =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP [ Y <- 2 ]  X |-> 1 ) [ Z <- 3 ] )   </k> requires Y =/=K X andBool Y in_keys(MAP)\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP [ Y <- 2 ]  X |-> 1 ) [ Z <- 3 ] )   </k> requires Y =/=K X andBool notBool Y in_keys(MAP) // oracle: ( MAP Y |-> 2 X |-> 1 ) [ Z <- 3 ]\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP  X |-> 2 ) [ Z <- 3 ]            )   </k> requires Y ==K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Z <- 3 ]  X |-> 2              )   </k> requires Y ==K X andBool Z in_keys(MAP) // implies Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP  X |-> 2 ) [ Z <- 3 ]            )   </k> requires Y ==K X andBool notBool Z in_keys(MAP)\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP [ Y <- 2 ]  X |-> 1 ) [ Z <- 3 ] )   </k> requires Y =/=K X andBool Z =/=K Y\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K Y andBool notBool Y in_keys(MAP) andBool Z in_keys(MAP) // implies Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 3 ]  X |-> 1              )   </k> requires Y =/=K X andBool Z  ==K Y andBool Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ]  X |-> 3              )   </k> requires Y =/=K X andBool Z =/=K Y andBool Z  ==K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X andBool Y in_keys(MAP) andBool Z in_keys(MAP)\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X andBool notBool Y in_keys(MAP) andBool notBool Z in_keys(MAP)\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP  X |-> 3                         )   </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (  .Map                                  )   </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X andBool X in_keys(MAP) // unsatisfiable pre-condition", "originalCommit": "7d38381c8013dd644f62030dadcda0afec1c33fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyODUzMw==", "url": "https://github.com/kframework/k/pull/1413#discussion_r452628533", "bodyText": "Note that I also found that this rule could lead to an infinite loop, even if we have the additional condition of K2 in_keys(MAP).  A counter example: M [ K1 <- _ ] [ K2 <- _ ] where M is a variable, and we have both K1 in_keys(M) and K2 in_keys(M).\n(It is possible to make it finite by having a custom in_keys rules, but its performance overhead could be problematic for a large map. So, such rules are better to be put in project-specific lemmas.)", "author": "daejunpark", "createdAt": "2020-07-10T05:25:20Z", "path": "k-distribution/include/kframework/builtin/domains.k", "diffHunk": "@@ -190,9 +190,7 @@ module MAP-JAVA-SYMBOLIC [kast, symbolic]\n   rule ((K1 |-> V1) MAP) [ K2 <- V2 ] => (K1 |-> V1) (MAP [ K2 <- V2 ]) requires K1 =/=K K2\n \n   rule (MAP:Map [ K1 <- V1 ]) [ K2 <- V2 ] => MAP              [ K1 <- V2 ] requires K1  ==K K2\n-\n-  // potential infinite loop\n-  // rule (MAP:Map [ K1 <- V1 ]) [ K2 <- V2 ] => MAP [ K2 <- V2 ] [ K1 <- V1 ] requires K1 =/=K K2\n+//rule (MAP:Map [ K1 <- V1 ]) [ K2 <- V2 ] => MAP [ K2 <- V2 ] [ K1 <- V1 ] requires K1 =/=K K2 // potential infinite loop even if `K2 in_keys(MAP)`", "originalCommit": "7d38381c8013dd644f62030dadcda0afec1c33fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e4aec0366fb2ff20ae78040b37f279c9f1dff0fc", "url": "https://github.com/kframework/k/commit/e4aec0366fb2ff20ae78040b37f279c9f1dff0fc", "message": "update assignment-30-spec.k.out", "committedDate": "2020-07-10T06:14:45Z", "type": "commit"}, {"oid": "167adf8fbbba6079a21f7ee145d35854f35df79d", "url": "https://github.com/kframework/k/commit/167adf8fbbba6079a21f7ee145d35854f35df79d", "message": "Merge branch 'master' into map-symbolic-tests", "committedDate": "2020-07-10T19:03:52Z", "type": "commit"}]}