{"pr_number": 1378, "pr_title": "Additional documentation for: cell fragments, the `prec` attribute, `#Layout` and converting between token sorts.", "pr_createdAt": "2020-06-25T23:48:34Z", "pr_url": "https://github.com/kframework/k/pull/1378", "timeline": [{"oid": "6a545a15e62f8a3e1c010acebd9ea3fd58510a48", "url": "https://github.com/kframework/k/commit/6a545a15e62f8a3e1c010acebd9ea3fd58510a48", "message": "pending-documentation: COnverting between token sorts", "committedDate": "2020-06-25T23:27:17Z", "type": "commit"}, {"oid": "535f62514df2ee06de9b4ee3dd2173a51cd5f721", "url": "https://github.com/kframework/k/commit/535f62514df2ee06de9b4ee3dd2173a51cd5f721", "message": "pending-documentation: Parsing comments / #Layout", "committedDate": "2020-06-25T23:30:57Z", "type": "commit"}, {"oid": "9939f6f466cc0d108c446d18a6b47ffe8d20603f", "url": "https://github.com/kframework/k/commit/9939f6f466cc0d108c446d18a6b47ffe8d20603f", "message": "pending-documentation: Cell fragments", "committedDate": "2020-06-25T23:36:07Z", "type": "commit"}, {"oid": "3ab43052d02a8e9341363e49ce8fb9defe704807", "url": "https://github.com/kframework/k/commit/3ab43052d02a8e9341363e49ce8fb9defe704807", "message": "pending-documentation: prec attribute", "committedDate": "2020-06-25T23:38:48Z", "type": "commit"}, {"oid": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff", "url": "https://github.com/kframework/k/commit/ed31c8428a5ea05cd61d59ebbe8aef341facaaff", "message": "pending-documentation: Remove enclosing modules and test related code blocks", "committedDate": "2020-06-25T23:45:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxODU0MQ==", "url": "https://github.com/kframework/k/pull/1378#discussion_r445918541", "bodyText": "Should this be indented consistently with the other code blocks?", "author": "ehildenb", "createdAt": "2020-06-26T01:13:38Z", "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```", "originalCommit": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk0MDQyMA==", "url": "https://github.com/kframework/k/pull/1378#discussion_r445940420", "bodyText": "Different code blocks in the document are formatted differently. The most common was unindented, so I was using that. But, I'll change it to 4 spaces.", "author": "nishantjr", "createdAt": "2020-06-26T02:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxODU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk0MTAzNA==", "url": "https://github.com/kframework/k/pull/1378#discussion_r445941034", "bodyText": "Actually, the document is overwhelmingly unindented, so I'll move the couple I forgot to left indented to that format", "author": "nishantjr", "createdAt": "2020-06-26T02:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxODU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNTIwNQ==", "url": "https://github.com/kframework/k/pull/1378#discussion_r445925205", "bodyText": "Clarify here that they will be thrown away by the scanner, so the parser will not even see these tokens.", "author": "ehildenb", "createdAt": "2020-06-26T01:42:15Z", "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```\n+\n+Similarly, the hook `STRING.string2Token` allows the inverse:\n+\n+```k\n+  syntax Bar ::= StringToBar(String) [function, functional, hook(STRING.string2token)]\n+```\n+\n+WARNING: This sort of conversion does *NOT* do any sort of parsing or validation.\n+Thus, we can create arbitary tokens of any sort:\n+\n+```\n+StringToBar(\"The sun rises in the west.\")\n+```\n+\n+Composing these two functions lets us convert from `Foo` to `Bar`\n+\n+```k\n+  syntax Bar ::= FooToBar(Foo) [function]\n+  rule FooToBar(F) => StringToBar(FooToString(F))\n+```\n+\n+### Parsing comments, and the `#Layout` sort\n+\n+Productions for the `#Layout` sort are used to describe tokens that are\n+considered \"whitespace\". For example, below, we use it to define lines begining\n+with `;` (semicolon) as comments.", "originalCommit": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNTMwNw==", "url": "https://github.com/kframework/k/pull/1378#discussion_r445925307", "bodyText": "whos syntax allows => with syntax that allows.\nAlso lowercase Names => names", "author": "ehildenb", "createdAt": "2020-06-26T01:42:49Z", "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```\n+\n+Similarly, the hook `STRING.string2Token` allows the inverse:\n+\n+```k\n+  syntax Bar ::= StringToBar(String) [function, functional, hook(STRING.string2token)]\n+```\n+\n+WARNING: This sort of conversion does *NOT* do any sort of parsing or validation.\n+Thus, we can create arbitary tokens of any sort:\n+\n+```\n+StringToBar(\"The sun rises in the west.\")\n+```\n+\n+Composing these two functions lets us convert from `Foo` to `Bar`\n+\n+```k\n+  syntax Bar ::= FooToBar(Foo) [function]\n+  rule FooToBar(F) => StringToBar(FooToString(F))\n+```\n+\n+### Parsing comments, and the `#Layout` sort\n+\n+Productions for the `#Layout` sort are used to describe tokens that are\n+considered \"whitespace\". For example, below, we use it to define lines begining\n+with `;` (semicolon) as comments.\n+\n+```k\n+syntax #Layout ::= r\"(;[^\\\\n\\\\r]*)\"    // Semi-colon comments\n+                 | r\"([\\\\ \\\\n\\\\r\\\\t])\" // Whitespace\n+```\n+\n+### `prec` attribute\n+\n+Consider the following naive attempt at creating a language whos syntax\n+allows two types of variables: Names that contain underbars, and names that\n+contain sharps/hashes/pound-signs:", "originalCommit": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNzgzNw==", "url": "https://github.com/kframework/k/pull/1378#discussion_r445927837", "bodyText": "This should not be in the documentation, but made into an issue.", "author": "ehildenb", "createdAt": "2020-06-26T01:53:43Z", "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```\n+\n+Similarly, the hook `STRING.string2Token` allows the inverse:\n+\n+```k\n+  syntax Bar ::= StringToBar(String) [function, functional, hook(STRING.string2token)]\n+```\n+\n+WARNING: This sort of conversion does *NOT* do any sort of parsing or validation.\n+Thus, we can create arbitary tokens of any sort:\n+\n+```\n+StringToBar(\"The sun rises in the west.\")\n+```\n+\n+Composing these two functions lets us convert from `Foo` to `Bar`\n+\n+```k\n+  syntax Bar ::= FooToBar(Foo) [function]\n+  rule FooToBar(F) => StringToBar(FooToString(F))\n+```\n+\n+### Parsing comments, and the `#Layout` sort\n+\n+Productions for the `#Layout` sort are used to describe tokens that are\n+considered \"whitespace\". For example, below, we use it to define lines begining\n+with `;` (semicolon) as comments.\n+\n+```k\n+syntax #Layout ::= r\"(;[^\\\\n\\\\r]*)\"    // Semi-colon comments\n+                 | r\"([\\\\ \\\\n\\\\r\\\\t])\" // Whitespace\n+```\n+\n+### `prec` attribute\n+\n+Consider the following naive attempt at creating a language whos syntax\n+allows two types of variables: Names that contain underbars, and names that\n+contain sharps/hashes/pound-signs:\n+\n+```k\n+syntax NameWithUnderbar ::= r\"[a-zA-Z][A-Za-z0-9_]*\"  [token]\n+syntax NameWithSharp    ::= r\"[a-zA-Z][A-Za-z0-9_#]*\" [token]\n+syntax Pgm ::= underbar(NameWithUnderbar)\n+             | sharp(NameWithSharp)\n+```\n+\n+Although, it seems that K has enough information to parse the programs\n+`underbar(foo)` and `sharp(foo)` with, the lexer does not take into account\n+whether a token is being parsed for the `sharp` or for the `underbar`\n+production. It chooses an arbitary sort for the token `foo` (perhaps\n+`NameWithUnderbar`). Thus, during paring it is unable to construct a valid term\n+for one of those programs (`sharp(foo)`) and produces the error message:\n+`Inner Parser: Parse error: unexpected token 'foo'.`\n+\n+Since calculating inclusions and intersections between regular expressions is\n+tricky, we must provide this information to K. We do this via the `prec(N)`\n+attribute that specifies the order in which the lexer tries tokens. Token\n+productions with higher precedence are tried first.\n+\n+We also need to make sorts with more specific tokens subsorts of ones with more\n+general tokens. We add the token attribute to this production so that all tokens\n+of a particular sort are marked with the sort it is parsed as, and not a subsort\n+thereof. e.g.\u00a0we get `underbar(#token(\"foo\", \"NameWithUnderbar\"))` instead of\n+`underbar(#token(\"foo\", \"#LowerId\"))`\n+\n+*TODO:* `#UpperId` and `#LowerId` have `prec(2)` while `KLabel` and `#KVariable`\n+have `prec(1)`. That does not leave much room for other priorities. Even if\n+`KLabel`, `#KVariable` aren't a problem, since we can't have negative\n+precedences, only `prec(0)` and `prec(1)` are available to users. Perhaps we\n+should multiply these by 100?", "originalCommit": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyODU0Nw==", "url": "https://github.com/kframework/k/pull/1378#discussion_r445928547", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            syntax Set ::= collectOddFoos(FoosCell) [function]\n          \n          \n            \n            rule collectOddFoos(<foos> <foo> I </foo> REST </foos>)\n          \n          \n            \n              => SetItem(I) collectOddFoos(<foos> REST </foos>)\n          \n          \n            \n              requires I %Int 2 ==Int 1\n          \n          \n            \n            rule collectOddFoos(<foos> <foo> I </foo> REST </foos>)\n          \n          \n            \n              => collectOddFoos(<foos> REST </foos>)\n          \n          \n            \n              requires I %Int 2 ==Int 0\n          \n          \n            \n            rule collectOddFoos(<foos> .Bag </foos>) => .Set\n          \n          \n            \n                syntax Set ::= collectOddFoos(FoosCell) [function]\n          \n          \n            \n             // -----------------------------------------\n          \n          \n            \n                rule collectOddFoos(<foos> .Bag </foos>) => .Set\n          \n          \n            \n                rule collectOddFoos(<foos> <foo> I </foo> REST </foos>) => SetItem(I) collectOddFoos(<foos> REST </foos>) requires I %Int 2 ==Int 1\n          \n          \n            \n                rule collectOddFoos(<foos> <foo> I </foo> REST </foos>) => collectOddFoos(<foos> REST </foos>) requires I %Int 2 ==Int 0\n          \n      \n    \n    \n  \n\nThis is just a suggestion, but try to format this one so it's more readable/scannable. I like to try and make it obvious what the differences between the multiple rules are.", "author": "ehildenb", "createdAt": "2020-06-26T01:56:34Z", "path": "pending-documentation.md", "diffHunk": "@@ -1321,6 +1414,43 @@ Note that in the case of Set and Map, one guarantee is that K1, K2, K3, and K4\n represent /distinct/ elements. Pattern matching fails if the correct number of\n distinct elements cannot be found.\n \n+### Matching on cell fragments\n+\n+K allows matching fragments of the configuration and using them to construct\n+terms and use as function parameters.\n+\n+```k\n+configuration <t>\n+                <k> #init ~> #collectOddFoos ~> $PGM </k>\n+                <foos>\n+                  <foo multiplicity=\"*\" type=\"Set\"> 1 </foo>\n+                </foos>\n+              </t>\n+```\n+\n+The `#collectOddFoos` construct grabs the entire content of the `<foos>` cell.\n+We may also match on only a portion of its content. Note that the fragment\n+must be wrapped in a `<foo>` cell at the call site.\n+\n+```k\n+syntax KItem ::= \"#collectOddFoos\"\n+rule <k> #collectOddFoos => collectOddFoos(<foos> FOOS </foos>) ... </k>\n+     <foos> FOOS </foos>\n+```\n+\n+The `collectOddFoos` function collects the items it needs\n+\n+```k\n+syntax Set ::= collectOddFoos(FoosCell) [function]\n+rule collectOddFoos(<foos> <foo> I </foo> REST </foos>)\n+  => SetItem(I) collectOddFoos(<foos> REST </foos>)\n+  requires I %Int 2 ==Int 1\n+rule collectOddFoos(<foos> <foo> I </foo> REST </foos>)\n+  => collectOddFoos(<foos> REST </foos>)\n+  requires I %Int 2 ==Int 0\n+rule collectOddFoos(<foos> .Bag </foos>) => .Set", "originalCommit": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0d143547e345f04af0087ac6e2d5fcb3ac127ec0", "url": "https://github.com/kframework/k/commit/0d143547e345f04af0087ac6e2d5fcb3ac127ec0", "message": "Fix formatting", "committedDate": "2020-06-26T02:52:24Z", "type": "commit"}, {"oid": "0cdd47ace0c9c236401336a9b5d9c8fb1ab5c15d", "url": "https://github.com/kframework/k/commit/0cdd47ace0c9c236401336a9b5d9c8fb1ab5c15d", "message": "Formatting", "committedDate": "2020-06-26T02:57:20Z", "type": "commit"}, {"oid": "ab89a913727290a39d99d0af52bf2791458230c8", "url": "https://github.com/kframework/k/commit/ab89a913727290a39d99d0af52bf2791458230c8", "message": "Remove TODO", "committedDate": "2020-06-26T02:57:41Z", "type": "commit"}, {"oid": "226d2895f4d927a14f866c2b7aa997e85c88499d", "url": "https://github.com/kframework/k/commit/226d2895f4d927a14f866c2b7aa997e85c88499d", "message": "Update pending-documentation.md", "committedDate": "2020-07-09T18:33:22Z", "type": "commit"}, {"oid": "1e76e674f2ac5283ff92707f979b1f36e9b12ea8", "url": "https://github.com/kframework/k/commit/1e76e674f2ac5283ff92707f979b1f36e9b12ea8", "message": "Merge branch 'master' into merge-kplay", "committedDate": "2020-07-09T20:22:01Z", "type": "commit"}]}