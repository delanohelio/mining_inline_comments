{"pr_number": 1259, "pr_title": "Add more support for Bison and add documentation", "pr_createdAt": "2020-05-05T22:08:56Z", "pr_url": "https://github.com/kframework/k/pull/1259", "timeline": [{"oid": "5272a78acb0043ca20b39b7fa7c740aa523a9eb2", "url": "https://github.com/kframework/k/commit/5272a78acb0043ca20b39b7fa7c740aa523a9eb2", "message": "add test", "committedDate": "2020-05-05T21:38:27Z", "type": "commit"}, {"oid": "3a87d8c564491d60f2c1dd51b478aa5f0b167e9e", "url": "https://github.com/kframework/k/commit/3a87d8c564491d60f2c1dd51b478aa5f0b167e9e", "message": "generate non PGM config variable parsers", "committedDate": "2020-05-05T21:38:37Z", "type": "commit"}, {"oid": "282e36353bd72b1bd5e184a3f3b2316f026a66b1", "url": "https://github.com/kframework/k/commit/282e36353bd72b1bd5e184a3f3b2316f026a66b1", "message": "add documentation", "committedDate": "2020-05-05T22:07:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY5ODUzNg==", "url": "https://github.com/kframework/k/pull/1259#discussion_r420698536", "bodyText": "What's going on here?", "author": "ehildenb", "createdAt": "2020-05-06T10:46:14Z", "path": "k-distribution/tests/regression-new/parseNonPgm/1.test.out", "diffHunk": "@@ -0,0 +1,8 @@\n+11<generatedTop>\n+  <k>\n+    .Pgm ~> .\n+  </k>", "originalCommit": "282e36353bd72b1bd5e184a3f3b2316f026a66b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyMzYyNA==", "url": "https://github.com/kframework/k/pull/1259#discussion_r421523624", "bodyText": "NVM, the 11 comes from the #write()", "author": "ehildenb", "createdAt": "2020-05-07T13:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY5ODUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwNjEwMw==", "url": "https://github.com/kframework/k/pull/1259#discussion_r420706103", "bodyText": "I don't particularly like this way of specifying the module to parse in, because it isn't local to where the variable is declared. For example, what if you want to use the INT-SYNTAX module to parse a given configuration variable?\nI think it's better to either,\n\nhave the annotation on the cell itself (eg. <foo parseModule=\"FOO-SYNTAX\"> $FOO:Foo </foo>), but this isn't perfect because what if the cell is like <foo> bar($FOO:Foo) </foo>.\nas an attribute on the module which declares the configuration\ndon't directly generate parsers for configuration variables, instead for pairs of (Sort, Module). So we would generate parser_Pgm_MAIN-SYNTAX-MODULE, parser_Pgm_SOME-OTHER-MODULE, parser_Foo_FOO-SYNTAX, parser_Foo_MAIN-SYNTAX-MODULE, where Pgm and Foo are sorts, not configuration variables. We can still always generate the default parser_Pgm_MAIN-SYNTAX-MODULE. Then kompile/kast can take a variadic number of Sort/Module pairs (default just being [(sort(PGM), MAIN-SYNTAX-MODULE)]) to generate the parsers.\n\nIn order of preference, I would say (3), (1), (2). Mostly I like (3) because it makes it exposes what the actual functionality is, which has little to do with the configuration variables, and more to do with parsers for sorts in modules. The only reason I see it getting conflated with configuration variables is because those are the most useful parsers to generate.", "author": "ehildenb", "createdAt": "2020-05-06T11:01:24Z", "path": "pending-documentation.md", "diffHunk": "@@ -1665,6 +1665,72 @@ Since this feature is not clearly needed by K users at the moment, it is only\n presented here as an example; its implementation will be postponed for such time\n when its usefulness becomes apparent.\n \n+Parser Generation\n+-----------------\n+\n+In addition to on-the-fly parser generation using `kast`, K is capable of\n+ahead-of-time parser generation of LR(1) or GLR parsers using Flex and Bison.\n+This can be done one of two different ways.\n+\n+1. You can explicitly request for a particular parser to be generated by\n+   invoking `kast --gen-parser <outputFile>` or\n+   `kast --gen-glr-parser <outputFile>` respectively. `kast` will then create a\n+   parser based on the same command line flags that govern on-the-fly parsing,\n+   like `-s` to specify the starting sort, and `-m` to specify the module to\n+   parse under. By default, this generates a parser for the sort of the $PGM\n+   configuration variable in the main syntax module of the definition.\n+2. You can request that a specific set of parsers be generated for all the\n+   configuration variables of your definition by passing the\n+   `--gen-bison-parser` or `--gen-glr-bison-parser` flags to `kompile`.\n+   `kompile` will decide the sorts to use as start symbols based on the sorts\n+   in the configuration declaration for the configuration variables. The $PGM\n+   configuration variable will be generated based on the main syntax module\n+   of the definition. The user must explicitly annotate other modules with the\n+   configuration variables that they should be used to parse as attributes.\n+   For example, `module TEST [parser(FOO)]` will tell `kompile` to parse the \n+   $FOO configuration variable using the syntax in the TEST module. If the user\n+   forgets to annotate the modules with the configuration variables, only the \n+   $PGM parser will be generated.", "originalCommit": "282e36353bd72b1bd5e184a3f3b2316f026a66b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "117b1eae1d0046d092e5de84d4f2c708dd0f27ba", "url": "https://github.com/kframework/k/commit/117b1eae1d0046d092e5de84d4f2c708dd0f27ba", "message": "update to new syntax based on Everett's comments", "committedDate": "2020-05-07T14:13:15Z", "type": "commit"}, {"oid": "a16118c800f3590f078568f822d04e42cad8331e", "url": "https://github.com/kframework/k/commit/a16118c800f3590f078568f822d04e42cad8331e", "message": "update documentation", "committedDate": "2020-05-07T14:16:40Z", "type": "commit"}, {"oid": "b1e8b1a2a69575434fc5f697f70b3ed0d6f96a2c", "url": "https://github.com/kframework/k/commit/b1e8b1a2a69575434fc5f697f70b3ed0d6f96a2c", "message": "fix whitespace", "committedDate": "2020-05-07T14:17:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0MDg3Nw==", "url": "https://github.com/kframework/k/pull/1259#discussion_r421540877", "bodyText": "I believe we use this same strategy for getting subparts of many axioms. Can you look and see if it's reasonable to factor out a method directed at it?", "author": "ehildenb", "createdAt": "2020-05-07T14:18:47Z", "path": "kernel/src/main/java/org/kframework/kompile/Kompile.java", "diffHunk": "@@ -154,10 +154,24 @@ public CompiledDefinition run(File definitionFile, String mainModuleName, String\n \n         if (kompileOptions.experimental.genBisonParser || kompileOptions.experimental.genGlrBisonParser) {\n             new KRead(kem, files, InputModes.PROGRAM).createBisonParser(def.programParsingModuleFor(def.mainSyntaxModuleName(), kem).get(), def.programStartSymbol, files.resolveKompiled(\"parser_PGM\"), kompileOptions.experimental.genGlrBisonParser);\n-            for (Module mod : iterable(def.getParsedDefinition().entryModules())) {\n-              if (mod.att().contains(\"parser\")) {\n-                new KRead(kem, files, InputModes.PROGRAM).createBisonParser(def.programParsingModuleFor(mod.name(), kem).get(), def.configurationVariableDefaultSorts.getOrDefault(\"$\" + mod.att().get(\"parser\"), Sorts.K()), files.resolveKompiled(\"parser_\" + mod.att().get(\"parser\")), kompileOptions.experimental.genGlrBisonParser);\n-              }\n+            for (Production prod : iterable(kompiledDefinition.mainModule().productions())) {\n+                if (prod.att().contains(\"cell\") && prod.att().contains(\"parser\")) {\n+                    String att = prod.att().get(\"parser\");\n+                    String[] parts = att.trim().split(\";\");\n+                    for (String part : parts) {\n+                        String[] subparts = part.trim().split(\",\");", "originalCommit": "117b1eae1d0046d092e5de84d4f2c708dd0f27ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e1328d2a5900b0ac0a74ee9d170db250560c59ea", "url": "https://github.com/kframework/k/commit/e1328d2a5900b0ac0a74ee9d170db250560c59ea", "message": "Merge branch 'master' into parser4", "committedDate": "2020-05-07T14:38:59Z", "type": "commit"}, {"oid": "6e9094a2460f071a40c5c6b8f381bf9b5b6e86ec", "url": "https://github.com/kframework/k/commit/6e9094a2460f071a40c5c6b8f381bf9b5b6e86ec", "message": "fix relative path", "committedDate": "2020-05-07T15:09:12Z", "type": "commit"}, {"oid": "8d4b4e2b03dd90c1607467d739f8e2f029955fcb", "url": "https://github.com/kframework/k/commit/8d4b4e2b03dd90c1607467d739f8e2f029955fcb", "message": "remove some dead code", "committedDate": "2020-05-07T15:33:19Z", "type": "commit"}, {"oid": "f9652bbe34a58426897abec7ac380945447b9cfe", "url": "https://github.com/kframework/k/commit/f9652bbe34a58426897abec7ac380945447b9cfe", "message": "add StringUtil functions to split attribute values", "committedDate": "2020-05-07T15:33:26Z", "type": "commit"}, {"oid": "7a23302c6ae912104f05b37e7fecdef236b2aefd", "url": "https://github.com/kframework/k/commit/7a23302c6ae912104f05b37e7fecdef236b2aefd", "message": "use StringUtil functions to split parser attribute", "committedDate": "2020-05-07T15:33:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5NjY3OA==", "url": "https://github.com/kframework/k/pull/1259#discussion_r421796678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               `TEST2` moducle. If the user forgets to annotate the declaration with the\n          \n          \n            \n               `TEST2` module. If the user forgets to annotate the declaration with the", "author": "ehildenb", "createdAt": "2020-05-07T21:11:05Z", "path": "pending-documentation.md", "diffHunk": "@@ -1665,6 +1665,75 @@ Since this feature is not clearly needed by K users at the moment, it is only\n presented here as an example; its implementation will be postponed for such time\n when its usefulness becomes apparent.\n \n+Parser Generation\n+-----------------\n+\n+In addition to on-the-fly parser generation using `kast`, K is capable of\n+ahead-of-time parser generation of LR(1) or GLR parsers using Flex and Bison.\n+This can be done one of two different ways.\n+\n+1. You can explicitly request for a particular parser to be generated by\n+   invoking `kast --gen-parser <outputFile>` or\n+   `kast --gen-glr-parser <outputFile>` respectively. `kast` will then create a\n+   parser based on the same command line flags that govern on-the-fly parsing,\n+   like `-s` to specify the starting sort, and `-m` to specify the module to\n+   parse under. By default, this generates a parser for the sort of the $PGM\n+   configuration variable in the main syntax module of the definition.\n+2. You can request that a specific set of parsers be generated for all the\n+   configuration variables of your definition by passing the\n+   `--gen-bison-parser` or `--gen-glr-bison-parser` flags to `kompile`.\n+   `kompile` will decide the sorts to use as start symbols based on the sorts\n+   in the configuration declaration for the configuration variables. The $PGM\n+   configuration variable will be generated based on the main syntax module\n+   of the definition. The user must explicitly annotate the configuration\n+   declaration with the other modules to use to parse the other configuration\n+   variables as attributes. For example, if I have the following cell in the\n+   configuration declaration: `<cell> foo($FOO:Foo, $BAR:Bar) </cell>`,\n+   One might annotate it with the attribute pair `parser=\"FOO, TEST; BAR, TEST2\"`\n+   to indicate that configuration variable `$FOO` should be parsed in the\n+   `TEST` module, and configuration variable `$BAR` should be parsed in the\n+   `TEST2` moducle. If the user forgets to annotate the declaration with the", "originalCommit": "7a23302c6ae912104f05b37e7fecdef236b2aefd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4accfc905b235b08198b1e30e63215eefb281945", "url": "https://github.com/kframework/k/commit/4accfc905b235b08198b1e30e63215eefb281945", "message": "Update pending-documentation.md\n\nCo-authored-by: Everett Hildenbrandt <everett.hildenbrandt@gmail.com>", "committedDate": "2020-05-08T16:40:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxNDc2NQ==", "url": "https://github.com/kframework/k/pull/1259#discussion_r422614765", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               parse under. By default, this generates a parser for the sort of the $PGM\n          \n          \n            \n               parse under. By default, this generates a parser for the sort of the `$PGM`", "author": "ehildenb", "createdAt": "2020-05-10T09:10:08Z", "path": "pending-documentation.md", "diffHunk": "@@ -1665,6 +1665,75 @@ Since this feature is not clearly needed by K users at the moment, it is only\n presented here as an example; its implementation will be postponed for such time\n when its usefulness becomes apparent.\n \n+Parser Generation\n+-----------------\n+\n+In addition to on-the-fly parser generation using `kast`, K is capable of\n+ahead-of-time parser generation of LR(1) or GLR parsers using Flex and Bison.\n+This can be done one of two different ways.\n+\n+1. You can explicitly request for a particular parser to be generated by\n+   invoking `kast --gen-parser <outputFile>` or\n+   `kast --gen-glr-parser <outputFile>` respectively. `kast` will then create a\n+   parser based on the same command line flags that govern on-the-fly parsing,\n+   like `-s` to specify the starting sort, and `-m` to specify the module to\n+   parse under. By default, this generates a parser for the sort of the $PGM", "originalCommit": "4accfc905b235b08198b1e30e63215eefb281945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxNDc5NQ==", "url": "https://github.com/kframework/k/pull/1259#discussion_r422614795", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               in the configuration declaration for the configuration variables. The $PGM\n          \n          \n            \n               in the configuration declaration for the configuration variables. The `$PGM`", "author": "ehildenb", "createdAt": "2020-05-10T09:10:25Z", "path": "pending-documentation.md", "diffHunk": "@@ -1665,6 +1665,75 @@ Since this feature is not clearly needed by K users at the moment, it is only\n presented here as an example; its implementation will be postponed for such time\n when its usefulness becomes apparent.\n \n+Parser Generation\n+-----------------\n+\n+In addition to on-the-fly parser generation using `kast`, K is capable of\n+ahead-of-time parser generation of LR(1) or GLR parsers using Flex and Bison.\n+This can be done one of two different ways.\n+\n+1. You can explicitly request for a particular parser to be generated by\n+   invoking `kast --gen-parser <outputFile>` or\n+   `kast --gen-glr-parser <outputFile>` respectively. `kast` will then create a\n+   parser based on the same command line flags that govern on-the-fly parsing,\n+   like `-s` to specify the starting sort, and `-m` to specify the module to\n+   parse under. By default, this generates a parser for the sort of the $PGM\n+   configuration variable in the main syntax module of the definition.\n+2. You can request that a specific set of parsers be generated for all the\n+   configuration variables of your definition by passing the\n+   `--gen-bison-parser` or `--gen-glr-bison-parser` flags to `kompile`.\n+   `kompile` will decide the sorts to use as start symbols based on the sorts\n+   in the configuration declaration for the configuration variables. The $PGM", "originalCommit": "4accfc905b235b08198b1e30e63215eefb281945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxNDg2Mw==", "url": "https://github.com/kframework/k/pull/1259#discussion_r422614863", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               parser attribute, only the $PGM parser will be generated.\n          \n          \n            \n               parser attribute, only the `$PGM` parser will be generated.", "author": "ehildenb", "createdAt": "2020-05-10T09:10:48Z", "path": "pending-documentation.md", "diffHunk": "@@ -1665,6 +1665,75 @@ Since this feature is not clearly needed by K users at the moment, it is only\n presented here as an example; its implementation will be postponed for such time\n when its usefulness becomes apparent.\n \n+Parser Generation\n+-----------------\n+\n+In addition to on-the-fly parser generation using `kast`, K is capable of\n+ahead-of-time parser generation of LR(1) or GLR parsers using Flex and Bison.\n+This can be done one of two different ways.\n+\n+1. You can explicitly request for a particular parser to be generated by\n+   invoking `kast --gen-parser <outputFile>` or\n+   `kast --gen-glr-parser <outputFile>` respectively. `kast` will then create a\n+   parser based on the same command line flags that govern on-the-fly parsing,\n+   like `-s` to specify the starting sort, and `-m` to specify the module to\n+   parse under. By default, this generates a parser for the sort of the $PGM\n+   configuration variable in the main syntax module of the definition.\n+2. You can request that a specific set of parsers be generated for all the\n+   configuration variables of your definition by passing the\n+   `--gen-bison-parser` or `--gen-glr-bison-parser` flags to `kompile`.\n+   `kompile` will decide the sorts to use as start symbols based on the sorts\n+   in the configuration declaration for the configuration variables. The $PGM\n+   configuration variable will be generated based on the main syntax module\n+   of the definition. The user must explicitly annotate the configuration\n+   declaration with the other modules to use to parse the other configuration\n+   variables as attributes. For example, if I have the following cell in the\n+   configuration declaration: `<cell> foo($FOO:Foo, $BAR:Bar) </cell>`,\n+   One might annotate it with the attribute pair `parser=\"FOO, TEST; BAR, TEST2\"`\n+   to indicate that configuration variable `$FOO` should be parsed in the\n+   `TEST` module, and configuration variable `$BAR` should be parsed in the\n+   `TEST2` module. If the user forgets to annotate the declaration with the\n+   parser attribute, only the $PGM parser will be generated.", "originalCommit": "4accfc905b235b08198b1e30e63215eefb281945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxNDk2Nw==", "url": "https://github.com/kframework/k/pull/1259#discussion_r422614967", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Bison parsers will always output kore. You can then pass the resulting AST\n          \n          \n            \n            * Bison parsers will always output Kore. You can then pass the resulting AST", "author": "ehildenb", "createdAt": "2020-05-10T09:11:07Z", "path": "pending-documentation.md", "diffHunk": "@@ -1665,6 +1665,75 @@ Since this feature is not clearly needed by K users at the moment, it is only\n presented here as an example; its implementation will be postponed for such time\n when its usefulness becomes apparent.\n \n+Parser Generation\n+-----------------\n+\n+In addition to on-the-fly parser generation using `kast`, K is capable of\n+ahead-of-time parser generation of LR(1) or GLR parsers using Flex and Bison.\n+This can be done one of two different ways.\n+\n+1. You can explicitly request for a particular parser to be generated by\n+   invoking `kast --gen-parser <outputFile>` or\n+   `kast --gen-glr-parser <outputFile>` respectively. `kast` will then create a\n+   parser based on the same command line flags that govern on-the-fly parsing,\n+   like `-s` to specify the starting sort, and `-m` to specify the module to\n+   parse under. By default, this generates a parser for the sort of the $PGM\n+   configuration variable in the main syntax module of the definition.\n+2. You can request that a specific set of parsers be generated for all the\n+   configuration variables of your definition by passing the\n+   `--gen-bison-parser` or `--gen-glr-bison-parser` flags to `kompile`.\n+   `kompile` will decide the sorts to use as start symbols based on the sorts\n+   in the configuration declaration for the configuration variables. The $PGM\n+   configuration variable will be generated based on the main syntax module\n+   of the definition. The user must explicitly annotate the configuration\n+   declaration with the other modules to use to parse the other configuration\n+   variables as attributes. For example, if I have the following cell in the\n+   configuration declaration: `<cell> foo($FOO:Foo, $BAR:Bar) </cell>`,\n+   One might annotate it with the attribute pair `parser=\"FOO, TEST; BAR, TEST2\"`\n+   to indicate that configuration variable `$FOO` should be parsed in the\n+   `TEST` module, and configuration variable `$BAR` should be parsed in the\n+   `TEST2` module. If the user forgets to annotate the declaration with the\n+   parser attribute, only the $PGM parser will be generated.\n+\n+Bison-generated parsers are extremely fast compared to `kast`, but they have\n+some important limitations:\n+\n+* Bison parsers will always output kore. You can then pass the resulting AST", "originalCommit": "4accfc905b235b08198b1e30e63215eefb281945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxNTEwNw==", "url": "https://github.com/kframework/k/pull/1259#discussion_r422615107", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              resulting productions generated for NeList will be LR(1) and use bounded\n          \n          \n            \n              resulting productions generated for `NeList{Sort}` will be LR(1) and use bounded", "author": "ehildenb", "createdAt": "2020-05-10T09:12:23Z", "path": "pending-documentation.md", "diffHunk": "@@ -1665,6 +1665,75 @@ Since this feature is not clearly needed by K users at the moment, it is only\n presented here as an example; its implementation will be postponed for such time\n when its usefulness becomes apparent.\n \n+Parser Generation\n+-----------------\n+\n+In addition to on-the-fly parser generation using `kast`, K is capable of\n+ahead-of-time parser generation of LR(1) or GLR parsers using Flex and Bison.\n+This can be done one of two different ways.\n+\n+1. You can explicitly request for a particular parser to be generated by\n+   invoking `kast --gen-parser <outputFile>` or\n+   `kast --gen-glr-parser <outputFile>` respectively. `kast` will then create a\n+   parser based on the same command line flags that govern on-the-fly parsing,\n+   like `-s` to specify the starting sort, and `-m` to specify the module to\n+   parse under. By default, this generates a parser for the sort of the $PGM\n+   configuration variable in the main syntax module of the definition.\n+2. You can request that a specific set of parsers be generated for all the\n+   configuration variables of your definition by passing the\n+   `--gen-bison-parser` or `--gen-glr-bison-parser` flags to `kompile`.\n+   `kompile` will decide the sorts to use as start symbols based on the sorts\n+   in the configuration declaration for the configuration variables. The $PGM\n+   configuration variable will be generated based on the main syntax module\n+   of the definition. The user must explicitly annotate the configuration\n+   declaration with the other modules to use to parse the other configuration\n+   variables as attributes. For example, if I have the following cell in the\n+   configuration declaration: `<cell> foo($FOO:Foo, $BAR:Bar) </cell>`,\n+   One might annotate it with the attribute pair `parser=\"FOO, TEST; BAR, TEST2\"`\n+   to indicate that configuration variable `$FOO` should be parsed in the\n+   `TEST` module, and configuration variable `$BAR` should be parsed in the\n+   `TEST2` module. If the user forgets to annotate the declaration with the\n+   parser attribute, only the $PGM parser will be generated.\n+\n+Bison-generated parsers are extremely fast compared to `kast`, but they have\n+some important limitations:\n+\n+* Bison parsers will always output kore. You can then pass the resulting AST\n+  directly to `llvm-krun` or `kore-exec` and bypass the `krun` frontend, making\n+  them very fast, but lower-level.\n+* Bison parsers do not yet support macros. This may change in a future release.\n+  Note that you can use anywhere rules instead of macros in most cases to get\n+  around this limitation, although they will not benefit from unparsing via the\n+  `alias` attribute.\n+* Obligation falls on the user to ensure that the grammar they write is LR(1)\n+  if they choose to use LR(1) parsing. If this does not happen, the parser\n+  generated will have shift/reduce or reduce/reduce conflicts and the parser\n+  may behave differently than `kast` would (`kast` is a GLL parser, ie, it\n+  is based on LL parsers and parses all unambiguous context-free grammars).\n+* If you are using LR(1) based parsing, the `prefer` and `avoid` attributes are\n+  ignored. It is only possible to implement these attributes by means of\n+  generalized LL or LR parsing and a postprocessing on the AST to remove the\n+  undesirable ambiguity.\n+* Obligation falls on the user to ensure that the grammar they write has as\n+  few conflicts as possible if they are using GLR parsing. Bison's GLR support\n+  is quite primitive, and in the worst case it can use exponential space and\n+  time to parse a program, which generally leads the generated parser to report\n+  \"memory exhausted\", indicating that the parse could not be completed within\n+  the stack space allocated by Bison. It's best to ensure that the grammar is \n+  as close to LR(1) as possible and only utilizes conflicts where absolutely\n+  necessary. One tool that can be used to facilitate this is to pass\n+  `--bison-lists` to kompile. This will disable support for the `List{Sort}`\n+  syntax production, and it will make `NeList{Sort}` left associative, but the\n+  resulting productions generated for NeList will be LR(1) and use bounded", "originalCommit": "4accfc905b235b08198b1e30e63215eefb281945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0c09d5e0f7a1bab6fc65efbbc46e07759265375f", "url": "https://github.com/kframework/k/commit/0c09d5e0f7a1bab6fc65efbbc46e07759265375f", "message": "pending-documentation: formatting", "committedDate": "2020-05-10T09:13:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYxNTMzNA==", "url": "https://github.com/kframework/k/pull/1259#discussion_r422615334", "bodyText": "I know we went over this, but if you can look again and see if this is re-usable in the places where we are doing this type of splitting, that would be good. I'm going to approve anyway.", "author": "ehildenb", "createdAt": "2020-05-10T09:13:48Z", "path": "kore/src/main/java/org/kframework/utils/StringUtil.java", "diffHunk": "@@ -822,4 +699,22 @@ public static String decodeKoreString(String encoded) {\n         }\n         return encoded;\n     }\n+\n+    public static String[] splitOneDimensionalAtt(String att) {\n+        String[] splitted = att.trim().split(\",\");\n+        for (int i = 0; i < splitted.length; i++) {\n+            splitted[i] = splitted[i].trim();\n+        }\n+        return splitted;\n+    }\n+\n+    public static String[][] splitTwoDimensionalAtt(String att) {", "originalCommit": "0c09d5e0f7a1bab6fc65efbbc46e07759265375f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d73b96a7635f12fb923ea6da94e4d5bd3b142c74", "url": "https://github.com/kframework/k/commit/d73b96a7635f12fb923ea6da94e4d5bd3b142c74", "message": "Merge branch 'master' into parser4", "committedDate": "2020-05-11T17:22:11Z", "type": "commit"}]}