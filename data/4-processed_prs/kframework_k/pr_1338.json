{"pr_number": 1338, "pr_title": "Replacement for krun", "pr_createdAt": "2020-06-12T17:54:33Z", "pr_url": "https://github.com/kframework/k/pull/1338", "timeline": [{"oid": "b89832b3e5f14103def3614b7210424268ff542e", "url": "https://github.com/kframework/k/commit/b89832b3e5f14103def3614b7210424268ff542e", "message": "fix bug in kast -o kore", "committedDate": "2020-06-22T18:57:01Z", "type": "commit"}, {"oid": "730a00f9d4c94e6b49aed5dac4902e8eaf04dccb", "url": "https://github.com/kframework/k/commit/730a00f9d4c94e6b49aed5dac4902e8eaf04dccb", "message": "fix issues with parsing K versus KItem", "committedDate": "2020-06-22T18:58:02Z", "type": "commit"}, {"oid": "e8d0335a1c2e6d3d93f2d21792c573e6f3053d6e", "url": "https://github.com/kframework/k/commit/e8d0335a1c2e6d3d93f2d21792c573e6f3053d6e", "message": "write necessary data to kompiled dir for kx to read", "committedDate": "2020-06-22T18:58:19Z", "type": "commit"}, {"oid": "5027b10af60fd2388f24071fad82479fb02a0e34", "url": "https://github.com/kframework/k/commit/5027b10af60fd2388f24071fad82479fb02a0e34", "message": "kx script", "committedDate": "2020-06-22T18:58:31Z", "type": "commit"}, {"oid": "39bb5c0bbfba15e82d4682392529ca8bf794d782", "url": "https://github.com/kframework/k/commit/39bb5c0bbfba15e82d4682392529ca8bf794d782", "message": "use kx script on llvm backend", "committedDate": "2020-06-22T18:58:36Z", "type": "commit"}, {"oid": "80417c26db96cf4046ddfeddbac5cf03f862bd25", "url": "https://github.com/kframework/k/commit/80417c26db96cf4046ddfeddbac5cf03f862bd25", "message": "expand macros in main module", "committedDate": "2020-06-22T19:46:48Z", "type": "commit"}, {"oid": "49ff3ef5558643ef5900851e56c3ff85861eeea9", "url": "https://github.com/kframework/k/commit/49ff3ef5558643ef5900851e56c3ff85861eeea9", "message": "update output file", "committedDate": "2020-06-22T20:19:33Z", "type": "commit"}, {"oid": "139a079e41f16f9043740634eab1f96e8ceb5cae", "url": "https://github.com/kframework/k/commit/139a079e41f16f9043740634eab1f96e8ceb5cae", "message": "fix test with invalid syntax production", "committedDate": "2020-06-22T20:19:40Z", "type": "commit"}, {"oid": "2d3e08dc7fc35ae0b7253019d566d527375e6cd1", "url": "https://github.com/kframework/k/commit/2d3e08dc7fc35ae0b7253019d566d527375e6cd1", "message": "don't use kx for krun-deserialize tests", "committedDate": "2020-06-22T20:19:49Z", "type": "commit"}, {"oid": "2d3e08dc7fc35ae0b7253019d566d527375e6cd1", "url": "https://github.com/kframework/k/commit/2d3e08dc7fc35ae0b7253019d566d527375e6cd1", "message": "don't use kx for krun-deserialize tests", "committedDate": "2020-06-22T20:19:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwNzYyNA==", "url": "https://github.com/kframework/k/pull/1338#discussion_r443807624", "bodyText": "I think we should set -eo pipefail at least, so any commands added in pipes also fail the script if they fail (instead of just the last command in the pipe).\nWe probably also should do set -euo pipefail, so that we fail on unitialized variables (and so changes to variables here must provide defaults), but that may be trickier.", "author": "ehildenb", "createdAt": "2020-06-22T20:29:33Z", "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,438 @@\n+#!/bin/bash\n+set -e", "originalCommit": "2d3e08dc7fc35ae0b7253019d566d527375e6cd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwODY2NQ==", "url": "https://github.com/kframework/k/pull/1338#discussion_r443808665", "bodyText": "Just a styling argument, any single-line if CONDITION; then COMMAND; fi can be rewritten as ! CONDITION || COMMAND. Up to you.", "author": "ehildenb", "createdAt": "2020-06-22T20:31:34Z", "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,438 @@\n+#!/bin/bash\n+set -e\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      -save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if $search; then\n+  io=false\n+fi\n+\n+if [[ \"${#ARGV[@]}\" -gt 1 ]]; then\n+  error 'Cannot pass more than one configuration variable as a positional argument.'\n+fi", "originalCommit": "2d3e08dc7fc35ae0b7253019d566d527375e6cd1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f02ce0b2964ab4c94cb236a78e6f2718aaa3581", "url": "https://github.com/kframework/k/commit/0f02ce0b2964ab4c94cb236a78e6f2718aaa3581", "message": "set -o pipefail", "committedDate": "2020-06-22T20:54:02Z", "type": "commit"}, {"oid": "88d2cbdd768994a7ce7ef342567d8653fb660da8", "url": "https://github.com/kframework/k/commit/88d2cbdd768994a7ce7ef342567d8653fb660da8", "message": "Merge branch 'master' into kx", "committedDate": "2020-06-23T16:26:42Z", "type": "commit"}, {"oid": "6ec8b4965d3d1d0158936aaf403d92a33c7ed55f", "url": "https://github.com/kframework/k/commit/6ec8b4965d3d1d0158936aaf403d92a33c7ed55f", "message": "review fixes", "committedDate": "2020-06-23T16:43:44Z", "type": "commit"}, {"oid": "2928398b686ae1cd10d29e34c198b7ad35959521", "url": "https://github.com/kframework/k/commit/2928398b686ae1cd10d29e34c198b7ad35959521", "message": "fix bug", "committedDate": "2020-06-23T17:06:33Z", "type": "commit"}, {"oid": "090bf614f2dbe44df9a8ff5e194778c01fc670ad", "url": "https://github.com/kframework/k/commit/090bf614f2dbe44df9a8ff5e194778c01fc670ad", "message": "fix bug", "committedDate": "2020-06-23T18:50:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzNDkzNw==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445634937", "bodyText": "This information isn't already saved somewhere else?", "author": "ehildenb", "createdAt": "2020-06-25T15:13:38Z", "path": "kernel/src/main/java/org/kframework/kompile/KompileFrontEnd.java", "diffHunk": "@@ -68,6 +68,7 @@ public int run() {\n         Kompile kompile = new Kompile(options, files.get(), kem, sw, !options.profileRules);\n         Backend backend = koreBackend.get();\n         CompiledDefinition def = kompile.run(options.outerParsing.mainDefinitionFile(files.get()), options.mainModule(files.get()), options.syntaxModule(files.get()), backend.steps(), backend.excludedModuleTags());\n+        files.get().saveToKompiled(\"mainModule.txt\", def.executionModule().name());\n         sw.printIntermediate(\"Kompile to kore\");", "originalCommit": "090bf614f2dbe44df9a8ff5e194778c01fc670ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY0NjU5Nw==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445646597", "bodyText": "It is not saved anywhere in any place that is convenient for a shell script to parse. Mostly the java code gets this information from the deserialized K definition, which we are not making use of in the new script.", "author": "dwightguth", "createdAt": "2020-06-25T15:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzNDkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY0OTI3Ng==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445649276", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  -save-temps          Do not delete temporary files when $KX terminates.\n          \n          \n            \n                  --save-temps         Do not delete temporary files when $KX terminates.", "author": "ehildenb", "createdAt": "2020-06-25T15:33:45Z", "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.", "originalCommit": "090bf614f2dbe44df9a8ff5e194778c01fc670ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MTA5OA==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445651098", "bodyText": "I don't see the definition of error anywhere...", "author": "ehildenb", "createdAt": "2020-06-25T15:36:30Z", "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'", "originalCommit": "090bf614f2dbe44df9a8ff5e194778c01fc670ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MjIyMg==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445652222", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  -save-temps)\n          \n          \n            \n                  trap - INT TERM EXIT\n          \n          \n            \n                  flags=\"$flags -save-temps\"\n          \n          \n            \n                  ;;\n          \n          \n            \n                  --save-temps)\n          \n          \n            \n                  trap - INT TERM EXIT\n          \n          \n            \n                  flags=\"$flags -save-temps\"\n          \n          \n            \n                  ;;\n          \n      \n    \n    \n  \n\nWhy do we have just a single dash here?", "author": "ehildenb", "createdAt": "2020-06-25T15:38:19Z", "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      -save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;", "originalCommit": "090bf614f2dbe44df9a8ff5e194778c01fc670ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "88b72a7be3d66878bc3c1f2717a5155f15129f2a", "url": "https://github.com/kframework/k/commit/88b72a7be3d66878bc3c1f2717a5155f15129f2a", "message": "Update k-distribution/src/main/scripts/bin/kx\n\nCo-authored-by: Everett Hildenbrandt <everett.hildenbrandt@gmail.com>", "committedDate": "2020-06-25T15:38:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MjU4Nw==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445652587", "bodyText": "It looks like flags is only intended to be for the llvm backend, maybe it should be named llvm_flags instead?", "author": "ehildenb", "createdAt": "2020-06-25T15:38:55Z", "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      -save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if $search; then\n+  io=false\n+fi\n+\n+if [[ \"${#ARGV[@]}\" -gt 1 ]]; then\n+  error 'Cannot pass more than one configuration variable as a positional argument.'\n+fi\n+\n+kompiledDir=\n+hasKompiledDir=false\n+for file in \"$dir\"/*-kompiled; do\n+  kompiledDir=$file\n+  if $hasKompiledDir; then\n+    error 'Multiple compiled definitions found in the current working directory: ' \"$dir\"/*-kompiled\n+  fi\n+  hasKompiledDir=true\n+done\n+\n+if ! $hasKompiledDir; then\n+  error 'Could not find a compiled definition. Use --directory to specify one.'\n+fi\n+\n+hasArgv=false\n+if [[ \"${#ARGV[@]}\" -gt 0 ]]; then\n+  config_var_PGM=\"${ARGV[0]}\"\n+  hasArgv=true\n+  params+=(\"PGM\")\n+fi\n+\n+mainModuleName=$(cat \"$kompiledDir\"/mainModule.txt)\n+\n+if [ \"$outputFile\" = \"-\" ]; then\n+  outputFile=/dev/stdout\n+fi\n+\n+if $term; then\n+  if [ -z \"${parser_PGM+unset}\" ]; then\n+    execute kast -m \"$mainModuleName\" \"$config_var_PGM\" -o kore > \"$input_file\"\n+  else\n+    execute $parser_PGM \"$config_var_PGM\" > \"$input_file\"\n+  fi\n+else\n+  for name in \"${params[@]}\"; do\n+    parser_name=\"parser_$name\"\n+    config_name=\"config_var_$name\"\n+    tempFile=\"$(mktemp tmp.in.\"$name\".XXXXXXXXXX)\"\n+    tempFiles+=(\"$tempFile\")\n+    sortName=`cat \"$kompiledDir\"/sort_\"$name\".txt`\n+    if [ -z \"${!parser_name+unset}\" ]; then\n+      if [ -f \"$kompiledDir/parser_$name\" ]; then\n+        parser=\"$kompiledDir/parser_$name\"\n+      elif [ \"$name\" = \"PGM\" ]; then\n+        if $hasArgv; then\n+          parser=\"kast -o kore\"\n+\telse\n+          parser=\"kast -m $mainModuleName -o kore\"\n+\tfi\n+      else\n+        parser=\"kast -m $mainModuleName -o kore\"\n+      fi\n+    else\n+      parser=\"${!parser_name}\"\n+    fi\n+    execute $parser \"${!config_name}\" > \"$tempFile\"\n+    configVars=\"$configVars -c $name $tempFile $sortName korefile\"\n+  done\n+  if [ \"$(cat \"$kompiledDir\"/sort_IO.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      ioText=on\n+    else\n+      ioText=off\n+    fi\n+    configVars=\"$configVars -c IO \\dv{SortString{}}(\\\"$ioText\\\") String kore\"\n+  fi\n+  if [ \"$(cat \"$kompiledDir\"/sort_STDIN.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      stdinText=\n+    else\n+      unescaped=$(</dev/stdin)\n+      stdinText=$(awk 'BEGIN {for(n=0;n<256;n++)ord[sprintf(\"%c\",n)]=n} {text = text $0 ORS} END {split(text, chars, \"\"); for (i=1; i<=length(text); i++) { if (chars[i] == \"\\\"\") { printf(\"%s\", \"\\\\\\\"\") } else if (chars[i] == \"\\\\\") { printf(\"%s\", \"\\\\\\\\\") } else if (chars[i] == \"\\n\") { printf(\"%s\", \"\\\\n\") } else if (chars[i] == \"\\t\") { printf(\"%s\", \"\\\\t\") } else if (chars[i] == \"\\r\") { printf(\"%s\", \"\\\\r\") } else if (chars[i] == \"\\f\") { printf(\"%s\", \"\\\\f\") } else if (ord[chars[i]] >= 32 && ord[chars[i]] < 127) { printf(\"%s\", chars[i]) } else { printf(\"\\\\x%02x\", ord[chars[i]]) } } }' <<< \"$unescaped\")\n+    fi\n+    stdinFile=\"$(mktemp tmp.stdin.XXXXXXXXXX)\"\n+    tempFiles+=(\"$stdinFile\")\n+    printf '\\dv{SortString{}}(\\\"%s\\\")\\n' \"$stdinText\" > \"$stdinFile\"\n+    configVars=\"$configVars -c STDIN $stdinFile String korefile\"\n+  fi\n+  execute llvm-krun $configVars -d \"$kompiledDir\" $flags --dry-run -o \"$input_file\"", "originalCommit": "090bf614f2dbe44df9a8ff5e194778c01fc670ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1Mzc1NA==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445653754", "bodyText": "Well, this code is going to be used by the haskell backend code path as well to construct the initial configuration, so I'm not sure that makes sense.", "author": "dwightguth", "createdAt": "2020-06-25T15:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MjU4Nw=="}], "type": "inlineReview"}, {"oid": "93d50dce28c3420f5279498b1699da6d70a4003d", "url": "https://github.com/kframework/k/commit/93d50dce28c3420f5279498b1699da6d70a4003d", "message": "Update k-distribution/src/main/scripts/bin/kx\n\nCo-authored-by: Everett Hildenbrandt <everett.hildenbrandt@gmail.com>", "committedDate": "2020-06-25T15:39:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MzQ0Ng==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445653446", "bodyText": "This should be more like:\nif $search && $io; then\n    error \"Cannot specify both --search* and --io on\"\nfi", "author": "ehildenb", "createdAt": "2020-06-25T15:40:10Z", "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      --save-temps         Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      -save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if $search; then\n+  io=false\n+fi\n+", "originalCommit": "88b72a7be3d66878bc3c1f2717a5155f15129f2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e880691069b3d90c7606281d649d3389e2eadb0", "url": "https://github.com/kframework/k/commit/4e880691069b3d90c7606281d649d3389e2eadb0", "message": "error function", "committedDate": "2020-06-25T15:43:52Z", "type": "commit"}, {"oid": "f5ffe62e0d608fecbc26fc6857c67683e75f8d05", "url": "https://github.com/kframework/k/commit/f5ffe62e0d608fecbc26fc6857c67683e75f8d05", "message": "fix overriding of io and color flags", "committedDate": "2020-06-25T15:46:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2OTIwMQ==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445669201", "bodyText": "Where is this coming from? Is this a heuristic or definitely correct?", "author": "ehildenb", "createdAt": "2020-06-25T16:03:31Z", "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,456 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+result=1\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+error () {\n+  printf \"%s\" \"[Error] Critical: \"\n+  echo \"$@\"\n+  exit $result\n+}\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      --save-temps         Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      --save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if [ -z \"${io+unset}\" ]; then\n+  if $search; then\n+    io=false\n+  else\n+    io=true\n+  fi\n+fi\n+\n+if [ -z \"${color+unset}\" ]; then\n+  if [[ \"$outputFile\" == \"-\" && -t 1 ]]; then\n+    color=true\n+  else\n+    color=false\n+  fi\n+fi\n+\n+if [[ \"${#ARGV[@]}\" -gt 1 ]]; then\n+  error 'Cannot pass more than one configuration variable as a positional argument.'\n+fi\n+\n+kompiledDir=\n+hasKompiledDir=false\n+for file in \"$dir\"/*-kompiled; do\n+  kompiledDir=$file\n+  if $hasKompiledDir; then\n+    error 'Multiple compiled definitions found in the current working directory: ' \"$dir\"/*-kompiled\n+  fi\n+  hasKompiledDir=true\n+done\n+\n+if ! $hasKompiledDir; then\n+  error 'Could not find a compiled definition. Use --directory to specify one.'\n+fi\n+\n+hasArgv=false\n+if [[ \"${#ARGV[@]}\" -gt 0 ]]; then\n+  config_var_PGM=\"${ARGV[0]}\"\n+  hasArgv=true\n+  params+=(\"PGM\")\n+fi\n+\n+mainModuleName=$(cat \"$kompiledDir\"/mainModule.txt)\n+\n+if [ \"$outputFile\" = \"-\" ]; then\n+  outputFile=/dev/stdout\n+fi\n+\n+if $term; then\n+  if [ -z \"${parser_PGM+unset}\" ]; then\n+    execute kast -m \"$mainModuleName\" \"$config_var_PGM\" -o kore > \"$input_file\"\n+  else\n+    execute $parser_PGM \"$config_var_PGM\" > \"$input_file\"\n+  fi\n+else\n+  for name in \"${params[@]}\"; do\n+    parser_name=\"parser_$name\"\n+    config_name=\"config_var_$name\"\n+    tempFile=\"$(mktemp tmp.in.\"$name\".XXXXXXXXXX)\"\n+    tempFiles+=(\"$tempFile\")\n+    sortName=`cat \"$kompiledDir\"/sort_\"$name\".txt`\n+    if [ -z \"${!parser_name+unset}\" ]; then\n+      if [ -f \"$kompiledDir/parser_$name\" ]; then\n+        parser=\"$kompiledDir/parser_$name\"\n+      elif [ \"$name\" = \"PGM\" ]; then\n+        if $hasArgv; then\n+          parser=\"kast -o kore\"\n+\telse\n+          parser=\"kast -m $mainModuleName -o kore\"\n+\tfi\n+      else\n+        parser=\"kast -m $mainModuleName -o kore\"\n+      fi\n+    else\n+      parser=\"${!parser_name}\"\n+    fi\n+    execute $parser \"${!config_name}\" > \"$tempFile\"\n+    configVars=\"$configVars -c $name $tempFile $sortName korefile\"\n+  done\n+  if [ \"$(cat \"$kompiledDir\"/sort_IO.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      ioText=on\n+    else\n+      ioText=off\n+    fi\n+    configVars=\"$configVars -c IO \\dv{SortString{}}(\\\"$ioText\\\") String kore\"\n+  fi\n+  if [ \"$(cat \"$kompiledDir\"/sort_STDIN.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      stdinText=\n+    else\n+      unescaped=$(</dev/stdin)\n+      stdinText=$(awk 'BEGIN {for(n=0;n<256;n++)ord[sprintf(\"%c\",n)]=n} {text = text $0 ORS} END {split(text, chars, \"\"); for (i=1; i<=length(text); i++) { if (chars[i] == \"\\\"\") { printf(\"%s\", \"\\\\\\\"\") } else if (chars[i] == \"\\\\\") { printf(\"%s\", \"\\\\\\\\\") } else if (chars[i] == \"\\n\") { printf(\"%s\", \"\\\\n\") } else if (chars[i] == \"\\t\") { printf(\"%s\", \"\\\\t\") } else if (chars[i] == \"\\r\") { printf(\"%s\", \"\\\\r\") } else if (chars[i] == \"\\f\") { printf(\"%s\", \"\\\\f\") } else if (ord[chars[i]] >= 32 && ord[chars[i]] < 127) { printf(\"%s\", chars[i]) } else { printf(\"\\\\x%02x\", ord[chars[i]]) } } }' <<< \"$unescaped\")", "originalCommit": "f5ffe62e0d608fecbc26fc6857c67683e75f8d05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0MDI2Mg==", "url": "https://github.com/kframework/k/pull/1338#discussion_r445740262", "bodyText": "This is the awk script to escape an ascii string into a K string literal.", "author": "dwightguth", "createdAt": "2020-06-25T18:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2OTIwMQ=="}], "type": "inlineReview"}, {"oid": "cbeaf4b6e15243a3917675c4591ef1b9da323d49", "url": "https://github.com/kframework/k/commit/cbeaf4b6e15243a3917675c4591ef1b9da323d49", "message": "formatting", "committedDate": "2020-06-26T17:46:54Z", "type": "commit"}, {"oid": "71a7780c81ae227a106fdff4e1b003892a7480f7", "url": "https://github.com/kframework/k/commit/71a7780c81ae227a106fdff4e1b003892a7480f7", "message": "Merge branch 'master' into kx", "committedDate": "2020-06-26T21:51:09Z", "type": "commit"}]}