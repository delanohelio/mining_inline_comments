{"pr_number": 1440, "pr_title": "Migrate ffi.k to ffi.md", "pr_createdAt": "2020-07-17T18:47:46Z", "pr_url": "https://github.com/kframework/k/pull/1440", "timeline": [{"oid": "0b5dc0961c376f904a69c85d0288da07930edb64", "url": "https://github.com/kframework/k/commit/0b5dc0961c376f904a69c85d0288da07930edb64", "message": "remove unused files", "committedDate": "2020-07-17T17:57:25Z", "type": "commit"}, {"oid": "73d1d99080b4c0511fff9bb45b9f80c01a50ba32", "url": "https://github.com/kframework/k/commit/73d1d99080b4c0511fff9bb45b9f80c01a50ba32", "message": "rename ffi.k to ffi.md and add documentation", "committedDate": "2020-07-17T18:33:02Z", "type": "commit"}, {"oid": "abb52279635f617bce835a8b1e200b56ffa5c99a", "url": "https://github.com/kframework/k/commit/abb52279635f617bce835a8b1e200b56ffa5c99a", "message": "update requires statements referencing ffi.k", "committedDate": "2020-07-17T18:33:14Z", "type": "commit"}, {"oid": "2225d72f63f662b2ca93a2f3298c81feb414fcd8", "url": "https://github.com/kframework/k/commit/2225d72f63f662b2ca93a2f3298c81feb414fcd8", "message": "move builtin directories before other directories in include path", "committedDate": "2020-07-17T18:42:29Z", "type": "commit"}, {"oid": "e63d596312035d021fc56814afeb7359c3dea9c6", "url": "https://github.com/kframework/k/commit/e63d596312035d021fc56814afeb7359c3dea9c6", "message": "add warning for deprecated filename", "committedDate": "2020-07-17T18:46:00Z", "type": "commit"}, {"oid": "2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0", "url": "https://github.com/kframework/k/commit/2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0", "message": "add test", "committedDate": "2020-07-17T18:46:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0OTg5NQ==", "url": "https://github.com/kframework/k/pull/1440#discussion_r456649895", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```k\n          \n          \n            \n                             | \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]\n          \n          \n            \n            ```\n          \n          \n            \n            ```k\n          \n          \n            \n              syntax Bytes ::= \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]", "author": "ehildenb", "createdAt": "2020-07-17T20:05:12Z", "path": "k-distribution/include/kframework/builtin/ffi.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+permalink: ffi.html\n+copyright: Copyright (c) 2019-2020 K Team. All Rights Reserved.\n+---\n+\n+K Foreign Function Interface\n+============================\n+\n+The K Foreign Function Interface (FFI) module provides a way to call native\n+functions directly from a K semantics using the C ABI. It also provides\n+utilities for allocating and deallocating byte buffers with static addresses\n+that are suitable for being passed to native code.\n+\n+It is built off of the underlying libffi library\n+(https://sourceware.org/libffi/) and is subject to some of the same\n+limitations as that library. Bear in mind, because this library exposes\n+a number of unsafe C APIs directly, misuse of the library is likely to lead\n+to memory corruption in your interpreter and can cause segmentation faults or\n+corrupted term representations that lead to undefined behavior at runtime.\n+\n+```k\n+require \"domains.k\"\n+\n+module FFI-SYNTAX\n+  imports LIST\n+```\n+\n+The FFIType sort is used to declare the native C ABI types of operands passed\n+to the `#ffiCall` function. These types roughly correspond to the types \n+declared in `ffi.h` by libffi.\n+\n+```k\n+  syntax FFIType ::= \"#void\" [klabel(#void), symbol]\n+                  | \"#uint8\" [klabel(#uint8), symbol]\n+                  | \"#sint8\" [klabel(#sint8), symbol]\n+                  | \"#uint16\" [klabel(#uint16), symbol]\n+                  | \"#sint16\" [klabel(#sint16), symbol]\n+                  | \"#uint32\" [klabel(#uint32), symbol]\n+                  | \"#sint32\" [klabel(#sint32), symbol]\n+                  | \"#uint64\" [klabel(#uint64), symbol]\n+                  | \"#sint64\" [klabel(#sint64), symbol]\n+                  | \"#float\" [klabel(#float), symbol]\n+                  | \"#double\" [klabel(#double), symbol]\n+                  | \"#uchar\" [klabel(#uchar), symbol]\n+                  | \"#schar\" [klabel(#schar), symbol]\n+                  | \"#ushort\" [klabel(#ushort), symbol]\n+                  | \"#sshort\" [klabel(#sshort), symbol]\n+                  | \"#uint\" [klabel(#uint), symbol]\n+                  | \"#sint\" [klabel(#sint), symbol]\n+                  | \"#ulong\" [klabel(#ulong), symbol]\n+                  | \"#slong\" [klabel(#slong), symbol]\n+                  | \"#longdouble\" [klabel(#longdouble), symbol]\n+                  | \"#struct\" \"(\" List \")\" [klabel(#struct), symbol]\n+endmodule\n+\n+module FFI\n+  imports FFI-SYNTAX\n+  imports BYTES\n+  imports STRING\n+\n+```\n+\n+FFI Calls\n+---------\n+\n+The `#ffiCall` functions are designed to call a native C ABI function and \n+return a native result. They come in three variants:\n+\n+### Non-variadic\n+\n+In the first variant, `#ffiCall(Address, Args, ArgTypes, ReturnType)` takes\n+an integer address of a function (which can be obtained from\n+`#functionAddress`), a `List` of `Bytes` containing the arguments of the\n+function, a `List` of `FFIType`s containing the types of the parameters of the\n+function, and an `FFIType` containing the return type of the function, and \n+returns the return value of the function as a `Bytes`.\n+\n+```k\n+  syntax Bytes ::= \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call)]\n+```\n+\n+### Variadic\n+\n+In the second variant,\n+`#ffiCall(Address, Args, FixedTypes, VariadicTypes, ReturnType` takes an\n+integer address of a function, a `List` of `Bytes` containing the arguments\n+of the call, a `List` of `FFIType`s containing the types of the fixed\n+parameters of the function, a `List` of `FFIType`s containing the types of the\n+variadic parameters of the function, and an `FFIType` containing the return\n+type of the function, and returns the return value of the function as a\n+`Bytes`.\n+\n+```k\n+                 | \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]\n+```", "originalCommit": "2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MDA1Mw==", "url": "https://github.com/kframework/k/pull/1440#discussion_r456650053", "bodyText": "Otherwise it's confusing and you're not able to copy-paste this code block around to other locatiions.", "author": "ehildenb", "createdAt": "2020-07-17T20:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0OTg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MDE2MA==", "url": "https://github.com/kframework/k/pull/1440#discussion_r456650160", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                             | \"#ffiCall\" \"(\" Bool \",\" Int \",\" List \",\" List \",\" Int \",\" FFIType \")\" [function]\n          \n          \n            \n              syntax Bytes ::= \"#ffiCall\" \"(\" Bool \",\" Int \",\" List \",\" List \",\" Int \",\" FFIType \")\" [function]", "author": "ehildenb", "createdAt": "2020-07-17T20:05:50Z", "path": "k-distribution/include/kframework/builtin/ffi.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+permalink: ffi.html\n+copyright: Copyright (c) 2019-2020 K Team. All Rights Reserved.\n+---\n+\n+K Foreign Function Interface\n+============================\n+\n+The K Foreign Function Interface (FFI) module provides a way to call native\n+functions directly from a K semantics using the C ABI. It also provides\n+utilities for allocating and deallocating byte buffers with static addresses\n+that are suitable for being passed to native code.\n+\n+It is built off of the underlying libffi library\n+(https://sourceware.org/libffi/) and is subject to some of the same\n+limitations as that library. Bear in mind, because this library exposes\n+a number of unsafe C APIs directly, misuse of the library is likely to lead\n+to memory corruption in your interpreter and can cause segmentation faults or\n+corrupted term representations that lead to undefined behavior at runtime.\n+\n+```k\n+require \"domains.k\"\n+\n+module FFI-SYNTAX\n+  imports LIST\n+```\n+\n+The FFIType sort is used to declare the native C ABI types of operands passed\n+to the `#ffiCall` function. These types roughly correspond to the types \n+declared in `ffi.h` by libffi.\n+\n+```k\n+  syntax FFIType ::= \"#void\" [klabel(#void), symbol]\n+                  | \"#uint8\" [klabel(#uint8), symbol]\n+                  | \"#sint8\" [klabel(#sint8), symbol]\n+                  | \"#uint16\" [klabel(#uint16), symbol]\n+                  | \"#sint16\" [klabel(#sint16), symbol]\n+                  | \"#uint32\" [klabel(#uint32), symbol]\n+                  | \"#sint32\" [klabel(#sint32), symbol]\n+                  | \"#uint64\" [klabel(#uint64), symbol]\n+                  | \"#sint64\" [klabel(#sint64), symbol]\n+                  | \"#float\" [klabel(#float), symbol]\n+                  | \"#double\" [klabel(#double), symbol]\n+                  | \"#uchar\" [klabel(#uchar), symbol]\n+                  | \"#schar\" [klabel(#schar), symbol]\n+                  | \"#ushort\" [klabel(#ushort), symbol]\n+                  | \"#sshort\" [klabel(#sshort), symbol]\n+                  | \"#uint\" [klabel(#uint), symbol]\n+                  | \"#sint\" [klabel(#sint), symbol]\n+                  | \"#ulong\" [klabel(#ulong), symbol]\n+                  | \"#slong\" [klabel(#slong), symbol]\n+                  | \"#longdouble\" [klabel(#longdouble), symbol]\n+                  | \"#struct\" \"(\" List \")\" [klabel(#struct), symbol]\n+endmodule\n+\n+module FFI\n+  imports FFI-SYNTAX\n+  imports BYTES\n+  imports STRING\n+\n+```\n+\n+FFI Calls\n+---------\n+\n+The `#ffiCall` functions are designed to call a native C ABI function and \n+return a native result. They come in three variants:\n+\n+### Non-variadic\n+\n+In the first variant, `#ffiCall(Address, Args, ArgTypes, ReturnType)` takes\n+an integer address of a function (which can be obtained from\n+`#functionAddress`), a `List` of `Bytes` containing the arguments of the\n+function, a `List` of `FFIType`s containing the types of the parameters of the\n+function, and an `FFIType` containing the return type of the function, and \n+returns the return value of the function as a `Bytes`.\n+\n+```k\n+  syntax Bytes ::= \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call)]\n+```\n+\n+### Variadic\n+\n+In the second variant,\n+`#ffiCall(Address, Args, FixedTypes, VariadicTypes, ReturnType` takes an\n+integer address of a function, a `List` of `Bytes` containing the arguments\n+of the call, a `List` of `FFIType`s containing the types of the fixed\n+parameters of the function, a `List` of `FFIType`s containing the types of the\n+variadic parameters of the function, and an `FFIType` containing the return\n+type of the function, and returns the return value of the function as a\n+`Bytes`.\n+\n+```k\n+                 | \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]\n+```\n+\n+### Generic\n+\n+In the third variant,\n+`#ffiCall(IsVariadic, Address, Args, ArgTypes, NFixed, ReturnType` takes\n+a boolean indicating whether the function is variadic or not, an integer\n+address of a function, a `List` of `Bytes` containing the arguments of the\n+call, a `List` of `FFIType`s containing the parameter typess of the call\n+followed by the types of the variadic arguments of the call, if any, an `Int`\n+containing how many of the arguments of the call are fixed or not, and an\n+`FFIType` containing the return type of the function, and returns the return\n+value of the function as a `Bytes`.\n+\n+```k\n+                 | \"#ffiCall\" \"(\" Bool \",\" Int \",\" List \",\" List \",\" Int \",\" FFIType \")\" [function]\n+", "originalCommit": "2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MDQ4MA==", "url": "https://github.com/kframework/k/pull/1440#discussion_r456650480", "bodyText": "Another option would be to just declare all three together, with the documentation above all together.", "author": "ehildenb", "createdAt": "2020-07-17T20:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MDE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MTA2MA==", "url": "https://github.com/kframework/k/pull/1440#discussion_r456651060", "bodyText": "This looks like a typo in the name of this variable allLookupDirectoris => allLookupDirectories\nWhat is this change? The 0 => 1.", "author": "ehildenb", "createdAt": "2020-07-17T20:07:53Z", "path": "kernel/src/main/java/org/kframework/parser/ParserUtils.java", "diffHunk": "@@ -155,8 +155,15 @@ else if (di instanceof Require) {\n \n                 String definitionFileName = ((Require) di).getValue();\n \n+                if (definitionFileName.equals(\"ffi.k\")) {\n+                    kem.registerCompilerWarning(ExceptionType.FUTURE_ERROR,\n+                        \"Requiring a K file in the K builtin directory via \" +\n+                        \"a deprecated filename. Please replace \\\"\" + definitionFileName +\n+                        \"\\\" with \\\"\" + definitionFileName.substring(0, definitionFileName.length() - 2) + \".md\\\".\", di);\n+                }\n+\n                 ArrayList<File> allLookupDirectoris = new ArrayList<>(lookupDirectories);\n-                allLookupDirectoris.add(0, currentDirectory);\n+                allLookupDirectoris.add(1, currentDirectory);", "originalCommit": "2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb1d937a429d4bdffe8bc45bf26446caa8edb618", "url": "https://github.com/kframework/k/commit/fb1d937a429d4bdffe8bc45bf26446caa8edb618", "message": "fix typo and add comment", "committedDate": "2020-07-17T20:22:54Z", "type": "commit"}, {"oid": "b7d440518042843325274ada03b0e80fd0daf45b", "url": "https://github.com/kframework/k/commit/b7d440518042843325274ada03b0e80fd0daf45b", "message": "fix blocks", "committedDate": "2020-07-17T20:39:04Z", "type": "commit"}, {"oid": "97f152d50fb0995c2a609addb28b9c50cd7cab33", "url": "https://github.com/kframework/k/commit/97f152d50fb0995c2a609addb28b9c50cd7cab33", "message": "Merge branch 'master' into prelude2", "committedDate": "2020-07-17T21:50:55Z", "type": "commit"}]}