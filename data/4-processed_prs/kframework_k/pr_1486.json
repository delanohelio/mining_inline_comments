{"pr_number": 1486, "pr_title": "Simple md", "pr_createdAt": "2020-08-04T21:08:21Z", "pr_url": "https://github.com/kframework/k/pull/1486", "timeline": [{"oid": "615bb73ce5becab71e748a1acd6bdeb676dbcb40", "url": "https://github.com/kframework/k/commit/615bb73ce5becab71e748a1acd6bdeb676dbcb40", "message": "Rename simple-untyped to md", "committedDate": "2020-08-04T21:04:29Z", "type": "commit"}, {"oid": "ddc4ff9a16ec0fb7b94c5be056afe81136bb9c86", "url": "https://github.com/kframework/k/commit/ddc4ff9a16ec0fb7b94c5be056afe81136bb9c86", "message": "Converting simple-untpyed to md", "committedDate": "2020-08-04T21:04:42Z", "type": "commit"}, {"oid": "6d55808134ea97c494e26e2ba43636e03e7ba4c8", "url": "https://github.com/kframework/k/commit/6d55808134ea97c494e26e2ba43636e03e7ba4c8", "message": "Rename simple-typed-static to md", "committedDate": "2020-08-04T21:04:50Z", "type": "commit"}, {"oid": "71fb1df39167547bd92a16b73693191e67bef961", "url": "https://github.com/kframework/k/commit/71fb1df39167547bd92a16b73693191e67bef961", "message": "Convert simple-typed-static to md", "committedDate": "2020-08-04T21:05:00Z", "type": "commit"}, {"oid": "76f1053ff9f030d2dbc8113757ec01e4c2b7a781", "url": "https://github.com/kframework/k/commit/76f1053ff9f030d2dbc8113757ec01e4c2b7a781", "message": "Rename simple-typed-dynamic to md", "committedDate": "2020-08-04T21:05:07Z", "type": "commit"}, {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576", "url": "https://github.com/kframework/k/commit/2992ff851da565dedcd5bbf4fea46de749b0e576", "message": "Convert simple-typed-dynamic to md", "committedDate": "2020-08-04T21:05:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzE0Mg==", "url": "https://github.com/kframework/k/pull/1486#discussion_r466503142", "bodyText": "This information can go in the markdown YAML header above (where the copyright is). Your choice, but that makes it more scrape-able.", "author": "ehildenb", "createdAt": "2020-08-06T15:38:03Z", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest", "originalCommit": "2992ff851da565dedcd5bbf4fea46de749b0e576", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUyOTg1MA==", "url": "https://github.com/kframework/k/pull/1486#discussion_r466529850", "bodyText": "I like the idea. Do you have a specific format in mind? Because I can't seem to find a configuration that I like. Apparently I can't put two values for the same tag.", "author": "radumereuta", "createdAt": "2020-08-06T16:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzM2OQ==", "url": "https://github.com/kframework/k/pull/1486#discussion_r466503369", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            ### Abstract\n          \n          \n            \n            This is the **K** semantic definition of the untyped SIMPLE language.\n          \n          \n            \n            ### Abstract\n          \n          \n            \n            \n          \n          \n            \n            This is the **K** semantic definition of the untyped SIMPLE language.\n          \n      \n    \n    \n  \n\nBlank lines after headers are more readable.", "author": "ehildenb", "createdAt": "2020-08-06T15:38:23Z", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.", "originalCommit": "2992ff851da565dedcd5bbf4fea46de749b0e576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzczOA==", "url": "https://github.com/kframework/k/pull/1486#discussion_r466503738", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Syntax\n          \n          \n            \n            We start by defining the SIMPLE syntax.  The language constructs discussed\n          \n          \n            \n            ### Syntax\n          \n          \n            \n            \n          \n          \n            \n            We start by defining the SIMPLE syntax.  The language constructs discussed", "author": "ehildenb", "createdAt": "2020-08-06T15:38:52Z", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.\n-\\item Functions and function values.  Functions can have zero or\n-more parameters and can return abruptly using a \\texttt{return} statement.\n+\n+* Functions and function values.  Functions can have zero or\n+more parameters and can return abruptly using a `return` statement.\n SIMPLE follows a call-by-value parameter passing style, with static scoping.\n Function names evaluate to function abstractions, which hereby become ordinary\n values in the language, same like the array references.\n-\\item Blocks with locals.  SIMPLE variables can be declared\n+\n+* Blocks with locals.  SIMPLE variables can be declared\n anywhere, their scope being from the place where they are declared\n until the end of the most nested enclosing block.\n-\\item Input/Output.  The expression \\texttt{read()} evaluates to the\n-next value in the input buffer, and the statement \\texttt{write(e)}\n-evaluates \\texttt{e} and outputs its value to the output buffer.  The\n+\n+* Input/Output.  The expression `read()` evaluates to the\n+next value in the input buffer, and the statement `write(e)`\n+evaluates `e` and outputs its value to the output buffer.  The\n input and output buffers are lists of values.\n-\\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n+\n+* Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n an exception can be caught and bound).\n-\\item Concurrency via dynamic thread creation/termination and\n+\n+* Concurrency via dynamic thread creation/termination and\n synchronization.  One can spawn a thread to execute any statement.\n The spawned thread shares with its parent its environment at creation time.\n Threads can be synchronized via a join command which blocks the current thread\n until the joined thread completes, via re-entrant locks which can be acquired\n and released, as well as through rendezvous commands.\n-\\end{itemize}\n+\n+\n Like in many other languages, some of SIMPLE's constructs can be\n desugared into a smaller set of basic constructs.  We do that at the end\n of the syntax module, and then we only give semantics to the core constructs.\n \n-\\paragraph{Note:}{\n-This definition is commented slightly more than others, because it is\n+__Note__: This definition is commented slightly more than others, because it is\n intended to be one of the first non-trivial definitions that the new\n-user of \\K sees.  We recommend the beginner user to first check the\n-language definitions discussed in the \\K tutorial.} */\n+user of **K** sees.  We recommend the beginner user to first check the\n+language definitions discussed in the **K** tutorial.\n \n+```k\n module SIMPLE-UNTYPED-SYNTAX\n   imports DOMAINS-SYNTAX\n+```\n \n-/*@ \\section{Syntax}\n+### Syntax\n We start by defining the SIMPLE syntax.  The language constructs discussed", "originalCommit": "2992ff851da565dedcd5bbf4fea46de749b0e576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzg2NQ==", "url": "https://github.com/kframework/k/pull/1486#discussion_r466503865", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Identifiers\n          \n          \n            \n            Recall from the **K** tutorial that identifiers are builtin and come under the\n          \n          \n            \n            ### Identifiers\n          \n          \n            \n            \n          \n          \n            \n            Recall from the **K** tutorial that identifiers are builtin and come under the", "author": "ehildenb", "createdAt": "2020-08-06T15:39:03Z", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.\n-\\item Functions and function values.  Functions can have zero or\n-more parameters and can return abruptly using a \\texttt{return} statement.\n+\n+* Functions and function values.  Functions can have zero or\n+more parameters and can return abruptly using a `return` statement.\n SIMPLE follows a call-by-value parameter passing style, with static scoping.\n Function names evaluate to function abstractions, which hereby become ordinary\n values in the language, same like the array references.\n-\\item Blocks with locals.  SIMPLE variables can be declared\n+\n+* Blocks with locals.  SIMPLE variables can be declared\n anywhere, their scope being from the place where they are declared\n until the end of the most nested enclosing block.\n-\\item Input/Output.  The expression \\texttt{read()} evaluates to the\n-next value in the input buffer, and the statement \\texttt{write(e)}\n-evaluates \\texttt{e} and outputs its value to the output buffer.  The\n+\n+* Input/Output.  The expression `read()` evaluates to the\n+next value in the input buffer, and the statement `write(e)`\n+evaluates `e` and outputs its value to the output buffer.  The\n input and output buffers are lists of values.\n-\\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n+\n+* Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n an exception can be caught and bound).\n-\\item Concurrency via dynamic thread creation/termination and\n+\n+* Concurrency via dynamic thread creation/termination and\n synchronization.  One can spawn a thread to execute any statement.\n The spawned thread shares with its parent its environment at creation time.\n Threads can be synchronized via a join command which blocks the current thread\n until the joined thread completes, via re-entrant locks which can be acquired\n and released, as well as through rendezvous commands.\n-\\end{itemize}\n+\n+\n Like in many other languages, some of SIMPLE's constructs can be\n desugared into a smaller set of basic constructs.  We do that at the end\n of the syntax module, and then we only give semantics to the core constructs.\n \n-\\paragraph{Note:}{\n-This definition is commented slightly more than others, because it is\n+__Note__: This definition is commented slightly more than others, because it is\n intended to be one of the first non-trivial definitions that the new\n-user of \\K sees.  We recommend the beginner user to first check the\n-language definitions discussed in the \\K tutorial.} */\n+user of **K** sees.  We recommend the beginner user to first check the\n+language definitions discussed in the **K** tutorial.\n \n+```k\n module SIMPLE-UNTYPED-SYNTAX\n   imports DOMAINS-SYNTAX\n+```\n \n-/*@ \\section{Syntax}\n+### Syntax\n We start by defining the SIMPLE syntax.  The language constructs discussed\n-above have the expected syntax and evaluation strategies.  Recall that in \\K\n+above have the expected syntax and evaluation strategies.  Recall that in **K**\n we annotate the syntax with appropriate strictness attributes, thus giving\n-each language construct the desired evaluation strategy. */\n+each language construct the desired evaluation strategy.\n \n-/*@ \\subsection{Identifiers}\n-Recall from the \\K tutorial that identifiers are builtin and come under the\n-syntactic category \\textit{Id}.  The special identifier for the function\n-``main'' belongs to all programs, and plays a special role in the semantics,\n+### Identifiers\n+Recall from the **K** tutorial that identifiers are builtin and come under the", "originalCommit": "2992ff851da565dedcd5bbf4fea46de749b0e576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNDEwMw==", "url": "https://github.com/kframework/k/pull/1486#discussion_r466504103", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Declarations\n          \n          \n            \n            There are two types of declarations: for variables (including arrays) and\n          \n          \n            \n            ### Declarations\n          \n          \n            \n            \n          \n          \n            \n            There are two types of declarations: for variables (including arrays) and\n          \n      \n    \n    \n  \n\nI'm going to stop marking this, but please fix them all.", "author": "ehildenb", "createdAt": "2020-08-06T15:39:21Z", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.\n-\\item Functions and function values.  Functions can have zero or\n-more parameters and can return abruptly using a \\texttt{return} statement.\n+\n+* Functions and function values.  Functions can have zero or\n+more parameters and can return abruptly using a `return` statement.\n SIMPLE follows a call-by-value parameter passing style, with static scoping.\n Function names evaluate to function abstractions, which hereby become ordinary\n values in the language, same like the array references.\n-\\item Blocks with locals.  SIMPLE variables can be declared\n+\n+* Blocks with locals.  SIMPLE variables can be declared\n anywhere, their scope being from the place where they are declared\n until the end of the most nested enclosing block.\n-\\item Input/Output.  The expression \\texttt{read()} evaluates to the\n-next value in the input buffer, and the statement \\texttt{write(e)}\n-evaluates \\texttt{e} and outputs its value to the output buffer.  The\n+\n+* Input/Output.  The expression `read()` evaluates to the\n+next value in the input buffer, and the statement `write(e)`\n+evaluates `e` and outputs its value to the output buffer.  The\n input and output buffers are lists of values.\n-\\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n+\n+* Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n an exception can be caught and bound).\n-\\item Concurrency via dynamic thread creation/termination and\n+\n+* Concurrency via dynamic thread creation/termination and\n synchronization.  One can spawn a thread to execute any statement.\n The spawned thread shares with its parent its environment at creation time.\n Threads can be synchronized via a join command which blocks the current thread\n until the joined thread completes, via re-entrant locks which can be acquired\n and released, as well as through rendezvous commands.\n-\\end{itemize}\n+\n+\n Like in many other languages, some of SIMPLE's constructs can be\n desugared into a smaller set of basic constructs.  We do that at the end\n of the syntax module, and then we only give semantics to the core constructs.\n \n-\\paragraph{Note:}{\n-This definition is commented slightly more than others, because it is\n+__Note__: This definition is commented slightly more than others, because it is\n intended to be one of the first non-trivial definitions that the new\n-user of \\K sees.  We recommend the beginner user to first check the\n-language definitions discussed in the \\K tutorial.} */\n+user of **K** sees.  We recommend the beginner user to first check the\n+language definitions discussed in the **K** tutorial.\n \n+```k\n module SIMPLE-UNTYPED-SYNTAX\n   imports DOMAINS-SYNTAX\n+```\n \n-/*@ \\section{Syntax}\n+### Syntax\n We start by defining the SIMPLE syntax.  The language constructs discussed\n-above have the expected syntax and evaluation strategies.  Recall that in \\K\n+above have the expected syntax and evaluation strategies.  Recall that in **K**\n we annotate the syntax with appropriate strictness attributes, thus giving\n-each language construct the desired evaluation strategy. */\n+each language construct the desired evaluation strategy.\n \n-/*@ \\subsection{Identifiers}\n-Recall from the \\K tutorial that identifiers are builtin and come under the\n-syntactic category \\textit{Id}.  The special identifier for the function\n-``main'' belongs to all programs, and plays a special role in the semantics,\n+### Identifiers\n+Recall from the **K** tutorial that identifiers are builtin and come under the\n+syntactic category `Id`.  The special identifier for the function\n+`main` belongs to all programs, and plays a special role in the semantics,\n so we declare it explicitly.  This would not be necessary if the identifiers\n were all included automatically in semantic definitions, but that is not\n-possible because of parsing reasons (e.g., \\K variables used to match\n+possible because of parsing reasons (e.g., **K** variables used to match\n concrete identifiers would then be ambiguously parsed as identifiers).  They\n are only included in the parser generated to parse programs (and used by the\n-\\texttt{kast} tool).  Consequently, we have to explicitly declare all the\n+`kast` tool).  Consequently, we have to explicitly declare all the\n concrete identifiers that play a special role in the semantics, like\n-\\texttt{main} below. */\n+`main` below.\n \n+```k\n   syntax Id ::= \"main\" [token]\n+```\n \n-/*@ \\subsection{Declarations}\n+### Declarations\n There are two types of declarations: for variables (including arrays) and", "originalCommit": "2992ff851da565dedcd5bbf4fea46de749b0e576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNDM4Mg==", "url": "https://github.com/kframework/k/pull/1486#discussion_r466504382", "bodyText": "Blank lines after codeblocks too please\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```\n          \n          \n            \n            ### Expressions\n          \n          \n            \n            ```\n          \n          \n            \n            \n          \n          \n            \n            ### Expressions", "author": "ehildenb", "createdAt": "2020-08-06T15:39:42Z", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.\n-\\item Functions and function values.  Functions can have zero or\n-more parameters and can return abruptly using a \\texttt{return} statement.\n+\n+* Functions and function values.  Functions can have zero or\n+more parameters and can return abruptly using a `return` statement.\n SIMPLE follows a call-by-value parameter passing style, with static scoping.\n Function names evaluate to function abstractions, which hereby become ordinary\n values in the language, same like the array references.\n-\\item Blocks with locals.  SIMPLE variables can be declared\n+\n+* Blocks with locals.  SIMPLE variables can be declared\n anywhere, their scope being from the place where they are declared\n until the end of the most nested enclosing block.\n-\\item Input/Output.  The expression \\texttt{read()} evaluates to the\n-next value in the input buffer, and the statement \\texttt{write(e)}\n-evaluates \\texttt{e} and outputs its value to the output buffer.  The\n+\n+* Input/Output.  The expression `read()` evaluates to the\n+next value in the input buffer, and the statement `write(e)`\n+evaluates `e` and outputs its value to the output buffer.  The\n input and output buffers are lists of values.\n-\\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n+\n+* Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n an exception can be caught and bound).\n-\\item Concurrency via dynamic thread creation/termination and\n+\n+* Concurrency via dynamic thread creation/termination and\n synchronization.  One can spawn a thread to execute any statement.\n The spawned thread shares with its parent its environment at creation time.\n Threads can be synchronized via a join command which blocks the current thread\n until the joined thread completes, via re-entrant locks which can be acquired\n and released, as well as through rendezvous commands.\n-\\end{itemize}\n+\n+\n Like in many other languages, some of SIMPLE's constructs can be\n desugared into a smaller set of basic constructs.  We do that at the end\n of the syntax module, and then we only give semantics to the core constructs.\n \n-\\paragraph{Note:}{\n-This definition is commented slightly more than others, because it is\n+__Note__: This definition is commented slightly more than others, because it is\n intended to be one of the first non-trivial definitions that the new\n-user of \\K sees.  We recommend the beginner user to first check the\n-language definitions discussed in the \\K tutorial.} */\n+user of **K** sees.  We recommend the beginner user to first check the\n+language definitions discussed in the **K** tutorial.\n \n+```k\n module SIMPLE-UNTYPED-SYNTAX\n   imports DOMAINS-SYNTAX\n+```\n \n-/*@ \\section{Syntax}\n+### Syntax\n We start by defining the SIMPLE syntax.  The language constructs discussed\n-above have the expected syntax and evaluation strategies.  Recall that in \\K\n+above have the expected syntax and evaluation strategies.  Recall that in **K**\n we annotate the syntax with appropriate strictness attributes, thus giving\n-each language construct the desired evaluation strategy. */\n+each language construct the desired evaluation strategy.\n \n-/*@ \\subsection{Identifiers}\n-Recall from the \\K tutorial that identifiers are builtin and come under the\n-syntactic category \\textit{Id}.  The special identifier for the function\n-``main'' belongs to all programs, and plays a special role in the semantics,\n+### Identifiers\n+Recall from the **K** tutorial that identifiers are builtin and come under the\n+syntactic category `Id`.  The special identifier for the function\n+`main` belongs to all programs, and plays a special role in the semantics,\n so we declare it explicitly.  This would not be necessary if the identifiers\n were all included automatically in semantic definitions, but that is not\n-possible because of parsing reasons (e.g., \\K variables used to match\n+possible because of parsing reasons (e.g., **K** variables used to match\n concrete identifiers would then be ambiguously parsed as identifiers).  They\n are only included in the parser generated to parse programs (and used by the\n-\\texttt{kast} tool).  Consequently, we have to explicitly declare all the\n+`kast` tool).  Consequently, we have to explicitly declare all the\n concrete identifiers that play a special role in the semantics, like\n-\\texttt{main} below. */\n+`main` below.\n \n+```k\n   syntax Id ::= \"main\" [token]\n+```\n \n-/*@ \\subsection{Declarations}\n+### Declarations\n There are two types of declarations: for variables (including arrays) and\n for functions.  We are going to allow declarations of the form\n-``\\texttt{var x=10, a[10,10], y=23;}'', which is why we allow the \\texttt{var}\n+`var x=10, a[10,10], y=23;`, which is why we allow the `var`\n keyword to take a list of expressions.  The non-terminals used in the two\n-productions below are defined shortly. */\n+productions below are defined shortly.\n \n+```k\n   syntax Decl ::= \"var\" Exps \";\"\n                 | \"function\" Id \"(\" Ids \")\" Block\n-\n-/*@ \\subsection{Expressions}\n-The expression constructs below are standard.  Increment (\\texttt{++}) takes\n+```\n+### Expressions", "originalCommit": "2992ff851da565dedcd5bbf4fea46de749b0e576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNjEyMQ==", "url": "https://github.com/kframework/k/pull/1486#discussion_r466506121", "bodyText": "I prefer bullet lists to be indented more like this (for readability/scanability):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Multidimensional arrays and array references.  An array evaluates\n          \n          \n            \n            to an array reference, which is a special value holding a location (where\n          \n          \n            \n            the elements of the array start) together with the size of the array;\n          \n          \n            \n            the elements of the array can be array references themselves (particularly\n          \n          \n            \n            when the array is multi-dimensional).  Array references are ordinary values,\n          \n          \n            \n            so they can be assigned to variables and passed/received by functions.\n          \n          \n            \n            * Multidimensional arrays and array references.  An array evaluates\n          \n          \n            \n              to an array reference, which is a special value holding a location (where\n          \n          \n            \n              the elements of the array start) together with the size of the array;\n          \n          \n            \n              the elements of the array can be array references themselves (particularly\n          \n          \n            \n              when the array is multi-dimensional).  Array references are ordinary values,\n          \n          \n            \n              so they can be assigned to variables and passed/received by functions.", "author": "ehildenb", "createdAt": "2020-08-06T15:42:06Z", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.", "originalCommit": "2992ff851da565dedcd5bbf4fea46de749b0e576", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNjI5Nw==", "url": "https://github.com/kframework/k/pull/1486#discussion_r466506297", "bodyText": "I would also prefer four spaces instead of 2, but up to you.", "author": "ehildenb", "createdAt": "2020-08-06T15:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNjEyMQ=="}], "type": "inlineReview"}, {"oid": "301a055d3869e5f21679dfbc21b723e6624c9f45", "url": "https://github.com/kframework/k/commit/301a055d3869e5f21679dfbc21b723e6624c9f45", "message": "Formatting", "committedDate": "2020-08-06T17:26:05Z", "type": "commit"}, {"oid": "0e5535c6cf00ed70b9dde692d1537ac9e84f868d", "url": "https://github.com/kframework/k/commit/0e5535c6cf00ed70b9dde692d1537ac9e84f868d", "message": "Merge branch 'master' into simpleMD", "committedDate": "2020-08-06T17:37:35Z", "type": "commit"}, {"oid": "39eb880c007a561597b99ef0fd289844ab944d91", "url": "https://github.com/kframework/k/commit/39eb880c007a561597b99ef0fd289844ab944d91", "message": "Merge branch 'master' into simpleMD", "committedDate": "2020-08-06T19:14:33Z", "type": "commit"}, {"oid": "19addbd5fa393d3e55ea917120e70cec3c61858d", "url": "https://github.com/kframework/k/commit/19addbd5fa393d3e55ea917120e70cec3c61858d", "message": "Merge branch 'master' into simpleMD", "committedDate": "2020-08-06T20:49:45Z", "type": "commit"}]}