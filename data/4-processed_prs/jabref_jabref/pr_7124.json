{"pr_number": 7124, "pr_title": "Enable automated cross library search using a cross library query lan\u2026", "pr_createdAt": "2020-11-24T20:37:34Z", "pr_url": "https://github.com/JabRef/jabref/pull/7124", "timeline": [{"oid": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "url": "https://github.com/JabRef/jabref/commit/32c7b34d4c650faf874b5df4cab4bd5e91d78242", "message": "Enable automated cross library search using a cross library query language.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-11-24T20:35:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3MjMxNA==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529872314", "bodyText": "As we are trying to get rid of the Globals it would be preferable if you could pass them as constructor arguments.\n(if you don't pass them, you would need to call Globals.prefs)", "author": "Siedlerchr", "createdAt": "2020-11-24T20:56:21Z", "path": "src/main/java/org/jabref/gui/StartLiteratureReviewAction.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package org.jabref.gui;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+import org.jabref.gui.actions.SimpleCommand;\n+import org.jabref.gui.importer.actions.OpenDatabaseAction;\n+import org.jabref.gui.util.BackgroundTask;\n+import org.jabref.gui.util.FileDialogConfiguration;\n+import org.jabref.logic.crawler.Crawler;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class StartLiteratureReviewAction extends SimpleCommand {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StartLiteratureReviewAction.class);\n+    private final JabRefFrame frame;\n+    private final DialogService dialogService;\n+\n+    public StartLiteratureReviewAction(JabRefFrame frame) {\n+        this.frame = frame;\n+        this.dialogService = frame.getDialogService();\n+    }\n+\n+    @Override\n+    public void execute() {\n+        FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder()\n+                .withInitialDirectory(getInitialDirectory())\n+                .build();\n+\n+        Optional<Path> studyDefinitionFile = dialogService.showFileOpenDialog(fileDialogConfiguration);\n+        if (studyDefinitionFile.isEmpty()) {\n+            // Do nothing if selection was canceled\n+            return;\n+        }\n+        final Crawler crawler;\n+        try {\n+            crawler = new Crawler(studyDefinitionFile.get(), Globals.getFileUpdateMonitor(), JabRefPreferences.getInstance().getSavePreferences(), Globals.entryTypesManager);", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3MjU5MQ==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529872591", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.info(\"Error during reading of study definition file.\", e);\n          \n          \n            \n                        LOGGER.error(\"Error during reading study definition file.\", e);", "author": "Siedlerchr", "createdAt": "2020-11-24T20:56:48Z", "path": "src/main/java/org/jabref/gui/StartLiteratureReviewAction.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package org.jabref.gui;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+import org.jabref.gui.actions.SimpleCommand;\n+import org.jabref.gui.importer.actions.OpenDatabaseAction;\n+import org.jabref.gui.util.BackgroundTask;\n+import org.jabref.gui.util.FileDialogConfiguration;\n+import org.jabref.logic.crawler.Crawler;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class StartLiteratureReviewAction extends SimpleCommand {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StartLiteratureReviewAction.class);\n+    private final JabRefFrame frame;\n+    private final DialogService dialogService;\n+\n+    public StartLiteratureReviewAction(JabRefFrame frame) {\n+        this.frame = frame;\n+        this.dialogService = frame.getDialogService();\n+    }\n+\n+    @Override\n+    public void execute() {\n+        FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder()\n+                .withInitialDirectory(getInitialDirectory())\n+                .build();\n+\n+        Optional<Path> studyDefinitionFile = dialogService.showFileOpenDialog(fileDialogConfiguration);\n+        if (studyDefinitionFile.isEmpty()) {\n+            // Do nothing if selection was canceled\n+            return;\n+        }\n+        final Crawler crawler;\n+        try {\n+            crawler = new Crawler(studyDefinitionFile.get(), Globals.getFileUpdateMonitor(), JabRefPreferences.getInstance().getSavePreferences(), Globals.entryTypesManager);\n+        } catch (IOException | ParseException | GitAPIException e) {\n+            LOGGER.info(\"Error during reading of study definition file.\", e);", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3MzAwMw==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529873003", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        dialogService.showErrorDialogAndWait(Localization.lang(\"Error during reading of study definition file.\"));\n          \n          \n            \n                        dialogService.showErrorDialogAndWait(Localization.lang(\"Error during reading of study definition file.\"),e);\n          \n      \n    \n    \n  \n\nIf you pass the exeption as parameter we will also see the stacktace in the error details.", "author": "Siedlerchr", "createdAt": "2020-11-24T20:57:34Z", "path": "src/main/java/org/jabref/gui/StartLiteratureReviewAction.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package org.jabref.gui;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+import org.jabref.gui.actions.SimpleCommand;\n+import org.jabref.gui.importer.actions.OpenDatabaseAction;\n+import org.jabref.gui.util.BackgroundTask;\n+import org.jabref.gui.util.FileDialogConfiguration;\n+import org.jabref.logic.crawler.Crawler;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class StartLiteratureReviewAction extends SimpleCommand {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StartLiteratureReviewAction.class);\n+    private final JabRefFrame frame;\n+    private final DialogService dialogService;\n+\n+    public StartLiteratureReviewAction(JabRefFrame frame) {\n+        this.frame = frame;\n+        this.dialogService = frame.getDialogService();\n+    }\n+\n+    @Override\n+    public void execute() {\n+        FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder()\n+                .withInitialDirectory(getInitialDirectory())\n+                .build();\n+\n+        Optional<Path> studyDefinitionFile = dialogService.showFileOpenDialog(fileDialogConfiguration);\n+        if (studyDefinitionFile.isEmpty()) {\n+            // Do nothing if selection was canceled\n+            return;\n+        }\n+        final Crawler crawler;\n+        try {\n+            crawler = new Crawler(studyDefinitionFile.get(), Globals.getFileUpdateMonitor(), JabRefPreferences.getInstance().getSavePreferences(), Globals.entryTypesManager);\n+        } catch (IOException | ParseException | GitAPIException e) {\n+            LOGGER.info(\"Error during reading of study definition file.\", e);\n+            dialogService.showErrorDialogAndWait(Localization.lang(\"Error during reading of study definition file.\"));", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NDE5Mw==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529874193", "bodyText": "Same as above, either pass Globals.pres as parameter or directly the workingDir as ctor param", "author": "Siedlerchr", "createdAt": "2020-11-24T20:59:50Z", "path": "src/main/java/org/jabref/gui/StartLiteratureReviewAction.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package org.jabref.gui;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+import org.jabref.gui.actions.SimpleCommand;\n+import org.jabref.gui.importer.actions.OpenDatabaseAction;\n+import org.jabref.gui.util.BackgroundTask;\n+import org.jabref.gui.util.FileDialogConfiguration;\n+import org.jabref.logic.crawler.Crawler;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class StartLiteratureReviewAction extends SimpleCommand {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StartLiteratureReviewAction.class);\n+    private final JabRefFrame frame;\n+    private final DialogService dialogService;\n+\n+    public StartLiteratureReviewAction(JabRefFrame frame) {\n+        this.frame = frame;\n+        this.dialogService = frame.getDialogService();\n+    }\n+\n+    @Override\n+    public void execute() {\n+        FileDialogConfiguration fileDialogConfiguration = new FileDialogConfiguration.Builder()\n+                .withInitialDirectory(getInitialDirectory())\n+                .build();\n+\n+        Optional<Path> studyDefinitionFile = dialogService.showFileOpenDialog(fileDialogConfiguration);\n+        if (studyDefinitionFile.isEmpty()) {\n+            // Do nothing if selection was canceled\n+            return;\n+        }\n+        final Crawler crawler;\n+        try {\n+            crawler = new Crawler(studyDefinitionFile.get(), Globals.getFileUpdateMonitor(), JabRefPreferences.getInstance().getSavePreferences(), Globals.entryTypesManager);\n+        } catch (IOException | ParseException | GitAPIException e) {\n+            LOGGER.info(\"Error during reading of study definition file.\", e);\n+            dialogService.showErrorDialogAndWait(Localization.lang(\"Error during reading of study definition file.\"));\n+            return;\n+        }\n+        BackgroundTask.wrap(() -> {\n+            crawler.performCrawl();\n+            return 0; // Return any value to make this a callable instead of a runnable. This allows throwing exceptions.\n+        })\n+                      .onFailure(e -> {\n+                          LOGGER.info(\"Error during persistence of crawling results.\");\n+                          dialogService.showErrorDialogAndWait(Localization.lang(\"Error during persistence of crawling results.\"), e);\n+                      })\n+                      .onSuccess(unused -> new OpenDatabaseAction(frame).openFile(Path.of(studyDefinitionFile.get().getParent().toString(), \"studyResult.bib\"), true))\n+                      .executeWith(Globals.TASK_EXECUTOR);\n+    }\n+\n+    /**\n+     * @return Path of current panel database directory or the working directory\n+     */\n+    private Path getInitialDirectory() {\n+        if (frame.getBasePanelCount() == 0) {\n+            return Globals.prefs.getWorkingDir();", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NTA2Mw==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529875063", "bodyText": "Also pass the ImportPreferences as parameter. This has the advantage that you can  mock them easier in a junit test", "author": "Siedlerchr", "createdAt": "2020-11-24T21:01:31Z", "path": "src/main/java/org/jabref/logic/crawler/Crawler.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package org.jabref.logic.crawler;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import org.jabref.logic.crawler.git.GitHandler;\n+import org.jabref.logic.exporter.SavePreferences;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.model.entry.BibEntryTypesManager;\n+import org.jabref.model.study.QueryResult;\n+import org.jabref.model.study.Study;\n+import org.jabref.model.util.FileUpdateMonitor;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+\n+/**\n+ * This class provides a service for SLR support by conducting an automated search and persistance\n+ * of studies using the queries and E-Libraries specified in the provided study definition file.\n+ *\n+ * It composes a StudyRepository for repository management,\n+ * and a StudyFetcher that manages the crawling over the selected E-Libraries.\n+ */\n+public class Crawler {\n+    private final StudyRepository studyRepository;\n+    private final StudyFetcher studyFetcher;\n+\n+    /**\n+     * Creates a crawler for retrieving studies from E-Libraries\n+     *\n+     * @param studyDefinitionFile The path to the study definition file that contains the list of targeted E-Libraries and used cross-library queries\n+     */\n+    public Crawler(Path studyDefinitionFile, FileUpdateMonitor fileUpdateMonitor, SavePreferences savePreferences, BibEntryTypesManager bibEntryTypesManager) throws IllegalArgumentException, IOException, ParseException, GitAPIException {", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3ODYwMw==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529878603", "bodyText": "I would use the enum constant: Could maybe also work  with bibEntry.getType().equals(LIBRARY_ENTRY) as well\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                         .filter(bibEntry -> bibEntry.getType().getName().equals(\"library\"))\n          \n          \n            \n                                         .filter(bibEntry -> bibEntry.getType().getName().equals(LIBRARY_ENTRY.getName()))", "author": "Siedlerchr", "createdAt": "2020-11-24T21:08:30Z", "path": "src/main/java/org/jabref/logic/crawler/LibraryEntryToFetcherConverter.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.jabref.logic.crawler;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.logic.importer.WebFetchers;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.UnknownField;\n+\n+/**\n+ * Converts library entries from the given study into their corresponding fetchers.\n+ */\n+class LibraryEntryToFetcherConverter {\n+    private final List<BibEntry> libraryEntries;\n+    private final ImportFormatPreferences importFormatPreferences;\n+\n+    public LibraryEntryToFetcherConverter(List<BibEntry> libraryEntries, ImportFormatPreferences importFormatPreferences) {\n+        this.libraryEntries = libraryEntries;\n+        this.importFormatPreferences = importFormatPreferences;\n+    }\n+\n+    /**\n+     * Returns a list of instances of all active library fetchers.\n+     *\n+     * A fetcher is considered active if there exists an library entry of the library the fetcher is associated with that is enabled.\n+     *\n+     * @return Instances of all active fetchers defined in the study definition.\n+     */\n+    public List<SearchBasedFetcher> getActiveFetchers() {\n+        return getFetchersFromLibraryEntries(this.libraryEntries);\n+    }\n+\n+    /**\n+     * Transforms a list of libraryEntries into a list of SearchBasedFetcher instances.\n+     *\n+     * @param libraryEntries List of entries\n+     * @return List of fetcher instances\n+     */\n+    private List<SearchBasedFetcher> getFetchersFromLibraryEntries(List<BibEntry> libraryEntries) {\n+        return libraryEntries.parallelStream()\n+                             .filter(bibEntry -> bibEntry.getType().getName().equals(\"library\"))", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3OTU5Ng==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529879596", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.info(\"Updating repository from remote failed\");\n          \n          \n            \n                        LOGGER.error(\"Updating repository from remote failed\",e);", "author": "Siedlerchr", "createdAt": "2020-11-24T21:10:16Z", "path": "src/main/java/org/jabref/logic/crawler/StudyRepository.java", "diffHunk": "@@ -0,0 +1,344 @@\n+package org.jabref.logic.crawler;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.logic.citationkeypattern.CitationKeyGenerator;\n+import org.jabref.logic.crawler.git.GitHandler;\n+import org.jabref.logic.database.DatabaseMerger;\n+import org.jabref.logic.exporter.BibtexDatabaseWriter;\n+import org.jabref.logic.exporter.SavePreferences;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.OpenDatabase;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.logic.importer.fileformat.BibtexParser;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.database.BibDatabaseContext;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.BibEntryTypesManager;\n+import org.jabref.model.entry.field.UnknownField;\n+import org.jabref.model.entry.types.SystematicLiteratureReviewStudyEntryType;\n+import org.jabref.model.study.FetchResult;\n+import org.jabref.model.study.QueryResult;\n+import org.jabref.model.study.Study;\n+import org.jabref.model.util.FileUpdateMonitor;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class manages all aspects of the study process related to the repository.\n+ *\n+ * It includes the parsing of the study definition file (study.bib) into a Study instance,\n+ * the structured persistence of the crawling results for the study within the file based repository,\n+ * as well as the sharing, and versioning of results using git.\n+ */\n+class StudyRepository {\n+    // Tests work with study.bib\n+    private static final String STUDY_DEFINITION_FILE_NAME = \"study.bib\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StudyRepository.class);\n+\n+    private final Path repositoryPath;\n+    private final Path studyDefinitionBib;\n+    private final GitHandler gitHandler;\n+    private final Study study;\n+    private final ImportFormatPreferences importFormatPreferences;\n+    private final FileUpdateMonitor fileUpdateMonitor;\n+    private final SavePreferences savePreferences;\n+    private final BibEntryTypesManager bibEntryTypesManager;\n+\n+    /**\n+     * Creates a study repository.\n+     *\n+     * @param pathToRepository Where the repository root is located.\n+     * @param gitHandler       The git handler that managages any interaction with the remote repository\n+     * @throws IllegalArgumentException If the repository root directory does not exist, or the root directory does not contain the study definition file.\n+     * @throws IOException              Thrown if the given repository does not exists, or the study definition file does not exist\n+     * @throws ParseException           Problem parsing the study definition file.\n+     */\n+    public StudyRepository(Path pathToRepository, GitHandler gitHandler, ImportFormatPreferences importFormatPreferences, FileUpdateMonitor fileUpdateMonitor, SavePreferences savePreferences, BibEntryTypesManager bibEntryTypesManager) throws IOException, ParseException, GitAPIException {\n+        this.repositoryPath = pathToRepository;\n+        this.gitHandler = gitHandler;\n+        try {\n+            gitHandler.updateLocalRepository();\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating repository from remote failed\");", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MDM4OQ==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529880389", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.info(\"Updating remote repository failed\");\n          \n          \n            \n                        LOGGER.error(\"Updating remote repository failed\",e);", "author": "Siedlerchr", "createdAt": "2020-11-24T21:11:47Z", "path": "src/main/java/org/jabref/logic/crawler/StudyRepository.java", "diffHunk": "@@ -0,0 +1,344 @@\n+package org.jabref.logic.crawler;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.logic.citationkeypattern.CitationKeyGenerator;\n+import org.jabref.logic.crawler.git.GitHandler;\n+import org.jabref.logic.database.DatabaseMerger;\n+import org.jabref.logic.exporter.BibtexDatabaseWriter;\n+import org.jabref.logic.exporter.SavePreferences;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.OpenDatabase;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.logic.importer.fileformat.BibtexParser;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.database.BibDatabaseContext;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.BibEntryTypesManager;\n+import org.jabref.model.entry.field.UnknownField;\n+import org.jabref.model.entry.types.SystematicLiteratureReviewStudyEntryType;\n+import org.jabref.model.study.FetchResult;\n+import org.jabref.model.study.QueryResult;\n+import org.jabref.model.study.Study;\n+import org.jabref.model.util.FileUpdateMonitor;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class manages all aspects of the study process related to the repository.\n+ *\n+ * It includes the parsing of the study definition file (study.bib) into a Study instance,\n+ * the structured persistence of the crawling results for the study within the file based repository,\n+ * as well as the sharing, and versioning of results using git.\n+ */\n+class StudyRepository {\n+    // Tests work with study.bib\n+    private static final String STUDY_DEFINITION_FILE_NAME = \"study.bib\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StudyRepository.class);\n+\n+    private final Path repositoryPath;\n+    private final Path studyDefinitionBib;\n+    private final GitHandler gitHandler;\n+    private final Study study;\n+    private final ImportFormatPreferences importFormatPreferences;\n+    private final FileUpdateMonitor fileUpdateMonitor;\n+    private final SavePreferences savePreferences;\n+    private final BibEntryTypesManager bibEntryTypesManager;\n+\n+    /**\n+     * Creates a study repository.\n+     *\n+     * @param pathToRepository Where the repository root is located.\n+     * @param gitHandler       The git handler that managages any interaction with the remote repository\n+     * @throws IllegalArgumentException If the repository root directory does not exist, or the root directory does not contain the study definition file.\n+     * @throws IOException              Thrown if the given repository does not exists, or the study definition file does not exist\n+     * @throws ParseException           Problem parsing the study definition file.\n+     */\n+    public StudyRepository(Path pathToRepository, GitHandler gitHandler, ImportFormatPreferences importFormatPreferences, FileUpdateMonitor fileUpdateMonitor, SavePreferences savePreferences, BibEntryTypesManager bibEntryTypesManager) throws IOException, ParseException, GitAPIException {\n+        this.repositoryPath = pathToRepository;\n+        this.gitHandler = gitHandler;\n+        try {\n+            gitHandler.updateLocalRepository();\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating repository from remote failed\");\n+        }\n+        this.importFormatPreferences = importFormatPreferences;\n+        this.fileUpdateMonitor = fileUpdateMonitor;\n+        this.studyDefinitionBib = Path.of(repositoryPath.toString(), STUDY_DEFINITION_FILE_NAME);\n+        this.savePreferences = savePreferences;\n+        this.bibEntryTypesManager = bibEntryTypesManager;\n+\n+        if (Files.notExists(repositoryPath)) {\n+            throw new IOException(\"The given repository does not exists.\");\n+        } else if (Files.notExists(studyDefinitionBib)) {\n+            throw new IOException(\"The study definition file does not exist in the given repository.\");\n+        }\n+        study = parseStudyFile();\n+        this.setUpRepositoryStructure();\n+    }\n+\n+    /**\n+     * Returns entries stored in the repository for a certain query and fetcher\n+     */\n+    public BibDatabaseContext getFetcherResultEntries(String query, String fetcherName) throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToFetcherResultFile(query, fetcherName), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * Returns the merged entries stored in the repository for a certain query\n+     */\n+    public BibDatabaseContext getQueryResultEntries(String query) throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToQueryResultFile(query), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * Returns the merged entries stored in the repository for all queries\n+     */\n+    public BibDatabaseContext getStudyResultEntries() throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToStudyResultFile(), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * The study definition file contains all the definitions of a study. This method extracts the BibEntries from the study BiB file.\n+     *\n+     * @return Returns the BibEntries parsed from the study definition file.\n+     * @throws IOException    Problem opening the input stream.\n+     * @throws ParseException Problem parsing the study definition file.\n+     */\n+    private Study parseStudyFile() throws IOException, ParseException {\n+        BibtexParser parser = new BibtexParser(importFormatPreferences, fileUpdateMonitor);\n+        List<BibEntry> parsedEntries = new ArrayList<>();\n+        try (InputStream inputStream = Files.newInputStream(studyDefinitionBib)) {\n+            parsedEntries.addAll(parser.parseEntries(inputStream));\n+        }\n+\n+        BibEntry studyEntry = parsedEntries.parallelStream()\n+                                           .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.STUDY_ENTRY)).findAny()\n+                                           .orElseThrow(() -> new ParseException(\"Study definition file does not contain a study entry\"));\n+        List<BibEntry> queryEntries = parsedEntries.parallelStream()\n+                                                   .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.SEARCH_QUERY_ENTRY))\n+                                                   .collect(Collectors.toList());\n+        List<BibEntry> libraryEntries = parsedEntries.parallelStream()\n+                                                     .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.LIBRARY_ENTRY))\n+                                                     .collect(Collectors.toList());\n+\n+        return new Study(studyEntry, queryEntries, libraryEntries);\n+    }\n+\n+    public Study getStudy() {\n+        return study;\n+    }\n+\n+    public void persist(List<QueryResult> crawlResults) throws IOException, GitAPIException {\n+        try {\n+            gitHandler.updateLocalRepository();\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating repository from remote failed\");\n+        }\n+        persistResults(crawlResults);\n+        study.setLastSearchDate(LocalDate.now());\n+        persistStudy();\n+        try {\n+            gitHandler.updateRemoteRepository(\"Conducted search \" + LocalDate.now());\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating remote repository failed\");", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MDk1Mw==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529880953", "bodyText": "Isn't this superflous? Why not let Files.createDirectory directlry throw the excption?", "author": "Siedlerchr", "createdAt": "2020-11-24T21:12:51Z", "path": "src/main/java/org/jabref/logic/crawler/StudyRepository.java", "diffHunk": "@@ -0,0 +1,344 @@\n+package org.jabref.logic.crawler;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.logic.citationkeypattern.CitationKeyGenerator;\n+import org.jabref.logic.crawler.git.GitHandler;\n+import org.jabref.logic.database.DatabaseMerger;\n+import org.jabref.logic.exporter.BibtexDatabaseWriter;\n+import org.jabref.logic.exporter.SavePreferences;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.OpenDatabase;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.logic.importer.fileformat.BibtexParser;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.database.BibDatabaseContext;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.BibEntryTypesManager;\n+import org.jabref.model.entry.field.UnknownField;\n+import org.jabref.model.entry.types.SystematicLiteratureReviewStudyEntryType;\n+import org.jabref.model.study.FetchResult;\n+import org.jabref.model.study.QueryResult;\n+import org.jabref.model.study.Study;\n+import org.jabref.model.util.FileUpdateMonitor;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class manages all aspects of the study process related to the repository.\n+ *\n+ * It includes the parsing of the study definition file (study.bib) into a Study instance,\n+ * the structured persistence of the crawling results for the study within the file based repository,\n+ * as well as the sharing, and versioning of results using git.\n+ */\n+class StudyRepository {\n+    // Tests work with study.bib\n+    private static final String STUDY_DEFINITION_FILE_NAME = \"study.bib\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StudyRepository.class);\n+\n+    private final Path repositoryPath;\n+    private final Path studyDefinitionBib;\n+    private final GitHandler gitHandler;\n+    private final Study study;\n+    private final ImportFormatPreferences importFormatPreferences;\n+    private final FileUpdateMonitor fileUpdateMonitor;\n+    private final SavePreferences savePreferences;\n+    private final BibEntryTypesManager bibEntryTypesManager;\n+\n+    /**\n+     * Creates a study repository.\n+     *\n+     * @param pathToRepository Where the repository root is located.\n+     * @param gitHandler       The git handler that managages any interaction with the remote repository\n+     * @throws IllegalArgumentException If the repository root directory does not exist, or the root directory does not contain the study definition file.\n+     * @throws IOException              Thrown if the given repository does not exists, or the study definition file does not exist\n+     * @throws ParseException           Problem parsing the study definition file.\n+     */\n+    public StudyRepository(Path pathToRepository, GitHandler gitHandler, ImportFormatPreferences importFormatPreferences, FileUpdateMonitor fileUpdateMonitor, SavePreferences savePreferences, BibEntryTypesManager bibEntryTypesManager) throws IOException, ParseException, GitAPIException {\n+        this.repositoryPath = pathToRepository;\n+        this.gitHandler = gitHandler;\n+        try {\n+            gitHandler.updateLocalRepository();\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating repository from remote failed\");\n+        }\n+        this.importFormatPreferences = importFormatPreferences;\n+        this.fileUpdateMonitor = fileUpdateMonitor;\n+        this.studyDefinitionBib = Path.of(repositoryPath.toString(), STUDY_DEFINITION_FILE_NAME);\n+        this.savePreferences = savePreferences;\n+        this.bibEntryTypesManager = bibEntryTypesManager;\n+\n+        if (Files.notExists(repositoryPath)) {\n+            throw new IOException(\"The given repository does not exists.\");\n+        } else if (Files.notExists(studyDefinitionBib)) {\n+            throw new IOException(\"The study definition file does not exist in the given repository.\");\n+        }\n+        study = parseStudyFile();\n+        this.setUpRepositoryStructure();\n+    }\n+\n+    /**\n+     * Returns entries stored in the repository for a certain query and fetcher\n+     */\n+    public BibDatabaseContext getFetcherResultEntries(String query, String fetcherName) throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToFetcherResultFile(query, fetcherName), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * Returns the merged entries stored in the repository for a certain query\n+     */\n+    public BibDatabaseContext getQueryResultEntries(String query) throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToQueryResultFile(query), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * Returns the merged entries stored in the repository for all queries\n+     */\n+    public BibDatabaseContext getStudyResultEntries() throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToStudyResultFile(), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * The study definition file contains all the definitions of a study. This method extracts the BibEntries from the study BiB file.\n+     *\n+     * @return Returns the BibEntries parsed from the study definition file.\n+     * @throws IOException    Problem opening the input stream.\n+     * @throws ParseException Problem parsing the study definition file.\n+     */\n+    private Study parseStudyFile() throws IOException, ParseException {\n+        BibtexParser parser = new BibtexParser(importFormatPreferences, fileUpdateMonitor);\n+        List<BibEntry> parsedEntries = new ArrayList<>();\n+        try (InputStream inputStream = Files.newInputStream(studyDefinitionBib)) {\n+            parsedEntries.addAll(parser.parseEntries(inputStream));\n+        }\n+\n+        BibEntry studyEntry = parsedEntries.parallelStream()\n+                                           .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.STUDY_ENTRY)).findAny()\n+                                           .orElseThrow(() -> new ParseException(\"Study definition file does not contain a study entry\"));\n+        List<BibEntry> queryEntries = parsedEntries.parallelStream()\n+                                                   .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.SEARCH_QUERY_ENTRY))\n+                                                   .collect(Collectors.toList());\n+        List<BibEntry> libraryEntries = parsedEntries.parallelStream()\n+                                                     .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.LIBRARY_ENTRY))\n+                                                     .collect(Collectors.toList());\n+\n+        return new Study(studyEntry, queryEntries, libraryEntries);\n+    }\n+\n+    public Study getStudy() {\n+        return study;\n+    }\n+\n+    public void persist(List<QueryResult> crawlResults) throws IOException, GitAPIException {\n+        try {\n+            gitHandler.updateLocalRepository();\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating repository from remote failed\");\n+        }\n+        persistResults(crawlResults);\n+        study.setLastSearchDate(LocalDate.now());\n+        persistStudy();\n+        try {\n+            gitHandler.updateRemoteRepository(\"Conducted search \" + LocalDate.now());\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating remote repository failed\");\n+        }\n+    }\n+\n+    private void persistStudy() throws IOException {\n+        writeResultToFile(studyDefinitionBib, new BibDatabase(study.getAllEntries()));\n+    }\n+\n+    /**\n+     * Create for each query a folder, and for each fetcher a bib file in the query folder to store its results.\n+     */\n+    private void setUpRepositoryStructure() throws IOException {\n+        // Cannot use stream here since IOException has to be thrown\n+        LibraryEntryToFetcherConverter converter = new LibraryEntryToFetcherConverter(study.getActiveLibraryEntries(), importFormatPreferences);\n+        for (String query : study.getSearchQueryStrings()) {\n+            createQueryResultFolder(query);\n+            converter.getActiveFetchers()\n+                     .forEach(searchBasedFetcher -> createFetcherResultFile(query, searchBasedFetcher));\n+            createQueryResultFile(query);\n+        }\n+        createStudyResultFile();\n+    }\n+\n+    /**\n+     * Creates a folder using the query and its corresponding query id.\n+     * This folder name is unique for each query, as long as the query id in the study definition is unique for each query.\n+     *\n+     * @param query The query the folder is created for\n+     */\n+    private void createQueryResultFolder(String query) throws IOException {\n+        Path queryResultFolder = getPathToQueryDirectory(query);\n+        createFolder(queryResultFolder);\n+    }\n+\n+    private void createFolder(Path folder) throws IOException {\n+        if (Files.notExists(folder)) {\n+            try {\n+                Files.createDirectory(folder);\n+            } catch (IOException e) {\n+                throw new IOException(\"Error during creation of repository structure.\", e);", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MzU5Nw==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529883597", "bodyText": "Extract the regex to a\nprivate final static string Pattern  =  Pattern.compile(regex)\npattern.matcher(query).replaceAll(\"\")", "author": "Siedlerchr", "createdAt": "2020-11-24T21:17:41Z", "path": "src/main/java/org/jabref/logic/crawler/StudyRepository.java", "diffHunk": "@@ -0,0 +1,344 @@\n+package org.jabref.logic.crawler;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.logic.citationkeypattern.CitationKeyGenerator;\n+import org.jabref.logic.crawler.git.GitHandler;\n+import org.jabref.logic.database.DatabaseMerger;\n+import org.jabref.logic.exporter.BibtexDatabaseWriter;\n+import org.jabref.logic.exporter.SavePreferences;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.OpenDatabase;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.logic.importer.fileformat.BibtexParser;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.database.BibDatabaseContext;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.BibEntryTypesManager;\n+import org.jabref.model.entry.field.UnknownField;\n+import org.jabref.model.entry.types.SystematicLiteratureReviewStudyEntryType;\n+import org.jabref.model.study.FetchResult;\n+import org.jabref.model.study.QueryResult;\n+import org.jabref.model.study.Study;\n+import org.jabref.model.util.FileUpdateMonitor;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class manages all aspects of the study process related to the repository.\n+ *\n+ * It includes the parsing of the study definition file (study.bib) into a Study instance,\n+ * the structured persistence of the crawling results for the study within the file based repository,\n+ * as well as the sharing, and versioning of results using git.\n+ */\n+class StudyRepository {\n+    // Tests work with study.bib\n+    private static final String STUDY_DEFINITION_FILE_NAME = \"study.bib\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StudyRepository.class);\n+\n+    private final Path repositoryPath;\n+    private final Path studyDefinitionBib;\n+    private final GitHandler gitHandler;\n+    private final Study study;\n+    private final ImportFormatPreferences importFormatPreferences;\n+    private final FileUpdateMonitor fileUpdateMonitor;\n+    private final SavePreferences savePreferences;\n+    private final BibEntryTypesManager bibEntryTypesManager;\n+\n+    /**\n+     * Creates a study repository.\n+     *\n+     * @param pathToRepository Where the repository root is located.\n+     * @param gitHandler       The git handler that managages any interaction with the remote repository\n+     * @throws IllegalArgumentException If the repository root directory does not exist, or the root directory does not contain the study definition file.\n+     * @throws IOException              Thrown if the given repository does not exists, or the study definition file does not exist\n+     * @throws ParseException           Problem parsing the study definition file.\n+     */\n+    public StudyRepository(Path pathToRepository, GitHandler gitHandler, ImportFormatPreferences importFormatPreferences, FileUpdateMonitor fileUpdateMonitor, SavePreferences savePreferences, BibEntryTypesManager bibEntryTypesManager) throws IOException, ParseException, GitAPIException {\n+        this.repositoryPath = pathToRepository;\n+        this.gitHandler = gitHandler;\n+        try {\n+            gitHandler.updateLocalRepository();\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating repository from remote failed\");\n+        }\n+        this.importFormatPreferences = importFormatPreferences;\n+        this.fileUpdateMonitor = fileUpdateMonitor;\n+        this.studyDefinitionBib = Path.of(repositoryPath.toString(), STUDY_DEFINITION_FILE_NAME);\n+        this.savePreferences = savePreferences;\n+        this.bibEntryTypesManager = bibEntryTypesManager;\n+\n+        if (Files.notExists(repositoryPath)) {\n+            throw new IOException(\"The given repository does not exists.\");\n+        } else if (Files.notExists(studyDefinitionBib)) {\n+            throw new IOException(\"The study definition file does not exist in the given repository.\");\n+        }\n+        study = parseStudyFile();\n+        this.setUpRepositoryStructure();\n+    }\n+\n+    /**\n+     * Returns entries stored in the repository for a certain query and fetcher\n+     */\n+    public BibDatabaseContext getFetcherResultEntries(String query, String fetcherName) throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToFetcherResultFile(query, fetcherName), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * Returns the merged entries stored in the repository for a certain query\n+     */\n+    public BibDatabaseContext getQueryResultEntries(String query) throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToQueryResultFile(query), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * Returns the merged entries stored in the repository for all queries\n+     */\n+    public BibDatabaseContext getStudyResultEntries() throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToStudyResultFile(), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * The study definition file contains all the definitions of a study. This method extracts the BibEntries from the study BiB file.\n+     *\n+     * @return Returns the BibEntries parsed from the study definition file.\n+     * @throws IOException    Problem opening the input stream.\n+     * @throws ParseException Problem parsing the study definition file.\n+     */\n+    private Study parseStudyFile() throws IOException, ParseException {\n+        BibtexParser parser = new BibtexParser(importFormatPreferences, fileUpdateMonitor);\n+        List<BibEntry> parsedEntries = new ArrayList<>();\n+        try (InputStream inputStream = Files.newInputStream(studyDefinitionBib)) {\n+            parsedEntries.addAll(parser.parseEntries(inputStream));\n+        }\n+\n+        BibEntry studyEntry = parsedEntries.parallelStream()\n+                                           .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.STUDY_ENTRY)).findAny()\n+                                           .orElseThrow(() -> new ParseException(\"Study definition file does not contain a study entry\"));\n+        List<BibEntry> queryEntries = parsedEntries.parallelStream()\n+                                                   .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.SEARCH_QUERY_ENTRY))\n+                                                   .collect(Collectors.toList());\n+        List<BibEntry> libraryEntries = parsedEntries.parallelStream()\n+                                                     .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.LIBRARY_ENTRY))\n+                                                     .collect(Collectors.toList());\n+\n+        return new Study(studyEntry, queryEntries, libraryEntries);\n+    }\n+\n+    public Study getStudy() {\n+        return study;\n+    }\n+\n+    public void persist(List<QueryResult> crawlResults) throws IOException, GitAPIException {\n+        try {\n+            gitHandler.updateLocalRepository();\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating repository from remote failed\");\n+        }\n+        persistResults(crawlResults);\n+        study.setLastSearchDate(LocalDate.now());\n+        persistStudy();\n+        try {\n+            gitHandler.updateRemoteRepository(\"Conducted search \" + LocalDate.now());\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating remote repository failed\");\n+        }\n+    }\n+\n+    private void persistStudy() throws IOException {\n+        writeResultToFile(studyDefinitionBib, new BibDatabase(study.getAllEntries()));\n+    }\n+\n+    /**\n+     * Create for each query a folder, and for each fetcher a bib file in the query folder to store its results.\n+     */\n+    private void setUpRepositoryStructure() throws IOException {\n+        // Cannot use stream here since IOException has to be thrown\n+        LibraryEntryToFetcherConverter converter = new LibraryEntryToFetcherConverter(study.getActiveLibraryEntries(), importFormatPreferences);\n+        for (String query : study.getSearchQueryStrings()) {\n+            createQueryResultFolder(query);\n+            converter.getActiveFetchers()\n+                     .forEach(searchBasedFetcher -> createFetcherResultFile(query, searchBasedFetcher));\n+            createQueryResultFile(query);\n+        }\n+        createStudyResultFile();\n+    }\n+\n+    /**\n+     * Creates a folder using the query and its corresponding query id.\n+     * This folder name is unique for each query, as long as the query id in the study definition is unique for each query.\n+     *\n+     * @param query The query the folder is created for\n+     */\n+    private void createQueryResultFolder(String query) throws IOException {\n+        Path queryResultFolder = getPathToQueryDirectory(query);\n+        createFolder(queryResultFolder);\n+    }\n+\n+    private void createFolder(Path folder) throws IOException {\n+        if (Files.notExists(folder)) {\n+            try {\n+                Files.createDirectory(folder);\n+            } catch (IOException e) {\n+                throw new IOException(\"Error during creation of repository structure.\", e);\n+            }\n+        }\n+    }\n+\n+    private void createFetcherResultFile(String query, SearchBasedFetcher searchBasedFetcher) {\n+        String fetcherName = searchBasedFetcher.getName();\n+        Path fetcherResultFile = getPathToFetcherResultFile(query, fetcherName);\n+        createBibFile(fetcherResultFile);\n+    }\n+\n+    private void createQueryResultFile(String query) {\n+        Path queryResultFile = getPathToFetcherResultFile(query, \"result\");\n+        createBibFile(queryResultFile);\n+    }\n+\n+    private void createStudyResultFile() {\n+        createBibFile(getPathToStudyResultFile());\n+    }\n+\n+    private void createBibFile(Path file) {\n+        if (Files.notExists(file)) {\n+            try {\n+                Files.createFile(file);\n+            } catch (IOException e) {\n+                throw new IllegalStateException(\"Error during creation of repository structure.\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a string that can be used as a folder name.\n+     * This removes all characters from the query that are illegal for directory names.\n+     * Structure: ID-trimmed query\n+     *\n+     * Examples:\n+     * Input: '(title: test-title AND abstract: Test)' as a query entry with id 1\n+     * Output: '1 - title= test-title AND abstract= Test'\n+     *\n+     * Input: 'abstract: Test*' as a query entry with id 1\n+     * Output: '1 - abstract= Test'\n+     *\n+     * Input: '\"test driven\"' as a query entry with id 1\n+     * Output: '1 - test driven'\n+     *\n+     * @param query that is trimmed and combined with its query id\n+     * @return a unique folder name for any query.\n+     */\n+    private String trimNameAndAddID(String query) {\n+        // Replace all field: with field= for folder name\n+        String trimmedNamed = query.replaceAll(\":\", \"=\");\n+        trimmedNamed = trimmedNamed.replaceAll(\"[^A-Za-z0-9_.\\\\s=-]\", \"\");", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4Mzg0NQ==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529883845", "bodyText": "extract to constant", "author": "Siedlerchr", "createdAt": "2020-11-24T21:18:15Z", "path": "src/main/java/org/jabref/logic/crawler/StudyRepository.java", "diffHunk": "@@ -0,0 +1,344 @@\n+package org.jabref.logic.crawler;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.jabref.logic.citationkeypattern.CitationKeyGenerator;\n+import org.jabref.logic.crawler.git.GitHandler;\n+import org.jabref.logic.database.DatabaseMerger;\n+import org.jabref.logic.exporter.BibtexDatabaseWriter;\n+import org.jabref.logic.exporter.SavePreferences;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.OpenDatabase;\n+import org.jabref.logic.importer.ParseException;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.logic.importer.fileformat.BibtexParser;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.database.BibDatabaseContext;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.BibEntryTypesManager;\n+import org.jabref.model.entry.field.UnknownField;\n+import org.jabref.model.entry.types.SystematicLiteratureReviewStudyEntryType;\n+import org.jabref.model.study.FetchResult;\n+import org.jabref.model.study.QueryResult;\n+import org.jabref.model.study.Study;\n+import org.jabref.model.util.FileUpdateMonitor;\n+import org.jabref.preferences.JabRefPreferences;\n+\n+import org.eclipse.jgit.api.errors.GitAPIException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class manages all aspects of the study process related to the repository.\n+ *\n+ * It includes the parsing of the study definition file (study.bib) into a Study instance,\n+ * the structured persistence of the crawling results for the study within the file based repository,\n+ * as well as the sharing, and versioning of results using git.\n+ */\n+class StudyRepository {\n+    // Tests work with study.bib\n+    private static final String STUDY_DEFINITION_FILE_NAME = \"study.bib\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(StudyRepository.class);\n+\n+    private final Path repositoryPath;\n+    private final Path studyDefinitionBib;\n+    private final GitHandler gitHandler;\n+    private final Study study;\n+    private final ImportFormatPreferences importFormatPreferences;\n+    private final FileUpdateMonitor fileUpdateMonitor;\n+    private final SavePreferences savePreferences;\n+    private final BibEntryTypesManager bibEntryTypesManager;\n+\n+    /**\n+     * Creates a study repository.\n+     *\n+     * @param pathToRepository Where the repository root is located.\n+     * @param gitHandler       The git handler that managages any interaction with the remote repository\n+     * @throws IllegalArgumentException If the repository root directory does not exist, or the root directory does not contain the study definition file.\n+     * @throws IOException              Thrown if the given repository does not exists, or the study definition file does not exist\n+     * @throws ParseException           Problem parsing the study definition file.\n+     */\n+    public StudyRepository(Path pathToRepository, GitHandler gitHandler, ImportFormatPreferences importFormatPreferences, FileUpdateMonitor fileUpdateMonitor, SavePreferences savePreferences, BibEntryTypesManager bibEntryTypesManager) throws IOException, ParseException, GitAPIException {\n+        this.repositoryPath = pathToRepository;\n+        this.gitHandler = gitHandler;\n+        try {\n+            gitHandler.updateLocalRepository();\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating repository from remote failed\");\n+        }\n+        this.importFormatPreferences = importFormatPreferences;\n+        this.fileUpdateMonitor = fileUpdateMonitor;\n+        this.studyDefinitionBib = Path.of(repositoryPath.toString(), STUDY_DEFINITION_FILE_NAME);\n+        this.savePreferences = savePreferences;\n+        this.bibEntryTypesManager = bibEntryTypesManager;\n+\n+        if (Files.notExists(repositoryPath)) {\n+            throw new IOException(\"The given repository does not exists.\");\n+        } else if (Files.notExists(studyDefinitionBib)) {\n+            throw new IOException(\"The study definition file does not exist in the given repository.\");\n+        }\n+        study = parseStudyFile();\n+        this.setUpRepositoryStructure();\n+    }\n+\n+    /**\n+     * Returns entries stored in the repository for a certain query and fetcher\n+     */\n+    public BibDatabaseContext getFetcherResultEntries(String query, String fetcherName) throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToFetcherResultFile(query, fetcherName), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * Returns the merged entries stored in the repository for a certain query\n+     */\n+    public BibDatabaseContext getQueryResultEntries(String query) throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToQueryResultFile(query), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * Returns the merged entries stored in the repository for all queries\n+     */\n+    public BibDatabaseContext getStudyResultEntries() throws IOException {\n+        return OpenDatabase.loadDatabase(getPathToStudyResultFile(), importFormatPreferences, fileUpdateMonitor).getDatabaseContext();\n+    }\n+\n+    /**\n+     * The study definition file contains all the definitions of a study. This method extracts the BibEntries from the study BiB file.\n+     *\n+     * @return Returns the BibEntries parsed from the study definition file.\n+     * @throws IOException    Problem opening the input stream.\n+     * @throws ParseException Problem parsing the study definition file.\n+     */\n+    private Study parseStudyFile() throws IOException, ParseException {\n+        BibtexParser parser = new BibtexParser(importFormatPreferences, fileUpdateMonitor);\n+        List<BibEntry> parsedEntries = new ArrayList<>();\n+        try (InputStream inputStream = Files.newInputStream(studyDefinitionBib)) {\n+            parsedEntries.addAll(parser.parseEntries(inputStream));\n+        }\n+\n+        BibEntry studyEntry = parsedEntries.parallelStream()\n+                                           .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.STUDY_ENTRY)).findAny()\n+                                           .orElseThrow(() -> new ParseException(\"Study definition file does not contain a study entry\"));\n+        List<BibEntry> queryEntries = parsedEntries.parallelStream()\n+                                                   .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.SEARCH_QUERY_ENTRY))\n+                                                   .collect(Collectors.toList());\n+        List<BibEntry> libraryEntries = parsedEntries.parallelStream()\n+                                                     .filter(bibEntry -> bibEntry.getType().equals(SystematicLiteratureReviewStudyEntryType.LIBRARY_ENTRY))\n+                                                     .collect(Collectors.toList());\n+\n+        return new Study(studyEntry, queryEntries, libraryEntries);\n+    }\n+\n+    public Study getStudy() {\n+        return study;\n+    }\n+\n+    public void persist(List<QueryResult> crawlResults) throws IOException, GitAPIException {\n+        try {\n+            gitHandler.updateLocalRepository();\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating repository from remote failed\");\n+        }\n+        persistResults(crawlResults);\n+        study.setLastSearchDate(LocalDate.now());\n+        persistStudy();\n+        try {\n+            gitHandler.updateRemoteRepository(\"Conducted search \" + LocalDate.now());\n+        } catch (GitAPIException e) {\n+            LOGGER.info(\"Updating remote repository failed\");\n+        }\n+    }\n+\n+    private void persistStudy() throws IOException {\n+        writeResultToFile(studyDefinitionBib, new BibDatabase(study.getAllEntries()));\n+    }\n+\n+    /**\n+     * Create for each query a folder, and for each fetcher a bib file in the query folder to store its results.\n+     */\n+    private void setUpRepositoryStructure() throws IOException {\n+        // Cannot use stream here since IOException has to be thrown\n+        LibraryEntryToFetcherConverter converter = new LibraryEntryToFetcherConverter(study.getActiveLibraryEntries(), importFormatPreferences);\n+        for (String query : study.getSearchQueryStrings()) {\n+            createQueryResultFolder(query);\n+            converter.getActiveFetchers()\n+                     .forEach(searchBasedFetcher -> createFetcherResultFile(query, searchBasedFetcher));\n+            createQueryResultFile(query);\n+        }\n+        createStudyResultFile();\n+    }\n+\n+    /**\n+     * Creates a folder using the query and its corresponding query id.\n+     * This folder name is unique for each query, as long as the query id in the study definition is unique for each query.\n+     *\n+     * @param query The query the folder is created for\n+     */\n+    private void createQueryResultFolder(String query) throws IOException {\n+        Path queryResultFolder = getPathToQueryDirectory(query);\n+        createFolder(queryResultFolder);\n+    }\n+\n+    private void createFolder(Path folder) throws IOException {\n+        if (Files.notExists(folder)) {\n+            try {\n+                Files.createDirectory(folder);\n+            } catch (IOException e) {\n+                throw new IOException(\"Error during creation of repository structure.\", e);\n+            }\n+        }\n+    }\n+\n+    private void createFetcherResultFile(String query, SearchBasedFetcher searchBasedFetcher) {\n+        String fetcherName = searchBasedFetcher.getName();\n+        Path fetcherResultFile = getPathToFetcherResultFile(query, fetcherName);\n+        createBibFile(fetcherResultFile);\n+    }\n+\n+    private void createQueryResultFile(String query) {\n+        Path queryResultFile = getPathToFetcherResultFile(query, \"result\");\n+        createBibFile(queryResultFile);\n+    }\n+\n+    private void createStudyResultFile() {\n+        createBibFile(getPathToStudyResultFile());\n+    }\n+\n+    private void createBibFile(Path file) {\n+        if (Files.notExists(file)) {\n+            try {\n+                Files.createFile(file);\n+            } catch (IOException e) {\n+                throw new IllegalStateException(\"Error during creation of repository structure.\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a string that can be used as a folder name.\n+     * This removes all characters from the query that are illegal for directory names.\n+     * Structure: ID-trimmed query\n+     *\n+     * Examples:\n+     * Input: '(title: test-title AND abstract: Test)' as a query entry with id 1\n+     * Output: '1 - title= test-title AND abstract= Test'\n+     *\n+     * Input: 'abstract: Test*' as a query entry with id 1\n+     * Output: '1 - abstract= Test'\n+     *\n+     * Input: '\"test driven\"' as a query entry with id 1\n+     * Output: '1 - test driven'\n+     *\n+     * @param query that is trimmed and combined with its query id\n+     * @return a unique folder name for any query.\n+     */\n+    private String trimNameAndAddID(String query) {\n+        // Replace all field: with field= for folder name\n+        String trimmedNamed = query.replaceAll(\":\", \"=\");\n+        trimmedNamed = trimmedNamed.replaceAll(\"[^A-Za-z0-9_.\\\\s=-]\", \"\");\n+        if (query.length() > 240) {\n+            trimmedNamed = query.substring(0, 240);\n+        }\n+        String id = findQueryIDByQueryString(query);\n+        return id + \" - \" + trimmedNamed;\n+    }\n+\n+    /**\n+     * Helper to find the query id for folder name creation.\n+     * Returns the id of the first SearchQuery BibEntry with a query field that matches the given query.\n+     *\n+     * @param query The query whose ID is searched\n+     * @return ID of the query defined in the study definition.\n+     */\n+    private String findQueryIDByQueryString(String query) {\n+        return study.getSearchQueryEntries()\n+                    .parallelStream()\n+                    .filter(bibEntry -> bibEntry.getField(new UnknownField(\"query\")).orElse(\"\").equals(query))", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NTI2MA==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529885260", "bodyText": "comment is a standard field", "author": "Siedlerchr", "createdAt": "2020-11-24T21:20:46Z", "path": "src/main/java/org/jabref/model/entry/types/SystematicLiteratureReviewStudyEntryTypeDefinitions.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package org.jabref.model.entry.types;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.jabref.model.entry.BibEntryType;\n+import org.jabref.model.entry.BibEntryTypeBuilder;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.field.UnknownField;\n+\n+/**\n+ * This class represents all supported entry types used in a study definition file\n+ */\n+public class SystematicLiteratureReviewStudyEntryTypeDefinitions {\n+\n+    /**\n+     * Entry type used for study meta data within a study definition file\n+     *\n+     * <ul>\n+     * <li>Required fields: author, lastsearchdate, name, enabled</li>\n+     * <li>Optional fields:</li>\n+     * </ul>\n+     */\n+    private static final BibEntryType STUDY_ENTRY = new BibEntryTypeBuilder()\n+            .withType(SystematicLiteratureReviewStudyEntryType.STUDY_ENTRY)\n+            .withRequiredFields(StandardField.AUTHOR, new UnknownField(\"lastsearchdate\"), new UnknownField(\"name\"), new UnknownField(\"researchquestions\"))\n+            .build();\n+\n+    /**\n+     * Entry type for the queries within the study definition file\n+     *\n+     * <ul>\n+     * <li>Required fields: query</li>\n+     * <li>Optional fields:</li>\n+     * </ul>\n+     */\n+    private static final BibEntryType SEARCH_QUERY_ENTRY = new BibEntryTypeBuilder()\n+            .withType(SystematicLiteratureReviewStudyEntryType.SEARCH_QUERY_ENTRY)\n+            .withRequiredFields(new UnknownField(\"query\"))\n+            .build();\n+\n+    /**\n+     * Entry type for the targeted libraries within a study definition file\n+     *\n+     * <ul>\n+     * <li>Required fields: name, enabled</li>\n+     * <li>Optional fields: comment</li>\n+     * </ul>\n+     */\n+    private static final BibEntryType LIBRARY_ENTRY = new BibEntryTypeBuilder()\n+            .withType(SystematicLiteratureReviewStudyEntryType.STUDY_ENTRY)\n+            .withRequiredFields(new UnknownField(\"name\"), new UnknownField(\"enabled\"))\n+            .withImportantFields(new UnknownField(\"comment\"))", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjI5OA==", "url": "https://github.com/JabRef/jabref/pull/7124#discussion_r529886298", "bodyText": "You already have static import, so Assertions... is superflous", "author": "Siedlerchr", "createdAt": "2020-11-24T21:22:50Z", "path": "src/test/java/org/jabref/model/study/StudyTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.jabref.model.study;\n+\n+import java.time.LocalDate;\n+import java.util.List;\n+\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.field.UnknownField;\n+import org.jabref.model.entry.types.SystematicLiteratureReviewStudyEntryType;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+class StudyTest {\n+    Study testStudy;\n+\n+    @BeforeEach\n+    public void setUpTestStudy() {\n+        BibEntry studyEntry = new BibEntry()\n+                .withField(new UnknownField(\"name\"), \"TestStudyName\")\n+                .withField(StandardField.AUTHOR, \"Jab Ref\")\n+                .withField(new UnknownField(\"researchQuestions\"), \"Question1; Question2\")\n+                .withField(new UnknownField(\"gitRepositoryURL\"), \"https://github.com/eclipse/jgit.git\");\n+        studyEntry.setType(SystematicLiteratureReviewStudyEntryType.STUDY_ENTRY);\n+\n+        // Create three SearchTerm entries.\n+        BibEntry searchQuery1 = new BibEntry()\n+                .withField(new UnknownField(\"query\"), \"TestSearchQuery1\");\n+        searchQuery1.setType(SystematicLiteratureReviewStudyEntryType.SEARCH_QUERY_ENTRY);\n+        searchQuery1.setCitationKey(\"query1\");\n+\n+        BibEntry searchQuery2 = new BibEntry()\n+                .withField(new UnknownField(\"query\"), \"TestSearchQuery2\");\n+        searchQuery2.setType(SystematicLiteratureReviewStudyEntryType.SEARCH_QUERY_ENTRY);\n+        searchQuery2.setCitationKey(\"query2\");\n+\n+        BibEntry searchQuery3 = new BibEntry()\n+                .withField(new UnknownField(\"query\"), \"TestSearchQuery3\");\n+        searchQuery3.setType(SystematicLiteratureReviewStudyEntryType.SEARCH_QUERY_ENTRY);\n+        searchQuery3.setCitationKey(\"query3\");\n+\n+        // Create two Library entries\n+        BibEntry library1 = new BibEntry()\n+                .withField(new UnknownField(\"name\"), \"acm\")\n+                .withField(new UnknownField(\"enabled\"), \"false\")\n+                .withField(new UnknownField(\"comment\"), \"disabled, because no good results\");\n+        library1.setType(SystematicLiteratureReviewStudyEntryType.LIBRARY_ENTRY);\n+        library1.setCitationKey(\"library1\");\n+\n+        BibEntry library2 = new BibEntry()\n+                .withField(new UnknownField(\"name\"), \"arxiv\")\n+                .withField(new UnknownField(\"enabled\"), \"true\")\n+                .withField(new UnknownField(\"Comment\"), \"\");\n+        library2.setType(SystematicLiteratureReviewStudyEntryType.LIBRARY_ENTRY);\n+        library2.setCitationKey(\"library2\");\n+\n+        testStudy = new Study(studyEntry, List.of(searchQuery1, searchQuery2, searchQuery3), List.of(library1, library2));\n+    }\n+\n+    @Test\n+    void getSearchTermsAsStrings() {\n+        List<String> expectedSearchTerms = List.of(\"TestSearchQuery1\", \"TestSearchQuery2\", \"TestSearchQuery3\");\n+        Assertions.assertEquals(expectedSearchTerms, testStudy.getSearchQueryStrings());\n+    }\n+\n+    @Test\n+    void setLastSearchTime() {\n+        LocalDate date = LocalDate.now();\n+        testStudy.setLastSearchDate(date);\n+        Assertions.assertEquals(date.toString(), testStudy.getStudyMetaDataField(StudyMetaDataField.STUDY_LAST_SEARCH).get());", "originalCommit": "32c7b34d4c650faf874b5df4cab4bd5e91d78242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7e45908fde29a2d43906ad39ed2a3c4e09adb0c0", "url": "https://github.com/JabRef/jabref/commit/7e45908fde29a2d43906ad39ed2a3c4e09adb0c0", "message": "Pull Global upward through constructor.", "committedDate": "2020-11-25T13:57:41Z", "type": "commit"}, {"oid": "2b6f56c67627af4ef82bf05c0c5ff38fb152b294", "url": "https://github.com/JabRef/jabref/commit/2b6f56c67627af4ef82bf05c0c5ff38fb152b294", "message": "Pull Globals and ImportFormatPreferences up through constructor\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-11-25T14:50:04Z", "type": "commit"}, {"oid": "93bb5073cacdbf884f693ff1cc65f0160c98959e", "url": "https://github.com/JabRef/jabref/commit/93bb5073cacdbf884f693ff1cc65f0160c98959e", "message": "Integrate requested changes and fix architecture tests by correcting test classes\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-11-25T15:56:14Z", "type": "commit"}, {"oid": "b4e2f10aba9c41c24b2f52d814c3b319e2796890", "url": "https://github.com/JabRef/jabref/commit/b4e2f10aba9c41c24b2f52d814c3b319e2796890", "message": "Remove unused imports\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-11-25T16:08:30Z", "type": "commit"}]}