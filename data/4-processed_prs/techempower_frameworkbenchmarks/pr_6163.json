{"pr_number": 6163, "pr_title": "ocaml opium process forking", "pr_createdAt": "2020-11-25T17:01:44Z", "pr_url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/6163", "timeline": [{"oid": "231ef36078f175c3c8a0c24fa75adb6190ae57b7", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/231ef36078f175c3c8a0c24fa75adb6190ae57b7", "message": "opium forks", "committedDate": "2020-11-25T17:00:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNTk3Mw==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/6163#discussion_r530525973", "bodyText": "@blandinw I notice that you have this function wrapped both in async and catch\nI'm not that familiar with Lwt, is it necessary?", "author": "mudrz", "createdAt": "2020-11-25T17:07:04Z", "path": "frameworks/OCaml/opium/src/bin/main_forks.ml", "diffHunk": "@@ -0,0 +1,69 @@\n+open Opium.Std\n+open Lwt.Syntax\n+\n+let run_app app ~instances ~port =\n+  let listen_address =\n+    let inet_addr = Unix.inet_addr_any in\n+    Unix.ADDR_INET (inet_addr, port)\n+  in\n+  let socket =\n+    Lwt_unix.socket (Unix.domain_of_sockaddr listen_address) Unix.SOCK_STREAM 0\n+  in\n+  Lwt_unix.setsockopt socket Unix.SO_REUSEADDR true;\n+\n+  Lwt_main.run (\n+    let+ () = Lwt_unix.bind socket listen_address in\n+    Lwt_unix.listen socket (Lwt_unix.somaxconn () [@ocaml.warning \"-3\"])\n+  );\n+\n+  let rec accept_loop socket handler instance =\n+    let* (socket', sockaddr') = Lwt_unix.accept socket in\n+    Lwt.async (fun () -> handler sockaddr' socket');", "originalCommit": "231ef36078f175c3c8a0c24fa75adb6190ae57b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUzMjg0NQ==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/6163#discussion_r530532845", "bodyText": "Probably an oversight on my end!\nIf I recall correctly, catch allows customized error handling, while async defers to async_exception_hook.\nIf that's correct, they're redundant and only one should be used.", "author": "blandinw", "createdAt": "2020-11-25T17:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0MTIxNw==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/6163#discussion_r530541217", "bodyText": "okay, thanks for the clarification \ud83d\udc4d\nassuming that the rest of the implementation is correct, we'll be able to compare httpaf with higher level libraries", "author": "mudrz", "createdAt": "2020-11-25T17:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0Njc2MQ==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/6163#discussion_r530546761", "bodyText": "Yes! The implementation looks good at a high level. It may be worth running a local test to compare the haproxy solution and this one, I'd expect a 5x to 10x speed up", "author": "blandinw", "createdAt": "2020-11-25T17:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyNTk3Mw=="}], "type": "inlineReview"}, {"oid": "66b17cf38a9ea4a025134aa5e521159ae46b281c", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/66b17cf38a9ea4a025134aa5e521159ae46b281c", "message": "start date refreshes", "committedDate": "2020-11-26T10:54:36Z", "type": "commit"}, {"oid": "74c23a58c110eb5c2d6305013303c0452a2f9dc1", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/74c23a58c110eb5c2d6305013303c0452a2f9dc1", "message": "add missing changes", "committedDate": "2020-11-26T11:32:26Z", "type": "commit"}]}