{"pr_number": 5429, "pr_title": "Add Scala framework: Scalene", "pr_createdAt": "2020-01-24T14:55:21Z", "pr_url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429", "timeline": [{"oid": "0a73cfb53db6eb6afc0a6652704ab68c214cd211", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/0a73cfb53db6eb6afc0a6652704ab68c214cd211", "message": "adding scalene framework test", "committedDate": "2020-01-24T14:41:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNTk2NA==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370715964", "bodyText": "The JSON serialization needs to happen on every request for this endpoint. Here, it is being serialized when the server starts.\nhttps://github.com/TechEmpower/FrameworkBenchmarks/wiki/Project-Information-Framework-Tests-Overview#json-serialization", "author": "nbrady-techempower", "createdAt": "2020-01-24T16:13:12Z", "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+package scalene.benchmark\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.scala.DefaultScalaModule\n+import scalene.actor.Pool\n+import scalene.routing._\n+import scalene.http.{BodyData, BodyFormatter, ContentType}\n+import scalene.sql._\n+import BasicConversions._\n+\n+object Main extends App {\n+\n+  trait JsonMessage\n+  case class JsonRouteMessage(message: String) extends JsonMessage\n+  case class DBRouteMessage(id: Int, randomnumber: Int) extends JsonMessage\n+  case class MultiDBRouteMessage(items: Array[DBRouteMessage]) extends JsonMessage\n+\n+  implicit val messageFormatter = new BodyFormatter[JsonMessage] {\n+    val mapper: ObjectMapper = new ObjectMapper().registerModule(DefaultScalaModule)\n+    def format(msg: JsonMessage) = {\n+      val obj = msg match {\n+        case MultiDBRouteMessage(items) => items\n+        case other => other\n+      }\n+      BodyData.Static(mapper.writeValueAsBytes(obj))\n+    }\n+    val contentType = Some(ContentType.`application/json`)\n+  }\n+\n+  val settings = Settings.basic(\n+    serverName = \"scalene\",\n+    port = 8080,\n+    server = ServerSettings.Default\n+  )\n+\n+  \n+  implicit val pool = new Pool\n+  val worldClient = MiniSQL.client(\n+    \"world-client\",\n+    \"jdbc:postgresql://tfb-database:5432/hello_world\",\n+    \"benchmarkdbuser\",\n+    \"benchmarkdbpass\"\n+  )\n+\n+  val random = new java.util.Random\n+  \n+  def randomWorld(session: MiniSQLSession): Option[DBRouteMessage] = {\n+    val stmt = session.prepared(\"SELECT id, randomnumber FROM world WHERE id = (?)\")\n+    stmt.setInt(1, math.abs(random.nextInt) % 10000 + 1)\n+    val rs = stmt.executeQuery()\n+    if (rs.next()) {\n+      Some(DBRouteMessage(rs.getInt(1), rs.getInt(2)))\n+    } else {\n+      None\n+    }      \n+  }\n+\n+  val dbRoute = GET / \"db\" to {_ =>\n+    worldClient.query{session =>\n+      randomWorld(session).map{_.ok}.getOrElse(\"N/A\".notFound)\n+    }\n+  }\n+\n+  val QueryNum = ![Int]\n+    .map{i => if (i < 1) 1 else if (i > 500) 500 else i}\n+    .recover{_ => 1}\n+\n+  val multiRoute = GET / \"queries\" / QueryNum to {num =>\n+    worldClient.query{session =>\n+      MultiDBRouteMessage(Array.fill(num)(randomWorld(session).get)).ok\n+    }\n+  }\n+\n+  val routes = Routes(\n+    GET / \"plaintext\" as \"Hello, World!\".ok,\n+    GET / \"json\"      as JsonRouteMessage(\"Hello, World!\").ok,", "originalCommit": "0a73cfb53db6eb6afc0a6652704ab68c214cd211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNTcwNw==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370725707", "bodyText": "ah good catch.  Fixed it!", "author": "DanSimon", "createdAt": "2020-01-24T16:32:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNTk2NA=="}], "type": "inlineReview"}, {"oid": "40bffaa0eaf8d3630e070b7fb9ebe33926a50e42", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/40bffaa0eaf8d3630e070b7fb9ebe33926a50e42", "message": "use function completion for all routes", "committedDate": "2020-01-24T16:28:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNjk4Ng==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370726986", "bodyText": "For the record, this one was fine.", "author": "nbrady-techempower", "createdAt": "2020-01-24T16:35:08Z", "path": "frameworks/Scala/scalene/src/main/scala/Benchmark.scala", "diffHunk": "@@ -0,0 +1,83 @@\n+package scalene.benchmark\n+\n+import com.fasterxml.jackson.databind.ObjectMapper\n+import com.fasterxml.jackson.module.scala.DefaultScalaModule\n+import scalene.actor.Pool\n+import scalene.routing._\n+import scalene.http.{BodyData, BodyFormatter, ContentType}\n+import scalene.sql._\n+import BasicConversions._\n+\n+object Main extends App {\n+\n+  trait JsonMessage\n+  case class JsonRouteMessage(message: String) extends JsonMessage\n+  case class DBRouteMessage(id: Int, randomnumber: Int) extends JsonMessage\n+  case class MultiDBRouteMessage(items: Array[DBRouteMessage]) extends JsonMessage\n+\n+  implicit val messageFormatter = new BodyFormatter[JsonMessage] {\n+    val mapper: ObjectMapper = new ObjectMapper().registerModule(DefaultScalaModule)\n+    def format(msg: JsonMessage) = {\n+      val obj = msg match {\n+        case MultiDBRouteMessage(items) => items\n+        case other => other\n+      }\n+      BodyData.Static(mapper.writeValueAsBytes(obj))\n+    }\n+    val contentType = Some(ContentType.`application/json`)\n+  }\n+\n+  val settings = Settings.basic(\n+    serverName = \"scalene\",\n+    port = 8080,\n+    server = ServerSettings.Default\n+  )\n+\n+  \n+  implicit val pool = new Pool\n+  val worldClient = MiniSQL.client(\n+    \"world-client\",\n+    \"jdbc:postgresql://tfb-database:5432/hello_world\",\n+    \"benchmarkdbuser\",\n+    \"benchmarkdbpass\"\n+  )\n+\n+  val random = new java.util.Random\n+  \n+  def randomWorld(session: MiniSQLSession): Option[DBRouteMessage] = {\n+    val stmt = session.prepared(\"SELECT id, randomnumber FROM world WHERE id = (?)\")\n+    stmt.setInt(1, math.abs(random.nextInt) % 10000 + 1)\n+    val rs = stmt.executeQuery()\n+    if (rs.next()) {\n+      Some(DBRouteMessage(rs.getInt(1), rs.getInt(2)))\n+    } else {\n+      None\n+    }      \n+  }\n+\n+  val dbRoute = GET / \"db\" to {_ =>\n+    worldClient.query{session =>\n+      randomWorld(session).map{_.ok}.getOrElse(\"N/A\".notFound)\n+    }\n+  }\n+\n+  val QueryNum = ![Int]\n+    .map{i => if (i < 1) 1 else if (i > 500) 500 else i}\n+    .recover{_ => 1}\n+\n+  val multiRoute = GET / \"queries\" / QueryNum to {num =>\n+    worldClient.query{session =>\n+      MultiDBRouteMessage(Array.fill(num)(randomWorld(session).get)).ok\n+    }\n+  }\n+\n+  val routes = Routes(\n+    GET / \"plaintext\" to {_ => \"Hello, World!\".ok},", "originalCommit": "40bffaa0eaf8d3630e070b7fb9ebe33926a50e42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyOTU2Mw==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5429#discussion_r370729563", "bodyText": "Good to know, I'll leave it for now as I don't think it will make much of a difference anyway.", "author": "DanSimon", "createdAt": "2020-01-24T16:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNjk4Ng=="}], "type": "inlineReview"}]}