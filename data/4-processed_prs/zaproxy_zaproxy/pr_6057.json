{"pr_number": 6057, "pr_title": "Fix bug that makes zap test same request twice", "pr_createdAt": "2020-06-30T22:29:28Z", "pr_url": "https://github.com/zaproxy/zaproxy/pull/6057", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAxNjY5MA==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r448016690", "bodyText": "Instead of importing and using you can simply reference it statically.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            && node.getHistoryReference().getHistoryType() == TYPE_TEMPORARY;\n          \n          \n            \n                            && node.getHistoryReference().getHistoryType() == HistoryReference.TYPE_TEMPORARY;", "author": "kingthorin", "createdAt": "2020-06-30T22:34:24Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/HostProcess.java", "diffHunk": "@@ -363,6 +367,45 @@ public void run() {\n         }\n     }\n \n+    private boolean bestNodeForUrl(StructuralNode node) {\n+\n+        if (!hasSamePropertiesAsRequestCreatedToFillSiteMap(node)) {\n+            return true;\n+        }\n+\n+        StructuralNode parentNode;\n+        try {\n+            parentNode = node.getParent();\n+        } catch (DatabaseException e) {\n+            return true;\n+        }\n+\n+        if (parentNode == null) {\n+            return true;\n+        }\n+\n+        String nodeURI = node.getURI().getEscapedURI();\n+        String nodeMethod = node.getMethod();\n+        Iterator<StructuralNode> siblingsIt = parentNode.getChildIterator();\n+        while (siblingsIt.hasNext()) {\n+            StructuralNode sibling = siblingsIt.next();\n+            String childURI = sibling.getURI().getEscapedURI();\n+            if (!sibling.isSameAs(node)\n+                    && sibling.getMethod().equals(nodeMethod)\n+                    && childURI.equals(nodeURI)\n+                    && sibling.isLeaf()\n+                    && !hasSamePropertiesAsRequestCreatedToFillSiteMap(sibling)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean hasSamePropertiesAsRequestCreatedToFillSiteMap(StructuralNode node) {\n+        return node.getMethod().equals(HttpRequestHeader.GET)\n+                && node.getHistoryReference().getHistoryType() == TYPE_TEMPORARY;", "originalCommit": "5df2419cb049eff567bacc8363954cf254ec714f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ0MjI4Ng==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r448442286", "bodyText": "thx, I  know but I was using it more than once and lines were getting to big to fit in one line.", "author": "DiogoMRSilva", "createdAt": "2020-07-01T15:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAxNjY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNDUzMQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r451624531", "bodyText": "This check will not work properly for all cases, not all nodes are included by default (e.g. out of scope, filters, not recurse) so we can't discard the temporary node beforehand. Taking the example in the issue, no nodes are scanned if you select the node \"3\" and disable recurse.\nIt might be safer to de-duplicate once we have all of them.", "author": "thc202", "createdAt": "2020-07-08T15:16:15Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/HostProcess.java", "diffHunk": "@@ -317,7 +319,7 @@ public void run() {\n                         startNode,\n                         true,\n                         node -> {\n-                            if (canScanNode(node)) {\n+                            if (canScanNode(node) && bestNodeForUrl(node)) {", "originalCommit": "6cc2172c8cbe4abc4a083c035dc06958b3c8ab23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4MTE2NQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r451681165", "bodyText": "I forgot that case. I believe it can be solved by adding the check canScanNode to the sibling\n...\n            if (!sibling.isSameAs(node)\n+                   && canScanNode(sibling)\n                    && sibling.getMethod().equals(nodeMethod)\n...\nWhat do you think?", "author": "DiogoMRSilva", "createdAt": "2020-07-08T16:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNDUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY5MDExNg==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r451690116", "bodyText": "That would address most part of it (e.g. out of scope, filters) but still not the above recurse case, the canScanNode does not tell if a node is included in the nodes to be scanned, that's done while traversing (to not check more nodes than really needed).", "author": "thc202", "createdAt": "2020-07-08T16:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNDUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxNDc5Nw==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r451714797", "bodyText": "True, I will do it after collecting all history nodes as you suggested.", "author": "DiogoMRSilva", "createdAt": "2020-07-08T17:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNDUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjE4NDY0MA==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r452184640", "bodyText": "It can also be de-duplicated as they are added, use a set and resolve the duplication immediately (might be simpler).", "author": "thc202", "createdAt": "2020-07-09T12:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNDUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE3MzgxMA==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r453173810", "bodyText": "Yes, it's simpler :), I used a dict to keep track of the locations where the requests were stored.", "author": "DiogoMRSilva", "createdAt": "2020-07-11T08:54:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNDUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNDgxMA==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r451624810", "bodyText": "isTemporary", "author": "thc202", "createdAt": "2020-07-08T15:16:40Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/HostProcess.java", "diffHunk": "@@ -363,6 +365,45 @@ public void run() {\n         }\n     }\n \n+    private boolean bestNodeForUrl(StructuralNode node) {\n+\n+        if (!hasSamePropertiesAsRequestCreatedToFillSiteMap(node)) {\n+            return true;\n+        }\n+\n+        StructuralNode parentNode;\n+        try {\n+            parentNode = node.getParent();\n+        } catch (DatabaseException e) {\n+            return true;\n+        }\n+\n+        if (parentNode == null) {\n+            return true;\n+        }\n+\n+        String nodeURI = node.getURI().getEscapedURI();\n+        String nodeMethod = node.getMethod();\n+        Iterator<StructuralNode> siblingsIt = parentNode.getChildIterator();\n+        while (siblingsIt.hasNext()) {\n+            StructuralNode sibling = siblingsIt.next();\n+            String childURI = sibling.getURI().getEscapedURI();\n+            if (!sibling.isSameAs(node)\n+                    && sibling.getMethod().equals(nodeMethod)\n+                    && childURI.equals(nodeURI)\n+                    && sibling.isLeaf()\n+                    && !hasSamePropertiesAsRequestCreatedToFillSiteMap(sibling)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean hasSamePropertiesAsRequestCreatedToFillSiteMap(StructuralNode node) {", "originalCommit": "6cc2172c8cbe4abc4a083c035dc06958b3c8ab23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyNDg1OA==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r451624858", "bodyText": "The type check would be enough, temporary tree nodes are all GET.", "author": "thc202", "createdAt": "2020-07-08T15:16:45Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/HostProcess.java", "diffHunk": "@@ -363,6 +365,45 @@ public void run() {\n         }\n     }\n \n+    private boolean bestNodeForUrl(StructuralNode node) {\n+\n+        if (!hasSamePropertiesAsRequestCreatedToFillSiteMap(node)) {\n+            return true;\n+        }\n+\n+        StructuralNode parentNode;\n+        try {\n+            parentNode = node.getParent();\n+        } catch (DatabaseException e) {\n+            return true;\n+        }\n+\n+        if (parentNode == null) {\n+            return true;\n+        }\n+\n+        String nodeURI = node.getURI().getEscapedURI();\n+        String nodeMethod = node.getMethod();\n+        Iterator<StructuralNode> siblingsIt = parentNode.getChildIterator();\n+        while (siblingsIt.hasNext()) {\n+            StructuralNode sibling = siblingsIt.next();\n+            String childURI = sibling.getURI().getEscapedURI();\n+            if (!sibling.isSameAs(node)\n+                    && sibling.getMethod().equals(nodeMethod)\n+                    && childURI.equals(nodeURI)\n+                    && sibling.isLeaf()\n+                    && !hasSamePropertiesAsRequestCreatedToFillSiteMap(sibling)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean hasSamePropertiesAsRequestCreatedToFillSiteMap(StructuralNode node) {\n+        return node.getMethod().equals(HttpRequestHeader.GET)", "originalCommit": "6cc2172c8cbe4abc4a083c035dc06958b3c8ab23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NDg5NA==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r453854894", "bodyText": "The checks can be reorder instead, e.g.:\nif (index == null) {\n    if (isTemporary(node)) {\n        indexOfTemporary.put(nodeHash(node), messagesIdsToAppScan.size());\n    }\n    messagesIdsToAppScan.add(nodeHistoryId);\n} else if (!isTemporary(node)) {\n    messagesIdsToAppScan.set(index, nodeHistoryId);\n}", "author": "thc202", "createdAt": "2020-07-13T18:41:47Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/HostProcess.java", "diffHunk": "@@ -313,12 +314,23 @@ public void run() {\n             }\n \n             for (StructuralNode startNode : startNodes) {\n+                Map<String, Integer> indexOfTemporary = new HashMap<>();\n                 traverse(\n                         startNode,\n                         true,\n                         node -> {\n                             if (canScanNode(node)) {\n-                                messagesIdsToAppScan.add(node.getHistoryReference().getHistoryId());\n+                                Integer index = indexOfTemporary.get(nodeHash(node));\n+                                int nodeHistoryId = node.getHistoryReference().getHistoryId();\n+                                if (isTemporary(node) && index == null) {\n+                                    indexOfTemporary.put(\n+                                            nodeHash(node), messagesIdsToAppScan.size());\n+                                    messagesIdsToAppScan.add(nodeHistoryId);\n+                                } else if (!isTemporary(node) && index == null) {\n+                                    messagesIdsToAppScan.add(nodeHistoryId);\n+                                } else if (!isTemporary(node) && index != null) {\n+                                    messagesIdsToAppScan.set(index, nodeHistoryId);\n+                                }", "originalCommit": "0a07784394e6a23ee32c8de300b5cc304df9a095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NDcxMw==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r457594713", "bodyText": "yes, that looks better.", "author": "DiogoMRSilva", "createdAt": "2020-07-20T18:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NDg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMzODI5Ng==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r508338296", "bodyText": "This is not working correctly when the temp node is after the non-temp node, it still scans both of them.", "author": "thc202", "createdAt": "2020-10-20T09:12:09Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/HostProcess.java", "diffHunk": "@@ -313,12 +314,23 @@ public void run() {\n             }\n \n             for (StructuralNode startNode : startNodes) {\n+                Map<String, Integer> indexOfTemporary = new HashMap<>();\n                 traverse(\n                         startNode,\n                         true,\n                         node -> {\n                             if (canScanNode(node)) {\n-                                messagesIdsToAppScan.add(node.getHistoryReference().getHistoryId());\n+                                Integer index = indexOfTemporary.get(nodeHash(node));\n+                                int nodeHistoryId = node.getHistoryReference().getHistoryId();\n+                                if (index == null) {", "originalCommit": "ae537ddaf65b14330d8aae4eeeec4db3d5a21292", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg5OTMwNA==", "url": "https://github.com/zaproxy/zaproxy/pull/6057#discussion_r522899304", "bodyText": "I incorrectly assumed they always came first. Thx for the catch", "author": "DiogoMRSilva", "createdAt": "2020-11-13T11:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMzODI5Ng=="}], "type": "inlineReview"}, {"oid": "86d695e8c92b264bec0e03b988526a863d10c5df", "url": "https://github.com/zaproxy/zaproxy/commit/86d695e8c92b264bec0e03b988526a863d10c5df", "message": "Refactor\n\nSigned-off-by: Diogo Silva <diogo.m.r.silva@tecnico.ulisboa.pt>", "committedDate": "2020-11-12T21:17:01Z", "type": "forcePushed"}, {"oid": "c1b6fe69b1b048c09e6caec48a5c7ff29c1a5dc5", "url": "https://github.com/zaproxy/zaproxy/commit/c1b6fe69b1b048c09e6caec48a5c7ff29c1a5dc5", "message": "Fix bug that makes zap test same request twice\n\nSigned-off-by: Diogo Silva <diogo.m.r.silva@tecnico.ulisboa.pt>", "committedDate": "2020-11-13T08:32:43Z", "type": "forcePushed"}, {"oid": "a794438d2947aa8f67ccce2d2f116e62c5fd6171", "url": "https://github.com/zaproxy/zaproxy/commit/a794438d2947aa8f67ccce2d2f116e62c5fd6171", "message": "Fix bug that makes zap test same request twice\n\nSigned-off-by: Diogo Silva <diogo.m.r.silva@tecnico.ulisboa.pt>", "committedDate": "2020-11-13T11:27:56Z", "type": "forcePushed"}, {"oid": "0cef4321a6b0a3266df0e1f0f607db39e14a42ca", "url": "https://github.com/zaproxy/zaproxy/commit/0cef4321a6b0a3266df0e1f0f607db39e14a42ca", "message": "Fix bug that makes zap test same request twice\n\nSigned-off-by: Diogo Silva <diogo.m.r.silva@tecnico.ulisboa.pt>", "committedDate": "2020-11-13T14:12:58Z", "type": "commit"}, {"oid": "0cef4321a6b0a3266df0e1f0f607db39e14a42ca", "url": "https://github.com/zaproxy/zaproxy/commit/0cef4321a6b0a3266df0e1f0f607db39e14a42ca", "message": "Fix bug that makes zap test same request twice\n\nSigned-off-by: Diogo Silva <diogo.m.r.silva@tecnico.ulisboa.pt>", "committedDate": "2020-11-13T14:12:58Z", "type": "forcePushed"}]}