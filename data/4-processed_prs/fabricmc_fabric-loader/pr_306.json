{"pr_number": 306, "pr_title": "Yeet Gson from loader", "pr_createdAt": "2020-09-05T02:05:38Z", "pr_url": "https://github.com/FabricMC/fabric-loader/pull/306", "timeline": [{"oid": "a9ecf13331eaef0a01aa9cf1c4a8cef52b5266d0", "url": "https://github.com/FabricMC/fabric-loader/commit/a9ecf13331eaef0a01aa9cf1c4a8cef52b5266d0", "message": "All of v1 and most of v0 schema\n\n\nCustom value error lol and deprcation\n\n\nReading people in v0\n\n\nRead the links\n\n\nlittle things\n\n\nHandle dependency versions\n\n\nHard yeet of gson, we just have gradle and cl exclusion\n\n\nWoops\n\n\nThrow exceptions when parsing version json\n\n\nRemove gson cl exclusion\n\n\nObligatory renames\n\n\nRe add gson methods for now :(\n\n\nOptimize reading code\n\n\nHandle duplicate schemaVersion field if schemaVersion is first field\n\n\nOptimize parts of exhaustive schemaVersion search\n\nThis fully delegates checks of duplicate mismatched `schemaVersion` values to the metadata parsers and inlines some logic to be more efficient.\nActual catch new parsing errors\n\n\nspell correction\n\n\nAnd it's super-minimized gson now\n\n\nThis commented aged like milk\n\n\nUse input stream reader instead\n\n\nExclude gson from licenser\n\n\nSpecify changes to Gson per apache 2.0\n\n\nMore unit tests\n\nAdds testing code for custom values.\n\nAdds a typical mod test case.\n\nFixed a bug where contact info would not read key of element before reading string value.\nClean up testing folders and categorize tests\n\n\nAdd long test file\n\n\nFix some parsing errors found during testing\n\n\nNeaten up a bit of jar resolving\n\n\nComplain about schemaVersion position\n\n\nMove the headers up", "committedDate": "2020-10-05T18:03:04Z", "type": "forcePushed"}, {"oid": "48e429cb130f922545c9559f433496ee2a32c9a4", "url": "https://github.com/FabricMC/fabric-loader/commit/48e429cb130f922545c9559f433496ee2a32c9a4", "message": "Move to JsonReader for parsing mod metadata\n\nCustom value error lol and deprcation\n\n\nReading people in v0\n\n\nRead the links\n\n\nlittle things\n\n\nHandle dependency versions\n\n\nHard yeet of gson, we just have gradle and cl exclusion\n\n\nWoops\n\n\nThrow exceptions when parsing version json\n\n\nRemove gson cl exclusion\n\n\nObligatory renames\n\n\nRe add gson methods for now :(\n\n\nOptimize reading code\n\n\nHandle duplicate schemaVersion field if schemaVersion is first field\n\n\nOptimize parts of exhaustive schemaVersion search\n\nThis fully delegates checks of duplicate mismatched `schemaVersion` values to the metadata parsers and inlines some logic to be more efficient.\nActual catch new parsing errors\n\n\nspell correction\n\n\nAnd it's super-minimized gson now\n\n\nThis commented aged like milk\n\n\nUse input stream reader instead\n\n\nExclude gson from licenser\n\n\nSpecify changes to Gson per apache 2.0\n\n\nMore unit tests\n\nAdds testing code for custom values.\n\nAdds a typical mod test case.\n\nFixed a bug where contact info would not read key of element before reading string value.\nClean up testing folders and categorize tests\n\n\nAdd long test file\n\n\nFix some parsing errors found during testing\n\n\nNeaten up a bit of jar resolving\n\n\nComplain about schemaVersion position\n\n\nMove the headers up", "committedDate": "2020-10-05T18:03:59Z", "type": "forcePushed"}, {"oid": "fd1cb5f03508c18b07e0a5d757541c3692888f7a", "url": "https://github.com/FabricMC/fabric-loader/commit/fd1cb5f03508c18b07e0a5d757541c3692888f7a", "message": "Move to JsonReader for parsing mod metadata\n\nCustom value error lol and deprcation\n\n\nReading people in v0\n\n\nRead the links\n\n\nlittle things\n\n\nHandle dependency versions\n\n\nHard yeet of gson, we just have gradle and cl exclusion\n\n\nWoops\n\n\nThrow exceptions when parsing version json\n\n\nRemove gson cl exclusion\n\n\nObligatory renames\n\n\nRe add gson methods for now :(\n\n\nOptimize reading code\n\n\nHandle duplicate schemaVersion field if schemaVersion is first field\n\n\nOptimize parts of exhaustive schemaVersion search\n\nThis fully delegates checks of duplicate mismatched `schemaVersion` values to the metadata parsers and inlines some logic to be more efficient.\nActual catch new parsing errors\n\n\nspell correction\n\n\nAnd it's super-minimized gson now\n\n\nThis commented aged like milk\n\n\nUse input stream reader instead\n\n\nExclude gson from licenser\n\n\nSpecify changes to Gson per apache 2.0\n\n\nMore unit tests\n\nAdds testing code for custom values.\n\nAdds a typical mod test case.\n\nFixed a bug where contact info would not read key of element before reading string value.\nClean up testing folders and categorize tests\n\n\nAdd long test file\n\n\nFix some parsing errors found during testing\n\n\nNeaten up a bit of jar resolving\n\n\nComplain about schemaVersion position\n\n\nMove the headers up", "committedDate": "2020-10-05T18:05:57Z", "type": "forcePushed"}, {"oid": "9947dc5d4865559341a1349acbeb57ec0aa58a46", "url": "https://github.com/FabricMC/fabric-loader/commit/9947dc5d4865559341a1349acbeb57ec0aa58a46", "message": "Move to JsonReader for parsing mod metadata\n\nCustom value error lol and deprcation\n\n\nReading people in v0\n\n\nRead the links\n\n\nlittle things\n\n\nHandle dependency versions\n\n\nHard yeet of gson, we just have gradle and cl exclusion\n\n\nWoops\n\n\nThrow exceptions when parsing version json\n\n\nRemove gson cl exclusion\n\n\nObligatory renames\n\n\nRe add gson methods for now :(\n\n\nOptimize reading code\n\n\nHandle duplicate schemaVersion field if schemaVersion is first field\n\n\nOptimize parts of exhaustive schemaVersion search\n\nThis fully delegates checks of duplicate mismatched `schemaVersion` values to the metadata parsers and inlines some logic to be more efficient.\nActual catch new parsing errors\n\n\nspell correction\n\n\nAnd it's super-minimized gson now\n\n\nThis commented aged like milk\n\n\nUse input stream reader instead\n\n\nExclude gson from licenser\n\n\nSpecify changes to Gson per apache 2.0\n\n\nMore unit tests\n\nAdds testing code for custom values.\n\nAdds a typical mod test case.\n\nFixed a bug where contact info would not read key of element before reading string value.\nClean up testing folders and categorize tests\n\n\nAdd long test file\n\n\nFix some parsing errors found during testing\n\n\nNeaten up a bit of jar resolving\n\n\nComplain about schemaVersion position\n\n\nMove the headers up\n\n\nFix parsing of entrypoints which makes unit tests work.\n\n\nThings should work, tested with a modpack", "committedDate": "2020-10-05T23:33:06Z", "type": "commit"}, {"oid": "9947dc5d4865559341a1349acbeb57ec0aa58a46", "url": "https://github.com/FabricMC/fabric-loader/commit/9947dc5d4865559341a1349acbeb57ec0aa58a46", "message": "Move to JsonReader for parsing mod metadata\n\nCustom value error lol and deprcation\n\n\nReading people in v0\n\n\nRead the links\n\n\nlittle things\n\n\nHandle dependency versions\n\n\nHard yeet of gson, we just have gradle and cl exclusion\n\n\nWoops\n\n\nThrow exceptions when parsing version json\n\n\nRemove gson cl exclusion\n\n\nObligatory renames\n\n\nRe add gson methods for now :(\n\n\nOptimize reading code\n\n\nHandle duplicate schemaVersion field if schemaVersion is first field\n\n\nOptimize parts of exhaustive schemaVersion search\n\nThis fully delegates checks of duplicate mismatched `schemaVersion` values to the metadata parsers and inlines some logic to be more efficient.\nActual catch new parsing errors\n\n\nspell correction\n\n\nAnd it's super-minimized gson now\n\n\nThis commented aged like milk\n\n\nUse input stream reader instead\n\n\nExclude gson from licenser\n\n\nSpecify changes to Gson per apache 2.0\n\n\nMore unit tests\n\nAdds testing code for custom values.\n\nAdds a typical mod test case.\n\nFixed a bug where contact info would not read key of element before reading string value.\nClean up testing folders and categorize tests\n\n\nAdd long test file\n\n\nFix some parsing errors found during testing\n\n\nNeaten up a bit of jar resolving\n\n\nComplain about schemaVersion position\n\n\nMove the headers up\n\n\nFix parsing of entrypoints which makes unit tests work.\n\n\nThings should work, tested with a modpack", "committedDate": "2020-10-05T23:33:06Z", "type": "forcePushed"}, {"oid": "05d75a30b339945ee2388eedfc9b0e8c7bd1f0a9", "url": "https://github.com/FabricMC/fabric-loader/commit/05d75a30b339945ee2388eedfc9b0e8c7bd1f0a9", "message": "Readd gson CL exclusion for now", "committedDate": "2020-10-05T23:37:03Z", "type": "commit"}, {"oid": "6e58034217d23c8f6f49e2edf02662341f41d758", "url": "https://github.com/FabricMC/fabric-loader/commit/6e58034217d23c8f6f49e2edf02662341f41d758", "message": "Cleanup two comments", "committedDate": "2020-10-05T23:41:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1MTU3MQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499951571", "bodyText": "LinkedHashMap to retain the order", "author": "sfPlayer1", "createdAt": "2020-10-06T01:05:36Z", "path": "src/main/java/net/fabricmc/loader/metadata/CustomValueImpl.java", "diffHunk": "@@ -16,63 +16,66 @@\n \n package net.fabricmc.loader.metadata;\n \n+import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Map.Entry;\n \n-import com.google.gson.JsonArray;\n-import com.google.gson.JsonElement;\n-import com.google.gson.JsonNull;\n-import com.google.gson.JsonObject;\n-import com.google.gson.JsonPrimitive;\n-\n import net.fabricmc.loader.api.metadata.CustomValue;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n \n abstract class CustomValueImpl implements CustomValue {\n \tstatic final CustomValue BOOLEAN_TRUE = new BooleanImpl(true);\n \tstatic final CustomValue BOOLEAN_FALSE = new BooleanImpl(false);\n \tstatic final CustomValue NULL = new NullImpl();\n \n-\tpublic static CustomValue fromJsonElement(JsonElement e) {\n-\t\tif (e instanceof JsonObject) {\n-\t\t\tJsonObject o = (JsonObject) e;\n-\t\t\tMap<String, CustomValue> entries = new LinkedHashMap<>(o.size());\n+\tpublic static CustomValue readCustomValue(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\tswitch (reader.peek()) {\n+\t\tcase BEGIN_OBJECT:\n+\t\t\treader.beginObject();\n+\n+\t\t\tfinal Map<String, CustomValue> values = new HashMap<>();", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1MjIwMA==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499952200", "bodyText": "Is toString being called during normal operation? If not, I'd move the string assembly to toString", "author": "sfPlayer1", "createdAt": "2020-10-06T01:08:15Z", "path": "src/main/java/net/fabricmc/loader/metadata/ModDependencyImpl.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.util.List;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.util.version.VersionPredicateParser;\n+\n+final class ModDependencyImpl implements ModDependency {\n+\tprivate final String modId;\n+\tprivate final List<String> matcherStringList;\n+\tprivate final String depAsStr;\n+\n+\tModDependencyImpl(String modId, List<String> matcherStringList) {\n+\t\tthis.modId = modId;\n+\t\tthis.matcherStringList = matcherStringList;\n+\n+\t\tfinal StringBuilder builder = new StringBuilder(\"{\");\n+\t\tbuilder.append(this.modId);\n+\t\tbuilder.append(\" @ [\");\n+\n+\t\tfor (int i = 0; i < matcherStringList.size(); i++) {\n+\t\t\tif (i > 0) {\n+\t\t\t\tbuilder.append(\" || \");\n+\t\t\t}\n+\n+\t\t\tbuilder.append(matcherStringList.get(i));\n+\t\t}\n+\n+\t\tbuilder.append(\"]}\");\n+\t\tthis.depAsStr = builder.toString();", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1Mjg3NA==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499952874", "bodyText": "this change is wrong", "author": "sfPlayer1", "createdAt": "2020-10-06T01:11:02Z", "path": "src/main/java/net/fabricmc/loader/minecraft/McVersionLookup.java", "diffHunk": "@@ -115,7 +115,7 @@ public static McVersion getVersion(Path gameJar) {\n \t}\n \n \tprivate static McVersion fromVersionJson(InputStream is) {\n-\t\ttry (JsonReader reader = new JsonReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {\n+\t\ttry(JsonReader reader = new JsonReader(new InputStreamReader(is))) {", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1Mzg1Mg==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499953852", "bodyText": "A single try-with-resource and a single variable should suffice. They all close the parent.", "author": "sfPlayer1", "createdAt": "2020-10-06T01:14:46Z", "path": "src/main/java/net/fabricmc/loader/metadata/ModMetadataParser.java", "diffHunk": "@@ -16,66 +16,117 @@\n \n package net.fabricmc.loader.metadata;\n \n-import com.google.gson.*;\n-import net.fabricmc.loader.FabricLoader;\n-import net.fabricmc.loader.api.metadata.ModEnvironment;\n-import net.fabricmc.loader.api.Version;\n-import net.fabricmc.loader.util.version.VersionDeserializer;\n-\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n \n-public class ModMetadataParser {\n+public final class ModMetadataParser {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n \tpublic static final int LATEST_VERSION = 1;\n \n-\tprivate static final Gson GSON_V1 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.JarEntry.class, new ModMetadataV1.JarEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.IconEntry.class, new ModMetadataV1.IconEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.LicenseEntry.class, new ModMetadataV1.LicenseEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.Person.class, new ModMetadataV1.Person.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.DependencyContainer.class, new ModMetadataV1.DependencyContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.MixinEntry.class, new ModMetadataV1.MixinEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.EntrypointContainer.class, new ModMetadataV1.EntrypointContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModEnvironment.class, new ModMetadataV1.EnvironmentDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.CustomValueContainer.class, new ModMetadataV1.CustomValueContainer.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final Gson GSON_V0 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Side.class, new ModMetadataV0.Side.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Mixins.class, new ModMetadataV0.Mixins.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Links.class, new ModMetadataV0.Links.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Dependency.class, new ModMetadataV0.Dependency.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Person.class, new ModMetadataV0.Person.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final JsonParser JSON_PARSER = new JsonParser();\n-\n-\tprivate static LoaderModMetadata getMod(FabricLoader loader, JsonObject object) {\n-\t\tif (!object.has(\"schemaVersion\")) {\n-\t\t\treturn GSON_V0.fromJson(object, ModMetadataV0.class);\n-\t\t} else {\n-\t\t\t//noinspection SwitchStatementWithTooFewBranches\n-\t\t\tswitch (object.get(\"schemaVersion\").getAsInt()) {\n-\t\t\t\tcase 1:\n-\t\t\t\t\treturn GSON_V1.fromJson(object, ModMetadataV1.class);\n-\t\t\t\tdefault:\n-\t\t\t\t\tloader.getLogger().warn(\"Mod ID \" + (object.has(\"id\") ? object.get(\"id\").getAsString() : \"<unknown>\") + \" has invalid schema version: \" + object.get(\"schemaVersion\").getAsInt());\n-\t\t\t\t\treturn null;\n+\t// Per the ECMA-404 (www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), the JSON spec does not prohibit duplicate keys.\n+\t// For all intensive purposes of replicating the logic of Gson before we have migrated to Nanojson, duplicate keys will replace previous entries.\n+\tpublic static LoaderModMetadata parseMetadata(Path modJson) throws IOException, ParseMetadataException {\n+\t\ttry {\n+\t\t\t// So some context:\n+\t\t\t// Per the json specification, ordering of fields is not typically enforced.\n+\t\t\t// Furthermore we cannot guarantee the `schemaVersion` is the first field in every `fabric.mod.json`\n+\t\t\t//\n+\t\t\t// To work around this, we do the following:\n+\t\t\t// Try to read first field\n+\t\t\t// If the first field is the schemaVersion, read the file normally.\n+\t\t\t//\n+\t\t\t// If the first field is not the schema version, fallback to a more exhaustive check.\n+\t\t\t// Read the rest of the file, looking for the `schemaVersion` field.\n+\t\t\t// If we find the field, cache the value\n+\t\t\t// If there happens to be another `schemaVersion` that has a differing value, then fail.\n+\t\t\t// At the end, if we find no `schemaVersion` then assume the `schemaVersion` is 0\n+\t\t\t// Re-read the JSON file.\n+\t\t\tint schemaVersion = 0;\n+\n+\t\t\ttry (InputStream stream = Files.newInputStream(modJson)) {\n+\t\t\t\ttry (JsonReader reader = new JsonReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NDIxNQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499954215", "bodyText": "redundant if before while", "author": "sfPlayer1", "createdAt": "2020-10-06T01:16:12Z", "path": "src/main/java/net/fabricmc/loader/metadata/ModMetadataParser.java", "diffHunk": "@@ -16,66 +16,117 @@\n \n package net.fabricmc.loader.metadata;\n \n-import com.google.gson.*;\n-import net.fabricmc.loader.FabricLoader;\n-import net.fabricmc.loader.api.metadata.ModEnvironment;\n-import net.fabricmc.loader.api.Version;\n-import net.fabricmc.loader.util.version.VersionDeserializer;\n-\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n \n-public class ModMetadataParser {\n+public final class ModMetadataParser {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n \tpublic static final int LATEST_VERSION = 1;\n \n-\tprivate static final Gson GSON_V1 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.JarEntry.class, new ModMetadataV1.JarEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.IconEntry.class, new ModMetadataV1.IconEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.LicenseEntry.class, new ModMetadataV1.LicenseEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.Person.class, new ModMetadataV1.Person.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.DependencyContainer.class, new ModMetadataV1.DependencyContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.MixinEntry.class, new ModMetadataV1.MixinEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.EntrypointContainer.class, new ModMetadataV1.EntrypointContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModEnvironment.class, new ModMetadataV1.EnvironmentDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.CustomValueContainer.class, new ModMetadataV1.CustomValueContainer.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final Gson GSON_V0 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Side.class, new ModMetadataV0.Side.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Mixins.class, new ModMetadataV0.Mixins.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Links.class, new ModMetadataV0.Links.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Dependency.class, new ModMetadataV0.Dependency.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Person.class, new ModMetadataV0.Person.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final JsonParser JSON_PARSER = new JsonParser();\n-\n-\tprivate static LoaderModMetadata getMod(FabricLoader loader, JsonObject object) {\n-\t\tif (!object.has(\"schemaVersion\")) {\n-\t\t\treturn GSON_V0.fromJson(object, ModMetadataV0.class);\n-\t\t} else {\n-\t\t\t//noinspection SwitchStatementWithTooFewBranches\n-\t\t\tswitch (object.get(\"schemaVersion\").getAsInt()) {\n-\t\t\t\tcase 1:\n-\t\t\t\t\treturn GSON_V1.fromJson(object, ModMetadataV1.class);\n-\t\t\t\tdefault:\n-\t\t\t\t\tloader.getLogger().warn(\"Mod ID \" + (object.has(\"id\") ? object.get(\"id\").getAsString() : \"<unknown>\") + \" has invalid schema version: \" + object.get(\"schemaVersion\").getAsInt());\n-\t\t\t\t\treturn null;\n+\t// Per the ECMA-404 (www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), the JSON spec does not prohibit duplicate keys.\n+\t// For all intensive purposes of replicating the logic of Gson before we have migrated to Nanojson, duplicate keys will replace previous entries.\n+\tpublic static LoaderModMetadata parseMetadata(Path modJson) throws IOException, ParseMetadataException {\n+\t\ttry {\n+\t\t\t// So some context:\n+\t\t\t// Per the json specification, ordering of fields is not typically enforced.\n+\t\t\t// Furthermore we cannot guarantee the `schemaVersion` is the first field in every `fabric.mod.json`\n+\t\t\t//\n+\t\t\t// To work around this, we do the following:\n+\t\t\t// Try to read first field\n+\t\t\t// If the first field is the schemaVersion, read the file normally.\n+\t\t\t//\n+\t\t\t// If the first field is not the schema version, fallback to a more exhaustive check.\n+\t\t\t// Read the rest of the file, looking for the `schemaVersion` field.\n+\t\t\t// If we find the field, cache the value\n+\t\t\t// If there happens to be another `schemaVersion` that has a differing value, then fail.\n+\t\t\t// At the end, if we find no `schemaVersion` then assume the `schemaVersion` is 0\n+\t\t\t// Re-read the JSON file.\n+\t\t\tint schemaVersion = 0;\n+\n+\t\t\ttry (InputStream stream = Files.newInputStream(modJson)) {\n+\t\t\t\ttry (JsonReader reader = new JsonReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Root of \\\"fabric.mod.json\\\" must be an object\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\tboolean firstField = true;\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\t// Try to read the schemaVersion\n+\t\t\t\t\t\tif (reader.nextName().equals(\"schemaVersion\")) {\n+\t\t\t\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"schemaVersion\\\" must be a number.\", reader);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tschemaVersion = reader.nextInt();\n+\n+\t\t\t\t\t\t\tif (firstField) {\n+\t\t\t\t\t\t\t\t// Finish reading the metadata\n+\t\t\t\t\t\t\t\treturn ModMetadataParser.readModMetadata(reader, schemaVersion);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// schemaVersion found, but after some content -> start over to parse all data with the detected version\n+\t\t\t\t\t\t\t\tif (reader.hasNext()) {", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NDQwOA==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499954408", "bodyText": "this was already verified before", "author": "sfPlayer1", "createdAt": "2020-10-06T01:17:00Z", "path": "src/main/java/net/fabricmc/loader/metadata/ModMetadataParser.java", "diffHunk": "@@ -16,66 +16,117 @@\n \n package net.fabricmc.loader.metadata;\n \n-import com.google.gson.*;\n-import net.fabricmc.loader.FabricLoader;\n-import net.fabricmc.loader.api.metadata.ModEnvironment;\n-import net.fabricmc.loader.api.Version;\n-import net.fabricmc.loader.util.version.VersionDeserializer;\n-\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n \n-public class ModMetadataParser {\n+public final class ModMetadataParser {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n \tpublic static final int LATEST_VERSION = 1;\n \n-\tprivate static final Gson GSON_V1 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.JarEntry.class, new ModMetadataV1.JarEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.IconEntry.class, new ModMetadataV1.IconEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.LicenseEntry.class, new ModMetadataV1.LicenseEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.Person.class, new ModMetadataV1.Person.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.DependencyContainer.class, new ModMetadataV1.DependencyContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.MixinEntry.class, new ModMetadataV1.MixinEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.EntrypointContainer.class, new ModMetadataV1.EntrypointContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModEnvironment.class, new ModMetadataV1.EnvironmentDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.CustomValueContainer.class, new ModMetadataV1.CustomValueContainer.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final Gson GSON_V0 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Side.class, new ModMetadataV0.Side.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Mixins.class, new ModMetadataV0.Mixins.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Links.class, new ModMetadataV0.Links.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Dependency.class, new ModMetadataV0.Dependency.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Person.class, new ModMetadataV0.Person.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final JsonParser JSON_PARSER = new JsonParser();\n-\n-\tprivate static LoaderModMetadata getMod(FabricLoader loader, JsonObject object) {\n-\t\tif (!object.has(\"schemaVersion\")) {\n-\t\t\treturn GSON_V0.fromJson(object, ModMetadataV0.class);\n-\t\t} else {\n-\t\t\t//noinspection SwitchStatementWithTooFewBranches\n-\t\t\tswitch (object.get(\"schemaVersion\").getAsInt()) {\n-\t\t\t\tcase 1:\n-\t\t\t\t\treturn GSON_V1.fromJson(object, ModMetadataV1.class);\n-\t\t\t\tdefault:\n-\t\t\t\t\tloader.getLogger().warn(\"Mod ID \" + (object.has(\"id\") ? object.get(\"id\").getAsString() : \"<unknown>\") + \" has invalid schema version: \" + object.get(\"schemaVersion\").getAsInt());\n-\t\t\t\t\treturn null;\n+\t// Per the ECMA-404 (www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), the JSON spec does not prohibit duplicate keys.\n+\t// For all intensive purposes of replicating the logic of Gson before we have migrated to Nanojson, duplicate keys will replace previous entries.\n+\tpublic static LoaderModMetadata parseMetadata(Path modJson) throws IOException, ParseMetadataException {\n+\t\ttry {\n+\t\t\t// So some context:\n+\t\t\t// Per the json specification, ordering of fields is not typically enforced.\n+\t\t\t// Furthermore we cannot guarantee the `schemaVersion` is the first field in every `fabric.mod.json`\n+\t\t\t//\n+\t\t\t// To work around this, we do the following:\n+\t\t\t// Try to read first field\n+\t\t\t// If the first field is the schemaVersion, read the file normally.\n+\t\t\t//\n+\t\t\t// If the first field is not the schema version, fallback to a more exhaustive check.\n+\t\t\t// Read the rest of the file, looking for the `schemaVersion` field.\n+\t\t\t// If we find the field, cache the value\n+\t\t\t// If there happens to be another `schemaVersion` that has a differing value, then fail.\n+\t\t\t// At the end, if we find no `schemaVersion` then assume the `schemaVersion` is 0\n+\t\t\t// Re-read the JSON file.\n+\t\t\tint schemaVersion = 0;\n+\n+\t\t\ttry (InputStream stream = Files.newInputStream(modJson)) {\n+\t\t\t\ttry (JsonReader reader = new JsonReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Root of \\\"fabric.mod.json\\\" must be an object\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\tboolean firstField = true;\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\t// Try to read the schemaVersion\n+\t\t\t\t\t\tif (reader.nextName().equals(\"schemaVersion\")) {\n+\t\t\t\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"schemaVersion\\\" must be a number.\", reader);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tschemaVersion = reader.nextInt();\n+\n+\t\t\t\t\t\t\tif (firstField) {\n+\t\t\t\t\t\t\t\t// Finish reading the metadata\n+\t\t\t\t\t\t\t\treturn ModMetadataParser.readModMetadata(reader, schemaVersion);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// schemaVersion found, but after some content -> start over to parse all data with the detected version\n+\t\t\t\t\t\t\t\tif (reader.hasNext()) {\n+\t\t\t\t\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\t\t\t\t\treader.skipValue();\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\treader.skipValue();\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tfirstField = false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.endObject();\n+\t\t\t\t}\n \t\t\t}\n+\n+\t\t\t// Slow path, schema version wasn't specified early enough, re-read with detected/inferred version\n+\t\t\ttry (InputStream stream = Files.newInputStream(modJson)) {\n+\t\t\t\ttry (JsonReader reader = new JsonReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NDUwNg==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499954506", "bodyText": "reader.endObjec() is missing here", "author": "sfPlayer1", "createdAt": "2020-10-06T01:17:25Z", "path": "src/main/java/net/fabricmc/loader/metadata/ModMetadataParser.java", "diffHunk": "@@ -16,66 +16,117 @@\n \n package net.fabricmc.loader.metadata;\n \n-import com.google.gson.*;\n-import net.fabricmc.loader.FabricLoader;\n-import net.fabricmc.loader.api.metadata.ModEnvironment;\n-import net.fabricmc.loader.api.Version;\n-import net.fabricmc.loader.util.version.VersionDeserializer;\n-\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n \n-public class ModMetadataParser {\n+public final class ModMetadataParser {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n \tpublic static final int LATEST_VERSION = 1;\n \n-\tprivate static final Gson GSON_V1 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.JarEntry.class, new ModMetadataV1.JarEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.IconEntry.class, new ModMetadataV1.IconEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.LicenseEntry.class, new ModMetadataV1.LicenseEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.Person.class, new ModMetadataV1.Person.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.DependencyContainer.class, new ModMetadataV1.DependencyContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.MixinEntry.class, new ModMetadataV1.MixinEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.EntrypointContainer.class, new ModMetadataV1.EntrypointContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModEnvironment.class, new ModMetadataV1.EnvironmentDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.CustomValueContainer.class, new ModMetadataV1.CustomValueContainer.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final Gson GSON_V0 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Side.class, new ModMetadataV0.Side.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Mixins.class, new ModMetadataV0.Mixins.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Links.class, new ModMetadataV0.Links.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Dependency.class, new ModMetadataV0.Dependency.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Person.class, new ModMetadataV0.Person.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final JsonParser JSON_PARSER = new JsonParser();\n-\n-\tprivate static LoaderModMetadata getMod(FabricLoader loader, JsonObject object) {\n-\t\tif (!object.has(\"schemaVersion\")) {\n-\t\t\treturn GSON_V0.fromJson(object, ModMetadataV0.class);\n-\t\t} else {\n-\t\t\t//noinspection SwitchStatementWithTooFewBranches\n-\t\t\tswitch (object.get(\"schemaVersion\").getAsInt()) {\n-\t\t\t\tcase 1:\n-\t\t\t\t\treturn GSON_V1.fromJson(object, ModMetadataV1.class);\n-\t\t\t\tdefault:\n-\t\t\t\t\tloader.getLogger().warn(\"Mod ID \" + (object.has(\"id\") ? object.get(\"id\").getAsString() : \"<unknown>\") + \" has invalid schema version: \" + object.get(\"schemaVersion\").getAsInt());\n-\t\t\t\t\treturn null;\n+\t// Per the ECMA-404 (www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), the JSON spec does not prohibit duplicate keys.\n+\t// For all intensive purposes of replicating the logic of Gson before we have migrated to Nanojson, duplicate keys will replace previous entries.\n+\tpublic static LoaderModMetadata parseMetadata(Path modJson) throws IOException, ParseMetadataException {\n+\t\ttry {\n+\t\t\t// So some context:\n+\t\t\t// Per the json specification, ordering of fields is not typically enforced.\n+\t\t\t// Furthermore we cannot guarantee the `schemaVersion` is the first field in every `fabric.mod.json`\n+\t\t\t//\n+\t\t\t// To work around this, we do the following:\n+\t\t\t// Try to read first field\n+\t\t\t// If the first field is the schemaVersion, read the file normally.\n+\t\t\t//\n+\t\t\t// If the first field is not the schema version, fallback to a more exhaustive check.\n+\t\t\t// Read the rest of the file, looking for the `schemaVersion` field.\n+\t\t\t// If we find the field, cache the value\n+\t\t\t// If there happens to be another `schemaVersion` that has a differing value, then fail.\n+\t\t\t// At the end, if we find no `schemaVersion` then assume the `schemaVersion` is 0\n+\t\t\t// Re-read the JSON file.\n+\t\t\tint schemaVersion = 0;\n+\n+\t\t\ttry (InputStream stream = Files.newInputStream(modJson)) {\n+\t\t\t\ttry (JsonReader reader = new JsonReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Root of \\\"fabric.mod.json\\\" must be an object\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\tboolean firstField = true;\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\t// Try to read the schemaVersion\n+\t\t\t\t\t\tif (reader.nextName().equals(\"schemaVersion\")) {\n+\t\t\t\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"schemaVersion\\\" must be a number.\", reader);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tschemaVersion = reader.nextInt();\n+\n+\t\t\t\t\t\t\tif (firstField) {\n+\t\t\t\t\t\t\t\t// Finish reading the metadata\n+\t\t\t\t\t\t\t\treturn ModMetadataParser.readModMetadata(reader, schemaVersion);\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t// schemaVersion found, but after some content -> start over to parse all data with the detected version\n+\t\t\t\t\t\t\t\tif (reader.hasNext()) {\n+\t\t\t\t\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\t\t\t\t\treader.skipValue();\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\treader.skipValue();\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tfirstField = false;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.endObject();\n+\t\t\t\t}\n \t\t\t}\n+\n+\t\t\t// Slow path, schema version wasn't specified early enough, re-read with detected/inferred version\n+\t\t\ttry (InputStream stream = Files.newInputStream(modJson)) {\n+\t\t\t\ttry (JsonReader reader = new JsonReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Root of \\\"fabric.mod.json\\\" must be an object\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.beginObject();\n+\t\t\t\t\tfinal LoaderModMetadata ret = ModMetadataParser.readModMetadata(reader, schemaVersion);\n+", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk2MjgwNQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499962805", "bodyText": "It was at the end of the specific version parsers but I moved it to there", "author": "i509VCB", "createdAt": "2020-10-06T01:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NDUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NDczNw==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499954737", "bodyText": "no qualified references to the current class' static members please, it is confusing", "author": "sfPlayer1", "createdAt": "2020-10-06T01:18:22Z", "path": "src/main/java/net/fabricmc/loader/metadata/ModMetadataParser.java", "diffHunk": "@@ -16,66 +16,117 @@\n \n package net.fabricmc.loader.metadata;\n \n-import com.google.gson.*;\n-import net.fabricmc.loader.FabricLoader;\n-import net.fabricmc.loader.api.metadata.ModEnvironment;\n-import net.fabricmc.loader.api.Version;\n-import net.fabricmc.loader.util.version.VersionDeserializer;\n-\n+import java.io.IOException;\n import java.io.InputStream;\n import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n \n-public class ModMetadataParser {\n+public final class ModMetadataParser {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n \tpublic static final int LATEST_VERSION = 1;\n \n-\tprivate static final Gson GSON_V1 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.JarEntry.class, new ModMetadataV1.JarEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.IconEntry.class, new ModMetadataV1.IconEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.LicenseEntry.class, new ModMetadataV1.LicenseEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.Person.class, new ModMetadataV1.Person.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.DependencyContainer.class, new ModMetadataV1.DependencyContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.MixinEntry.class, new ModMetadataV1.MixinEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.EntrypointContainer.class, new ModMetadataV1.EntrypointContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModEnvironment.class, new ModMetadataV1.EnvironmentDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.CustomValueContainer.class, new ModMetadataV1.CustomValueContainer.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final Gson GSON_V0 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Side.class, new ModMetadataV0.Side.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Mixins.class, new ModMetadataV0.Mixins.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Links.class, new ModMetadataV0.Links.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Dependency.class, new ModMetadataV0.Dependency.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Person.class, new ModMetadataV0.Person.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final JsonParser JSON_PARSER = new JsonParser();\n-\n-\tprivate static LoaderModMetadata getMod(FabricLoader loader, JsonObject object) {\n-\t\tif (!object.has(\"schemaVersion\")) {\n-\t\t\treturn GSON_V0.fromJson(object, ModMetadataV0.class);\n-\t\t} else {\n-\t\t\t//noinspection SwitchStatementWithTooFewBranches\n-\t\t\tswitch (object.get(\"schemaVersion\").getAsInt()) {\n-\t\t\t\tcase 1:\n-\t\t\t\t\treturn GSON_V1.fromJson(object, ModMetadataV1.class);\n-\t\t\t\tdefault:\n-\t\t\t\t\tloader.getLogger().warn(\"Mod ID \" + (object.has(\"id\") ? object.get(\"id\").getAsString() : \"<unknown>\") + \" has invalid schema version: \" + object.get(\"schemaVersion\").getAsInt());\n-\t\t\t\t\treturn null;\n+\t// Per the ECMA-404 (www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), the JSON spec does not prohibit duplicate keys.\n+\t// For all intensive purposes of replicating the logic of Gson before we have migrated to Nanojson, duplicate keys will replace previous entries.\n+\tpublic static LoaderModMetadata parseMetadata(Path modJson) throws IOException, ParseMetadataException {\n+\t\ttry {\n+\t\t\t// So some context:\n+\t\t\t// Per the json specification, ordering of fields is not typically enforced.\n+\t\t\t// Furthermore we cannot guarantee the `schemaVersion` is the first field in every `fabric.mod.json`\n+\t\t\t//\n+\t\t\t// To work around this, we do the following:\n+\t\t\t// Try to read first field\n+\t\t\t// If the first field is the schemaVersion, read the file normally.\n+\t\t\t//\n+\t\t\t// If the first field is not the schema version, fallback to a more exhaustive check.\n+\t\t\t// Read the rest of the file, looking for the `schemaVersion` field.\n+\t\t\t// If we find the field, cache the value\n+\t\t\t// If there happens to be another `schemaVersion` that has a differing value, then fail.\n+\t\t\t// At the end, if we find no `schemaVersion` then assume the `schemaVersion` is 0\n+\t\t\t// Re-read the JSON file.\n+\t\t\tint schemaVersion = 0;\n+\n+\t\t\ttry (InputStream stream = Files.newInputStream(modJson)) {\n+\t\t\t\ttry (JsonReader reader = new JsonReader(new InputStreamReader(stream, StandardCharsets.UTF_8))) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Root of \\\"fabric.mod.json\\\" must be an object\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\tboolean firstField = true;\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\t// Try to read the schemaVersion\n+\t\t\t\t\t\tif (reader.nextName().equals(\"schemaVersion\")) {\n+\t\t\t\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"schemaVersion\\\" must be a number.\", reader);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\tschemaVersion = reader.nextInt();\n+\n+\t\t\t\t\t\t\tif (firstField) {\n+\t\t\t\t\t\t\t\t// Finish reading the metadata\n+\t\t\t\t\t\t\t\treturn ModMetadataParser.readModMetadata(reader, schemaVersion);", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NTMzNA==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499955334", "bodyText": "this should store the raw version in a variable, then add the wrong one to the exc", "author": "sfPlayer1", "createdAt": "2020-10-06T01:20:34Z", "path": "src/main/java/net/fabricmc/loader/metadata/V0ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,430 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V0ModMetadataParser {\n+\tprivate static final Pattern WEBSITE_PATTERN = Pattern.compile(\"\\\\((.+)\\\\)\");\n+\tprivate static final Pattern EMAIL_PATTERN = Pattern.compile(\"<(.+)>\");\n+\n+\tpublic static LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tV0ModMetadata.Mixins mixins = null;\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tString initializer = null;\n+\t\tList<String> initializers = new ArrayList<>();\n+\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation links = null;\n+\t\tString license = null;\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 0) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 0. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NTQ1MA==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499955450", "bodyText": "warn for default case", "author": "sfPlayer1", "createdAt": "2020-10-06T01:20:52Z", "path": "src/main/java/net/fabricmc/loader/metadata/V0ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,430 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V0ModMetadataParser {\n+\tprivate static final Pattern WEBSITE_PATTERN = Pattern.compile(\"\\\\((.+)\\\\)\");\n+\tprivate static final Pattern EMAIL_PATTERN = Pattern.compile(\"<(.+)>\");\n+\n+\tpublic static LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tV0ModMetadata.Mixins mixins = null;\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tString initializer = null;\n+\t\tList<String> initializers = new ArrayList<>();\n+\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation links = null;\n+\t\tString license = null;\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 0) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 0. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, requires, \"requires\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, conflicts, \"conflicts\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tmixins = V0ModMetadataParser.readMixins(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"side\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Side must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tswitch (reader.nextString()) {\n+\t\t\t\tcase \"universal\":\n+\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"client\":\n+\t\t\t\t\tenvironment = ModEnvironment.CLIENT;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"server\":\n+\t\t\t\t\tenvironment = ModEnvironment.SERVER;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk2MzcyOQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499963729", "bodyText": "I think the default branch of the switch block should be to fail, you don't exactly have a 4th mod environment", "author": "i509VCB", "createdAt": "2020-10-06T01:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NTQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NTcyNg==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499955726", "bodyText": "warn for default case", "author": "sfPlayer1", "createdAt": "2020-10-06T01:21:47Z", "path": "src/main/java/net/fabricmc/loader/metadata/V0ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,430 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V0ModMetadataParser {\n+\tprivate static final Pattern WEBSITE_PATTERN = Pattern.compile(\"\\\\((.+)\\\\)\");\n+\tprivate static final Pattern EMAIL_PATTERN = Pattern.compile(\"<(.+)>\");\n+\n+\tpublic static LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tV0ModMetadata.Mixins mixins = null;\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tString initializer = null;\n+\t\tList<String> initializers = new ArrayList<>();\n+\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation links = null;\n+\t\tString license = null;\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 0) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 0. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, requires, \"requires\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, conflicts, \"conflicts\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tmixins = V0ModMetadataParser.readMixins(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"side\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Side must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tswitch (reader.nextString()) {\n+\t\t\t\tcase \"universal\":\n+\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"client\":\n+\t\t\t\t\tenvironment = ModEnvironment.CLIENT;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"server\":\n+\t\t\t\t\tenvironment = ModEnvironment.SERVER;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializer\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializer must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tinitializer = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializers\":\n+\t\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializers must be in a list\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\treader.beginArray();\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Initializer in initializers list must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinitializers.add(reader.nextString());\n+\t\t\t\t}\n+\n+\t\t\t\treader.endArray();\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, recommends, \"recommends\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"links\":\n+\t\t\t\tlinks = V0ModMetadataParser.readLinks(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"License name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tlicense = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t// TODO: Hard fail?\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\t// Optional stuff\n+\t\tif (links == null) {\n+\t\t\tlinks = ContactInformation.EMPTY;\n+\t\t}\n+\n+\t\t// `initializer` and `initializers` cannot be used at the same time\n+\t\tif (initializer != null) {\n+\t\t\tif (!initializers.isEmpty()) {\n+\t\t\t\tthrow new ParseMetadataException(\"initializer and initializers should not be set at the same time! (mod ID '\" + id + \"')\");\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new V0ModMetadata(id, version, requires, conflicts, mixins, environment, initializer, initializers, name, description, recommends, authors, contributors, links, license);\n+\t}\n+\n+\tprivate static ContactInformation readLinks(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\tfinal Map<String, String> contactInfo = new HashMap<>();\n+\n+\t\tswitch (reader.peek()) {\n+\t\tcase STRING:\n+\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n+\t\t\tbreak;\n+\t\tcase BEGIN_OBJECT:\n+\t\t\treader.beginObject();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\tcase \"homepage\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"homepage link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"issues\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"issues link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"issues\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"sources\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"sources link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"sources\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\t}", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NTc5NQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499955795", "bodyText": "warn for default case", "author": "sfPlayer1", "createdAt": "2020-10-06T01:21:57Z", "path": "src/main/java/net/fabricmc/loader/metadata/V0ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,430 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V0ModMetadataParser {\n+\tprivate static final Pattern WEBSITE_PATTERN = Pattern.compile(\"\\\\((.+)\\\\)\");\n+\tprivate static final Pattern EMAIL_PATTERN = Pattern.compile(\"<(.+)>\");\n+\n+\tpublic static LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tV0ModMetadata.Mixins mixins = null;\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tString initializer = null;\n+\t\tList<String> initializers = new ArrayList<>();\n+\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation links = null;\n+\t\tString license = null;\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 0) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 0. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, requires, \"requires\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, conflicts, \"conflicts\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tmixins = V0ModMetadataParser.readMixins(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"side\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Side must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tswitch (reader.nextString()) {\n+\t\t\t\tcase \"universal\":\n+\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"client\":\n+\t\t\t\t\tenvironment = ModEnvironment.CLIENT;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"server\":\n+\t\t\t\t\tenvironment = ModEnvironment.SERVER;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializer\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializer must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tinitializer = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializers\":\n+\t\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializers must be in a list\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\treader.beginArray();\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Initializer in initializers list must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinitializers.add(reader.nextString());\n+\t\t\t\t}\n+\n+\t\t\t\treader.endArray();\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, recommends, \"recommends\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"links\":\n+\t\t\t\tlinks = V0ModMetadataParser.readLinks(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"License name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tlicense = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t// TODO: Hard fail?\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\t// Optional stuff\n+\t\tif (links == null) {\n+\t\t\tlinks = ContactInformation.EMPTY;\n+\t\t}\n+\n+\t\t// `initializer` and `initializers` cannot be used at the same time\n+\t\tif (initializer != null) {\n+\t\t\tif (!initializers.isEmpty()) {\n+\t\t\t\tthrow new ParseMetadataException(\"initializer and initializers should not be set at the same time! (mod ID '\" + id + \"')\");\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new V0ModMetadata(id, version, requires, conflicts, mixins, environment, initializer, initializers, name, description, recommends, authors, contributors, links, license);\n+\t}\n+\n+\tprivate static ContactInformation readLinks(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\tfinal Map<String, String> contactInfo = new HashMap<>();\n+\n+\t\tswitch (reader.peek()) {\n+\t\tcase STRING:\n+\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n+\t\t\tbreak;\n+\t\tcase BEGIN_OBJECT:\n+\t\t\treader.beginObject();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\tcase \"homepage\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"homepage link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"issues\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"issues link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"issues\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"sources\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"sources link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"sources\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treader.endObject();\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow new ParseMetadataException(\"Expected links to be an object or string\", reader);\n+\t\t}\n+\n+\t\treturn new MapBackedContactInformation(contactInfo);\n+\t}\n+\n+\tprivate static V0ModMetadata.Mixins readMixins(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\tfinal List<String> client = new ArrayList<>();\n+\t\tfinal List<String> common = new ArrayList<>();\n+\t\tfinal List<String> server = new ArrayList<>();\n+\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Expected mixins to be an object.\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"client\":\n+\t\t\t\tclient.addAll(V0ModMetadataParser.readStringArray(reader, \"client\"));\n+\t\t\t\tbreak;\n+\t\t\tcase \"common\":\n+\t\t\t\tcommon.addAll(V0ModMetadataParser.readStringArray(reader, \"common\"));\n+\t\t\t\tbreak;\n+\t\t\tcase \"server\":\n+\t\t\t\tserver.addAll(V0ModMetadataParser.readStringArray(reader, \"server\"));\n+\t\t\t\tbreak;\n+\t\t\t}", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NjA1OQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499956059", "bodyText": "lots of qualified static references here", "author": "sfPlayer1", "createdAt": "2020-10-06T01:22:50Z", "path": "src/main/java/net/fabricmc/loader/metadata/V0ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,430 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V0ModMetadataParser {\n+\tprivate static final Pattern WEBSITE_PATTERN = Pattern.compile(\"\\\\((.+)\\\\)\");\n+\tprivate static final Pattern EMAIL_PATTERN = Pattern.compile(\"<(.+)>\");\n+\n+\tpublic static LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tV0ModMetadata.Mixins mixins = null;\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tString initializer = null;\n+\t\tList<String> initializers = new ArrayList<>();\n+\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation links = null;\n+\t\tString license = null;\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 0) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 0. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, requires, \"requires\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, conflicts, \"conflicts\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tmixins = V0ModMetadataParser.readMixins(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"side\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Side must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tswitch (reader.nextString()) {\n+\t\t\t\tcase \"universal\":\n+\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"client\":\n+\t\t\t\t\tenvironment = ModEnvironment.CLIENT;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"server\":\n+\t\t\t\t\tenvironment = ModEnvironment.SERVER;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializer\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializer must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tinitializer = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializers\":\n+\t\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializers must be in a list\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\treader.beginArray();\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Initializer in initializers list must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinitializers.add(reader.nextString());\n+\t\t\t\t}\n+\n+\t\t\t\treader.endArray();\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, recommends, \"recommends\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"links\":\n+\t\t\t\tlinks = V0ModMetadataParser.readLinks(reader);", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NjY3Nw==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499956677", "bodyText": "this is 2 lines too early", "author": "sfPlayer1", "createdAt": "2020-10-06T01:25:25Z", "path": "src/main/java/net/fabricmc/loader/metadata/V0ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,430 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V0ModMetadataParser {\n+\tprivate static final Pattern WEBSITE_PATTERN = Pattern.compile(\"\\\\((.+)\\\\)\");\n+\tprivate static final Pattern EMAIL_PATTERN = Pattern.compile(\"<(.+)>\");\n+\n+\tpublic static LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tV0ModMetadata.Mixins mixins = null;\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tString initializer = null;\n+\t\tList<String> initializers = new ArrayList<>();\n+\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation links = null;\n+\t\tString license = null;\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 0) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 0. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, requires, \"requires\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, conflicts, \"conflicts\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tmixins = V0ModMetadataParser.readMixins(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"side\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Side must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tswitch (reader.nextString()) {\n+\t\t\t\tcase \"universal\":\n+\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"client\":\n+\t\t\t\t\tenvironment = ModEnvironment.CLIENT;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"server\":\n+\t\t\t\t\tenvironment = ModEnvironment.SERVER;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializer\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializer must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tinitializer = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializers\":\n+\t\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializers must be in a list\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\treader.beginArray();\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Initializer in initializers list must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinitializers.add(reader.nextString());\n+\t\t\t\t}\n+\n+\t\t\t\treader.endArray();\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, recommends, \"recommends\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"links\":\n+\t\t\t\tlinks = V0ModMetadataParser.readLinks(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"License name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tlicense = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t// TODO: Hard fail?\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\t// Optional stuff\n+\t\tif (links == null) {\n+\t\t\tlinks = ContactInformation.EMPTY;\n+\t\t}\n+\n+\t\t// `initializer` and `initializers` cannot be used at the same time\n+\t\tif (initializer != null) {\n+\t\t\tif (!initializers.isEmpty()) {\n+\t\t\t\tthrow new ParseMetadataException(\"initializer and initializers should not be set at the same time! (mod ID '\" + id + \"')\");\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new V0ModMetadata(id, version, requires, conflicts, mixins, environment, initializer, initializers, name, description, recommends, authors, contributors, links, license);\n+\t}\n+\n+\tprivate static ContactInformation readLinks(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\tfinal Map<String, String> contactInfo = new HashMap<>();\n+\n+\t\tswitch (reader.peek()) {\n+\t\tcase STRING:\n+\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n+\t\t\tbreak;\n+\t\tcase BEGIN_OBJECT:\n+\t\t\treader.beginObject();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\tcase \"homepage\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"homepage link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"issues\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"issues link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"issues\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"sources\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"sources link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"sources\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treader.endObject();\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow new ParseMetadataException(\"Expected links to be an object or string\", reader);\n+\t\t}\n+\n+\t\treturn new MapBackedContactInformation(contactInfo);\n+\t}\n+\n+\tprivate static V0ModMetadata.Mixins readMixins(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\tfinal List<String> client = new ArrayList<>();\n+\t\tfinal List<String> common = new ArrayList<>();\n+\t\tfinal List<String> server = new ArrayList<>();\n+\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Expected mixins to be an object.\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"client\":\n+\t\t\t\tclient.addAll(V0ModMetadataParser.readStringArray(reader, \"client\"));\n+\t\t\t\tbreak;\n+\t\t\tcase \"common\":\n+\t\t\t\tcommon.addAll(V0ModMetadataParser.readStringArray(reader, \"common\"));\n+\t\t\t\tbreak;\n+\t\t\tcase \"server\":\n+\t\t\t\tserver.addAll(V0ModMetadataParser.readStringArray(reader, \"server\"));\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\treader.endObject();\n+\t\treturn new V0ModMetadata.Mixins(client, common, server);\n+\t}\n+\n+\tprivate static List<String> readStringArray(JsonReader reader, String key) throws IOException, ParseMetadataException {\n+\t\tswitch (reader.peek()) {\n+\t\tcase NULL:\n+\t\t\treader.nextNull();\n+\t\t\treturn Collections.emptyList();\n+\t\tcase STRING:\n+\t\t\treturn Collections.singletonList(reader.nextString());\n+\t\tcase BEGIN_ARRAY:\n+\t\t\treader.beginArray();\n+\t\t\tfinal List<String> list = new ArrayList<>();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Expected entries in %s to be an array of strings\", key), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tlist.add(reader.nextString());\n+\t\t\t}\n+\n+\t\t\treader.endArray();\n+\t\t\treturn list;\n+\t\tdefault:\n+\t\t\tthrow new ParseMetadataException(String.format(\"Expected %s to be a string or an array of strings\", key), reader);\n+\t\t}\n+\t}\n+\n+\tprivate static void readDependenciesContainer(JsonReader reader, Map<String, ModDependency> dependencies, String name) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(String.format(\"%s must be an object containing dependencies.\", name), reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tfinal String modId = reader.nextName();\n+\t\t\tfinal List<String> versionMatchers = new ArrayList<>();\n+\n+\t\t\tswitch (reader.peek()) {\n+\t\t\tcase STRING:\n+\t\t\t\tversionMatchers.add(reader.nextString());\n+\t\t\t\tbreak;\n+\t\t\tcase BEGIN_ARRAY:\n+\t\t\t\treader.beginArray();\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"List of version requirements must be strings\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tversionMatchers.add(reader.nextString());\n+\t\t\t\t}\n+\n+\t\t\t\treader.endArray();\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new ParseMetadataException(\"Expected version to be a string or array\", reader);\n+\t\t\t}\n+\n+\t\t\treader.endObject();", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1Njg1Mw==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499956853", "bodyText": "missing default case warning", "author": "sfPlayer1", "createdAt": "2020-10-06T01:26:01Z", "path": "src/main/java/net/fabricmc/loader/metadata/V0ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,430 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V0ModMetadataParser {\n+\tprivate static final Pattern WEBSITE_PATTERN = Pattern.compile(\"\\\\((.+)\\\\)\");\n+\tprivate static final Pattern EMAIL_PATTERN = Pattern.compile(\"<(.+)>\");\n+\n+\tpublic static LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tV0ModMetadata.Mixins mixins = null;\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tString initializer = null;\n+\t\tList<String> initializers = new ArrayList<>();\n+\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation links = null;\n+\t\tString license = null;\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 0) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 0. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, requires, \"requires\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, conflicts, \"conflicts\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tmixins = V0ModMetadataParser.readMixins(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"side\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Side must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tswitch (reader.nextString()) {\n+\t\t\t\tcase \"universal\":\n+\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"client\":\n+\t\t\t\t\tenvironment = ModEnvironment.CLIENT;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"server\":\n+\t\t\t\t\tenvironment = ModEnvironment.SERVER;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializer\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializer must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tinitializer = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"initializers\":\n+\t\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Initializers must be in a list\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\treader.beginArray();\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Initializer in initializers list must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tinitializers.add(reader.nextString());\n+\t\t\t\t}\n+\n+\t\t\t\treader.endArray();\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV0ModMetadataParser.readDependenciesContainer(reader, recommends, \"recommends\");\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV0ModMetadataParser.readPeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"links\":\n+\t\t\t\tlinks = V0ModMetadataParser.readLinks(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"License name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tlicense = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t// TODO: Hard fail?\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\t// Optional stuff\n+\t\tif (links == null) {\n+\t\t\tlinks = ContactInformation.EMPTY;\n+\t\t}\n+\n+\t\t// `initializer` and `initializers` cannot be used at the same time\n+\t\tif (initializer != null) {\n+\t\t\tif (!initializers.isEmpty()) {\n+\t\t\t\tthrow new ParseMetadataException(\"initializer and initializers should not be set at the same time! (mod ID '\" + id + \"')\");\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn new V0ModMetadata(id, version, requires, conflicts, mixins, environment, initializer, initializers, name, description, recommends, authors, contributors, links, license);\n+\t}\n+\n+\tprivate static ContactInformation readLinks(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\tfinal Map<String, String> contactInfo = new HashMap<>();\n+\n+\t\tswitch (reader.peek()) {\n+\t\tcase STRING:\n+\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n+\t\t\tbreak;\n+\t\tcase BEGIN_OBJECT:\n+\t\t\treader.beginObject();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\tcase \"homepage\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"homepage link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"homepage\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"issues\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"issues link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"issues\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"sources\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"sources link must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactInfo.put(\"sources\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treader.endObject();\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow new ParseMetadataException(\"Expected links to be an object or string\", reader);\n+\t\t}\n+\n+\t\treturn new MapBackedContactInformation(contactInfo);\n+\t}\n+\n+\tprivate static V0ModMetadata.Mixins readMixins(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\tfinal List<String> client = new ArrayList<>();\n+\t\tfinal List<String> common = new ArrayList<>();\n+\t\tfinal List<String> server = new ArrayList<>();\n+\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Expected mixins to be an object.\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"client\":\n+\t\t\t\tclient.addAll(V0ModMetadataParser.readStringArray(reader, \"client\"));\n+\t\t\t\tbreak;\n+\t\t\tcase \"common\":\n+\t\t\t\tcommon.addAll(V0ModMetadataParser.readStringArray(reader, \"common\"));\n+\t\t\t\tbreak;\n+\t\t\tcase \"server\":\n+\t\t\t\tserver.addAll(V0ModMetadataParser.readStringArray(reader, \"server\"));\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\treader.endObject();\n+\t\treturn new V0ModMetadata.Mixins(client, common, server);\n+\t}\n+\n+\tprivate static List<String> readStringArray(JsonReader reader, String key) throws IOException, ParseMetadataException {\n+\t\tswitch (reader.peek()) {\n+\t\tcase NULL:\n+\t\t\treader.nextNull();\n+\t\t\treturn Collections.emptyList();\n+\t\tcase STRING:\n+\t\t\treturn Collections.singletonList(reader.nextString());\n+\t\tcase BEGIN_ARRAY:\n+\t\t\treader.beginArray();\n+\t\t\tfinal List<String> list = new ArrayList<>();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Expected entries in %s to be an array of strings\", key), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tlist.add(reader.nextString());\n+\t\t\t}\n+\n+\t\t\treader.endArray();\n+\t\t\treturn list;\n+\t\tdefault:\n+\t\t\tthrow new ParseMetadataException(String.format(\"Expected %s to be a string or an array of strings\", key), reader);\n+\t\t}\n+\t}\n+\n+\tprivate static void readDependenciesContainer(JsonReader reader, Map<String, ModDependency> dependencies, String name) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(String.format(\"%s must be an object containing dependencies.\", name), reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tfinal String modId = reader.nextName();\n+\t\t\tfinal List<String> versionMatchers = new ArrayList<>();\n+\n+\t\t\tswitch (reader.peek()) {\n+\t\t\tcase STRING:\n+\t\t\t\tversionMatchers.add(reader.nextString());\n+\t\t\t\tbreak;\n+\t\t\tcase BEGIN_ARRAY:\n+\t\t\t\treader.beginArray();\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"List of version requirements must be strings\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tversionMatchers.add(reader.nextString());\n+\t\t\t\t}\n+\n+\t\t\t\treader.endArray();\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new ParseMetadataException(\"Expected version to be a string or array\", reader);\n+\t\t\t}\n+\n+\t\t\treader.endObject();\n+\t\t\tdependencies.put(modId, new ModDependencyImpl(modId, versionMatchers));\n+\t\t}\n+\t}\n+\n+\tprivate static void readPeople(JsonReader reader, List<Person> people) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\tthrow new ParseMetadataException(\"List of people must be an array\", reader);\n+\t\t}\n+\n+\t\treader.beginArray();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tpeople.add(V0ModMetadataParser.readPerson(reader));\n+\t\t}\n+\n+\t\treader.endArray();\n+\t}\n+\n+\tprivate static Person readPerson(JsonReader reader) throws IOException, ParseMetadataException {\n+\t\tfinal HashMap<String, String> contactMap = new HashMap<>();\n+\t\tString name = \"\";\n+\n+\t\tswitch (reader.peek()) {\n+\t\tcase STRING:\n+\t\t\tfinal String person = reader.nextString();\n+\t\t\tString[] parts = person.split(\" \");\n+\n+\t\t\tMatcher websiteMatcher = V0ModMetadataParser.WEBSITE_PATTERN.matcher(parts[parts.length - 1]);\n+\n+\t\t\tif (websiteMatcher.matches()) {\n+\t\t\t\tcontactMap.put(\"website\", websiteMatcher.group(1));\n+\t\t\t\tparts = Arrays.copyOf(parts, parts.length - 1);\n+\t\t\t}\n+\n+\t\t\tMatcher emailMatcher = V0ModMetadataParser.EMAIL_PATTERN.matcher(parts[parts.length - 1]);\n+\n+\t\t\tif (emailMatcher.matches()) {\n+\t\t\t\tcontactMap.put(\"email\", emailMatcher.group(1));\n+\t\t\t\tparts = Arrays.copyOf(parts, parts.length - 1);\n+\t\t\t}\n+\n+\t\t\tname = String.join(\" \", parts);\n+\n+\t\t\treturn new ContactInfoBackedPerson(name, new MapBackedContactInformation(contactMap));\n+\t\tcase BEGIN_OBJECT:\n+\t\t\treader.beginObject();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\tcase \"name\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tname = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"email\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactMap.put(\"email\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"website\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tcontactMap.put(\"website\", reader.nextString());\n+\t\t\t\t\tbreak;\n+\t\t\t\t}", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzAyMg==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499957022", "bodyText": "warn about unknown ones", "author": "sfPlayer1", "createdAt": "2020-10-06T01:26:50Z", "path": "src/main/java/net/fabricmc/loader/metadata/V1ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.CustomValue;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V1ModMetadataParser {\n+\t/**\n+\t * Reads a {@code fabric.mod.json} file of schema version {@code 1}.\n+\t *\n+\t * @param reader the json reader to read the file with\n+\t * @return the metadata of this file, null if the file could not be parsed\n+\t * @throws IOException         if there was any issue reading the file\n+\t */\n+\tstatic LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException  {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tMap<String, List<EntrypointMetadata>> entrypoints = new HashMap<>();\n+\t\tList<NestedJarEntry> jars = new ArrayList<>();\n+\t\tList<V1ModMetadata.MixinEntry> mixins = new ArrayList<>();\n+\t\tString accessWidener = null;\n+\n+\t\t// Optional (dependency resolution)\n+\t\tMap<String, ModDependency> depends = new HashMap<>();\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tMap<String, ModDependency> suggests = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tMap<String, ModDependency> breaks = new HashMap<>();\n+\n+\t\t// Happy little accidents\n+\t\t@Deprecated\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\n+\t\t// Optional (metadata)\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation contact = null;\n+\t\tList<String> license = new ArrayList<>();\n+\t\tV1ModMetadata.IconEntry icon = null;\n+\n+\t\t// Optional (language adapter providers)\n+\t\tMap<String, String> languageAdapters = new HashMap<>();\n+\n+\t\t// Optional (custom values)\n+\t\tMap<String, CustomValue> customValues = new HashMap<>();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\t// Work our way from required to entirely optional\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 1) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 1. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"environment\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Environment must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"entrypoints\":\n+\t\t\t\tV1ModMetadataParser.readEntrypoints(reader, entrypoints);\n+\t\t\t\tbreak;\n+\t\t\tcase \"jars\":\n+\t\t\t\tV1ModMetadataParser.readNestedJarEntries(reader, jars);\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tV1ModMetadataParser.readMixinConfigs(reader, mixins);\n+\t\t\t\tbreak;\n+\t\t\tcase \"accessWidener\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Access Widener file must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\taccessWidener = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"depends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, depends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, recommends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"suggests\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, suggests);\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, conflicts);\n+\t\t\t\tbreak;\n+\t\t\tcase \"breaks\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, breaks);\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, requires);\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contact\":\n+\t\t\t\tcontact = V1ModMetadataParser.readContactInfo(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tV1ModMetadataParser.readLicense(reader, license);\n+\t\t\t\tbreak;\n+\t\t\tcase \"icon\":\n+\t\t\t\ticon = V1ModMetadataParser.readIcon(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"languageAdapters\":\n+\t\t\t\tV1ModMetadataParser.readLanguageAdapters(reader, languageAdapters);\n+\t\t\t\tbreak;\n+\t\t\tcase \"custom\":\n+\t\t\t\tV1ModMetadataParser.readCustomValues(reader, customValues);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.skipValue();", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzM4Mw==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499957383", "bodyText": "I'd move the above test to where it can actually happen (in the object case above)", "author": "sfPlayer1", "createdAt": "2020-10-06T01:28:23Z", "path": "src/main/java/net/fabricmc/loader/metadata/V1ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.CustomValue;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V1ModMetadataParser {\n+\t/**\n+\t * Reads a {@code fabric.mod.json} file of schema version {@code 1}.\n+\t *\n+\t * @param reader the json reader to read the file with\n+\t * @return the metadata of this file, null if the file could not be parsed\n+\t * @throws IOException         if there was any issue reading the file\n+\t */\n+\tstatic LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException  {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tMap<String, List<EntrypointMetadata>> entrypoints = new HashMap<>();\n+\t\tList<NestedJarEntry> jars = new ArrayList<>();\n+\t\tList<V1ModMetadata.MixinEntry> mixins = new ArrayList<>();\n+\t\tString accessWidener = null;\n+\n+\t\t// Optional (dependency resolution)\n+\t\tMap<String, ModDependency> depends = new HashMap<>();\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tMap<String, ModDependency> suggests = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tMap<String, ModDependency> breaks = new HashMap<>();\n+\n+\t\t// Happy little accidents\n+\t\t@Deprecated\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\n+\t\t// Optional (metadata)\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation contact = null;\n+\t\tList<String> license = new ArrayList<>();\n+\t\tV1ModMetadata.IconEntry icon = null;\n+\n+\t\t// Optional (language adapter providers)\n+\t\tMap<String, String> languageAdapters = new HashMap<>();\n+\n+\t\t// Optional (custom values)\n+\t\tMap<String, CustomValue> customValues = new HashMap<>();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\t// Work our way from required to entirely optional\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 1) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 1. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"environment\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Environment must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"entrypoints\":\n+\t\t\t\tV1ModMetadataParser.readEntrypoints(reader, entrypoints);\n+\t\t\t\tbreak;\n+\t\t\tcase \"jars\":\n+\t\t\t\tV1ModMetadataParser.readNestedJarEntries(reader, jars);\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tV1ModMetadataParser.readMixinConfigs(reader, mixins);\n+\t\t\t\tbreak;\n+\t\t\tcase \"accessWidener\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Access Widener file must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\taccessWidener = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"depends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, depends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, recommends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"suggests\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, suggests);\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, conflicts);\n+\t\t\t\tbreak;\n+\t\t\tcase \"breaks\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, breaks);\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, requires);\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contact\":\n+\t\t\t\tcontact = V1ModMetadataParser.readContactInfo(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tV1ModMetadataParser.readLicense(reader, license);\n+\t\t\t\tbreak;\n+\t\t\tcase \"icon\":\n+\t\t\t\ticon = V1ModMetadataParser.readIcon(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"languageAdapters\":\n+\t\t\t\tV1ModMetadataParser.readLanguageAdapters(reader, languageAdapters);\n+\t\t\t\tbreak;\n+\t\t\tcase \"custom\":\n+\t\t\t\tV1ModMetadataParser.readCustomValues(reader, customValues);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\treturn new V1ModMetadata(id, version, environment, entrypoints, jars, mixins, accessWidener, depends, recommends, suggests, conflicts, breaks, requires, name, description, authors, contributors, contact, license, icon, languageAdapters, customValues);\n+\t}\n+\n+\tprivate static ModEnvironment readEnvironment(JsonReader reader) throws ParseMetadataException, IOException {\n+\t\tfinal String environment = reader.nextString().toLowerCase(Locale.ROOT);\n+\n+\t\tif (environment.isEmpty() || environment.equals(\"*\")) {\n+\t\t\treturn ModEnvironment.UNIVERSAL;\n+\t\t} else if (environment.equals(\"client\")) {\n+\t\t\treturn ModEnvironment.CLIENT;\n+\t\t} else if (environment.equals(\"server\")) {\n+\t\t\treturn ModEnvironment.SERVER;\n+\t\t} else {\n+\t\t\tthrow new ParseMetadataException(\"Invalid environment type: \" + environment + \"!\", reader);\n+\t\t}\n+\t}\n+\n+\tprivate static void readEntrypoints(JsonReader reader, Map<String, List<EntrypointMetadata>> entrypoints) throws IOException, ParseMetadataException {\n+\t\t// Entrypoints must be an object\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Entrypoints must be an object\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tfinal String key = reader.nextName();\n+\n+\t\t\tList<EntrypointMetadata> metadata = new ArrayList<>();\n+\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\tthrow new ParseMetadataException(\"Entrypoint list must be an array!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginArray();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tString adapter = \"default\";\n+\t\t\t\tString value = null;\n+\n+\t\t\t\t// Entrypoints may be specified directly as a string or as an object to allow specification of the language adapter to use.\n+\t\t\t\tswitch (reader.peek()) {\n+\t\t\t\tcase STRING:\n+\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\t\tcase \"adapter\":\n+\t\t\t\t\t\t\tadapter = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tcase \"value\":\n+\t\t\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tdefault: // TODO: Ignore invalid elements in the entrypoint object?\n+\t\t\t\t\t\t\treader.skipValue();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.endObject();\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new ParseMetadataException(\"Entrypoint must be a string or object with \\\"value\\\" field\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tif (value == null) {\n+\t\t\t\t\tthrow new ParseMetadataException.MissingRequired(\"Entrypoint value must be present\");\n+\t\t\t\t}", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzUxNA==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499957514", "bodyText": "warn?", "author": "sfPlayer1", "createdAt": "2020-10-06T01:28:51Z", "path": "src/main/java/net/fabricmc/loader/metadata/V1ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.CustomValue;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V1ModMetadataParser {\n+\t/**\n+\t * Reads a {@code fabric.mod.json} file of schema version {@code 1}.\n+\t *\n+\t * @param reader the json reader to read the file with\n+\t * @return the metadata of this file, null if the file could not be parsed\n+\t * @throws IOException         if there was any issue reading the file\n+\t */\n+\tstatic LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException  {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tMap<String, List<EntrypointMetadata>> entrypoints = new HashMap<>();\n+\t\tList<NestedJarEntry> jars = new ArrayList<>();\n+\t\tList<V1ModMetadata.MixinEntry> mixins = new ArrayList<>();\n+\t\tString accessWidener = null;\n+\n+\t\t// Optional (dependency resolution)\n+\t\tMap<String, ModDependency> depends = new HashMap<>();\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tMap<String, ModDependency> suggests = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tMap<String, ModDependency> breaks = new HashMap<>();\n+\n+\t\t// Happy little accidents\n+\t\t@Deprecated\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\n+\t\t// Optional (metadata)\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation contact = null;\n+\t\tList<String> license = new ArrayList<>();\n+\t\tV1ModMetadata.IconEntry icon = null;\n+\n+\t\t// Optional (language adapter providers)\n+\t\tMap<String, String> languageAdapters = new HashMap<>();\n+\n+\t\t// Optional (custom values)\n+\t\tMap<String, CustomValue> customValues = new HashMap<>();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\t// Work our way from required to entirely optional\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 1) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 1. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"environment\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Environment must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"entrypoints\":\n+\t\t\t\tV1ModMetadataParser.readEntrypoints(reader, entrypoints);\n+\t\t\t\tbreak;\n+\t\t\tcase \"jars\":\n+\t\t\t\tV1ModMetadataParser.readNestedJarEntries(reader, jars);\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tV1ModMetadataParser.readMixinConfigs(reader, mixins);\n+\t\t\t\tbreak;\n+\t\t\tcase \"accessWidener\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Access Widener file must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\taccessWidener = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"depends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, depends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, recommends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"suggests\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, suggests);\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, conflicts);\n+\t\t\t\tbreak;\n+\t\t\tcase \"breaks\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, breaks);\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, requires);\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contact\":\n+\t\t\t\tcontact = V1ModMetadataParser.readContactInfo(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tV1ModMetadataParser.readLicense(reader, license);\n+\t\t\t\tbreak;\n+\t\t\tcase \"icon\":\n+\t\t\t\ticon = V1ModMetadataParser.readIcon(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"languageAdapters\":\n+\t\t\t\tV1ModMetadataParser.readLanguageAdapters(reader, languageAdapters);\n+\t\t\t\tbreak;\n+\t\t\tcase \"custom\":\n+\t\t\t\tV1ModMetadataParser.readCustomValues(reader, customValues);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\treturn new V1ModMetadata(id, version, environment, entrypoints, jars, mixins, accessWidener, depends, recommends, suggests, conflicts, breaks, requires, name, description, authors, contributors, contact, license, icon, languageAdapters, customValues);\n+\t}\n+\n+\tprivate static ModEnvironment readEnvironment(JsonReader reader) throws ParseMetadataException, IOException {\n+\t\tfinal String environment = reader.nextString().toLowerCase(Locale.ROOT);\n+\n+\t\tif (environment.isEmpty() || environment.equals(\"*\")) {\n+\t\t\treturn ModEnvironment.UNIVERSAL;\n+\t\t} else if (environment.equals(\"client\")) {\n+\t\t\treturn ModEnvironment.CLIENT;\n+\t\t} else if (environment.equals(\"server\")) {\n+\t\t\treturn ModEnvironment.SERVER;\n+\t\t} else {\n+\t\t\tthrow new ParseMetadataException(\"Invalid environment type: \" + environment + \"!\", reader);\n+\t\t}\n+\t}\n+\n+\tprivate static void readEntrypoints(JsonReader reader, Map<String, List<EntrypointMetadata>> entrypoints) throws IOException, ParseMetadataException {\n+\t\t// Entrypoints must be an object\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Entrypoints must be an object\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tfinal String key = reader.nextName();\n+\n+\t\t\tList<EntrypointMetadata> metadata = new ArrayList<>();\n+\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\tthrow new ParseMetadataException(\"Entrypoint list must be an array!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginArray();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tString adapter = \"default\";\n+\t\t\t\tString value = null;\n+\n+\t\t\t\t// Entrypoints may be specified directly as a string or as an object to allow specification of the language adapter to use.\n+\t\t\t\tswitch (reader.peek()) {\n+\t\t\t\tcase STRING:\n+\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\t\tcase \"adapter\":\n+\t\t\t\t\t\t\tadapter = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tcase \"value\":\n+\t\t\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tdefault: // TODO: Ignore invalid elements in the entrypoint object?\n+\t\t\t\t\t\t\treader.skipValue();", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzU3NQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499957575", "bodyText": "warn?", "author": "sfPlayer1", "createdAt": "2020-10-06T01:29:09Z", "path": "src/main/java/net/fabricmc/loader/metadata/V1ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.CustomValue;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V1ModMetadataParser {\n+\t/**\n+\t * Reads a {@code fabric.mod.json} file of schema version {@code 1}.\n+\t *\n+\t * @param reader the json reader to read the file with\n+\t * @return the metadata of this file, null if the file could not be parsed\n+\t * @throws IOException         if there was any issue reading the file\n+\t */\n+\tstatic LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException  {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tMap<String, List<EntrypointMetadata>> entrypoints = new HashMap<>();\n+\t\tList<NestedJarEntry> jars = new ArrayList<>();\n+\t\tList<V1ModMetadata.MixinEntry> mixins = new ArrayList<>();\n+\t\tString accessWidener = null;\n+\n+\t\t// Optional (dependency resolution)\n+\t\tMap<String, ModDependency> depends = new HashMap<>();\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tMap<String, ModDependency> suggests = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tMap<String, ModDependency> breaks = new HashMap<>();\n+\n+\t\t// Happy little accidents\n+\t\t@Deprecated\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\n+\t\t// Optional (metadata)\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation contact = null;\n+\t\tList<String> license = new ArrayList<>();\n+\t\tV1ModMetadata.IconEntry icon = null;\n+\n+\t\t// Optional (language adapter providers)\n+\t\tMap<String, String> languageAdapters = new HashMap<>();\n+\n+\t\t// Optional (custom values)\n+\t\tMap<String, CustomValue> customValues = new HashMap<>();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\t// Work our way from required to entirely optional\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 1) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 1. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"environment\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Environment must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"entrypoints\":\n+\t\t\t\tV1ModMetadataParser.readEntrypoints(reader, entrypoints);\n+\t\t\t\tbreak;\n+\t\t\tcase \"jars\":\n+\t\t\t\tV1ModMetadataParser.readNestedJarEntries(reader, jars);\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tV1ModMetadataParser.readMixinConfigs(reader, mixins);\n+\t\t\t\tbreak;\n+\t\t\tcase \"accessWidener\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Access Widener file must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\taccessWidener = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"depends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, depends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, recommends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"suggests\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, suggests);\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, conflicts);\n+\t\t\t\tbreak;\n+\t\t\tcase \"breaks\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, breaks);\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, requires);\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contact\":\n+\t\t\t\tcontact = V1ModMetadataParser.readContactInfo(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tV1ModMetadataParser.readLicense(reader, license);\n+\t\t\t\tbreak;\n+\t\t\tcase \"icon\":\n+\t\t\t\ticon = V1ModMetadataParser.readIcon(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"languageAdapters\":\n+\t\t\t\tV1ModMetadataParser.readLanguageAdapters(reader, languageAdapters);\n+\t\t\t\tbreak;\n+\t\t\tcase \"custom\":\n+\t\t\t\tV1ModMetadataParser.readCustomValues(reader, customValues);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\treturn new V1ModMetadata(id, version, environment, entrypoints, jars, mixins, accessWidener, depends, recommends, suggests, conflicts, breaks, requires, name, description, authors, contributors, contact, license, icon, languageAdapters, customValues);\n+\t}\n+\n+\tprivate static ModEnvironment readEnvironment(JsonReader reader) throws ParseMetadataException, IOException {\n+\t\tfinal String environment = reader.nextString().toLowerCase(Locale.ROOT);\n+\n+\t\tif (environment.isEmpty() || environment.equals(\"*\")) {\n+\t\t\treturn ModEnvironment.UNIVERSAL;\n+\t\t} else if (environment.equals(\"client\")) {\n+\t\t\treturn ModEnvironment.CLIENT;\n+\t\t} else if (environment.equals(\"server\")) {\n+\t\t\treturn ModEnvironment.SERVER;\n+\t\t} else {\n+\t\t\tthrow new ParseMetadataException(\"Invalid environment type: \" + environment + \"!\", reader);\n+\t\t}\n+\t}\n+\n+\tprivate static void readEntrypoints(JsonReader reader, Map<String, List<EntrypointMetadata>> entrypoints) throws IOException, ParseMetadataException {\n+\t\t// Entrypoints must be an object\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Entrypoints must be an object\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tfinal String key = reader.nextName();\n+\n+\t\t\tList<EntrypointMetadata> metadata = new ArrayList<>();\n+\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\tthrow new ParseMetadataException(\"Entrypoint list must be an array!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginArray();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tString adapter = \"default\";\n+\t\t\t\tString value = null;\n+\n+\t\t\t\t// Entrypoints may be specified directly as a string or as an object to allow specification of the language adapter to use.\n+\t\t\t\tswitch (reader.peek()) {\n+\t\t\t\tcase STRING:\n+\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\t\tcase \"adapter\":\n+\t\t\t\t\t\t\tadapter = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tcase \"value\":\n+\t\t\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tdefault: // TODO: Ignore invalid elements in the entrypoint object?\n+\t\t\t\t\t\t\treader.skipValue();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.endObject();\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new ParseMetadataException(\"Entrypoint must be a string or object with \\\"value\\\" field\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tif (value == null) {\n+\t\t\t\t\tthrow new ParseMetadataException.MissingRequired(\"Entrypoint value must be present\");\n+\t\t\t\t}\n+\n+\t\t\t\tmetadata.add(new V1ModMetadata.EntrypointMetadataImpl(adapter, value));\n+\t\t\t}\n+\n+\t\t\treader.endArray();\n+\n+\t\t\t// Empty arrays are acceptable, do not check if the List of metadata is empty\n+\t\t\tentrypoints.put(key, metadata);\n+\t\t}\n+\n+\t\treader.endObject();\n+\t}\n+\n+\tprivate static void readNestedJarEntries(JsonReader reader, List<NestedJarEntry> jars) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\tthrow new ParseMetadataException(\"Jar entries must be in an array\", reader);\n+\t\t}\n+\n+\t\treader.beginArray();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\t\tthrow new ParseMetadataException(\"Invalid type for JAR entry!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginObject();\n+\t\t\tString file = null;\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tif (reader.nextName().equals(\"file\")) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"file\\\" entry in jar object must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tfile = reader.nextString();\n+\t\t\t\t} else {\n+\t\t\t\t\treader.skipValue();", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzY1Nw==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499957657", "bodyText": "warn? error?", "author": "sfPlayer1", "createdAt": "2020-10-06T01:29:34Z", "path": "src/main/java/net/fabricmc/loader/metadata/V1ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.CustomValue;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V1ModMetadataParser {\n+\t/**\n+\t * Reads a {@code fabric.mod.json} file of schema version {@code 1}.\n+\t *\n+\t * @param reader the json reader to read the file with\n+\t * @return the metadata of this file, null if the file could not be parsed\n+\t * @throws IOException         if there was any issue reading the file\n+\t */\n+\tstatic LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException  {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tMap<String, List<EntrypointMetadata>> entrypoints = new HashMap<>();\n+\t\tList<NestedJarEntry> jars = new ArrayList<>();\n+\t\tList<V1ModMetadata.MixinEntry> mixins = new ArrayList<>();\n+\t\tString accessWidener = null;\n+\n+\t\t// Optional (dependency resolution)\n+\t\tMap<String, ModDependency> depends = new HashMap<>();\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tMap<String, ModDependency> suggests = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tMap<String, ModDependency> breaks = new HashMap<>();\n+\n+\t\t// Happy little accidents\n+\t\t@Deprecated\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\n+\t\t// Optional (metadata)\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation contact = null;\n+\t\tList<String> license = new ArrayList<>();\n+\t\tV1ModMetadata.IconEntry icon = null;\n+\n+\t\t// Optional (language adapter providers)\n+\t\tMap<String, String> languageAdapters = new HashMap<>();\n+\n+\t\t// Optional (custom values)\n+\t\tMap<String, CustomValue> customValues = new HashMap<>();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\t// Work our way from required to entirely optional\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 1) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 1. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"environment\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Environment must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"entrypoints\":\n+\t\t\t\tV1ModMetadataParser.readEntrypoints(reader, entrypoints);\n+\t\t\t\tbreak;\n+\t\t\tcase \"jars\":\n+\t\t\t\tV1ModMetadataParser.readNestedJarEntries(reader, jars);\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tV1ModMetadataParser.readMixinConfigs(reader, mixins);\n+\t\t\t\tbreak;\n+\t\t\tcase \"accessWidener\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Access Widener file must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\taccessWidener = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"depends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, depends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, recommends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"suggests\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, suggests);\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, conflicts);\n+\t\t\t\tbreak;\n+\t\t\tcase \"breaks\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, breaks);\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, requires);\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contact\":\n+\t\t\t\tcontact = V1ModMetadataParser.readContactInfo(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tV1ModMetadataParser.readLicense(reader, license);\n+\t\t\t\tbreak;\n+\t\t\tcase \"icon\":\n+\t\t\t\ticon = V1ModMetadataParser.readIcon(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"languageAdapters\":\n+\t\t\t\tV1ModMetadataParser.readLanguageAdapters(reader, languageAdapters);\n+\t\t\t\tbreak;\n+\t\t\tcase \"custom\":\n+\t\t\t\tV1ModMetadataParser.readCustomValues(reader, customValues);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\treturn new V1ModMetadata(id, version, environment, entrypoints, jars, mixins, accessWidener, depends, recommends, suggests, conflicts, breaks, requires, name, description, authors, contributors, contact, license, icon, languageAdapters, customValues);\n+\t}\n+\n+\tprivate static ModEnvironment readEnvironment(JsonReader reader) throws ParseMetadataException, IOException {\n+\t\tfinal String environment = reader.nextString().toLowerCase(Locale.ROOT);\n+\n+\t\tif (environment.isEmpty() || environment.equals(\"*\")) {\n+\t\t\treturn ModEnvironment.UNIVERSAL;\n+\t\t} else if (environment.equals(\"client\")) {\n+\t\t\treturn ModEnvironment.CLIENT;\n+\t\t} else if (environment.equals(\"server\")) {\n+\t\t\treturn ModEnvironment.SERVER;\n+\t\t} else {\n+\t\t\tthrow new ParseMetadataException(\"Invalid environment type: \" + environment + \"!\", reader);\n+\t\t}\n+\t}\n+\n+\tprivate static void readEntrypoints(JsonReader reader, Map<String, List<EntrypointMetadata>> entrypoints) throws IOException, ParseMetadataException {\n+\t\t// Entrypoints must be an object\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Entrypoints must be an object\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tfinal String key = reader.nextName();\n+\n+\t\t\tList<EntrypointMetadata> metadata = new ArrayList<>();\n+\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\tthrow new ParseMetadataException(\"Entrypoint list must be an array!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginArray();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tString adapter = \"default\";\n+\t\t\t\tString value = null;\n+\n+\t\t\t\t// Entrypoints may be specified directly as a string or as an object to allow specification of the language adapter to use.\n+\t\t\t\tswitch (reader.peek()) {\n+\t\t\t\tcase STRING:\n+\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\t\tcase \"adapter\":\n+\t\t\t\t\t\t\tadapter = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tcase \"value\":\n+\t\t\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tdefault: // TODO: Ignore invalid elements in the entrypoint object?\n+\t\t\t\t\t\t\treader.skipValue();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.endObject();\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new ParseMetadataException(\"Entrypoint must be a string or object with \\\"value\\\" field\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tif (value == null) {\n+\t\t\t\t\tthrow new ParseMetadataException.MissingRequired(\"Entrypoint value must be present\");\n+\t\t\t\t}\n+\n+\t\t\t\tmetadata.add(new V1ModMetadata.EntrypointMetadataImpl(adapter, value));\n+\t\t\t}\n+\n+\t\t\treader.endArray();\n+\n+\t\t\t// Empty arrays are acceptable, do not check if the List of metadata is empty\n+\t\t\tentrypoints.put(key, metadata);\n+\t\t}\n+\n+\t\treader.endObject();\n+\t}\n+\n+\tprivate static void readNestedJarEntries(JsonReader reader, List<NestedJarEntry> jars) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\tthrow new ParseMetadataException(\"Jar entries must be in an array\", reader);\n+\t\t}\n+\n+\t\treader.beginArray();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\t\tthrow new ParseMetadataException(\"Invalid type for JAR entry!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginObject();\n+\t\t\tString file = null;\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tif (reader.nextName().equals(\"file\")) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"file\\\" entry in jar object must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tfile = reader.nextString();\n+\t\t\t\t} else {\n+\t\t\t\t\treader.skipValue();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treader.endObject();\n+\n+\t\t\tif (file == null) {\n+\t\t\t\tthrow new ParseMetadataException(\"Missing mandatory key 'file' in JAR entry!\", reader);\n+\t\t\t}\n+\n+\t\t\tjars.add(new V1ModMetadata.JarEntry(file));\n+\t\t}\n+\n+\t\treader.endArray();\n+\t}\n+\n+\tprivate static void readMixinConfigs(JsonReader reader, List<V1ModMetadata.MixinEntry> mixins) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\tthrow new ParseMetadataException(\"Mixin configs must be in an array\", reader);\n+\t\t}\n+\n+\t\treader.beginArray();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.peek()) {\n+\t\t\tcase STRING:\n+\t\t\t\t// All mixin configs specified via string are assumed to be universal\n+\t\t\t\tmixins.add(new V1ModMetadata.MixinEntry(reader.nextString(), ModEnvironment.UNIVERSAL));\n+\t\t\t\tbreak;\n+\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\treader.beginObject();\n+\n+\t\t\t\tString config = null;\n+\t\t\t\tModEnvironment environment = null;\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\t// Environment is optional\n+\t\t\t\t\tcase \"environment\":\n+\t\t\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase \"config\":\n+\t\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t\tthrow new ParseMetadataException(\"Value of \\\"config\\\" must be a string\", reader);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tconfig = reader.nextString();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treader.endObject();\n+\n+\t\t\t\tif (environment == null) {\n+\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL; // Default to universal\n+\t\t\t\t}\n+\n+\t\t\t\tif (config == null) {\n+\t\t\t\t\tthrow new ParseMetadataException.MissingRequired(\"Missing mandatory key 'config' in mixin entry!\");\n+\t\t\t\t}\n+\n+\t\t\t\tmixins.add(new V1ModMetadata.MixinEntry(config, environment));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.skipValue();", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzY5Mg==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499957692", "bodyText": "warn for default case", "author": "sfPlayer1", "createdAt": "2020-10-06T01:29:43Z", "path": "src/main/java/net/fabricmc/loader/metadata/V1ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.CustomValue;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V1ModMetadataParser {\n+\t/**\n+\t * Reads a {@code fabric.mod.json} file of schema version {@code 1}.\n+\t *\n+\t * @param reader the json reader to read the file with\n+\t * @return the metadata of this file, null if the file could not be parsed\n+\t * @throws IOException         if there was any issue reading the file\n+\t */\n+\tstatic LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException  {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tMap<String, List<EntrypointMetadata>> entrypoints = new HashMap<>();\n+\t\tList<NestedJarEntry> jars = new ArrayList<>();\n+\t\tList<V1ModMetadata.MixinEntry> mixins = new ArrayList<>();\n+\t\tString accessWidener = null;\n+\n+\t\t// Optional (dependency resolution)\n+\t\tMap<String, ModDependency> depends = new HashMap<>();\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tMap<String, ModDependency> suggests = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tMap<String, ModDependency> breaks = new HashMap<>();\n+\n+\t\t// Happy little accidents\n+\t\t@Deprecated\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\n+\t\t// Optional (metadata)\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation contact = null;\n+\t\tList<String> license = new ArrayList<>();\n+\t\tV1ModMetadata.IconEntry icon = null;\n+\n+\t\t// Optional (language adapter providers)\n+\t\tMap<String, String> languageAdapters = new HashMap<>();\n+\n+\t\t// Optional (custom values)\n+\t\tMap<String, CustomValue> customValues = new HashMap<>();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\t// Work our way from required to entirely optional\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 1) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 1. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"environment\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Environment must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"entrypoints\":\n+\t\t\t\tV1ModMetadataParser.readEntrypoints(reader, entrypoints);\n+\t\t\t\tbreak;\n+\t\t\tcase \"jars\":\n+\t\t\t\tV1ModMetadataParser.readNestedJarEntries(reader, jars);\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tV1ModMetadataParser.readMixinConfigs(reader, mixins);\n+\t\t\t\tbreak;\n+\t\t\tcase \"accessWidener\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Access Widener file must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\taccessWidener = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"depends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, depends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, recommends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"suggests\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, suggests);\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, conflicts);\n+\t\t\t\tbreak;\n+\t\t\tcase \"breaks\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, breaks);\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, requires);\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contact\":\n+\t\t\t\tcontact = V1ModMetadataParser.readContactInfo(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tV1ModMetadataParser.readLicense(reader, license);\n+\t\t\t\tbreak;\n+\t\t\tcase \"icon\":\n+\t\t\t\ticon = V1ModMetadataParser.readIcon(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"languageAdapters\":\n+\t\t\t\tV1ModMetadataParser.readLanguageAdapters(reader, languageAdapters);\n+\t\t\t\tbreak;\n+\t\t\tcase \"custom\":\n+\t\t\t\tV1ModMetadataParser.readCustomValues(reader, customValues);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\treturn new V1ModMetadata(id, version, environment, entrypoints, jars, mixins, accessWidener, depends, recommends, suggests, conflicts, breaks, requires, name, description, authors, contributors, contact, license, icon, languageAdapters, customValues);\n+\t}\n+\n+\tprivate static ModEnvironment readEnvironment(JsonReader reader) throws ParseMetadataException, IOException {\n+\t\tfinal String environment = reader.nextString().toLowerCase(Locale.ROOT);\n+\n+\t\tif (environment.isEmpty() || environment.equals(\"*\")) {\n+\t\t\treturn ModEnvironment.UNIVERSAL;\n+\t\t} else if (environment.equals(\"client\")) {\n+\t\t\treturn ModEnvironment.CLIENT;\n+\t\t} else if (environment.equals(\"server\")) {\n+\t\t\treturn ModEnvironment.SERVER;\n+\t\t} else {\n+\t\t\tthrow new ParseMetadataException(\"Invalid environment type: \" + environment + \"!\", reader);\n+\t\t}\n+\t}\n+\n+\tprivate static void readEntrypoints(JsonReader reader, Map<String, List<EntrypointMetadata>> entrypoints) throws IOException, ParseMetadataException {\n+\t\t// Entrypoints must be an object\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Entrypoints must be an object\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tfinal String key = reader.nextName();\n+\n+\t\t\tList<EntrypointMetadata> metadata = new ArrayList<>();\n+\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\tthrow new ParseMetadataException(\"Entrypoint list must be an array!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginArray();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tString adapter = \"default\";\n+\t\t\t\tString value = null;\n+\n+\t\t\t\t// Entrypoints may be specified directly as a string or as an object to allow specification of the language adapter to use.\n+\t\t\t\tswitch (reader.peek()) {\n+\t\t\t\tcase STRING:\n+\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\t\tcase \"adapter\":\n+\t\t\t\t\t\t\tadapter = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tcase \"value\":\n+\t\t\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tdefault: // TODO: Ignore invalid elements in the entrypoint object?\n+\t\t\t\t\t\t\treader.skipValue();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.endObject();\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new ParseMetadataException(\"Entrypoint must be a string or object with \\\"value\\\" field\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tif (value == null) {\n+\t\t\t\t\tthrow new ParseMetadataException.MissingRequired(\"Entrypoint value must be present\");\n+\t\t\t\t}\n+\n+\t\t\t\tmetadata.add(new V1ModMetadata.EntrypointMetadataImpl(adapter, value));\n+\t\t\t}\n+\n+\t\t\treader.endArray();\n+\n+\t\t\t// Empty arrays are acceptable, do not check if the List of metadata is empty\n+\t\t\tentrypoints.put(key, metadata);\n+\t\t}\n+\n+\t\treader.endObject();\n+\t}\n+\n+\tprivate static void readNestedJarEntries(JsonReader reader, List<NestedJarEntry> jars) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\tthrow new ParseMetadataException(\"Jar entries must be in an array\", reader);\n+\t\t}\n+\n+\t\treader.beginArray();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\t\tthrow new ParseMetadataException(\"Invalid type for JAR entry!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginObject();\n+\t\t\tString file = null;\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tif (reader.nextName().equals(\"file\")) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"file\\\" entry in jar object must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tfile = reader.nextString();\n+\t\t\t\t} else {\n+\t\t\t\t\treader.skipValue();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treader.endObject();\n+\n+\t\t\tif (file == null) {\n+\t\t\t\tthrow new ParseMetadataException(\"Missing mandatory key 'file' in JAR entry!\", reader);\n+\t\t\t}\n+\n+\t\t\tjars.add(new V1ModMetadata.JarEntry(file));\n+\t\t}\n+\n+\t\treader.endArray();\n+\t}\n+\n+\tprivate static void readMixinConfigs(JsonReader reader, List<V1ModMetadata.MixinEntry> mixins) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\tthrow new ParseMetadataException(\"Mixin configs must be in an array\", reader);\n+\t\t}\n+\n+\t\treader.beginArray();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.peek()) {\n+\t\t\tcase STRING:\n+\t\t\t\t// All mixin configs specified via string are assumed to be universal\n+\t\t\t\tmixins.add(new V1ModMetadata.MixinEntry(reader.nextString(), ModEnvironment.UNIVERSAL));\n+\t\t\t\tbreak;\n+\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\treader.beginObject();\n+\n+\t\t\t\tString config = null;\n+\t\t\t\tModEnvironment environment = null;\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\t// Environment is optional\n+\t\t\t\t\tcase \"environment\":\n+\t\t\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase \"config\":\n+\t\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t\tthrow new ParseMetadataException(\"Value of \\\"config\\\" must be a string\", reader);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tconfig = reader.nextString();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzgxNQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r499957815", "bodyText": "warn?", "author": "sfPlayer1", "createdAt": "2020-10-06T01:30:14Z", "path": "src/main/java/net/fabricmc/loader/metadata/V1ModMetadataParser.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.metadata;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import net.fabricmc.loader.api.Version;\n+import net.fabricmc.loader.api.VersionParsingException;\n+import net.fabricmc.loader.api.metadata.ContactInformation;\n+import net.fabricmc.loader.api.metadata.CustomValue;\n+import net.fabricmc.loader.api.metadata.ModDependency;\n+import net.fabricmc.loader.api.metadata.ModEnvironment;\n+import net.fabricmc.loader.api.metadata.Person;\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+import net.fabricmc.loader.util.version.VersionDeserializer;\n+\n+final class V1ModMetadataParser {\n+\t/**\n+\t * Reads a {@code fabric.mod.json} file of schema version {@code 1}.\n+\t *\n+\t * @param reader the json reader to read the file with\n+\t * @return the metadata of this file, null if the file could not be parsed\n+\t * @throws IOException         if there was any issue reading the file\n+\t */\n+\tstatic LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException  {\n+\t\t// All the values the `fabric.mod.json` may contain:\n+\t\t// Required\n+\t\tString id = null;\n+\t\tVersion version = null;\n+\n+\t\t// Optional (mod loading)\n+\t\tModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal\n+\t\tMap<String, List<EntrypointMetadata>> entrypoints = new HashMap<>();\n+\t\tList<NestedJarEntry> jars = new ArrayList<>();\n+\t\tList<V1ModMetadata.MixinEntry> mixins = new ArrayList<>();\n+\t\tString accessWidener = null;\n+\n+\t\t// Optional (dependency resolution)\n+\t\tMap<String, ModDependency> depends = new HashMap<>();\n+\t\tMap<String, ModDependency> recommends = new HashMap<>();\n+\t\tMap<String, ModDependency> suggests = new HashMap<>();\n+\t\tMap<String, ModDependency> conflicts = new HashMap<>();\n+\t\tMap<String, ModDependency> breaks = new HashMap<>();\n+\n+\t\t// Happy little accidents\n+\t\t@Deprecated\n+\t\tMap<String, ModDependency> requires = new HashMap<>();\n+\n+\t\t// Optional (metadata)\n+\t\tString name = null;\n+\t\tString description = null;\n+\t\tList<Person> authors = new ArrayList<>();\n+\t\tList<Person> contributors = new ArrayList<>();\n+\t\tContactInformation contact = null;\n+\t\tList<String> license = new ArrayList<>();\n+\t\tV1ModMetadata.IconEntry icon = null;\n+\n+\t\t// Optional (language adapter providers)\n+\t\tMap<String, String> languageAdapters = new HashMap<>();\n+\n+\t\t// Optional (custom values)\n+\t\tMap<String, CustomValue> customValues = new HashMap<>();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\t// Work our way from required to entirely optional\n+\t\t\tswitch (reader.nextName()) {\n+\t\t\tcase \"schemaVersion\":\n+\t\t\t\t// Duplicate field, make sure it matches our current schema version\n+\t\t\t\tif (reader.peek() != JsonToken.NUMBER) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Duplicate \\\"schemaVersion\\\" field is not a number\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tfinal int read = reader.nextInt();\n+\n+\t\t\t\tif (read != 1) {\n+\t\t\t\t\tthrow new ParseMetadataException(String.format(\"Duplicate \\\"schemaVersion\\\" field does not match the predicted schema version of 1. Duplicate field value is %s\", read), reader);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"id\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod id must be a non-empty string with a length of 3-64 characters.\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tid = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"version\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Version must be a non-empty string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\ttry {\n+\t\t\t\t\tversion = VersionDeserializer.deserialize(reader.nextString());\n+\t\t\t\t} catch (VersionParsingException e) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Failed to parse version\", e);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"environment\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Environment must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"entrypoints\":\n+\t\t\t\tV1ModMetadataParser.readEntrypoints(reader, entrypoints);\n+\t\t\t\tbreak;\n+\t\t\tcase \"jars\":\n+\t\t\t\tV1ModMetadataParser.readNestedJarEntries(reader, jars);\n+\t\t\t\tbreak;\n+\t\t\tcase \"mixins\":\n+\t\t\t\tV1ModMetadataParser.readMixinConfigs(reader, mixins);\n+\t\t\t\tbreak;\n+\t\t\tcase \"accessWidener\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Access Widener file must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\taccessWidener = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"depends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, depends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"recommends\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, recommends);\n+\t\t\t\tbreak;\n+\t\t\tcase \"suggests\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, suggests);\n+\t\t\t\tbreak;\n+\t\t\tcase \"conflicts\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, conflicts);\n+\t\t\t\tbreak;\n+\t\t\tcase \"breaks\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, breaks);\n+\t\t\t\tbreak;\n+\t\t\tcase \"requires\":\n+\t\t\t\tV1ModMetadataParser.readDependenciesContainer(reader, requires);\n+\t\t\t\tbreak;\n+\t\t\tcase \"name\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod name must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tname = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"description\":\n+\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\tthrow new ParseMetadataException(\"Mod description must be a string\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tdescription = reader.nextString();\n+\t\t\t\tbreak;\n+\t\t\tcase \"authors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, authors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contributors\":\n+\t\t\t\tV1ModMetadataParser.parsePeople(reader, contributors);\n+\t\t\t\tbreak;\n+\t\t\tcase \"contact\":\n+\t\t\t\tcontact = V1ModMetadataParser.readContactInfo(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"license\":\n+\t\t\t\tV1ModMetadataParser.readLicense(reader, license);\n+\t\t\t\tbreak;\n+\t\t\tcase \"icon\":\n+\t\t\t\ticon = V1ModMetadataParser.readIcon(reader);\n+\t\t\t\tbreak;\n+\t\t\tcase \"languageAdapters\":\n+\t\t\t\tV1ModMetadataParser.readLanguageAdapters(reader, languageAdapters);\n+\t\t\t\tbreak;\n+\t\t\tcase \"custom\":\n+\t\t\t\tV1ModMetadataParser.readCustomValues(reader, customValues);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Finally close off the object\n+\t\treader.endObject();\n+\n+\t\t// Validate all required fields are resolved\n+\t\tif (id == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"id\");\n+\t\t}\n+\n+\t\tif (version == null) {\n+\t\t\tthrow new ParseMetadataException.MissingRequired(\"version\");\n+\t\t}\n+\n+\t\treturn new V1ModMetadata(id, version, environment, entrypoints, jars, mixins, accessWidener, depends, recommends, suggests, conflicts, breaks, requires, name, description, authors, contributors, contact, license, icon, languageAdapters, customValues);\n+\t}\n+\n+\tprivate static ModEnvironment readEnvironment(JsonReader reader) throws ParseMetadataException, IOException {\n+\t\tfinal String environment = reader.nextString().toLowerCase(Locale.ROOT);\n+\n+\t\tif (environment.isEmpty() || environment.equals(\"*\")) {\n+\t\t\treturn ModEnvironment.UNIVERSAL;\n+\t\t} else if (environment.equals(\"client\")) {\n+\t\t\treturn ModEnvironment.CLIENT;\n+\t\t} else if (environment.equals(\"server\")) {\n+\t\t\treturn ModEnvironment.SERVER;\n+\t\t} else {\n+\t\t\tthrow new ParseMetadataException(\"Invalid environment type: \" + environment + \"!\", reader);\n+\t\t}\n+\t}\n+\n+\tprivate static void readEntrypoints(JsonReader reader, Map<String, List<EntrypointMetadata>> entrypoints) throws IOException, ParseMetadataException {\n+\t\t// Entrypoints must be an object\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Entrypoints must be an object\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tfinal String key = reader.nextName();\n+\n+\t\t\tList<EntrypointMetadata> metadata = new ArrayList<>();\n+\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\t\tthrow new ParseMetadataException(\"Entrypoint list must be an array!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginArray();\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tString adapter = \"default\";\n+\t\t\t\tString value = null;\n+\n+\t\t\t\t// Entrypoints may be specified directly as a string or as an object to allow specification of the language adapter to use.\n+\t\t\t\tswitch (reader.peek()) {\n+\t\t\t\tcase STRING:\n+\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\t\treader.beginObject();\n+\n+\t\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\t\tcase \"adapter\":\n+\t\t\t\t\t\t\tadapter = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tcase \"value\":\n+\t\t\t\t\t\t\tvalue = reader.nextString();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\tdefault: // TODO: Ignore invalid elements in the entrypoint object?\n+\t\t\t\t\t\t\treader.skipValue();\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n+\t\t\t\t\treader.endObject();\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new ParseMetadataException(\"Entrypoint must be a string or object with \\\"value\\\" field\", reader);\n+\t\t\t\t}\n+\n+\t\t\t\tif (value == null) {\n+\t\t\t\t\tthrow new ParseMetadataException.MissingRequired(\"Entrypoint value must be present\");\n+\t\t\t\t}\n+\n+\t\t\t\tmetadata.add(new V1ModMetadata.EntrypointMetadataImpl(adapter, value));\n+\t\t\t}\n+\n+\t\t\treader.endArray();\n+\n+\t\t\t// Empty arrays are acceptable, do not check if the List of metadata is empty\n+\t\t\tentrypoints.put(key, metadata);\n+\t\t}\n+\n+\t\treader.endObject();\n+\t}\n+\n+\tprivate static void readNestedJarEntries(JsonReader reader, List<NestedJarEntry> jars) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\tthrow new ParseMetadataException(\"Jar entries must be in an array\", reader);\n+\t\t}\n+\n+\t\treader.beginArray();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\t\tthrow new ParseMetadataException(\"Invalid type for JAR entry!\", reader);\n+\t\t\t}\n+\n+\t\t\treader.beginObject();\n+\t\t\tString file = null;\n+\n+\t\t\twhile (reader.hasNext()) {\n+\t\t\t\tif (reader.nextName().equals(\"file\")) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"file\\\" entry in jar object must be a string\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tfile = reader.nextString();\n+\t\t\t\t} else {\n+\t\t\t\t\treader.skipValue();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treader.endObject();\n+\n+\t\t\tif (file == null) {\n+\t\t\t\tthrow new ParseMetadataException(\"Missing mandatory key 'file' in JAR entry!\", reader);\n+\t\t\t}\n+\n+\t\t\tjars.add(new V1ModMetadata.JarEntry(file));\n+\t\t}\n+\n+\t\treader.endArray();\n+\t}\n+\n+\tprivate static void readMixinConfigs(JsonReader reader, List<V1ModMetadata.MixinEntry> mixins) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\tthrow new ParseMetadataException(\"Mixin configs must be in an array\", reader);\n+\t\t}\n+\n+\t\treader.beginArray();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.peek()) {\n+\t\t\tcase STRING:\n+\t\t\t\t// All mixin configs specified via string are assumed to be universal\n+\t\t\t\tmixins.add(new V1ModMetadata.MixinEntry(reader.nextString(), ModEnvironment.UNIVERSAL));\n+\t\t\t\tbreak;\n+\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\treader.beginObject();\n+\n+\t\t\t\tString config = null;\n+\t\t\t\tModEnvironment environment = null;\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\t// Environment is optional\n+\t\t\t\t\tcase \"environment\":\n+\t\t\t\t\t\tenvironment = V1ModMetadataParser.readEnvironment(reader);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase \"config\":\n+\t\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t\tthrow new ParseMetadataException(\"Value of \\\"config\\\" must be a string\", reader);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tconfig = reader.nextString();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treader.endObject();\n+\n+\t\t\t\tif (environment == null) {\n+\t\t\t\t\tenvironment = ModEnvironment.UNIVERSAL; // Default to universal\n+\t\t\t\t}\n+\n+\t\t\t\tif (config == null) {\n+\t\t\t\t\tthrow new ParseMetadataException.MissingRequired(\"Missing mandatory key 'config' in mixin entry!\");\n+\t\t\t\t}\n+\n+\t\t\t\tmixins.add(new V1ModMetadata.MixinEntry(config, environment));\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treader.skipValue();\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\treader.endArray();\n+\t}\n+\n+\tprivate static void readDependenciesContainer(JsonReader reader, Map<String, ModDependency> modDependencies) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_OBJECT) {\n+\t\t\tthrow new ParseMetadataException(\"Dependency container must be an object!\", reader);\n+\t\t}\n+\n+\t\treader.beginObject();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tfinal String modId = reader.nextName();\n+\t\t\tfinal List<String> matcherStringList = new ArrayList<>();\n+\n+\t\t\tswitch (reader.peek()) {\n+\t\t\tcase STRING:\n+\t\t\t\tmatcherStringList.add(reader.nextString());\n+\t\t\t\tbreak;\n+\t\t\tcase BEGIN_ARRAY:\n+\t\t\t\treader.beginArray();\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"Dependency version range array must only contain string values\", reader);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tmatcherStringList.add(reader.nextString());\n+\t\t\t\t}\n+\n+\t\t\t\treader.endArray();\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new ParseMetadataException(\"Dependency version range must be a string or string array!\", reader);\n+\t\t\t}\n+\n+\t\t\tmodDependencies.put(modId, new ModDependencyImpl(modId, matcherStringList));\n+\t\t}\n+\n+\t\treader.endObject();\n+\t}\n+\n+\tprivate static void parsePeople(JsonReader reader, List<Person> people) throws IOException, ParseMetadataException {\n+\t\tif (reader.peek() != JsonToken.BEGIN_ARRAY) {\n+\t\t\tthrow new ParseMetadataException(\"List of people must be an array\", reader);\n+\t\t}\n+\n+\t\treader.beginArray();\n+\n+\t\twhile (reader.hasNext()) {\n+\t\t\tswitch (reader.peek()) {\n+\t\t\tcase STRING:\n+\t\t\t\t// Just a name\n+\t\t\t\tpeople.add(new SimplePerson(reader.nextString()));\n+\t\t\t\tbreak;\n+\t\t\tcase BEGIN_OBJECT:\n+\t\t\t\t// Map-backed impl\n+\t\t\t\treader.beginObject();\n+\t\t\t\t// Name is required\n+\t\t\t\tString personName = null;\n+\t\t\t\tContactInformation contactInformation = null;\n+\n+\t\t\t\twhile (reader.hasNext()) {\n+\t\t\t\t\tswitch (reader.nextName()) {\n+\t\t\t\t\tcase \"name\":\n+\t\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t\tthrow new ParseMetadataException(\"Name of person in dependency container must be a string\", reader);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tpersonName = reader.nextString();\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t// Effectively optional\n+\t\t\t\t\tcase \"contact\":\n+\t\t\t\t\t\tcontactInformation = V1ModMetadataParser.readContactInfo(reader);\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault: // Ignore unsupported keys", "originalCommit": "6e58034217d23c8f6f49e2edf02662341f41d758", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3326db56e9adc4a41099d877f6301586b1eff048", "url": "https://github.com/FabricMC/fabric-loader/commit/3326db56e9adc4a41099d877f6301586b1eff048", "message": "Resolve review requests and add warning message system", "committedDate": "2020-10-06T03:58:05Z", "type": "commit"}, {"oid": "238293486102de16477ffa774c980439da9820bf", "url": "https://github.com/FabricMC/fabric-loader/commit/238293486102de16477ffa774c980439da9820bf", "message": "Words", "committedDate": "2020-10-06T04:02:38Z", "type": "commit"}, {"oid": "7d32d77032f7ab0daca4dc49a810ad95945df679", "url": "https://github.com/FabricMC/fabric-loader/commit/7d32d77032f7ab0daca4dc49a810ad95945df679", "message": "Add Fabric copyright to modified gson files", "committedDate": "2020-10-10T06:19:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3MDA1Ng==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502770056", "bodyText": "Hmm, does this need deprecation since it's not in an API class? (edit: this wasn't supposed to be a suggest changes review, oops)", "author": "Juuxel", "createdAt": "2020-10-10T09:33:34Z", "path": "src/main/java/net/fabricmc/loader/metadata/AbstractModMetadata.java", "diffHunk": "@@ -50,6 +50,14 @@ public CustomValue getCustomValue(String key) {\n \t\treturn getCustomValues().get(key);\n \t}\n \n+\t/**\n+\t * Converts a custom value to a json element.\n+\t * This will be removed in a future version when we remove the gson dependency.\n+\t *\n+\t * @param value the custom value\n+\t * @return a json element\n+\t */\n+\t@Deprecated", "originalCommit": "7d32d77032f7ab0daca4dc49a810ad95945df679", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgwOTEyMw==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502809123", "bodyText": "It's really just a marker for the future when gson gets fully dropped", "author": "i509VCB", "createdAt": "2020-10-10T16:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3MDA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNTIzOA==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502815238", "bodyText": "actually, since we are using the annotations in fapi now, would this now be able to use the annotations as well", "author": "shedaniel", "createdAt": "2020-10-10T17:55:33Z", "path": "build.gradle", "diffHunk": "@@ -38,9 +38,11 @@ repositories {\n }\n \n dependencies {\n-\tminecraft \"com.mojang:minecraft:1.14.4\"\n-\tmappings \"net.fabricmc:yarn:1.14.4+build.1\"\n+\t// TODO: Stop depending on Minecraft in main build.gradle\n+\tminecraft \"com.mojang:minecraft:1.16.3\"\n+\tmappings \"net.fabricmc:yarn:1.16.3+build.27:v2\"\n \n+\t// TODO: Jetbrains annotations", "originalCommit": "7d32d77032f7ab0daca4dc49a810ad95945df679", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNjM3OQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502816379", "bodyText": "We can't depend on fabric api. Annotations are for a later date but I don't like how discussions are going just for annotations in fabric loader", "author": "i509VCB", "createdAt": "2020-10-10T18:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNTIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNjYzNg==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502816636", "bodyText": "I took fapi as an example, the jetbrains annotations are applied through loom 0.5, I do admit that it doesn't have much to do with this PR tho.", "author": "shedaniel", "createdAt": "2020-10-10T18:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNTIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyNTcxOA==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502825718", "bodyText": "I will look into fixing latest loom as a loader dev env, I dont see an issue with using JB's annotations in loader?", "author": "modmuss50", "createdAt": "2020-10-10T19:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNTIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyNTU4Nw==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502825587", "bodyText": "Can this now be done? or do we need to repackage it in mixin? (Id like to repackage all of mixins libs, possibly appart from asm)", "author": "modmuss50", "createdAt": "2020-10-10T19:48:16Z", "path": "src/main/java/net/fabricmc/loader/launch/knot/KnotClassLoader.java", "diffHunk": "@@ -144,7 +144,9 @@ public URL nextElement() {\n \t\tsynchronized (getClassLoadingLock(name)) {\n \t\t\tClass<?> c = findLoadedClass(name);\n \n-\t\t\tif (c == null && !name.startsWith(\"com.google.gson.\") && !name.startsWith(\"java.\")) { // FIXME: remove the GSON exclusion once loader stops using it (or repackages it)\n+\t\t\t// FIXME: remove the GSON exclusion once loader stops using gson.\n+\t\t\t// We now repackage Gson's JsonReader so removal is now possible\n+\t\t\tif (c == null && !name.startsWith(\"com.google.gson.\") && !name.startsWith(\"java.\")) {", "originalCommit": "7d32d77032f7ab0daca4dc49a810ad95945df679", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyNjIwNw==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502826207", "bodyText": "I asked player about that. He wants to deal with the actual removal of gson and it's corresponding exemption a bit later.", "author": "i509VCB", "createdAt": "2020-10-10T19:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyNTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjkxNjU1MQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502916551", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t// For all intensive purposes of replicating the logic of Gson's fromJson before we have migrated to JsonReader, duplicate keys will replace previous entries.\n          \n          \n            \n            \t// For all intents and purposes of replicating the logic of Gson's fromJson before we have migrated to JsonReader, duplicate keys will replace previous entries.", "author": "Pyrofab", "createdAt": "2020-10-11T13:35:11Z", "path": "src/main/java/net/fabricmc/loader/metadata/ModMetadataParser.java", "diffHunk": "@@ -16,66 +16,129 @@\n \n package net.fabricmc.loader.metadata;\n \n-import com.google.gson.*;\n-import net.fabricmc.loader.FabricLoader;\n-import net.fabricmc.loader.api.metadata.ModEnvironment;\n-import net.fabricmc.loader.api.Version;\n-import net.fabricmc.loader.util.version.VersionDeserializer;\n-\n-import java.io.InputStream;\n+import java.io.IOException;\n import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n \n-public class ModMetadataParser {\n+import net.fabricmc.loader.lib.gson.JsonReader;\n+import net.fabricmc.loader.lib.gson.JsonToken;\n+\n+public final class ModMetadataParser {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n \tpublic static final int LATEST_VERSION = 1;\n \n-\tprivate static final Gson GSON_V1 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.JarEntry.class, new ModMetadataV1.JarEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.IconEntry.class, new ModMetadataV1.IconEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.LicenseEntry.class, new ModMetadataV1.LicenseEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.Person.class, new ModMetadataV1.Person.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.DependencyContainer.class, new ModMetadataV1.DependencyContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.MixinEntry.class, new ModMetadataV1.MixinEntry.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.EntrypointContainer.class, new ModMetadataV1.EntrypointContainer.Deserializer())\n-\t\t.registerTypeAdapter(ModEnvironment.class, new ModMetadataV1.EnvironmentDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV1.CustomValueContainer.class, new ModMetadataV1.CustomValueContainer.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final Gson GSON_V0 = new GsonBuilder()\n-\t\t.registerTypeAdapter(Version.class, new VersionDeserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Side.class, new ModMetadataV0.Side.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Mixins.class, new ModMetadataV0.Mixins.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Links.class, new ModMetadataV0.Links.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Dependency.class, new ModMetadataV0.Dependency.Deserializer())\n-\t\t.registerTypeAdapter(ModMetadataV0.Person.class, new ModMetadataV0.Person.Deserializer())\n-\t\t.create();\n-\n-\tprivate static final JsonParser JSON_PARSER = new JsonParser();\n-\n-\tprivate static LoaderModMetadata getMod(FabricLoader loader, JsonObject object) {\n-\t\tif (!object.has(\"schemaVersion\")) {\n-\t\t\treturn GSON_V0.fromJson(object, ModMetadataV0.class);\n-\t\t} else {\n-\t\t\t//noinspection SwitchStatementWithTooFewBranches\n-\t\t\tswitch (object.get(\"schemaVersion\").getAsInt()) {\n-\t\t\t\tcase 1:\n-\t\t\t\t\treturn GSON_V1.fromJson(object, ModMetadataV1.class);\n-\t\t\t\tdefault:\n-\t\t\t\t\tloader.getLogger().warn(\"Mod ID \" + (object.has(\"id\") ? object.get(\"id\").getAsString() : \"<unknown>\") + \" has invalid schema version: \" + object.get(\"schemaVersion\").getAsInt());\n-\t\t\t\t\treturn null;\n+\t// Per the ECMA-404 (www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), the JSON spec does not prohibit duplicate keys.\n+\t// For all intensive purposes of replicating the logic of Gson's fromJson before we have migrated to JsonReader, duplicate keys will replace previous entries.", "originalCommit": "7d32d77032f7ab0daca4dc49a810ad95945df679", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjkxNjk0OA==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502916948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t// FIXME: Needs it's own type?\n          \n          \n            \n            \t\t\t\t\t\t// FIXME: Needs its own type?", "author": "Pyrofab", "createdAt": "2020-10-11T13:38:54Z", "path": "src/main/java/net/fabricmc/loader/minecraft/McVersionLookup.java", "diffHunk": "@@ -124,10 +125,33 @@ private static McVersion fromVersionJson(InputStream is) {\n \n \t\t\twhile (reader.hasNext()) {\n \t\t\t\tswitch (reader.nextName()) {\n-\t\t\t\tcase \"id\": id = reader.nextString(); break;\n-\t\t\t\tcase \"name\": name = reader.nextString(); break;\n-\t\t\t\tcase \"release_target\": release = reader.nextString(); break;\n-\t\t\t\tdefault: reader.skipValue();\n+\t\t\t\tcase \"id\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t// FIXME: Needs it's own type?", "originalCommit": "7d32d77032f7ab0daca4dc49a810ad95945df679", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjkxNjk4MQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502916981", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t// FIXME: Needs it's own type?\n          \n          \n            \n            \t\t\t\t\t\t// FIXME: Needs its own type?", "author": "Pyrofab", "createdAt": "2020-10-11T13:39:10Z", "path": "src/main/java/net/fabricmc/loader/minecraft/McVersionLookup.java", "diffHunk": "@@ -124,10 +125,33 @@ private static McVersion fromVersionJson(InputStream is) {\n \n \t\t\twhile (reader.hasNext()) {\n \t\t\t\tswitch (reader.nextName()) {\n-\t\t\t\tcase \"id\": id = reader.nextString(); break;\n-\t\t\t\tcase \"name\": name = reader.nextString(); break;\n-\t\t\t\tcase \"release_target\": release = reader.nextString(); break;\n-\t\t\t\tdefault: reader.skipValue();\n+\t\t\t\tcase \"id\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t// FIXME: Needs it's own type?\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"id\\\" in version json must be a string\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tid = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"name\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t// FIXME: Needs it's own type?", "originalCommit": "7d32d77032f7ab0daca4dc49a810ad95945df679", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjkxNzAwNg==", "url": "https://github.com/FabricMC/fabric-loader/pull/306#discussion_r502917006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t// FIXME: Needs it's own type?\n          \n          \n            \n            \t\t\t\t\t\t// FIXME: Needs its own type?", "author": "Pyrofab", "createdAt": "2020-10-11T13:39:22Z", "path": "src/main/java/net/fabricmc/loader/minecraft/McVersionLookup.java", "diffHunk": "@@ -124,10 +125,33 @@ private static McVersion fromVersionJson(InputStream is) {\n \n \t\t\twhile (reader.hasNext()) {\n \t\t\t\tswitch (reader.nextName()) {\n-\t\t\t\tcase \"id\": id = reader.nextString(); break;\n-\t\t\t\tcase \"name\": name = reader.nextString(); break;\n-\t\t\t\tcase \"release_target\": release = reader.nextString(); break;\n-\t\t\t\tdefault: reader.skipValue();\n+\t\t\t\tcase \"id\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t// FIXME: Needs it's own type?\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"id\\\" in version json must be a string\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tid = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"name\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t// FIXME: Needs it's own type?\n+\t\t\t\t\t\tthrow new ParseMetadataException(\"\\\"name\\\" in version json must be a string\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tname = reader.nextString();\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"release_target\":\n+\t\t\t\t\tif (reader.peek() != JsonToken.STRING) {\n+\t\t\t\t\t\t// FIXME: Needs it's own type?", "originalCommit": "7d32d77032f7ab0daca4dc49a810ad95945df679", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "323c2a6430cea552b03c6f5b3acaefea16613b45", "url": "https://github.com/FabricMC/fabric-loader/commit/323c2a6430cea552b03c6f5b3acaefea16613b45", "message": "Apply suggestions from code review\n\nCo-authored-by: Pyrofab <redstoneinfire@gmail.com>", "committedDate": "2020-10-11T17:06:01Z", "type": "commit"}, {"oid": "a73ac1fcf1b489648c6ce830fb193044ce7adb7b", "url": "https://github.com/FabricMC/fabric-loader/commit/a73ac1fcf1b489648c6ce830fb193044ce7adb7b", "message": "Drop added TODO markers from build.gradle", "committedDate": "2020-10-16T20:38:29Z", "type": "commit"}]}