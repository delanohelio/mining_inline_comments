{"pr_number": 206, "pr_title": "AccessWidener", "pr_createdAt": "2020-02-19T19:45:30Z", "pr_url": "https://github.com/FabricMC/fabric-loader/pull/206", "timeline": [{"oid": "6bb96d8f2515a9332f5ab0f270f8d45bc8885ccb", "url": "https://github.com/FabricMC/fabric-loader/commit/6bb96d8f2515a9332f5ab0f270f8d45bc8885ccb", "message": "First pass on access changing", "committedDate": "2020-02-19T19:42:08Z", "type": "commit"}, {"oid": "b7d250be66a123d36a7edfbd75600328fd729a77", "url": "https://github.com/FabricMC/fabric-loader/commit/b7d250be66a123d36a7edfbd75600328fd729a77", "message": "Decapsulator", "committedDate": "2020-02-20T18:52:25Z", "type": "commit"}, {"oid": "45156350fe51222c5696c0df5dee7eded33fdba2", "url": "https://github.com/FabricMC/fabric-loader/commit/45156350fe51222c5696c0df5dee7eded33fdba2", "message": "More cleanup", "committedDate": "2020-02-20T19:11:06Z", "type": "commit"}, {"oid": "281a13e070d7578b94c638f738d2d02aa8c9b56d", "url": "https://github.com/FabricMC/fabric-loader/commit/281a13e070d7578b94c638f738d2d02aa8c9b56d", "message": "AccessWidener", "committedDate": "2020-02-20T19:15:29Z", "type": "commit"}, {"oid": "feef947984a4e84f760d2dd7201bbbcb66e20419", "url": "https://github.com/FabricMC/fabric-loader/commit/feef947984a4e84f760d2dd7201bbbcb66e20419", "message": "Add licenses", "committedDate": "2020-02-21T14:18:08Z", "type": "commit"}, {"oid": "d596b183ac570706c2c29aeedd24e2c9facb4ff1", "url": "https://github.com/FabricMC/fabric-loader/commit/d596b183ac570706c2c29aeedd24e2c9facb4ff1", "message": "Formatting", "committedDate": "2020-02-23T12:29:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r383935053", "bodyText": "I suggest considering method inheritance here.", "author": "liach", "createdAt": "2020-02-25T15:03:14Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);", "originalCommit": "d596b183ac570706c2c29aeedd24e2c9facb4ff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNzA4OQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r383937089", "bodyText": "Player suggested to use tiny remapper for this (need exposing).\nEven then I think it would be best for loom to handle it, I dont know of an easy / quick way to do it here.", "author": "modmuss50", "createdAt": "2020-02-25T15:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzODcyMA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r383938720", "bodyText": "Imo loom does not suffice, given if you raise visibility of a method from protected to public in net.minecraft.block.Block, other mods may still override that method and have it as protected, causing a runtime error.", "author": "liach", "createdAt": "2020-02-25T15:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3ODc4OQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384278789", "bodyText": "Widening superclass method accessibility does not cause a run time error.", "author": "kvverti", "createdAt": "2020-02-26T05:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4MjgzNA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384282834", "bodyText": "Well, when the mod that raised the method to public calls the protected method, the runtime illegal access error occurs.", "author": "liach", "createdAt": "2020-02-26T05:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4NTM5NA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384285394", "bodyText": "That would be a compile time error in the development environment, not a run time error. (Just tested, not even a compile error) Calling an overriding protected method by virtual dispatch over a public superclass method does not in itself cause a run time error.", "author": "kvverti", "createdAt": "2020-02-26T05:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4NzIwNQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384287205", "bodyText": "Mind send class files that I can test? Too lazy to generate with asm", "author": "liach", "createdAt": "2020-02-26T05:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDQ4OA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384294488", "bodyText": "Here is a Gist.\nPlace the files in the appropriate package structure, then compile and run using the following steps.\n\nSet access of Super#m to protected\n$ javac p/Super.java q/Sub.java\nSet access of Super#m to public\n$ javac p/Super.java\n$ javac access/AccessTest.java access/UseM.java\n$ java access.AccessTest\n\nYou should get the output\nSubclass\nSubclass", "author": "kvverti", "createdAt": "2020-02-26T06:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NzI4Ng==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384297286", "bodyText": "Unfortunately GitHub will not allow me to upload a zip of the class files", "author": "kvverti", "createdAt": "2020-02-26T06:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5ODc1MQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384298751", "bodyText": "Should be fine as removing final doesn't affect subclasses and protected still works.", "author": "liach", "createdAt": "2020-02-26T06:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzNTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5OTM3Mw==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384299373", "bodyText": "extra semicolon", "author": "liach", "createdAt": "2020-02-26T06:42:40Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\t\");\n+\n+\t\tif (header.length != 2 || !header[0].equals(\"accessWidener\\\\v1\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Unsupported or invalid access accessWidener file, expected: accessWidener\\\\v1 <namespace>\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[1], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[1])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[1]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[1];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\t//Will be a common issue, make it clear.\n+\t\t\tif (line.contains(\" \")) {\n+\t\t\t\tthrow new RuntimeException(\"AccessWidener contains one or more space character, tabs are required on line: \" + line);\n+\t\t\t}\n+\n+\t\t\tString[] split = line.split(\"\\t\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], Access.DEFAULT)));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, Access.DEFAULT)));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"public\":\n+\t\t\treturn access.makePublic();\n+\t\tcase \"protected\":\n+\t\t\treturn access.makeProtected();\n+\t\tcase \"stripfinal\":\n+\t\t\treturn access.stripFinal();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, Access.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tpublic enum Access {\n+\t\tDEFAULT(false, false, false),\n+\t\tPROTECTED(true, false, false),\n+\t\tPROTECTED_STRIP_FINAL(true, false, true),\n+\t\tPUBLIC(false, true, false),\n+\t\tPUBLIC_STRIP_FINAL(false, true, true),\n+\t\tSTRIP_FINAL(false, false, true);\n+\n+\t\tprivate final boolean makeProtected;\n+\t\tprivate final boolean makePublic;\n+\t\tprivate final boolean stripFinal;\n+\n+\t\tAccess(boolean makeProtected, boolean makePublic, boolean stripFinal) {\n+\t\t\tthis.makeProtected = makeProtected;\n+\t\t\tthis.makePublic = makePublic;\n+\t\t\tthis.stripFinal = stripFinal;\n+\t\t}\n+\n+\t\tpublic Access makePublic() {\n+\t\t\treturn stripFinal ? PUBLIC_STRIP_FINAL : PUBLIC;\n+\t\t}\n+\n+\t\tpublic Access makeProtected() {\n+\t\t\tif (makePublic) return this;\n+\t\t\treturn stripFinal ? PROTECTED_STRIP_FINAL : PROTECTED;\n+\t\t}\n+\n+\t\tpublic Access stripFinal() {\n+\t\t\tif (makePublic) {\n+\t\t\t\treturn PUBLIC_STRIP_FINAL;\n+\t\t\t} else if (makeProtected) {\n+\t\t\t\treturn PROTECTED_STRIP_FINAL;\n+\t\t\t}\n+\n+\t\t\treturn STRIP_FINAL;\n+\t\t}\n+\n+\t\tpublic int apply(int access) {\n+\t\t\tif (makePublic) {\n+\t\t\t\taccess = (access & ~7) | Opcodes.ACC_PUBLIC;\n+\t\t\t} else if (makeProtected) {\n+\t\t\t\tif ((access & Opcodes.ACC_PUBLIC) == 0) {\n+\t\t\t\t\t//Only make it protected if not public\n+\t\t\t\t\taccess = (access & ~7) | Opcodes.ACC_PROTECTED;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (stripFinal) {\n+\t\t\t\taccess = access & ~Opcodes.ACC_FINAL;;", "originalCommit": "d596b183ac570706c2c29aeedd24e2c9facb4ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MzU3MA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384583570", "bodyText": "This check may not be reached outside of dev env. Scroll up; you need to change the condition check for transformAccess local var to check for existence in access widener as well!", "author": "liach", "createdAt": "2020-02-26T15:51:19Z", "path": "src/main/java/net/fabricmc/loader/transformer/FabricTransformer.java", "diffHunk": "@@ -56,6 +58,11 @@\n \t\tClassVisitor visitor = classWriter;\n \t\tint visitorCount = 0;\n \n+\t\tif (isMinecraftClass && FabricLoader.INSTANCE.getAccessWidener().getTargets().contains(name)) {", "originalCommit": "d596b183ac570706c2c29aeedd24e2c9facb4ff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5MjQ1Mg==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r384592452", "bodyText": "Ah yes, good spot.", "author": "modmuss50", "createdAt": "2020-02-26T16:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MzU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjY4MA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395332680", "bodyText": "https://github.com/FabricMC/fabric-loader/pull/206/files#diff-357f0c28bb837e6ad9c13252885f47bcR52 Still needs to be fixed.", "author": "liach", "createdAt": "2020-03-19T21:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MzU3MA=="}], "type": "inlineReview"}, {"oid": "8a7cfb6b31727203db010c7e348d3a867964caa5", "url": "https://github.com/FabricMC/fabric-loader/commit/8a7cfb6b31727203db010c7e348d3a867964caa5", "message": "Move to a more defined way of changing access, untested.", "committedDate": "2020-03-19T16:15:53Z", "type": "commit"}, {"oid": "d06c704b1cf9d09b9f9c689f9a70d33698486ca9", "url": "https://github.com/FabricMC/fabric-loader/commit/d06c704b1cf9d09b9f9c689f9a70d33698486ca9", "message": "Some more work", "committedDate": "2020-03-19T19:57:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NjAxOA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395286018", "bodyText": "The method could still have package visibility.", "author": "kvverti", "createdAt": "2020-03-19T19:59:58Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -195,21 +195,46 @@ public Access getMethodAccess(EntryTriple entryTriple) {\n \t\treturn classes;\n \t}\n \n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}", "originalCommit": "d06c704b1cf9d09b9f9c689f9a70d33698486ca9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDgwMw==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395294803", "bodyText": "I think ive fixed this now.", "author": "modmuss50", "createdAt": "2020-03-19T20:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NjAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NzY5MA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395287690", "bodyText": "Classes can only be either public or package private.", "author": "kvverti", "createdAt": "2020-03-19T20:03:11Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -195,21 +195,46 @@ public Access getMethodAccess(EntryTriple entryTriple) {\n \t\treturn classes;\n \t}\n \n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n \tpublic interface Access {\n \t\tAccess makeAccessible();\n \n \t\tAccess makeExtendable();\n \n \t\tAccess makeMutable();\n \n-\t\tIntUnaryOperator getOperator();\n+\t\tint apply(int i);\n \t}\n \n \tpublic enum ClassAccess implements Access {\n \t\tDEFAULT(i -> i),\n-\t\tACCESSIBLE(i -> ((i & Opcodes.ACC_PRIVATE) != 0 ? Opcodes.ACC_FINAL : 0) | (i & ~7) | Opcodes.ACC_PUBLIC), //Make public, add final if private\n-\t\tEXTENDABLE(i -> ((i & ~7) | Opcodes.ACC_PUBLIC) & ~Opcodes.ACC_FINAL), //Make public and strip final\n-\t\tACCESSIBLE_EXTENDABLE(i -> ((i & ~7) | Opcodes.ACC_PUBLIC) & ~Opcodes.ACC_FINAL); //Make public and strip final\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makeProtected(removeFinal(i))),", "originalCommit": "d06c704b1cf9d09b9f9c689f9a70d33698486ca9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NDUwNg==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395294506", "bodyText": "Nested class accessibility is defined in the InnerClasses attribute. This is used by the compiler to enforce access requirements for nested classes.\nJVMS-4.7.6", "author": "kvverti", "createdAt": "2020-03-19T20:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NzY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzMzNw==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395343337", "bodyText": "This is handled by visitInnerClass", "author": "modmuss50", "createdAt": "2020-03-19T21:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NzY5MA=="}], "type": "inlineReview"}, {"oid": "dc16c9b6011567950f2a1cfcca91e717d6dfacbf", "url": "https://github.com/FabricMC/fabric-loader/commit/dc16c9b6011567950f2a1cfcca91e717d6dfacbf", "message": "Fix some minor issues", "committedDate": "2020-03-19T20:16:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTM1Mg==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395295352", "bodyText": "The method could still be package private...\nYou need if((i & Opcodes.ACC_PUBLIC) != 0)", "author": "kvverti", "createdAt": "2020-03-19T20:17:57Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -200,7 +200,7 @@ private static int makePublic(int i) {\n \t}\n \n \tprivate static int makeProtected(int i) {\n-\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\tif ((i & ~Opcodes.ACC_PUBLIC) == 0) {", "originalCommit": "dc16c9b6011567950f2a1cfcca91e717d6dfacbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTcwNg==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395295706", "bodyText": "ah yeah, thanks :D", "author": "modmuss50", "createdAt": "2020-03-19T20:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5NTM1Mg=="}], "type": "inlineReview"}, {"oid": "1a841824033c4fe296b47675353a5e07706c09a3", "url": "https://github.com/FabricMC/fabric-loader/commit/1a841824033c4fe296b47675353a5e07706c09a3", "message": "Fix stupid issue.\n\nBitwise can get confusing lol", "committedDate": "2020-03-19T20:19:19Z", "type": "commit"}, {"oid": "b50cc19e7838f8d1161a5c01fb5bf183575208e4", "url": "https://github.com/FabricMC/fabric-loader/commit/b50cc19e7838f8d1161a5c01fb5bf183575208e4", "message": "Fix namespace reading bugs", "committedDate": "2020-03-19T20:45:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0OA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395333248", "bodyText": "Why no flexible namespace support but rather enforces the current namespace? Seems to me that it won't work in both dev and production", "author": "liach", "createdAt": "2020-03-19T21:35:45Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {", "originalCommit": "b50cc19e7838f8d1161a5c01fb5bf183575208e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MDU0OQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395340549", "bodyText": "Humm, good point, ill have to bring over the remapper. Might almost be worth making this a lib now..", "author": "modmuss50", "createdAt": "2020-03-19T21:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MjA3OA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395342078", "bodyText": "Actaully no, this is fine. In dev everything is named and at runtime everything is intermediary it matches the mod classes. No need to change this.", "author": "modmuss50", "createdAt": "2020-03-19T21:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDk1MQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395334951", "bodyText": "Hmm, a class cannot be private, so makeFinalIfPrivate is pointless\nhttps://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1-200-E.1\n(private is not an option in this list)", "author": "liach", "createdAt": "2020-03-19T21:39:34Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),", "originalCommit": "b50cc19e7838f8d1161a5c01fb5bf183575208e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NTAxMA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395345010", "bodyText": "What does private class get compiled down to? package private?", "author": "modmuss50", "createdAt": "2020-03-19T22:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1MjUwOQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395352509", "bodyText": "package private I think, which guarantees the enclosing class' access to it as same-level class\n#206 (comment)", "author": "liach", "createdAt": "2020-03-19T22:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NzM3Ng==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395387376", "bodyText": "Ok, I think we will need to remove this then.", "author": "modmuss50", "createdAt": "2020-03-20T00:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNDk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNTUyNw==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395335527", "bodyText": "guess this interface can extend IntUnaryOperator", "author": "liach", "createdAt": "2020-03-19T21:40:49Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {", "originalCommit": "b50cc19e7838f8d1161a5c01fb5bf183575208e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MTE1Ng==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395341156", "bodyText": "I dont think there is much gain in doing so tbh.", "author": "modmuss50", "createdAt": "2020-03-19T21:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNTUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjg5OQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395336899", "bodyText": "What if I want to make a field accessible as a subclass (protected) but not exposed to other users?", "author": "liach", "createdAt": "2020-03-19T21:44:05Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makePublic(removeFinal(i))),\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i)));\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tClassAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Classes cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum MethodAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))), //Make public, add final if private\n+\t\tEXTENDABLE(i -> makeProtected(removeFinal(i))), //Make protected and strip final\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i))); //Make public and strip final\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tMethodAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Methods cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum FieldAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(i)),", "originalCommit": "b50cc19e7838f8d1161a5c01fb5bf183575208e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDE4Mw==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395344183", "bodyText": "extendable doesnt really fit for fields, so I think this is fine.", "author": "modmuss50", "createdAt": "2020-03-19T22:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzA4OA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395337088", "bodyText": "How about method being accessible by subclass but not other outer classes?", "author": "liach", "createdAt": "2020-03-19T21:44:31Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tpublic void loadFromMods(FabricLoader fabricLoader) {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {\n+\t\t\tthrow new RuntimeException(String.format(\"Namespace (%s) does not match current runtime namespace (%s)\", header[2], currentNamespace));\n+\t\t}\n+\n+\t\tif (namespace != null) {\n+\t\t\tif (!namespace.equals(header[2])) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Namespace mismatch, expected %s got %s\", namespace, header[2]));\n+\t\t\t}\n+\t\t}\n+\n+\t\tnamespace = header[2];\n+\n+\t\tString line;\n+\n+\t\tSet<String> targets = new LinkedHashSet<>();\n+\n+\t\twhile ((line = reader.readLine()) != null) {\n+\t\t\t//Comment handling\n+\t\t\tint commentPos = line.indexOf('#');\n+\n+\t\t\tif (commentPos >= 0) {\n+\t\t\t\tline = line.substring(0, commentPos).trim();\n+\t\t\t}\n+\n+\t\t\tif (line.isEmpty()) continue;\n+\n+\t\t\tString[] split = line.split(\"\\\\s+\");\n+\n+\t\t\tif (split.length != 3 && split.length != 5) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Invalid line (%s)\", line));\n+\t\t\t}\n+\n+\t\t\tString access = split[0];\n+\n+\t\t\ttargets.add(split[2].replaceAll(\"/\", \".\"));\n+\n+\t\t\tswitch (split[1]) {\n+\t\t\tcase \"class\":\n+\t\t\t\tif (split.length != 3) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tclass\\t<className>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\tclassAccess.put(split[2], applyAccess(access, classAccess.getOrDefault(split[2], ClassAccess.DEFAULT), null));\n+\t\t\t\tbreak;\n+\t\t\tcase \"field\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tfield\\t<className>\\t<fieldName>\\t<fieldDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(fieldAccess, new EntryTriple(split[2], split[3], split[4]), access, FieldAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tcase \"method\":\n+\t\t\t\tif (split.length != 5) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Expected (<access>\\tmethod\\t<className>\\t<methodName>\\t<methodDesc>) got (%s)\", line));\n+\t\t\t\t}\n+\n+\t\t\t\taddOrMerge(methodAccess, new EntryTriple(split[2], split[3], split[4]), access, MethodAccess.DEFAULT);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new UnsupportedOperationException(\"Unsupported type \" + split[1]);\n+\t\t\t}\n+\t\t}\n+\n+\t\tSet<String> parentClasses = new LinkedHashSet<>();\n+\n+\t\t//Also transform all parent classes\n+\t\tfor (String clazz : targets) {\n+\t\t\twhile (clazz.contains(\"$\")) {\n+\t\t\t\tclazz = clazz.substring(0, clazz.lastIndexOf(\"$\"));\n+\t\t\t\tparentClasses.add(clazz);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclasses.addAll(targets);\n+\t\tclasses.addAll(parentClasses);\n+\t}\n+\n+\tvoid addOrMerge(Map<EntryTriple, Access> map, EntryTriple entry, String access, Access defaultAccess) {\n+\t\tif (entry == null || access == null) {\n+\t\t\tthrow new RuntimeException(\"Input entry or access is null\");\n+\t\t}\n+\n+\t\tmap.put(entry, applyAccess(access, map.getOrDefault(entry, defaultAccess), entry));\n+\t}\n+\n+\tprivate Access applyAccess(String input, Access access, EntryTriple entryTriple) {\n+\t\tswitch (input.toLowerCase(Locale.ROOT)) {\n+\t\tcase \"accessible\":\n+\t\t\tmakeClassAccessible(entryTriple);\n+\t\t\treturn access.makeAccessible();\n+\t\tcase \"extendable\":\n+\t\t\tmakeClassExtendable(entryTriple);\n+\t\t\treturn access.makeExtendable();\n+\t\tcase \"mutable\":\n+\t\t\treturn access.makeMutable();\n+\t\tdefault:\n+\t\t\tthrow new UnsupportedOperationException(\"Unknown access type:\" + input);\n+\t\t}\n+\t}\n+\n+\tprivate void makeClassAccessible(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"accessible\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tprivate void makeClassExtendable(EntryTriple entryTriple) {\n+\t\tif (entryTriple == null) return;\n+\t\tclassAccess.put(entryTriple.getOwner(), applyAccess(\"extendable\", classAccess.getOrDefault(entryTriple.getOwner(), ClassAccess.DEFAULT), null));\n+\t}\n+\n+\tpublic Access getClassAccess(String className) {\n+\t\treturn classAccess.getOrDefault(className, ClassAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getFieldAccess(EntryTriple entryTriple) {\n+\t\treturn fieldAccess.getOrDefault(entryTriple, FieldAccess.DEFAULT);\n+\t}\n+\n+\tpublic Access getMethodAccess(EntryTriple entryTriple) {\n+\t\treturn methodAccess.getOrDefault(entryTriple, MethodAccess.DEFAULT);\n+\t}\n+\n+\tpublic Set<String> getTargets() {\n+\t\treturn classes;\n+\t}\n+\n+\tprivate static int makePublic(int i) {\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED)) | Opcodes.ACC_PUBLIC;\n+\t}\n+\n+\tprivate static int makeProtected(int i) {\n+\t\tif ((i & Opcodes.ACC_PUBLIC) != 0) {\n+\t\t\t//Return i if public\n+\t\t\treturn i;\n+\t\t}\n+\n+\t\treturn (i & ~(Opcodes.ACC_PRIVATE)) | Opcodes.ACC_PROTECTED;\n+\t}\n+\n+\tprivate static int makeFinalIfPrivate(int i) {\n+\t\tif ((i & Opcodes.ACC_PRIVATE) != 0) {\n+\t\t\treturn i | Opcodes.ACC_FINAL;\n+\t\t}\n+\n+\t\treturn i;\n+\t}\n+\n+\tprivate static int removeFinal(int i) {\n+\t\treturn i & ~Opcodes.ACC_FINAL;\n+\t}\n+\n+\tpublic interface Access {\n+\t\tAccess makeAccessible();\n+\n+\t\tAccess makeExtendable();\n+\n+\t\tAccess makeMutable();\n+\n+\t\tint apply(int i);\n+\t}\n+\n+\tpublic enum ClassAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))),\n+\t\tEXTENDABLE(i -> makePublic(removeFinal(i))),\n+\t\tACCESSIBLE_EXTENDABLE(i -> makePublic(removeFinal(i)));\n+\n+\t\tprivate final IntUnaryOperator operator;\n+\n+\t\tClassAccess(IntUnaryOperator operator) {\n+\t\t\tthis.operator = operator;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeAccessible() {\n+\t\t\tif (this == EXTENDABLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn ACCESSIBLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeExtendable() {\n+\t\t\tif (this == ACCESSIBLE || this == ACCESSIBLE_EXTENDABLE) {\n+\t\t\t\treturn ACCESSIBLE_EXTENDABLE;\n+\t\t\t}\n+\n+\t\t\treturn EXTENDABLE;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Access makeMutable() {\n+\t\t\tthrow new UnsupportedOperationException(\"Classes cannot be made mutable\");\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int apply(int i) {\n+\t\t\treturn operator.applyAsInt(i);\n+\t\t}\n+\t}\n+\n+\tpublic enum MethodAccess implements Access {\n+\t\tDEFAULT(i -> i),\n+\t\tACCESSIBLE(i -> makePublic(makeFinalIfPrivate(i))), //Make public, add final if private", "originalCommit": "b50cc19e7838f8d1161a5c01fb5bf183575208e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NzI1MQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r395387251", "bodyText": "Im not 100% sure what you mean? I dont think its an issue due to it actaully using the bridge method.", "author": "modmuss50", "createdAt": "2020-03-20T00:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA4MjYzMA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r398082630", "bodyText": "I think ill just remove makeFinalIfPrivate it sounds like its going to cause more issues than it will fix.", "author": "modmuss50", "createdAt": "2020-03-25T18:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzA4OA=="}], "type": "inlineReview"}, {"oid": "83afd3b2a7d8758604f90160678ead0efe924e81", "url": "https://github.com/FabricMC/fabric-loader/commit/83afd3b2a7d8758604f90160678ead0efe924e81", "message": "Fix issue", "committedDate": "2020-03-19T21:59:02Z", "type": "commit"}, {"oid": "dc3e2a6d646dc6ab8d4e4e8efca8c8076b6cc65d", "url": "https://github.com/FabricMC/fabric-loader/commit/dc3e2a6d646dc6ab8d4e4e8efca8c8076b6cc65d", "message": "Merge remote-tracking branch 'remotes/upstream/master' into access\n\n# Conflicts:\n#\tsrc/main/java/net/fabricmc/loader/FabricLoader.java", "committedDate": "2020-03-19T22:12:56Z", "type": "commit"}, {"oid": "5f4cfa22623886f931f364c722ed541150e44fc9", "url": "https://github.com/FabricMC/fabric-loader/commit/5f4cfa22623886f931f364c722ed541150e44fc9", "message": "Apply some feedback.", "committedDate": "2020-03-25T18:36:38Z", "type": "commit"}, {"oid": "2e7ff0a6c617be815eb9dc5963f9384e427f2600", "url": "https://github.com/FabricMC/fabric-loader/commit/2e7ff0a6c617be815eb9dc5963f9384e427f2600", "message": "Remove un-needed comments", "committedDate": "2020-03-25T18:41:39Z", "type": "commit"}, {"oid": "639f5fd767e4f5a7a82ff83c3d28f9bcc79406b9", "url": "https://github.com/FabricMC/fabric-loader/commit/639f5fd767e4f5a7a82ff83c3d28f9bcc79406b9", "message": "Add back makeFinalIfPrivate to methods", "committedDate": "2020-03-26T14:46:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0NjkwNQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r400346905", "bodyText": "The package should have lowercased name", "author": "liach", "createdAt": "2020-03-30T16:56:56Z", "path": "src/main/java/net/fabricmc/loader/transformer/accessWidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accessWidener;", "originalCommit": "639f5fd767e4f5a7a82ff83c3d28f9bcc79406b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1NTMxOA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r400355318", "bodyText": "Done", "author": "modmuss50", "createdAt": "2020-03-30T17:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0NjkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1MDI2Nw==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r400350267", "bodyText": "This seems a bit redundant to me to call a method on the loader's instance, and then require the loader again as a param.\nCouldn't we just make the loader one of the ctor params for the AccessWideners since we won't usually be passing multiple instances of loader into the same game.", "author": "i509VCB", "createdAt": "2020-03-30T17:02:03Z", "path": "src/main/java/net/fabricmc/loader/launch/FabricTweaker.java", "diffHunk": "@@ -122,6 +122,8 @@ public void injectIntoClassLoader(LaunchClassLoader launchClassLoader) {\n \t\t\t}\n \t\t}\n \n+\t\tFabricLoader.INSTANCE.getAccessWidener().loadFromMods(FabricLoader.INSTANCE);", "originalCommit": "639f5fd767e4f5a7a82ff83c3d28f9bcc79406b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1OTM1Ng==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r400359356", "bodyText": "Done.", "author": "modmuss50", "createdAt": "2020-03-30T17:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1MDI2Nw=="}], "type": "inlineReview"}, {"oid": "42fd6e06314597009ef0e0c53b653806585b0f58", "url": "https://github.com/FabricMC/fabric-loader/commit/42fd6e06314597009ef0e0c53b653806585b0f58", "message": "fix package name.", "committedDate": "2020-03-30T17:09:51Z", "type": "commit"}, {"oid": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e", "url": "https://github.com/FabricMC/fabric-loader/commit/ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e", "message": "Pass FabricLoader instance via a constructor", "committedDate": "2020-03-30T17:16:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQxMjQ1Mg==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403412452", "bodyText": "Maye something indicating nullability (not required, this is internal impl)", "author": "liach", "createdAt": "2020-04-04T02:34:29Z", "path": "src/main/java/net/fabricmc/loader/metadata/LoaderModMetadata.java", "diffHunk": "@@ -36,6 +36,7 @@ default String getOldStyleLanguageAdapter() {\n \tMap<String, String> getLanguageAdapterDefinitions();\n \tCollection<NestedJarEntry> getJars();\n \tCollection<String> getMixinConfigs(EnvType type);\n+\tString getAccessWidener();", "originalCommit": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQxMjU1NQ==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403412555", "bodyText": "Can we just do dynamic namespace remapping instead, which the mapping parser already allows? We cannot always assume that we run in intermediary.", "author": "liach", "createdAt": "2020-04-04T02:35:53Z", "path": "src/main/java/net/fabricmc/loader/transformer/accesswidener/AccessWidener.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accesswidener;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.IntUnaryOperator;\n+\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.loader.FabricLoader;\n+import net.fabricmc.loader.api.ModContainer;\n+import net.fabricmc.loader.metadata.LoaderModMetadata;\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidener {\n+\tpublic String namespace;\n+\tpublic Map<String, Access> classAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> methodAccess = new HashMap<>();\n+\tpublic Map<EntryTriple, Access> fieldAccess = new HashMap<>();\n+\tprivate Set<String> classes = new LinkedHashSet<>();\n+\n+\tprivate final FabricLoader fabricLoader;\n+\n+\tpublic AccessWidener(FabricLoader fabricLoader) {\n+\t\tthis.fabricLoader = fabricLoader;\n+\t}\n+\n+\tpublic void loadFromMods() {\n+\t\tfor (ModContainer modContainer : fabricLoader.getAllMods()) {\n+\t\t\tLoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();\n+\t\t\tString accessWidener = modMetadata.getAccessWidener();\n+\n+\t\t\tif (accessWidener != null) {\n+\t\t\t\tPath path = modContainer.getPath(accessWidener);\n+\n+\t\t\t\ttry (BufferedReader reader = Files.newBufferedReader(path)) {\n+\t\t\t\t\tread(reader, fabricLoader.getMappingResolver().getCurrentRuntimeNamespace());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tthrow new RuntimeException(\"Failed to read accessWidener file from mod \" + modMetadata.getId(), e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void read(BufferedReader reader, String currentNamespace) throws IOException {\n+\t\tString[] header = reader.readLine().split(\"\\\\s+\");\n+\n+\t\tif (header.length != 3 || !header[0].equals(\"accessWidener\")) {\n+\t\t\tthrow new UnsupportedOperationException(\"Invalid access access widener file\");\n+\t\t}\n+\n+\t\tif (!header[1].equals(\"v1\")) {\n+\t\t\tthrow new RuntimeException(String.format(\"Unsupported access widener format (%s)\", header[1]));\n+\t\t}\n+\n+\t\tif (!header[2].equals(currentNamespace)) {", "originalCommit": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ3NjM2Mw==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403476363", "bodyText": "The namespace matches the same as the mod's classes. When we do runtime remapping of mods then this can be done.\nI dont see a reason for it now.", "author": "modmuss50", "createdAt": "2020-04-04T14:28:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQxMjU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQxMjYwOA==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403412608", "bodyText": "Remember to bump this to 8 later", "author": "liach", "createdAt": "2020-04-04T02:36:44Z", "path": "src/main/java/net/fabricmc/loader/transformer/accesswidener/AccessWidenerVisitor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2016 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.loader.transformer.accesswidener;\n+\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.FieldVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+import net.fabricmc.mappings.EntryTriple;\n+\n+public class AccessWidenerVisitor extends ClassVisitor {\n+\tprivate final AccessWidener accessWidener;\n+\n+\tprivate String className;\n+\n+\tpublic AccessWidenerVisitor(int api, ClassVisitor classVisitor, AccessWidener accessWidener) {\n+\t\tsuper(api, classVisitor);\n+\t\tthis.accessWidener = accessWidener;\n+\t}\n+\n+\t@Override\n+\tpublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+\t\tclassName = name;\n+\t\tsuper.visit(\n+\t\t\t\tversion,\n+\t\t\t\taccessWidener.getClassAccess(name).applyAsInt(access),\n+\t\t\t\tname,\n+\t\t\t\tsignature,\n+\t\t\t\tsuperName,\n+\t\t\t\tinterfaces\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic void visitInnerClass(String name, String outerName, String innerName, int access) {\n+\t\tsuper.visitInnerClass(\n+\t\t\t\tname,\n+\t\t\t\touterName,\n+\t\t\t\tinnerName,\n+\t\t\t\taccessWidener.getClassAccess(name).applyAsInt(access)\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n+\t\treturn super.visitField(\n+\t\t\t\taccessWidener.getFieldAccess(new EntryTriple(className, name, descriptor)).applyAsInt(access),\n+\t\t\t\tname,\n+\t\t\t\tdescriptor,\n+\t\t\t\tsignature,\n+\t\t\t\tvalue\n+\t\t);\n+\t}\n+\n+\t@Override\n+\tpublic MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n+\t\treturn new AccessWidenerMethodVisitor(super.visitMethod(\n+\t\t\t\taccessWidener.getMethodAccess(new EntryTriple(className, name, descriptor)).applyAsInt(access),\n+\t\t\t\tname,\n+\t\t\t\tdescriptor,\n+\t\t\t\tsignature,\n+\t\t\t\texceptions\n+\t\t));\n+\t}\n+\n+\tprivate class AccessWidenerMethodVisitor extends MethodVisitor {\n+\t\tAccessWidenerMethodVisitor(MethodVisitor methodVisitor) {\n+\t\t\tsuper(Opcodes.ASM7, methodVisitor);", "originalCommit": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3541df137dbc0fff51c73337526081dc5d10a989", "url": "https://github.com/FabricMC/fabric-loader/commit/3541df137dbc0fff51c73337526081dc5d10a989", "message": "Merge remote-tracking branch 'remotes/upstream/master' into access", "committedDate": "2020-04-04T14:03:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ3NjI1Ng==", "url": "https://github.com/FabricMC/fabric-loader/pull/206#discussion_r403476256", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tvisitor = new AccessWidenerVisitor(Opcodes.ASM7, visitor, FabricLoader.INSTANCE.getAccessWidener());\n          \n          \n            \n            \t\t\tvisitor = new AccessWidenerVisitor(Opcodes.ASM8, visitor, FabricLoader.INSTANCE.getAccessWidener());\n          \n      \n    \n    \n  \n\nThis will need doing when the ASM8 PR is merged.", "author": "modmuss50", "createdAt": "2020-04-04T14:27:52Z", "path": "src/main/java/net/fabricmc/loader/transformer/FabricTransformer.java", "diffHunk": "@@ -56,6 +59,11 @@\n \t\tClassVisitor visitor = classWriter;\n \t\tint visitorCount = 0;\n \n+\t\tif (applyAccessWidener) {\n+\t\t\tvisitor = new AccessWidenerVisitor(Opcodes.ASM7, visitor, FabricLoader.INSTANCE.getAccessWidener());", "originalCommit": "ef5148d9b9b19fbafdfbb0e2068354cbd5cd139e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0fe9b4c0e7aae1b6ce0aba88d6dbe148dc1dd617", "url": "https://github.com/FabricMC/fabric-loader/commit/0fe9b4c0e7aae1b6ce0aba88d6dbe148dc1dd617", "message": "Merge remote-tracking branch 'remotes/upstream/master' into access", "committedDate": "2020-04-06T14:31:20Z", "type": "commit"}, {"oid": "03b8e685cab0faca1bdb237ae9322e6dc9e19552", "url": "https://github.com/FabricMC/fabric-loader/commit/03b8e685cab0faca1bdb237ae9322e6dc9e19552", "message": "Update AccessWidenerVisitor to use ASM8", "committedDate": "2020-04-06T14:32:23Z", "type": "commit"}]}